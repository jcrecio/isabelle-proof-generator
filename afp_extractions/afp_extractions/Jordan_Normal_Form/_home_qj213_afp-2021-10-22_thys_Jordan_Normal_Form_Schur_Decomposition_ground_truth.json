{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Schur_Decomposition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma vec_inv_closed[simp]: \"v \\<in> carrier_vec n \\<Longrightarrow> vec_inv v \\<in> carrier_vec n\"", "lemma vec_inv_dim[simp]: \"dim_vec (vec_inv v) = dim_vec v\"", "lemma vec_inv[simp]:\n  assumes v: \"v : carrier_vec n\"\n      and v0: \"(v::'a::conjugatable_ordered_field vec) \\<noteq> 0\\<^sub>v n\"\n  shows \"vec_inv v \\<bullet> v = 1\"", "lemma corthogonal_inv:\n  assumes orth: \"corthogonal (vs ::'a::conjugatable_field vec list)\"\n      and V: \"set vs \\<subseteq> carrier_vec n\"\n  shows \"inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)\"\n    (is \"inverts_mat ?W ?V\")", "lemma corthogonal_matD[elim]:\n  assumes orth: \"corthogonal_mat A\"\n      and i: \"i < dim_col A\"\n      and j: \"j < dim_col A\"\n  shows \"(col A i \\<bullet>c col A j = 0) = (i \\<noteq> j)\"", "lemma corthogonal_matI[intro]:\n  assumes \"(\\<And>i j. i < dim_col A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> (col A i \\<bullet>c col A j = 0) = (i \\<noteq> j))\"\n  shows \"corthogonal_mat A\"", "lemma corthogonal_inv_result:\n  assumes o: \"corthogonal_mat (A::'a::conjugatable_field mat)\"\n  shows \"inverts_mat (corthogonal_inv A) A\"", "lemma (in vec_space) basis_completion: fixes v :: \"'a :: field vec\"\n  assumes v: \"v \\<in> carrier_vec n\"\n      and v0: \"v \\<noteq> 0\\<^sub>v n\"\n  shows \n    \"basis (set (basis_completion v))\"\n    \"set (basis_completion v) \\<subseteq> carrier_vec n\"\n    \"span (set (basis_completion v)) = carrier_vec n\" \n    \"distinct (basis_completion v)\"\n    \"\\<not> lin_dep (set (basis_completion v))\"\n    \"length (basis_completion v) = n\"\n    \"hd (basis_completion v) = v\"", "lemma orthogonal_mat_of_cols:\n  assumes W: \"set ws \\<subseteq> carrier_vec n\"\n    and orth: \"corthogonal ws\"\n    and len: \"length ws = n\"\n  shows \"corthogonal_mat (mat_of_cols n ws)\" (is \"corthogonal_mat ?W\")", "lemma corthogonal_col_ev_0: fixes A :: \"'a :: conjugatable_ordered_field mat\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n  and v: \"v \\<in> carrier_vec n\"\n  and v0: \"v \\<noteq> 0\\<^sub>v n\"\n  and eigen[simp]: \"A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\"\n  and n: \"n \\<noteq> 0\"\n  and hdws: \"hd ws = v\"\n  and ws: \"set ws \\<subseteq> carrier_vec n\" \"corthogonal ws\" \"length ws = n\"\n  defines \"W == mat_of_cols n ws\"\n  defines \"W' == corthogonal_inv W\"\n  defines \"A' == W' * A * W\"\n  shows \"col A' 0 = vec n (\\<lambda> i. if i = 0 then e else 0)\"", "theorem schur_decomposition:\n  assumes A: \"(A::'a::conjugatable_ordered_field mat) \\<in> carrier_mat n n\"\n      and c: \"char_poly A = (\\<Prod> (e :: 'a) \\<leftarrow> es. [:- e, 1:])\"\n      and B: \"schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = es\"", "lemma schur_upper_triangular:\n  assumes A: \"(A :: 'a :: conjugatable_ordered_field mat) \\<in> carrier_mat n n\"\n  and linear: \"char_poly A = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  defines B: \"B \\<equiv> schur_upper_triangular A es\"\n  shows \"B \\<in> carrier_mat n n\" \"upper_triangular B\" \"similar_mat A B\"", "lemma schur_decomposition_exists: assumes A: \"A \\<in> carrier_mat n n\"\n  and linear: \"char_poly A = (\\<Prod> (a :: 'a :: conjugatable_ordered_field) \\<leftarrow> es. [:- a, 1:])\"\n  shows \"\\<exists> B \\<in> carrier_mat n n. upper_triangular B \\<and> similar_mat A B\"", "lemma char_poly_0_block: fixes A :: \"'a :: conjugatable_ordered_field mat\"\n  assumes A: \"A = four_block_mat B C (0\\<^sub>m m n) D\"\n  and linearB: \"\\<exists> es. char_poly B = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and linearD: \"\\<exists> es. char_poly D = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and C: \"C \\<in> carrier_mat n m\"\n  and D: \"D \\<in> carrier_mat m m\"\n  shows \"char_poly A = char_poly B * char_poly D\"", "lemma char_poly_0_block': fixes A :: \"'a :: conjugatable_ordered_field mat\"\n  assumes A: \"A = four_block_mat B (0\\<^sub>m n m) C D\"\n  and linearB: \"\\<exists> es. char_poly B = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and linearD: \"\\<exists> es. char_poly D = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and C: \"C \\<in> carrier_mat m n\"\n  and D: \"D \\<in> carrier_mat m m\"\n  shows \"char_poly A = char_poly B * char_poly D\""], "translations": [["", "lemma vec_inv_closed[simp]: \"v \\<in> carrier_vec n \\<Longrightarrow> vec_inv v \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n \\<Longrightarrow> vec_inv v \\<in> carrier_vec n", "unfolding vec_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n \\<Longrightarrow>\n    (1::'a) / (v \\<bullet>c v) \\<cdot>\\<^sub>v conjugate v\n    \\<in> carrier_vec n", "by auto"], ["", "lemma vec_inv_dim[simp]: \"dim_vec (vec_inv v) = dim_vec v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_inv v) = dim_vec v", "unfolding vec_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ((1::'a) / (v \\<bullet>c v) \\<cdot>\\<^sub>v conjugate v) =\n    dim_vec v", "by auto"], ["", "lemma vec_inv[simp]:\n  assumes v: \"v : carrier_vec n\"\n      and v0: \"(v::'a::conjugatable_ordered_field vec) \\<noteq> 0\\<^sub>v n\"\n  shows \"vec_inv v \\<bullet> v = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "assume \"v \\<bullet>c v = 0\""], ["proof (state)\nthis:\n  v \\<bullet>c v = (0::'a)\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "hence \"v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<bullet>c v = (0::'a)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v n", "using conjugate_square_eq_0_vec[OF v]"], ["proof (prove)\nusing this:\n  v \\<bullet>c v = (0::'a)\n  (v \\<bullet>c v = (0::'a)) = (v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "hence False"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "using v0"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "}"], ["proof (state)\nthis:\n  v \\<bullet>c v = (0::'a) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "moreover"], ["proof (state)\nthis:\n  v \\<bullet>c v = (0::'a) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "have \"conjugate v \\<bullet> v = v \\<bullet>c v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate v \\<bullet> v = v \\<bullet>c v", "apply (rule comm_scalar_prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. conjugate v \\<in> carrier_vec ?n\n 2. v \\<in> carrier_vec ?n", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. conjugate v \\<in> carrier_vec ?n\n 2. v \\<in> carrier_vec ?n", "by auto"], ["proof (state)\nthis:\n  conjugate v \\<bullet> v = v \\<bullet>c v\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<bullet>c v = (0::'a) \\<Longrightarrow> False\n  conjugate v \\<bullet> v = v \\<bullet>c v", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<bullet>c v = (0::'a) \\<Longrightarrow> False\n  conjugate v \\<bullet> v = v \\<bullet>c v\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> v = (1::'a)", "unfolding vec_inv_def"], ["proof (prove)\nusing this:\n  v \\<bullet>c v = (0::'a) \\<Longrightarrow> False\n  conjugate v \\<bullet> v = v \\<bullet>c v\n\ngoal (1 subgoal):\n 1. ((1::'a) / (v \\<bullet>c v) \\<cdot>\\<^sub>v conjugate v) \\<bullet> v =\n    (1::'a)", "apply (subst smult_scalar_prod_distrib)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<bullet>c v = (0::'a) \\<Longrightarrow> False;\n     conjugate v \\<bullet> v = v \\<bullet>c v\\<rbrakk>\n    \\<Longrightarrow> conjugate v \\<in> carrier_vec ?n2\n 2. \\<lbrakk>v \\<bullet>c v = (0::'a) \\<Longrightarrow> False;\n     conjugate v \\<bullet> v = v \\<bullet>c v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> carrier_vec ?n2\n 3. \\<lbrakk>v \\<bullet>c v = (0::'a) \\<Longrightarrow> False;\n     conjugate v \\<bullet> v = v \\<bullet>c v\\<rbrakk>\n    \\<Longrightarrow> (1::'a) / (v \\<bullet>c v) *\n                      (conjugate v \\<bullet> v) =\n                      (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<bullet>c v = (0::'a) \\<Longrightarrow> False;\n     conjugate v \\<bullet> v = v \\<bullet>c v\\<rbrakk>\n    \\<Longrightarrow> conjugate v \\<in> carrier_vec ?n2\n 2. \\<lbrakk>v \\<bullet>c v = (0::'a) \\<Longrightarrow> False;\n     conjugate v \\<bullet> v = v \\<bullet>c v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> carrier_vec ?n2\n 3. \\<lbrakk>v \\<bullet>c v = (0::'a) \\<Longrightarrow> False;\n     conjugate v \\<bullet> v = v \\<bullet>c v\\<rbrakk>\n    \\<Longrightarrow> (1::'a) / (v \\<bullet>c v) *\n                      (conjugate v \\<bullet> v) =\n                      (1::'a)", "by auto"], ["proof (state)\nthis:\n  vec_inv v \\<bullet> v = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma corthogonal_inv:\n  assumes orth: \"corthogonal (vs ::'a::conjugatable_field vec list)\"\n      and V: \"set vs \\<subseteq> carrier_vec n\"\n  shows \"inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)\"\n    (is \"inverts_mat ?W ?V\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)", "define l where \"l = length vs\""], ["proof (state)\nthis:\n  l = length vs\n\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)", "have rW[simp]: \"dim_row ?W = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_of_rows n (map vec_inv vs)) = l", "using l_def"], ["proof (prove)\nusing this:\n  l = length vs\n\ngoal (1 subgoal):\n 1. dim_row (mat_of_rows n (map vec_inv vs)) = l", "by auto"], ["proof (state)\nthis:\n  dim_row (mat_of_rows n (map vec_inv vs)) = l\n\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)", "have cV[simp]:\"dim_col ?V = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (mat_of_cols n vs) = l", "using l_def"], ["proof (prove)\nusing this:\n  l = length vs\n\ngoal (1 subgoal):\n 1. dim_col (mat_of_cols n vs) = l", "by auto"], ["proof (state)\nthis:\n  dim_col (mat_of_cols n vs) = l\n\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)", "have dim: \"\\<And>i. i < length vs \\<Longrightarrow> vs!i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length vs \\<Longrightarrow> vs ! i \\<in> carrier_vec n", "using V"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length vs \\<Longrightarrow> vs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i < length vs \\<Longrightarrow> vs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)", "unfolding inverts_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map vec_inv vs) * mat_of_cols n vs =\n    1\\<^sub>m (dim_row (mat_of_rows n (map vec_inv vs)))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (1\\<^sub>m (dim_row (mat_of_rows n (map vec_inv vs))));\n        j < dim_col\n             (1\\<^sub>m (dim_row (mat_of_rows n (map vec_inv vs))))\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         1\\<^sub>m\n                          (dim_row (mat_of_rows n (map vec_inv vs))) $$\n                         (i, j)\n 2. dim_row (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) =\n    dim_row (1\\<^sub>m (dim_row (mat_of_rows n (map vec_inv vs))))\n 3. dim_col (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) =\n    dim_col (1\\<^sub>m (dim_row (mat_of_rows n (map vec_inv vs))))", "unfolding mat_of_rows_carrier length_map l_def[symmetric]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m l);\n        j < dim_col (1\\<^sub>m l)\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         1\\<^sub>m l $$ (i, j)\n 2. dim_row (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) =\n    dim_row (1\\<^sub>m l)\n 3. dim_col (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) =\n    dim_col (1\\<^sub>m l)", "unfolding index_one_mat"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < l; j < l\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         (if i = j then 1::'a else (0::'a))\n 2. dim_row (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l\n 3. dim_col (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < l; j < l\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         (if i = j then 1::'a else (0::'a))\n 2. dim_row (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l\n 3. dim_col (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l", "show \"dim_row (?W * ?V) = l\" \"dim_col (?W * ?V) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l &&&\n    dim_col (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l", "unfolding times_mat_def rW cV"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat l l\n       (\\<lambda>(i, j).\n           row (mat_of_rows n (map vec_inv vs)) i \\<bullet>\n           col (mat_of_cols n vs) j)) =\n    l &&&\n    dim_col\n     (mat l l\n       (\\<lambda>(i, j).\n           row (mat_of_rows n (map vec_inv vs)) i \\<bullet>\n           col (mat_of_cols n vs) j)) =\n    l", "by auto"], ["proof (state)\nthis:\n  dim_row (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l\n  dim_col (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) = l\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < l; j < l\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         (if i = j then 1::'a else (0::'a))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < l; j < l\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         (if i = j then 1::'a else (0::'a))", "assume i:\"i<l\" and j: \"j<l\""], ["proof (state)\nthis:\n  i < l\n  j < l\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < l; j < l\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         (if i = j then 1::'a else (0::'a))", "hence i2: \"i<length vs\"\n      and i3: \"i<length (map vec_inv vs)\"\n      and j2: \"j<length vs\""], ["proof (prove)\nusing this:\n  i < l\n  j < l\n\ngoal (1 subgoal):\n 1. i < length vs &&& i < length (map vec_inv vs) &&& j < length vs", "using l_def"], ["proof (prove)\nusing this:\n  i < l\n  j < l\n  l = length vs\n\ngoal (1 subgoal):\n 1. i < length vs &&& i < length (map vec_inv vs) &&& j < length vs", "by auto"], ["proof (state)\nthis:\n  i < length vs\n  i < length (map vec_inv vs)\n  j < length vs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < l; j < l\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         (if i = j then 1::'a else (0::'a))", "hence id2: \"vs ! i \\<in> carrier_vec n\"\n      and id3: \"map vec_inv vs ! i \\<in> carrier_vec n\"\n      and id4: \"conjugate (vs ! i) \\<in> carrier_vec n\"\n      and jd2: \"vs ! j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  i < length vs\n  i < length (map vec_inv vs)\n  j < length vs\n\ngoal (1 subgoal):\n 1. (vs ! i \\<in> carrier_vec n &&&\n     map vec_inv vs ! i \\<in> carrier_vec n) &&&\n    conjugate (vs ! i) \\<in> carrier_vec n &&& vs ! j \\<in> carrier_vec n", "using dim"], ["proof (prove)\nusing this:\n  i < length vs\n  i < length (map vec_inv vs)\n  j < length vs\n  ?i < length vs \\<Longrightarrow> vs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (vs ! i \\<in> carrier_vec n &&&\n     map vec_inv vs ! i \\<in> carrier_vec n) &&&\n    conjugate (vs ! i) \\<in> carrier_vec n &&& vs ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  vs ! i \\<in> carrier_vec n\n  map vec_inv vs ! i \\<in> carrier_vec n\n  conjugate (vs ! i) \\<in> carrier_vec n\n  vs ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < l; j < l\\<rbrakk>\n       \\<Longrightarrow> (mat_of_rows n (map vec_inv vs) *\n                          mat_of_cols n vs) $$\n                         (i, j) =\n                         (if i = j then 1::'a else (0::'a))", "show \"(?W * ?V) $$ (i,j) = (if i = j then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) $$ (i, j) =\n    (if i = j then 1::'a else (0::'a))", "unfolding times_mat_def rW cV"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat l l\n     (\\<lambda>(i, j).\n         row (mat_of_rows n (map vec_inv vs)) i \\<bullet>\n         col (mat_of_cols n vs) j) $$\n    (i, j) =\n    (if i = j then 1::'a else (0::'a))", "unfolding index_mat[OF i j] split"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows n (map vec_inv vs)) i \\<bullet>\n    col (mat_of_cols n vs) j =\n    (if i = j then 1::'a else (0::'a))", "unfolding mat_of_rows_row[OF i3 id3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map vec_inv vs ! i \\<bullet> col (mat_of_cols n vs) j =\n    (if i = j then 1::'a else (0::'a))", "unfolding col_mat_of_cols[OF j2 jd2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map vec_inv vs ! i \\<bullet> vs ! j = (if i = j then 1::'a else (0::'a))", "unfolding nth_map[OF i2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_inv (vs ! i) \\<bullet> vs ! j = (if i = j then 1::'a else (0::'a))", "unfolding vec_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) / (vs ! i \\<bullet>c vs ! i) \\<cdot>\\<^sub>v\n     conjugate (vs ! i)) \\<bullet>\n    vs ! j =\n    (if i = j then 1::'a else (0::'a))", "unfolding smult_scalar_prod_distrib[OF id4 jd2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / (vs ! i \\<bullet>c vs ! i) *\n    (conjugate (vs ! i) \\<bullet> vs ! j) =\n    (if i = j then 1::'a else (0::'a))", "unfolding comm_scalar_prod[OF id4 jd2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / (vs ! i \\<bullet>c vs ! i) * (vs ! j \\<bullet>c vs ! i) =\n    (if i = j then 1::'a else (0::'a))", "using corthogonalD[OF orth j2 i2]"], ["proof (prove)\nusing this:\n  (vs ! j \\<bullet>c vs ! i = (0::'a)) = (j \\<noteq> i)\n\ngoal (1 subgoal):\n 1. (1::'a) / (vs ! i \\<bullet>c vs ! i) * (vs ! j \\<bullet>c vs ! i) =\n    (if i = j then 1::'a else (0::'a))", "by auto"], ["proof (state)\nthis:\n  (mat_of_rows n (map vec_inv vs) * mat_of_cols n vs) $$ (i, j) =\n  (if i = j then 1::'a else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inverts_mat (mat_of_rows n (map vec_inv vs)) (mat_of_cols n vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition corthogonal_inv :: \"'a::conjugatable_field mat \\<Rightarrow> 'a mat\"\n  where \"corthogonal_inv A = mat_of_rows (dim_row A) (map vec_inv (cols A))\""], ["", "definition mat_adjoint :: \"'a :: conjugatable_field mat \\<Rightarrow> 'a mat\"\n  where \"mat_adjoint A \\<equiv> mat_of_rows (dim_row A) (map conjugate (cols A))\""], ["", "definition corthogonal_mat :: \"'a::conjugatable_field mat \\<Rightarrow> bool\"\n  where \"corthogonal_mat A \\<equiv>\n    let B = mat_adjoint A * A in\n    diagonal_mat B \\<and> (\\<forall>i<dim_col A. B $$ (i,i) \\<noteq> 0)\""], ["", "lemma corthogonal_matD[elim]:\n  assumes orth: \"corthogonal_mat A\"\n      and i: \"i < dim_col A\"\n      and j: \"j < dim_col A\"\n  shows \"(col A i \\<bullet>c col A j = 0) = (i \\<noteq> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (col A i \\<bullet>c col A j = (0::'a)) = (i \\<noteq> j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "have ci: \"col A i : carrier_vec (dim_row A)\"\n   and cj: \"col A j : carrier_vec (dim_row A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A i \\<in> carrier_vec (dim_row A) &&&\n    col A j \\<in> carrier_vec (dim_row A)", "by auto"], ["proof (state)\nthis:\n  col A i \\<in> carrier_vec (dim_row A)\n  col A j \\<in> carrier_vec (dim_row A)\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "note [simp] = conjugate_conjugate_sprod[OF ci cj]"], ["proof (state)\nthis:\n  conjugate (conjugate (col A i) \\<bullet> col A j) =\n  col A i \\<bullet>c col A j\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "let ?B = \"mat_adjoint A * A\""], ["proof (state)\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "have diag: \"diagonal_mat ?B\" and zero: \"\\<And>i. i<dim_col A \\<Longrightarrow> ?B $$ (i,i) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_mat (mat_adjoint A * A) &&&\n    (\\<And>i.\n        i < dim_col A \\<Longrightarrow>\n        (mat_adjoint A * A) $$ (i, i) \\<noteq> (0::'a))", "using orth"], ["proof (prove)\nusing this:\n  corthogonal_mat A\n\ngoal (1 subgoal):\n 1. diagonal_mat (mat_adjoint A * A) &&&\n    (\\<And>i.\n        i < dim_col A \\<Longrightarrow>\n        (mat_adjoint A * A) $$ (i, i) \\<noteq> (0::'a))", "unfolding corthogonal_mat_def Let_def"], ["proof (prove)\nusing this:\n  diagonal_mat (mat_adjoint A * A) \\<and>\n  (\\<forall>i<dim_col A. (mat_adjoint A * A) $$ (i, i) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. diagonal_mat (mat_adjoint A * A) &&&\n    (\\<And>i.\n        i < dim_col A \\<Longrightarrow>\n        (mat_adjoint A * A) $$ (i, i) \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  diagonal_mat (mat_adjoint A * A)\n  ?i < dim_col A \\<Longrightarrow>\n  (mat_adjoint A * A) $$ (?i, ?i) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "{"], ["proof (state)\nthis:\n  diagonal_mat (mat_adjoint A * A)\n  ?i < dim_col A \\<Longrightarrow>\n  (mat_adjoint A * A) $$ (?i, ?i) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "hence \"conjugate (col A i) \\<bullet> col A j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)", "using zero[OF i]"], ["proof (prove)\nusing this:\n  i = j\n  (mat_adjoint A * A) $$ (i, i) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)", "unfolding mat_adjoint_def"], ["proof (prove)\nusing this:\n  i = j\n  (mat_of_rows (dim_row A) (map conjugate (cols A)) * A) $$ (i, i) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)", "using i"], ["proof (prove)\nusing this:\n  i = j\n  (mat_of_rows (dim_row A) (map conjugate (cols A)) * A) $$ (i, i) \\<noteq>\n  (0::'a)\n  i < dim_col A\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "hence \"conjugate (conjugate (col A i) \\<bullet> col A j) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. conjugate (conjugate (col A i) \\<bullet> col A j) \\<noteq> (0::'a)", "unfolding conjugate_zero_iff"], ["proof (prove)\nusing this:\n  conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  conjugate (conjugate (col A i) \\<bullet> col A j) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "hence \"col A i \\<bullet>c col A j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  conjugate (conjugate (col A i) \\<bullet> col A j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. col A i \\<bullet>c col A j \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  col A i \\<bullet>c col A j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "}"], ["proof (state)\nthis:\n  i = j \\<Longrightarrow> col A i \\<bullet>c col A j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n 2. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "thus \"col A i \\<bullet>c col A j = 0 \\<Longrightarrow> i \\<noteq> j\""], ["proof (prove)\nusing this:\n  i = j \\<Longrightarrow> col A i \\<bullet>c col A j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "{"], ["proof (state)\nthis:\n  col A i \\<bullet>c col A j = (0::'a) \\<Longrightarrow> i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "hence \"conjugate (col A i) \\<bullet> col A j = 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j = (0::'a)", "using diag"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  diagonal_mat (mat_adjoint A * A)\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j = (0::'a)", "unfolding diagonal_mat_def"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  \\<forall>i<dim_row (mat_adjoint A * A).\n     \\<forall>j<dim_col (mat_adjoint A * A).\n        i \\<noteq> j \\<longrightarrow>\n        (mat_adjoint A * A) $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j = (0::'a)", "unfolding mat_adjoint_def"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  \\<forall>i<dim_row (mat_of_rows (dim_row A) (map conjugate (cols A)) * A).\n     \\<forall>j<dim_col\n                 (mat_of_rows (dim_row A) (map conjugate (cols A)) * A).\n        i \\<noteq> j \\<longrightarrow>\n        (mat_of_rows (dim_row A) (map conjugate (cols A)) * A) $$ (i, j) =\n        (0::'a)\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j = (0::'a)", "using i j"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  \\<forall>i<dim_row (mat_of_rows (dim_row A) (map conjugate (cols A)) * A).\n     \\<forall>j<dim_col\n                 (mat_of_rows (dim_row A) (map conjugate (cols A)) * A).\n        i \\<noteq> j \\<longrightarrow>\n        (mat_of_rows (dim_row A) (map conjugate (cols A)) * A) $$ (i, j) =\n        (0::'a)\n  i < dim_col A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  conjugate (col A i) \\<bullet> col A j = (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "hence \"conjugate (conjugate (col A i) \\<bullet> col A j) = 0\""], ["proof (prove)\nusing this:\n  conjugate (col A i) \\<bullet> col A j = (0::'a)\n\ngoal (1 subgoal):\n 1. conjugate (conjugate (col A i) \\<bullet> col A j) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  conjugate (conjugate (col A i) \\<bullet> col A j) = (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)", "thus \"col A i \\<bullet>c col A j = 0\""], ["proof (prove)\nusing this:\n  conjugate (conjugate (col A i) \\<bullet> col A j) = (0::'a)\n\ngoal (1 subgoal):\n 1. col A i \\<bullet>c col A j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  col A i \\<bullet>c col A j = (0::'a)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  i \\<noteq> j \\<Longrightarrow> col A i \\<bullet>c col A j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma corthogonal_matI[intro]:\n  assumes \"(\\<And>i j. i < dim_col A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> (col A i \\<bullet>c col A j = 0) = (i \\<noteq> j))\"\n  shows \"corthogonal_mat A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal_mat A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. corthogonal_mat A", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. corthogonal_mat A", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. corthogonal_mat A", "assume i: \"i < dim_col A\" and j: \"j < dim_col A\" and ij: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i < dim_col A\n  j < dim_col A\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "have \"conjugate (col A i) \\<bullet> col A j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A j = (0::'a)", "by (metis assms col_dim i j ij conjugate_vec_sprod_comm)"], ["proof (state)\nthis:\n  conjugate (col A i) \\<bullet> col A j = (0::'a)\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. corthogonal_mat A", "assume \"i < dim_col A\""], ["proof (state)\nthis:\n  i < dim_col A\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "hence \"conjugate (col A i) \\<bullet> col A i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i < dim_col A\n\ngoal (1 subgoal):\n 1. conjugate (col A i) \\<bullet> col A i \\<noteq> (0::'a)", "by (metis assms comm_scalar_prod carrier_vec_conjugate carrier_vecI)"], ["proof (state)\nthis:\n  conjugate (col A i) \\<bullet> col A i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "}"], ["proof (state)\nthis:\n  ?i2 < dim_col A \\<Longrightarrow>\n  conjugate (col A ?i2) \\<bullet> col A ?i2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n  ?i2 < dim_col A \\<Longrightarrow>\n  conjugate (col A ?i2) \\<bullet> col A ?i2 \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n  ?i2 < dim_col A \\<Longrightarrow>\n  conjugate (col A ?i2) \\<bullet> col A ?i2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. corthogonal_mat A", "unfolding corthogonal_mat_def Let_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n  ?i2 < dim_col A \\<Longrightarrow>\n  conjugate (col A ?i2) \\<bullet> col A ?i2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. diagonal_mat (mat_adjoint A * A) \\<and>\n    (\\<forall>i<dim_col A. (mat_adjoint A * A) $$ (i, i) \\<noteq> (0::'a))", "unfolding diagonal_mat_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n  ?i2 < dim_col A \\<Longrightarrow>\n  conjugate (col A ?i2) \\<bullet> col A ?i2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_row (mat_adjoint A * A).\n        \\<forall>j<dim_col (mat_adjoint A * A).\n           i \\<noteq> j \\<longrightarrow>\n           (mat_adjoint A * A) $$ (i, j) = (0::'a)) \\<and>\n    (\\<forall>i<dim_col A. (mat_adjoint A * A) $$ (i, i) \\<noteq> (0::'a))", "unfolding mat_adjoint_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < dim_col A; ?j2 < dim_col A; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> conjugate (col A ?i2) \\<bullet> col A ?j2 = (0::'a)\n  ?i2 < dim_col A \\<Longrightarrow>\n  conjugate (col A ?i2) \\<bullet> col A ?i2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_row\n                 (mat_of_rows (dim_row A) (map conjugate (cols A)) * A).\n        \\<forall>j<dim_col\n                    (mat_of_rows (dim_row A) (map conjugate (cols A)) * A).\n           i \\<noteq> j \\<longrightarrow>\n           (mat_of_rows (dim_row A) (map conjugate (cols A)) * A) $$\n           (i, j) =\n           (0::'a)) \\<and>\n    (\\<forall>i<dim_col A.\n        (mat_of_rows (dim_row A) (map conjugate (cols A)) * A) $$\n        (i, i) \\<noteq>\n        (0::'a))", "by auto"], ["proof (state)\nthis:\n  corthogonal_mat A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma corthogonal_inv_result:\n  assumes o: \"corthogonal_mat (A::'a::conjugatable_field mat)\"\n  shows \"inverts_mat (corthogonal_inv A) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (corthogonal_inv A) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverts_mat (corthogonal_inv A) A", "have oc: \"corthogonal (cols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal (cols A)", "apply (intro corthogonalI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (cols A); j < length (cols A)\\<rbrakk>\n       \\<Longrightarrow> (cols A ! i \\<bullet>c cols A ! j = (0::'a)) =\n                         (i \\<noteq> j)", "using corthogonal_matD[OF o]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < dim_col A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> (col A ?i \\<bullet>c col A ?j = (0::'a)) =\n                    (?i \\<noteq> ?j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (cols A); j < length (cols A)\\<rbrakk>\n       \\<Longrightarrow> (cols A ! i \\<bullet>c cols A ! j = (0::'a)) =\n                         (i \\<noteq> j)", "by auto"], ["proof (state)\nthis:\n  corthogonal (cols A)\n\ngoal (1 subgoal):\n 1. inverts_mat (corthogonal_inv A) A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (corthogonal_inv A) A", "unfolding corthogonal_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows (dim_row A) (map vec_inv (cols A))) A", "using corthogonal_inv[OF oc cols_dim]"], ["proof (prove)\nusing this:\n  inverts_mat (mat_of_rows (dim_row A) (map vec_inv (cols A)))\n   (mat_of_cols (dim_row A) (cols A))\n\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows (dim_row A) (map vec_inv (cols A))) A", "by auto"], ["proof (state)\nthis:\n  inverts_mat (corthogonal_inv A) A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \"extends a vector to a basis\""], ["", "definition basis_completion :: \"'a::ring_1 vec \\<Rightarrow> 'a vec list\" where\n  \"basis_completion v \\<equiv> let \n     n = dim_vec v;\n     drop_index = hd ([ i . i <- [0..<n], v $ i \\<noteq> 0]);\n     vs = [unit_vec n i. i <- [0..<n], i \\<noteq> drop_index] \n   in v # vs\""], ["", "lemma (in vec_space) basis_completion: fixes v :: \"'a :: field vec\"\n  assumes v: \"v \\<in> carrier_vec n\"\n      and v0: \"v \\<noteq> 0\\<^sub>v n\"\n  shows \n    \"basis (set (basis_completion v))\"\n    \"set (basis_completion v) \\<subseteq> carrier_vec n\"\n    \"span (set (basis_completion v)) = carrier_vec n\" \n    \"distinct (basis_completion v)\"\n    \"\\<not> lin_dep (set (basis_completion v))\"\n    \"length (basis_completion v) = n\"\n    \"hd (basis_completion v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (basis (set (basis_completion v)) &&&\n     set (basis_completion v) \\<subseteq> carrier_vec n &&&\n     local.span (set (basis_completion v)) = carrier_vec n) &&&\n    (distinct (basis_completion v) &&&\n     lin_indpt (set (basis_completion v))) &&&\n    length (basis_completion v) = n &&& hd (basis_completion v) = v", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "let ?b = \"basis_completion v\""], ["proof (state)\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "note d = basis_completion_def Let_def"], ["proof (state)\nthis:\n  basis_completion ?v \\<equiv>\n  let n = dim_vec ?v;\n      drop_index =\n        hd (concat\n             (map (\\<lambda>i. if ?v $ i \\<noteq> (0::?'a) then [i] else [])\n               [0..<n]))\n  in Let (concat\n           (map (\\<lambda>i.\n                    if i \\<noteq> drop_index then [unit_vec n i] else [])\n             [0..<n]))\n      ((#) ?v)\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "from v"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n", "have dim: \"dim_vec v = n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec v = n", "by auto"], ["proof (state)\nthis:\n  dim_vec v = n\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "let ?is = \"[ i . i <- [0..<n], v $ i \\<noteq> 0]\""], ["proof (state)\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "{"], ["proof (state)\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "assume empty: \"set ?is = {}\""], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>i. if v $ i \\<noteq> (0::'a) then [i] else [])\n          [0..<n])) =\n  {}\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "have \"v = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v n", "by (rule eq_vecI, insert empty v, auto)"], ["proof (state)\nthis:\n  v = 0\\<^sub>v n\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "}"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>i. if v $ i \\<noteq> (0::'a) then [i] else [])\n          [0..<n])) =\n  {} \\<Longrightarrow>\n  v = 0\\<^sub>v n\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "with v0"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v n\n  set (concat\n        (map (\\<lambda>i. if v $ i \\<noteq> (0::'a) then [i] else [])\n          [0..<n])) =\n  {} \\<Longrightarrow>\n  v = 0\\<^sub>v n", "obtain k ids where id: \"?is = k # ids\" and mem: \"k \\<in> set ?is\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  set (concat\n        (map (\\<lambda>i. if v $ i \\<noteq> (0::'a) then [i] else [])\n          [0..<n])) =\n  {} \\<Longrightarrow>\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>k ids.\n        \\<lbrakk>concat\n                  (map (\\<lambda>i.\n                           if v $ i \\<noteq> (0::'a) then [i] else [])\n                    [0..<n]) =\n                 k # ids;\n         k \\<in> set (concat\n                       (map (\\<lambda>i.\n                                if v $ i \\<noteq> (0::'a) then [i] else [])\n                         [0..<n]))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ?is, auto)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i. if v $ i \\<noteq> (0::'a) then [i] else []) [0..<n]) =\n  k # ids\n  k \\<in> set (concat\n                (map (\\<lambda>i.\n                         if v $ i \\<noteq> (0::'a) then [i] else [])\n                  [0..<n]))\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "from mem"], ["proof (chain)\npicking this:\n  k \\<in> set (concat\n                (map (\\<lambda>i.\n                         if v $ i \\<noteq> (0::'a) then [i] else [])\n                  [0..<n]))", "have vk: \"v $ k \\<noteq> 0\" and k: \"k < n\""], ["proof (prove)\nusing this:\n  k \\<in> set (concat\n                (map (\\<lambda>i.\n                         if v $ i \\<noteq> (0::'a) then [i] else [])\n                  [0..<n]))\n\ngoal (1 subgoal):\n 1. v $ k \\<noteq> (0::'a) &&& k < n", "by auto"], ["proof (state)\nthis:\n  v $ k \\<noteq> (0::'a)\n  k < n\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "{"], ["proof (state)\nthis:\n  v $ k \\<noteq> (0::'a)\n  k < n\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "fix i"], ["proof (state)\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "assume i: \"\\<not> i < k\""], ["proof (state)\nthis:\n  \\<not> i < k\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "have id: \"k # [Suc k..<n] = [k ..< n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k # [Suc k..<n] = [k..<n]", "using k"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. k # [Suc k..<n] = [k..<n]", "by (simp add: upt_conv_Cons)"], ["proof (state)\nthis:\n  k # [Suc k..<n] = [k..<n]\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "from i"], ["proof (chain)\npicking this:\n  \\<not> i < k", "have \"i < n \\<Longrightarrow> (k # [Suc k..<n]) ! (i - k) = i\""], ["proof (prove)\nusing this:\n  \\<not> i < k\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> (k # [Suc k..<n]) ! (i - k) = i", "unfolding id"], ["proof (prove)\nusing this:\n  \\<not> i < k\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> [k..<n] ! (i - k) = i", "by (subst nth_upt, auto)"], ["proof (state)\nthis:\n  i < n \\<Longrightarrow> (k # [Suc k..<n]) ! (i - k) = i\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> ?i3 < k; ?i3 < n\\<rbrakk>\n  \\<Longrightarrow> (k # [Suc k..<n]) ! (?i3 - k) = ?i3\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "hence split: \"[0 ..< n] = [0 ..< k] @ k # [Suc k ..< n]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?i3 < k; ?i3 < n\\<rbrakk>\n  \\<Longrightarrow> (k # [Suc k..<n]) ! (?i3 - k) = ?i3\n\ngoal (1 subgoal):\n 1. [0..<n] = [0..<k] @ k # [Suc k..<n]", "by (intro nth_equalityI, insert k, auto simp: nth_append)"], ["proof (state)\nthis:\n  [0..<n] = [0..<k] @ k # [Suc k..<n]\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "{"], ["proof (state)\nthis:\n  [0..<n] = [0..<k] @ k # [Suc k..<n]\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "fix as"], ["proof (state)\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "assume \"k \\<notin> set as\""], ["proof (state)\nthis:\n  k \\<notin> set as\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "hence \"[unit_vec n i. i <- as, i \\<noteq> k] = [unit_vec n i. i <- as]\""], ["proof (prove)\nusing this:\n  k \\<notin> set as\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) as) =\n    map (unit_vec n) as", "by (induct as, auto)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) as) =\n  map (unit_vec n) as\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "}"], ["proof (state)\nthis:\n  k \\<notin> set ?as5 \\<Longrightarrow>\n  concat\n   (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) ?as5) =\n  map (unit_vec n) ?as5\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "note conv = this"], ["proof (state)\nthis:\n  k \\<notin> set ?as5 \\<Longrightarrow>\n  concat\n   (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) ?as5) =\n  map (unit_vec n) ?as5\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "have b_all: \"?b = v # [unit_vec n i. i <- [0..<n], i \\<noteq> k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_completion v =\n    v #\n    concat\n     (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) [0..<n])", "unfolding d dim id"], ["proof (prove)\ngoal (1 subgoal):\n 1. v #\n    concat\n     (map (\\<lambda>i.\n              if i \\<noteq> hd (k # ids) then [unit_vec n i] else [])\n       [0..<n]) =\n    v #\n    concat\n     (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) [0..<n])", "by simp"], ["proof (state)\nthis:\n  basis_completion v =\n  v #\n  concat\n   (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) [0..<n])\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "also"], ["proof (state)\nthis:\n  basis_completion v =\n  v #\n  concat\n   (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) [0..<n])\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "have \"[unit_vec n i. i <- [0..<n], i \\<noteq> k] = [unit_vec n i. i <- [0..<k]] @ [unit_vec n i. i <- [Suc k..<n]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else [])\n       [0..<n]) =\n    map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]", "unfolding split"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else [])\n       ([0..<k] @ k # [Suc k..<n])) =\n    map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]", "by (auto simp: conv)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) [0..<n]) =\n  map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "finally"], ["proof (chain)\npicking this:\n  basis_completion v =\n  v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]", "have b: \"?b = v # [unit_vec n i. i <- [0..<k]] @ [unit_vec n i. i <- [Suc k..<n]]\""], ["proof (prove)\nusing this:\n  basis_completion v =\n  v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]\n\ngoal (1 subgoal):\n 1. basis_completion v =\n    v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]", "by simp"], ["proof (state)\nthis:\n  basis_completion v =\n  v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]\n\ngoal (7 subgoals):\n 1. basis (set (basis_completion v))\n 2. set (basis_completion v) \\<subseteq> carrier_vec n\n 3. local.span (set (basis_completion v)) = carrier_vec n\n 4. distinct (basis_completion v)\n 5. lin_indpt (set (basis_completion v))\n 6. length (basis_completion v) = n\n 7. hd (basis_completion v) = v", "show carr: \"set ?b \\<subseteq> carrier_vec n\" (is \"?S \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (basis_completion v) \\<subseteq> carrier_vec n", "unfolding b"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n])\n    \\<subseteq> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. set (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (basis_completion v) \\<subseteq> carrier_vec n\n\ngoal (6 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))\n 5. length (basis_completion v) = n\n 6. hd (basis_completion v) = v", "show \"hd ?b = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (basis_completion v) = v", "unfolding b"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) = v", "by auto"], ["proof (state)\nthis:\n  hd (basis_completion v) = v\n\ngoal (5 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))\n 5. length (basis_completion v) = n", "show len: \"length (basis_completion v) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (basis_completion v) = n", "unfolding b"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) = n", "using k"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. length (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) = n", "by auto"], ["proof (state)\nthis:\n  length (basis_completion v) = n\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "define I where \"I = (\\<lambda> i. if i < k then i else Suc i)\""], ["proof (state)\nthis:\n  I = (\\<lambda>i. if i < k then i else Suc i)\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "have I: \"\\<And> i. I i \\<noteq> k\" \"\\<And> i. Suc i < n \\<Longrightarrow> I i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. I i \\<noteq> k) &&&\n    (\\<And>i. Suc i < n \\<Longrightarrow> I i < n)", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. (if i < k then i else Suc i) \\<noteq> k) &&&\n    (\\<And>i. Suc i < n \\<Longrightarrow> (if i < k then i else Suc i) < n)", "by auto"], ["proof (state)\nthis:\n  I ?i2 \\<noteq> k\n  Suc ?i2 < n \\<Longrightarrow> I ?i2 < n\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "{"], ["proof (state)\nthis:\n  I ?i2 \\<noteq> k\n  Suc ?i2 < n \\<Longrightarrow> I ?i2 < n\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "fix i"], ["proof (state)\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "have \"?b ! i = (if i = 0 then v else unit_vec n (I (i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_completion v ! i = (if i = 0 then v else unit_vec n (I (i - 1)))", "unfolding b I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) ! i =\n    (if i = 0 then v\n     else unit_vec n (if i - 1 < k then i - 1 else Suc (i - 1)))", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) ! i =\n    (if i = 0 then v\n     else unit_vec n (if i - 1 < k then i - 1 else Suc (i - 1)))", "by (auto split: if_splits simp: nth_append)"], ["proof (state)\nthis:\n  basis_completion v ! i = (if i = 0 then v else unit_vec n (I (i - 1)))\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "}"], ["proof (state)\nthis:\n  ?i4 < n \\<Longrightarrow>\n  basis_completion v ! ?i4 =\n  (if ?i4 = 0 then v else unit_vec n (I (?i4 - 1)))\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "note bi = this"], ["proof (state)\nthis:\n  ?i4 < n \\<Longrightarrow>\n  basis_completion v ! ?i4 =\n  (if ?i4 = 0 then v else unit_vec n (I (?i4 - 1)))\n\ngoal (4 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. distinct (basis_completion v)\n 4. lin_indpt (set (basis_completion v))", "show dist: \"distinct ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (basis_completion v)", "unfolding distinct_conv_nth len"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<forall>j<n.\n          i \\<noteq> j \\<longrightarrow>\n          basis_completion v ! i \\<noteq> basis_completion v ! j", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> basis_completion v ! i \\<noteq>\n                         basis_completion v ! j", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> basis_completion v ! i \\<noteq>\n                         basis_completion v ! j", "assume i: \"i < n\" and j: \"j < n\" and ij: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i < n\n  j < n\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> basis_completion v ! i \\<noteq>\n                         basis_completion v ! j", "show \"?b ! i \\<noteq> ?b ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_completion v ! i \\<noteq> basis_completion v ! j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_completion v ! i = basis_completion v ! j \\<Longrightarrow> False", "assume id1: \"?b ! i = ?b ! j\""], ["proof (state)\nthis:\n  basis_completion v ! i = basis_completion v ! j\n\ngoal (1 subgoal):\n 1. basis_completion v ! i = basis_completion v ! j \\<Longrightarrow> False", "hence id2: \"\\<And> l. ?b ! i $ l = ?b ! j $ l\""], ["proof (prove)\nusing this:\n  basis_completion v ! i = basis_completion v ! j\n\ngoal (1 subgoal):\n 1. \\<And>l. basis_completion v ! i $ l = basis_completion v ! j $ l", "by auto"], ["proof (state)\nthis:\n  basis_completion v ! i $ ?l2 = basis_completion v ! j $ ?l2\n\ngoal (1 subgoal):\n 1. basis_completion v ! i = basis_completion v ! j \\<Longrightarrow> False", "have \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> i = j\n 2. i \\<noteq> 0 \\<Longrightarrow> i = j", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> i = j\n 2. i \\<noteq> 0 \\<Longrightarrow> i = j", "hence biv: \"?b ! i = v\""], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. basis_completion v ! i = v", "unfolding b"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) ! i = v", "by simp"], ["proof (state)\nthis:\n  basis_completion v ! i = v\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> i = j\n 2. i \\<noteq> 0 \\<Longrightarrow> i = j", "from True ij"], ["proof (chain)\npicking this:\n  i = 0\n  i \\<noteq> j", "have bj: \"?b ! j = unit_vec n (I (j - 1))\" \"Suc (j - 1) = j\""], ["proof (prove)\nusing this:\n  i = 0\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. basis_completion v ! j = unit_vec n (I (j - 1)) &&& Suc (j - 1) = j", "unfolding bi[OF j]"], ["proof (prove)\nusing this:\n  i = 0\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (if j = 0 then v else unit_vec n (I (j - 1))) =\n    unit_vec n (I (j - 1)) &&&\n    Suc (j - 1) = j", "by auto"], ["proof (state)\nthis:\n  basis_completion v ! j = unit_vec n (I (j - 1))\n  Suc (j - 1) = j\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> i = j\n 2. i \\<noteq> 0 \\<Longrightarrow> i = j", "with id2[of k, unfolded biv bj] vk I[of \"j - 1\"] k j"], ["proof (chain)\npicking this:\n  v $ k = unit_vec n (I (j - 1)) $ k\n  v $ k \\<noteq> (0::'a)\n  I (j - 1) \\<noteq> k\n  Suc (j - 1) < n \\<Longrightarrow> I (j - 1) < n\n  k < n\n  j < n\n  basis_completion v ! j = unit_vec n (I (j - 1))\n  Suc (j - 1) = j", "have False"], ["proof (prove)\nusing this:\n  v $ k = unit_vec n (I (j - 1)) $ k\n  v $ k \\<noteq> (0::'a)\n  I (j - 1) \\<noteq> k\n  Suc (j - 1) < n \\<Longrightarrow> I (j - 1) < n\n  k < n\n  j < n\n  basis_completion v ! j = unit_vec n (I (j - 1))\n  Suc (j - 1) = j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> i = j\n 2. i \\<noteq> 0 \\<Longrightarrow> i = j", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. i = j", ".."], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> i = j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> i = j", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> i = j", "note i0 = this"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> i = j", "hence bi': \"?b ! i = unit_vec n (I (i - 1))\" \"Suc (i - 1) = i\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. basis_completion v ! i = unit_vec n (I (i - 1)) &&& Suc (i - 1) = i", "unfolding bi[OF i]"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i = 0 then v else unit_vec n (I (i - 1))) =\n    unit_vec n (I (i - 1)) &&&\n    Suc (i - 1) = i", "by auto"], ["proof (state)\nthis:\n  basis_completion v ! i = unit_vec n (I (i - 1))\n  Suc (i - 1) = i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> i = j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof (cases \"j = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> i = j\n 2. j \\<noteq> 0 \\<Longrightarrow> i = j", "case True"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> i = j\n 2. j \\<noteq> 0 \\<Longrightarrow> i = j", "hence bj: \"?b ! j = v\""], ["proof (prove)\nusing this:\n  j = 0\n\ngoal (1 subgoal):\n 1. basis_completion v ! j = v", "unfolding b"], ["proof (prove)\nusing this:\n  j = 0\n\ngoal (1 subgoal):\n 1. (v # map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) ! j = v", "by simp"], ["proof (state)\nthis:\n  basis_completion v ! j = v\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> i = j\n 2. j \\<noteq> 0 \\<Longrightarrow> i = j", "from id2[of k, unfolded bi' bj] vk I[of \"i - 1\"] k i bi'"], ["proof (chain)\npicking this:\n  unit_vec n (I (i - 1)) $ k = v $ k\n  v $ k \\<noteq> (0::'a)\n  I (i - 1) \\<noteq> k\n  Suc (i - 1) < n \\<Longrightarrow> I (i - 1) < n\n  k < n\n  i < n\n  basis_completion v ! i = unit_vec n (I (i - 1))\n  Suc (i - 1) = i", "have False"], ["proof (prove)\nusing this:\n  unit_vec n (I (i - 1)) $ k = v $ k\n  v $ k \\<noteq> (0::'a)\n  I (i - 1) \\<noteq> k\n  Suc (i - 1) < n \\<Longrightarrow> I (i - 1) < n\n  k < n\n  i < n\n  basis_completion v ! i = unit_vec n (I (i - 1))\n  Suc (i - 1) = i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> i = j\n 2. j \\<noteq> 0 \\<Longrightarrow> i = j", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "case False"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "note j0 = this"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "hence bj: \"?b ! j = unit_vec n (I (j - 1))\" \"Suc (j - 1) = j\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. basis_completion v ! j = unit_vec n (I (j - 1)) &&& Suc (j - 1) = j", "unfolding bi[OF j]"], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if j = 0 then v else unit_vec n (I (j - 1))) =\n    unit_vec n (I (j - 1)) &&&\n    Suc (j - 1) = j", "by auto"], ["proof (state)\nthis:\n  basis_completion v ! j = unit_vec n (I (j - 1))\n  Suc (j - 1) = j\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "have \"1 = ?b ! i $ I (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) = basis_completion v ! i $ I (i - 1)", "unfolding bi'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) = unit_vec n (I (i - 1)) $ I (i - 1)", "using I[of \"i - 1\"] i i0"], ["proof (prove)\nusing this:\n  I (i - 1) \\<noteq> k\n  Suc (i - 1) < n \\<Longrightarrow> I (i - 1) < n\n  i < n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1::'a) = unit_vec n (I (i - 1)) $ I (i - 1)", "by auto"], ["proof (state)\nthis:\n  (1::'a) = basis_completion v ! i $ I (i - 1)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "also"], ["proof (state)\nthis:\n  (1::'a) = basis_completion v ! i $ I (i - 1)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "have \"\\<dots> = unit_vec n (I (j - 1)) $ I (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_completion v ! i $ I (i - 1) = unit_vec n (I (j - 1)) $ I (i - 1)", "unfolding id1 bj"], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vec n (I (j - 1)) $ I (i - 1) = unit_vec n (I (j - 1)) $ I (i - 1)", "by simp"], ["proof (state)\nthis:\n  basis_completion v ! i $ I (i - 1) = unit_vec n (I (j - 1)) $ I (i - 1)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "also"], ["proof (state)\nthis:\n  basis_completion v ! i $ I (i - 1) = unit_vec n (I (j - 1)) $ I (i - 1)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "have \"\\<dots> = (if I (i - 1) = I (j - 1) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vec n (I (j - 1)) $ I (i - 1) =\n    (if I (i - 1) = I (j - 1) then 1::'a else (0::'a))", "using I[of \"i - 1\"] I[of \"j - 1\"] i0 j0 i j"], ["proof (prove)\nusing this:\n  I (i - 1) \\<noteq> k\n  Suc (i - 1) < n \\<Longrightarrow> I (i - 1) < n\n  I (j - 1) \\<noteq> k\n  Suc (j - 1) < n \\<Longrightarrow> I (j - 1) < n\n  i \\<noteq> 0\n  j \\<noteq> 0\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. unit_vec n (I (j - 1)) $ I (i - 1) =\n    (if I (i - 1) = I (j - 1) then 1::'a else (0::'a))", "by auto"], ["proof (state)\nthis:\n  unit_vec n (I (j - 1)) $ I (i - 1) =\n  (if I (i - 1) = I (j - 1) then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "finally"], ["proof (chain)\npicking this:\n  (1::'a) = (if I (i - 1) = I (j - 1) then 1::'a else (0::'a))", "have \"I (i - 1) = I (j - 1)\""], ["proof (prove)\nusing this:\n  (1::'a) = (if I (i - 1) = I (j - 1) then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. I (i - 1) = I (j - 1)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  I (i - 1) = I (j - 1)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> i = j", "with i0 j0"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  j \\<noteq> 0\n  I (i - 1) = I (j - 1)", "show \"i = j\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  j \\<noteq> 0\n  I (i - 1) = I (j - 1)\n\ngoal (1 subgoal):\n 1. i = j", "unfolding I_def"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  j \\<noteq> 0\n  (if i - 1 < k then i - 1 else Suc (i - 1)) =\n  (if j - 1 < k then j - 1 else Suc (j - 1))\n\ngoal (1 subgoal):\n 1. i = j", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. basis_completion v ! i = basis_completion v ! j \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. False", "using ij"], ["proof (prove)\nusing this:\n  i = j\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  basis_completion v ! i \\<noteq> basis_completion v ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (basis_completion v)\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "have \"span (set ?b) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (basis_completion v)) \\<subseteq> carrier_vec n", "using carr"], ["proof (prove)\nusing this:\n  set (basis_completion v) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span (set (basis_completion v)) \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  local.span (set (basis_completion v)) \\<subseteq> carrier_vec n\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "moreover"], ["proof (state)\nthis:\n  local.span (set (basis_completion v)) \\<subseteq> carrier_vec n\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "{"], ["proof (state)\nthis:\n  local.span (set (basis_completion v)) \\<subseteq> carrier_vec n\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "fix w :: \"'a vec\""], ["proof (state)\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "assume w: \"w \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "define lookup where \"lookup = (v,k) # [(unit_vec n i, i). i <- [0..<n], i \\<noteq> k]\""], ["proof (state)\nthis:\n  lookup =\n  (v, k) #\n  concat\n   (map (\\<lambda>i. if i \\<noteq> k then [(unit_vec n i, i)] else [])\n     [0..<n])\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "define a where \"a = (\\<lambda> vi. case map_of lookup vi of Some i \\<Rightarrow> if i = k then w $ k / v $ k else\n       w $ i - w $ k / v $ k * v $ i)\""], ["proof (state)\nthis:\n  a =\n  (\\<lambda>vi.\n      case map_of lookup vi of\n      Some i \\<Rightarrow>\n        if i = k then w $ k / v $ k else w $ i - w $ k / v $ k * v $ i)\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "have \"map fst lookup = ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst lookup = basis_completion v", "unfolding b_all lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst\n     ((v, k) #\n      concat\n       (map (\\<lambda>i. if i \\<noteq> k then [(unit_vec n i, i)] else [])\n         [0..<n])) =\n    v #\n    concat\n     (map (\\<lambda>i. if i \\<noteq> k then [unit_vec n i] else []) [0..<n])", "by (auto simp: map_concat o_def if_distrib, unfold list.simps fst_def prod.simps, simp)"], ["proof (state)\nthis:\n  map fst lookup = basis_completion v\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "with dist"], ["proof (chain)\npicking this:\n  distinct (basis_completion v)\n  map fst lookup = basis_completion v", "have dist: \"distinct (map fst lookup)\""], ["proof (prove)\nusing this:\n  distinct (basis_completion v)\n  map fst lookup = basis_completion v\n\ngoal (1 subgoal):\n 1. distinct (map fst lookup)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst lookup)\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "let ?w = \"lincomb a (set ?b)\""], ["proof (state)\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "have \"?w \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a (set (basis_completion v)) \\<in> carrier_vec n", "using carr"], ["proof (prove)\nusing this:\n  set (basis_completion v) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lincomb a (set (basis_completion v)) \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  lincomb a (set (basis_completion v)) \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "with w"], ["proof (chain)\npicking this:\n  w \\<in> carrier_vec n\n  lincomb a (set (basis_completion v)) \\<in> carrier_vec n", "have dim: \"dim_vec w = n\" \"dim_vec ?w = n\""], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  lincomb a (set (basis_completion v)) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec w = n &&& dim_vec (lincomb a (set (basis_completion v))) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec w = n\n  dim_vec (lincomb a (set (basis_completion v))) = n\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "have \"w = ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = lincomb a (set (basis_completion v))", "proof (rule eq_vecI; unfold dim)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       w $ i = lincomb a (set (basis_completion v)) $ i\n 2. n = n", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       w $ i = lincomb a (set (basis_completion v)) $ i\n 2. n = n", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       w $ i = lincomb a (set (basis_completion v)) $ i\n 2. n = n", "show \"w $ i = ?w $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w $ i = lincomb a (set (basis_completion v)) $ i", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (basis_completion\n    v). a v \\<cdot>\\<^sub>v v) $\n    i", "proof (subst finsum_index[OF i _ carr])"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>v. a v \\<cdot>\\<^sub>v v)\n    \\<in> set (basis_completion v) \\<rightarrow> carrier_vec n\n 2. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "show \"(\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> set ?b \\<rightarrow> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. a v \\<cdot>\\<^sub>v v)\n    \\<in> set (basis_completion v) \\<rightarrow> carrier_vec n", "using carr"], ["proof (prove)\nusing this:\n  set (basis_completion v) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. a v \\<cdot>\\<^sub>v v)\n    \\<in> set (basis_completion v) \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. a v \\<cdot>\\<^sub>v v)\n  \\<in> set (basis_completion v) \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "{"], ["proof (state)\nthis:\n  (\\<lambda>v. a v \\<cdot>\\<^sub>v v)\n  \\<in> set (basis_completion v) \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "fix x :: \"'a vec\" and j"], ["proof (state)\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "assume \"x = unit_vec n j\" \"j \\<noteq> k\" \"j < n\""], ["proof (state)\nthis:\n  x = unit_vec n j\n  j \\<noteq> k\n  j < n\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "hence \"(x,j) \\<in> set lookup\""], ["proof (prove)\nusing this:\n  x = unit_vec n j\n  j \\<noteq> k\n  j < n\n\ngoal (1 subgoal):\n 1. (x, j) \\<in> set lookup", "unfolding lookup_def"], ["proof (prove)\nusing this:\n  x = unit_vec n j\n  j \\<noteq> k\n  j < n\n\ngoal (1 subgoal):\n 1. (x, j)\n    \\<in> set ((v, k) #\n               concat\n                (map (\\<lambda>i.\n                         if i \\<noteq> k then [(unit_vec n i, i)] else [])\n                  [0..<n]))", "by auto"], ["proof (state)\nthis:\n  (x, j) \\<in> set lookup\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "from map_of_is_SomeI[OF dist this]"], ["proof (chain)\npicking this:\n  map_of lookup x = Some j", "have \"a x = w $ j - w $ k / v $ k * v $ j\""], ["proof (prove)\nusing this:\n  map_of lookup x = Some j\n\ngoal (1 subgoal):\n 1. a x = w $ j - w $ k / v $ k * v $ j", "unfolding a_def"], ["proof (prove)\nusing this:\n  map_of lookup x = Some j\n\ngoal (1 subgoal):\n 1. (case map_of lookup x of\n     Some i \\<Rightarrow>\n       if i = k then w $ k / v $ k else w $ i - w $ k / v $ k * v $ i) =\n    w $ j - w $ k / v $ k * v $ j", "using \\<open>j \\<noteq> k\\<close>"], ["proof (prove)\nusing this:\n  map_of lookup x = Some j\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. (case map_of lookup x of\n     Some i \\<Rightarrow>\n       if i = k then w $ k / v $ k else w $ i - w $ k / v $ k * v $ i) =\n    w $ j - w $ k / v $ k * v $ j", "by auto"], ["proof (state)\nthis:\n  a x = w $ j - w $ k / v $ k * v $ j\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x4 = unit_vec n ?j4; ?j4 \\<noteq> k; ?j4 < n\\<rbrakk>\n  \\<Longrightarrow> a ?x4 = w $ ?j4 - w $ k / v $ k * v $ ?j4\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "note a = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x4 = unit_vec n ?j4; ?j4 \\<noteq> k; ?j4 < n\\<rbrakk>\n  \\<Longrightarrow> a ?x4 = w $ ?j4 - w $ k / v $ k * v $ ?j4\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "have \"(\\<Sum>x\\<in>set ?b. (a x \\<cdot>\\<^sub>v x) $ i) = (a v \\<cdot>\\<^sub>v v) $ i + (\\<Sum>x\\<in>(set ?b) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n    (a v \\<cdot>\\<^sub>v v) $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i)", "by (rule sum.remove[OF finite_set], auto simp: b)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  (a v \\<cdot>\\<^sub>v v) $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  (a v \\<cdot>\\<^sub>v v) $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "have \"a v = w $ k / v $ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a v = w $ k / v $ k", "unfolding a_def lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case map_of\n           ((v, k) #\n            concat\n             (map (\\<lambda>i.\n                      if i \\<noteq> k then [(unit_vec n i, i)] else [])\n               [0..<n]))\n           v of\n     Some i \\<Rightarrow>\n       if i = k then w $ k / v $ k else w $ i - w $ k / v $ k * v $ i) =\n    w $ k / v $ k", "by auto"], ["proof (state)\nthis:\n  a v = w $ k / v $ k\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "also"], ["proof (state)\nthis:\n  a v = w $ k / v $ k\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "have \"(\\<dots> \\<cdot>\\<^sub>v v) $ i = w $ k / v $ k * v $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w $ k / v $ k \\<cdot>\\<^sub>v v) $ i = w $ k / v $ k * v $ i", "using i v"], ["proof (prove)\nusing this:\n  i < n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (w $ k / v $ k \\<cdot>\\<^sub>v v) $ i = w $ k / v $ k * v $ i", "by auto"], ["proof (state)\nthis:\n  (w $ k / v $ k \\<cdot>\\<^sub>v v) $ i = w $ k / v $ k * v $ i\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)", "have \"(\\<Sum>x\\<in>set ?b. (a x \\<cdot>\\<^sub>v x) $ i) = w $ k / v $ k * v $ i + (\\<Sum>x\\<in>(set ?b) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i)", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "have \"\\<dots> = w $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i\n 2. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "case True"], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i\n 2. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "hence \"w $ k / v $ k * v $ i = w $ k\""], ["proof (prove)\nusing this:\n  i = k\n\ngoal (1 subgoal):\n 1. w $ k / v $ k * v $ i = w $ k", "using vk"], ["proof (prove)\nusing this:\n  i = k\n  v $ k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. w $ k / v $ k * v $ i = w $ k", "by auto"], ["proof (state)\nthis:\n  w $ k / v $ k * v $ i = w $ k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i\n 2. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "moreover"], ["proof (state)\nthis:\n  w $ k / v $ k * v $ i = w $ k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i\n 2. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "have \"(\\<Sum>x\\<in>(set ?b) - {v}. (a x \\<cdot>\\<^sub>v x) $ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    (0::'a)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ k) =\n    (0::'a)", "proof (rule sum.neutral, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (basis_completion v) - {v} \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) $ k = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (basis_completion v) - {v} \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) $ k = (0::'a)", "assume \"x \\<in> set ?b - {v}\""], ["proof (state)\nthis:\n  x \\<in> set (basis_completion v) - {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (basis_completion v) - {v} \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) $ k = (0::'a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (basis_completion v) - {v}", "obtain j where x: \"x = unit_vec n j\" \"j \\<noteq> k\" \"j < n\""], ["proof (prove)\nusing this:\n  x \\<in> set (basis_completion v) - {v}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x = unit_vec n j; j \\<noteq> k; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using k"], ["proof (prove)\nusing this:\n  x \\<in> set (basis_completion v) - {v}\n  k < n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x = unit_vec n j; j \\<noteq> k; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding b"], ["proof (prove)\nusing this:\n  x \\<in> set (v #\n               map (unit_vec n) [0..<k] @ map (unit_vec n) [Suc k..<n]) -\n          {v}\n  k < n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x = unit_vec n j; j \\<noteq> k; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = unit_vec n j\n  j \\<noteq> k\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (basis_completion v) - {v} \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) $ k = (0::'a)", "show \"(a x \\<cdot>\\<^sub>v x) $ k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a x \\<cdot>\\<^sub>v x) $ k = (0::'a)", "unfolding a[OF x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((w $ j - w $ k / v $ k * v $ j) \\<cdot>\\<^sub>v x) $ k = (0::'a)", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((w $ j - w $ k / v $ k * v $ j) \\<cdot>\\<^sub>v unit_vec n j) $ k =\n    (0::'a)", "using x k"], ["proof (prove)\nusing this:\n  x = unit_vec n j\n  j \\<noteq> k\n  j < n\n  k < n\n\ngoal (1 subgoal):\n 1. ((w $ j - w $ k / v $ k * v $ j) \\<cdot>\\<^sub>v unit_vec n j) $ k =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  (a x \\<cdot>\\<^sub>v x) $ k = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i\n 2. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "ultimately"], ["proof (chain)\npicking this:\n  w $ k / v $ k * v $ i = w $ k\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  w $ k / v $ k * v $ i = w $ k\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "unfolding True"], ["proof (prove)\nusing this:\n  w $ k / v $ k * v $ k = w $ k\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ k) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. w $ k / v $ k * v $ k +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ k) =\n    w $ k", "by simp"], ["proof (state)\nthis:\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "let ?ui = \"unit_vec n i :: 'a vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "assume \"?ui = v\""], ["proof (state)\nthis:\n  unit_vec n i = v\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "from arg_cong[OF this, of \"\\<lambda> v. v $ k\"] vk i k False"], ["proof (chain)\npicking this:\n  unit_vec n i $ k = v $ k\n  v $ k \\<noteq> (0::'a)\n  i < n\n  k < n\n  i \\<noteq> k", "have False"], ["proof (prove)\nusing this:\n  unit_vec n i $ k = v $ k\n  v $ k \\<noteq> (0::'a)\n  i < n\n  k < n\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "}"], ["proof (state)\nthis:\n  unit_vec n i = v \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "hence diff: \"?ui \\<noteq> v\""], ["proof (prove)\nusing this:\n  unit_vec n i = v \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. unit_vec n i \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  unit_vec n i \\<noteq> v\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "from a[OF refl False]"], ["proof (chain)\npicking this:\n  i < n \\<Longrightarrow> a (unit_vec n i) = w $ i - w $ k / v $ k * v $ i", "have ai: \"(a ?ui \\<cdot>\\<^sub>v ?ui) $ i = w $ i - w $ k / v $ k * v $ i\""], ["proof (prove)\nusing this:\n  i < n \\<Longrightarrow> a (unit_vec n i) = w $ i - w $ k / v $ k * v $ i\n\ngoal (1 subgoal):\n 1. (a (unit_vec n i) \\<cdot>\\<^sub>v unit_vec n i) $ i =\n    w $ i - w $ k / v $ k * v $ i", "using i"], ["proof (prove)\nusing this:\n  i < n \\<Longrightarrow> a (unit_vec n i) = w $ i - w $ k / v $ k * v $ i\n  i < n\n\ngoal (1 subgoal):\n 1. (a (unit_vec n i) \\<cdot>\\<^sub>v unit_vec n i) $ i =\n    w $ i - w $ k / v $ k * v $ i", "by auto"], ["proof (state)\nthis:\n  (a (unit_vec n i) \\<cdot>\\<^sub>v unit_vec n i) $ i =\n  w $ i - w $ k / v $ k * v $ i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "have \"?ui \\<in> set ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vec n i \\<in> set (basis_completion v)", "unfolding b_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vec n i\n    \\<in> set (v #\n               concat\n                (map (\\<lambda>i.\n                         if i \\<noteq> k then [unit_vec n i] else [])\n                  [0..<n]))", "using False k i"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n  k < n\n  i < n\n\ngoal (1 subgoal):\n 1. unit_vec n i\n    \\<in> set (v #\n               concat\n                (map (\\<lambda>i.\n                         if i \\<noteq> k then [unit_vec n i] else [])\n                  [0..<n]))", "by auto"], ["proof (state)\nthis:\n  unit_vec n i \\<in> set (basis_completion v)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "with diff"], ["proof (chain)\npicking this:\n  unit_vec n i \\<noteq> v\n  unit_vec n i \\<in> set (basis_completion v)", "have mem: \"unit_vec n i \\<in> set ?b - {v}\""], ["proof (prove)\nusing this:\n  unit_vec n i \\<noteq> v\n  unit_vec n i \\<in> set (basis_completion v)\n\ngoal (1 subgoal):\n 1. unit_vec n i \\<in> set (basis_completion v) - {v}", "by auto"], ["proof (state)\nthis:\n  unit_vec n i \\<in> set (basis_completion v) - {v}\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "have \"w $ k / v $ k * v $ i + (\\<Sum>x\\<in>(set ?b) - {v}. (a x \\<cdot>\\<^sub>v x) $ i)\n            = w $ i + (\\<Sum>x\\<in>(set ?b) - {v,?ui}. (a x \\<cdot>\\<^sub>v x) $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v, unit_vec n i}.\n       (a x \\<cdot>\\<^sub>v x) $ i)", "by (subst sum.remove[OF _ mem], auto simp: ai intro!: sum.cong)"], ["proof (state)\nthis:\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v, unit_vec n i}.\n     (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "also"], ["proof (state)\nthis:\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v, unit_vec n i}.\n     (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "have \"(\\<Sum>x\\<in>(set ?b) - {v,?ui}. (a x \\<cdot>\\<^sub>v x) $ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (basis_completion v) - {v, unit_vec n i}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    (0::'a)", "by (rule sum.neutral, unfold b_all, insert i k, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (basis_completion v) - {v, unit_vec n i}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "finally"], ["proof (chain)\npicking this:\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i + (0::'a)\n\ngoal (1 subgoal):\n 1. w $ k / v $ k * v $ i +\n    (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n       (a x \\<cdot>\\<^sub>v x) $ i) =\n    w $ i", "by simp"], ["proof (state)\nthis:\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w $ k / v $ k * v $ i +\n  (\\<Sum>x\\<in>set (basis_completion v) - {v}.\n     (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i", "show \"w $ i = (\\<Sum>x\\<in>set ?b. (a x \\<cdot>\\<^sub>v x) $ i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i) =\n  w $ i\n\ngoal (1 subgoal):\n 1. w $ i =\n    (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)", "by simp"], ["proof (state)\nthis:\n  w $ i =\n  (\\<Sum>x\\<in>set (basis_completion v). (a x \\<cdot>\\<^sub>v x) $ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w $ i = lincomb a (set (basis_completion v)) $ i\n\ngoal (1 subgoal):\n 1. n = n", "qed auto"], ["proof (state)\nthis:\n  w = lincomb a (set (basis_completion v))\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "hence \"w \\<in> span (set ?b)\""], ["proof (prove)\nusing this:\n  w = lincomb a (set (basis_completion v))\n\ngoal (1 subgoal):\n 1. w \\<in> local.span (set (basis_completion v))", "unfolding span_def"], ["proof (prove)\nusing this:\n  w = lincomb a (set (basis_completion v))\n\ngoal (1 subgoal):\n 1. w \\<in> {lincomb a A |a A.\n             finite A \\<and> A \\<subseteq> set (basis_completion v)}", "by auto"], ["proof (state)\nthis:\n  w \\<in> local.span (set (basis_completion v))\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "}"], ["proof (state)\nthis:\n  ?w4 \\<in> carrier_vec n \\<Longrightarrow>\n  ?w4 \\<in> local.span (set (basis_completion v))\n\ngoal (3 subgoals):\n 1. basis (set (basis_completion v))\n 2. local.span (set (basis_completion v)) = carrier_vec n\n 3. lin_indpt (set (basis_completion v))", "ultimately"], ["proof (chain)\npicking this:\n  local.span (set (basis_completion v)) \\<subseteq> carrier_vec n\n  ?w4 \\<in> carrier_vec n \\<Longrightarrow>\n  ?w4 \\<in> local.span (set (basis_completion v))", "show span: \"span (set ?b) = carrier_vec n\""], ["proof (prove)\nusing this:\n  local.span (set (basis_completion v)) \\<subseteq> carrier_vec n\n  ?w4 \\<in> carrier_vec n \\<Longrightarrow>\n  ?w4 \\<in> local.span (set (basis_completion v))\n\ngoal (1 subgoal):\n 1. local.span (set (basis_completion v)) = carrier_vec n", "by blast"], ["proof (state)\nthis:\n  local.span (set (basis_completion v)) = carrier_vec n\n\ngoal (2 subgoals):\n 1. basis (set (basis_completion v))\n 2. lin_indpt (set (basis_completion v))", "show \"basis (set ?b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis (set (basis_completion v))", "proof (rule dim_gen_is_basis[OF finite_set carr span])"], ["proof (state)\ngoal (1 subgoal):\n 1. card (set (basis_completion v)) \\<le> local.dim", "have \"card (set ?b) = dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (basis_completion v)) = local.dim", "using dist len distinct_card"], ["proof (prove)\nusing this:\n  distinct (basis_completion v)\n  length (basis_completion v) = n\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. card (set (basis_completion v)) = local.dim", "unfolding dim_is_n"], ["proof (prove)\nusing this:\n  distinct (basis_completion v)\n  length (basis_completion v) = n\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. card (set (basis_completion v)) = n", "by blast"], ["proof (state)\nthis:\n  card (set (basis_completion v)) = local.dim\n\ngoal (1 subgoal):\n 1. card (set (basis_completion v)) \\<le> local.dim", "thus \"card (set ?b) \\<le> dim\""], ["proof (prove)\nusing this:\n  card (set (basis_completion v)) = local.dim\n\ngoal (1 subgoal):\n 1. card (set (basis_completion v)) \\<le> local.dim", "by simp"], ["proof (state)\nthis:\n  card (set (basis_completion v)) \\<le> local.dim\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  basis (set (basis_completion v))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (basis_completion v))", "thus \"\\<not> lin_dep (set ?b)\""], ["proof (prove)\nusing this:\n  basis (set (basis_completion v))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (basis_completion v))", "unfolding basis_def"], ["proof (prove)\nusing this:\n  lin_indpt (set (basis_completion v)) \\<and>\n  local.span (set (basis_completion v)) = carrier_vec n \\<and>\n  set (basis_completion v) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_indpt (set (basis_completion v))", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set (basis_completion v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_mat_of_cols:\n  assumes W: \"set ws \\<subseteq> carrier_vec n\"\n    and orth: \"corthogonal ws\"\n    and len: \"length ws = n\"\n  shows \"corthogonal_mat (mat_of_cols n ws)\" (is \"corthogonal_mat ?W\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal_mat (mat_of_cols n ws)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col (mat_of_cols n ws);\n        j < dim_col (mat_of_cols n ws)\\<rbrakk>\n       \\<Longrightarrow> (col (mat_of_cols n ws) i \\<bullet>c\n                          col (mat_of_cols n ws) j =\n                          (0::'a)) =\n                         (i \\<noteq> j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col (mat_of_cols n ws);\n        j < dim_col (mat_of_cols n ws)\\<rbrakk>\n       \\<Longrightarrow> (col (mat_of_cols n ws) i \\<bullet>c\n                          col (mat_of_cols n ws) j =\n                          (0::'a)) =\n                         (i \\<noteq> j)", "assume i: \"i < dim_col ?W\" and j: \"j < dim_col ?W\""], ["proof (state)\nthis:\n  i < dim_col (mat_of_cols n ws)\n  j < dim_col (mat_of_cols n ws)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col (mat_of_cols n ws);\n        j < dim_col (mat_of_cols n ws)\\<rbrakk>\n       \\<Longrightarrow> (col (mat_of_cols n ws) i \\<bullet>c\n                          col (mat_of_cols n ws) j =\n                          (0::'a)) =\n                         (i \\<noteq> j)", "hence [simp]: \"ws ! i : carrier_vec n\" \"ws ! j : carrier_vec n\""], ["proof (prove)\nusing this:\n  i < dim_col (mat_of_cols n ws)\n  j < dim_col (mat_of_cols n ws)\n\ngoal (1 subgoal):\n 1. ws ! i \\<in> carrier_vec n &&& ws ! j \\<in> carrier_vec n", "using W len"], ["proof (prove)\nusing this:\n  i < dim_col (mat_of_cols n ws)\n  j < dim_col (mat_of_cols n ws)\n  set ws \\<subseteq> carrier_vec n\n  length ws = n\n\ngoal (1 subgoal):\n 1. ws ! i \\<in> carrier_vec n &&& ws ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ws ! i \\<in> carrier_vec n\n  ws ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col (mat_of_cols n ws);\n        j < dim_col (mat_of_cols n ws)\\<rbrakk>\n       \\<Longrightarrow> (col (mat_of_cols n ws) i \\<bullet>c\n                          col (mat_of_cols n ws) j =\n                          (0::'a)) =\n                         (i \\<noteq> j)", "have \"i < length ws\" and \"j < length ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ws &&& j < length ws", "using i j"], ["proof (prove)\nusing this:\n  i < dim_col (mat_of_cols n ws)\n  j < dim_col (mat_of_cols n ws)\n\ngoal (1 subgoal):\n 1. i < length ws &&& j < length ws", "using len W"], ["proof (prove)\nusing this:\n  i < dim_col (mat_of_cols n ws)\n  j < dim_col (mat_of_cols n ws)\n  length ws = n\n  set ws \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < length ws &&& j < length ws", "by auto"], ["proof (state)\nthis:\n  i < length ws\n  j < length ws\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col (mat_of_cols n ws);\n        j < dim_col (mat_of_cols n ws)\\<rbrakk>\n       \\<Longrightarrow> (col (mat_of_cols n ws) i \\<bullet>c\n                          col (mat_of_cols n ws) j =\n                          (0::'a)) =\n                         (i \\<noteq> j)", "thus \"col ?W i \\<bullet>c col ?W j = 0 \\<longleftrightarrow> i \\<noteq> j\""], ["proof (prove)\nusing this:\n  i < length ws\n  j < length ws\n\ngoal (1 subgoal):\n 1. (col (mat_of_cols n ws) i \\<bullet>c col (mat_of_cols n ws) j =\n     (0::'a)) =\n    (i \\<noteq> j)", "using orth"], ["proof (prove)\nusing this:\n  i < length ws\n  j < length ws\n  corthogonal ws\n\ngoal (1 subgoal):\n 1. (col (mat_of_cols n ws) i \\<bullet>c col (mat_of_cols n ws) j =\n     (0::'a)) =\n    (i \\<noteq> j)", "unfolding corthogonal_def"], ["proof (prove)\nusing this:\n  i < length ws\n  j < length ws\n  \\<forall>i<length ws.\n     \\<forall>j<length ws.\n        (ws ! i \\<bullet>c ws ! j = (0::'a)) = (i \\<noteq> j)\n\ngoal (1 subgoal):\n 1. (col (mat_of_cols n ws) i \\<bullet>c col (mat_of_cols n ws) j =\n     (0::'a)) =\n    (i \\<noteq> j)", "by simp"], ["proof (state)\nthis:\n  (col (mat_of_cols n ws) i \\<bullet>c col (mat_of_cols n ws) j = (0::'a)) =\n  (i \\<noteq> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma corthogonal_col_ev_0: fixes A :: \"'a :: conjugatable_ordered_field mat\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n  and v: \"v \\<in> carrier_vec n\"\n  and v0: \"v \\<noteq> 0\\<^sub>v n\"\n  and eigen[simp]: \"A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\"\n  and n: \"n \\<noteq> 0\"\n  and hdws: \"hd ws = v\"\n  and ws: \"set ws \\<subseteq> carrier_vec n\" \"corthogonal ws\" \"length ws = n\"\n  defines \"W == mat_of_cols n ws\"\n  defines \"W' == corthogonal_inv W\"\n  defines \"A' == W' * A * W\"\n  shows \"col A' 0 = vec n (\\<lambda> i. if i = 0 then e else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "let ?f = \"(\\<lambda> i. if i = 0 then e else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "from ws"], ["proof (chain)\npicking this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n", "have W: \"W \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat n n", "unfolding W_def"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. mat_of_cols n ws \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "from W"], ["proof (chain)\npicking this:\n  W \\<in> carrier_mat n n", "have W': \"W' \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W' \\<in> carrier_mat n n", "unfolding W'_def \n    corthogonal_inv_def mat_of_rows_def"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat (length (map vec_inv (cols W))) (dim_row W)\n     (\\<lambda>(i, y). map vec_inv (cols W) ! i $ y)\n    \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "from A W W'"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n", "have A': \"A' \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "unfolding A'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W' * A * W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "show \"col A' 0 = vec n ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "proof (rule,unfold dim_vec)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i\n 2. dim_vec (col A' 0) = n", "show dim: \"dim_vec (col A' 0) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (col A' 0) = n", "using A'"], ["proof (prove)\nusing this:\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_vec (col A' 0) = n", "by simp"], ["proof (state)\nthis:\n  dim_vec (col A' 0) = n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have row0: \"vec_inv v \\<bullet> (A *\\<^sub>v v) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> (A *\\<^sub>v v) = e", "using scalar_prod_smult_distrib[OF vec_inv_closed[OF v] v]"], ["proof (prove)\nusing this:\n  vec_inv v \\<bullet> (?a \\<cdot>\\<^sub>v v) = ?a * (vec_inv v \\<bullet> v)\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> (A *\\<^sub>v v) = e", "using vec_inv[OF v v0]"], ["proof (prove)\nusing this:\n  vec_inv v \\<bullet> (?a \\<cdot>\\<^sub>v v) = ?a * (vec_inv v \\<bullet> v)\n  vec_inv v \\<bullet> v = (1::'a)\n\ngoal (1 subgoal):\n 1. vec_inv v \\<bullet> (A *\\<^sub>v v) = e", "by auto"], ["proof (state)\nthis:\n  vec_inv v \\<bullet> (A *\\<^sub>v v) = e\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "hence i2: \"i < length ws\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. i < length ws", "using ws"], ["proof (prove)\nusing this:\n  i < n\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. i < length ws", "by auto"], ["proof (state)\nthis:\n  i < length ws\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "let ?wsi = \"ws ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have z: \"0 < dim_col A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dim_col A'", "using A' n"], ["proof (prove)\nusing this:\n  A' \\<in> carrier_mat n n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < dim_col A'", "by auto"], ["proof (state)\nthis:\n  0 < dim_col A'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "hence z2: \"0 < length ws\""], ["proof (prove)\nusing this:\n  0 < dim_col A'\n\ngoal (1 subgoal):\n 1. 0 < length ws", "using A' ws"], ["proof (prove)\nusing this:\n  0 < dim_col A'\n  A' \\<in> carrier_mat n n\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. 0 < length ws", "by auto"], ["proof (state)\nthis:\n  0 < length ws\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have wsi[simp]: \"ws!i : carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws ! i \\<in> carrier_vec n", "using ws i"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n  i < n\n\ngoal (1 subgoal):\n 1. ws ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ws ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "hence ws0[simp]: \"ws!0 = v\""], ["proof (prove)\nusing this:\n  ws ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. ws ! 0 = v", "using hd_conv_nth[symmetric] hdws z2"], ["proof (prove)\nusing this:\n  ws ! i \\<in> carrier_vec n\n  ?xs \\<noteq> [] \\<Longrightarrow> ?xs ! 0 = hd ?xs\n  hd ws = v\n  0 < length ws\n\ngoal (1 subgoal):\n 1. ws ! 0 = v", "by auto"], ["proof (state)\nthis:\n  ws ! 0 = v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"col A' 0 $ i = A' $$ (i, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A' 0 $ i = A' $$ (i, 0)", "using A' i"], ["proof (prove)\nusing this:\n  A' \\<in> carrier_mat n n\n  i < n\n\ngoal (1 subgoal):\n 1. col A' 0 $ i = A' $$ (i, 0)", "by auto"], ["proof (state)\nthis:\n  col A' 0 $ i = A' $$ (i, 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  col A' 0 $ i = A' $$ (i, 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"... = (W' * (A * W)) $$ (i, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $$ (i, 0) = (W' * (A * W)) $$ (i, 0)", "unfolding A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (W' * A * W) $$ (i, 0) = (W' * (A * W)) $$ (i, 0)", "using W' A W"], ["proof (prove)\nusing this:\n  W' \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (W' * A * W) $$ (i, 0) = (W' * (A * W)) $$ (i, 0)", "by auto"], ["proof (state)\nthis:\n  A' $$ (i, 0) = (W' * (A * W)) $$ (i, 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  A' $$ (i, 0) = (W' * (A * W)) $$ (i, 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"... = row W' i \\<bullet> col (A * W) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (W' * (A * W)) $$ (i, 0) = row W' i \\<bullet> col (A * W) 0", "apply (subst index_mult_mat)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row W'\n 2. 0 < dim_col (A * W)\n 3. row W' i \\<bullet> col (A * W) 0 = row W' i \\<bullet> col (A * W) 0", "using W W' A i"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  i < n\n\ngoal (3 subgoals):\n 1. i < dim_row W'\n 2. 0 < dim_col (A * W)\n 3. row W' i \\<bullet> col (A * W) 0 = row W' i \\<bullet> col (A * W) 0", "by auto"], ["proof (state)\nthis:\n  (W' * (A * W)) $$ (i, 0) = row W' i \\<bullet> col (A * W) 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  (W' * (A * W)) $$ (i, 0) = row W' i \\<bullet> col (A * W) 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"row W' i = vec_inv ?wsi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row W' i = vec_inv (ws ! i)", "unfolding W'_def W_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (corthogonal_inv (mat_of_cols n ws)) i = vec_inv (ws ! i)", "unfolding corthogonal_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows (dim_row (mat_of_cols n ws))\n          (map vec_inv (cols (mat_of_cols n ws))))\n     i =\n    vec_inv (ws ! i)", "using i ws"], ["proof (prove)\nusing this:\n  i < n\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. row (mat_of_rows (dim_row (mat_of_cols n ws))\n          (map vec_inv (cols (mat_of_cols n ws))))\n     i =\n    vec_inv (ws ! i)", "by auto"], ["proof (state)\nthis:\n  row W' i = vec_inv (ws ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  row W' i = vec_inv (ws ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"col (A * W) 0 = A *\\<^sub>v col W 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (A * W) 0 = A *\\<^sub>v col W 0", "using A W z A'"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n  0 < dim_col A'\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. col (A * W) 0 = A *\\<^sub>v col W 0", "by auto"], ["proof (state)\nthis:\n  col (A * W) 0 = A *\\<^sub>v col W 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  col (A * W) 0 = A *\\<^sub>v col W 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"col W 0 = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col W 0 = v", "unfolding W_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat_of_cols n ws) 0 = v", "using z2 ws0 n col_mat_of_cols v"], ["proof (prove)\nusing this:\n  0 < length ws\n  ws ! 0 = v\n  n \\<noteq> 0\n  \\<lbrakk>?j < length ?vs; ?vs ! ?j \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> col (mat_of_cols ?n ?vs) ?j = ?vs ! ?j\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. col (mat_of_cols n ws) 0 = v", "by blast"], ["proof (state)\nthis:\n  col W 0 = v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  col W 0 = v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "using eigen"], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "."], ["proof (state)\nthis:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"vec_inv ?wsi \\<bullet> (e \\<cdot>\\<^sub>v v) = e * (vec_inv ?wsi \\<bullet> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_inv (ws ! i) \\<bullet> (e \\<cdot>\\<^sub>v v) =\n    e * (vec_inv (ws ! i) \\<bullet> v)", "using scalar_prod_smult_distrib[OF vec_inv_closed[OF wsi] v]"], ["proof (prove)\nusing this:\n  vec_inv (ws ! i) \\<bullet> (?a \\<cdot>\\<^sub>v v) =\n  ?a * (vec_inv (ws ! i) \\<bullet> v)\n\ngoal (1 subgoal):\n 1. vec_inv (ws ! i) \\<bullet> (e \\<cdot>\\<^sub>v v) =\n    e * (vec_inv (ws ! i) \\<bullet> v)", "."], ["proof (state)\nthis:\n  vec_inv (ws ! i) \\<bullet> (e \\<cdot>\\<^sub>v v) =\n  e * (vec_inv (ws ! i) \\<bullet> v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  vec_inv (ws ! i) \\<bullet> (e \\<cdot>\\<^sub>v v) =\n  e * (vec_inv (ws ! i) \\<bullet> v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"... = ?f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "proof(cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "using vec_inv[OF v v0]"], ["proof (prove)\nusing this:\n  i = 0\n  vec_inv v \\<bullet> v = (1::'a)\n\ngoal (1 subgoal):\n 1. e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "by simp"], ["proof (state)\nthis:\n  e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "hence z: \"0 < length ws\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < length ws", "using i ws"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i < n\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. 0 < length ws", "by auto"], ["proof (state)\nthis:\n  0 < length ws\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "note cwsi = carrier_vec_conjugate[OF wsi]"], ["proof (state)\nthis:\n  conjugate (ws ! i) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "have \"vec_inv ?wsi \\<bullet> v = 1 / (?wsi \\<bullet>c ?wsi) * (conjugate ?wsi \\<bullet> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_inv (ws ! i) \\<bullet> v =\n    (1::'a) / (ws ! i \\<bullet>c ws ! i) * (conjugate (ws ! i) \\<bullet> v)", "unfolding vec_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) / (ws ! i \\<bullet>c ws ! i) \\<cdot>\\<^sub>v\n     conjugate (ws ! i)) \\<bullet>\n    v =\n    (1::'a) / (ws ! i \\<bullet>c ws ! i) * (conjugate (ws ! i) \\<bullet> v)", "unfolding smult_scalar_prod_distrib[OF cwsi v]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / (ws ! i \\<bullet>c ws ! i) *\n    (conjugate (ws ! i) \\<bullet> v) =\n    (1::'a) / (ws ! i \\<bullet>c ws ! i) * (conjugate (ws ! i) \\<bullet> v)", ".."], ["proof (state)\nthis:\n  vec_inv (ws ! i) \\<bullet> v =\n  (1::'a) / (ws ! i \\<bullet>c ws ! i) * (conjugate (ws ! i) \\<bullet> v)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "also"], ["proof (state)\nthis:\n  vec_inv (ws ! i) \\<bullet> v =\n  (1::'a) / (ws ! i \\<bullet>c ws ! i) * (conjugate (ws ! i) \\<bullet> v)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "have \"conjugate ?wsi \\<bullet> v = v \\<bullet>c ?wsi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (ws ! i) \\<bullet> v = v \\<bullet>c ws ! i", "using comm_scalar_prod[OF cwsi v]"], ["proof (prove)\nusing this:\n  conjugate (ws ! i) \\<bullet> v = v \\<bullet>c ws ! i\n\ngoal (1 subgoal):\n 1. conjugate (ws ! i) \\<bullet> v = v \\<bullet>c ws ! i", "."], ["proof (state)\nthis:\n  conjugate (ws ! i) \\<bullet> v = v \\<bullet>c ws ! i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "also"], ["proof (state)\nthis:\n  conjugate (ws ! i) \\<bullet> v = v \\<bullet>c ws ! i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<bullet>c ws ! i = (0::'a)", "using corthogonalD[OF ws(2) z i2] False"], ["proof (prove)\nusing this:\n  (ws ! 0 \\<bullet>c ws ! i = (0::'a)) = (0 \\<noteq> i)\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<bullet>c ws ! i = (0::'a)", "unfolding ws0"], ["proof (prove)\nusing this:\n  (v \\<bullet>c ws ! i = (0::'a)) = (0 \\<noteq> i)\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<bullet>c ws ! i = (0::'a)", "by auto"], ["proof (state)\nthis:\n  v \\<bullet>c ws ! i = (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "finally"], ["proof (chain)\npicking this:\n  vec_inv (ws ! i) \\<bullet> v =\n  (1::'a) / (ws ! i \\<bullet>c ws ! i) * (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_inv (ws ! i) \\<bullet> v =\n  (1::'a) / (ws ! i \\<bullet>c ws ! i) * (0::'a)\n\ngoal (1 subgoal):\n 1. e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "using False"], ["proof (prove)\nusing this:\n  vec_inv (ws ! i) \\<bullet> v =\n  (1::'a) / (ws ! i \\<bullet>c ws ! i) * (0::'a)\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))", "by auto"], ["proof (state)\nthis:\n  e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "also"], ["proof (state)\nthis:\n  e * (vec_inv (ws ! i) \\<bullet> v) = (if i = 0 then e else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "have \"... = vec n ?f $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = 0 then e else (0::'a)) =\n    vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. (if i = 0 then e else (0::'a)) =\n    vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "by simp"], ["proof (state)\nthis:\n  (if i = 0 then e else (0::'a)) =\n  vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "finally"], ["proof (chain)\npicking this:\n  col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "show \"col A' 0 $ i = vec n ?f $ i\""], ["proof (prove)\nusing this:\n  col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i\n\ngoal (1 subgoal):\n 1. col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i", "."], ["proof (state)\nthis:\n  col A' 0 $ i = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \"Schur decomposition\""], ["", "fun schur_decomposition :: \"'a::conjugatable_field mat \\<Rightarrow> 'a list \\<Rightarrow> 'a mat \\<times> 'a mat \\<times> 'a mat\" where \n  \"schur_decomposition A [] = (A, 1\\<^sub>m (dim_row A), 1\\<^sub>m (dim_row A))\"\n| \"schur_decomposition A (e # es) = (let\n       n = dim_row A;\n       n1 = n - 1;\n       v = find_eigenvector A e;\n       ws = gram_schmidt n (basis_completion v);\n       W = mat_of_cols n ws;\n       W' = corthogonal_inv W;\n       A' = W' * A * W;\n       (A1,A2,A0,A3) = split_block A' 1 1;\n       (B,P,Q) = schur_decomposition A3 es;\n       z_row = (0\\<^sub>m 1 n1);\n       z_col = (0\\<^sub>m n1 1);\n       one_1 = 1\\<^sub>m 1\n     in (four_block_mat A1 (A2 * P) A0 B, \n     W * four_block_mat one_1 z_row z_col P, \n     four_block_mat one_1 z_row z_col Q * W'))\""], ["", "theorem schur_decomposition:\n  assumes A: \"(A::'a::conjugatable_ordered_field mat) \\<in> carrier_mat n n\"\n      and c: \"char_poly A = (\\<Prod> (e :: 'a) \\<leftarrow> es. [:- e, 1:])\"\n      and B: \"schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = es", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n  schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = es", "proof (induct es arbitrary: n A B P Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n A B P Q.\n       \\<lbrakk>A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1::'a:]);\n        schur_decomposition A [] = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = []\n 2. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "case Nil"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1::'a:])\n  schur_decomposition A [] = (B, P, Q)\n\ngoal (2 subgoals):\n 1. \\<And>n A B P Q.\n       \\<lbrakk>A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1::'a:]);\n        schur_decomposition A [] = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = []\n 2. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "with degree_monic_char_poly[of A n]"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n \\<Longrightarrow>\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1::'a:])\n  schur_decomposition A [] = (B, P, Q)", "show ?case"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n \\<Longrightarrow>\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1::'a:])\n  schur_decomposition A [] = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = []", "by (auto intro: similar_mat_wit_refl simp: diag_mat_def)"], ["proof (state)\nthis:\n  similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = []\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "case (Cons e es n A C P Q)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n   schur_decomposition ?A es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P ?Q \\<and>\n                    upper_triangular ?B \\<and> diag_mat ?B = es\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1::'a:])\n  schur_decomposition A (e # es) = (C, P, Q)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "let ?n1 = \"n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n   schur_decomposition ?A es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P ?Q \\<and>\n                    upper_triangular ?B \\<and> diag_mat ?B = es\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1::'a:])\n  schur_decomposition A (e # es) = (C, P, Q)", "have A: \"A \\<in> carrier_mat n n\" and dim: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n   schur_decomposition ?A es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P ?Q \\<and>\n                    upper_triangular ?B \\<and> diag_mat ?B = es\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1::'a:])\n  schur_decomposition A (e # es) = (C, P, Q)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n &&& dim_row A = n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "let ?cp = \"char_poly A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from Cons(3)"], ["proof (chain)\npicking this:\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1::'a:])", "have cp: \"?cp = [: -e, 1 :] * (\\<Prod>e \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A = [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])", "by auto"], ["proof (state)\nthis:\n  char_poly A = [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have mon: \"monic (\\<Prod>e\\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])", "by (rule monic_prod_list, auto)"], ["proof (state)\nthis:\n  monic (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have deg: \"degree ?cp = Suc (degree (\\<Prod>e\\<leftarrow> es. [:- e, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (char_poly A) =\n    Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]))", "unfolding cp"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])) =\n    Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]))", "by (subst degree_mult_eq, insert mon, auto)"], ["proof (state)\nthis:\n  degree (char_poly A) =\n  Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]))\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "with degree_monic_char_poly[OF A]"], ["proof (chain)\npicking this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)\n  degree (char_poly A) =\n  Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]))", "have n: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)\n  degree (char_poly A) =\n  Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "define v where \"v = find_eigenvector A e\""], ["proof (state)\nthis:\n  v = find_eigenvector A e\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "define b where \"b = basis_completion v\""], ["proof (state)\nthis:\n  b = basis_completion v\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "define ws where \"ws = gram_schmidt n b\""], ["proof (state)\nthis:\n  ws = gram_schmidt n b\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "define W where \"W = mat_of_cols n ws\""], ["proof (state)\nthis:\n  W = mat_of_cols n ws\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "define W' where \"W' = corthogonal_inv W\""], ["proof (state)\nthis:\n  W' = corthogonal_inv W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "define A' where \"A' = W' * A * W\""], ["proof (state)\nthis:\n  A' = W' * A * W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "obtain A1 A2 A0 A3 where splitA': \"split_block A' 1 1 = (A1,A2,A0,A3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A1 A2 A0 A3.\n        split_block A' 1 1 = (A1, A2, A0, A3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_block A' 1 1\", auto)"], ["proof (state)\nthis:\n  split_block A' 1 1 = (A1, A2, A0, A3)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "obtain B P' Q' where schur: \"schur_decomposition A3 es = (B,P',Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B P' Q'.\n        schur_decomposition A3 es = (B, P', Q') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"schur_decomposition A3 es\", auto)"], ["proof (state)\nthis:\n  schur_decomposition A3 es = (B, P', Q')\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "let ?P' = \"four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 ?n1) (0\\<^sub>m ?n1 1) P'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "let ?Q' = \"four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 ?n1) (0\\<^sub>m ?n1 1) Q'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have C: \"C = four_block_mat A1 (A2 * P') A0 B\" and P: \"P = W * ?P'\" and Q: \"Q = ?Q' * W'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = four_block_mat A1 (A2 * P') A0 B &&&\n    P =\n    W *\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P' &&&\n    Q =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "using Cons(4)"], ["proof (prove)\nusing this:\n  schur_decomposition A (e # es) = (C, P, Q)\n\ngoal (1 subgoal):\n 1. C = four_block_mat A1 (A2 * P') A0 B &&&\n    P =\n    W *\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P' &&&\n    Q =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "unfolding schur_decomposition.simps\n    Let_def list.sel dim\n    v_def[symmetric] b_def[symmetric] ws_def[symmetric] W'_def[symmetric] W_def[symmetric]\n    A'_def[symmetric] split splitA' schur"], ["proof (prove)\nusing this:\n  (four_block_mat A1 (A2 * P') A0 B,\n   W *\n   four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n    P',\n   four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n    Q' *\n   W') =\n  (C, P, Q)\n\ngoal (1 subgoal):\n 1. C = four_block_mat A1 (A2 * P') A0 B &&&\n    P =\n    W *\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P' &&&\n    Q =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "by auto"], ["proof (state)\nthis:\n  C = four_block_mat A1 (A2 * P') A0 B\n  P =\n  W *\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   P'\n  Q =\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' *\n  W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have e: \"eigenvalue A e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue A e", "unfolding eigenvalue_root_char_poly[OF A] cp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])) e =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  eigenvalue A e\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from find_eigenvector[OF A e]"], ["proof (chain)\npicking this:\n  eigenvector A (find_eigenvector A e) e", "have ev: \"eigenvector A v e\""], ["proof (prove)\nusing this:\n  eigenvector A (find_eigenvector A e) e\n\ngoal (1 subgoal):\n 1. eigenvector A v e", "unfolding v_def"], ["proof (prove)\nusing this:\n  eigenvector A (find_eigenvector A e) e\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "."], ["proof (state)\nthis:\n  eigenvector A v e\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from this[unfolded eigenvector_def]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "have v[simp]: \"v \\<in> carrier_vec n\" and v0: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& v \\<noteq> 0\\<^sub>v n", "using A"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& v \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "interpret cof_vec_space n \"TYPE('a)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from basis_completion[OF v v0, folded b_def]"], ["proof (chain)\npicking this:\n  basis (set b)\n  set b \\<subseteq> carrier_vec n\n  local.span (set b) = carrier_vec n\n  distinct b\n  lin_indpt (set b)\n  length b = n\n  hd b = v", "have span_b: \"span (set b) = carrier_vec n\" and dist_b: \"distinct b\" \n    and indep: \"\\<not> lin_dep (set b)\" and b: \"set b \\<subseteq> carrier_vec n\" and hdb: \"hd b = v\" \n    and len_b: \"length b = n\""], ["proof (prove)\nusing this:\n  basis (set b)\n  set b \\<subseteq> carrier_vec n\n  local.span (set b) = carrier_vec n\n  distinct b\n  lin_indpt (set b)\n  length b = n\n  hd b = v\n\ngoal (1 subgoal):\n 1. (local.span (set b) = carrier_vec n &&&\n     distinct b &&& lin_indpt (set b)) &&&\n    set b \\<subseteq> carrier_vec n &&& hd b = v &&& length b = n", "by auto"], ["proof (state)\nthis:\n  local.span (set b) = carrier_vec n\n  distinct b\n  lin_indpt (set b)\n  set b \\<subseteq> carrier_vec n\n  hd b = v\n  length b = n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from hdb len_b n"], ["proof (chain)\npicking this:\n  hd b = v\n  length b = n\n  n \\<noteq> 0", "obtain vs where bv: \"b = v # vs\""], ["proof (prove)\nusing this:\n  hd b = v\n  length b = n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>vs. b = v # vs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases b, auto)"], ["proof (state)\nthis:\n  b = v # vs\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from gram_schmidt_result[OF b dist_b indep refl, folded ws_def]"], ["proof (chain)\npicking this:\n  local.span (set b) = local.span (set ws)\n  corthogonal ws\n  set ws \\<subseteq> carrier_vec n\n  length ws = length b\n  distinct ws", "have ws: \"set ws \\<subseteq> carrier_vec n\" \"corthogonal ws\" \"length ws = n\""], ["proof (prove)\nusing this:\n  local.span (set b) = local.span (set ws)\n  corthogonal ws\n  set ws \\<subseteq> carrier_vec n\n  length ws = length b\n  distinct ws\n\ngoal (1 subgoal):\n 1. set ws \\<subseteq> carrier_vec n &&& corthogonal ws &&& length ws = n", "by (auto simp: len_b)"], ["proof (state)\nthis:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from gram_schmidt_hd[OF v, of vs, folded bv]"], ["proof (chain)\npicking this:\n  hd (gram_schmidt n b) = v", "have hdws: \"hd ws = v\""], ["proof (prove)\nusing this:\n  hd (gram_schmidt n b) = v\n\ngoal (1 subgoal):\n 1. hd ws = v", "unfolding ws_def"], ["proof (prove)\nusing this:\n  hd (gram_schmidt n b) = v\n\ngoal (1 subgoal):\n 1. hd (gram_schmidt n b) = v", "."], ["proof (state)\nthis:\n  hd ws = v\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have orth_W: \"corthogonal_mat W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal_mat W", "using orthogonal_mat_of_cols ws"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?ws \\<subseteq> carrier_vec ?n; corthogonal ?ws;\n   length ?ws = ?n\\<rbrakk>\n  \\<Longrightarrow> corthogonal_mat (mat_of_cols ?n ?ws)\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. corthogonal_mat W", "unfolding W_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?ws \\<subseteq> carrier_vec ?n; corthogonal ?ws;\n   length ?ws = ?n\\<rbrakk>\n  \\<Longrightarrow> corthogonal_mat (mat_of_cols ?n ?ws)\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. corthogonal_mat (mat_of_cols n ws)", "."], ["proof (state)\nthis:\n  corthogonal_mat W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have W: \"W \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat n n", "using ws"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat n n", "unfolding W_def"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. mat_of_cols n ws \\<in> carrier_mat n n", "using mat_of_cols_carrier(1)[of n ws]"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n  mat_of_cols n ws \\<in> carrier_mat n (length ws)\n\ngoal (1 subgoal):\n 1. mat_of_cols n ws \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have W': \"W' \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W' \\<in> carrier_mat n n", "unfolding W'_def corthogonal_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows (dim_row W) (map vec_inv (cols W)) \\<in> carrier_mat n n", "using W"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat_of_rows (dim_row W) (map vec_inv (cols W)) \\<in> carrier_mat n n", "by (auto simp: mat_of_rows_def)"], ["proof (state)\nthis:\n  W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from corthogonal_inv_result[OF orth_W]"], ["proof (chain)\npicking this:\n  inverts_mat (corthogonal_inv W) W", "have W'W: \"inverts_mat W' W\""], ["proof (prove)\nusing this:\n  inverts_mat (corthogonal_inv W) W\n\ngoal (1 subgoal):\n 1. inverts_mat W' W", "unfolding W'_def"], ["proof (prove)\nusing this:\n  inverts_mat (corthogonal_inv W) W\n\ngoal (1 subgoal):\n 1. inverts_mat (corthogonal_inv W) W", "."], ["proof (state)\nthis:\n  inverts_mat W' W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "hence WW': \"inverts_mat W W'\""], ["proof (prove)\nusing this:\n  inverts_mat W' W\n\ngoal (1 subgoal):\n 1. inverts_mat W W'", "using mat_mult_left_right_inverse[OF W' W] W' W"], ["proof (prove)\nusing this:\n  inverts_mat W' W\n  W' * W = 1\\<^sub>m n \\<Longrightarrow> W * W' = 1\\<^sub>m n\n  W' \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inverts_mat W W'", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  W' * W = 1\\<^sub>m (dim_row W')\n  W' * W = 1\\<^sub>m n \\<Longrightarrow> W * W' = 1\\<^sub>m n\n  W' \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W * W' = 1\\<^sub>m (dim_row W)", "by auto"], ["proof (state)\nthis:\n  inverts_mat W W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have A': \"A' \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "using W W' A"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "unfolding A'_def"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W' * A * W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have A'A_wit: \"similar_mat_wit A' A W' W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A' A W' W", "by (rule similar_mat_witI[of _ _ n], insert W W' A A' W'W WW', auto simp: A'_def\n    inverts_mat_def)"], ["proof (state)\nthis:\n  similar_mat_wit A' A W' W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "hence A'A: \"similar_mat A' A\""], ["proof (prove)\nusing this:\n  similar_mat_wit A' A W' W\n\ngoal (1 subgoal):\n 1. similar_mat A' A", "unfolding similar_mat_def"], ["proof (prove)\nusing this:\n  similar_mat_wit A' A W' W\n\ngoal (1 subgoal):\n 1. \\<exists>P. Ex (similar_mat_wit A' A P)", "by blast"], ["proof (state)\nthis:\n  similar_mat A' A\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from similar_mat_wit_sym[OF A'A_wit]"], ["proof (chain)\npicking this:\n  similar_mat_wit A A' W W'", "have simAA': \"similar_mat_wit A A' W W'\""], ["proof (prove)\nusing this:\n  similar_mat_wit A A' W W'\n\ngoal (1 subgoal):\n 1. similar_mat_wit A A' W W'", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A A' W W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have eigen[simp]: \"A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\" and v0: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v &&& v \\<noteq> 0\\<^sub>v n", "using v_def find_eigenvector[OF A e] A"], ["proof (prove)\nusing this:\n  v = find_eigenvector A e\n  eigenvector A (find_eigenvector A e) e\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v &&& v \\<noteq> 0\\<^sub>v n", "unfolding eigenvector_def"], ["proof (prove)\nusing this:\n  v = find_eigenvector A e\n  find_eigenvector A e \\<in> carrier_vec (dim_row A) \\<and>\n  find_eigenvector A e \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v find_eigenvector A e = e \\<cdot>\\<^sub>v find_eigenvector A e\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v &&& v \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "let ?f = \"(\\<lambda> i. if i = 0 then e else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have col0: \"col A' 0 = vec n ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "unfolding A'_def W'_def W_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (corthogonal_inv (mat_of_cols n ws) * A * mat_of_cols n ws) 0 =\n    vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "using corthogonal_col_ev_0[OF A v v0 eigen n hdws ws]"], ["proof (prove)\nusing this:\n  col (corthogonal_inv (mat_of_cols n ws) * A * mat_of_cols n ws) 0 =\n  vec n (\\<lambda>i. if i = 0 then e else (0::'a))\n\ngoal (1 subgoal):\n 1. col (corthogonal_inv (mat_of_cols n ws) * A * mat_of_cols n ws) 0 =\n    vec n (\\<lambda>i. if i = 0 then e else (0::'a))", "."], ["proof (state)\nthis:\n  col A' 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from A' n"], ["proof (chain)\npicking this:\n  A' \\<in> carrier_mat n n\n  n \\<noteq> 0", "have \"dim_row A' = 1 + ?n1\" \"dim_col A' = 1 + ?n1\""], ["proof (prove)\nusing this:\n  A' \\<in> carrier_mat n n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dim_row A' = 1 + (n - 1) &&& dim_col A' = 1 + (n - 1)", "by auto"], ["proof (state)\nthis:\n  dim_row A' = 1 + (n - 1)\n  dim_col A' = 1 + (n - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from split_block[OF splitA' this]"], ["proof (chain)\npicking this:\n  A1 \\<in> carrier_mat 1 1\n  A2 \\<in> carrier_mat 1 (n - 1)\n  A0 \\<in> carrier_mat (n - 1) 1\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  A' = four_block_mat A1 A2 A0 A3", "have A2: \"A2 \\<in> carrier_mat 1 ?n1\"\n    and A3: \"A3 \\<in> carrier_mat ?n1 ?n1\" \n    and A'block: \"A' = four_block_mat A1 A2 A0 A3\""], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat 1 1\n  A2 \\<in> carrier_mat 1 (n - 1)\n  A0 \\<in> carrier_mat (n - 1) 1\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  A' = four_block_mat A1 A2 A0 A3\n\ngoal (1 subgoal):\n 1. A2 \\<in> carrier_mat 1 (n - 1) &&&\n    A3 \\<in> carrier_mat (n - 1) (n - 1) &&& A' = four_block_mat A1 A2 A0 A3", "by auto"], ["proof (state)\nthis:\n  A2 \\<in> carrier_mat 1 (n - 1)\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  A' = four_block_mat A1 A2 A0 A3\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have A1id: \"A1 = mat 1 1 (\\<lambda> _. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 = mat 1 1 (\\<lambda>_. e)", "using splitA'[unfolded split_block_def Let_def] arg_cong[OF col0, of \"\\<lambda> v. v $ 0\"] A' n"], ["proof (prove)\nusing this:\n  (mat 1 1 (($$) A'),\n   mat 1 (dim_col A' - 1) (\\<lambda>(i, j). A' $$ (i, j + 1)),\n   mat (dim_row A' - 1) 1 (\\<lambda>(i, j). A' $$ (i + 1, j)),\n   mat (dim_row A' - 1) (dim_col A' - 1)\n    (\\<lambda>(i, j). A' $$ (i + 1, j + 1))) =\n  (A1, A2, A0, A3)\n  col A' 0 $ 0 = vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ 0\n  A' \\<in> carrier_mat n n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A1 = mat 1 1 (\\<lambda>_. e)", "by (auto simp: col_def)"], ["proof (state)\nthis:\n  A1 = mat 1 1 (\\<lambda>_. e)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have A1: \"A1 \\<in> carrier_mat 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 \\<in> carrier_mat 1 1", "unfolding A1id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 1 (\\<lambda>_. e) \\<in> carrier_mat 1 1", "by auto"], ["proof (state)\nthis:\n  A1 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "{"], ["proof (state)\nthis:\n  A1 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "assume \"i < ?n1\""], ["proof (state)\nthis:\n  i < n - 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "with arg_cong[OF col0, of \"\\<lambda> v. v $ Suc i\"] A'"], ["proof (chain)\npicking this:\n  col A' 0 $ Suc i =\n  vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ Suc i\n  A' \\<in> carrier_mat n n\n  i < n - 1", "have \"A' $$ (Suc i, 0) = 0\""], ["proof (prove)\nusing this:\n  col A' 0 $ Suc i =\n  vec n (\\<lambda>i. if i = 0 then e else (0::'a)) $ Suc i\n  A' \\<in> carrier_mat n n\n  i < n - 1\n\ngoal (1 subgoal):\n 1. A' $$ (Suc i, 0) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A' $$ (Suc i, 0) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "}"], ["proof (state)\nthis:\n  ?i4 < n - 1 \\<Longrightarrow> A' $$ (Suc ?i4, 0) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "note A'0 = this"], ["proof (state)\nthis:\n  ?i4 < n - 1 \\<Longrightarrow> A' $$ (Suc ?i4, 0) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have A0id: \"A0 = 0\\<^sub>m ?n1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 = 0\\<^sub>m (n - 1) 1", "using splitA'[unfolded split_block_def Let_def] A'0 A'"], ["proof (prove)\nusing this:\n  (mat 1 1 (($$) A'),\n   mat 1 (dim_col A' - 1) (\\<lambda>(i, j). A' $$ (i, j + 1)),\n   mat (dim_row A' - 1) 1 (\\<lambda>(i, j). A' $$ (i + 1, j)),\n   mat (dim_row A' - 1) (dim_col A' - 1)\n    (\\<lambda>(i, j). A' $$ (i + 1, j + 1))) =\n  (A1, A2, A0, A3)\n  ?i4 < n - 1 \\<Longrightarrow> A' $$ (Suc ?i4, 0) = (0::'a)\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A0 = 0\\<^sub>m (n - 1) 1", "by auto"], ["proof (state)\nthis:\n  A0 = 0\\<^sub>m (n - 1) 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have A0: \"A0 \\<in> carrier_mat ?n1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 \\<in> carrier_mat (n - 1) 1", "unfolding A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m (n - 1) 1 \\<in> carrier_mat (n - 1) 1", "by auto"], ["proof (state)\nthis:\n  A0 \\<in> carrier_mat (n - 1) 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from cp char_poly_similar[OF A'A]"], ["proof (chain)\npicking this:\n  char_poly A = [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n  char_poly A' = char_poly A", "have cp: \"char_poly A' = [: -e,1 :] * (\\<Prod> e \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\nusing this:\n  char_poly A = [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n  char_poly A' = char_poly A\n\ngoal (1 subgoal):\n 1. char_poly A' = [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  char_poly A' = [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "also"], ["proof (state)\nthis:\n  char_poly A' = [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have \"char_poly A' = char_poly A1 * char_poly A3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A' = char_poly A1 * char_poly A3", "unfolding A'block A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m (n - 1) 1) A3) =\n    char_poly A1 * char_poly A3", "by (rule char_poly_four_block_zeros_col[OF A1 A2 A3])"], ["proof (state)\nthis:\n  char_poly A' = char_poly A1 * char_poly A3\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "also"], ["proof (state)\nthis:\n  char_poly A' = char_poly A1 * char_poly A3\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have \"char_poly A1 = [: -e,1 :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A1 = [:- e, 1::'a:]", "by (simp add: A1id char_poly_defs det_def signof_def sign_def)"], ["proof (state)\nthis:\n  char_poly A1 = [:- e, 1::'a:]\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "finally"], ["proof (chain)\npicking this:\n  [:- e, 1::'a:] * char_poly A3 =\n  [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])", "have cp: \"char_poly A3 = (\\<Prod> e \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\nusing this:\n  [:- e, 1::'a:] * char_poly A3 =\n  [:- e, 1::'a:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A3 = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])", "by (metis mult_cancel_left pCons_eq_0_iff zero_neq_one)"], ["proof (state)\nthis:\n  char_poly A3 = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from Cons(1)[OF A3 cp schur]"], ["proof (chain)\npicking this:\n  similar_mat_wit A3 B P' Q' \\<and>\n  upper_triangular B \\<and> diag_mat B = es", "have simIH: \"similar_mat_wit A3 B P' Q'\" and ut: \"upper_triangular B\" and diag: \"diag_mat B = es\""], ["proof (prove)\nusing this:\n  similar_mat_wit A3 B P' Q' \\<and>\n  upper_triangular B \\<and> diag_mat B = es\n\ngoal (1 subgoal):\n 1. similar_mat_wit A3 B P' Q' &&& upper_triangular B &&& diag_mat B = es", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A3 B P' Q'\n  upper_triangular B\n  diag_mat B = es\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from similar_mat_witD2[OF A3 simIH]"], ["proof (chain)\npicking this:\n  P' * Q' = 1\\<^sub>m (n - 1)\n  Q' * P' = 1\\<^sub>m (n - 1)\n  A3 = P' * B * Q'\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  B \\<in> carrier_mat (n - 1) (n - 1)\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n  Q' \\<in> carrier_mat (n - 1) (n - 1)", "have B: \"B \\<in> carrier_mat ?n1 ?n1\" and P': \"P' \\<in> carrier_mat ?n1 ?n1\" and Q': \"Q' \\<in> carrier_mat ?n1 ?n1\" \n    and PQ': \"P' * Q' = 1\\<^sub>m ?n1\""], ["proof (prove)\nusing this:\n  P' * Q' = 1\\<^sub>m (n - 1)\n  Q' * P' = 1\\<^sub>m (n - 1)\n  A3 = P' * B * Q'\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  B \\<in> carrier_mat (n - 1) (n - 1)\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n  Q' \\<in> carrier_mat (n - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. (B \\<in> carrier_mat (n - 1) (n - 1) &&&\n     P' \\<in> carrier_mat (n - 1) (n - 1)) &&&\n    Q' \\<in> carrier_mat (n - 1) (n - 1) &&& P' * Q' = 1\\<^sub>m (n - 1)", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat (n - 1) (n - 1)\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n  Q' \\<in> carrier_mat (n - 1) (n - 1)\n  P' * Q' = 1\\<^sub>m (n - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have A0_eq: \"A0 = P' * A0 * 1\\<^sub>m 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 = P' * A0 * 1\\<^sub>m 1", "unfolding A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m (n - 1) 1 = P' * 0\\<^sub>m (n - 1) 1 * 1\\<^sub>m 1", "using P'"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m (n - 1) 1 = P' * 0\\<^sub>m (n - 1) 1 * 1\\<^sub>m 1", "by auto"], ["proof (state)\nthis:\n  A0 = P' * A0 * 1\\<^sub>m 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have simA'C: \"similar_mat_wit A' C ?P' ?Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A' C\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P')\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) Q')", "unfolding A'block C"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (four_block_mat A1 A2 A0 A3)\n     (four_block_mat A1 (A2 * P') A0 B)\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P')\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) Q')", "by (rule similar_mat_wit_four_block[OF similar_mat_wit_refl[OF A1] simIH _ A0_eq A1 A3 A0],\n    insert PQ' A2 P' Q', auto)"], ["proof (state)\nthis:\n  similar_mat_wit A' C\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P')\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q')\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have ut1: \"upper_triangular A1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular A1", "unfolding A1id"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (mat 1 1 (\\<lambda>_. e))", "by auto"], ["proof (state)\nthis:\n  upper_triangular A1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "have ut: \"upper_triangular C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular C", "unfolding C A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (four_block_mat A1 (A2 * P') (0\\<^sub>m (n - 1) 1) B)", "by (intro upper_triangular_four_block[OF _ B ut1 ut], auto simp: A1id)"], ["proof (state)\nthis:\n  upper_triangular C\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from A1id"], ["proof (chain)\npicking this:\n  A1 = mat 1 1 (\\<lambda>_. e)", "have diagA1: \"diag_mat A1 = [e]\""], ["proof (prove)\nusing this:\n  A1 = mat 1 1 (\\<lambda>_. e)\n\ngoal (1 subgoal):\n 1. diag_mat A1 = [e]", "unfolding diag_mat_def"], ["proof (prove)\nusing this:\n  A1 = mat 1 1 (\\<lambda>_. e)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. A1 $$ (i, i)) [0..<dim_row A1] = [e]", "by auto"], ["proof (state)\nthis:\n  diag_mat A1 = [e]\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from diag_four_block_mat[OF A1 B]"], ["proof (chain)\npicking this:\n  diag_mat (four_block_mat A1 ?B ?C B) = diag_mat A1 @ diag_mat B", "have diag: \"diag_mat C = e # es\""], ["proof (prove)\nusing this:\n  diag_mat (four_block_mat A1 ?B ?C B) = diag_mat A1 @ diag_mat B\n\ngoal (1 subgoal):\n 1. diag_mat C = e # es", "unfolding diag diagA1 C"], ["proof (prove)\nusing this:\n  diag_mat (four_block_mat A1 ?B ?C B) = [e] @ es\n\ngoal (1 subgoal):\n 1. diag_mat (four_block_mat A1 (A2 * P') A0 B) = e # es", "by simp"], ["proof (state)\nthis:\n  diag_mat C = e # es\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1::'a:]);\n                    schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1::'a:]);\n        schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and> diag_mat B = a # es", "from ut similar_mat_wit_trans[OF simAA' simA'C, folded P Q] diag"], ["proof (chain)\npicking this:\n  upper_triangular C\n  similar_mat_wit A C P Q\n  diag_mat C = e # es", "show ?case"], ["proof (prove)\nusing this:\n  upper_triangular C\n  similar_mat_wit A C P Q\n  diag_mat C = e # es\n\ngoal (1 subgoal):\n 1. similar_mat_wit A C P Q \\<and>\n    upper_triangular C \\<and> diag_mat C = e # es", "by blast"], ["proof (state)\nthis:\n  similar_mat_wit A C P Q \\<and>\n  upper_triangular C \\<and> diag_mat C = e # es\n\ngoal:\nNo subgoals!", "qed"], ["", "definition schur_upper_triangular :: \"'a::conjugatable_field mat \\<Rightarrow> 'a list \\<Rightarrow> 'a mat\" where \n  \"schur_upper_triangular A es = (case schur_decomposition A es of (B,_,_) \\<Rightarrow> B)\""], ["", "lemma schur_upper_triangular:\n  assumes A: \"(A :: 'a :: conjugatable_ordered_field mat) \\<in> carrier_mat n n\"\n  and linear: \"char_poly A = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  defines B: \"B \\<equiv> schur_upper_triangular A es\"\n  shows \"B \\<in> carrier_mat n n\" \"upper_triangular B\" \"similar_mat A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n &&& upper_triangular B &&& similar_mat A B", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. B \\<in> carrier_mat n n\n 2. upper_triangular B\n 3. similar_mat A B", "let ?B = \"schur_upper_triangular A es\""], ["proof (state)\ngoal (3 subgoals):\n 1. B \\<in> carrier_mat n n\n 2. upper_triangular B\n 3. similar_mat A B", "obtain C P Q where schur: \"schur_decomposition A es = (C,P,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C P Q.\n        schur_decomposition A es = (C, P, Q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"schur_decomposition A es\", auto)"], ["proof (state)\nthis:\n  schur_decomposition A es = (C, P, Q)\n\ngoal (3 subgoals):\n 1. B \\<in> carrier_mat n n\n 2. upper_triangular B\n 3. similar_mat A B", "hence B: \"B = C\""], ["proof (prove)\nusing this:\n  schur_decomposition A es = (C, P, Q)\n\ngoal (1 subgoal):\n 1. B = C", "using A"], ["proof (prove)\nusing this:\n  schur_decomposition A es = (C, P, Q)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B = C", "unfolding schur_upper_triangular_def B"], ["proof (prove)\nusing this:\n  schur_decomposition A es = (C, P, Q)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (case schur_decomposition A es of (B, xa, xaa) \\<Rightarrow> B) = C", "by auto"], ["proof (state)\nthis:\n  B = C\n\ngoal (3 subgoals):\n 1. B \\<in> carrier_mat n n\n 2. upper_triangular B\n 3. similar_mat A B", "from schur_decomposition[OF A linear schur]"], ["proof (chain)\npicking this:\n  similar_mat_wit A C P Q \\<and> upper_triangular C \\<and> diag_mat C = es", "have sim: \"similar_mat_wit A B P Q\" and B: \"upper_triangular B\""], ["proof (prove)\nusing this:\n  similar_mat_wit A C P Q \\<and> upper_triangular C \\<and> diag_mat C = es\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q &&& upper_triangular B", "unfolding B"], ["proof (prove)\nusing this:\n  similar_mat_wit A C P Q \\<and> upper_triangular C \\<and> diag_mat C = es\n\ngoal (1 subgoal):\n 1. similar_mat_wit A C P Q &&& upper_triangular C", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P Q\n  upper_triangular B\n\ngoal (3 subgoals):\n 1. B \\<in> carrier_mat n n\n 2. upper_triangular B\n 3. similar_mat A B", "from sim"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P Q", "show \"similar_mat A B\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P Q\n\ngoal (1 subgoal):\n 1. similar_mat A B", "unfolding similar_mat_def"], ["proof (prove)\nusing this:\n  similar_mat_wit A B P Q\n\ngoal (1 subgoal):\n 1. \\<exists>P. Ex (similar_mat_wit A B P)", "by auto"], ["proof (state)\nthis:\n  similar_mat A B\n\ngoal (2 subgoals):\n 1. B \\<in> carrier_mat n n\n 2. upper_triangular B", "from similar_mat_witD2[OF A sim]"], ["proof (chain)\npicking this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n", "show \"B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. upper_triangular B", "show \"upper_triangular B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular B", "by fact"], ["proof (state)\nthis:\n  upper_triangular B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma schur_decomposition_exists: assumes A: \"A \\<in> carrier_mat n n\"\n  and linear: \"char_poly A = (\\<Prod> (a :: 'a :: conjugatable_ordered_field) \\<leftarrow> es. [:- a, 1:])\"\n  shows \"\\<exists> B \\<in> carrier_mat n n. upper_triangular B \\<and> similar_mat A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B\\<in>carrier_mat n n.\n       upper_triangular B \\<and> similar_mat A B", "using schur_upper_triangular[OF A linear]"], ["proof (prove)\nusing this:\n  schur_upper_triangular A es \\<in> carrier_mat n n\n  upper_triangular (schur_upper_triangular A es)\n  similar_mat A (schur_upper_triangular A es)\n\ngoal (1 subgoal):\n 1. \\<exists>B\\<in>carrier_mat n n.\n       upper_triangular B \\<and> similar_mat A B", "by blast"], ["", "lemma char_poly_0_block: fixes A :: \"'a :: conjugatable_ordered_field mat\"\n  assumes A: \"A = four_block_mat B C (0\\<^sub>m m n) D\"\n  and linearB: \"\\<exists> es. char_poly B = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and linearD: \"\\<exists> es. char_poly D = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and C: \"C \\<in> carrier_mat n m\"\n  and D: \"D \\<in> carrier_mat m m\"\n  shows \"char_poly A = char_poly B * char_poly D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from linearB"], ["proof (chain)\npicking this:\n  \\<exists>es. char_poly B = (\\<Prod>a\\<leftarrow>es. [:- a, 1::'a:])", "obtain bs where cB: \"char_poly B = (\\<Prod>a\\<leftarrow>bs. [:- a, 1:])\""], ["proof (prove)\nusing this:\n  \\<exists>es. char_poly B = (\\<Prod>a\\<leftarrow>es. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        char_poly B =\n        (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly B = (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from linearD"], ["proof (chain)\npicking this:\n  \\<exists>es. char_poly D = (\\<Prod>a\\<leftarrow>es. [:- a, 1::'a:])", "obtain ds where cD: \"char_poly D = (\\<Prod>a\\<leftarrow>ds. [:- a, 1:])\""], ["proof (prove)\nusing this:\n  \\<exists>es. char_poly D = (\\<Prod>a\\<leftarrow>es. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. (\\<And>ds.\n        char_poly D =\n        (\\<Prod>a\\<leftarrow>ds. [:- a, 1::'a:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly D = (\\<Prod>a\\<leftarrow>ds. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from schur_decomposition_exists[OF B cB]"], ["proof (chain)\npicking this:\n  \\<exists>Ba\\<in>carrier_mat n n.\n     upper_triangular Ba \\<and> similar_mat B Ba", "obtain B' PB QB where sB: \"schur_decomposition B bs = (B',PB,QB)\""], ["proof (prove)\nusing this:\n  \\<exists>Ba\\<in>carrier_mat n n.\n     upper_triangular Ba \\<and> similar_mat B Ba\n\ngoal (1 subgoal):\n 1. (\\<And>B' PB QB.\n        schur_decomposition B bs = (B', PB, QB) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"schur_decomposition B bs\", auto)"], ["proof (state)\nthis:\n  schur_decomposition B bs = (B', PB, QB)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "obtain D' PD QD where sD: \"schur_decomposition D ds = (D',PD,QD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D' PD QD.\n        schur_decomposition D ds = (D', PD, QD) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"schur_decomposition D ds\", auto)"], ["proof (state)\nthis:\n  schur_decomposition D ds = (D', PD, QD)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from schur_decomposition[OF B cB sB] similar_mat_witD2[OF B, of B']"], ["proof (chain)\npicking this:\n  similar_mat_wit B B' PB QB \\<and>\n  upper_triangular B' \\<and> diag_mat B' = bs\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?P * ?Q = 1\\<^sub>m n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?Q * ?P = 1\\<^sub>m n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> B = ?P * B' * ?Q\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> B \\<in> carrier_mat n n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> B' \\<in> carrier_mat n n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?P \\<in> carrier_mat n n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?Q \\<in> carrier_mat n n", "have \n    simB: \"similar_mat B B'\" and utB: \"upper_triangular B'\" and diagB: \"diag_mat B' = bs\"\n    and B': \"B' \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  similar_mat_wit B B' PB QB \\<and>\n  upper_triangular B' \\<and> diag_mat B' = bs\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?P * ?Q = 1\\<^sub>m n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?Q * ?P = 1\\<^sub>m n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> B = ?P * B' * ?Q\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> B \\<in> carrier_mat n n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> B' \\<in> carrier_mat n n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?P \\<in> carrier_mat n n\n  similar_mat_wit B B' ?P ?Q \\<Longrightarrow> ?Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (similar_mat B B' &&& upper_triangular B') &&&\n    diag_mat B' = bs &&& B' \\<in> carrier_mat n n", "by (auto simp: similar_mat_def)"], ["proof (state)\nthis:\n  similar_mat B B'\n  upper_triangular B'\n  diag_mat B' = bs\n  B' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from schur_decomposition[OF D cD sD] similar_mat_witD2[OF D, of D']"], ["proof (chain)\npicking this:\n  similar_mat_wit D D' PD QD \\<and>\n  upper_triangular D' \\<and> diag_mat D' = ds\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?P * ?Q = 1\\<^sub>m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?Q * ?P = 1\\<^sub>m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> D = ?P * D' * ?Q\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> D \\<in> carrier_mat m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> D' \\<in> carrier_mat m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?P \\<in> carrier_mat m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?Q \\<in> carrier_mat m m", "have \n    simD: \"similar_mat D D'\" and utD: \"upper_triangular D'\" and diagD: \"diag_mat D' = ds\"\n    and D': \"D' \\<in> carrier_mat m m\""], ["proof (prove)\nusing this:\n  similar_mat_wit D D' PD QD \\<and>\n  upper_triangular D' \\<and> diag_mat D' = ds\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?P * ?Q = 1\\<^sub>m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?Q * ?P = 1\\<^sub>m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> D = ?P * D' * ?Q\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> D \\<in> carrier_mat m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> D' \\<in> carrier_mat m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?P \\<in> carrier_mat m m\n  similar_mat_wit D D' ?P ?Q \\<Longrightarrow> ?Q \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. (similar_mat D D' &&& upper_triangular D') &&&\n    diag_mat D' = ds &&& D' \\<in> carrier_mat m m", "by (auto simp: similar_mat_def)"], ["proof (state)\nthis:\n  similar_mat D D'\n  upper_triangular D'\n  diag_mat D' = ds\n  D' \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?z = \"0\\<^sub>m m n\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from similar_mat_four_block_0_ex[OF simB simD C B D, folded A]"], ["proof (chain)\npicking this:\n  \\<exists>B0.\n     B0 \\<in> carrier_mat n m \\<and>\n     similar_mat A (four_block_mat B' B0 (0\\<^sub>m m n) D')", "obtain B0 where B0: \"B0 \\<in> carrier_mat n m\" and sim: \"similar_mat A (four_block_mat B' B0 ?z D')\""], ["proof (prove)\nusing this:\n  \\<exists>B0.\n     B0 \\<in> carrier_mat n m \\<and>\n     similar_mat A (four_block_mat B' B0 (0\\<^sub>m m n) D')\n\ngoal (1 subgoal):\n 1. (\\<And>B0.\n        \\<lbrakk>B0 \\<in> carrier_mat n m;\n         similar_mat A (four_block_mat B' B0 (0\\<^sub>m m n) D')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B0 \\<in> carrier_mat n m\n  similar_mat A (four_block_mat B' B0 (0\\<^sub>m m n) D')\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?block = \"four_block_mat B' B0 ?z D'\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?cp = char_poly"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?prod = \"QB * C * PD\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?diag = \"\\<lambda> A. (\\<Prod>a\\<leftarrow>diag_mat A. [:- a, 1:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from char_poly_similar[OF sim]"], ["proof (chain)\npicking this:\n  char_poly A = char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D')", "have \"?cp A = ?cp ?block\""], ["proof (prove)\nusing this:\n  char_poly A = char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D')\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D')", "by simp"], ["proof (state)\nthis:\n  char_poly A = char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D')\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  char_poly A = char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D')\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"\\<dots> = ?diag ?block\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D') =\n    (\\<Prod>a\\<leftarrow>diag_mat\n                          (four_block_mat B' B0 (0\\<^sub>m m n)\n                            D'). [:- a, 1::'a:])", "by (rule char_poly_upper_triangular[OF four_block_carrier_mat[OF B' D'] upper_triangular_four_block[OF B' D' utB utD]])"], ["proof (state)\nthis:\n  char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D') =\n  (\\<Prod>a\\<leftarrow>diag_mat\n                        (four_block_mat B' B0 (0\\<^sub>m m n)\n                          D'). [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  char_poly (four_block_mat B' B0 (0\\<^sub>m m n) D') =\n  (\\<Prod>a\\<leftarrow>diag_mat\n                        (four_block_mat B' B0 (0\\<^sub>m m n)\n                          D'). [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"\\<dots> = ?diag B' * ?diag D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>diag_mat\n                          (four_block_mat B' B0 (0\\<^sub>m m n)\n                            D'). [:- a, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>diag_mat B'. [:- a, 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>diag_mat D'. [:- a, 1::'a:])", "unfolding diag_four_block_mat[OF B' D']"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>diag_mat B' @ diag_mat D'. [:- a, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>diag_mat B'. [:- a, 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>diag_mat D'. [:- a, 1::'a:])", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>diag_mat\n                        (four_block_mat B' B0 (0\\<^sub>m m n)\n                          D'). [:- a, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>diag_mat B'. [:- a, 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>diag_mat D'. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>diag_mat\n                        (four_block_mat B' B0 (0\\<^sub>m m n)\n                          D'). [:- a, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>diag_mat B'. [:- a, 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>diag_mat D'. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"?diag B' = ?cp B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>diag_mat B'. [:- a, 1::'a:]) = char_poly B'", "by (subst char_poly_upper_triangular[OF B' utB], simp)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>diag_mat B'. [:- a, 1::'a:]) = char_poly B'\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>diag_mat B'. [:- a, 1::'a:]) = char_poly B'\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"\\<dots> = ?cp B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly B' = char_poly B", "by (rule char_poly_similar[OF similar_mat_sym[OF simB]])"], ["proof (state)\nthis:\n  char_poly B' = char_poly B\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  char_poly B' = char_poly B\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"?diag D' = ?cp D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>diag_mat D'. [:- a, 1::'a:]) = char_poly D'", "by (subst char_poly_upper_triangular[OF D' utD], simp)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>diag_mat D'. [:- a, 1::'a:]) = char_poly D'\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>diag_mat D'. [:- a, 1::'a:]) = char_poly D'\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"\\<dots> = ?cp D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly D' = char_poly D", "by (rule char_poly_similar[OF similar_mat_sym[OF simD]])"], ["proof (state)\nthis:\n  char_poly D' = char_poly D\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "finally"], ["proof (chain)\npicking this:\n  char_poly A = char_poly B * char_poly D", "show ?thesis"], ["proof (prove)\nusing this:\n  char_poly A = char_poly B * char_poly D\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "."], ["proof (state)\nthis:\n  char_poly A = char_poly B * char_poly D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_0_block': fixes A :: \"'a :: conjugatable_ordered_field mat\"\n  assumes A: \"A = four_block_mat B (0\\<^sub>m n m) C D\"\n  and linearB: \"\\<exists> es. char_poly B = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and linearD: \"\\<exists> es. char_poly D = (\\<Prod> a \\<leftarrow> es. [:- a, 1:])\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and C: \"C \\<in> carrier_mat m n\"\n  and D: \"D \\<in> carrier_mat m m\"\n  shows \"char_poly A = char_poly B * char_poly D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?A = \"four_block_mat B (0\\<^sub>m n m) C D\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?B = \"transpose_mat B\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "let ?D = \"transpose_mat D\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have AC: \"?A \\<in> carrier_mat (n + m) (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat B (0\\<^sub>m n m) C D \\<in> carrier_mat (n + m) (n + m)", "using B D"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  D \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. four_block_mat B (0\\<^sub>m n m) C D \\<in> carrier_mat (n + m) (n + m)", "by auto"], ["proof (state)\nthis:\n  four_block_mat B (0\\<^sub>m n m) C D \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "from arg_cong[OF transpose_four_block_mat[OF B zero_carrier_mat C D], of char_poly,\n    unfolded char_poly_transpose_mat[OF AC], folded A]"], ["proof (chain)\npicking this:\n  char_poly A =\n  char_poly\n   (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m n m)\\<^sup>T D\\<^sup>T)", "have \"char_poly A =\n    char_poly (four_block_mat ?B (transpose_mat C) (0\\<^sub>m m n) ?D)\""], ["proof (prove)\nusing this:\n  char_poly A =\n  char_poly\n   (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m n m)\\<^sup>T D\\<^sup>T)\n\ngoal (1 subgoal):\n 1. char_poly A =\n    char_poly (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m m n) D\\<^sup>T)", "by auto"], ["proof (state)\nthis:\n  char_poly A =\n  char_poly (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m m n) D\\<^sup>T)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  char_poly A =\n  char_poly (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m m n) D\\<^sup>T)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"\\<dots> = char_poly ?B * char_poly ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly\n     (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m m n) D\\<^sup>T) =\n    char_poly B\\<^sup>T * char_poly D\\<^sup>T", "by (rule char_poly_0_block[OF refl], insert B C D linearB linearD, auto)"], ["proof (state)\nthis:\n  char_poly (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m m n) D\\<^sup>T) =\n  char_poly B\\<^sup>T * char_poly D\\<^sup>T\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "also"], ["proof (state)\nthis:\n  char_poly (four_block_mat B\\<^sup>T C\\<^sup>T (0\\<^sub>m m n) D\\<^sup>T) =\n  char_poly B\\<^sup>T * char_poly D\\<^sup>T\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "have \"\\<dots> = char_poly B * char_poly D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly B\\<^sup>T * char_poly D\\<^sup>T = char_poly B * char_poly D", "using B D"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  D \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. char_poly B\\<^sup>T * char_poly D\\<^sup>T = char_poly B * char_poly D", "by simp"], ["proof (state)\nthis:\n  char_poly B\\<^sup>T * char_poly D\\<^sup>T = char_poly B * char_poly D\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "finally"], ["proof (chain)\npicking this:\n  char_poly A = char_poly B * char_poly D", "show ?thesis"], ["proof (prove)\nusing this:\n  char_poly A = char_poly B * char_poly D\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "."], ["proof (state)\nthis:\n  char_poly A = char_poly B * char_poly D\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}