{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Jordan_Normal_Form.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma jordan_block_index[simp]: \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> \n  jordan_block n a $$ (i,j) = (if i = j then a else if Suc i = j then 1 else 0)\"\n  \"dim_row (jordan_block n k) = n\"\n  \"dim_col (jordan_block n k) = n\"", "lemma jordan_block_carrier[simp]: \"jordan_block n k \\<in> carrier_mat n n\"", "lemma jordan_block_char_poly: \"char_poly (jordan_block n a) = [: -a, 1:]^n\"", "lemma jordan_block_pow_carrier[simp]:\n  \"jordan_block n a ^\\<^sub>m r \\<in> carrier_mat n n\"", "lemma jordan_block_pow_dim[simp]:\n  \"dim_row (jordan_block n a ^\\<^sub>m r) = n\" \"dim_col (jordan_block n a ^\\<^sub>m r) = n\"", "lemma jordan_block_pow: \"(jordan_block n (a :: 'a :: comm_ring_1)) ^\\<^sub>m r = \n  mat n n (\\<lambda> (i,j). if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j) else 0)\"", "lemma jordan_matrix_dim[simp]: \n  \"dim_row (jordan_matrix n_as) = sum_list (map fst n_as)\"\n  \"dim_col (jordan_matrix n_as) = sum_list (map fst n_as)\"", "lemma jordan_matrix_carrier[simp]: \n  \"jordan_matrix n_as \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))\"", "lemma jordan_matrix_upper_triangular: \"i < sum_list (map fst n_as)\n  \\<Longrightarrow> j < i \\<Longrightarrow> jordan_matrix n_as $$ (i,j) = 0\"", "lemma jordan_matrix_pow: \"(jordan_matrix n_as) ^\\<^sub>m r = \n  diag_block_mat (map (\\<lambda> (n,a). (jordan_block n a) ^\\<^sub>m r) n_as)\"", "lemma jordan_matrix_char_poly: \n  \"char_poly (jordan_matrix n_as) = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\"", "lemma jordan_nf_powE: assumes A: \"A \\<in> carrier_mat n n\" and jnf: \"jordan_nf A n_as\" \n  obtains P Q where \"P \\<in> carrier_mat n n\" \"Q \\<in> carrier_mat n n\" and \n  \"char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1:] ^ na)\"\n  \"\\<And> k. A ^\\<^sub>m k = P * (jordan_matrix n_as)^\\<^sub>m k * Q\"", "lemma choose_poly_bound: assumes \"i \\<le> d\"\n  shows \"r choose i \\<le> max 1 (r^d)\"", "lemma poly_exp_constant_bound: \"\\<exists> p. \\<forall> x. c * b ^ x * of_nat x ^ deg \\<le> p\"", "lemma poly_exp_max_constant_bound: \"\\<exists> p. \\<forall> x. c * b ^ x * max 1 (of_nat x ^ deg) \\<le> p\"", "lemma jordan_block_bound: \n  assumes i: \"i < n\" and j: \"j < n\"\n  shows \"norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)) \n    \\<le> norm a ^ (k + i - j) * max 1 (of_nat k ^ (n - 1))\"\n    (is \"?lhs \\<le> ?rhs\")", "lemma jordan_block_poly_bound: \n  assumes i: \"i < n\" and j: \"j < n\" and a: \"norm a = 1\"\n  shows \"norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)) \\<le> max 1 (of_nat k ^ (n - 1))\"\n    (is \"?lhs \\<le> ?rhs\")", "theorem jordan_block_constant_bound: assumes a: \"norm a < 1\" \n  shows \"\\<exists> p. \\<forall> i j k. i < n \\<longrightarrow> j < n \\<longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)) \\<le> p\"", "lemma norm_boundI[intro]:\n  assumes \"\\<And> i j. i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> norm (A $$ (i,j)) \\<le> b\"\n  shows \"norm_bound A b\"", "lemma  jordan_block_constant_bound2:\n\"\\<exists>p. norm (a :: 'a :: real_normed_field) < 1 \\<longrightarrow>\n    (\\<forall>i j k. i < n \\<longrightarrow> j < n \\<longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p)\"", "lemma jordan_matrix_poly_bound2:\n  fixes n_as :: \"(nat \\<times> 'a) list\"\n  assumes n_as: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> n > 0 \\<Longrightarrow> norm a \\<le> 1\"\n  and N: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> n \\<le> N\"\n  shows \"\\<exists>c1. \\<forall>k. \\<forall>e \\<in> elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n    norm e \\<le> c1 + of_nat k ^ (N - 1)\"", "lemma norm_bound_bridge:\n  \"\\<forall>e \\<in> elements_mat A. norm e \\<le> b \\<Longrightarrow> norm_bound A b\"", "lemma norm_bound_mult: assumes A1: \"A1 \\<in> carrier_mat nr n\"\n  and A2: \"A2 \\<in> carrier_mat n nc\"\n  and b1: \"norm_bound A1 b1\"\n  and b2: \"norm_bound A2 b2\"\n  shows \"norm_bound (A1 * A2) (b1 * b2 * of_nat n)\"", "lemma norm_bound_max: \"norm_bound A (Max {norm (A $$ (i,j)) | i j. i < dim_row A \\<and> j < dim_col A})\" \n  (is \"norm_bound A (Max ?norms)\")", "lemma jordan_matrix_poly_bound: fixes n_as :: \"(nat \\<times> 'a)list\"\n  assumes n_as: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> n > 0 \\<Longrightarrow> norm a \\<le> 1\"\n  and N: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> n \\<le> N\"\n  shows \"\\<exists> c1. \\<forall> k. norm_bound (jordan_matrix n_as ^\\<^sub>m k) (c1 + of_nat k ^ (N - 1))\"", "lemma jordan_nf_matrix_poly_bound: fixes n_as :: \"(nat \\<times> 'a)list\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n  and n_as: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> n > 0 \\<Longrightarrow> norm a \\<le> 1\"\n  and N: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> n \\<le> N\"\n  and jnf: \"jordan_nf A n_as\"\n  shows \"\\<exists> c1 c2. \\<forall> k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * of_nat k ^ (N - 1))\"", "lemma char_matrix_jordan_block: \"char_matrix (jordan_block n a) b = (jordan_block n (a - b))\"", "lemma diag_jordan_block_pow: \"diag_mat (jordan_block n (a :: 'a) ^\\<^sub>m k) = replicate n (a ^ k)\"", "lemma jordan_block_zero_pow: \"(jordan_block n (0 :: 'a)) ^\\<^sub>m k = \n  (mat n n (\\<lambda> (i,j). if j \\<ge> i \\<and> j - i = k then 1 else 0))\"", "lemma jordan_matrix_concat_diag_block_mat: \"jordan_matrix (concat jbs) = diag_block_mat (map jordan_matrix jbs)\"", "lemma jordan_nf_diag_block_mat: assumes Ms: \"\\<And> A jbs. (A,jbs) \\<in> set Ms \\<Longrightarrow> jordan_nf A jbs\"\n  shows \"jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))\"", "lemma jordan_nf_char_poly: assumes \"jordan_nf A n_as\"\n  shows \"char_poly A = (\\<Prod> (n,a) \\<leftarrow> n_as. [:- a, 1:] ^ n)\"", "lemma jordan_nf_block_size_order_bound: assumes jnf: \"jordan_nf A n_as\"\n  and mem: \"(n,a) \\<in> set n_as\"\n  shows \"n \\<le> order a (char_poly A)\"", "lemma similar_mat_jordan_block_smult: fixes A :: \"'a :: field mat\" \n  assumes \"similar_mat A (jordan_block n a)\" \n   and k: \"k \\<noteq> 0\" \n  shows \"similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))\"", "lemma jordan_matrix_Cons:  \"jordan_matrix (Cons (n,a) n_as) = four_block_mat \n  (jordan_block n a)                 (0\\<^sub>m n (sum_list (map fst n_as))) \n  (0\\<^sub>m (sum_list (map fst n_as)) n)   (jordan_matrix n_as)\"", "lemma similar_mat_jordan_matrix_smult:  fixes n_as :: \"(nat \\<times> 'a :: field) list\"\n  assumes k: \"k \\<noteq> 0\" \n  shows \"similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as) (jordan_matrix (map (\\<lambda> (n,a). (n, k * a)) n_as))\"", "lemma jordan_nf_smult: fixes k :: \"'a :: field\" \n  assumes jn: \"jordan_nf A n_as\" \n  and k: \"k \\<noteq> 0\" \n  shows \"jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda> (n,a). (n, k * a)) n_as)\"", "lemma jordan_nf_order: assumes \"jordan_nf A n_as\" \n  shows \"order a (char_poly A)  = sum_list (map fst (filter (\\<lambda> na. snd na = a) n_as))\"", "lemma factored_char_poly_norm_bound: assumes A: \"A \\<in> carrier_mat n n\"\n  and linear_factors: \"char_poly A = (\\<Prod> (a :: 'a :: real_normed_field) \\<leftarrow> as. [:- a, 1:])\"\n  and jnf_exists: \"\\<exists> n_as. jordan_nf A n_as\" \n  and le_1: \"\\<And> a. a \\<in> set as \\<Longrightarrow> norm a \\<le> 1\"\n  and le_N: \"\\<And> a. a \\<in> set as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> length (filter ((=) a) as) \\<le> N\"\n  shows \"\\<exists> c1 c2. \\<forall> k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * of_nat k ^ (N - 1))\""], "translations": [["", "lemma jordan_block_index[simp]: \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> \n  jordan_block n a $$ (i,j) = (if i = j then a else if Suc i = j then 1 else 0)\"\n  \"dim_row (jordan_block n k) = n\"\n  \"dim_col (jordan_block n k) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> jordan_block n a $$ (i, j) =\n                       (if i = j then a\n                        else if Suc i = j then 1::'a else (0::'a))) &&&\n    dim_row (jordan_block n k) = n &&& dim_col (jordan_block n k) = n", "unfolding jordan_block_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> mat n n\n                        (\\<lambda>(i, j).\n                            if i = j then a\n                            else if Suc i = j then 1::'a else (0::'a)) $$\n                       (i, j) =\n                       (if i = j then a\n                        else if Suc i = j then 1::'a else (0::'a))) &&&\n    dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if i = j then k else if Suc i = j then 1::'b else (0::'b))) =\n    n &&&\n    dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if i = j then k else if Suc i = j then 1::'b else (0::'b))) =\n    n", "by auto"], ["", "lemma jordan_block_carrier[simp]: \"jordan_block n k \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n k \\<in> carrier_mat n n", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n k \\<in> {m. dim_row m = n \\<and> dim_col m = n}", "by auto"], ["", "lemma jordan_block_char_poly: \"char_poly (jordan_block n a) = [: -a, 1:]^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (jordan_block n a) = [:- a, 1::'a:] ^ n", "unfolding char_poly_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (jordan_block n a)) +\n         map_mat (\\<lambda>a. [:- a:]) (jordan_block n a)) =\n    [:- a, 1::'a:] ^ n", "by (subst det_upper_triangular[of _ n], auto simp: prod_list_diag_prod)"], ["", "lemma jordan_block_pow_carrier[simp]:\n  \"jordan_block n a ^\\<^sub>m r \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n a ^\\<^sub>m r \\<in> carrier_mat n n", "by auto"], ["", "lemma jordan_block_pow_dim[simp]:\n  \"dim_row (jordan_block n a ^\\<^sub>m r) = n\" \"dim_col (jordan_block n a ^\\<^sub>m r) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (jordan_block n a ^\\<^sub>m r) = n &&&\n    dim_col (jordan_block n a ^\\<^sub>m r) = n", "by auto"], ["", "lemma jordan_block_pow: \"(jordan_block n (a :: 'a :: comm_ring_1)) ^\\<^sub>m r = \n  mat n n (\\<lambda> (i,j). if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n a ^\\<^sub>m r =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a))", "proof (induct r)"], ["proof (state)\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "{"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "fix i j :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "assume \"i \\<noteq> j\" \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "hence \"j - i > 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. 0 < j - i", "by auto"], ["proof (state)\nthis:\n  0 < j - i\n\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "hence \"0 choose (j - i) = 0\""], ["proof (prove)\nusing this:\n  0 < j - i\n\ngoal (1 subgoal):\n 1. 0 choose (j - i) = 0", "by simp"], ["proof (state)\nthis:\n  0 choose (j - i) = 0\n\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 \\<noteq> ?j2; ?i2 \\<le> ?j2\\<rbrakk>\n  \\<Longrightarrow> 0 choose (?j2 - ?i2) = 0\n\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "note [simp] = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 \\<noteq> ?j2; ?i2 \\<le> ?j2\\<rbrakk>\n  \\<Longrightarrow> 0 choose (?j2 - ?i2) = 0\n\ngoal (2 subgoals):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))\n 2. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n a ^\\<^sub>m 0 =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n           else (0::'a))", "by (simp, rule eq_matI, auto)"], ["proof (state)\nthis:\n  jordan_block n a ^\\<^sub>m 0 =\n  mat n n\n   (\\<lambda>b.\n       case b of\n       (i, j) \\<Rightarrow>\n         if i \\<le> j then of_nat (0 choose (j - i)) * a ^ (0 + i - j)\n         else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "case (Suc r)"], ["proof (state)\nthis:\n  jordan_block n a ^\\<^sub>m r =\n  mat n n\n   (\\<lambda>b.\n       case b of\n       (i, j) \\<Rightarrow>\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "let ?jb = \"jordan_block n a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "let ?rij = \"\\<lambda> r i j. of_nat (r choose (j - i)) * a ^ (r + i - j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "let ?v = \"\\<lambda> i j. if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j) else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "have \"?jb ^\\<^sub>m Suc r = mat n n (\\<lambda> (i,j). if i \\<le> j then ?rij r i j else 0) * ?jb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n a ^\\<^sub>m Suc r =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a", "by (simp add: Suc)"], ["proof (state)\nthis:\n  jordan_block n a ^\\<^sub>m Suc r =\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) *\n  jordan_block n a\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "also"], ["proof (state)\nthis:\n  jordan_block n a ^\\<^sub>m Suc r =\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) *\n  jordan_block n a\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "have \"\\<dots> = mat n n (\\<lambda> (i,j). if i \\<le> j then ?rij (Suc r) i j else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "assume j: \"j < n\""], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "hence col: \"col (jordan_block n a) j = vec n (\\<lambda>i. if i = j then a else if Suc i = j then 1 else 0)\""], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. col (jordan_block n a) j =\n    vec n\n     (\\<lambda>i. if i = j then a else if Suc i = j then 1::'a else (0::'a))", "unfolding jordan_block_def col_mat[OF j]"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>i.\n         case (i, j) of\n         (i, j) \\<Rightarrow>\n           if i = j then a else if Suc i = j then 1::'a else (0::'a)) =\n    vec n\n     (\\<lambda>i. if i = j then a else if Suc i = j then 1::'a else (0::'a))", "by simp"], ["proof (state)\nthis:\n  col (jordan_block n a) j =\n  vec n\n   (\\<lambda>i. if i = j then a else if Suc i = j then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "have \"vec n f \\<bullet> col (jordan_block n a) j = (f j * a + (if j = 0 then 0 else f (j - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "define p where \"p = (\\<lambda> i. vec n f $ i * col (jordan_block n a) j $ i)\""], ["proof (state)\nthis:\n  p = (\\<lambda>i. vec n f $ i * col (jordan_block n a) j $ i)\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "have \"vec n f \\<bullet> col (jordan_block n a) j = (\\<Sum>i = 0 ..< n. p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j = sum p {0..<n}", "unfolding scalar_prod_def p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (col (jordan_block n a) j).\n        vec n f $ i * col (jordan_block n a) j $ i) =\n    (\\<Sum>i = 0..<n. vec n f $ i * col (jordan_block n a) j $ i)", "by simp"], ["proof (state)\nthis:\n  vec n f \\<bullet> col (jordan_block n a) j = sum p {0..<n}\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "also"], ["proof (state)\nthis:\n  vec n f \\<bullet> col (jordan_block n a) j = sum p {0..<n}\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "have \"\\<dots> = p j + sum p ({0 ..< n} - {j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p {0..<n} = p j + sum p ({0..<n} - {j})", "using j"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. sum p {0..<n} = p j + sum p ({0..<n} - {j})", "by (subst sum.remove[of _ j], auto)"], ["proof (state)\nthis:\n  sum p {0..<n} = p j + sum p ({0..<n} - {j})\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "also"], ["proof (state)\nthis:\n  sum p {0..<n} = p j + sum p ({0..<n} - {j})\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "have \"p j = f j * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p j = f j * a", "unfolding p_def col"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n f $ j *\n    vec n\n     (\\<lambda>i.\n         if i = j then a else if Suc i = j then 1::'a else (0::'a)) $\n    j =\n    f j * a", "using j"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. vec n f $ j *\n    vec n\n     (\\<lambda>i.\n         if i = j then a else if Suc i = j then 1::'a else (0::'a)) $\n    j =\n    f j * a", "by auto"], ["proof (state)\nthis:\n  p j = f j * a\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "also"], ["proof (state)\nthis:\n  p j = f j * a\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "have \"sum p ({0 ..< n} - {j}) = (if j = 0 then 0 else f (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "proof (cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "case 0"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "have \"sum p ({0 ..< n} - {j}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {j}) = (0::'a)", "by (rule sum.neutral, auto simp: p_def col 0)"], ["proof (state)\nthis:\n  sum p ({0..<n} - {j}) = (0::'a)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum p ({0..<n} - {j}) = (0::'a)\n\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "using 0"], ["proof (prove)\nusing this:\n  sum p ({0..<n} - {j}) = (0::'a)\n  j = 0\n\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "by simp"], ["proof (state)\nthis:\n  sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "case (Suc jj)"], ["proof (state)\nthis:\n  j = Suc jj\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "with j"], ["proof (chain)\npicking this:\n  j < n\n  j = Suc jj", "have jj: \"jj \\<in> {0 ..< n} - {j}\""], ["proof (prove)\nusing this:\n  j < n\n  j = Suc jj\n\ngoal (1 subgoal):\n 1. jj \\<in> {0..<n} - {j}", "by auto"], ["proof (state)\nthis:\n  jj \\<in> {0..<n} - {j}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "have \"sum p ({0 ..< n} - {j}) = p jj + sum p ({0 ..< n} - {j} - {jj})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {j}) = p jj + sum p ({0..<n} - {j} - {jj})", "by (subst sum.remove[OF _ jj], auto)"], ["proof (state)\nthis:\n  sum p ({0..<n} - {j}) = p jj + sum p ({0..<n} - {j} - {jj})\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "also"], ["proof (state)\nthis:\n  sum p ({0..<n} - {j}) = p jj + sum p ({0..<n} - {j} - {jj})\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "have \"p jj = f (j - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p jj = f (j - 1)", "unfolding p_def col"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n f $ jj *\n    vec n\n     (\\<lambda>i.\n         if i = j then a else if Suc i = j then 1::'a else (0::'a)) $\n    jj =\n    f (j - 1)", "using jj"], ["proof (prove)\nusing this:\n  jj \\<in> {0..<n} - {j}\n\ngoal (1 subgoal):\n 1. vec n f $ jj *\n    vec n\n     (\\<lambda>i.\n         if i = j then a else if Suc i = j then 1::'a else (0::'a)) $\n    jj =\n    f (j - 1)", "by (auto simp: Suc)"], ["proof (state)\nthis:\n  p jj = f (j - 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "also"], ["proof (state)\nthis:\n  p jj = f (j - 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "have \"sum p ({0 ..< n} - {j} - {jj}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {j} - {jj}) = (0::'a)", "by (rule sum.neutral, auto simp: p_def col, auto simp: Suc)"], ["proof (state)\nthis:\n  sum p ({0..<n} - {j} - {jj}) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "finally"], ["proof (chain)\npicking this:\n  sum p ({0..<n} - {j}) = f (j - 1) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum p ({0..<n} - {j}) = f (j - 1) + (0::'a)\n\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))", "unfolding Suc"], ["proof (prove)\nusing this:\n  sum p ({0..<n} - {Suc jj}) = f (Suc jj - 1) + (0::'a)\n\ngoal (1 subgoal):\n 1. sum p ({0..<n} - {Suc jj}) =\n    (if Suc jj = 0 then 0::'a else f (Suc jj - 1))", "by simp"], ["proof (state)\nthis:\n  sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum p ({0..<n} - {j}) = (if j = 0 then 0::'a else f (j - 1))\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "finally"], ["proof (chain)\npicking this:\n  vec n f \\<bullet> col (jordan_block n a) j =\n  f j * a + (if j = 0 then 0::'a else f (j - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  vec n f \\<bullet> col (jordan_block n a) j =\n  f j * a + (if j = 0 then 0::'a else f (j - 1))\n\ngoal (1 subgoal):\n 1. vec n f \\<bullet> col (jordan_block n a) j =\n    f j * a + (if j = 0 then 0::'a else f (j - 1))", "."], ["proof (state)\nthis:\n  vec n f \\<bullet> col (jordan_block n a) j =\n  f j * a + (if j = 0 then 0::'a else f (j - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec n f \\<bullet> col (jordan_block n a) j =\n  f j * a + (if j = 0 then 0::'a else f (j - 1))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "}"], ["proof (state)\nthis:\n  ?j2 < n \\<Longrightarrow>\n  vec n ?f2 \\<bullet> col (jordan_block n a) ?j2 =\n  ?f2 ?j2 * a + (if ?j2 = 0 then 0::'a else ?f2 (?j2 - 1))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "note scalar_to_sum = this"], ["proof (state)\nthis:\n  ?j2 < n \\<Longrightarrow>\n  vec n ?f2 \\<bullet> col (jordan_block n a) ?j2 =\n  ?f2 ?j2 * a + (if ?j2 = 0 then 0::'a else ?f2 (?j2 - 1))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "{"], ["proof (state)\nthis:\n  ?j2 < n \\<Longrightarrow>\n  vec n ?f2 \\<bullet> col (jordan_block n a) ?j2 =\n  ?f2 ?j2 * a + (if ?j2 = 0 then 0::'a else ?f2 (?j2 - 1))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "assume i: \"i < n\" and ij: \"i > j\""], ["proof (state)\nthis:\n  i < n\n  j < i\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "hence j: \"j < n\""], ["proof (prove)\nusing this:\n  i < n\n  j < i\n\ngoal (1 subgoal):\n 1. j < n", "by auto"], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "have \"vec n (?v i) \\<bullet> col (jordan_block n a) j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) \\<bullet>\n    col (jordan_block n a) j =\n    (0::'a)", "unfolding scalar_to_sum[OF j]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n     else (0::'a)) *\n    a +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    (0::'a)", "using ij i j"], ["proof (prove)\nusing this:\n  j < i\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. (if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n     else (0::'a)) *\n    a +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>j.\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) \\<bullet>\n  col (jordan_block n a) j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < ?i2\\<rbrakk>\n  \\<Longrightarrow> vec n\n                     (\\<lambda>j.\n                         if ?i2 \\<le> j\n                         then of_nat (r choose (j - ?i2)) *\n                              a ^ (r + ?i2 - j)\n                         else (0::'a)) \\<bullet>\n                    col (jordan_block n a) ?j2 =\n                    (0::'a)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "note easy_case = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < ?i2\\<rbrakk>\n  \\<Longrightarrow> vec n\n                     (\\<lambda>j.\n                         if ?i2 \\<le> j\n                         then of_nat (r choose (j - ?i2)) *\n                              a ^ (r + ?i2 - j)\n                         else (0::'a)) \\<bullet>\n                    col (jordan_block n a) ?j2 =\n                    (0::'a)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < ?i2\\<rbrakk>\n  \\<Longrightarrow> vec n\n                     (\\<lambda>j.\n                         if ?i2 \\<le> j\n                         then of_nat (r choose (j - ?i2)) *\n                              a ^ (r + ?i2 - j)\n                         else (0::'a)) \\<bullet>\n                    col (jordan_block n a) ?j2 =\n                    (0::'a)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "assume j: \"j < n\" and ij: \"i \\<le> j\""], ["proof (state)\nthis:\n  j < n\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "hence i: \"i < n\" and id: \"\\<And> p q. (if i \\<le> j then p else q) = p\""], ["proof (prove)\nusing this:\n  j < n\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i < n &&& (\\<And>p q. (if i \\<le> j then p else q) = p)", "by auto"], ["proof (state)\nthis:\n  i < n\n  (if i \\<le> j then ?p else ?q) = ?p\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "have \"vec n (?v i) \\<bullet> col (jordan_block n a) j =\n        (of_nat (r choose (j - i)) * (a ^ (Suc (r + i - j)))) +\n          (if j = 0 then 0\n         else if i \\<le> j - 1 then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1)) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) \\<bullet>\n    col (jordan_block n a) j =\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a))", "unfolding scalar_to_sum[OF j]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n     else (0::'a)) *\n    a +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a))", "using ij"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n     else (0::'a)) *\n    a +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a))", "by simp"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>j.\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) \\<bullet>\n  col (jordan_block n a) j =\n  of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n  (if j = 0 then 0::'a\n   else if i \\<le> j - 1\n        then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n        else (0::'a))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "also"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>j.\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) \\<bullet>\n  col (jordan_block n a) j =\n  of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n  (if j = 0 then 0::'a\n   else if i \\<le> j - 1\n        then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n        else (0::'a))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "have \"\\<dots> = of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "proof (cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "case (Suc jj)"], ["proof (state)\nthis:\n  j = Suc jj\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "{"], ["proof (state)\nthis:\n  j = Suc jj\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "assume \"i \\<le> Suc jj\" and \"\\<not> i \\<le> jj\""], ["proof (state)\nthis:\n  i \\<le> Suc jj\n  \\<not> i \\<le> jj\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "hence \"i = Suc jj\""], ["proof (prove)\nusing this:\n  i \\<le> Suc jj\n  \\<not> i \\<le> jj\n\ngoal (1 subgoal):\n 1. i = Suc jj", "by auto"], ["proof (state)\nthis:\n  i = Suc jj\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "hence \"a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\""], ["proof (prove)\nusing this:\n  i = Suc jj\n\ngoal (1 subgoal):\n 1. a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)", "by simp"], ["proof (state)\nthis:\n  a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> Suc jj; \\<not> i \\<le> jj\\<rbrakk>\n  \\<Longrightarrow> a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> Suc jj; \\<not> i \\<le> jj\\<rbrakk>\n  \\<Longrightarrow> a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> Suc jj; \\<not> i \\<le> jj\\<rbrakk>\n  \\<Longrightarrow> a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "assume ijj: \"i \\<le> jj\""], ["proof (state)\nthis:\n  i \\<le> jj\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "have \"of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) \n          + of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n            of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "proof (cases \"r + i < jj\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n 2. \\<not> r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "case True"], ["proof (state)\nthis:\n  r + i < jj\n\ngoal (2 subgoals):\n 1. r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n 2. \\<not> r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "hence gt: \"jj - i > r\" \"Suc jj - i > r\" \"Suc jj - i > Suc r\""], ["proof (prove)\nusing this:\n  r + i < jj\n\ngoal (1 subgoal):\n 1. r < jj - i &&& r < Suc jj - i &&& Suc r < Suc jj - i", "by auto"], ["proof (state)\nthis:\n  r < jj - i\n  r < Suc jj - i\n  Suc r < Suc jj - i\n\ngoal (2 subgoals):\n 1. r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n 2. \\<not> r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "unfolding binomial_eq_0[OF gt(1)] binomial_eq_0[OF gt(2)] binomial_eq_0[OF gt(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat 0 * (a * a ^ (r + i - Suc jj)) + of_nat 0 * a ^ (r + i - jj) =\n    of_nat 0 * a ^ (r + i - jj)", "by simp"], ["proof (state)\nthis:\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n\ngoal (1 subgoal):\n 1. \\<not> r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "case False"], ["proof (state)\nthis:\n  \\<not> r + i < jj\n\ngoal (1 subgoal):\n 1. \\<not> r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "hence ge: \"r + i \\<ge> jj\""], ["proof (prove)\nusing this:\n  \\<not> r + i < jj\n\ngoal (1 subgoal):\n 1. jj \\<le> r + i", "by simp"], ["proof (state)\nthis:\n  jj \\<le> r + i\n\ngoal (1 subgoal):\n 1. \\<not> r + i < jj \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "proof (cases \"jj = r + i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jj = r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n 2. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "case True"], ["proof (state)\nthis:\n  jj = r + i\n\ngoal (2 subgoals):\n 1. jj = r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n 2. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "have gt: \"r < Suc r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < Suc r", "by simp"], ["proof (state)\nthis:\n  r < Suc r\n\ngoal (2 subgoals):\n 1. jj = r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n 2. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc (r + i) - i)) * (a * a ^ (r + i - Suc (r + i))) +\n    of_nat (r choose (r + i - i)) * a ^ (r + i - (r + i)) =\n    of_nat (Suc r choose (Suc (r + i) - i)) * a ^ (r + i - (r + i))", "by (simp add: binomial_eq_0[OF gt])"], ["proof (state)\nthis:\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "case False"], ["proof (state)\nthis:\n  jj \\<noteq> r + i\n\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "with ge"], ["proof (chain)\npicking this:\n  jj \\<le> r + i\n  jj \\<noteq> r + i", "have lt: \"jj < r + i\""], ["proof (prove)\nusing this:\n  jj \\<le> r + i\n  jj \\<noteq> r + i\n\ngoal (1 subgoal):\n 1. jj < r + i", "by auto"], ["proof (state)\nthis:\n  jj < r + i\n\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "hence \"r + i - jj = Suc (r + i - Suc jj)\""], ["proof (prove)\nusing this:\n  jj < r + i\n\ngoal (1 subgoal):\n 1. r + i - jj = Suc (r + i - Suc jj)", "by simp"], ["proof (state)\nthis:\n  r + i - jj = Suc (r + i - Suc jj)\n\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "hence prod: \"a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\""], ["proof (prove)\nusing this:\n  r + i - jj = Suc (r + i - Suc jj)\n\ngoal (1 subgoal):\n 1. a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)", "by simp"], ["proof (state)\nthis:\n  a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "from ijj"], ["proof (chain)\npicking this:\n  i \\<le> jj", "have id: \"Suc jj - i = Suc (jj - i)\""], ["proof (prove)\nusing this:\n  i \\<le> jj\n\ngoal (1 subgoal):\n 1. Suc jj - i = Suc (jj - i)", "by simp"], ["proof (state)\nthis:\n  Suc jj - i = Suc (jj - i)\n\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "have binom: \"Suc r choose (Suc jj - i) = \n                r choose (Suc jj - i) + (r choose (jj - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc r choose (Suc jj - i) = r choose (Suc jj - i) + (r choose (jj - i))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc r choose Suc (jj - i) = r choose Suc (jj - i) + (r choose (jj - i))", "by (subst binomial_Suc_Suc, simp)"], ["proof (state)\nthis:\n  Suc r choose (Suc jj - i) = r choose (Suc jj - i) + (r choose (jj - i))\n\ngoal (1 subgoal):\n 1. jj \\<noteq> r + i \\<Longrightarrow>\n    of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "unfolding prod binom"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc jj - i)) * a ^ (r + i - jj) +\n    of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n    of_nat (r choose (Suc jj - i) + (r choose (jj - i))) * a ^ (r + i - jj)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "}"], ["proof (state)\nthis:\n  i \\<le> jj \\<Longrightarrow>\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n       (if j = 0 then 0::'a\n        else if i \\<le> j - 1\n             then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n             else (0::'a)) =\n       of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>i \\<le> Suc jj; \\<not> i \\<le> jj\\<rbrakk>\n  \\<Longrightarrow> a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n  i \\<le> jj \\<Longrightarrow>\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> Suc jj; \\<not> i \\<le> jj\\<rbrakk>\n  \\<Longrightarrow> a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n  i \\<le> jj \\<Longrightarrow>\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n\ngoal (1 subgoal):\n 1. of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "using ij"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> Suc jj; \\<not> i \\<le> jj\\<rbrakk>\n  \\<Longrightarrow> a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n  i \\<le> jj \\<Longrightarrow>\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "unfolding Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> Suc jj; \\<not> i \\<le> jj\\<rbrakk>\n  \\<Longrightarrow> a * a ^ (r + i - Suc jj) = a ^ (r + i - jj)\n  i \\<le> jj \\<Longrightarrow>\n  of_nat (r choose (Suc jj - i)) * (a * a ^ (r + i - Suc jj)) +\n  of_nat (r choose (jj - i)) * a ^ (r + i - jj) =\n  of_nat (Suc r choose (Suc jj - i)) * a ^ (r + i - jj)\n  i \\<le> Suc jj\n\ngoal (1 subgoal):\n 1. of_nat (r choose (Suc jj - i)) * a ^ Suc (r + i - Suc jj) +\n    (if Suc jj = 0 then 0::'a\n     else if i \\<le> Suc jj - 1\n          then of_nat (r choose (Suc jj - 1 - i)) *\n               a ^ (r + i - (Suc jj - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (Suc jj - i)) * a ^ (Suc (r + i) - Suc jj)", "by auto"], ["proof (state)\nthis:\n  of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n  (if j = 0 then 0::'a\n   else if i \\<le> j - 1\n        then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n        else (0::'a)) =\n  of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n\ngoal (1 subgoal):\n 1. j = 0 \\<Longrightarrow>\n    of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n    (if j = 0 then 0::'a\n     else if i \\<le> j - 1\n          then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n          else (0::'a)) =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "qed auto"], ["proof (state)\nthis:\n  of_nat (r choose (j - i)) * a ^ Suc (r + i - j) +\n  (if j = 0 then 0::'a\n   else if i \\<le> j - 1\n        then of_nat (r choose (j - 1 - i)) * a ^ (r + i - (j - 1))\n        else (0::'a)) =\n  of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "finally"], ["proof (chain)\npicking this:\n  vec n\n   (\\<lambda>j.\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) \\<bullet>\n  col (jordan_block n a) j =\n  of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "have \"vec n (?v i) \\<bullet> col (jordan_block n a) j \n        = of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\""], ["proof (prove)\nusing this:\n  vec n\n   (\\<lambda>j.\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) \\<bullet>\n  col (jordan_block n a) j =\n  of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) \\<bullet>\n    col (jordan_block n a) j =\n    of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)", "."], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>j.\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) \\<bullet>\n  col (jordan_block n a) j =\n  of_nat (Suc r choose (j - i)) * a ^ (Suc (r + i) - j)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < n; ?i2 \\<le> ?j2\\<rbrakk>\n  \\<Longrightarrow> vec n\n                     (\\<lambda>j.\n                         if ?i2 \\<le> j\n                         then of_nat (r choose (j - ?i2)) *\n                              a ^ (r + ?i2 - j)\n                         else (0::'a)) \\<bullet>\n                    col (jordan_block n a) ?j2 =\n                    of_nat (Suc r choose (?j2 - ?i2)) *\n                    a ^ (Suc (r + ?i2) - ?j2)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "note main_case = this"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < n; ?i2 \\<le> ?j2\\<rbrakk>\n  \\<Longrightarrow> vec n\n                     (\\<lambda>j.\n                         if ?i2 \\<le> j\n                         then of_nat (r choose (j - ?i2)) *\n                              a ^ (r + ?i2 - j)\n                         else (0::'a)) \\<bullet>\n                    col (jordan_block n a) ?j2 =\n                    of_nat (Suc r choose (?j2 - ?i2)) *\n                    a ^ (Suc (r + ?i2) - ?j2)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n         else (0::'a)) *\n    jordan_block n a =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))", "by (rule eq_matI, insert easy_case main_case, auto)"], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) *\n  jordan_block n a =\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n       else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n       else (0::'a)) *\n  jordan_block n a =\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n       else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       jordan_block n a ^\\<^sub>m r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j then of_nat (r choose (j - i)) * a ^ (r + i - j)\n              else (0::'a)) \\<Longrightarrow>\n       jordan_block n a ^\\<^sub>m Suc r =\n       mat n n\n        (\\<lambda>b.\n            case b of\n            (i, j) \\<Rightarrow>\n              if i \\<le> j\n              then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n              else (0::'a))", "finally"], ["proof (chain)\npicking this:\n  jordan_block n a ^\\<^sub>m Suc r =\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n       else (0::'a))", "show ?case"], ["proof (prove)\nusing this:\n  jordan_block n a ^\\<^sub>m Suc r =\n  mat n n\n   (\\<lambda>(i, j).\n       if i \\<le> j then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n       else (0::'a))\n\ngoal (1 subgoal):\n 1. jordan_block n a ^\\<^sub>m Suc r =\n    mat n n\n     (\\<lambda>b.\n         case b of\n         (i, j) \\<Rightarrow>\n           if i \\<le> j\n           then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n           else (0::'a))", "by simp"], ["proof (state)\nthis:\n  jordan_block n a ^\\<^sub>m Suc r =\n  mat n n\n   (\\<lambda>b.\n       case b of\n       (i, j) \\<Rightarrow>\n         if i \\<le> j\n         then of_nat (Suc r choose (j - i)) * a ^ (Suc r + i - j)\n         else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition jordan_matrix :: \"(nat \\<times> 'a :: {zero,one})list \\<Rightarrow> 'a mat\" where\n  \"jordan_matrix n_as = diag_block_mat (map (\\<lambda> (n,a). jordan_block n a) n_as)\""], ["", "lemma jordan_matrix_dim[simp]: \n  \"dim_row (jordan_matrix n_as) = sum_list (map fst n_as)\"\n  \"dim_col (jordan_matrix n_as) = sum_list (map fst n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (jordan_matrix n_as) = sum_list (map fst n_as) &&&\n    dim_col (jordan_matrix n_as) = sum_list (map fst n_as)", "unfolding jordan_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n    sum_list (map fst n_as) &&&\n    dim_col\n     (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n    sum_list (map fst n_as)", "by (subst dim_diag_block_mat, auto, (induct n_as, auto simp: Let_def)+)"], ["", "lemma jordan_matrix_carrier[simp]: \n  \"jordan_matrix n_as \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix n_as\n    \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix n_as\n    \\<in> {m. dim_row m = sum_list (map fst n_as) \\<and>\n              dim_col m = sum_list (map fst n_as)}", "by auto"], ["", "lemma jordan_matrix_upper_triangular: \"i < sum_list (map fst n_as)\n  \\<Longrightarrow> j < i \\<Longrightarrow> jordan_matrix n_as $$ (i,j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < sum_list (map fst n_as); j < i\\<rbrakk>\n    \\<Longrightarrow> jordan_matrix n_as $$ (i, j) = (0::'a)", "unfolding jordan_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < sum_list (map fst n_as); j < i\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>(x, y). jordan_block x y) n_as) $$\n                      (i, j) =\n                      (0::'a)", "by (rule diag_block_upper_triangular, auto simp: jordan_matrix_def[symmetric])"], ["", "lemma jordan_matrix_pow: \"(jordan_matrix n_as) ^\\<^sub>m r = \n  diag_block_mat (map (\\<lambda> (n,a). (jordan_block n a) ^\\<^sub>m r) n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix n_as ^\\<^sub>m r =\n    diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as)", "unfolding jordan_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as) ^\\<^sub>m\n    r =\n    diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as)", "by (subst diag_block_pow_mat, force, rule arg_cong[of _ _ diag_block_mat], auto)"], ["", "lemma jordan_matrix_char_poly: \n  \"char_poly (jordan_matrix n_as) = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (jordan_matrix n_as) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly (jordan_matrix n_as) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "let ?n = \"sum_list (map fst n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly (jordan_matrix n_as) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "have \"diag_mat\n     ([:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) + map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as)) =\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1:]) n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n      map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as)) =\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)", "unfolding jordan_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as))) =\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)", "proof (induct n_as)"], ["proof (state)\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "case (Cons na n_as)"], ["proof (state)\nthis:\n  diag_mat\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n    map_mat (\\<lambda>a. [:- a:])\n     (diag_block_mat\n       (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n         n_as))) =\n  concat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n     n_as)\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "obtain n a where na: \"na = (n,a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n a. na = (n, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  na = (n, a)\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "let ?n2 = \"sum_list (map fst n_as)\""], ["proof (state)\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "note fbo = four_block_one_mat"], ["proof (state)\nthis:\n  four_block_mat (1\\<^sub>m ?n1.0) (0\\<^sub>m ?n1.0 ?n2.0)\n   (0\\<^sub>m ?n2.0 ?n1.0) (1\\<^sub>m ?n2.0) =\n  1\\<^sub>m (?n1.0 + ?n2.0)\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "note mz = zero_carrier_mat"], ["proof (state)\nthis:\n  0\\<^sub>m ?nr ?nc \\<in> carrier_mat ?nr ?nc\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "note mo = one_carrier_mat"], ["proof (state)\nthis:\n  1\\<^sub>m ?n \\<in> carrier_mat ?n ?n\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "have mA: \"\\<And> A. A \\<in> carrier_mat (dim_row A) (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. A \\<in> carrier_mat (dim_row A) (dim_col A)", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. A \\<in> {m. dim_row m = dim_row A \\<and> dim_col m = dim_col A}", "by auto"], ["proof (state)\nthis:\n  ?A \\<in> carrier_mat (dim_row ?A) (dim_col ?A)\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "let ?Bs = \"map (\\<lambda>(x, y). jordan_block x y) n_as\""], ["proof (state)\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "let ?B = \"diag_block_mat ?Bs\""], ["proof (state)\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "from jordan_matrix_dim[of n_as, unfolded jordan_matrix_def]"], ["proof (chain)\npicking this:\n  dim_row (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n  dim_col (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)", "have dimB: \"dim_row ?B = ?n2\" \"dim_col ?B = ?n2\""], ["proof (prove)\nusing this:\n  dim_row (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n  dim_col (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. dim_row\n     (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n    sum_list (map fst n_as) &&&\n    dim_col\n     (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n    sum_list (map fst n_as)", "by auto"], ["proof (state)\nthis:\n  dim_row (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n  dim_col (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "hence B: \"?B \\<in> carrier_mat ?n2 ?n2\""], ["proof (prove)\nusing this:\n  dim_row (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n  dim_col (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)\n    \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))", "unfolding carrier_mat_def"], ["proof (prove)\nusing this:\n  dim_row (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n  dim_col (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)) =\n  sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)\n    \\<in> {m. dim_row m = sum_list (map fst n_as) \\<and>\n              dim_col m = sum_list (map fst n_as)}", "by simp"], ["proof (state)\nthis:\n  diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)\n  \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))\n\ngoal (2 subgoals):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])\n 2. \\<And>a n_as.\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst n_as)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              n_as))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          n_as) \\<Longrightarrow>\n       diag_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (sum_list (map fst (a # n_as))) +\n         map_mat (\\<lambda>a. [:- a:])\n          (diag_block_mat\n            (map (\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> jordan_block a b)\n              (a # n_as)))) =\n       concat\n        (map (\\<lambda>a.\n                 case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n          (a # n_as))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n      1\\<^sub>m (sum_list (map fst (na # n_as))) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           (na # n_as)))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       (na # n_as))", "unfolding na fbo"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n      1\\<^sub>m (sum_list (map fst ((n, a) # n_as))) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           ((n, a) # n_as)))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       ((n, a) # n_as))", "apply (simp add: Let_def fbo[symmetric] del: fbo)"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n      four_block_mat (1\\<^sub>m n) (0\\<^sub>m n (sum_list (map fst n_as)))\n       (0\\<^sub>m (sum_list (map fst n_as)) n)\n       (1\\<^sub>m (sum_list (map fst n_as))) +\n      map_mat (\\<lambda>a. [:- a:])\n       (four_block_mat (jordan_block n a)\n         (0\\<^sub>m n\n           (dim_col\n             (diag_block_mat\n               (map (\\<lambda>(x, y). jordan_block x y) n_as))))\n         (0\\<^sub>m\n           (dim_row\n             (diag_block_mat\n               (map (\\<lambda>(x, y). jordan_block x y) n_as)))\n           n)\n         (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)))) =\n    replicate n [:- a, 1::'a:] @\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)", "apply (subst smult_four_block_mat[OF mo mz mz mo])"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     (four_block_mat ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n)\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n        0\\<^sub>m n (sum_list (map fst n_as)))\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n        0\\<^sub>m (sum_list (map fst n_as)) n)\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n        1\\<^sub>m (sum_list (map fst n_as))) +\n      map_mat (\\<lambda>a. [:- a:])\n       (four_block_mat (jordan_block n a)\n         (0\\<^sub>m n\n           (dim_col\n             (diag_block_mat\n               (map (\\<lambda>(x, y). jordan_block x y) n_as))))\n         (0\\<^sub>m\n           (dim_row\n             (diag_block_mat\n               (map (\\<lambda>(x, y). jordan_block x y) n_as)))\n           n)\n         (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)))) =\n    replicate n [:- a, 1::'a:] @\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)", "apply (subst map_four_block_mat[OF jordan_block_carrier mz mz mA])"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     (four_block_mat ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n)\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n        0\\<^sub>m n (sum_list (map fst n_as)))\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n        0\\<^sub>m (sum_list (map fst n_as)) n)\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n        1\\<^sub>m (sum_list (map fst n_as))) +\n      four_block_mat (map_mat (\\<lambda>a. [:- a:]) (jordan_block n a))\n       (map_mat (\\<lambda>a. [:- a:])\n         (0\\<^sub>m n\n           (dim_col\n             (diag_block_mat\n               (map (\\<lambda>(x, y). jordan_block x y) n_as)))))\n       (map_mat (\\<lambda>a. [:- a:])\n         (0\\<^sub>m\n           (dim_row\n             (diag_block_mat\n               (map (\\<lambda>(x, y). jordan_block x y) n_as)))\n           n))\n       (map_mat (\\<lambda>a. [:- a:])\n         (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)))) =\n    replicate n [:- a, 1::'a:] @\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)", "apply (subst add_four_block_mat[of _ n n _ ?n2 _ ?n2], auto simp: dimB B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     (four_block_mat\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) (jordan_block n a))\n       (map_mat (\\<lambda>a. [:- a:])\n         (0\\<^sub>m n (sum_list (map fst n_as))))\n       (map_mat (\\<lambda>a. [:- a:])\n         (0\\<^sub>m (sum_list (map fst n_as)) n))\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n        1\\<^sub>m (sum_list (map fst n_as)) +\n        map_mat (\\<lambda>a. [:- a:])\n         (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as)))) =\n    replicate n [:- a, 1::'a:] @\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)", "apply (subst diag_four_block_mat[of _ n _ ?n2], auto simp: dimB B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) (jordan_block n a)) @\n    diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as))) =\n    replicate n [:- a, 1::'a:] @\n    concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)", "apply (subst Cons, auto simp: jordan_block_def diag_mat_def, \n      intro nth_equalityI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  diag_mat\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    1\\<^sub>m (sum_list (map fst (na # n_as))) +\n    map_mat (\\<lambda>a. [:- a:])\n     (diag_block_mat\n       (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n         (na # n_as)))) =\n  concat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n     (na # n_as))\n\ngoal (1 subgoal):\n 1. diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst [])) +\n      map_mat (\\<lambda>a. [:- a:])\n       (diag_block_mat\n         (map (\\<lambda>a. case a of (a, b) \\<Rightarrow> jordan_block a b)\n           []))) =\n    concat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> replicate n [:- a, 1::'a:])\n       [])", "qed (force simp: diag_mat_def)"], ["proof (state)\nthis:\n  diag_mat\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n    map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as)) =\n  concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)\n\ngoal (1 subgoal):\n 1. char_poly (jordan_matrix n_as) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "also"], ["proof (state)\nthis:\n  diag_mat\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n    map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as)) =\n  concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)\n\ngoal (1 subgoal):\n 1. char_poly (jordan_matrix n_as) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "have \"prod_list ... = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "by (induct n_as, auto)"], ["proof (state)\nthis:\n  prod_list\n   (concat (map (\\<lambda>(n, a). replicate n [:- a, 1::'a:]) n_as)) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. char_poly (jordan_matrix n_as) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "finally"], ["proof (chain)\npicking this:\n  prod_list\n   (diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n      map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as))) =\n  (\\<Prod>a\\<leftarrow>n_as. case a of\n                             (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_list\n   (diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n      map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as))) =\n  (\\<Prod>a\\<leftarrow>n_as. case a of\n                             (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. char_poly (jordan_matrix n_as) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "unfolding char_poly_defs"], ["proof (prove)\nusing this:\n  prod_list\n   (diag_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (sum_list (map fst n_as)) +\n      map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as))) =\n  (\\<Prod>a\\<leftarrow>n_as. case a of\n                             (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (jordan_matrix n_as)) +\n         map_mat (\\<lambda>a. [:- a:]) (jordan_matrix n_as)) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "by (subst det_upper_triangular[of _ ?n], auto simp: jordan_matrix_upper_triangular)"], ["proof (state)\nthis:\n  char_poly (jordan_matrix n_as) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition jordan_nf :: \"'a :: semiring_1 mat \\<Rightarrow> (nat \\<times> 'a)list \\<Rightarrow> bool\" where\n  \"jordan_nf A n_as \\<equiv> (0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as))\""], ["", "lemma jordan_nf_powE: assumes A: \"A \\<in> carrier_mat n n\" and jnf: \"jordan_nf A n_as\" \n  obtains P Q where \"P \\<in> carrier_mat n n\" \"Q \\<in> carrier_mat n n\" and \n  \"char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1:] ^ na)\"\n  \"\\<And> k. A ^\\<^sub>m k = P * (jordan_matrix n_as)^\\<^sub>m k * Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat n n; Q \\<in> carrier_mat n n;\n         char_poly A =\n         (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na);\n         \\<And>k.\n            A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat n n; Q \\<in> carrier_mat n n;\n         char_poly A =\n         (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na);\n         \\<And>k.\n            A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dim: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat n n; Q \\<in> carrier_mat n n;\n         char_poly A =\n         (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na);\n         \\<And>k.\n            A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume obt: \"\\<And>P Q. P \\<in> carrier_mat n n \\<Longrightarrow> Q \\<in> carrier_mat n n \\<Longrightarrow> \n    char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1:] ^ na) \\<Longrightarrow> \n    (\\<And>k. A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q) \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>?P \\<in> carrier_mat n n; ?Q \\<in> carrier_mat n n;\n   char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na);\n   \\<And>k.\n      A ^\\<^sub>m k = ?P * jordan_matrix n_as ^\\<^sub>m k * ?Q\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat n n; Q \\<in> carrier_mat n n;\n         char_poly A =\n         (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na);\n         \\<And>k.\n            A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from jnf[unfolded jordan_nf_def]"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)", "obtain P Q where\n    simw: \"similar_mat_wit A (jordan_matrix n_as) P Q\"\n    and sim: \"similar_mat A (jordan_matrix n_as)\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>similar_mat_wit A (jordan_matrix n_as) P Q;\n         similar_mat A (jordan_matrix n_as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding similar_mat_def"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and>\n  (\\<exists>P. Ex (similar_mat_wit A (jordan_matrix n_as) P))\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>similar_mat_wit A (jordan_matrix n_as) P Q;\n         \\<exists>P. Ex (similar_mat_wit A (jordan_matrix n_as) P)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  similar_mat_wit A (jordan_matrix n_as) P Q\n  similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat n n; Q \\<in> carrier_mat n n;\n         char_poly A =\n         (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na);\n         \\<And>k.\n            A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule obt)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?P \\<in> carrier_mat n n\n 2. ?Q \\<in> carrier_mat n n\n 3. char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na)\n 4. \\<And>k. A ^\\<^sub>m k = ?P * jordan_matrix n_as ^\\<^sub>m k * ?Q", "show \"\\<And> k. A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q", "by (rule similar_mat_wit_pow_id[OF simw])"], ["proof (state)\nthis:\n  A ^\\<^sub>m ?k = P * jordan_matrix n_as ^\\<^sub>m ?k * Q\n\ngoal (3 subgoals):\n 1. P \\<in> carrier_mat n n\n 2. Q \\<in> carrier_mat n n\n 3. char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na)", "show \"char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1:] ^ na)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na)", "unfolding char_poly_similar[OF sim] jordan_matrix_char_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n    (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na)", ".."], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>(na, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ na)\n\ngoal (2 subgoals):\n 1. P \\<in> carrier_mat n n\n 2. Q \\<in> carrier_mat n n", "qed (insert simw[unfolded similar_mat_wit_def Let_def dim], auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma choose_poly_bound: assumes \"i \\<le> d\"\n  shows \"r choose i \\<le> max 1 (r^d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r choose i \\<le> max 1 (r ^ d)", "proof (cases \"i \\<le> r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<not> i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> r\n\ngoal (2 subgoals):\n 1. i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<not> i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "hence \"r choose i = 0\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> r\n\ngoal (1 subgoal):\n 1. r choose i = 0", "by simp"], ["proof (state)\nthis:\n  r choose i = 0\n\ngoal (2 subgoals):\n 1. i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<not> i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "thus ?thesis"], ["proof (prove)\nusing this:\n  r choose i = 0\n\ngoal (1 subgoal):\n 1. r choose i \\<le> max 1 (r ^ d)", "by arith"], ["proof (state)\nthis:\n  r choose i \\<le> max 1 (r ^ d)\n\ngoal (1 subgoal):\n 1. i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "case True"], ["proof (state)\nthis:\n  i \\<le> r\n\ngoal (1 subgoal):\n 1. i \\<le> r \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r choose i \\<le> max 1 (r ^ d)", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<And>nat. r = Suc nat \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "case (Suc rr)"], ["proof (state)\nthis:\n  r = Suc rr\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<And>nat. r = Suc nat \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "from binomial_le_pow[OF True]"], ["proof (chain)\npicking this:\n  r choose i \\<le> r ^ i", "have \"r choose i \\<le> r ^ i\""], ["proof (prove)\nusing this:\n  r choose i \\<le> r ^ i\n\ngoal (1 subgoal):\n 1. r choose i \\<le> r ^ i", "by simp"], ["proof (state)\nthis:\n  r choose i \\<le> r ^ i\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<And>nat. r = Suc nat \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "also"], ["proof (state)\nthis:\n  r choose i \\<le> r ^ i\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<And>nat. r = Suc nat \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "have \"\\<dots> \\<le> r^d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ^ i \\<le> r ^ d", "using power_increasing[OF \\<open>i \\<le> d\\<close>, of r] Suc"], ["proof (prove)\nusing this:\n  1 \\<le> r \\<Longrightarrow> r ^ i \\<le> r ^ d\n  r = Suc rr\n\ngoal (1 subgoal):\n 1. r ^ i \\<le> r ^ d", "by auto"], ["proof (state)\nthis:\n  r ^ i \\<le> r ^ d\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)\n 2. \\<And>nat. r = Suc nat \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "finally"], ["proof (chain)\npicking this:\n  r choose i \\<le> r ^ d", "show ?thesis"], ["proof (prove)\nusing this:\n  r choose i \\<le> r ^ d\n\ngoal (1 subgoal):\n 1. r choose i \\<le> max 1 (r ^ d)", "by simp"], ["proof (state)\nthis:\n  r choose i \\<le> max 1 (r ^ d)\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> r choose i \\<le> max 1 (r ^ d)", "qed (insert True, simp)"], ["proof (state)\nthis:\n  r choose i \\<le> max 1 (r ^ d)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes b :: \"'a :: archimedean_field\"\n  assumes b: \"0 < b\" \"b < 1\"\nbegin"], ["", "lemma poly_exp_constant_bound: \"\\<exists> p. \\<forall> x. c * b ^ x * of_nat x ^ deg \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "proof (cases \"c \\<le> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p\n 2. \\<not> c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "case True"], ["proof (state)\nthis:\n  c \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p\n 2. \\<not> c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "by (rule exI[of _ 0], intro allI, \n    rule mult_nonpos_nonneg[OF mult_nonpos_nonneg[OF True]], insert b, auto)"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "case False"], ["proof (state)\nthis:\n  \\<not> c \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "hence c: \"c \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> c \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "from poly_exp_bound[OF b, of deg]"], ["proof (chain)\npicking this:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p", "obtain p where \"\\<And> x. b ^ x * of_nat x ^ deg \\<le> p\""], ["proof (prove)\nusing this:\n  \\<exists>p. \\<forall>x. b ^ x * of_nat x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>x. b ^ x * of_nat x ^ deg \\<le> p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b ^ ?x * of_nat ?x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> (0::'a) \\<Longrightarrow>\n    \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "from mult_left_mono[OF this c]"], ["proof (chain)\npicking this:\n  c * (b ^ ?x1 * of_nat ?x1 ^ deg) \\<le> c * p", "show ?thesis"], ["proof (prove)\nusing this:\n  c * (b ^ ?x1 * of_nat ?x1 ^ deg) \\<le> c * p\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "by (intro exI[of _ \"c * p\"], auto simp: ac_simps)"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_exp_max_constant_bound: \"\\<exists> p. \\<forall> x. c * b ^ x * max 1 (of_nat x ^ deg) \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> p", "from poly_exp_constant_bound[of c deg]"], ["proof (chain)\npicking this:\n  \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p", "obtain p where\n    p: \"\\<And> x. c * b ^ x * of_nat x ^ deg \\<le> p\""], ["proof (prove)\nusing this:\n  \\<exists>p. \\<forall>x. c * b ^ x * of_nat x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>x. c * b ^ x * of_nat x ^ deg \\<le> p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c * b ^ ?x * of_nat ?x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. \\<forall>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> p", "proof (rule exI[of _ \"max p c\"], intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "let ?exp = \"of_nat x ^ deg :: 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "show \"c * b ^ x * max 1 ?exp \\<le> max p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "hence \"?exp \\<noteq> of_nat 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat x ^ deg \\<noteq> of_nat 0", "by simp"], ["proof (state)\nthis:\n  of_nat x ^ deg \\<noteq> of_nat 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "hence \"?exp \\<ge> 1\""], ["proof (prove)\nusing this:\n  of_nat x ^ deg \\<noteq> of_nat 0\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> of_nat x ^ deg", "by (metis less_one not_less of_nat_1 of_nat_less_iff of_nat_power)"], ["proof (state)\nthis:\n  (1::'a) \\<le> of_nat x ^ deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "hence \"max 1 ?exp = ?exp\""], ["proof (prove)\nusing this:\n  (1::'a) \\<le> of_nat x ^ deg\n\ngoal (1 subgoal):\n 1. max (1::'a) (of_nat x ^ deg) = of_nat x ^ deg", "by simp"], ["proof (state)\nthis:\n  max (1::'a) (of_nat x ^ deg) = of_nat x ^ deg\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "thus ?thesis"], ["proof (prove)\nusing this:\n  max (1::'a) (of_nat x ^ deg) = of_nat x ^ deg\n\ngoal (1 subgoal):\n 1. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "using p[of x]"], ["proof (prove)\nusing this:\n  max (1::'a) (of_nat x ^ deg) = of_nat x ^ deg\n  c * b ^ x * of_nat x ^ deg \\<le> p\n\ngoal (1 subgoal):\n 1. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "by simp"], ["proof (state)\nthis:\n  c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow>\n    c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c", "qed (cases deg, auto)"], ["proof (state)\nthis:\n  c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> max p c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. \\<forall>x. c * b ^ x * max (1::'a) (of_nat x ^ deg) \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context\n  fixes a :: \"'a :: real_normed_field\"\nbegin"], ["", "lemma jordan_block_bound: \n  assumes i: \"i < n\" and j: \"j < n\"\n  shows \"norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)) \n    \\<le> norm a ^ (k + i - j) * max 1 (of_nat k ^ (n - 1))\"\n    (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "have id: \"(jordan_block n a ^\\<^sub>m k) $$ (i,j) = (if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (jordan_block n a ^\\<^sub>m k) $$ (i, j) =\n    (if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n     else (0::'a))", "unfolding jordan_block_pow"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n         else (0::'a)) $$\n    (i, j) =\n    (if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n     else (0::'a))", "using i j"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n         else (0::'a)) $$\n    (i, j) =\n    (if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  (jordan_block n a ^\\<^sub>m k) $$ (i, j) =\n  (if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "from i j"], ["proof (chain)\npicking this:\n  i < n\n  j < n", "have diff: \"j - i \\<le> n - 1\""], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. j - i \\<le> n - 1", "by auto"], ["proof (state)\nthis:\n  j - i \\<le> n - 1\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "proof (cases \"i \\<le> j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n 2. \\<not> i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> j\n\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n 2. \\<not> i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "unfolding id"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. norm\n     (if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n      else (0::'a))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "by simp"], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "case True"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "hence \"?lhs = norm (of_nat (k choose (j - i)) * a ^ (k + i - j))\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) =\n    norm (of_nat (k choose (j - i)) * a ^ (k + i - j))", "unfolding id"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. norm\n     (if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n      else (0::'a)) =\n    norm (of_nat (k choose (j - i)) * a ^ (k + i - j))", "by simp"], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) =\n  norm (of_nat (k choose (j - i)) * a ^ (k + i - j))\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "also"], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) =\n  norm (of_nat (k choose (j - i)) * a ^ (k + i - j))\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "have \"\\<dots> \\<le> norm (of_nat (k choose (j - i)) :: 'a) * norm (a ^ (k + i - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i)) * a ^ (k + i - j))\n    \\<le> norm (of_nat (k choose (j - i))) * norm (a ^ (k + i - j))", "by (rule norm_mult_ineq)"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i)) * a ^ (k + i - j))\n  \\<le> norm (of_nat (k choose (j - i))) * norm (a ^ (k + i - j))\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "also"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i)) * a ^ (k + i - j))\n  \\<le> norm (of_nat (k choose (j - i))) * norm (a ^ (k + i - j))\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "have \"\\<dots> \\<le> (max 1 (of_nat k ^ (n - 1))) * norm a ^ (k + i - j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i))) * norm (a ^ (k + i - j))\n    \\<le> max 1 (real k ^ (n - 1)) * norm a ^ (k + i - j)", "proof (rule mult_mono[OF _ norm_power_ineq _ norm_ge_zero])"], ["proof (state)\ngoal (2 subgoals):\n 1. norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))\n 2. 0 \\<le> max 1 (real k ^ (n - 1))", "have \"k choose (j - i) \\<le> max 1 (k ^ (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k choose (j - i) \\<le> max 1 (k ^ (n - 1))", "by (rule choose_poly_bound[OF diff])"], ["proof (state)\nthis:\n  k choose (j - i) \\<le> max 1 (k ^ (n - 1))\n\ngoal (2 subgoals):\n 1. norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))\n 2. 0 \\<le> max 1 (real k ^ (n - 1))", "hence \"norm (of_nat (k choose (j - i)) :: 'a) \\<le> of_nat (max 1 (k ^ (n - 1)))\""], ["proof (prove)\nusing this:\n  k choose (j - i) \\<le> max 1 (k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i))) \\<le> real (max 1 (k ^ (n - 1)))", "unfolding norm_of_nat of_nat_le_iff"], ["proof (prove)\nusing this:\n  k choose (j - i) \\<le> max 1 (k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. k choose (j - i) \\<le> max 1 (k ^ (n - 1))", "."], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i))) \\<le> real (max 1 (k ^ (n - 1)))\n\ngoal (2 subgoals):\n 1. norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))\n 2. 0 \\<le> max 1 (real k ^ (n - 1))", "also"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i))) \\<le> real (max 1 (k ^ (n - 1)))\n\ngoal (2 subgoals):\n 1. norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))\n 2. 0 \\<le> max 1 (real k ^ (n - 1))", "have \"\\<dots> = max 1 (of_nat k ^ (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (max 1 (k ^ (n - 1))) = max 1 (real k ^ (n - 1))", "by (metis max_def of_nat_1 of_nat_le_iff of_nat_power)"], ["proof (state)\nthis:\n  real (max 1 (k ^ (n - 1))) = max 1 (real k ^ (n - 1))\n\ngoal (2 subgoals):\n 1. norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))\n 2. 0 \\<le> max 1 (real k ^ (n - 1))", "finally"], ["proof (chain)\npicking this:\n  norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))", "show \"norm (of_nat (k choose (j - i)) :: 'a) \\<le> max 1 (real_of_nat k ^ (n - 1))\""], ["proof (prove)\nusing this:\n  norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))", "."], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i))) \\<le> max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. 0 \\<le> max 1 (real k ^ (n - 1))", "qed simp"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i))) * norm (a ^ (k + i - j))\n  \\<le> max 1 (real k ^ (n - 1)) * norm a ^ (k + i - j)\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "also"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i))) * norm (a ^ (k + i - j))\n  \\<le> max 1 (real k ^ (n - 1)) * norm a ^ (k + i - j)\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max 1 (real k ^ (n - 1)) * norm a ^ (k + i - j) =\n    norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "by simp"], ["proof (state)\nthis:\n  max 1 (real k ^ (n - 1)) * norm a ^ (k + i - j) =\n  norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "finally"], ["proof (chain)\npicking this:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "."], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_block_poly_bound: \n  assumes i: \"i < n\" and j: \"j < n\" and a: \"norm a = 1\"\n  shows \"norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)) \\<le> max 1 (of_nat k ^ (n - 1))\"\n    (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> max 1 (real k ^ (n - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> max 1 (real k ^ (n - 1))", "from jordan_block_bound[OF i j, of k, unfolded a]"], ["proof (chain)\npicking this:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> 1 ^ (k + i - j) * max 1 (real k ^ (n - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> 1 ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> max 1 (real k ^ (n - 1))", "by simp"], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> max 1 (real k ^ (n - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem jordan_block_constant_bound: assumes a: \"norm a < 1\" \n  shows \"\\<exists> p. \\<forall> i j k. i < n \\<longrightarrow> j < n \\<longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)) \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "case True"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "proof (rule exI[of _ 1], intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> 1", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> 1", "assume *: \"i < n\" \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> 1", "{"], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> 1", "assume ij: \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> 1", "have \"norm ((of_nat (k choose (j - i)) :: 'a) * 0 ^ (k + i - j)) \\<le> 1\" (is \"norm ?lhs \\<le> 1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "proof (cases \"k + i > j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n 2. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "case True"], ["proof (state)\nthis:\n  j < k + i\n\ngoal (2 subgoals):\n 1. j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n 2. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "hence \"?lhs = 0\""], ["proof (prove)\nusing this:\n  j < k + i\n\ngoal (1 subgoal):\n 1. of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)\n\ngoal (2 subgoals):\n 1. j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n 2. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "also"], ["proof (state)\nthis:\n  of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)\n\ngoal (2 subgoals):\n 1. j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n 2. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "have \"norm (\\<dots>) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (0::'a) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  norm (0::'a) \\<le> 1\n\ngoal (2 subgoals):\n 1. j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n 2. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "."], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "case False"], ["proof (state)\nthis:\n  \\<not> j < k + i\n\ngoal (1 subgoal):\n 1. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "hence id: \"?lhs = (of_nat (k choose (j - i)) :: 'a)\" and j: \"j - i \\<ge> k\""], ["proof (prove)\nusing this:\n  \\<not> j < k + i\n\ngoal (1 subgoal):\n 1. of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) =\n    of_nat (k choose (j - i)) &&&\n    k \\<le> j - i", "by auto"], ["proof (state)\nthis:\n  of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) =\n  of_nat (k choose (j - i))\n  k \\<le> j - i\n\ngoal (1 subgoal):\n 1. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "from j"], ["proof (chain)\npicking this:\n  k \\<le> j - i", "have \"k choose (j - i) = 0 \\<or> k choose (j - i) = 1\""], ["proof (prove)\nusing this:\n  k \\<le> j - i\n\ngoal (1 subgoal):\n 1. k choose (j - i) = 0 \\<or> k choose (j - i) = 1", "by (simp add: nat_less_le)"], ["proof (state)\nthis:\n  k choose (j - i) = 0 \\<or> k choose (j - i) = 1\n\ngoal (1 subgoal):\n 1. \\<not> j < k + i \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "thus \"norm ?lhs \\<le> 1\""], ["proof (prove)\nusing this:\n  k choose (j - i) = 0 \\<or> k choose (j - i) = 1\n\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k choose (j - i) = 0 \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n 2. k choose (j - i) = 1 \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "assume k: \"k choose (j - i) = 0\""], ["proof (state)\nthis:\n  k choose (j - i) = 0\n\ngoal (2 subgoals):\n 1. k choose (j - i) = 0 \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n 2. k choose (j - i) = 1 \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "unfolding id k"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat 0 * (0::'a) ^ (k + i - j)) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. k choose (j - i) = 1 \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k choose (j - i) = 1 \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "assume k: \"k choose (j - i) = 1\""], ["proof (state)\nthis:\n  k choose (j - i) = 1\n\ngoal (1 subgoal):\n 1. k choose (j - i) = 1 \\<Longrightarrow>\n    norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat (k choose (j - i))) \\<le> 1", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_nat 1) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> 1", "}"], ["proof (state)\nthis:\n  i \\<le> j \\<Longrightarrow>\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> 1", "thus \"norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)) \\<le> 1\""], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow>\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> 1", "unfolding True"], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow>\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n (0::'a) ^\\<^sub>m k) $$ (i, j)) \\<le> 1", "unfolding jordan_block_pow"], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow>\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n\ngoal (1 subgoal):\n 1. norm\n     (mat n n\n       (\\<lambda>(i, j).\n           if i \\<le> j\n           then of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)\n           else (0::'a)) $$\n      (i, j))\n    \\<le> 1", "using *"], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow>\n  norm (of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)) \\<le> 1\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. norm\n     (mat n n\n       (\\<lambda>(i, j).\n           if i \\<le> j\n           then of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)\n           else (0::'a)) $$\n      (i, j))\n    \\<le> 1", "by auto"], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     \\<forall>i j k.\n        i < n \\<longrightarrow>\n        j < n \\<longrightarrow>\n        norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "case False"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "hence na: \"norm a > 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < norm a", "by auto"], ["proof (state)\nthis:\n  0 < norm a\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "define c where \"c = inverse (norm a ^ n)\""], ["proof (state)\nthis:\n  c = inverse (norm a ^ n)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "define deg where \"deg = n - 1\""], ["proof (state)\nthis:\n  deg = n - 1\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "have c: \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < inverse (norm a ^ n)", "using na"], ["proof (prove)\nusing this:\n  0 < norm a\n\ngoal (1 subgoal):\n 1. 0 < inverse (norm a ^ n)", "by auto"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "define b where \"b = norm a\""], ["proof (state)\nthis:\n  b = norm a\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "from a na"], ["proof (chain)\npicking this:\n  norm a < 1\n  0 < norm a", "have \"0 < b\" \"b < 1\""], ["proof (prove)\nusing this:\n  norm a < 1\n  0 < norm a\n\ngoal (1 subgoal):\n 1. 0 < b &&& b < 1", "unfolding b_def"], ["proof (prove)\nusing this:\n  norm a < 1\n  0 < norm a\n\ngoal (1 subgoal):\n 1. 0 < norm a &&& norm a < 1", "by auto"], ["proof (state)\nthis:\n  0 < b\n  b < 1\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "from poly_exp_max_constant_bound[OF this, of c deg]"], ["proof (chain)\npicking this:\n  \\<exists>p. \\<forall>x. c * b ^ x * max 1 (real x ^ deg) \\<le> p", "obtain p where \"\\<And> k. c * b ^ k * max 1 (of_nat k ^ deg) \\<le> p\""], ["proof (prove)\nusing this:\n  \\<exists>p. \\<forall>x. c * b ^ x * max 1 (real x ^ deg) \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>k.\n            c * b ^ k * max 1 (real k ^ deg) \\<le> p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c * b ^ ?k * max 1 (real ?k ^ deg) \\<le> p\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       \\<forall>i j k.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow>\n          norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "proof (intro exI[of _ p], intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "assume ij: \"i < n\" \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "from jordan_block_bound[OF this]"], ["proof (chain)\npicking this:\n  norm ((jordan_block n a ^\\<^sub>m ?k) $$ (i, j))\n  \\<le> norm a ^ (?k + i - j) * max 1 (real ?k ^ (n - 1))", "have \"norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n      \\<le> norm a ^ (k + i - j) * max 1 (real_of_nat k ^ (n - 1))\""], ["proof (prove)\nusing this:\n  norm ((jordan_block n a ^\\<^sub>m ?k) $$ (i, j))\n  \\<le> norm a ^ (?k + i - j) * max 1 (real ?k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))", "."], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "also"], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n  \\<le> norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "have \"\\<dots> \\<le> c * norm a ^ k * max 1 (real_of_nat k ^ (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n    \\<le> c * norm a ^ k * max 1 (real k ^ (n - 1))", "proof (rule mult_right_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm a ^ (k + i - j) \\<le> c * norm a ^ k\n 2. 0 \\<le> max 1 (real k ^ (n - 1))", "from ij"], ["proof (chain)\npicking this:\n  i < n\n  j < n", "have \"i - j \\<le> n\""], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. i - j \\<le> n", "by auto"], ["proof (state)\nthis:\n  i - j \\<le> n\n\ngoal (2 subgoals):\n 1. norm a ^ (k + i - j) \\<le> c * norm a ^ k\n 2. 0 \\<le> max 1 (real k ^ (n - 1))", "show \"norm a ^ (k + i - j) \\<le> c * norm a ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a ^ (k + i - j) \\<le> c * norm a ^ k", "proof (rule mult_left_le_imp_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?c * norm a ^ (k + i - j) \\<le> ?c * (c * norm a ^ k)\n 2. 0 < ?c", "show \"0 < norm a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < norm a ^ n", "using na"], ["proof (prove)\nusing this:\n  0 < norm a\n\ngoal (1 subgoal):\n 1. 0 < norm a ^ n", "by auto"], ["proof (state)\nthis:\n  0 < norm a ^ n\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "let ?lhs = \"norm a ^ n * norm a ^ (k + i - j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "let ?rhs = \"norm a ^ n * (c * norm a ^ k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "from ij"], ["proof (chain)\npicking this:\n  i < n\n  j < n", "have ge: \"n + (k + i - j) \\<ge> k\""], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. k \\<le> n + (k + i - j)", "by arith"], ["proof (state)\nthis:\n  k \\<le> n + (k + i - j)\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "have \"?lhs = norm a ^ (n + (k + i - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) = norm a ^ (n + (k + i - j))", "by (simp add: power_add)"], ["proof (state)\nthis:\n  norm a ^ n * norm a ^ (k + i - j) = norm a ^ (n + (k + i - j))\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "also"], ["proof (state)\nthis:\n  norm a ^ n * norm a ^ (k + i - j) = norm a ^ (n + (k + i - j))\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "have \"\\<dots> \\<le> norm a ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a ^ (n + (k + i - j)) \\<le> norm a ^ k", "using ge a na"], ["proof (prove)\nusing this:\n  k \\<le> n + (k + i - j)\n  norm a < 1\n  0 < norm a\n\ngoal (1 subgoal):\n 1. norm a ^ (n + (k + i - j)) \\<le> norm a ^ k", "using less_imp_le power_decreasing"], ["proof (prove)\nusing this:\n  k \\<le> n + (k + i - j)\n  norm a < 1\n  0 < norm a\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n  \\<lbrakk>?n \\<le> ?N; (0::?'a) \\<le> ?a; ?a \\<le> (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a ^ ?N \\<le> ?a ^ ?n\n\ngoal (1 subgoal):\n 1. norm a ^ (n + (k + i - j)) \\<le> norm a ^ k", "by blast"], ["proof (state)\nthis:\n  norm a ^ (n + (k + i - j)) \\<le> norm a ^ k\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "also"], ["proof (state)\nthis:\n  norm a ^ (n + (k + i - j)) \\<le> norm a ^ k\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a ^ k = norm a ^ n * (c * norm a ^ k)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a ^ k = norm a ^ n * (inverse (norm a ^ n) * norm a ^ k)", "using na"], ["proof (prove)\nusing this:\n  0 < norm a\n\ngoal (1 subgoal):\n 1. norm a ^ k = norm a ^ n * (inverse (norm a ^ n) * norm a ^ k)", "by simp"], ["proof (state)\nthis:\n  norm a ^ k = norm a ^ n * (c * norm a ^ k)\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "finally"], ["proof (chain)\npicking this:\n  norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)\n\ngoal (1 subgoal):\n 1. norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)", "."], ["proof (state)\nthis:\n  norm a ^ n * norm a ^ (k + i - j) \\<le> norm a ^ n * (c * norm a ^ k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm a ^ (k + i - j) \\<le> c * norm a ^ k\n\ngoal (1 subgoal):\n 1. 0 \\<le> max 1 (real k ^ (n - 1))", "qed simp"], ["proof (state)\nthis:\n  norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n  \\<le> c * norm a ^ k * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "also"], ["proof (state)\nthis:\n  norm a ^ (k + i - j) * max 1 (real k ^ (n - 1))\n  \\<le> c * norm a ^ k * max 1 (real k ^ (n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "have \"\\<dots> = c * b ^ k * max 1 (real_of_nat k ^ deg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * norm a ^ k * max 1 (real k ^ (n - 1)) =\n    c * b ^ k * max 1 (real k ^ deg)", "unfolding b_def deg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * norm a ^ k * max 1 (real k ^ (n - 1)) =\n    c * norm a ^ k * max 1 (real k ^ (n - 1))", ".."], ["proof (state)\nthis:\n  c * norm a ^ k * max 1 (real k ^ (n - 1)) =\n  c * b ^ k * max 1 (real k ^ deg)\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "also"], ["proof (state)\nthis:\n  c * norm a ^ k * max 1 (real k ^ (n - 1)) =\n  c * b ^ k * max 1 (real k ^ deg)\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "have \"\\<dots> \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * b ^ k * max 1 (real k ^ deg) \\<le> p", "by fact"], ["proof (state)\nthis:\n  c * b ^ k * max 1 (real k ^ deg) \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                         \\<le> p", "finally"], ["proof (chain)\npicking this:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "show \"norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\""], ["proof (prove)\nusing this:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p", "."], ["proof (state)\nthis:\n  norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     \\<forall>i j k.\n        i < n \\<longrightarrow>\n        j < n \\<longrightarrow>\n        norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["", "definition norm_bound :: \"'a mat \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"norm_bound A b \\<equiv> \\<forall> i j. i < dim_row A \\<longrightarrow> j < dim_col A \\<longrightarrow> norm (A $$ (i,j)) \\<le> b\""], ["", "lemma norm_boundI[intro]:\n  assumes \"\\<And> i j. i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> norm (A $$ (i,j)) \\<le> b\"\n  shows \"norm_bound A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.norm_bound A b", "unfolding norm_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < dim_row A \\<longrightarrow>\n       j < dim_col A \\<longrightarrow> norm (A $$ (i, j)) \\<le> b", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> norm (A $$ (?i, ?j)) \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < dim_row A \\<longrightarrow>\n       j < dim_col A \\<longrightarrow> norm (A $$ (i, j)) \\<le> b", "by blast"], ["", "lemma  jordan_block_constant_bound2:\n\"\\<exists>p. norm (a :: 'a :: real_normed_field) < 1 \\<longrightarrow>\n    (\\<forall>i j k. i < n \\<longrightarrow> j < n \\<longrightarrow> norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       norm a < 1 \\<longrightarrow>\n       (\\<forall>i j k.\n           i < n \\<longrightarrow>\n           j < n \\<longrightarrow>\n           norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p)", "using jordan_block_constant_bound"], ["proof (prove)\nusing this:\n  norm a < 1 \\<Longrightarrow>\n  \\<exists>p.\n     \\<forall>i j k.\n        i < ?n \\<longrightarrow>\n        j < ?n \\<longrightarrow>\n        norm ((jordan_block ?n a ^\\<^sub>m k) $$ (i, j)) \\<le> p\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       norm a < 1 \\<longrightarrow>\n       (\\<forall>i j k.\n           i < n \\<longrightarrow>\n           j < n \\<longrightarrow>\n           norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)) \\<le> p)", "by auto"], ["", "lemma jordan_matrix_poly_bound2:\n  fixes n_as :: \"(nat \\<times> 'a) list\"\n  assumes n_as: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> n > 0 \\<Longrightarrow> norm a \\<le> 1\"\n  and N: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> n \\<le> N\"\n  shows \"\\<exists>c1. \\<forall>k. \\<forall>e \\<in> elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n    norm e \\<le> c1 + of_nat k ^ (N - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "from jordan_matrix_carrier[of n_as]"], ["proof (chain)\npicking this:\n  jordan_matrix n_as\n  \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))", "obtain d where\n    jm: \"jordan_matrix n_as \\<in> carrier_mat d d\""], ["proof (prove)\nusing this:\n  jordan_matrix n_as\n  \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        jordan_matrix n_as \\<in> carrier_mat d d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  jordan_matrix n_as \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "define f where \"f = (\\<lambda>n (a::'a) i j k. norm ((jordan_block n a ^\\<^sub>m k) $$ (i,j)))\""], ["proof (state)\nthis:\n  f = (\\<lambda>n a i j k. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j)))\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "let ?g = \"\\<lambda>k c1. c1 + of_nat k ^ (N-1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "let ?P = \"\\<lambda>n (a::'a) i j k c1. f n a i j k \\<le> ?g k c1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "define Q where \"Q = (\\<lambda>n (a::'a) k c1. \\<forall>i j. i<n \\<longrightarrow> j<n \\<longrightarrow> ?P n a i j k c1)\""], ["proof (state)\nthis:\n  Q =\n  (\\<lambda>n a k c1.\n      \\<forall>i j.\n         i < n \\<longrightarrow>\n         j < n \\<longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "have \"\\<And> c c' k n a i j. c \\<le> c' \\<Longrightarrow> ?P n a i j k c \\<Longrightarrow> ?P n a i j k c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c c' k n a i j.\n       \\<lbrakk>c \\<le> c'; f n a i j k \\<le> c + real k ^ (N - 1)\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> c' + real k ^ (N - 1)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?c1 \\<le> ?c'1;\n   f ?n1 ?a1 ?i1 ?j1 ?k1 \\<le> ?c1 + real ?k1 ^ (N - 1)\\<rbrakk>\n  \\<Longrightarrow> f ?n1 ?a1 ?i1 ?j1 ?k1 \\<le> ?c'1 + real ?k1 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "hence Q_mono: \"\\<And>n a c c'. c \\<le> c' \\<Longrightarrow> \\<forall>k. Q n a k c \\<Longrightarrow> \\<forall>k. Q n a k c'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?c1 \\<le> ?c'1;\n   f ?n1 ?a1 ?i1 ?j1 ?k1 \\<le> ?c1 + real ?k1 ^ (N - 1)\\<rbrakk>\n  \\<Longrightarrow> f ?n1 ?a1 ?i1 ?j1 ?k1 \\<le> ?c'1 + real ?k1 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<And>n a c c'.\n       \\<lbrakk>c \\<le> c'; \\<forall>k. Q n a k c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k. Q n a k c'", "unfolding Q_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c1 \\<le> ?c'1;\n   f ?n1 ?a1 ?i1 ?j1 ?k1 \\<le> ?c1 + real ?k1 ^ (N - 1)\\<rbrakk>\n  \\<Longrightarrow> f ?n1 ?a1 ?i1 ?j1 ?k1 \\<le> ?c'1 + real ?k1 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<And>n a c c'.\n       \\<lbrakk>c \\<le> c';\n        \\<forall>k i j.\n           i < n \\<longrightarrow>\n           j < n \\<longrightarrow>\n           f n a i j k \\<le> c + real k ^ (N - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k i j.\n                            i < n \\<longrightarrow>\n                            j < n \\<longrightarrow>\n                            f n a i j k \\<le> c' + real k ^ (N - 1)", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>?c1 \\<le> ?c'1; \\<forall>k. Q ?n1 ?a1 k ?c1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k. Q ?n1 ?a1 k ?c'1\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?c1 \\<le> ?c'1; \\<forall>k. Q ?n1 ?a1 k ?c1\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k. Q ?n1 ?a1 k ?c'1\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "fix n a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "assume na: \"(n,a) \\<in> set n_as\""], ["proof (state)\nthis:\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "obtain c where c: \"norm a < 1 \\<longrightarrow> (\\<forall>i j k. i < n \\<longrightarrow> j < n \\<longrightarrow> f n a i j k \\<le> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        norm a < 1 \\<longrightarrow>\n        (\\<forall>i j k.\n            i < n \\<longrightarrow>\n            j < n \\<longrightarrow> f n a i j k \\<le> c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (rule exE[OF jordan_block_constant_bound2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>c.\n                   norm a < 1 \\<longrightarrow>\n                   (\\<forall>i j k.\n                       i < n \\<longrightarrow>\n                       j < n \\<longrightarrow>\n                       f n a i j k \\<le> c) \\<Longrightarrow>\n                   thesis;\n        norm a < 1 \\<longrightarrow>\n        (\\<forall>i j k.\n            i < ?n4 \\<longrightarrow>\n            j < ?n4 \\<longrightarrow>\n            norm ((jordan_block ?n4 a ^\\<^sub>m k) $$ (i, j))\n            \\<le> x)\\<rbrakk>\n       \\<Longrightarrow> thesis", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>c.\n                   norm a < 1 \\<longrightarrow>\n                   (\\<forall>i j k.\n                       i < n \\<longrightarrow>\n                       j < n \\<longrightarrow>\n                       norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                       \\<le> c) \\<Longrightarrow>\n                   thesis;\n        norm a < 1 \\<longrightarrow>\n        (\\<forall>i j k.\n            i < ?n4 \\<longrightarrow>\n            j < ?n4 \\<longrightarrow>\n            norm ((jordan_block ?n4 a ^\\<^sub>m k) $$ (i, j))\n            \\<le> x)\\<rbrakk>\n       \\<Longrightarrow> thesis", "using Jordan_Normal_Form.jordan_block_constant_bound2"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     norm ?a < 1 \\<longrightarrow>\n     (\\<forall>i j k.\n         i < ?n \\<longrightarrow>\n         j < ?n \\<longrightarrow>\n         norm ((jordan_block ?n ?a ^\\<^sub>m k) $$ (i, j)) \\<le> p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>c.\n                   norm a < 1 \\<longrightarrow>\n                   (\\<forall>i j k.\n                       i < n \\<longrightarrow>\n                       j < n \\<longrightarrow>\n                       norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n                       \\<le> c) \\<Longrightarrow>\n                   thesis;\n        norm a < 1 \\<longrightarrow>\n        (\\<forall>i j k.\n            i < ?n4 \\<longrightarrow>\n            j < ?n4 \\<longrightarrow>\n            norm ((jordan_block ?n4 a ^\\<^sub>m k) $$ (i, j))\n            \\<le> x)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by metis"], ["proof (state)\nthis:\n  norm a < 1 \\<longrightarrow>\n  (\\<forall>i j k.\n      i < n \\<longrightarrow> j < n \\<longrightarrow> f n a i j k \\<le> c)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "define c1 where \"c1 = max 1 c\""], ["proof (state)\nthis:\n  c1 = max 1 c\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "then"], ["proof (chain)\npicking this:\n  c1 = max 1 c", "have \"c1 \\<ge> 1\" \"c1 \\<ge> c\""], ["proof (prove)\nusing this:\n  c1 = max 1 c\n\ngoal (1 subgoal):\n 1. 1 \\<le> c1 &&& c \\<le> c1", "by auto"], ["proof (state)\nthis:\n  1 \\<le> c1\n  c \\<le> c1\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "have \"\\<exists>c1. \\<forall>k i j. i < n \\<longrightarrow> j < n \\<longrightarrow> ?P n a i j k c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k i j.\n          i < n \\<longrightarrow>\n          j < n \\<longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)", "proof rule+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> ?c1.0 + real k ^ (N - 1)", "fix i j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> ?c1.0 + real k ^ (N - 1)", "assume \"i < n\" \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>k i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> ?c1.0 + real k ^ (N - 1)", "then"], ["proof (chain)\npicking this:\n  i < n\n  j < n", "have \"0<n\""], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>k i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> ?c1.0 + real k ^ (N - 1)", "let ?jbs = \"map (\\<lambda>(n,a). jordan_block n a) n_as\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> ?c1.0 + real k ^ (N - 1)", "have sq_jbs: \"Ball (set ?jbs) square_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (map (\\<lambda>(n, a). jordan_block n a) n_as)) square_mat", "by auto"], ["proof (state)\nthis:\n  Ball (set (map (\\<lambda>(n, a). jordan_block n a) n_as)) square_mat\n\ngoal (1 subgoal):\n 1. \\<And>k i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> ?c1.0 + real k ^ (N - 1)", "have \"jordan_matrix n_as ^\\<^sub>m k = diag_block_mat (map (\\<lambda>A. A ^\\<^sub>m k) ?jbs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix n_as ^\\<^sub>m k =\n    diag_block_mat\n     (map (\\<lambda>A. A ^\\<^sub>m k)\n       (map (\\<lambda>(n, a). jordan_block n a) n_as))", "unfolding jordan_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as) ^\\<^sub>m\n    k =\n    diag_block_mat\n     (map (\\<lambda>A. A ^\\<^sub>m k)\n       (map (\\<lambda>(n, a). jordan_block n a) n_as))", "using diag_block_pow_mat[OF sq_jbs]"], ["proof (prove)\nusing this:\n  diag_block_mat (map (\\<lambda>(n, a). jordan_block n a) n_as) ^\\<^sub>m\n  ?n =\n  diag_block_mat\n   (map (\\<lambda>A. A ^\\<^sub>m ?n)\n     (map (\\<lambda>(n, a). jordan_block n a) n_as))\n\ngoal (1 subgoal):\n 1. diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as) ^\\<^sub>m\n    k =\n    diag_block_mat\n     (map (\\<lambda>A. A ^\\<^sub>m k)\n       (map (\\<lambda>(n, a). jordan_block n a) n_as))", "by auto"], ["proof (state)\nthis:\n  jordan_matrix n_as ^\\<^sub>m k =\n  diag_block_mat\n   (map (\\<lambda>A. A ^\\<^sub>m k)\n     (map (\\<lambda>(n, a). jordan_block n a) n_as))\n\ngoal (1 subgoal):\n 1. \\<And>k i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> f n a i j k \\<le> ?c1.0 + real k ^ (N - 1)", "show \"?P n a i j k c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n a i j k \\<le> c1 + real k ^ (N - 1)", "proof (cases \"norm a = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "case True"], ["proof (state)\nthis:\n  norm a = 1\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "{"], ["proof (state)\nthis:\n  norm a = 1\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "have nN:\"n-1 \\<le> N-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 1 \\<le> N - 1", "using N[OF na] True"], ["proof (prove)\nusing this:\n  norm a = 1 \\<Longrightarrow> n \\<le> N\n  norm a = 1\n\ngoal (1 subgoal):\n 1. n - 1 \\<le> N - 1", "by auto"], ["proof (state)\nthis:\n  n - 1 \\<le> N - 1\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "have \"f n a i j k \\<le> max 1 (of_nat k ^ (n-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n a i j k \\<le> max 1 (real k ^ (n - 1))", "using Jordan_Normal_Form.jordan_block_poly_bound True \\<open>i<n\\<close> \\<open>j<n\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?n; ?j < ?n; norm ?a = 1\\<rbrakk>\n  \\<Longrightarrow> norm ((jordan_block ?n ?a ^\\<^sub>m ?k) $$ (?i, ?j))\n                    \\<le> max 1 (real ?k ^ (?n - 1))\n  norm a = 1\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. f n a i j k \\<le> max 1 (real k ^ (n - 1))", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?n; ?j < ?n; norm ?a = 1\\<rbrakk>\n  \\<Longrightarrow> norm ((jordan_block ?n ?a ^\\<^sub>m ?k) $$ (?i, ?j))\n                    \\<le> max 1 (real ?k ^ (?n - 1))\n  norm a = 1\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. norm ((jordan_block n a ^\\<^sub>m k) $$ (i, j))\n    \\<le> max 1 (real k ^ (n - 1))", "by auto"], ["proof (state)\nthis:\n  f n a i j k \\<le> max 1 (real k ^ (n - 1))\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "also"], ["proof (state)\nthis:\n  f n a i j k \\<le> max 1 (real k ^ (n - 1))\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "have \"... \\<le> max 1 (of_nat k ^ (N-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))", "proof (cases \"k=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))", "by (subst max.mono[OF _ power_increasing[OF nN]], auto)"], ["proof (state)\nthis:\n  max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow>\n    max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))", "qed (simp add: power_eq_if)"], ["proof (state)\nthis:\n  max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "also"], ["proof (state)\nthis:\n  max 1 (real k ^ (n - 1)) \\<le> max 1 (real k ^ (N - 1))\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "have \"... \\<le> max c1 (of_nat k ^ (N-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max 1 (real k ^ (N - 1)) \\<le> max c1 (real k ^ (N - 1))", "using \\<open>c1\\<ge>1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> c1\n\ngoal (1 subgoal):\n 1. max 1 (real k ^ (N - 1)) \\<le> max c1 (real k ^ (N - 1))", "by auto"], ["proof (state)\nthis:\n  max 1 (real k ^ (N - 1)) \\<le> max c1 (real k ^ (N - 1))\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "also"], ["proof (state)\nthis:\n  max 1 (real k ^ (N - 1)) \\<le> max c1 (real k ^ (N - 1))\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "have \"... \\<le> c1 + (of_nat k ^ (N-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max c1 (real k ^ (N - 1)) \\<le> c1 + real k ^ (N - 1)", "using \\<open>c1\\<ge>1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> c1\n\ngoal (1 subgoal):\n 1. max c1 (real k ^ (N - 1)) \\<le> c1 + real k ^ (N - 1)", "by auto"], ["proof (state)\nthis:\n  max c1 (real k ^ (N - 1)) \\<le> c1 + real k ^ (N - 1)\n\ngoal (2 subgoals):\n 1. norm a = 1 \\<Longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n 2. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "finally"], ["proof (chain)\npicking this:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. f n a i j k \\<le> c1 + real k ^ (N - 1)", "by simp"], ["proof (state)\nthis:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "}"], ["proof (state)\nthis:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "case False"], ["proof (state)\nthis:\n  norm a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "{"], ["proof (state)\nthis:\n  norm a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "then"], ["proof (chain)\npicking this:\n  norm a \\<noteq> 1", "have na1: \"norm a < 1\""], ["proof (prove)\nusing this:\n  norm a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. norm a < 1", "using n_as[OF na] \\<open>0<n\\<close>"], ["proof (prove)\nusing this:\n  norm a \\<noteq> 1\n  0 < n \\<Longrightarrow> norm a \\<le> 1\n  0 < n\n\ngoal (1 subgoal):\n 1. norm a < 1", "by auto"], ["proof (state)\nthis:\n  norm a < 1\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "hence \"f n a i j k \\<le> c\""], ["proof (prove)\nusing this:\n  norm a < 1\n\ngoal (1 subgoal):\n 1. f n a i j k \\<le> c", "using c \\<open>i<n\\<close> \\<open>j<n\\<close>"], ["proof (prove)\nusing this:\n  norm a < 1\n  norm a < 1 \\<longrightarrow>\n  (\\<forall>i j k.\n      i < n \\<longrightarrow> j < n \\<longrightarrow> f n a i j k \\<le> c)\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. f n a i j k \\<le> c", "by auto"], ["proof (state)\nthis:\n  f n a i j k \\<le> c\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "also"], ["proof (state)\nthis:\n  f n a i j k \\<le> c\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "have \"... \\<le> c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> c1", "using \\<open>c\\<le>c1\\<close>"], ["proof (prove)\nusing this:\n  c \\<le> c1\n\ngoal (1 subgoal):\n 1. c \\<le> c1", "."], ["proof (state)\nthis:\n  c \\<le> c1\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "also"], ["proof (state)\nthis:\n  c \\<le> c1\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "have \"... \\<le> c1 + of_nat k ^ (N-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 \\<le> c1 + real k ^ (N - 1)", "by auto"], ["proof (state)\nthis:\n  c1 \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. norm a \\<noteq> 1 \\<Longrightarrow>\n    f n a i j k \\<le> c1 + real k ^ (N - 1)", "finally"], ["proof (chain)\npicking this:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. f n a i j k \\<le> c1 + real k ^ (N - 1)", "by auto"], ["proof (state)\nthis:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>c1.\n     \\<forall>k i j.\n        i < n \\<longrightarrow>\n        j < n \\<longrightarrow> f n a i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "}"], ["proof (state)\nthis:\n  (?n3, ?aa3) \\<in> set n_as \\<Longrightarrow>\n  \\<exists>c1.\n     \\<forall>k i j.\n        i < ?n3 \\<longrightarrow>\n        j < ?n3 \\<longrightarrow>\n        f ?n3 ?aa3 i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "hence \"\\<forall>na. \\<exists>c1. na \\<in> set n_as \\<longrightarrow> (\\<forall>k. Q (fst na) (snd na) k c1)\""], ["proof (prove)\nusing this:\n  (?n3, ?aa3) \\<in> set n_as \\<Longrightarrow>\n  \\<exists>c1.\n     \\<forall>k i j.\n        i < ?n3 \\<longrightarrow>\n        j < ?n3 \\<longrightarrow>\n        f ?n3 ?aa3 i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<forall>na.\n       \\<exists>c1.\n          na \\<in> set n_as \\<longrightarrow>\n          (\\<forall>k. Q (fst na) (snd na) k c1)", "unfolding Q_def"], ["proof (prove)\nusing this:\n  (?n3, ?aa3) \\<in> set n_as \\<Longrightarrow>\n  \\<exists>c1.\n     \\<forall>k i j.\n        i < ?n3 \\<longrightarrow>\n        j < ?n3 \\<longrightarrow>\n        f ?n3 ?aa3 i j k \\<le> c1 + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<forall>na.\n       \\<exists>c1.\n          na \\<in> set n_as \\<longrightarrow>\n          (\\<forall>k i j.\n              i < fst na \\<longrightarrow>\n              j < fst na \\<longrightarrow>\n              f (fst na) (snd na) i j k \\<le> c1 + real k ^ (N - 1))", "by auto"], ["proof (state)\nthis:\n  \\<forall>na.\n     \\<exists>c1.\n        na \\<in> set n_as \\<longrightarrow>\n        (\\<forall>k. Q (fst na) (snd na) k c1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        x \\<in> set n_as \\<longrightarrow>\n        (\\<forall>k. Q (fst x) (snd x) k (f x))", "obtain c'\n    where c': \"\\<And> na k. na \\<in> set n_as \\<Longrightarrow> Q (fst na) (snd na) k (c' na)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        x \\<in> set n_as \\<longrightarrow>\n        (\\<forall>k. Q (fst x) (snd x) k (f x))\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        (\\<And>na k.\n            na \\<in> set n_as \\<Longrightarrow>\n            Q (fst na) (snd na) k (c' na)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?na1 \\<in> set n_as \\<Longrightarrow>\n  Q (fst ?na1) (snd ?na1) ?k1 (c' ?na1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "define c where \"c = max 0 (Max (set (map c' n_as)))\""], ["proof (state)\nthis:\n  c = max 0 (Max (set (map c' n_as)))\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "{"], ["proof (state)\nthis:\n  c = max 0 (Max (set (map c' n_as)))\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "fix n a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "assume na: \"(n,a) \\<in> set n_as\""], ["proof (state)\nthis:\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "then"], ["proof (chain)\npicking this:\n  (n, a) \\<in> set n_as", "have Q: \"\\<forall> k. Q n a k (c' (n,a))\""], ["proof (prove)\nusing this:\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. \\<forall>k. Q n a k (c' (n, a))", "using c'[OF na]"], ["proof (prove)\nusing this:\n  (n, a) \\<in> set n_as\n  Q (fst (n, a)) (snd (n, a)) ?k1 (c' (n, a))\n\ngoal (1 subgoal):\n 1. \\<forall>k. Q n a k (c' (n, a))", "by auto"], ["proof (state)\nthis:\n  \\<forall>k. Q n a k (c' (n, a))\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "from na"], ["proof (chain)\npicking this:\n  (n, a) \\<in> set n_as", "have \"c' (n,a) \\<in> set (map c' n_as)\""], ["proof (prove)\nusing this:\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. c' (n, a) \\<in> set (map c' n_as)", "by auto"], ["proof (state)\nthis:\n  c' (n, a) \\<in> set (map c' n_as)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "from Max_ge[OF _ this]"], ["proof (chain)\npicking this:\n  finite (set (map c' n_as)) \\<Longrightarrow>\n  c' (n, a) \\<le> Max (set (map c' n_as))", "have \"c' (n,a) \\<le> c\""], ["proof (prove)\nusing this:\n  finite (set (map c' n_as)) \\<Longrightarrow>\n  c' (n, a) \\<le> Max (set (map c' n_as))\n\ngoal (1 subgoal):\n 1. c' (n, a) \\<le> c", "unfolding c_def"], ["proof (prove)\nusing this:\n  finite (set (map c' n_as)) \\<Longrightarrow>\n  c' (n, a) \\<le> Max (set (map c' n_as))\n\ngoal (1 subgoal):\n 1. c' (n, a) \\<le> max 0 (Max (set (map c' n_as)))", "by auto"], ["proof (state)\nthis:\n  c' (n, a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "from Q_mono[OF this Q]"], ["proof (chain)\npicking this:\n  \\<forall>k. Q n a k c", "have \"\\<And> k. Q n a k c\""], ["proof (prove)\nusing this:\n  \\<forall>k. Q n a k c\n\ngoal (1 subgoal):\n 1. \\<And>k. Q n a k c", "by blast"], ["proof (state)\nthis:\n  Q n a ?k1 c\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "}"], ["proof (state)\nthis:\n  (?n4, ?aa4) \\<in> set n_as \\<Longrightarrow> Q ?n4 ?aa4 ?k1 c\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "hence Q: \"\\<And>k n a. (n,a) \\<in> set n_as \\<Longrightarrow> Q n a k c\""], ["proof (prove)\nusing this:\n  (?n4, ?aa4) \\<in> set n_as \\<Longrightarrow> Q ?n4 ?aa4 ?k1 c\n\ngoal (1 subgoal):\n 1. \\<And>k n a. (n, a) \\<in> set n_as \\<Longrightarrow> Q n a k c", "by auto"], ["proof (state)\nthis:\n  (?n1, ?a1) \\<in> set n_as \\<Longrightarrow> Q ?n1 ?a1 ?k1 c\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "have c0: \"c \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max 0 (Max (set (map c' n_as)))", "by simp"], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "{"], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "fix k n a e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "assume na:\"(n,a) \\<in> set n_as\""], ["proof (state)\nthis:\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "let ?jbk = \"jordan_block n a ^\\<^sub>m k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "assume \"e \\<in> elements_mat ?jbk\""], ["proof (state)\nthis:\n  e \\<in> elements_mat (jordan_block n a ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "from elements_matD[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>i j.\n     i < dim_row (jordan_block n a ^\\<^sub>m k) \\<and>\n     j < dim_col (jordan_block n a ^\\<^sub>m k) \\<and>\n     e = (jordan_block n a ^\\<^sub>m k) $$ (i, j)", "obtain i j\n      where \"i < n\" \"j < n\" and [simp]: \"e = ?jbk $$ (i,j)\""], ["proof (prove)\nusing this:\n  \\<exists>i j.\n     i < dim_row (jordan_block n a ^\\<^sub>m k) \\<and>\n     j < dim_col (jordan_block n a ^\\<^sub>m k) \\<and>\n     e = (jordan_block n a ^\\<^sub>m k) $$ (i, j)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < n; j < n;\n         e = (jordan_block n a ^\\<^sub>m k) $$ (i, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only:pow_mat_dim_square[OF jordan_block_carrier],auto)"], ["proof (state)\nthis:\n  i < n\n  j < n\n  e = (jordan_block n a ^\\<^sub>m k) $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "hence \"norm e \\<le> ?g k c\""], ["proof (prove)\nusing this:\n  i < n\n  j < n\n  e = (jordan_block n a ^\\<^sub>m k) $$ (i, j)\n\ngoal (1 subgoal):\n 1. norm e \\<le> c + real k ^ (N - 1)", "using Q[OF na]"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n  e = (jordan_block n a ^\\<^sub>m k) $$ (i, j)\n  Q n a ?k1 c\n\ngoal (1 subgoal):\n 1. norm e \\<le> c + real k ^ (N - 1)", "unfolding Q_def f_def"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n  e = (jordan_block n a ^\\<^sub>m k) $$ (i, j)\n  \\<forall>i j.\n     i < n \\<longrightarrow>\n     j < n \\<longrightarrow>\n     norm ((jordan_block n a ^\\<^sub>m ?k1) $$ (i, j))\n     \\<le> c + real ?k1 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. norm e \\<le> c + real k ^ (N - 1)", "by simp"], ["proof (state)\nthis:\n  norm e \\<le> c + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?n3, ?aa3) \\<in> set n_as;\n   ?e3 \\<in> elements_mat (jordan_block ?n3 ?aa3 ^\\<^sub>m ?k3)\\<rbrakk>\n  \\<Longrightarrow> norm ?e3 \\<le> c + real ?k3 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "hence norm_jordan:\n    \"\\<And>k. \\<forall>(n,a) \\<in> set n_as. \\<forall>e \\<in> elements_mat (jordan_block n a ^\\<^sub>m k).\n     norm e \\<le> ?g k c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?n3, ?aa3) \\<in> set n_as;\n   ?e3 \\<in> elements_mat (jordan_block ?n3 ?aa3 ^\\<^sub>m ?k3)\\<rbrakk>\n  \\<Longrightarrow> norm ?e3 \\<le> c + real ?k3 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<forall>(n, a)\\<in>set n_as.\n          \\<forall>e\\<in>elements_mat (jordan_block n a ^\\<^sub>m k).\n             norm e \\<le> c + real k ^ (N - 1)", "by auto"], ["proof (state)\nthis:\n  \\<forall>(n, a)\\<in>set n_as.\n     \\<forall>e\\<in>elements_mat (jordan_block n a ^\\<^sub>m ?k1).\n        norm e \\<le> c + real ?k1 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "{"], ["proof (state)\nthis:\n  \\<forall>(n, a)\\<in>set n_as.\n     \\<forall>e\\<in>elements_mat (jordan_block n a ^\\<^sub>m ?k1).\n        norm e \\<le> c + real ?k1 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "let ?jmk = \"jordan_matrix n_as ^\\<^sub>m k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "have \"dim_row ?jmk = d\" \"dim_col ?jmk = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (jordan_matrix n_as ^\\<^sub>m k) = d &&&\n    dim_col (jordan_matrix n_as ^\\<^sub>m k) = d", "using jm"], ["proof (prove)\nusing this:\n  jordan_matrix n_as \\<in> carrier_mat d d\n\ngoal (1 subgoal):\n 1. dim_row (jordan_matrix n_as ^\\<^sub>m k) = d &&&\n    dim_col (jordan_matrix n_as ^\\<^sub>m k) = d", "by (simp only:pow_mat_dim_square[OF jm])+"], ["proof (state)\nthis:\n  dim_row (jordan_matrix n_as ^\\<^sub>m k) = d\n  dim_col (jordan_matrix n_as ^\\<^sub>m k) = d\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "let ?As = \"(map (\\<lambda>(n,a). jordan_block n a ^\\<^sub>m k) n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "have \"\\<And>e. e \\<in> elements_mat ?jmk \\<Longrightarrow> norm e \\<le> ?g k c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "assume e:\"e \\<in> elements_mat ?jmk\""], ["proof (state)\nthis:\n  e \\<in> elements_mat (jordan_matrix n_as ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "obtain i j where ij: \"i < d\" \"j < d\" and \"e = ?jmk $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < d; j < d;\n         e = (jordan_matrix n_as ^\\<^sub>m k) $$ (i, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elements_matD[OF e]"], ["proof (prove)\nusing this:\n  \\<exists>i j.\n     i < dim_row (jordan_matrix n_as ^\\<^sub>m k) \\<and>\n     j < dim_col (jordan_matrix n_as ^\\<^sub>m k) \\<and>\n     e = (jordan_matrix n_as ^\\<^sub>m k) $$ (i, j)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < d; j < d;\n         e = (jordan_matrix n_as ^\\<^sub>m k) $$ (i, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only:pow_mat_dim_square[OF jm],auto)"], ["proof (state)\nthis:\n  i < d\n  j < d\n  e = (jordan_matrix n_as ^\\<^sub>m k) $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "have \"?jmk = diag_block_mat ?As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix n_as ^\\<^sub>m k =\n    diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k) n_as)", "using jordan_matrix_pow[of n_as k]"], ["proof (prove)\nusing this:\n  jordan_matrix n_as ^\\<^sub>m k =\n  diag_block_mat (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k) n_as)\n\ngoal (1 subgoal):\n 1. jordan_matrix n_as ^\\<^sub>m k =\n    diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k) n_as)", "by auto"], ["proof (state)\nthis:\n  jordan_matrix n_as ^\\<^sub>m k =\n  diag_block_mat (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k) n_as)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "hence \"elements_mat ?jmk \\<subseteq> {0} \\<union> \\<Union> (set (map elements_mat ?As))\""], ["proof (prove)\nusing this:\n  jordan_matrix n_as ^\\<^sub>m k =\n  diag_block_mat (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k) n_as)\n\ngoal (1 subgoal):\n 1. elements_mat (jordan_matrix n_as ^\\<^sub>m k)\n    \\<subseteq> {0::'a} \\<union>\n                \\<Union>\n                 (set (map elements_mat\n                        (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                          n_as)))", "using elements_diag_block_mat[of ?As]"], ["proof (prove)\nusing this:\n  jordan_matrix n_as ^\\<^sub>m k =\n  diag_block_mat (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k) n_as)\n  elements_mat\n   (diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k) n_as))\n  \\<subseteq> {0::'a} \\<union>\n              \\<Union>\n               (set (map elements_mat\n                      (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                        n_as)))\n\ngoal (1 subgoal):\n 1. elements_mat (jordan_matrix n_as ^\\<^sub>m k)\n    \\<subseteq> {0::'a} \\<union>\n                \\<Union>\n                 (set (map elements_mat\n                        (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                          n_as)))", "by auto"], ["proof (state)\nthis:\n  elements_mat (jordan_matrix n_as ^\\<^sub>m k)\n  \\<subseteq> {0::'a} \\<union>\n              \\<Union>\n               (set (map elements_mat\n                      (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                        n_as)))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "hence e_mem: \"e \\<in> {0} \\<union> \\<Union> (set (map elements_mat ?As))\""], ["proof (prove)\nusing this:\n  elements_mat (jordan_matrix n_as ^\\<^sub>m k)\n  \\<subseteq> {0::'a} \\<union>\n              \\<Union>\n               (set (map elements_mat\n                      (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                        n_as)))\n\ngoal (1 subgoal):\n 1. e \\<in> {0::'a} \\<union>\n            \\<Union>\n             (set (map elements_mat\n                    (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                      n_as)))", "using e"], ["proof (prove)\nusing this:\n  elements_mat (jordan_matrix n_as ^\\<^sub>m k)\n  \\<subseteq> {0::'a} \\<union>\n              \\<Union>\n               (set (map elements_mat\n                      (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                        n_as)))\n  e \\<in> elements_mat (jordan_matrix n_as ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. e \\<in> {0::'a} \\<union>\n            \\<Union>\n             (set (map elements_mat\n                    (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                      n_as)))", "by blast"], ["proof (state)\nthis:\n  e \\<in> {0::'a} \\<union>\n          \\<Union>\n           (set (map elements_mat\n                  (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                    n_as)))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> elements_mat\n                (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n       norm e \\<le> c + real k ^ (N - 1)", "show \"norm e \\<le> ?g k c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm e \\<le> c + real k ^ (N - 1)", "proof (cases \"e = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)\n 2. e \\<noteq> (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)", "case False"], ["proof (state)\nthis:\n  e \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. e = (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)\n 2. e \\<noteq> (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)", "then"], ["proof (chain)\npicking this:\n  e \\<noteq> (0::'a)", "have \"e \\<in> \\<Union> (set (map elements_mat ?As))\""], ["proof (prove)\nusing this:\n  e \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. e \\<in> \\<Union>\n             (set (map elements_mat\n                    (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                      n_as)))", "using e_mem"], ["proof (prove)\nusing this:\n  e \\<noteq> (0::'a)\n  e \\<in> {0::'a} \\<union>\n          \\<Union>\n           (set (map elements_mat\n                  (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                    n_as)))\n\ngoal (1 subgoal):\n 1. e \\<in> \\<Union>\n             (set (map elements_mat\n                    (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                      n_as)))", "by auto"], ["proof (state)\nthis:\n  e \\<in> \\<Union>\n           (set (map elements_mat\n                  (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                    n_as)))\n\ngoal (2 subgoals):\n 1. e = (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)\n 2. e \\<noteq> (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)", "then"], ["proof (chain)\npicking this:\n  e \\<in> \\<Union>\n           (set (map elements_mat\n                  (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                    n_as)))", "obtain n a\n            where \"e \\<in> elements_mat (jordan_block n a ^\\<^sub>m k)\"\n            and na: \"(n,a) \\<in> set n_as\""], ["proof (prove)\nusing this:\n  e \\<in> \\<Union>\n           (set (map elements_mat\n                  (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m k)\n                    n_as)))\n\ngoal (1 subgoal):\n 1. (\\<And>n a.\n        \\<lbrakk>e \\<in> elements_mat (jordan_block n a ^\\<^sub>m k);\n         (n, a) \\<in> set n_as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  e \\<in> elements_mat (jordan_block n a ^\\<^sub>m k)\n  (n, a) \\<in> set n_as\n\ngoal (2 subgoals):\n 1. e = (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)\n 2. e \\<noteq> (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> elements_mat (jordan_block n a ^\\<^sub>m k)\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. norm e \\<le> c + real k ^ (N - 1)", "using norm_jordan na"], ["proof (prove)\nusing this:\n  e \\<in> elements_mat (jordan_block n a ^\\<^sub>m k)\n  (n, a) \\<in> set n_as\n  \\<forall>(n, a)\\<in>set n_as.\n     \\<forall>e\\<in>elements_mat (jordan_block n a ^\\<^sub>m ?k1).\n        norm e \\<le> c + real ?k1 ^ (N - 1)\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. norm e \\<le> c + real k ^ (N - 1)", "by force"], ["proof (state)\nthis:\n  norm e \\<le> c + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. e = (0::'a) \\<Longrightarrow> norm e \\<le> c + real k ^ (N - 1)", "qed (insert c0, auto)"], ["proof (state)\nthis:\n  norm e \\<le> c + real k ^ (N - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?e1 \\<in> elements_mat (jordan_matrix n_as ^\\<^sub>m k) \\<Longrightarrow>\n  norm ?e1 \\<le> c + real k ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "}"], ["proof (state)\nthis:\n  ?e1\n  \\<in> elements_mat (jordan_matrix n_as ^\\<^sub>m ?k4) \\<Longrightarrow>\n  norm ?e1 \\<le> c + real ?k4 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?e1\n  \\<in> elements_mat (jordan_matrix n_as ^\\<^sub>m ?k4) \\<Longrightarrow>\n  norm ?e1 \\<le> c + real ?k4 ^ (N - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n             norm e \\<le> c1 + real k ^ (N - 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>c1.\n     \\<forall>k.\n        \\<forall>e\\<in>elements_mat (jordan_matrix n_as ^\\<^sub>m k).\n           norm e \\<le> c1 + real k ^ (N - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_bound_bridge:\n  \"\\<forall>e \\<in> elements_mat A. norm e \\<le> b \\<Longrightarrow> norm_bound A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>elements_mat A. norm e \\<le> b \\<Longrightarrow>\n    local.norm_bound A b", "unfolding norm_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>elements_mat A. norm e \\<le> b \\<Longrightarrow>\n    \\<forall>i j.\n       i < dim_row A \\<longrightarrow>\n       j < dim_col A \\<longrightarrow> norm (A $$ (i, j)) \\<le> b", "by force"], ["", "lemma norm_bound_mult: assumes A1: \"A1 \\<in> carrier_mat nr n\"\n  and A2: \"A2 \\<in> carrier_mat n nc\"\n  and b1: \"norm_bound A1 b1\"\n  and b2: \"norm_bound A2 b2\"\n  shows \"norm_bound (A1 * A2) (b1 * b2 * of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.norm_bound (A1 * A2) (b1 * b2 * real n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "let ?A = \"A1 * A2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "let ?n = \"of_nat n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "assume i: \"i < dim_row ?A\" and j: \"j < dim_col ?A\""], ["proof (state)\nthis:\n  i < dim_row (A1 * A2)\n  j < dim_col (A1 * A2)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "define v1 where \"v1 = (\\<lambda> k. row A1 i $ k)\""], ["proof (state)\nthis:\n  v1 = ($) (row A1 i)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "define v2 where \"v2 = (\\<lambda> k. col A2 j $ k)\""], ["proof (state)\nthis:\n  v2 = ($) (col A2 j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "from assms(1-2)"], ["proof (chain)\npicking this:\n  A1 \\<in> carrier_mat nr n\n  A2 \\<in> carrier_mat n nc", "have dim: \"dim_row A1 = nr\" \"dim_col A2 = nc\" \"dim_col A1 = n\" \"dim_row A2 = n\""], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat nr n\n  A2 \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. (dim_row A1 = nr &&& dim_col A2 = nc) &&&\n    dim_col A1 = n &&& dim_row A2 = n", "by auto"], ["proof (state)\nthis:\n  dim_row A1 = nr\n  dim_col A2 = nc\n  dim_col A1 = n\n  dim_row A2 = n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "{"], ["proof (state)\nthis:\n  dim_row A1 = nr\n  dim_col A2 = nc\n  dim_col A1 = n\n  dim_row A2 = n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "assume k: \"k < n\""], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "have n: \"norm (v1 k) \\<le> b1\" \"norm (v2 k) \\<le> b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v1 k) \\<le> b1 &&& norm (v2 k) \\<le> b2", "using i j k dim v1_def v2_def\n      b1[unfolded norm_bound_def, rule_format, of i k] \n      b2[unfolded norm_bound_def, rule_format, of k j]"], ["proof (prove)\nusing this:\n  i < dim_row (A1 * A2)\n  j < dim_col (A1 * A2)\n  k < n\n  dim_row A1 = nr\n  dim_col A2 = nc\n  dim_col A1 = n\n  dim_row A2 = n\n  v1 = ($) (row A1 i)\n  v2 = ($) (col A2 j)\n  \\<lbrakk>i < dim_row A1; k < dim_col A1\\<rbrakk>\n  \\<Longrightarrow> norm (A1 $$ (i, k)) \\<le> b1\n  \\<lbrakk>k < dim_row A2; j < dim_col A2\\<rbrakk>\n  \\<Longrightarrow> norm (A2 $$ (k, j)) \\<le> b2\n\ngoal (1 subgoal):\n 1. norm (v1 k) \\<le> b1 &&& norm (v2 k) \\<le> b2", "by auto"], ["proof (state)\nthis:\n  norm (v1 k) \\<le> b1\n  norm (v2 k) \\<le> b2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "have \"norm (v1 k * v2 k) \\<le> norm (v1 k) * norm (v2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v1 k * v2 k) \\<le> norm (v1 k) * norm (v2 k)", "by (rule norm_mult_ineq)"], ["proof (state)\nthis:\n  norm (v1 k * v2 k) \\<le> norm (v1 k) * norm (v2 k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "also"], ["proof (state)\nthis:\n  norm (v1 k * v2 k) \\<le> norm (v1 k) * norm (v2 k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "have \"\\<dots> \\<le> b1 * b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v1 k) * norm (v2 k) \\<le> b1 * b2", "by (rule mult_mono'[OF n], auto)"], ["proof (state)\nthis:\n  norm (v1 k) * norm (v2 k) \\<le> b1 * b2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "finally"], ["proof (chain)\npicking this:\n  norm (v1 k * v2 k) \\<le> b1 * b2", "have \"norm (v1 k * v2 k) \\<le> b1 * b2\""], ["proof (prove)\nusing this:\n  norm (v1 k * v2 k) \\<le> b1 * b2\n\ngoal (1 subgoal):\n 1. norm (v1 k * v2 k) \\<le> b1 * b2", "."], ["proof (state)\nthis:\n  norm (v1 k * v2 k) \\<le> b1 * b2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "}"], ["proof (state)\nthis:\n  ?k3 < n \\<Longrightarrow> norm (v1 ?k3 * v2 ?k3) \\<le> b1 * b2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "note bound = this"], ["proof (state)\nthis:\n  ?k3 < n \\<Longrightarrow> norm (v1 ?k3 * v2 ?k3) \\<le> b1 * b2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "have \"?A $$ (i,j) = row A1 i \\<bullet> col A2 j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A1 * A2) $$ (i, j) = row A1 i \\<bullet> col A2 j", "using dim i j"], ["proof (prove)\nusing this:\n  dim_row A1 = nr\n  dim_col A2 = nc\n  dim_col A1 = n\n  dim_row A2 = n\n  i < dim_row (A1 * A2)\n  j < dim_col (A1 * A2)\n\ngoal (1 subgoal):\n 1. (A1 * A2) $$ (i, j) = row A1 i \\<bullet> col A2 j", "by simp"], ["proof (state)\nthis:\n  (A1 * A2) $$ (i, j) = row A1 i \\<bullet> col A2 j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "also"], ["proof (state)\nthis:\n  (A1 * A2) $$ (i, j) = row A1 i \\<bullet> col A2 j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "have \"\\<dots> = (\\<Sum> k = 0 ..< n. v1 k * v2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A1 i \\<bullet> col A2 j = (\\<Sum>k = 0..<n. v1 k * v2 k)", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec (col A2 j). row A1 i $ ia * col A2 j $ ia) =\n    (\\<Sum>k = 0..<n. v1 k * v2 k)", "using dim i j v1_def v2_def"], ["proof (prove)\nusing this:\n  dim_row A1 = nr\n  dim_col A2 = nc\n  dim_col A1 = n\n  dim_row A2 = n\n  i < dim_row (A1 * A2)\n  j < dim_col (A1 * A2)\n  v1 = ($) (row A1 i)\n  v2 = ($) (col A2 j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec (col A2 j). row A1 i $ ia * col A2 j $ ia) =\n    (\\<Sum>k = 0..<n. v1 k * v2 k)", "by simp"], ["proof (state)\nthis:\n  row A1 i \\<bullet> col A2 j = (\\<Sum>k = 0..<n. v1 k * v2 k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "also"], ["proof (state)\nthis:\n  row A1 i \\<bullet> col A2 j = (\\<Sum>k = 0..<n. v1 k * v2 k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "have \"norm (\\<dots>) \\<le> (\\<Sum> k = 0 ..< n. b1 * b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (\\<Sum>k = 0..<n. v1 k * v2 k) \\<le> (\\<Sum>k = 0..<n. b1 * b2)", "by (rule sum_norm_le, insert bound, simp)"], ["proof (state)\nthis:\n  norm (\\<Sum>k = 0..<n. v1 k * v2 k) \\<le> (\\<Sum>k = 0..<n. b1 * b2)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "also"], ["proof (state)\nthis:\n  norm (\\<Sum>k = 0..<n. v1 k * v2 k) \\<le> (\\<Sum>k = 0..<n. b1 * b2)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "have \"\\<dots> = b1 * b2 * ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. b1 * b2) = b1 * b2 * real n", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n. b1 * b2) = b1 * b2 * real n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (A1 * A2); j < dim_col (A1 * A2)\\<rbrakk>\n       \\<Longrightarrow> norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "finally"], ["proof (chain)\npicking this:\n  norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "show \"norm (?A $$ (i,j)) \\<le> b1 * b2 * ?n\""], ["proof (prove)\nusing this:\n  norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n\n\ngoal (1 subgoal):\n 1. norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n", "."], ["proof (state)\nthis:\n  norm ((A1 * A2) $$ (i, j)) \\<le> b1 * b2 * real n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_bound_max: \"norm_bound A (Max {norm (A $$ (i,j)) | i j. i < dim_row A \\<and> j < dim_col A})\" \n  (is \"norm_bound A (Max ?norms)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.norm_bound A\n     (Max {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> norm (A $$ (i, j))\n                         \\<le> Max {norm (A $$ (i, j)) |i j.\n                                    i < dim_row A \\<and> j < dim_col A}", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> norm (A $$ (i, j))\n                         \\<le> Max {norm (A $$ (i, j)) |i j.\n                                    i < dim_row A \\<and> j < dim_col A}", "have fin: \"finite ?norms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}", "by (simp add: finite_image_set2)"], ["proof (state)\nthis:\n  finite {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> norm (A $$ (i, j))\n                         \\<le> Max {norm (A $$ (i, j)) |i j.\n                                    i < dim_row A \\<and> j < dim_col A}", "assume \"i < dim_row A\" and \"j < dim_col A\""], ["proof (state)\nthis:\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> norm (A $$ (i, j))\n                         \\<le> Max {norm (A $$ (i, j)) |i j.\n                                    i < dim_row A \\<and> j < dim_col A}", "hence \"norm (A $$ (i,j)) \\<in> ?norms\""], ["proof (prove)\nusing this:\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. norm (A $$ (i, j))\n    \\<in> {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}", "by auto"], ["proof (state)\nthis:\n  norm (A $$ (i, j))\n  \\<in> {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> norm (A $$ (i, j))\n                         \\<le> Max {norm (A $$ (i, j)) |i j.\n                                    i < dim_row A \\<and> j < dim_col A}", "from Max_ge[OF fin this]"], ["proof (chain)\npicking this:\n  norm (A $$ (i, j))\n  \\<le> Max {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}", "show \"norm (A $$ (i,j)) \\<le> Max ?norms\""], ["proof (prove)\nusing this:\n  norm (A $$ (i, j))\n  \\<le> Max {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}\n\ngoal (1 subgoal):\n 1. norm (A $$ (i, j))\n    \\<le> Max {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}", "."], ["proof (state)\nthis:\n  norm (A $$ (i, j))\n  \\<le> Max {norm (A $$ (i, j)) |i j. i < dim_row A \\<and> j < dim_col A}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_matrix_poly_bound: fixes n_as :: \"(nat \\<times> 'a)list\"\n  assumes n_as: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> n > 0 \\<Longrightarrow> norm a \\<le> 1\"\n  and N: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> n \\<le> N\"\n  shows \"\\<exists> c1. \\<forall> k. norm_bound (jordan_matrix n_as ^\\<^sub>m k) (c1 + of_nat k ^ (N - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          local.norm_bound (jordan_matrix n_as ^\\<^sub>m k)\n           (c1 + real k ^ (N - 1))", "using jordan_matrix_poly_bound2 norm_bound_bridge N n_as"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n a.\n              \\<lbrakk>(n, a) \\<in> set ?n_as; 0 < n\\<rbrakk>\n              \\<Longrightarrow> norm a \\<le> 1;\n   \\<And>n a.\n      \\<lbrakk>(n, a) \\<in> set ?n_as; norm a = 1\\<rbrakk>\n      \\<Longrightarrow> n \\<le> ?N\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c1.\n                       \\<forall>k.\n                          \\<forall>e\\<in>elements_mat\n    (jordan_matrix ?n_as ^\\<^sub>m k).\n                             norm e \\<le> c1 + real k ^ (?N - 1)\n  \\<forall>e\\<in>elements_mat ?A. norm e \\<le> ?b \\<Longrightarrow>\n  local.norm_bound ?A ?b\n  \\<lbrakk>(?n, ?a) \\<in> set n_as; norm ?a = 1\\<rbrakk>\n  \\<Longrightarrow> ?n \\<le> N\n  \\<lbrakk>(?n, ?a) \\<in> set n_as; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> norm ?a \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          local.norm_bound (jordan_matrix n_as ^\\<^sub>m k)\n           (c1 + real k ^ (N - 1))", "by metis"], ["", "lemma jordan_nf_matrix_poly_bound: fixes n_as :: \"(nat \\<times> 'a)list\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n  and n_as: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> n > 0 \\<Longrightarrow> norm a \\<le> 1\"\n  and N: \"\\<And> n a. (n,a) \\<in> set n_as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> n \\<le> N\"\n  and jnf: \"jordan_nf A n_as\"\n  shows \"\\<exists> c1 c2. \\<forall> k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * of_nat k ^ (N - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?cp2 = \"\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?J = \"jordan_matrix n_as\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "from jnf[unfolded jordan_nf_def]"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)", "have sim: \"similar_mat A ?J\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. similar_mat A (jordan_matrix n_as)", "by auto"], ["proof (state)\nthis:\n  similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "then"], ["proof (chain)\npicking this:\n  similar_mat A (jordan_matrix n_as)", "obtain P Q where sim_wit: \"similar_mat_wit A ?J P Q\""], ["proof (prove)\nusing this:\n  similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        similar_mat_wit A (jordan_matrix n_as) P Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding similar_mat_def"], ["proof (prove)\nusing this:\n  \\<exists>P. Ex (similar_mat_wit A (jordan_matrix n_as) P)\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        similar_mat_wit A (jordan_matrix n_as) P Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A (jordan_matrix n_as) P Q\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "from similar_mat_wit_pow_id[OF this]"], ["proof (chain)\npicking this:\n  A ^\\<^sub>m ?k = P * jordan_matrix n_as ^\\<^sub>m ?k * Q", "have pow: \"\\<And> k. A ^\\<^sub>m k = P * ?J ^\\<^sub>m k * Q\""], ["proof (prove)\nusing this:\n  A ^\\<^sub>m ?k = P * jordan_matrix n_as ^\\<^sub>m ?k * Q\n\ngoal (1 subgoal):\n 1. \\<And>k. A ^\\<^sub>m k = P * jordan_matrix n_as ^\\<^sub>m k * Q", "."], ["proof (state)\nthis:\n  A ^\\<^sub>m ?k = P * jordan_matrix n_as ^\\<^sub>m ?k * Q\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "from sim_wit[unfolded similar_mat_wit_def Let_def] A"], ["proof (chain)\npicking this:\n  {A, jordan_matrix n_as, P, Q}\n  \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n  P * Q = 1\\<^sub>m (dim_row A) \\<and>\n  Q * P = 1\\<^sub>m (dim_row A) \\<and> A = P * jordan_matrix n_as * Q\n  A \\<in> carrier_mat n n", "have J: \"?J \\<in> carrier_mat n n\" and P: \"P \\<in> carrier_mat n n\" and Q: \"Q \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  {A, jordan_matrix n_as, P, Q}\n  \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n  P * Q = 1\\<^sub>m (dim_row A) \\<and>\n  Q * P = 1\\<^sub>m (dim_row A) \\<and> A = P * jordan_matrix n_as * Q\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. jordan_matrix n_as \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& Q \\<in> carrier_mat n n", "unfolding carrier_mat_def"], ["proof (prove)\nusing this:\n  {A, jordan_matrix n_as, P, Q}\n  \\<subseteq> {m. dim_row m = dim_row A \\<and> dim_col m = dim_row A} \\<and>\n  P * Q = 1\\<^sub>m (dim_row A) \\<and>\n  Q * P = 1\\<^sub>m (dim_row A) \\<and> A = P * jordan_matrix n_as * Q\n  A \\<in> {m. dim_row m = n \\<and> dim_col m = n}\n\ngoal (1 subgoal):\n 1. jordan_matrix n_as \\<in> {m. dim_row m = n \\<and> dim_col m = n} &&&\n    P \\<in> {m. dim_row m = n \\<and> dim_col m = n} &&&\n    Q \\<in> {m. dim_row m = n \\<and> dim_col m = n}", "by force+"], ["proof (state)\nthis:\n  jordan_matrix n_as \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "have \"\\<exists>c1. \\<forall> k. norm_bound (?J ^\\<^sub>m k) (c1 + of_nat k ^ (N - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1.\n       \\<forall>k.\n          local.norm_bound (jordan_matrix n_as ^\\<^sub>m k)\n           (c1 + real k ^ (N - 1))", "by (rule jordan_matrix_poly_bound[OF n_as N])"], ["proof (state)\nthis:\n  \\<exists>c1.\n     \\<forall>k.\n        local.norm_bound (jordan_matrix n_as ^\\<^sub>m k)\n         (c1 + real k ^ (N - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "then"], ["proof (chain)\npicking this:\n  \\<exists>c1.\n     \\<forall>k.\n        local.norm_bound (jordan_matrix n_as ^\\<^sub>m k)\n         (c1 + real k ^ (N - 1))", "obtain c1 where \n    bound_pow: \"\\<And> k. norm_bound ((?J ^\\<^sub>m k)) (c1 + of_nat k ^ (N - 1))\""], ["proof (prove)\nusing this:\n  \\<exists>c1.\n     \\<forall>k.\n        local.norm_bound (jordan_matrix n_as ^\\<^sub>m k)\n         (c1 + real k ^ (N - 1))\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        (\\<And>k.\n            local.norm_bound (jordan_matrix n_as ^\\<^sub>m k)\n             (c1 + real k ^ (N - 1))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  local.norm_bound (jordan_matrix n_as ^\\<^sub>m ?k)\n   (c1 + real ?k ^ (N - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "obtain bP where bP: \"norm_bound P bP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bP.\n        local.norm_bound P bP \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using norm_bound_max[of P]"], ["proof (prove)\nusing this:\n  local.norm_bound P\n   (Max {norm (P $$ (i, j)) |i j. i < dim_row P \\<and> j < dim_col P})\n\ngoal (1 subgoal):\n 1. (\\<And>bP.\n        local.norm_bound P bP \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  local.norm_bound P bP\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "obtain bQ where bQ: \"norm_bound Q bQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bQ.\n        local.norm_bound Q bQ \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using norm_bound_max[of Q]"], ["proof (prove)\nusing this:\n  local.norm_bound Q\n   (Max {norm (Q $$ (i, j)) |i j. i < dim_row Q \\<and> j < dim_col Q})\n\ngoal (1 subgoal):\n 1. (\\<And>bQ.\n        local.norm_bound Q bQ \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  local.norm_bound Q bQ\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?n = \"of_nat n :: real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?c2 = \"bP * ?n * bQ * ?n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?c1 = \"?c2 * c1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "have Jk: \"?J ^\\<^sub>m k \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix n_as ^\\<^sub>m k \\<in> carrier_mat n n", "using J"], ["proof (prove)\nusing this:\n  jordan_matrix n_as \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. jordan_matrix n_as ^\\<^sub>m k \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  jordan_matrix n_as ^\\<^sub>m k \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "from norm_bound_mult[OF mult_carrier_mat[OF P Jk] Q \n      norm_bound_mult[OF P Jk bP bound_pow] bQ, folded pow]"], ["proof (chain)\npicking this:\n  local.norm_bound (A ^\\<^sub>m k)\n   (bP * (c1 + real k ^ (N - 1)) * real n * bQ * real n)", "have \"norm_bound (A ^\\<^sub>m k) (?c1 + ?c2 * of_nat k ^ (N - 1))\"  (is \"norm_bound _ ?exp\")"], ["proof (prove)\nusing this:\n  local.norm_bound (A ^\\<^sub>m k)\n   (bP * (c1 + real k ^ (N - 1)) * real n * bQ * real n)\n\ngoal (1 subgoal):\n 1. local.norm_bound (A ^\\<^sub>m k)\n     (bP * real n * bQ * real n * c1 +\n      bP * real n * bQ * real n * real k ^ (N - 1))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  local.norm_bound (A ^\\<^sub>m k)\n   (bP * real n * bQ * real n * c1 +\n    bP * real n * bQ * real n * real k ^ (N - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "}"], ["proof (state)\nthis:\n  local.norm_bound (A ^\\<^sub>m ?k2)\n   (bP * real n * bQ * real n * c1 +\n    bP * real n * bQ * real n * real ?k2 ^ (N - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "note main = this"], ["proof (state)\nthis:\n  local.norm_bound (A ^\\<^sub>m ?k2)\n   (bP * real n * bQ * real n * c1 +\n    bP * real n * bQ * real n * real ?k2 ^ (N - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k.\n          local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "by (intro exI allI, rule main)"], ["proof (state)\nthis:\n  \\<exists>c1 c2.\n     \\<forall>k.\n        local.norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context \n  fixes f_ty :: \"'a :: field itself\"\nbegin"], ["", "lemma char_matrix_jordan_block: \"char_matrix (jordan_block n a) b = (jordan_block n (a - b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_matrix (jordan_block n a) b = jordan_block n (a - b)", "unfolding char_matrix_def jordan_block_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i = j then a else if Suc i = j then 1::'b else (0::'b)) +\n    - b \\<cdot>\\<^sub>m\n    1\\<^sub>m\n     (dim_row\n       (mat n n\n         (\\<lambda>(i, j).\n             if i = j then a else if Suc i = j then 1::'b else (0::'b)))) =\n    mat n n\n     (\\<lambda>(i, j).\n         if i = j then a - b else if Suc i = j then 1::'b else (0::'b))", "by auto"], ["", "lemma diag_jordan_block_pow: \"diag_mat (jordan_block n (a :: 'a) ^\\<^sub>m k) = replicate n (a ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat (jordan_block n a ^\\<^sub>m k) = replicate n (a ^ k)", "unfolding diag_mat_def jordan_block_pow"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            mat n n\n             (\\<lambda>(i, j).\n                 if i \\<le> j\n                 then of_nat (k choose (j - i)) * a ^ (k + i - j)\n                 else (0::'a)) $$\n            (i, i))\n     [0..<\n      dim_row\n       (mat n n\n         (\\<lambda>(i, j).\n             if i \\<le> j then of_nat (k choose (j - i)) * a ^ (k + i - j)\n             else (0::'a)))] =\n    replicate n (a ^ k)", "by (intro nth_equalityI, auto)"], ["", "lemma jordan_block_zero_pow: \"(jordan_block n (0 :: 'a)) ^\\<^sub>m k = \n  (mat n n (\\<lambda> (i,j). if j \\<ge> i \\<and> j - i = k then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "assume  *: \"j - i \\<noteq> k\""], ["proof (state)\nthis:\n  j - i \\<noteq> k\n\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "have \"of_nat (k choose (j - i)) * 0 ^ (k + i - j) = (0 :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "proof (cases \"k + i - j > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)\n 2. \\<not> 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "case True"], ["proof (state)\nthis:\n  0 < k + i - j\n\ngoal (2 subgoals):\n 1. 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)\n 2. \\<not> 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < k + i - j\n\ngoal (1 subgoal):\n 1. of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "by (cases \"k + i - j\", auto)"], ["proof (state)\nthis:\n  of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < k + i - j\n\ngoal (1 subgoal):\n 1. \\<not> 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "with *"], ["proof (chain)\npicking this:\n  j - i \\<noteq> k\n  \\<not> 0 < k + i - j", "have \"j - i > k\""], ["proof (prove)\nusing this:\n  j - i \\<noteq> k\n  \\<not> 0 < k + i - j\n\ngoal (1 subgoal):\n 1. k < j - i", "by auto"], ["proof (state)\nthis:\n  k < j - i\n\ngoal (1 subgoal):\n 1. \\<not> 0 < k + i - j \\<Longrightarrow>\n    of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < j - i\n\ngoal (1 subgoal):\n 1. of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)", "by (simp add: binomial_eq_0)"], ["proof (state)\nthis:\n  of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j) = (0::'a)\n\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "}"], ["proof (state)\nthis:\n  ?j2 - ?i2 \\<noteq> k \\<Longrightarrow>\n  of_nat (k choose (?j2 - ?i2)) * (0::'a) ^ (k + ?i2 - ?j2) = (0::'a)\n\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?j2 - ?i2 \\<noteq> k \\<Longrightarrow>\n  of_nat (k choose (?j2 - ?i2)) * (0::'a) ^ (k + ?i2 - ?j2) = (0::'a)\n\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "unfolding jordan_block_pow"], ["proof (prove)\nusing this:\n  ?j2 - ?i2 \\<noteq> k \\<Longrightarrow>\n  of_nat (k choose (?j2 - ?i2)) * (0::'a) ^ (k + ?i2 - ?j2) = (0::'a)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (k choose (j - i)) * (0::'a) ^ (k + i - j)\n         else (0::'a)) =\n    mat n n\n     (\\<lambda>(i, j).\n         if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  jordan_block n (0::'a) ^\\<^sub>m k =\n  mat n n\n   (\\<lambda>(i, j). if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma jordan_matrix_concat_diag_block_mat: \"jordan_matrix (concat jbs) = diag_block_mat (map jordan_matrix jbs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix (concat jbs) = diag_block_mat (map jordan_matrix jbs)", "unfolding jordan_matrix_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) (concat jbs)) =\n    diag_block_mat\n     (map (\\<lambda>n_as.\n              diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as))\n       jbs)", "by (induct jbs, auto simp: diag_block_mat_append Let_def)"], ["", "lemma jordan_nf_diag_block_mat: assumes Ms: \"\\<And> A jbs. (A,jbs) \\<in> set Ms \\<Longrightarrow> jordan_nf A jbs\"\n  shows \"jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "let ?Ms = \"map (\\<lambda> (A, jbs). (A, jordan_matrix jbs)) Ms\""], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "have id: \"map fst ?Ms = map fst Ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms) =\n    map fst Ms", "by auto"], ["proof (state)\nthis:\n  map fst (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms) = map fst Ms\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "have id2: \"map snd ?Ms = map jordan_matrix (map snd Ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms) =\n    map jordan_matrix (map snd Ms)", "by auto"], ["proof (state)\nthis:\n  map snd (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms) =\n  map jordan_matrix (map snd Ms)\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "{"], ["proof (state)\nthis:\n  map snd (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms) =\n  map jordan_matrix (map snd Ms)\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "assume \"(A,B) \\<in> set ?Ms\""], ["proof (state)\nthis:\n  (A, B) \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms)\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "then"], ["proof (chain)\npicking this:\n  (A, B) \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms)", "obtain jbs where mem: \"(A,jbs) \\<in> set Ms\" and B: \"B = jordan_matrix jbs\""], ["proof (prove)\nusing this:\n  (A, B) \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs)) Ms)\n\ngoal (1 subgoal):\n 1. (\\<And>jbs.\n        \\<lbrakk>(A, jbs) \\<in> set Ms; B = jordan_matrix jbs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (A, jbs) \\<in> set Ms\n  B = jordan_matrix jbs\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "from Ms[OF mem]"], ["proof (chain)\npicking this:\n  jordan_nf A jbs", "have \"similar_mat A B\""], ["proof (prove)\nusing this:\n  jordan_nf A jbs\n\ngoal (1 subgoal):\n 1. similar_mat A B", "unfolding B jordan_nf_def"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set jbs \\<and> similar_mat A (jordan_matrix jbs)\n\ngoal (1 subgoal):\n 1. similar_mat A (jordan_matrix jbs)", "by auto"], ["proof (state)\nthis:\n  similar_mat A B\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "}"], ["proof (state)\nthis:\n  (?A2, ?B2)\n  \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs))\n              Ms) \\<Longrightarrow>\n  similar_mat ?A2 ?B2\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "from similar_diag_mat_block_mat[of ?Ms, OF this, unfolded id id2] Ms"], ["proof (chain)\npicking this:\n  (\\<And>A B.\n      (A, B)\n      \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs))\n                  Ms) \\<Longrightarrow>\n      (A, B)\n      \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs))\n                  Ms)) \\<Longrightarrow>\n  similar_mat (diag_block_mat (map fst Ms))\n   (diag_block_mat (map jordan_matrix (map snd Ms)))\n  (?A, ?jbs) \\<in> set Ms \\<Longrightarrow> jordan_nf ?A ?jbs", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      (A, B)\n      \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs))\n                  Ms) \\<Longrightarrow>\n      (A, B)\n      \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs))\n                  Ms)) \\<Longrightarrow>\n  similar_mat (diag_block_mat (map fst Ms))\n   (diag_block_mat (map jordan_matrix (map snd Ms)))\n  (?A, ?jbs) \\<in> set Ms \\<Longrightarrow> jordan_nf ?A ?jbs\n\ngoal (1 subgoal):\n 1. jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))", "unfolding jordan_nf_def jordan_matrix_concat_diag_block_mat"], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      (A, B)\n      \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs))\n                  Ms) \\<Longrightarrow>\n      (A, B)\n      \\<in> set (map (\\<lambda>(A, jbs). (A, jordan_matrix jbs))\n                  Ms)) \\<Longrightarrow>\n  similar_mat (diag_block_mat (map fst Ms))\n   (diag_block_mat (map jordan_matrix (map snd Ms)))\n  (?A, ?jbs) \\<in> set Ms \\<Longrightarrow>\n  0 \\<notin> fst ` set ?jbs \\<and> similar_mat ?A (jordan_matrix ?jbs)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` set (concat (map snd Ms)) \\<and>\n    similar_mat (diag_block_mat (map fst Ms))\n     (diag_block_mat (map jordan_matrix (map snd Ms)))", "by force"], ["proof (state)\nthis:\n  jordan_nf (diag_block_mat (map fst Ms)) (concat (map snd Ms))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_nf_char_poly: assumes \"jordan_nf A n_as\"\n  shows \"char_poly A = (\\<Prod> (n,a) \\<leftarrow> n_as. [:- a, 1:] ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "unfolding jordan_matrix_char_poly[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = char_poly (jordan_matrix n_as)", "by (rule char_poly_similar, insert assms[unfolded jordan_nf_def], auto)"], ["", "lemma jordan_nf_block_size_order_bound: assumes jnf: \"jordan_nf A n_as\"\n  and mem: \"(n,a) \\<in> set n_as\"\n  shows \"n \\<le> order a (char_poly A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "from jnf[unfolded jordan_nf_def]"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)", "have \"similar_mat A (jordan_matrix n_as)\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. similar_mat A (jordan_matrix n_as)", "by auto"], ["proof (state)\nthis:\n  similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "from similar_matD[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n P Q.\n     {A, jordan_matrix n_as, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and> A = P * jordan_matrix n_as * Q", "obtain m where \"A \\<in> carrier_mat m m\""], ["proof (prove)\nusing this:\n  \\<exists>n P Q.\n     {A, jordan_matrix n_as, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and> A = P * jordan_matrix n_as * Q\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        A \\<in> carrier_mat m m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "from degree_monic_char_poly[OF this]"], ["proof (chain)\npicking this:\n  degree (char_poly A) = m \\<and> coeff (char_poly A) m = (1::'a)", "have A: \"char_poly A \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (char_poly A) = m \\<and> coeff (char_poly A) m = (1::'a)\n\ngoal (1 subgoal):\n 1. char_poly A \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  char_poly A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "from mem"], ["proof (chain)\npicking this:\n  (n, a) \\<in> set n_as", "obtain as bs where nas: \"n_as = as @ (n,a) # bs\""], ["proof (prove)\nusing this:\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        n_as = as @ (n, a) # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  n_as = as @ (n, a) # bs\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "from jordan_nf_char_poly[OF jnf]"], ["proof (chain)\npicking this:\n  char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "have cA: \"char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\""], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "."], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "also"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "have \"\\<dots> = [: -a, 1:] ^ n * (\\<Prod>(n, a)\\<leftarrow> as @ bs. [:- a, 1:] ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n    [:- a, 1::'a:] ^ n *\n    (\\<Prod>(n, a)\\<leftarrow>as @ bs. [:- a, 1::'a:] ^ n)", "unfolding nas"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(n, a)\\<leftarrow>as @ (n, a) # bs. [:- a, 1::'a:] ^ n) =\n    [:- a, 1::'a:] ^ n *\n    (\\<Prod>(n, a)\\<leftarrow>as @ bs. [:- a, 1::'a:] ^ n)", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n  [:- a, 1::'a:] ^ n *\n  (\\<Prod>(n, a)\\<leftarrow>as @ bs. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n  [:- a, 1::'a:] ^ n *\n  (\\<Prod>(n, a)\\<leftarrow>as @ bs. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "have \"[: -a,1 :] ^ n dvd \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] ^ n dvd\n    [:- a, 1::'a:] ^ n *\n    (\\<Prod>(n, a)\\<leftarrow>as @ bs. [:- a, 1::'a:] ^ n)", "unfolding dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       [:- a, 1::'a:] ^ n *\n       (\\<Prod>(n, a)\\<leftarrow>as @ bs. [:- a, 1::'a:] ^ n) =\n       [:- a, 1::'a:] ^ n * k", "by blast"], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ n dvd\n  [:- a, 1::'a:] ^ n *\n  (\\<Prod>(n, a)\\<leftarrow>as @ bs. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "finally"], ["proof (chain)\npicking this:\n  [:- a, 1::'a:] ^ n dvd char_poly A", "have \"[: -a,1 :] ^ n dvd char_poly A\""], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] ^ n dvd char_poly A\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] ^ n dvd char_poly A", "by auto"], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ n dvd char_poly A\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "from order_max[OF this A]"], ["proof (chain)\npicking this:\n  n \\<le> order a (char_poly A)", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> order a (char_poly A)\n\ngoal (1 subgoal):\n 1. n \\<le> order a (char_poly A)", "."], ["proof (state)\nthis:\n  n \\<le> order a (char_poly A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma similar_mat_jordan_block_smult: fixes A :: \"'a :: field mat\" \n  assumes \"similar_mat A (jordan_block n a)\" \n   and k: \"k \\<noteq> 0\" \n  shows \"similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "let ?J = \"jordan_block n a\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "let ?Jk = \"jordan_block n (k * a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "let ?kJ = \"k \\<cdot>\\<^sub>m jordan_block n a\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "from k"], ["proof (chain)\npicking this:\n  k \\<noteq> (0::'a)", "have inv: \"k ^ i \\<noteq> 0\" for i"], ["proof (prove)\nusing this:\n  k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. k ^ i \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  k ^ ?i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "let ?A = \"mat_diag n (\\<lambda> i. k^i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "let ?B = \"mat_diag n (\\<lambda> i. inverse (k^i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "have \"similar_mat_wit ?Jk ?kJ ?A ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (jordan_block n (k * a))\n     (k \\<cdot>\\<^sub>m jordan_block n a) (mat_diag n ((^) k))\n     (mat_diag n (\\<lambda>i. inverse (k ^ i)))", "proof (rule similar_mat_witI)"], ["proof (state)\ngoal (7 subgoals):\n 1. mat_diag n ((^) k) * mat_diag n (\\<lambda>i. inverse (k ^ i)) =\n    1\\<^sub>m ?n\n 2. mat_diag n (\\<lambda>i. inverse (k ^ i)) * mat_diag n ((^) k) =\n    1\\<^sub>m ?n\n 3. jordan_block n (k * a) =\n    mat_diag n ((^) k) * (k \\<cdot>\\<^sub>m jordan_block n a) *\n    mat_diag n (\\<lambda>i. inverse (k ^ i))\n 4. jordan_block n (k * a) \\<in> carrier_mat ?n ?n\n 5. k \\<cdot>\\<^sub>m jordan_block n a \\<in> carrier_mat ?n ?n\n 6. mat_diag n ((^) k) \\<in> carrier_mat ?n ?n\n 7. mat_diag n (\\<lambda>i. inverse (k ^ i)) \\<in> carrier_mat ?n ?n", "show \"jordan_block n (k * a) = ?A * ?kJ * ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n (k * a) =\n    mat_diag n ((^) k) * (k \\<cdot>\\<^sub>m jordan_block n a) *\n    mat_diag n (\\<lambda>i. inverse (k ^ i))", "by (subst mat_diag_mult_left[of _ _ n], force, subst mat_diag_mult_right[of _ n],\n       insert k inv, auto simp: jordan_block_def field_simps intro!: eq_matI)"], ["proof (state)\nthis:\n  jordan_block n (k * a) =\n  mat_diag n ((^) k) * (k \\<cdot>\\<^sub>m jordan_block n a) *\n  mat_diag n (\\<lambda>i. inverse (k ^ i))\n\ngoal (6 subgoals):\n 1. mat_diag n ((^) k) * mat_diag n (\\<lambda>i. inverse (k ^ i)) =\n    1\\<^sub>m ?n\n 2. mat_diag n (\\<lambda>i. inverse (k ^ i)) * mat_diag n ((^) k) =\n    1\\<^sub>m ?n\n 3. jordan_block n (k * a) \\<in> carrier_mat ?n ?n\n 4. k \\<cdot>\\<^sub>m jordan_block n a \\<in> carrier_mat ?n ?n\n 5. mat_diag n ((^) k) \\<in> carrier_mat ?n ?n\n 6. mat_diag n (\\<lambda>i. inverse (k ^ i)) \\<in> carrier_mat ?n ?n", "qed (auto simp: inv field_simps k)"], ["proof (state)\nthis:\n  similar_mat_wit (jordan_block n (k * a))\n   (k \\<cdot>\\<^sub>m jordan_block n a) (mat_diag n ((^) k))\n   (mat_diag n (\\<lambda>i. inverse (k ^ i)))\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "hence kJ: \"similar_mat ?Jk ?kJ\""], ["proof (prove)\nusing this:\n  similar_mat_wit (jordan_block n (k * a))\n   (k \\<cdot>\\<^sub>m jordan_block n a) (mat_diag n ((^) k))\n   (mat_diag n (\\<lambda>i. inverse (k ^ i)))\n\ngoal (1 subgoal):\n 1. similar_mat (jordan_block n (k * a))\n     (k \\<cdot>\\<^sub>m jordan_block n a)", "unfolding similar_mat_def"], ["proof (prove)\nusing this:\n  similar_mat_wit (jordan_block n (k * a))\n   (k \\<cdot>\\<^sub>m jordan_block n a) (mat_diag n ((^) k))\n   (mat_diag n (\\<lambda>i. inverse (k ^ i)))\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       Ex (similar_mat_wit (jordan_block n (k * a))\n            (k \\<cdot>\\<^sub>m jordan_block n a) P)", "by auto"], ["proof (state)\nthis:\n  similar_mat (jordan_block n (k * a)) (k \\<cdot>\\<^sub>m jordan_block n a)\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "have \"similar_mat A ?J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat A (jordan_block n a)", "by fact"], ["proof (state)\nthis:\n  similar_mat A (jordan_block n a)\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "hence \"similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m ?J)\""], ["proof (prove)\nusing this:\n  similar_mat A (jordan_block n a)\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_block n a)", "by (rule similar_mat_smult)"], ["proof (state)\nthis:\n  similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_block n a)\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "with kJ"], ["proof (chain)\npicking this:\n  similar_mat (jordan_block n (k * a)) (k \\<cdot>\\<^sub>m jordan_block n a)\n  similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_block n a)", "show ?thesis"], ["proof (prove)\nusing this:\n  similar_mat (jordan_block n (k * a)) (k \\<cdot>\\<^sub>m jordan_block n a)\n  similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_block n a)\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "using similar_mat_sym similar_mat_trans"], ["proof (prove)\nusing this:\n  similar_mat (jordan_block n (k * a)) (k \\<cdot>\\<^sub>m jordan_block n a)\n  similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_block n a)\n  similar_mat ?A ?B \\<Longrightarrow> similar_mat ?B ?A\n  \\<lbrakk>similar_mat ?A ?B; similar_mat ?B ?C\\<rbrakk>\n  \\<Longrightarrow> similar_mat ?A ?C\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))", "by blast"], ["proof (state)\nthis:\n  similar_mat (k \\<cdot>\\<^sub>m A) (jordan_block n (k * a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_matrix_Cons:  \"jordan_matrix (Cons (n,a) n_as) = four_block_mat \n  (jordan_block n a)                 (0\\<^sub>m n (sum_list (map fst n_as))) \n  (0\\<^sub>m (sum_list (map fst n_as)) n)   (jordan_matrix n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix ((n, a) # n_as) =\n    four_block_mat (jordan_block n a)\n     (0\\<^sub>m n (sum_list (map fst n_as)))\n     (0\\<^sub>m (sum_list (map fst n_as)) n) (jordan_matrix n_as)", "unfolding jordan_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>(x, y). jordan_block x y) ((n, a) # n_as)) =\n    four_block_mat (jordan_block n a)\n     (0\\<^sub>m n (sum_list (map fst n_as)))\n     (0\\<^sub>m (sum_list (map fst n_as)) n)\n     (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as))", "by (simp, simp add: jordan_matrix_def[symmetric])"], ["", "lemma similar_mat_jordan_matrix_smult:  fixes n_as :: \"(nat \\<times> 'a :: field) list\"\n  assumes k: \"k \\<noteq> 0\" \n  shows \"similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as) (jordan_matrix (map (\\<lambda> (n,a). (n, k * a)) n_as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n     (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))", "proof (induct n_as)"], ["proof (state)\ngoal (2 subgoals):\n 1. similar_mat (k \\<cdot>\\<^sub>m jordan_matrix [])\n     (jordan_matrix\n       (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a)) []))\n 2. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. similar_mat (k \\<cdot>\\<^sub>m jordan_matrix [])\n     (jordan_matrix\n       (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a)) []))\n 2. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m jordan_matrix [])\n     (jordan_matrix\n       (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a)) []))", "by (auto simp: jordan_matrix_def intro!: similar_mat_refl)"], ["proof (state)\nthis:\n  similar_mat (k \\<cdot>\\<^sub>m jordan_matrix [])\n   (jordan_matrix\n     (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a)) []))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "case (Cons na n_as)"], ["proof (state)\nthis:\n  similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n   (jordan_matrix\n     (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a)) n_as))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "obtain n a where na: \"na = (n,a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n a. na = (n, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  na = (n, a)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "let ?l = \"map (\\<lambda> (n,a). (n, k * a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "let ?n = \"sum_list (map fst n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "have \"k \\<cdot>\\<^sub>m jordan_matrix (Cons na n_as) = k \\<cdot>\\<^sub>m four_block_mat \n     (jordan_block n a) (0\\<^sub>m n ?n)\n     (0\\<^sub>m ?n n) (jordan_matrix n_as)\" (is \"?M = _ \\<cdot>\\<^sub>m four_block_mat ?A ?B ?C ?D\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot>\\<^sub>m jordan_matrix (na # n_as) =\n    k \\<cdot>\\<^sub>m\n    four_block_mat (jordan_block n a)\n     (0\\<^sub>m n (sum_list (map fst n_as)))\n     (0\\<^sub>m (sum_list (map fst n_as)) n) (jordan_matrix n_as)", "by (simp add: na jordan_matrix_Cons)"], ["proof (state)\nthis:\n  k \\<cdot>\\<^sub>m jordan_matrix (na # n_as) =\n  k \\<cdot>\\<^sub>m\n  four_block_mat (jordan_block n a) (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n) (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "also"], ["proof (state)\nthis:\n  k \\<cdot>\\<^sub>m jordan_matrix (na # n_as) =\n  k \\<cdot>\\<^sub>m\n  four_block_mat (jordan_block n a) (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n) (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "have \"\\<dots> = four_block_mat (k \\<cdot>\\<^sub>m ?A) ?B ?C (k \\<cdot>\\<^sub>m ?D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot>\\<^sub>m\n    four_block_mat (jordan_block n a)\n     (0\\<^sub>m n (sum_list (map fst n_as)))\n     (0\\<^sub>m (sum_list (map fst n_as)) n) (jordan_matrix n_as) =\n    four_block_mat (k \\<cdot>\\<^sub>m jordan_block n a)\n     (0\\<^sub>m n (sum_list (map fst n_as)))\n     (0\\<^sub>m (sum_list (map fst n_as)) n)\n     (k \\<cdot>\\<^sub>m jordan_matrix n_as)", "by (subst smult_four_block_mat, auto)"], ["proof (state)\nthis:\n  k \\<cdot>\\<^sub>m\n  four_block_mat (jordan_block n a) (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n) (jordan_matrix n_as) =\n  four_block_mat (k \\<cdot>\\<^sub>m jordan_block n a)\n   (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n)\n   (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "finally"], ["proof (chain)\npicking this:\n  k \\<cdot>\\<^sub>m jordan_matrix (na # n_as) =\n  four_block_mat (k \\<cdot>\\<^sub>m jordan_block n a)\n   (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n)\n   (k \\<cdot>\\<^sub>m jordan_matrix n_as)", "have jm: \"?M = four_block_mat (k \\<cdot>\\<^sub>m ?A) ?B ?C (k \\<cdot>\\<^sub>m ?D)\""], ["proof (prove)\nusing this:\n  k \\<cdot>\\<^sub>m jordan_matrix (na # n_as) =\n  four_block_mat (k \\<cdot>\\<^sub>m jordan_block n a)\n   (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n)\n   (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. k \\<cdot>\\<^sub>m jordan_matrix (na # n_as) =\n    four_block_mat (k \\<cdot>\\<^sub>m jordan_block n a)\n     (0\\<^sub>m n (sum_list (map fst n_as)))\n     (0\\<^sub>m (sum_list (map fst n_as)) n)\n     (k \\<cdot>\\<^sub>m jordan_matrix n_as)", "."], ["proof (state)\nthis:\n  k \\<cdot>\\<^sub>m jordan_matrix (na # n_as) =\n  four_block_mat (k \\<cdot>\\<^sub>m jordan_block n a)\n   (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n)\n   (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "have [simp]: \"fst (case x of (n :: nat, a) \\<Rightarrow> (n, k * a)) = fst x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case x of (n, a) \\<Rightarrow> (n, k * a)) = fst x", "by (cases x, auto)"], ["proof (state)\nthis:\n  fst (case ?x1 of (n, a) \\<Rightarrow> (n, k * a)) = fst ?x1\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "have jmk: \"jordan_matrix (?l (Cons na n_as)) = four_block_mat\n     (jordan_block n (k * a)) ?B\n     ?C (jordan_matrix (?l n_as))\" (is \"?kM = four_block_mat ?kA _ _ ?kD\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) (na # n_as)) =\n    four_block_mat (jordan_block n (k * a))\n     (0\\<^sub>m n (sum_list (map fst n_as)))\n     (0\\<^sub>m (sum_list (map fst n_as)) n)\n     (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))", "by (simp add: na jordan_matrix_Cons o_def)"], ["proof (state)\nthis:\n  jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) (na # n_as)) =\n  four_block_mat (jordan_block n (k * a))\n   (0\\<^sub>m n (sum_list (map fst n_as)))\n   (0\\<^sub>m (sum_list (map fst n_as)) n)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            n_as)) \\<Longrightarrow>\n       similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (a # n_as))\n        (jordan_matrix\n          (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n            (a # n_as)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (na # n_as))\n     (jordan_matrix\n       (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n         (na # n_as)))", "unfolding jmk jm"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat\n     (four_block_mat (k \\<cdot>\\<^sub>m jordan_block n a)\n       (0\\<^sub>m n (sum_list (map fst n_as)))\n       (0\\<^sub>m (sum_list (map fst n_as)) n)\n       (k \\<cdot>\\<^sub>m jordan_matrix n_as))\n     (four_block_mat (jordan_block n (k * a))\n       (0\\<^sub>m n (sum_list (map fst n_as)))\n       (0\\<^sub>m (sum_list (map fst n_as)) n)\n       (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as)))", "by (rule similar_mat_four_block_0_0[OF similar_mat_jordan_block_smult[OF _ k] Cons],\n      auto intro!: similar_mat_refl)"], ["proof (state)\nthis:\n  similar_mat (k \\<cdot>\\<^sub>m jordan_matrix (na # n_as))\n   (jordan_matrix\n     (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> (n, k * a))\n       (na # n_as)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_nf_smult: fixes k :: \"'a :: field\" \n  assumes jn: \"jordan_nf A n_as\" \n  and k: \"k \\<noteq> 0\" \n  shows \"jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda> (n,a). (n, k * a)) n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda>(n, a). (n, k * a)) n_as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda>(n, a). (n, k * a)) n_as)", "let ?l = \"map (\\<lambda> (n,a). (n, k * a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda>(n, a). (n, k * a)) n_as)", "from jn[unfolded jordan_nf_def]"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)", "have sim: \"similar_mat A (jordan_matrix n_as)\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. similar_mat A (jordan_matrix n_as)", "by auto"], ["proof (state)\nthis:\n  similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda>(n, a). (n, k * a)) n_as)", "from similar_mat_smult[OF this, of k] similar_mat_jordan_matrix_smult[OF k, of n_as]"], ["proof (chain)\npicking this:\n  similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n  similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))", "have \"similar_mat (k \\<cdot>\\<^sub>m A) (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))\""], ["proof (prove)\nusing this:\n  similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n  similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A)\n     (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))", "using similar_mat_trans"], ["proof (prove)\nusing this:\n  similar_mat (k \\<cdot>\\<^sub>m A) (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n  similar_mat (k \\<cdot>\\<^sub>m jordan_matrix n_as)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))\n  \\<lbrakk>similar_mat ?A ?B; similar_mat ?B ?C\\<rbrakk>\n  \\<Longrightarrow> similar_mat ?A ?C\n\ngoal (1 subgoal):\n 1. similar_mat (k \\<cdot>\\<^sub>m A)\n     (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))", "by blast"], ["proof (state)\nthis:\n  similar_mat (k \\<cdot>\\<^sub>m A)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))\n\ngoal (1 subgoal):\n 1. jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda>(n, a). (n, k * a)) n_as)", "with jn"], ["proof (chain)\npicking this:\n  jordan_nf A n_as\n  similar_mat (k \\<cdot>\\<^sub>m A)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))", "show ?thesis"], ["proof (prove)\nusing this:\n  jordan_nf A n_as\n  similar_mat (k \\<cdot>\\<^sub>m A)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))\n\ngoal (1 subgoal):\n 1. jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda>(n, a). (n, k * a)) n_as)", "unfolding jordan_nf_def"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n  similar_mat (k \\<cdot>\\<^sub>m A)\n   (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` set (map (\\<lambda>(n, a). (n, k * a)) n_as) \\<and>\n    similar_mat (k \\<cdot>\\<^sub>m A)\n     (jordan_matrix (map (\\<lambda>(n, a). (n, k * a)) n_as))", "by force"], ["proof (state)\nthis:\n  jordan_nf (k \\<cdot>\\<^sub>m A) (map (\\<lambda>(n, a). (n, k * a)) n_as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_nf_order: assumes \"jordan_nf A n_as\" \n  shows \"order a (char_poly A)  = sum_list (map fst (filter (\\<lambda> na. snd na = a) n_as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "let ?p = \"\\<lambda> n_as. (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "let ?s = \"\\<lambda> n_as. sum_list (map fst (filter (\\<lambda> na. snd na = a) n_as))\""], ["proof (state)\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "from jordan_nf_char_poly[OF assms]"], ["proof (chain)\npicking this:\n  char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "have \"order a (char_poly A) = order a (?p n_as)\""], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "by simp"], ["proof (state)\nthis:\n  order a (char_poly A) =\n  order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "also"], ["proof (state)\nthis:\n  order a (char_poly A) =\n  order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "have \"\\<dots> = ?s n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "proof (induct n_as)"], ["proof (state)\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "case (Cons nb n_as)"], ["proof (state)\nthis:\n  order a\n   (\\<Prod>a\\<leftarrow>n_as. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "obtain n b where nb: \"nb = (n,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n b. nb = (n, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  nb = (n, b)\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "have \"order a (?p (nb # n_as)) = order a ([: -b, 1:] ^ n * ?p n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a (\\<Prod>(n, a)\\<leftarrow>nb # n_as. [:- a, 1::'a:] ^ n) =\n    order a\n     ([:- b, 1::'a:] ^ n *\n      (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n))", "unfolding nb"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a (\\<Prod>(n, a)\\<leftarrow>(n, b) # n_as. [:- a, 1::'a:] ^ n) =\n    order a\n     ([:- b, 1::'a:] ^ n *\n      (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n))", "by simp"], ["proof (state)\nthis:\n  order a (\\<Prod>(n, a)\\<leftarrow>nb # n_as. [:- a, 1::'a:] ^ n) =\n  order a\n   ([:- b, 1::'a:] ^ n *\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n))\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "also"], ["proof (state)\nthis:\n  order a (\\<Prod>(n, a)\\<leftarrow>nb # n_as. [:- a, 1::'a:] ^ n) =\n  order a\n   ([:- b, 1::'a:] ^ n *\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n))\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "have \"\\<dots> = order a ([: -b, 1:] ^ n) + order a (?p n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a\n     ([:- b, 1::'a:] ^ n *\n      (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)) =\n    order a ([:- b, 1::'a:] ^ n) +\n    order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "by (rule order_mult, auto simp: prod_list_zero_iff)"], ["proof (state)\nthis:\n  order a\n   ([:- b, 1::'a:] ^ n *\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)) =\n  order a ([:- b, 1::'a:] ^ n) +\n  order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "also"], ["proof (state)\nthis:\n  order a\n   ([:- b, 1::'a:] ^ n *\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)) =\n  order a ([:- b, 1::'a:] ^ n) +\n  order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "have \"\\<dots> = (if a = b then n else 0) + ?s n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a ([:- b, 1::'a:] ^ n) +\n    order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n    (if a = b then n else 0) +\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "unfolding Cons order_linear_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if - b = - a then n else 0) +\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as)) =\n    (if a = b then n else 0) +\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "by simp"], ["proof (state)\nthis:\n  order a ([:- b, 1::'a:] ^ n) +\n  order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n  (if a = b then n else 0) +\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "also"], ["proof (state)\nthis:\n  order a ([:- b, 1::'a:] ^ n) +\n  order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n  (if a = b then n else 0) +\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "have \"\\<dots> = ?s (nb # n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = b then n else 0) +\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as)) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) (nb # n_as)))", "unfolding nb"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = b then n else 0) +\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as)) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) ((n, b) # n_as)))", "by auto"], ["proof (state)\nthis:\n  (if a = b then n else 0) +\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as)) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) (nb # n_as)))\n\ngoal (2 subgoals):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))\n 2. \\<And>aa n_as.\n       order a\n        (\\<Prod>a\\<leftarrow>n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list\n        (map fst (filter (\\<lambda>na. snd na = a) n_as)) \\<Longrightarrow>\n       order a\n        (\\<Prod>a\\<leftarrow>aa #\n                             n_as. case a of\n                                   (n, a) \\<Rightarrow>\n                                     [:- a, 1::'a:] ^ n) =\n       sum_list (map fst (filter (\\<lambda>na. snd na = a) (aa # n_as)))", "finally"], ["proof (chain)\npicking this:\n  order a (\\<Prod>(n, a)\\<leftarrow>nb # n_as. [:- a, 1::'a:] ^ n) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) (nb # n_as)))", "show ?case"], ["proof (prove)\nusing this:\n  order a (\\<Prod>(n, a)\\<leftarrow>nb # n_as. [:- a, 1::'a:] ^ n) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) (nb # n_as)))\n\ngoal (1 subgoal):\n 1. order a\n     (\\<Prod>a\\<leftarrow>nb #\n                          n_as. case a of\n                                (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) (nb # n_as)))", "."], ["proof (state)\nthis:\n  order a\n   (\\<Prod>a\\<leftarrow>nb #\n                        n_as. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) (nb # n_as)))\n\ngoal (1 subgoal):\n 1. order a\n     (\\<Prod>a\\<leftarrow>[]. case a of\n                              (n, a) \\<Rightarrow> [:- a, 1::'a:] ^ n) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) []))", "qed simp"], ["proof (state)\nthis:\n  order a (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))\n\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "finally"], ["proof (chain)\npicking this:\n  order a (char_poly A) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "show ?thesis"], ["proof (prove)\nusing this:\n  order a (char_poly A) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))\n\ngoal (1 subgoal):\n 1. order a (char_poly A) =\n    sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))", "."], ["proof (state)\nthis:\n  order a (char_poly A) =\n  sum_list (map fst (filter (\\<lambda>na. snd na = a) n_as))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Application for Complexity\\<close>"], ["", "lemma factored_char_poly_norm_bound: assumes A: \"A \\<in> carrier_mat n n\"\n  and linear_factors: \"char_poly A = (\\<Prod> (a :: 'a :: real_normed_field) \\<leftarrow> as. [:- a, 1:])\"\n  and jnf_exists: \"\\<exists> n_as. jordan_nf A n_as\" \n  and le_1: \"\\<And> a. a \\<in> set as \\<Longrightarrow> norm a \\<le> 1\"\n  and le_N: \"\\<And> a. a \\<in> set as \\<Longrightarrow> norm a = 1 \\<Longrightarrow> length (filter ((=) a) as) \\<le> N\"\n  shows \"\\<exists> c1 c2. \\<forall> k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * of_nat k ^ (N - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "from jnf_exists"], ["proof (chain)\npicking this:\n  \\<exists>n_as. jordan_nf A n_as", "obtain n_as \n    where jnf: \"jordan_nf A n_as\""], ["proof (prove)\nusing this:\n  \\<exists>n_as. jordan_nf A n_as\n\ngoal (1 subgoal):\n 1. (\\<And>n_as.\n        jordan_nf A n_as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  jordan_nf A n_as\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?cp1 = \"(\\<Prod> a \\<leftarrow> as. [:- a, 1:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?cp2 = \"\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "let ?J = \"jordan_matrix n_as\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "from jnf[unfolded jordan_nf_def]"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)", "have sim: \"similar_mat A ?J\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. similar_mat A (jordan_matrix n_as)", "by auto"], ["proof (state)\nthis:\n  similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "from char_poly_similar[OF sim, unfolded linear_factors jordan_matrix_char_poly]"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "have cp: \"?cp1 = ?cp2\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)", "."], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n)\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))", "proof (rule jordan_nf_matrix_poly_bound[OF A _ _ jnf])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "fix n a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "assume na: \"(n,a) \\<in> set n_as\""], ["proof (state)\nthis:\n  (n, a) \\<in> set n_as\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "then"], ["proof (chain)\npicking this:\n  (n, a) \\<in> set n_as", "obtain na1 na2 where n_as: \"n_as = na1 @ (n,a) # na2\""], ["proof (prove)\nusing this:\n  (n, a) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. (\\<And>na1 na2.\n        n_as = na1 @ (n, a) # na2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_decomp"], ["proof (prove)\nusing this:\n  \\<exists>ys zs. n_as = ys @ (n, a) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>na1 na2.\n        n_as = na1 @ (n, a) # na2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n_as = na1 @ (n, a) # na2\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "then"], ["proof (chain)\npicking this:\n  n_as = na1 @ (n, a) # na2", "obtain p where \"?cp2 = [: -a, 1 :]^n * p\""], ["proof (prove)\nusing this:\n  n_as = na1 @ (n, a) # na2\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n        [:- a, 1::'a:] ^ n * p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding n_as"], ["proof (prove)\nusing this:\n  na1 @ (n, a) # na2 = na1 @ (n, a) # na2\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<Prod>(n, a)\\<leftarrow>na1 @ (n, a) # na2. [:- a, 1::'a:] ^ n) =\n        [:- a, 1::'a:] ^ n * p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1::'a:] ^ n) =\n  [:- a, 1::'a:] ^ n * p\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "from cp[unfolded this]"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) = [:- a, 1::'a:] ^ n * p", "have dvd: \"[: -a, 1 :] ^ n dvd ?cp1\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) = [:- a, 1::'a:] ^ n * p\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:])", "by auto"], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ n dvd (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:])\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "let ?as = \"filter ((=) a) as\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "let ?pn = \"\\<lambda> as. \\<Prod>a\\<leftarrow>as. [:- a, 1:]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "let ?p = \"\\<lambda> as. \\<Prod>a\\<leftarrow>as. [: a, 1:]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "have \"?pn as = ?p (map uminus as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>map uminus as. [:a, 1::'a:])", "by (induct as, auto)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>map uminus as. [:a, 1::'a:])\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "from poly_linear_exp_linear_factors[OF dvd[unfolded this]]"], ["proof (chain)\npicking this:\n  n \\<le> length (filter ((=) (- a)) (map uminus as))", "have \"n \\<le> length (filter ((=) (- a)) (map uminus as))\""], ["proof (prove)\nusing this:\n  n \\<le> length (filter ((=) (- a)) (map uminus as))\n\ngoal (1 subgoal):\n 1. n \\<le> length (filter ((=) (- a)) (map uminus as))", "."], ["proof (state)\nthis:\n  n \\<le> length (filter ((=) (- a)) (map uminus as))\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "also"], ["proof (state)\nthis:\n  n \\<le> length (filter ((=) (- a)) (map uminus as))\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "have \"\\<dots> = length (filter ((=) a) as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (- a)) (map uminus as)) = length (filter ((=) a) as)", "by (induct as, auto)"], ["proof (state)\nthis:\n  length (filter ((=) (- a)) (map uminus as)) = length (filter ((=) a) as)\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "finally"], ["proof (chain)\npicking this:\n  n \\<le> length (filter ((=) a) as)", "have filt: \"n \\<le> length (filter ((=) a) as)\""], ["proof (prove)\nusing this:\n  n \\<le> length (filter ((=) a) as)\n\ngoal (1 subgoal):\n 1. n \\<le> length (filter ((=) a) as)", "."], ["proof (state)\nthis:\n  n \\<le> length (filter ((=) a) as)\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "{"], ["proof (state)\nthis:\n  n \\<le> length (filter ((=) a) as)\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "assume \"0 < n\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "with filt"], ["proof (chain)\npicking this:\n  n \\<le> length (filter ((=) a) as)\n  0 < n", "obtain b bs where \"?as = b # bs\""], ["proof (prove)\nusing this:\n  n \\<le> length (filter ((=) a) as)\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<And>b bs.\n        filter ((=) a) as = b # bs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?as, auto)"], ["proof (state)\nthis:\n  filter ((=) a) as = b # bs\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "from arg_cong[OF this, of set]"], ["proof (chain)\npicking this:\n  set (filter ((=) a) as) = set (b # bs)", "have \"a \\<in> set as\""], ["proof (prove)\nusing this:\n  set (filter ((=) a) as) = set (b # bs)\n\ngoal (1 subgoal):\n 1. a \\<in> set as", "by auto"], ["proof (state)\nthis:\n  a \\<in> set as\n\ngoal (2 subgoals):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; 0 < n\\<rbrakk>\n       \\<Longrightarrow> norm a \\<le> 1\n 2. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "from le_1[rule_format, OF this]"], ["proof (chain)\npicking this:\n  norm a \\<le> 1", "show \"norm a \\<le> 1\""], ["proof (prove)\nusing this:\n  norm a \\<le> 1\n\ngoal (1 subgoal):\n 1. norm a \\<le> 1", "."], ["proof (state)\nthis:\n  norm a \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "note \\<open>a \\<in> set as\\<close>"], ["proof (state)\nthis:\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "}"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow> a \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "note mem = this"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow> a \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "{"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow> a \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "assume \"norm a = 1\""], ["proof (state)\nthis:\n  norm a = 1\n\ngoal (1 subgoal):\n 1. \\<And>n a.\n       \\<lbrakk>(n, a) \\<in> set n_as; norm a = 1\\<rbrakk>\n       \\<Longrightarrow> n \\<le> N", "from le_N[OF mem this] filt"], ["proof (chain)\npicking this:\n  0 < n \\<Longrightarrow> length (filter ((=) a) as) \\<le> N\n  n \\<le> length (filter ((=) a) as)", "show \"n \\<le> N\""], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow> length (filter ((=) a) as) \\<le> N\n  n \\<le> length (filter ((=) a) as)\n\ngoal (1 subgoal):\n 1. n \\<le> N", "by (cases n, auto)"], ["proof (state)\nthis:\n  n \\<le> N\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  norm a = 1 \\<Longrightarrow> n \\<le> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>c1 c2.\n     \\<forall>k. norm_bound (A ^\\<^sub>m k) (c1 + c2 * real k ^ (N - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}