{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Determinant.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma(in ring_hom) hom_signof[simp]: \"hom (signof p) = signof p\"", "lemma(in comm_ring_hom) hom_det[simp]: \"det (map_mat hom A) = hom (det A)\"", "lemma det_def': \"A \\<in> carrier_mat n n \\<Longrightarrow> \n  det A = (\\<Sum> p \\<in> {p. p permutes {0 ..< n}}. \n     signof p * (\\<Prod> i = 0 ..< n. A $$ (i, p i)))\"", "lemma det_smult[simp]: \"det (a \\<cdot>\\<^sub>m A) = a ^ dim_col A * det A\"", "lemma det_transpose: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"det (transpose_mat A) = det A\"", "lemma det_col:\n  assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"det A = (\\<Sum> p | p permutes {0 ..< n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))\"\n    (is \"_ = (sum (\\<lambda>p. _ * ?prod p) ?P)\")", "lemma mat_det_left_def: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"det A = (\\<Sum>p\\<in>{p. p permutes {0..<dim_row A}}. signof p * (\\<Prod>i = 0 ..< dim_row A. A $$ (p i, i)))\"", "lemma det_upper_triangular:\n  assumes ut: \"upper_triangular A\"\n  and m: \"A \\<in> carrier_mat n n\"\n  shows \"det A = prod_list (diag_mat A)\"", "lemma det_one[simp]: \"det (1\\<^sub>m n) = 1\"", "lemma det_zero[simp]: assumes \"n > 0\" shows \"det (0\\<^sub>m n n) = 0\"", "lemma det_dim_zero[simp]: \"A \\<in> carrier_mat 0 0 \\<Longrightarrow> det A = 1\"", "lemma det_lower_triangular:\n  assumes ld: \"\\<And>i j. i < j \\<Longrightarrow> j < n \\<Longrightarrow> A $$ (i,j) = 0\"\n  and m: \"A \\<in> carrier_mat n n\"\n  shows \"det A = prod_list (diag_mat A)\"", "lemma det_permute_rows: assumes A: \"A \\<in> carrier_mat n n\"\n  and p: \"p permutes {0 ..< (n :: nat)}\"\n  shows \"det (mat n n (\\<lambda> (i,j). A $$ (p i, j))) = signof p * det A\"", "lemma det_multrow_mat: assumes k: \"k < n\"\n  shows \"det (multrow_mat n k a) = a\"", "lemma swap_rows_mat_eq_permute: \n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> swaprows_mat n k l = mat n n (\\<lambda>(i, j). 1\\<^sub>m n $$ (Fun.swap k l id i, j))\"", "lemma det_swaprows_mat: assumes k: \"k < n\" and l: \"l < n\" and kl: \"k \\<noteq> l\"\n  shows \"det (swaprows_mat n k l) = - 1\"", "lemma det_addrow_mat: \n  assumes l: \"k \\<noteq> l\"\n  shows \"det (addrow_mat n a k l) = 1\"", "lemma det_identical_rows:\n  assumes A: \"A \\<in> carrier_mat n n\"  \n    and ij: \"i \\<noteq> j\"\n    and i: \"i < n\" and j: \"j < n\"\n    and r: \"row A i = row A j\"\n  shows \"det A = 0\"", "lemma det_row_0: assumes k: \"k < n\"\n  and c: \"c \\<in> {0 ..< n} \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) = 0\"", "lemma det_row_add: \n  assumes abc: \"a k \\<in> carrier_vec n\" \"b k \\<in> carrier_vec n\" \"c \\<in> {0..<n} \\<rightarrow> carrier_vec n\"\n    and k: \"k < n\"\n  shows \"det(mat\\<^sub>r n n (\\<lambda> i. if i = k then a i + b i else c i)) =\n    det(mat\\<^sub>r n n (\\<lambda> i. if i = k then a i else c i)) +\n    det(mat\\<^sub>r n n (\\<lambda> i. if i = k then b i else c i))\"\n  (is \"?lhs = ?rhs\")", "lemma det_linear_row_finsum:\n  assumes fS: \"finite S\" and c: \"c \\<in> {0..<n} \\<rightarrow> carrier_vec n\" and k: \"k < n\"\n  and a: \"a k \\<in> S \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda> i. if i = k then finsum_vec TYPE('a :: comm_ring_1) n (a i) S else c i)) =\n    sum (\\<lambda>j. det (mat\\<^sub>r n n (\\<lambda> i. if i = k then a  i j else c i))) S\"", "lemma det_linear_rows_finsum_lemma:\n  assumes fS: \"finite S\"\n    and fT: \"finite T\" and c: \"c \\<in> {0..<n} \\<rightarrow> carrier_vec n\"\n    and T: \"T \\<subseteq> {0 ..< n}\"\n    and a: \"a \\<in> T \\<rightarrow> S \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then finsum_vec TYPE('a :: comm_ring_1) n (a i) S else c i)) =\n    sum (\\<lambda>f. det(mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then a i (f i) else c i)))\n      {f. (\\<forall>i \\<in> T. f i \\<in> S) \\<and> (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}\"", "lemma det_linear_rows_sum:\n  assumes fS: \"finite S\"\n  and a: \"a \\<in> {0..<n} \\<rightarrow> S \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda> i. finsum_vec TYPE('a :: comm_ring_1) n (a i) S)) =\n    sum (\\<lambda>f. det (mat\\<^sub>r n n (\\<lambda> i. a i (f i)))) \n    {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and> (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\"", "lemma det_rows_mul:\n  assumes a: \"a \\<in> {0..<n} \\<rightarrow> carrier_vec n\"\n  shows \"det(mat\\<^sub>r n n (\\<lambda> i. c i \\<cdot>\\<^sub>v a i)) =\n    prod c {0..<n} * det(mat\\<^sub>r n n (\\<lambda> i. a i))\"", "lemma mat_mul_finsum_alt:\n  assumes A: \"A \\<in> carrier_mat nr n\" and B: \"B \\<in> carrier_mat n nc\"\n  shows \"A * B = mat\\<^sub>r nr nc (\\<lambda> i. finsum_vec TYPE('a :: semiring_0) nc (\\<lambda>k. A $$ (i,k) \\<cdot>\\<^sub>v row B k) {0 ..< n})\"", "lemma det_mult:\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"det (A * B) = det A * det (B :: 'a :: comm_ring_1 mat)\"", "lemma unit_imp_det_non_zero: assumes \"A \\<in> Units (ring_mat TYPE('a :: comm_ring_1) n b)\"\n   shows \"det A \\<noteq> 0\"", "lemma det_non_zero_imp_unit: assumes A: \"A \\<in> carrier_mat n n\"\n  and dA: \"det A \\<noteq> (0 :: 'a :: field)\"\n  shows \"A \\<in> Units (ring_mat TYPE('a) n b)\"", "lemma mat_mult_left_right_inverse: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" \n  and B: \"B \\<in> carrier_mat n n\" and AB: \"A * B = 1\\<^sub>m n\"\n  shows \"B * A = 1\\<^sub>m n\"", "lemma det_zero_imp_zero_row: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  and det: \"det A = 0\"\n  shows \"\\<exists> P. P \\<in> Units (ring_mat TYPE('a) n b) \\<and> row (P * A) (n - 1) = 0\\<^sub>v n \\<and> 0 < n\n    \\<and> row_echelon_form (P * A)\"", "lemma det_0_iff_vec_prod_zero_field: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"det A = 0 \\<longleftrightarrow> (\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\" (is \"?l = (\\<exists> v. ?P v)\")", "lemma det_0_iff_vec_prod_zero: assumes A: \"(A :: 'a :: idom mat) \\<in> carrier_mat n n\"\n  shows \"det A = 0 \\<longleftrightarrow> (\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\"", "lemma det_0_negate: assumes  A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"(det (- A) = 0) = (det A = 0)\"", "lemma det_multrow: \n  assumes k: \"k < n\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (multrow k a A) = a * det A\"", "lemma det_multrow_div:\n  assumes k: \"k < n\" and A: \"A \\<in> carrier_mat n n\" and a0: \"a \\<noteq> 0\"\n  shows \"det (multrow k a A :: 'a :: idom_divide mat) div a = det A\"", "lemma det_addrow: \n  assumes l: \"l < n\" and k: \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (addrow a k l A) = det A\"", "lemma det_swaprows: \n  assumes *: \"k < n\" \"l < n\" and k: \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (swaprows k l A) = - det A\"", "lemma det_similar: assumes \"similar_mat A B\" \n  shows \"det A = det B\"", "lemma det_four_block_mat_upper_right_zero_col: assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A20: \"A2 = (0\\<^sub>m n 1)\" and A3: \"A3 \\<in> carrier_mat 1 n\"\n  and A4: \"A4 \\<in> carrier_mat 1 1\"\n  shows \"det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\" (is \"det ?A = _\")", "lemma det_swap_initial_rows: assumes A: \"A \\<in> carrier_mat m m\" \n  and lt: \"k + n \\<le> m\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (if i < n then i + k else if i < k + n then i - n else i, j)))\"", "lemma det_swap_rows: assumes A: \"A \\<in> carrier_mat (k + n) (k + n)\" \n  shows \"det A = (-1)^(k * n) * det (mat (k + n) (k + n) (\\<lambda> (i,j). \n    A $$ ((if i < k then i + n else i - k),j)))\"", "lemma det_swap_final_rows: assumes A: \"A \\<in> carrier_mat m m\"\n  and m: \"m = l + k + n\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (if i < l then i else if i < l + n then i + k else i - n, j)))\" \n    (is \"_ = _ * det ?M\")", "lemma det_swap_final_cols: assumes A: \"A \\<in> carrier_mat m m\"\n  and m: \"m = l + k + n\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (i, if j < l then j else if j < l + n then j + k else j - n)))\"", "lemma det_swap_initial_cols: assumes A: \"A \\<in> carrier_mat m m\" \n  and lt: \"k + n \\<le> m\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (i, if j < n then j + k else if j < k + n then j - n else j)))\"", "lemma det_swap_cols: assumes A: \"A \\<in> carrier_mat (k + n) (k + n)\" \n  shows \"det A = (-1)^(k * n) * det (mat (k + n) (k + n) (\\<lambda> (i,j). \n   A $$ (i,(if j < k then j + n else j - k))))\" (is \"_ = _ * det ?B\")", "lemma det_four_block_mat_upper_right_zero: fixes A1 :: \"'a :: idom mat\" \n  assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A20: \"A2 = (0\\<^sub>m n m)\" and A3: \"A3 \\<in> carrier_mat m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"  \nshows \"det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\"", "lemma det_swapcols: \n  assumes *: \"k < n\" \"l < n\" \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (swapcols k l A) = - det A\"", "lemma swap_row_to_front_det: \"A \\<in> carrier_mat n n \\<Longrightarrow> I < n \\<Longrightarrow> det (swap_row_to_front A I)\n  = (-1)^I * det A\"", "lemma swap_col_to_front_det: \"A \\<in> carrier_mat n n \\<Longrightarrow> I < n \\<Longrightarrow> det (swap_col_to_front A I)\n  = (-1)^I * det A\"", "lemma swap_row_to_front_four_block: assumes A1: \"A1 \\<in> carrier_mat n m1\"\n  and A2: \"A2 \\<in> carrier_mat n m2\" \n  and A3: \"A3 \\<in> carrier_mat 1 m1\" \n  and A4: \"A4 \\<in> carrier_mat 1 m2\"\n  shows \"swap_row_to_front (four_block_mat A1 A2 A3 A4) n = four_block_mat A3 A4 A1 A2\"", "lemma swap_col_to_front_four_block: assumes A1: \"A1 \\<in> carrier_mat n1 m\"\n  and A2: \"A2 \\<in> carrier_mat n1 1\" \n  and A3: \"A3 \\<in> carrier_mat n2 m\" \n  and A4: \"A4 \\<in> carrier_mat n2 1\"\n  shows \"swap_col_to_front (four_block_mat A1 A2 A3 A4) m = four_block_mat A2 A1 A4 A3\"", "lemma det_four_block_mat_lower_right_zero_col: assumes A1: \"A1 \\<in> carrier_mat 1 n\"\n  and A2: \"A2 \\<in> carrier_mat 1 1\"\n  and A3: \"A3 \\<in> carrier_mat n n\"\n  and A40: \"A4 = (0\\<^sub>m n 1)\" \n  shows \"det (four_block_mat A1 A2 A3 A4) = (-1)^n * det A2 * det A3\" (is \"det ?A = _\")", "lemma det_four_block_mat_lower_left_zero_col: assumes A1: \"A1 \\<in> carrier_mat 1 1\"\n  and A2: \"A2 \\<in> carrier_mat 1 n\"\n  and A30: \"A3 = (0\\<^sub>m n 1)\" \n  and A4: \"A4 \\<in> carrier_mat n n\"\n  shows \"det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\" (is \"det ?A = _\")", "lemma det_addcol[simp]: \n  assumes l: \"l < n\" and k: \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (addcol a k l A) = det A\"", "lemma insert_index[simp]:\n  \"i' < i \\<Longrightarrow> insert_index i i' = i'\"\n  \"i' \\<ge> i \\<Longrightarrow> insert_index i i' = Suc i'\"", "lemma delete_insert_index[simp]:\n  \"delete_index i (insert_index i i') = i'\"", "lemma insert_delete_index:\n  assumes i'i: \"i' \\<noteq> i\"\n  shows \"insert_index i (delete_index i i') = i'\"", "lemmas permutation_delete_expand =\n  permutation_delete_def[unfolded delete_dom_def delete_ran_def insert_index_def delete_index_def]", "lemmas permutation_insert_expand =\n  permutation_insert_def[unfolded insert_dom_def insert_ran_def insert_index_def delete_index_def]", "lemma permutation_insert_inserted[simp]:\n  \"permutation_insert (i::nat) j p i = j\"", "lemma permutation_insert_base:\n  assumes p: \"p permutes {0..<n}\"\n  shows \"permutation_insert n n p = p\"", "lemma permutation_insert_row_step:\n  shows \"permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id = permutation_insert i j p\"\n    (is \"?l = ?r\")", "lemma permutation_insert_column_step:\n  assumes p: \"p permutes {0..<n}\" and \"j < n\"\n  shows \"(Fun.swap j (Suc j) id) \\<circ> (permutation_insert i (Suc j) p) = permutation_insert i j p\"\n    (is \"?l = ?r\")", "lemma delete_dom_image:\n  assumes i: \"i \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes iff: \"\\<forall>i' \\<in> ?N. f i' = f i \\<longrightarrow> i' = i\"\n  shows \"delete_dom f i ` {0..<n} = f ` ?N - {f i}\" (is \"?L = ?R\")", "lemma delete_ran_image:\n  assumes j: \"j \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes fimg: \"f ` {0..<n} =  ?N - {j}\"\n  shows \"delete_ran f j ` {0..<n} = {0..<n}\" (is \"?L = ?R\")", "lemma delete_index_inj_on:\n  assumes iS: \"i \\<notin> S\"\n  shows \"inj_on (delete_index i) S\"", "lemma insert_index_inj_on:\n  shows \"inj_on (insert_index i) S\"", "lemma delete_dom_inj_on:\n  assumes i: \"i \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes inj: \"inj_on f ?N\"\n  shows \"inj_on (delete_dom f i) {0..<n}\"", "lemma delete_ran_inj_on:\n  assumes j: \"j \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes img: \"f ` {0..<n} =  ?N - {j}\"\n  shows \"inj_on (delete_ran f j) {0..<n}\"", "lemma permutation_delete_bij_betw:\n  assumes i: \"i \\<in> {0 ..< Suc n}\" (is \"_ \\<in> ?N\")\n  assumes bij: \"bij_betw p ?N ?N\"\n  shows \"bij_betw (permutation_delete p i) {0..<n} {0..<n}\" (is \"bij_betw ?p _ _\")", "lemma permutation_delete_permutes:\n  assumes p: \"p permutes {0 ..< Suc n}\" (is \"_ permutes ?N\")\n      and i: \"i < Suc n\"\n  shows \"permutation_delete p i permutes {0..<n}\" (is \"?p permutes ?N'\")", "lemma permutation_insert_delete:\n  assumes p: \"p permutes {0..<Suc n}\"\n      and i: \"i < Suc n\"\n  shows \"permutation_insert i (p i) (permutation_delete p i) = p\"\n    (is \"?l = _\")", "lemma insert_index_exclude[simp]:\n  \"insert_index i i' \\<noteq> i\"", "lemma insert_index_image:\n  assumes i: \"i < Suc n\"\n  shows \"insert_index i ` {0..<n} = {0..<Suc n} - {i}\" (is \"?L = ?R\")", "lemma insert_ran_image:\n  assumes j: \"j < Suc n\"\n  assumes img: \"f ` {0..<n} = {0..<n}\"\n  shows \"insert_ran f j ` {0..<n} = {0..<Suc n} - {j}\" (is \"?L = ?R\")", "lemma insert_dom_image:\n  assumes i: \"i < Suc n\" and j: \"j < Suc n\"\n    and img: \"f ` {0..<n} = {0..<Suc n} - {j}\" (is \"_ = ?N - _\")\n  shows \"insert_dom f i j ` ?N = ?N\" (is \"?f ` _ = _\")", "lemma insert_ran_inj_on:\n  assumes inj: \"inj_on f {0..<n}\" and j: \"j < Suc n\"\n  shows \"inj_on (insert_ran f j) {0..<n}\" (is \"inj_on ?f _\")", "lemma insert_dom_inj_on:\n  assumes inj: \"inj_on f {0..<n}\"\n      and i: \"i < Suc n\" and j: \"j < Suc n\"\n      and img: \"f ` {0..<n} = {0..<Suc n} - {j}\" (is \"_ = ?N - _\")\n  shows \"inj_on (insert_dom f i j) ?N\"", "lemma permutation_insert_bij_betw:\n  assumes q: \"q permutes {0..<n}\" and i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"bij_betw (permutation_insert i j q) {0..<Suc n} {0..<Suc n}\"\n    (is \"bij_betw ?q ?N _\")", "lemma permutation_insert_permutes:\n  assumes q: \"q permutes {0..<n}\"\n      and i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"permutation_insert i j q permutes {0..<Suc n}\" (is \"?p permutes ?N\")", "lemma permutation_fix:\n  assumes i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"{ p. p permutes {0..<Suc n} \\<and> p i = j } =\n         permutation_insert i j ` { q. q permutes {0..<n} }\"\n    (is \"?L = ?R\")", "lemma permutation_split_ran:\n  assumes j: \"j \\<in> S\"\n  shows \"{ p. p permutes S } = (\\<Union>i \\<in> S. { p. p permutes S \\<and> p i = j })\"\n  (is \"?L = ?R\")", "lemma permutation_disjoint_dom:\n  assumes i: \"i \\<in> S\" and i': \"i' \\<in> S\" and j: \"j \\<in> S\" and ii': \"i \\<noteq> i'\"\n  shows \"{ p. p permutes S \\<and> p i = j } \\<inter> { p. p permutes S \\<and> p i' = j } = {}\"\n    (is \"?L \\<inter> ?R = {}\")", "lemma permutation_disjoint_ran:\n  assumes i: \"i \\<in> S\" and j: \"j \\<in> S\" and j': \"j' \\<in> S\" and jj': \"j \\<noteq> j'\"\n  shows \"{ p. p permutes S \\<and> p i = j } \\<inter> { p. p permutes S \\<and> p i = j' } = {}\"\n    (is \"?L \\<inter> ?R = {}\")", "lemma permutation_insert_inj_on:\n  assumes \"i < Suc n\"\n  assumes \"j < Suc n\"\n  shows \"inj_on (permutation_insert i j) { q. q permutes {0..<n} }\"\n  (is \"inj_on ?f ?S\")", "lemma signof_permutation_insert:\n  assumes p: \"p permutes {0..<n}\" and i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"signof (permutation_insert i j p) = (-1::'a::ring_1)^(i+j) * signof p\"", "lemma foo:\n  assumes i: \"i < Suc n\" and j: \"j < Suc n\"\n  assumes q: \"q permutes {0..<n}\"\n  shows \"{(i', permutation_insert i j q i') | i'. i' \\<in> {0..<Suc n} - {i} } =\n  { (insert_index i i'', insert_index j (q i'')) | i''. i'' < n }\" (is \"?L = ?R\")", "lemma mat_delete_dim[simp]:\n  \"dim_row (mat_delete A i j) = dim_row A - 1\"\n  \"dim_col (mat_delete A i j) = dim_col A - 1\"", "lemma mat_delete_carrier:\n  assumes A: \"A \\<in> carrier_mat m n\"\n  shows \"mat_delete A i j \\<in> carrier_mat (m-1) (n-1)\"", "lemma \"mat_delete_index\":\n  assumes A: \"A \\<in> carrier_mat (Suc n) (Suc n)\"\n      and i: \"i < Suc n\" and j: \"j < Suc n\"\n      and i': \"i' < n\" and j': \"j' < n\"\n  shows \"A $$ (insert_index i i', insert_index j j') = mat_delete A i j $$ (i', j')\"", "lemma laplace_expansion_column:\n  assumes A: \"(A :: 'a :: comm_ring_1 mat) \\<in> carrier_mat n n\"\n      and j: \"j < n\"\n  shows \"det A = (\\<Sum>i<n. A $$ (i,j) * cofactor A i j)\"", "lemma laplace_expansion_row:\n  assumes A: \"(A :: 'a :: comm_ring_1 mat) \\<in> carrier_mat n n\"\n      and i: \"i < n\"\n    shows \"det A = (\\<Sum>j<n. A $$ (i,j) * cofactor A i j)\"", "lemma degree_det_le: assumes \"\\<And> i j. i < n \\<Longrightarrow> j < n \\<Longrightarrow> degree (A $$ (i,j)) \\<le> k\"\n  and A: \"A \\<in> carrier_mat n n\" \nshows \"degree (det A) \\<le> k * n\"", "lemma upper_triangular_imp_det_eq_0_iff:\n  fixes A :: \"'a :: idom mat\"\n  assumes \"A \\<in> carrier_mat n n\" and \"upper_triangular A\"\n  shows \"det A = 0 \\<longleftrightarrow> 0 \\<in> set (diag_mat A)\"", "lemma det_identical_columns:\n  assumes A: \"A \\<in> carrier_mat n n\"  \n    and ij: \"i \\<noteq> j\"\n    and i: \"i < n\" and j: \"j < n\"\n    and r: \"col A i = col A j\"\n  shows \"det A = 0\"", "lemma adj_mat: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"adj_mat A \\<in> carrier_mat n n\"\n  \"A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\" \n  \"adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\"", "lemma cramer_lemma_mat:  \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and x: \"x \\<in> carrier_vec n\" \n  and k: \"k < n\" \nshows \"det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A\""], "translations": [["", "lemma(in ring_hom) hom_signof[simp]: \"hom (signof p) = signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (signof p) = signof p", "unfolding signof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (if sign p = 1 then 1::'a else - (1::'a)) =\n    (if sign p = 1 then 1::'b else - (1::'b))", "by (auto simp: hom_distribs)"], ["", "lemma(in comm_ring_hom) hom_det[simp]: \"det (map_mat hom A) = hom (det A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>h A) = hom (det A)", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row (mat\\<^sub>h A) = dim_col (mat\\<^sub>h A)\n     then \\<Sum>p | p permutes {0..<dim_row (mat\\<^sub>h A)}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row (mat\\<^sub>h A).\n                mat\\<^sub>h A $$ (i, p i))\n     else (0::'b)) =\n    hom (if dim_row A = dim_col A\n         then \\<Sum>p | p permutes {0..<dim_row A}.\n                signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n         else (0::'a))", "by (auto simp: hom_distribs)"], ["", "lemma det_def': \"A \\<in> carrier_mat n n \\<Longrightarrow> \n  det A = (\\<Sum> p \\<in> {p. p permutes {0 ..< n}}. \n     signof p * (\\<Prod> i = 0 ..< n. A $$ (i, p i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    det A =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a)) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))", "by auto"], ["", "lemma det_smult[simp]: \"det (a \\<cdot>\\<^sub>m A) = a ^ dim_col A * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (a \\<cdot>\\<^sub>m A) = a ^ dim_col A * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (a \\<cdot>\\<^sub>m A) = a ^ dim_col A * det A", "have [simp]: \"(\\<Prod>i = 0..<dim_col A. a) = a ^ dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_col A. a) = a ^ dim_col A", "by(subst prod_constant;simp)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<dim_col A. a) = a ^ dim_col A\n\ngoal (1 subgoal):\n 1. det (a \\<cdot>\\<^sub>m A) = a ^ dim_col A * det A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (a \\<cdot>\\<^sub>m A) = a ^ dim_col A * det A", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row (a \\<cdot>\\<^sub>m A) = dim_col (a \\<cdot>\\<^sub>m A)\n     then \\<Sum>p | p permutes {0..<dim_row (a \\<cdot>\\<^sub>m A)}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row (a \\<cdot>\\<^sub>m A).\n                (a \\<cdot>\\<^sub>m A) $$ (i, p i))\n     else (0::'a)) =\n    a ^ dim_col A *\n    (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))", "unfolding index_smult_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row A. (a \\<cdot>\\<^sub>m A) $$ (i, p i))\n     else (0::'a)) =\n    a ^ dim_col A *\n    (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))", "by (auto intro: sum.cong simp: sum_distrib_left prod.distrib)"], ["proof (state)\nthis:\n  det (a \\<cdot>\\<^sub>m A) = a ^ dim_col A * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_transpose: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"det (transpose_mat A) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "let ?di = \"\\<lambda>A i j. A $$ (i,j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "let ?U = \"{0 ..< n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "have fU: \"finite ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<n}", "by simp"], ["proof (state)\nthis:\n  finite {0..<n}\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "let ?inv = \"Hilbert_Choice.inv\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "assume p: \"p \\<in> {p. p permutes ?U}\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "from p"], ["proof (chain)\npicking this:\n  p \\<in> {p. p permutes {0..<n}}", "have pU: \"p permutes ?U\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. p permutes {0..<n}", "by blast"], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "have sth: \"signof (?inv p) = signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (inv p) = signof p", "by (rule signof_inv[OF _ pU], simp)"], ["proof (state)\nthis:\n  signof (inv p) = signof p\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "from permutes_inj[OF pU]"], ["proof (chain)\npicking this:\n  inj p", "have pi: \"inj_on p ?U\""], ["proof (prove)\nusing this:\n  inj p\n\ngoal (1 subgoal):\n 1. inj_on p {0..<n}", "by (blast intro: subset_inj_on)"], ["proof (state)\nthis:\n  inj_on p {0..<n}\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "let ?f = \"\\<lambda>i. transpose_mat A $$ (i, ?inv p i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "note pU_U = permutes_image[OF pU]"], ["proof (state)\nthis:\n  p ` {0..<n} = {0..<n}\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "note [simp] = permutes_less[OF pU]"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> p ?i < n\n  ?i < n \\<Longrightarrow> inv p ?i < n\n  p (inv p ?i) = ?i\n  inv p (p ?i) = ?i\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "have \"prod ?f ?U = prod ?f (p ` ?U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n    (\\<Prod>i\\<in>p ` {0..<n}. A\\<^sup>T $$ (i, inv p i))", "using pU_U"], ["proof (prove)\nusing this:\n  p ` {0..<n} = {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n    (\\<Prod>i\\<in>p ` {0..<n}. A\\<^sup>T $$ (i, inv p i))", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n  (\\<Prod>i\\<in>p ` {0..<n}. A\\<^sup>T $$ (i, inv p i))\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n  (\\<Prod>i\\<in>p ` {0..<n}. A\\<^sup>T $$ (i, inv p i))\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "have \"\\<dots> = prod (?f \\<circ> p) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>p ` {0..<n}. A\\<^sup>T $$ (i, inv p i)) =\n    prod ((\\<lambda>i. A\\<^sup>T $$ (i, inv p i)) \\<circ> p) {0..<n}", "by (rule prod.reindex[OF pi])"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>p ` {0..<n}. A\\<^sup>T $$ (i, inv p i)) =\n  prod ((\\<lambda>i. A\\<^sup>T $$ (i, inv p i)) \\<circ> p) {0..<n}\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>p ` {0..<n}. A\\<^sup>T $$ (i, inv p i)) =\n  prod ((\\<lambda>i. A\\<^sup>T $$ (i, inv p i)) \\<circ> p) {0..<n}\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "have \"\\<dots> = prod (\\<lambda>i. A $$ (i, p i)) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod ((\\<lambda>i. A\\<^sup>T $$ (i, inv p i)) \\<circ> p) {0..<n} =\n    (\\<Prod>i = 0..<n. A $$ (i, p i))", "by (rule prod.cong, insert A, auto)"], ["proof (state)\nthis:\n  prod ((\\<lambda>i. A\\<^sup>T $$ (i, inv p i)) \\<circ> p) {0..<n} =\n  (\\<Prod>i = 0..<n. A $$ (i, p i))\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, p i))", "have \"signof (?inv p) * prod ?f ?U =\n      signof p * prod (\\<lambda>i. A $$ (i, p i)) ?U\""], ["proof (prove)\nusing this:\n  (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, p i))\n\ngoal (1 subgoal):\n 1. signof (inv p) * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n    signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))", "unfolding sth"], ["proof (prove)\nusing this:\n  (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, p i))\n\ngoal (1 subgoal):\n 1. signof p * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n    signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))", "by simp"], ["proof (state)\nthis:\n  signof (inv p) * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv p i)) =\n  signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "}"], ["proof (state)\nthis:\n  ?p4 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  signof (inv ?p4) * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv ?p4 i)) =\n  signof ?p4 * (\\<Prod>i = 0..<n. A $$ (i, ?p4 i))\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "then"], ["proof (chain)\npicking this:\n  ?p4 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  signof (inv ?p4) * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv ?p4 i)) =\n  signof ?p4 * (\\<Prod>i = 0..<n. A $$ (i, ?p4 i))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p4 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  signof (inv ?p4) * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv ?p4 i)) =\n  signof ?p4 * (\\<Prod>i = 0..<n. A $$ (i, ?p4 i))\n\ngoal (1 subgoal):\n 1. det A\\<^sup>T = det A", "unfolding det_def"], ["proof (prove)\nusing this:\n  ?p4 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  signof (inv ?p4) * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv ?p4 i)) =\n  signof ?p4 * (\\<Prod>i = 0..<n. A $$ (i, ?p4 i))\n\ngoal (1 subgoal):\n 1. (if dim_row A\\<^sup>T = dim_col A\\<^sup>T\n     then \\<Sum>p | p permutes {0..<dim_row A\\<^sup>T}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row A\\<^sup>T. A\\<^sup>T $$ (i, p i))\n     else (0::'a)) =\n    (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))", "using A"], ["proof (prove)\nusing this:\n  ?p4 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  signof (inv ?p4) * (\\<Prod>i = 0..<n. A\\<^sup>T $$ (i, inv ?p4 i)) =\n  signof ?p4 * (\\<Prod>i = 0..<n. A $$ (i, ?p4 i))\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (if dim_row A\\<^sup>T = dim_col A\\<^sup>T\n     then \\<Sum>p | p permutes {0..<dim_row A\\<^sup>T}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row A\\<^sup>T. A\\<^sup>T $$ (i, p i))\n     else (0::'a)) =\n    (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))", "by (simp, subst sum_permutations_inverse, intro sum.cong, auto)"], ["proof (state)\nthis:\n  det A\\<^sup>T = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_col:\n  assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"det A = (\\<Sum> p | p permutes {0 ..< n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))\"\n    (is \"_ = (sum (\\<lambda>p. _ * ?prod p) ?P)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?i = \"Hilbert_Choice.inv\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?N = \"{0 ..< n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?f = \"\\<lambda>p. signof p * ?prod p\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?prod' = \"\\<lambda>p. \\<Prod>j<n. A $$ (j, ?i p j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?prod'' = \"\\<lambda>p. \\<Prod>j<n. A $$ (j, p j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?f' = \"\\<lambda>p. signof (?i p) * ?prod' p\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?f'' = \"\\<lambda>p. signof p * ?prod'' p\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "let ?P' = \"{ ?i p | p. p permutes ?N }\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "have [simp]: \"{0..<n} = {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} = {..<n}", "by auto"], ["proof (state)\nthis:\n  {0..<n} = {..<n}\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "have \"sum ?f ?P = sum ?f' ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j)))", "proof (rule sum.cong[OF refl],unfold mem_Collect_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x permutes {0..<n} \\<Longrightarrow>\n       signof x * (\\<Prod>j<n. A $$ (x j, j)) =\n       signof (inv x) * (\\<Prod>j<n. A $$ (j, inv x j))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x permutes {0..<n} \\<Longrightarrow>\n       signof x * (\\<Prod>j<n. A $$ (x j, j)) =\n       signof (inv x) * (\\<Prod>j<n. A $$ (j, inv x j))", "assume p: \"p permutes ?N\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x permutes {0..<n} \\<Longrightarrow>\n       signof x * (\\<Prod>j<n. A $$ (x j, j)) =\n       signof (inv x) * (\\<Prod>j<n. A $$ (j, inv x j))", "have [simp]: \"?prod p = ?prod' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<n. A $$ (p j, j)) = (\\<Prod>j<n. A $$ (j, inv p j))", "using permutes_prod[OF p, of \"\\<lambda>x y. A $$ (x,y)\"]"], ["proof (prove)\nusing this:\n  (\\<Prod>s = 0..<n. A $$ (p s, s)) = (\\<Prod>s = 0..<n. A $$ (s, inv p s))\n\ngoal (1 subgoal):\n 1. (\\<Prod>j<n. A $$ (p j, j)) = (\\<Prod>j<n. A $$ (j, inv p j))", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>j<n. A $$ (p j, j)) = (\\<Prod>j<n. A $$ (j, inv p j))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x permutes {0..<n} \\<Longrightarrow>\n       signof x * (\\<Prod>j<n. A $$ (x j, j)) =\n       signof (inv x) * (\\<Prod>j<n. A $$ (j, inv x j))", "have [simp]: \"signof p = signof (?i p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p = signof (inv p)", "apply(rule signof_inv[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?S\n 2. p permutes ?S", "using p"], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n\ngoal (2 subgoals):\n 1. finite ?S\n 2. p permutes ?S", "by auto"], ["proof (state)\nthis:\n  signof p = signof (inv p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x permutes {0..<n} \\<Longrightarrow>\n       signof x * (\\<Prod>j<n. A $$ (x j, j)) =\n       signof (inv x) * (\\<Prod>j<n. A $$ (j, inv x j))", "show \"?f p = ?f' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p * (\\<Prod>j<n. A $$ (p j, j)) =\n    signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))", "by auto"], ["proof (state)\nthis:\n  signof p * (\\<Prod>j<n. A $$ (p j, j)) =\n  signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j))) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j))) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "have \"... = sum ?f' ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))) =\n    (\\<Sum>p\\<in>{inv p |p. p permutes {0..<n}}.\n       signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j)))", "by (rule sum.cong[OF image_inverse_permutations[symmetric]],auto)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))) =\n  (\\<Sum>p\\<in>{inv p |p. p permutes {0..<n}}.\n     signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))) =\n  (\\<Sum>p\\<in>{inv p |p. p permutes {0..<n}}.\n     signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "have \"... = sum ?f'' ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>{inv p |p. p permutes {0..<n}}.\n       signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))) =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (j, p j)))", "unfolding sum.reindex[OF inv_inj_on_permutes,unfolded image_Collect]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>p.\n             signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))) \\<circ>\n         inv)\n     {p. p permutes {0..<n}} =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (j, p j)))", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{p. p permutes {0..<n}}.\n       signof (inv (inv x)) * (\\<Prod>j<n. A $$ (j, inv (inv x) j))) =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (j, p j)))", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof (inv (inv x)) * (\\<Prod>j<n. A $$ (j, inv (inv x) j)) =\n       signof x * (\\<Prod>j<n. A $$ (j, x j))", "using inv_inv_eq[OF permutes_bij]"], ["proof (prove)\nusing this:\n  ?f permutes ?s1 \\<Longrightarrow> inv (inv ?f) = ?f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof (inv (inv x)) * (\\<Prod>j<n. A $$ (j, inv (inv x) j)) =\n       signof x * (\\<Prod>j<n. A $$ (j, x j))", "by force"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>{inv p |p. p permutes {0..<n}}.\n     signof (inv p) * (\\<Prod>j<n. A $$ (j, inv p j))) =\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (j, p j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j))) =\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (j, p j)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j))) =\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (j, p j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "unfolding det_def'[OF A]"], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j))) =\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (j, p j)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) =\n    (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))", "by auto"], ["proof (state)\nthis:\n  det A =\n  (\\<Sum>p | p permutes {0..<n}. signof p * (\\<Prod>j<n. A $$ (p j, j)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_det_left_def: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"det A = (\\<Sum>p\\<in>{p. p permutes {0..<dim_row A}}. signof p * (\\<Prod>i = 0 ..< dim_row A. A $$ (p i, i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))", "have cong: \"\\<And> a b c. b = c \\<Longrightarrow> a * b = a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. b = c \\<Longrightarrow> a * b = a * c", "by simp"], ["proof (state)\nthis:\n  ?b = ?c \\<Longrightarrow> ?a * ?b = ?a * ?c\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))", "unfolding det_transpose[OF A, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A\\<^sup>T =\n    (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))", "unfolding det_def index_transpose_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_col A = dim_row A\n     then \\<Sum>p | p permutes {0..<dim_col A}.\n            signof p * (\\<Prod>i = 0..<dim_col A. A\\<^sup>T $$ (i, p i))\n     else (0::'a)) =\n    (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (if dim_col A = dim_row A\n     then \\<Sum>p | p permutes {0..<dim_col A}.\n            signof p * (\\<Prod>i = 0..<dim_col A. A\\<^sup>T $$ (i, p i))\n     else (0::'a)) =\n    (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))", "by simp"], ["proof (state)\nthis:\n  det A =\n  (\\<Sum>p | p permutes {0..<dim_row A}.\n     signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_upper_triangular:\n  assumes ut: \"upper_triangular A\"\n  and m: \"A \\<in> carrier_mat n n\"\n  shows \"det A = prod_list (diag_mat A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "note det_def = det_def'[OF m]"], ["proof (state)\nthis:\n  det A =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "let ?U = \"{0..<n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "let ?PU = \"{p. p permutes ?U}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "let ?pp = \"\\<lambda>p. signof p * (\\<Prod> i = 0 ..< n. A $$ (i, p i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have fU: \"finite ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<n}", "by simp"], ["proof (state)\nthis:\n  finite {0..<n}\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "from finite_permutations[OF fU]"], ["proof (chain)\npicking this:\n  finite {p. p permutes {0..<n}}", "have fPU: \"finite ?PU\""], ["proof (prove)\nusing this:\n  finite {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. finite {p. p permutes {0..<n}}", "."], ["proof (state)\nthis:\n  finite {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have id0: \"{id} \\<subseteq> ?PU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {id} \\<subseteq> {p. p permutes {0..<n}}", "by (auto simp add: permutes_id)"], ["proof (state)\nthis:\n  {id} \\<subseteq> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "{"], ["proof (state)\nthis:\n  {id} \\<subseteq> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "assume p: \"p \\<in> ?PU - {id}\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<n}} - {id}\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "from p"], ["proof (chain)\npicking this:\n  p \\<in> {p. p permutes {0..<n}} - {id}", "have pU: \"p permutes ?U\" and pid: \"p \\<noteq> id\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<n}} - {id}\n\ngoal (1 subgoal):\n 1. p permutes {0..<n} &&& p \\<noteq> id", "by blast+"], ["proof (state)\nthis:\n  p permutes {0..<n}\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "from permutes_natset_ge[OF pU] pid"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{0..<n}. i \\<le> p i \\<Longrightarrow> p = id\n  p \\<noteq> id", "obtain i where i: \"p i < i\" and \"i < n\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..<n}. i \\<le> p i \\<Longrightarrow> p = id\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>p i < i; i < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  p i < i\n  i < n\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "from upper_triangularD[OF ut i] \\<open>i < n\\<close> m"], ["proof (chain)\npicking this:\n  i < dim_row A \\<Longrightarrow> A $$ (i, p i) = (0::'a)\n  i < n\n  A \\<in> carrier_mat n n", "have ex:\"\\<exists>i \\<in> ?U. A $$ (i,p i) = 0\""], ["proof (prove)\nusing this:\n  i < dim_row A \\<Longrightarrow> A $$ (i, p i) = (0::'a)\n  i < n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>{0..<n}. A $$ (i, p i) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i\\<in>{0..<n}. A $$ (i, p i) = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have \"(\\<Prod> i = 0 ..< n. A $$ (i, p i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. A $$ (i, p i)) = (0::'a)", "by (rule prod_zero[OF fU ex])"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. A $$ (i, p i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "hence \"?pp p = 0\""], ["proof (prove)\nusing this:\n  (\\<Prod>i = 0..<n. A $$ (i, p i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "}"], ["proof (state)\nthis:\n  ?p2 \\<in> {p. p permutes {0..<n}} - {id} \\<Longrightarrow>\n  signof ?p2 * (\\<Prod>i = 0..<n. A $$ (i, ?p2 i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "then"], ["proof (chain)\npicking this:\n  ?p2 \\<in> {p. p permutes {0..<n}} - {id} \\<Longrightarrow>\n  signof ?p2 * (\\<Prod>i = 0..<n. A $$ (i, ?p2 i)) = (0::'a)", "have p0: \"\\<And> p. p \\<in> ?PU - {id} \\<Longrightarrow> ?pp p = 0\""], ["proof (prove)\nusing this:\n  ?p2 \\<in> {p. p permutes {0..<n}} - {id} \\<Longrightarrow>\n  signof ?p2 * (\\<Prod>i = 0..<n. A $$ (i, ?p2 i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {p. p permutes {0..<n}} - {id} \\<Longrightarrow>\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  ?p \\<in> {p. p permutes {0..<n}} - {id} \\<Longrightarrow>\n  signof ?p * (\\<Prod>i = 0..<n. A $$ (i, ?p i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "from m"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dim: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n", "by simp"], ["proof (state)\nthis:\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have \"det A = (\\<Sum> p \\<in> ?PU. ?pp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))", "by auto"], ["proof (state)\nthis:\n  det A =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "also"], ["proof (state)\nthis:\n  det A =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have \"\\<dots> = ?pp id + (\\<Sum> p \\<in> ?PU - {id}. ?pp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) =\n    signof id * (\\<Prod>i = 0..<n. A $$ (i, id i)) +\n    (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {id}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))", "by (rule sum.remove, insert id0 fPU m, auto simp: p0)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) =\n  signof id * (\\<Prod>i = 0..<n. A $$ (i, id i)) +\n  (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {id}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) =\n  signof id * (\\<Prod>i = 0..<n. A $$ (i, id i)) +\n  (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {id}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have \"(\\<Sum> p \\<in> ?PU - {id}. ?pp p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {id}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) =\n    (0::'a)", "by (rule sum.neutral, insert fPU, auto simp: p0)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {id}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "finally"], ["proof (chain)\npicking this:\n  det A = signof id * (\\<Prod>i = 0..<n. A $$ (i, id i)) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = signof id * (\\<Prod>i = 0..<n. A $$ (i, id i)) + (0::'a)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "using m"], ["proof (prove)\nusing this:\n  det A = signof id * (\\<Prod>i = 0..<n. A $$ (i, id i)) + (0::'a)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "by (auto simp: prod_list_diag_prod)"], ["proof (state)\nthis:\n  det A = prod_list (diag_mat A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_one[simp]: \"det (1\\<^sub>m n) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) = (1::'a)", "have \"det (1\\<^sub>m n) = prod_list (diag_mat (1\\<^sub>m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) = prod_list (diag_mat (1\\<^sub>m n))", "by (rule det_upper_triangular[of _ n], auto)"], ["proof (state)\nthis:\n  det (1\\<^sub>m n) = prod_list (diag_mat (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) = (1::'a)", "also"], ["proof (state)\nthis:\n  det (1\\<^sub>m n) = prod_list (diag_mat (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) = (1::'a)", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat (1\\<^sub>m n)) = (1::'b)", "by (induct n, auto)"], ["proof (state)\nthis:\n  prod_list (diag_mat (1\\<^sub>m n)) = (1::?'b2)\n\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  det (1\\<^sub>m n) = (1::?'b3)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (1\\<^sub>m n) = (1::?'b3)\n\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) = (1::'a)", "."], ["proof (state)\nthis:\n  det (1\\<^sub>m n) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_zero[simp]: assumes \"n > 0\" shows \"det (0\\<^sub>m n n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (0\\<^sub>m n n) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (0\\<^sub>m n n) = (0::'a)", "have \"det (0\\<^sub>m n n) = prod_list (diag_mat (0\\<^sub>m n n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (0\\<^sub>m n n) = prod_list (diag_mat (0\\<^sub>m n n))", "by (rule det_upper_triangular[of _ n], auto)"], ["proof (state)\nthis:\n  det (0\\<^sub>m n n) = prod_list (diag_mat (0\\<^sub>m n n))\n\ngoal (1 subgoal):\n 1. det (0\\<^sub>m n n) = (0::'a)", "also"], ["proof (state)\nthis:\n  det (0\\<^sub>m n n) = prod_list (diag_mat (0\\<^sub>m n n))\n\ngoal (1 subgoal):\n 1. det (0\\<^sub>m n n) = (0::'a)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat (0\\<^sub>m n n)) = (0::'b)", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. prod_list (diag_mat (0\\<^sub>m n n)) = (0::'b)", "by (cases n, auto)"], ["proof (state)\nthis:\n  prod_list (diag_mat (0\\<^sub>m n n)) = (0::?'b2)\n\ngoal (1 subgoal):\n 1. det (0\\<^sub>m n n) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  det (0\\<^sub>m n n) = (0::?'b3)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (0\\<^sub>m n n) = (0::?'b3)\n\ngoal (1 subgoal):\n 1. det (0\\<^sub>m n n) = (0::'a)", "."], ["proof (state)\nthis:\n  det (0\\<^sub>m n n) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_dim_zero[simp]: \"A \\<in> carrier_mat 0 0 \\<Longrightarrow> det A = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat 0 0 \\<Longrightarrow> det A = (1::'a)", "unfolding det_def carrier_mat_def signof_def sign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> {m. dim_row m = 0 \\<and> dim_col m = 0} \\<Longrightarrow>\n    (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            (if (if evenperm p then 1 else - 1) = 1 then 1::'a\n             else - (1::'a)) *\n            (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a)) =\n    (1::'a)", "by auto"], ["", "lemma det_lower_triangular:\n  assumes ld: \"\\<And>i j. i < j \\<Longrightarrow> j < n \\<Longrightarrow> A $$ (i,j) = 0\"\n  and m: \"A \\<in> carrier_mat n n\"\n  shows \"det A = prod_list (diag_mat A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have \"det A = det (transpose_mat A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", "using det_transpose[OF m]"], ["proof (prove)\nusing this:\n  det A\\<^sup>T = det A\n\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "also"], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "have \"\\<dots> = prod_list (diag_mat (transpose_mat A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = prod_list (diag_mat A\\<^sup>T)", "by (rule det_upper_triangular, insert m ld, auto)"], ["proof (state)\nthis:\n  det A\\<^sup>T = prod_list (diag_mat A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "finally"], ["proof (chain)\npicking this:\n  det A = prod_list (diag_mat A\\<^sup>T)", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = prod_list (diag_mat A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "using m"], ["proof (prove)\nusing this:\n  det A = prod_list (diag_mat A\\<^sup>T)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "by simp"], ["proof (state)\nthis:\n  det A = prod_list (diag_mat A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_permute_rows: assumes A: \"A \\<in> carrier_mat n n\"\n  and p: \"p permutes {0 ..< (n :: nat)}\"\n  shows \"det (mat n n (\\<lambda> (i,j). A $$ (p i, j))) = signof p * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "let ?U = \"{0 ..< (n :: nat)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "have cong: \"\\<And> a b c. b = c \\<Longrightarrow> a * b = a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. b = c \\<Longrightarrow> a * b = a * c", "by auto"], ["proof (state)\nthis:\n  ?b = ?c \\<Longrightarrow> ?a * ?b = ?a * ?c\n\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "have \"det (mat n n (\\<lambda> (i,j). A $$ (p i, j))) = \n    (\\<Sum> q \\<in> {q . q permutes ?U}. signof q * (\\<Prod> i \\<in> ?U. A $$ (p i, q i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof q * (\\<Prod>i = 0..<n. A $$ (p i, q i)))", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n        dim_col (mat n n (\\<lambda>(i, j). A $$ (p i, j)))\n     then \\<Sum>p | p permutes\n                    {0..<dim_row\n                          (mat n n (\\<lambda>(i, j). A $$ (p i, j)))}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row\n                             (mat n n (\\<lambda>(i, j). A $$ (p i, j))).\n                mat n n (\\<lambda>(i, j). A $$ (p i, j)) $$ (i, p i))\n     else (0::'a)) =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof q * (\\<Prod>i = 0..<n. A $$ (p i, q i)))", "using A p"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. (if dim_row (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n        dim_col (mat n n (\\<lambda>(i, j). A $$ (p i, j)))\n     then \\<Sum>p | p permutes\n                    {0..<dim_row\n                          (mat n n (\\<lambda>(i, j). A $$ (p i, j)))}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row\n                             (mat n n (\\<lambda>(i, j). A $$ (p i, j))).\n                mat n n (\\<lambda>(i, j). A $$ (p i, j)) $$ (i, p i))\n     else (0::'a)) =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof q * (\\<Prod>i = 0..<n. A $$ (p i, q i)))", "by auto"], ["proof (state)\nthis:\n  det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n  (\\<Sum>q | q permutes {0..<n}.\n     signof q * (\\<Prod>i = 0..<n. A $$ (p i, q i)))\n\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "also"], ["proof (state)\nthis:\n  det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n  (\\<Sum>q | q permutes {0..<n}.\n     signof q * (\\<Prod>i = 0..<n. A $$ (p i, q i)))\n\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "have \"\\<dots> = (\\<Sum> q \\<in> {q . q permutes ?U}. signof (q \\<circ> p) * (\\<Prod> i \\<in> ?U. A $$ (p i, (q \\<circ> p) i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q | q permutes {0..<n}.\n       signof q * (\\<Prod>i = 0..<n. A $$ (p i, q i))) =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof (q \\<circ> p) *\n       (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)))", "by (rule sum_permutations_compose_right[OF p])"], ["proof (state)\nthis:\n  (\\<Sum>q | q permutes {0..<n}.\n     signof q * (\\<Prod>i = 0..<n. A $$ (p i, q i))) =\n  (\\<Sum>q | q permutes {0..<n}.\n     signof (q \\<circ> p) * (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)))\n\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "finally"], ["proof (chain)\npicking this:\n  det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n  (\\<Sum>q | q permutes {0..<n}.\n     signof (q \\<circ> p) * (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)))", "have 1: \"det (mat n n (\\<lambda> (i,j). A $$ (p i, j)))\n    = (\\<Sum> q \\<in> {q . q permutes ?U}. signof (q \\<circ> p) * (\\<Prod> i \\<in> ?U. A $$ (p i, (q \\<circ> p) i)))\""], ["proof (prove)\nusing this:\n  det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n  (\\<Sum>q | q permutes {0..<n}.\n     signof (q \\<circ> p) * (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)))\n\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof (q \\<circ> p) *\n       (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)))", "."], ["proof (state)\nthis:\n  det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) =\n  (\\<Sum>q | q permutes {0..<n}.\n     signof (q \\<circ> p) * (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)))\n\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "have 2: \"signof p * det A = \n    (\\<Sum> q\\<in>{q. q permutes ?U}. signof p * signof q * (\\<Prod>i\\<in> ?U. A $$ (i, q i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p * det A =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof p * signof q * (\\<Prod>i = 0..<n. A $$ (i, q i)))", "unfolding det_def'[OF A] sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>na\\<in>{p. p permutes {0..<n}}.\n       signof p * (signof na * (\\<Prod>i = 0..<n. A $$ (i, na i)))) =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof p * signof q * (\\<Prod>i = 0..<n. A $$ (i, q i)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  signof p * det A =\n  (\\<Sum>q | q permutes {0..<n}.\n     signof p * signof q * (\\<Prod>i = 0..<n. A $$ (i, q i)))\n\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A", "unfolding 1 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q | q permutes {0..<n}.\n       signof (q \\<circ> p) *\n       (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i))) =\n    (\\<Sum>q | q permutes {0..<n}.\n       signof p * signof q * (\\<Prod>i = 0..<n. A $$ (i, q i)))", "proof (rule sum.cong, insert p A, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "assume q: \"q permutes ?U\""], ["proof (state)\nthis:\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "let ?inv = \"Hilbert_Choice.inv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "from permutes_inv[OF p]"], ["proof (chain)\npicking this:\n  inv p permutes {0..<n}", "have ip: \"?inv p permutes ?U\""], ["proof (prove)\nusing this:\n  inv p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. inv p permutes {0..<n}", "."], ["proof (state)\nthis:\n  inv p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "have \"prod (\\<lambda>i. A $$ (p i, (q \\<circ> p) i)) ?U = \n      prod (\\<lambda>i. A $$ ((p \\<circ> ?inv p) i, (q \\<circ> (p \\<circ> ?inv p)) i)) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)) =\n    (\\<Prod>i = 0..<n.\n        A $$ ((p \\<circ> inv p) i, (q \\<circ> (p \\<circ> inv p)) i))", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. A $$ (p i, q (p i))) =\n    (\\<Prod>i = 0..<n. A $$ (p (inv p i), q (p (inv p i))))", "by (rule trans[OF prod.permute[OF ip] prod.cong], insert A p q, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)) =\n  (\\<Prod>i = 0..<n.\n      A $$ ((p \\<circ> inv p) i, (q \\<circ> (p \\<circ> inv p)) i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)) =\n  (\\<Prod>i = 0..<n.\n      A $$ ((p \\<circ> inv p) i, (q \\<circ> (p \\<circ> inv p)) i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "have \"\\<dots> = prod (\\<lambda>i. A$$(i,q i)) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        A $$ ((p \\<circ> inv p) i, (q \\<circ> (p \\<circ> inv p)) i)) =\n    (\\<Prod>i = 0..<n. A $$ (i, q i))", "by (simp only: o_def permutes_inverses[OF p])"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      A $$ ((p \\<circ> inv p) i, (q \\<circ> (p \\<circ> inv p)) i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, q i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, q i))", "have thp: \"prod (\\<lambda>i. A $$ (p i, (q \\<circ> p) i)) ?U = prod (\\<lambda>i. A$$(i,q i)) ?U\""], ["proof (prove)\nusing this:\n  (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, q i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)) =\n    (\\<Prod>i = 0..<n. A $$ (i, q i))", "."], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, q i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x permutes {0..<n}; p permutes {0..<n};\n        A \\<in> carrier_mat n n\\<rbrakk>\n       \\<Longrightarrow> signof (x \\<circ> p) *\n                         (\\<Prod>i = 0..<n. A $$ (p i, x (p i))) =\n                         signof p * signof x *\n                         (\\<Prod>i = 0..<n. A $$ (i, x i))", "show \"signof (q \\<circ> p) * (\\<Prod>i\\<in>{0..<n}. A $$ (p i, q (p i))) =\n         signof p * signof q * (\\<Prod>i\\<in>{0..<n}. A $$ (i, q i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (q \\<circ> p) * (\\<Prod>i = 0..<n. A $$ (p i, q (p i))) =\n    signof p * signof q * (\\<Prod>i = 0..<n. A $$ (i, q i))", "unfolding thp[symmetric] signof_compose[OF q p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof q * signof p * (\\<Prod>i = 0..<n. A $$ (p i, q (p i))) =\n    signof p * signof q * (\\<Prod>i = 0..<n. A $$ (p i, (q \\<circ> p) i))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  signof (q \\<circ> p) * (\\<Prod>i = 0..<n. A $$ (p i, q (p i))) =\n  signof p * signof q * (\\<Prod>i = 0..<n. A $$ (i, q i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (mat n n (\\<lambda>(i, j). A $$ (p i, j))) = signof p * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_multrow_mat: assumes k: \"k < n\"\n  shows \"det (multrow_mat n k a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (multrow_mat n k a) = a", "proof (rule trans[OF det_lower_triangular[of n]], unfold prod_list_diag_prod)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> multrow_mat n k a $$ (i, j) = (0::'a)\n 2. multrow_mat n k a \\<in> carrier_mat n n\n 3. (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n        multrow_mat n k a $$ (i, i)) =\n    a", "let ?f = \"\\<lambda> i. multrow_mat n k a $$ (i, i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> multrow_mat n k a $$ (i, j) = (0::'a)\n 2. multrow_mat n k a \\<in> carrier_mat n n\n 3. (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n        multrow_mat n k a $$ (i, i)) =\n    a", "have \"(\\<Prod>i\\<in>{0..<n}. ?f i) = ?f k * (\\<Prod>i\\<in>{0..<n} - {k}. ?f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. multrow_mat n k a $$ (i, i)) =\n    multrow_mat n k a $$ (k, k) *\n    (\\<Prod>i\\<in>{0..<n} - {k}. multrow_mat n k a $$ (i, i))", "by (rule prod.remove, insert k, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. multrow_mat n k a $$ (i, i)) =\n  multrow_mat n k a $$ (k, k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}. multrow_mat n k a $$ (i, i))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> multrow_mat n k a $$ (i, j) = (0::'a)\n 2. multrow_mat n k a \\<in> carrier_mat n n\n 3. (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n        multrow_mat n k a $$ (i, i)) =\n    a", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. multrow_mat n k a $$ (i, i)) =\n  multrow_mat n k a $$ (k, k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}. multrow_mat n k a $$ (i, i))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> multrow_mat n k a $$ (i, j) = (0::'a)\n 2. multrow_mat n k a \\<in> carrier_mat n n\n 3. (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n        multrow_mat n k a $$ (i, i)) =\n    a", "have \"(\\<Prod>i\\<in>{0..<n} - {k}. ?f i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {k}. multrow_mat n k a $$ (i, i)) = (1::'a)", "by (rule prod.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<n} - {k}. multrow_mat n k a $$ (i, i)) = (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> multrow_mat n k a $$ (i, j) = (0::'a)\n 2. multrow_mat n k a \\<in> carrier_mat n n\n 3. (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n        multrow_mat n k a $$ (i, i)) =\n    a", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i = 0..<n. multrow_mat n k a $$ (i, i)) =\n  multrow_mat n k a $$ (k, k) * (1::'a)", "show \"(\\<Prod>i\\<in>{0..<dim_row (multrow_mat n k a)}. ?f i) = a\""], ["proof (prove)\nusing this:\n  (\\<Prod>i = 0..<n. multrow_mat n k a $$ (i, i)) =\n  multrow_mat n k a $$ (k, k) * (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n        multrow_mat n k a $$ (i, i)) =\n    a", "using k"], ["proof (prove)\nusing this:\n  (\\<Prod>i = 0..<n. multrow_mat n k a $$ (i, i)) =\n  multrow_mat n k a $$ (k, k) * (1::'a)\n  k < n\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n        multrow_mat n k a $$ (i, i)) =\n    a", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<dim_row (multrow_mat n k a).\n      multrow_mat n k a $$ (i, i)) =\n  a\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < n\\<rbrakk>\n       \\<Longrightarrow> multrow_mat n k a $$ (i, j) = (0::'a)\n 2. multrow_mat n k a \\<in> carrier_mat n n", "qed (insert k, auto)"], ["", "lemma swap_rows_mat_eq_permute: \n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> swaprows_mat n k l = mat n n (\\<lambda>(i, j). 1\\<^sub>m n $$ (Fun.swap k l id i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < n; l < n\\<rbrakk>\n    \\<Longrightarrow> swaprows_mat n k l =\n                      mat n n\n                       (\\<lambda>(i, j).\n                           1\\<^sub>m n $$ (Fun.swap k l id i, j))", "by (rule eq_matI, auto simp: swap_def)"], ["", "lemma det_swaprows_mat: assumes k: \"k < n\" and l: \"l < n\" and kl: \"k \\<noteq> l\"\n  shows \"det (swaprows_mat n k l) = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l) = - (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l) = - (1::'a)", "let ?n = \"{0 ..< (n :: nat)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l) = - (1::'a)", "let ?p = \"Fun.swap k l id\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l) = - (1::'a)", "have p: \"?p permutes ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap k l id permutes {0..<n}", "by (rule permutes_swap_id, insert k l, auto)"], ["proof (state)\nthis:\n  Fun.swap k l id permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l) = - (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l) = - (1::'a)", "by (rule trans[OF trans[OF _ det_permute_rows[OF one_carrier_mat[of n] p]]],\n    subst swap_rows_mat_eq_permute[OF k l], auto simp: signof_def sign_swap_id kl)"], ["proof (state)\nthis:\n  det (swaprows_mat n k l) = - (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_addrow_mat: \n  assumes l: \"k \\<noteq> l\"\n  shows \"det (addrow_mat n a k l) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = (1::'a)", "have \"det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "proof (cases \"k < l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < l \\<Longrightarrow>\n    det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))\n 2. \\<not> k < l \\<Longrightarrow>\n    det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "case True"], ["proof (state)\nthis:\n  k < l\n\ngoal (2 subgoals):\n 1. k < l \\<Longrightarrow>\n    det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))\n 2. \\<not> k < l \\<Longrightarrow>\n    det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "by (rule det_upper_triangular[of _ n], insert True, auto intro!: upper_triangularI)"], ["proof (state)\nthis:\n  det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))\n\ngoal (1 subgoal):\n 1. \\<not> k < l \\<Longrightarrow>\n    det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < l \\<Longrightarrow>\n    det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "case False"], ["proof (state)\nthis:\n  \\<not> k < l\n\ngoal (1 subgoal):\n 1. \\<not> k < l \\<Longrightarrow>\n    det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))", "by (rule det_lower_triangular[of n], insert False, auto)"], ["proof (state)\nthis:\n  det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))\n\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = (1::'a)", "also"], ["proof (state)\nthis:\n  det (addrow_mat n a k l) = prod_list (diag_mat (addrow_mat n a k l))\n\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = (1::'a)", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat (addrow_mat n a k l)) = (1::'a)", "unfolding prod_list_diag_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_row (addrow_mat n a k l).\n        addrow_mat n a k l $$ (i, i)) =\n    (1::'a)", "by (rule prod.neutral, insert l, auto)"], ["proof (state)\nthis:\n  prod_list (diag_mat (addrow_mat n a k l)) = (1::'a)\n\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  det (addrow_mat n a k l) = (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (addrow_mat n a k l) = (1::'a)\n\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = (1::'a)", "."], ["proof (state)\nthis:\n  det (addrow_mat n a k l) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following proof is new, as it does not use $2 \\neq 0$ as in Multivariate-Analysis.\\<close>"], ["", "lemma det_identical_rows:\n  assumes A: \"A \\<in> carrier_mat n n\"  \n    and ij: \"i \\<noteq> j\"\n    and i: \"i < n\" and j: \"j < n\"\n    and r: \"row A i = row A j\"\n  shows \"det A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "let ?p = \"Fun.swap i j id\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "let ?n = \"{0 ..< n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have sp: \"signof ?p = - 1\" \"sign ?p = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (Fun.swap i j id) = - (1::'b) &&& sign (Fun.swap i j id) = - 1", "unfolding signof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if sign (Fun.swap i j id) = 1 then 1::'b else - (1::'b)) =\n    - (1::'b) &&&\n    sign (Fun.swap i j id) = - 1", "using ij"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (if sign (Fun.swap i j id) = 1 then 1::'b else - (1::'b)) =\n    - (1::'b) &&&\n    sign (Fun.swap i j id) = - 1", "by (auto simp add: sign_swap_id)"], ["proof (state)\nthis:\n  signof (Fun.swap i j id) = - (1::?'b)\n  sign (Fun.swap i j id) = - 1\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "let ?f = \"\\<lambda> p. signof p * (\\<Prod>i\\<in>?n. A $$ (p i, i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "let ?all = \"{p. p permutes ?n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "let ?one = \"{p. p permutes ?n \\<and> sign p = 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "let ?none = \"{p. p permutes ?n \\<and> sign p \\<noteq> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "let ?pone = \"(\\<lambda> p. ?p o p) ` ?one\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have split: \"?one \\<union> ?none = ?all\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n    {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    {p. p permutes {0..<n}}", "by auto"], ["proof (state)\nthis:\n  {p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n  {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n  {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have p: \"?p permutes ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap i j id permutes {0..<n}", "by (rule permutes_swap_id, insert i j, auto)"], ["proof (state)\nthis:\n  Fun.swap i j id permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "from permutes_inj[OF p]"], ["proof (chain)\npicking this:\n  inj (Fun.swap i j id)", "have injp: \"inj ?p\""], ["proof (prove)\nusing this:\n  inj (Fun.swap i j id)\n\ngoal (1 subgoal):\n 1. inj (Fun.swap i j id)", "by auto"], ["proof (state)\nthis:\n  inj (Fun.swap i j id)\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "{"], ["proof (state)\nthis:\n  inj (Fun.swap i j id)\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "assume q: \"q permutes ?n\""], ["proof (state)\nthis:\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"(\\<Prod>k\\<in>?n. A $$ (?p (q k), k)) = (\\<Prod>k\\<in>?n. A $$ (q k, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k = 0..<n. A $$ (Fun.swap i j id (q k), k)) =\n    (\\<Prod>k = 0..<n. A $$ (q k, k))", "proof (rule prod.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       A $$ (Fun.swap i j id (q x), x) = A $$ (q x, x)", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       A $$ (Fun.swap i j id (q x), x) = A $$ (q x, x)", "assume k: \"k \\<in> ?n\""], ["proof (state)\nthis:\n  k \\<in> {0..<n}\n\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       A $$ (Fun.swap i j id (q x), x) = A $$ (q x, x)", "from r"], ["proof (chain)\npicking this:\n  row A i = row A j", "have row: \"row A i $ k = row A j $ k\""], ["proof (prove)\nusing this:\n  row A i = row A j\n\ngoal (1 subgoal):\n 1. row A i $ k = row A j $ k", "by simp"], ["proof (state)\nthis:\n  row A i $ k = row A j $ k\n\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       A $$ (Fun.swap i j id (q x), x) = A $$ (q x, x)", "hence \"A $$ (i,k) = A $$ (j,k)\""], ["proof (prove)\nusing this:\n  row A i $ k = row A j $ k\n\ngoal (1 subgoal):\n 1. A $$ (i, k) = A $$ (j, k)", "using k i j A"], ["proof (prove)\nusing this:\n  row A i $ k = row A j $ k\n  k \\<in> {0..<n}\n  i < n\n  j < n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A $$ (i, k) = A $$ (j, k)", "by auto"], ["proof (state)\nthis:\n  A $$ (i, k) = A $$ (j, k)\n\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       A $$ (Fun.swap i j id (q x), x) = A $$ (q x, x)", "thus \"A $$ (?p (q k), k) = A $$ (q k, k)\""], ["proof (prove)\nusing this:\n  A $$ (i, k) = A $$ (j, k)\n\ngoal (1 subgoal):\n 1. A $$ (Fun.swap i j id (q k), k) = A $$ (q k, k)", "by (cases \"q k = i\", auto, cases \"q k = j\", auto)"], ["proof (state)\nthis:\n  A $$ (Fun.swap i j id (q k), k) = A $$ (q k, k)\n\ngoal (1 subgoal):\n 1. {0..<n} = {0..<n}", "qed (insert A q, auto)"], ["proof (state)\nthis:\n  (\\<Prod>k = 0..<n. A $$ (Fun.swap i j id (q k), k)) =\n  (\\<Prod>k = 0..<n. A $$ (q k, k))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "}"], ["proof (state)\nthis:\n  ?q3 permutes {0..<n} \\<Longrightarrow>\n  (\\<Prod>k = 0..<n. A $$ (Fun.swap i j id (?q3 k), k)) =\n  (\\<Prod>k = 0..<n. A $$ (?q3 k, k))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "note * = this"], ["proof (state)\nthis:\n  ?q3 permutes {0..<n} \\<Longrightarrow>\n  (\\<Prod>k = 0..<n. A $$ (Fun.swap i j id (?q3 k), k)) =\n  (\\<Prod>k = 0..<n. A $$ (?q3 k, k))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have pp: \"\\<And> q. q permutes ?n \\<Longrightarrow> permutation q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. q permutes {0..<n} \\<Longrightarrow> permutation q", "unfolding \n    permutation_permutes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q permutes {0..<n} \\<Longrightarrow>\n       \\<exists>S. finite S \\<and> q permutes S", "by auto"], ["proof (state)\nthis:\n  ?q1 permutes {0..<n} \\<Longrightarrow> permutation ?q1\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"det A = (\\<Sum>p\\<in> ?one \\<union> ?none. ?f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p\\<in>{p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n                 {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p\\<in>{p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n                 {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))", "unfolding mat_det_left_def[OF A] split"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<dim_row A}.\n       signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))", "by simp"], ["proof (state)\nthis:\n  det A =\n  (\\<Sum>p\\<in>{p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n               {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "also"], ["proof (state)\nthis:\n  det A =\n  (\\<Sum>p\\<in>{p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n               {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"\\<dots> = (\\<Sum>p\\<in> ?one. ?f p) + (\\<Sum>p\\<in> ?none. ?f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>{p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n                 {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n    (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) +\n    (\\<Sum>p | p permutes {0..<n} \\<and> sign p \\<noteq> 1.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))", "by (rule sum.union_disjoint, insert A, auto simp: finite_permutations)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>{p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n               {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) +\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p \\<noteq> 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>{p. p permutes {0..<n} \\<and> sign p = 1} \\<union>\n               {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) +\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p \\<noteq> 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"?none = ?pone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "assume \"q \\<in> ?none\""], ["proof (state)\nthis:\n  q \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "hence q: \"q permutes ?n\" and sq: \"sign q = -1\""], ["proof (prove)\nusing this:\n  q \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. q permutes {0..<n} &&& sign q = - 1", "unfolding sign_def"], ["proof (prove)\nusing this:\n  q \\<in> {p. p permutes {0..<n} \\<and>\n              (if evenperm p then 1 else - 1) \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. q permutes {0..<n} &&& (if evenperm q then 1 else - 1) = - 1", "by auto"], ["proof (state)\nthis:\n  q permutes {0..<n}\n  sign q = - 1\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "from permutes_compose[OF q p] sign_compose[OF pp[OF p] pp[OF q], unfolded sp sq]"], ["proof (chain)\npicking this:\n  Fun.swap i j id \\<circ> q permutes {0..<n}\n  sign (Fun.swap i j id \\<circ> q) = - 1 * - 1", "have \"?p o q \\<in> ?one\""], ["proof (prove)\nusing this:\n  Fun.swap i j id \\<circ> q permutes {0..<n}\n  sign (Fun.swap i j id \\<circ> q) = - 1 * - 1\n\ngoal (1 subgoal):\n 1. Fun.swap i j id \\<circ> q\n    \\<in> {p. p permutes {0..<n} \\<and> sign p = 1}", "by auto"], ["proof (state)\nthis:\n  Fun.swap i j id \\<circ> q \\<in> {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "hence \"?p o (?p o q) \\<in> ?pone\""], ["proof (prove)\nusing this:\n  Fun.swap i j id \\<circ> q \\<in> {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. Fun.swap i j id \\<circ> (Fun.swap i j id \\<circ> q)\n    \\<in> (\\<circ>) (Fun.swap i j id) `\n          {p. p permutes {0..<n} \\<and> sign p = 1}", "by auto"], ["proof (state)\nthis:\n  Fun.swap i j id \\<circ> (Fun.swap i j id \\<circ> q)\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "also"], ["proof (state)\nthis:\n  Fun.swap i j id \\<circ> (Fun.swap i j id \\<circ> q)\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "have \"?p o (?p o q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap i j id \\<circ> (Fun.swap i j id \\<circ> q) = q", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Fun.swap i j id (Fun.swap i j id (q x))) = q", "by (intro ext, auto simp: swap_def)"], ["proof (state)\nthis:\n  Fun.swap i j id \\<circ> (Fun.swap i j id \\<circ> q) = q\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "finally"], ["proof (chain)\npicking this:\n  q \\<in> (\\<circ>) (Fun.swap i j id) `\n          {p. p permutes {0..<n} \\<and> sign p = 1}", "have \"q \\<in> ?pone\""], ["proof (prove)\nusing this:\n  q \\<in> (\\<circ>) (Fun.swap i j id) `\n          {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<circ>) (Fun.swap i j id) `\n            {p. p permutes {0..<n} \\<and> sign p = 1}", "."], ["proof (state)\nthis:\n  q \\<in> (\\<circ>) (Fun.swap i j id) `\n          {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "}"], ["proof (state)\nthis:\n  ?q3\n  \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} \\<Longrightarrow>\n  ?q3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "moreover"], ["proof (state)\nthis:\n  ?q3\n  \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} \\<Longrightarrow>\n  ?q3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "{"], ["proof (state)\nthis:\n  ?q3\n  \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} \\<Longrightarrow>\n  ?q3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "fix pq"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "assume \"pq \\<in> ?pone\""], ["proof (state)\nthis:\n  pq \\<in> (\\<circ>) (Fun.swap i j id) `\n           {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "then"], ["proof (chain)\npicking this:\n  pq \\<in> (\\<circ>) (Fun.swap i j id) `\n           {p. p permutes {0..<n} \\<and> sign p = 1}", "obtain q where q: \"q \\<in> ?one\" and pq: \"pq = ?p o q\""], ["proof (prove)\nusing this:\n  pq \\<in> (\\<circ>) (Fun.swap i j id) `\n           {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> {p. p permutes {0..<n} \\<and> sign p = 1};\n         pq = Fun.swap i j id \\<circ> q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> {p. p permutes {0..<n} \\<and> sign p = 1}\n  pq = Fun.swap i j id \\<circ> q\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "from q"], ["proof (chain)\npicking this:\n  q \\<in> {p. p permutes {0..<n} \\<and> sign p = 1}", "have q: \"q permutes ?n\" and sq: \"sign q = 1\""], ["proof (prove)\nusing this:\n  q \\<in> {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. q permutes {0..<n} &&& sign q = 1", "by auto"], ["proof (state)\nthis:\n  q permutes {0..<n}\n  sign q = 1\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "from sign_compose[OF pp[OF p] pp[OF q], unfolded sq sp]"], ["proof (chain)\npicking this:\n  sign (Fun.swap i j id \\<circ> q) = - 1 * 1", "have spq: \"sign pq = -1\""], ["proof (prove)\nusing this:\n  sign (Fun.swap i j id \\<circ> q) = - 1 * 1\n\ngoal (1 subgoal):\n 1. sign pq = - 1", "unfolding pq"], ["proof (prove)\nusing this:\n  sign (Fun.swap i j id \\<circ> q) = - 1 * 1\n\ngoal (1 subgoal):\n 1. sign (Fun.swap i j id \\<circ> q) = - 1", "by auto"], ["proof (state)\nthis:\n  sign pq = - 1\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "from permutes_compose[OF q p]"], ["proof (chain)\npicking this:\n  Fun.swap i j id \\<circ> q permutes {0..<n}", "have pq: \"pq permutes ?n\""], ["proof (prove)\nusing this:\n  Fun.swap i j id \\<circ> q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. pq permutes {0..<n}", "unfolding pq"], ["proof (prove)\nusing this:\n  Fun.swap i j id \\<circ> q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. Fun.swap i j id \\<circ> q permutes {0..<n}", "by auto"], ["proof (state)\nthis:\n  pq permutes {0..<n}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "from pq spq"], ["proof (chain)\npicking this:\n  pq permutes {0..<n}\n  sign pq = - 1", "have \"pq \\<in> ?none\""], ["proof (prove)\nusing this:\n  pq permutes {0..<n}\n  sign pq = - 1\n\ngoal (1 subgoal):\n 1. pq \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}", "by auto"], ["proof (state)\nthis:\n  pq \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "}"], ["proof (state)\nthis:\n  ?pq3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1} \\<Longrightarrow>\n  ?pq3 \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "ultimately"], ["proof (chain)\npicking this:\n  ?q3\n  \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} \\<Longrightarrow>\n  ?q3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1}\n  ?pq3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1} \\<Longrightarrow>\n  ?pq3 \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?q3\n  \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} \\<Longrightarrow>\n  ?q3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1}\n  ?pq3\n  \\<in> (\\<circ>) (Fun.swap i j id) `\n        {p. p permutes {0..<n} \\<and> sign p = 1} \\<Longrightarrow>\n  ?pq3 \\<in> {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n    (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}", "by blast"], ["proof (state)\nthis:\n  {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n  (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n  (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "also"], ["proof (state)\nthis:\n  {p. p permutes {0..<n} \\<and> sign p \\<noteq> 1} =\n  (\\<circ>) (Fun.swap i j id) ` {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"(\\<Sum>p\\<in> ?pone. ?f p) = (\\<Sum>p\\<in> ?one. ?f (?p o p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i j id) `\n                 {p. p permutes {0..<n} \\<and> sign p = 1}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n    (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof (Fun.swap i j id \\<circ> p) *\n       (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))", "proof (rule trans[OF sum.reindex])"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on ((\\<circ>) (Fun.swap i j id))\n     {p. p permutes {0..<n} \\<and> sign p = 1}\n 2. sum ((\\<lambda>p. signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) \\<circ>\n         (\\<circ>) (Fun.swap i j id))\n     {p. p permutes {0..<n} \\<and> sign p = 1} =\n    (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof (Fun.swap i j id \\<circ> p) *\n       (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))", "show \"inj_on ((\\<circ>) ?p) ?one\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((\\<circ>) (Fun.swap i j id))\n     {p. p permutes {0..<n} \\<and> sign p = 1}", "using fun.inj_map[OF injp]"], ["proof (prove)\nusing this:\n  inj ((\\<circ>) (Fun.swap i j id))\n\ngoal (1 subgoal):\n 1. inj_on ((\\<circ>) (Fun.swap i j id))\n     {p. p permutes {0..<n} \\<and> sign p = 1}", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        Fun.swap i j id \\<circ> x =\n        Fun.swap i j id \\<circ> y \\<longrightarrow>\n        x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{p. p permutes {0..<n} \\<and> sign p = 1}.\n       \\<forall>y\\<in>{p. p permutes {0..<n} \\<and> sign p = 1}.\n          Fun.swap i j id \\<circ> x =\n          Fun.swap i j id \\<circ> y \\<longrightarrow>\n          x = y", "by auto"], ["proof (state)\nthis:\n  inj_on ((\\<circ>) (Fun.swap i j id))\n   {p. p permutes {0..<n} \\<and> sign p = 1}\n\ngoal (1 subgoal):\n 1. sum ((\\<lambda>p. signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) \\<circ>\n         (\\<circ>) (Fun.swap i j id))\n     {p. p permutes {0..<n} \\<and> sign p = 1} =\n    (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof (Fun.swap i j id \\<circ> p) *\n       (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i j id) `\n               {p. p permutes {0..<n} \\<and> sign p = 1}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof (Fun.swap i j id \\<circ> p) *\n     (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i j id) `\n               {p. p permutes {0..<n} \\<and> sign p = 1}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof (Fun.swap i j id \\<circ> p) *\n     (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"(\\<Sum>p\\<in> ?one. ?f p) + (\\<Sum>p\\<in> ?one. ?f (?p o p))\n    = (\\<Sum>p\\<in> ?one. ?f p + ?f (?p o p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) +\n    (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof (Fun.swap i j id \\<circ> p) *\n       (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia))) =\n    (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)) +\n       signof (Fun.swap i j id \\<circ> p) *\n       (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))", "by (rule sum.distrib[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) +\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof (Fun.swap i j id \\<circ> p) *\n     (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia))) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)) +\n     signof (Fun.swap i j id \\<circ> p) *\n     (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))) +\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof (Fun.swap i j id \\<circ> p) *\n     (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia))) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)) +\n     signof (Fun.swap i j id \\<circ> p) *\n     (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia)))\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n       signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)) +\n       signof (Fun.swap i j id \\<circ> p) *\n       (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia))) =\n    (0::'a)", "by (rule sum.neutral, insert A, auto simp: \n      sp sign_compose[OF pp[OF p] pp] ij signof_def finite_permutations *)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> sign p = 1.\n     signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)) +\n     signof (Fun.swap i j id \\<circ> p) *\n     (\\<Prod>ia = 0..<n. A $$ ((Fun.swap i j id \\<circ> p) ia, ia))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  det A = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "."], ["proof (state)\nthis:\n  det A = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_row_0: assumes k: \"k < n\"\n  and c: \"c \\<in> {0 ..< n} \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "assume p: \"p permutes {0 ..< n}\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "have \"(\\<Prod>i\\<in>{0..<n}. mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i) $$ (i, p i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i) $$\n        (i, p i)) =\n    (0::'a)", "by (rule prod_zero[OF _ bexI[of _ k]], \n      insert k p c[unfolded carrier_vec_def], auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i) $$\n      (i, p i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i) $$\n      (i, ?p2 i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i) $$\n      (i, ?p2 i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n    (0::'a)", "unfolding det_def"], ["proof (prove)\nusing this:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i) $$\n      (i, ?p2 i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (if dim_row\n         (mat\\<^sub>r n n\n           (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n        dim_col\n         (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i))\n     then \\<Sum>p | p permutes\n                    {0..<dim_row\n                          (mat\\<^sub>r n n\n                            (\\<lambda>i.\n                                if i = k then 0\\<^sub>v n else c i))}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row\n                             (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k then 0\\<^sub>v n else c i)).\n                mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then 0\\<^sub>v n else c i) $$\n                (i, p i))\n     else (0::'a)) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then 0\\<^sub>v n else c i)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_row_add: \n  assumes abc: \"a k \\<in> carrier_vec n\" \"b k \\<in> carrier_vec n\" \"c \\<in> {0..<n} \\<rightarrow> carrier_vec n\"\n    and k: \"k < n\"\n  shows \"det(mat\\<^sub>r n n (\\<lambda> i. if i = k then a i + b i else c i)) =\n    det(mat\\<^sub>r n n (\\<lambda> i. if i = k then a i else c i)) +\n    det(mat\\<^sub>r n n (\\<lambda> i. if i = k then b i else c i))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "let ?n = \"{0..<n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "let ?m = \"\\<lambda> a b p i. mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else b i) $$ (i, p i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "let ?c = \"\\<lambda> p i. mat\\<^sub>r n n c $$ (i, p i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "let ?ab = \"\\<lambda> i. a i + b i\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "note intros = add_carrier_vec[of _ n]"], ["proof (state)\nthis:\n  \\<lbrakk>?v\\<^sub>1 \\<in> carrier_vec n;\n   ?v\\<^sub>2 \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> ?v\\<^sub>1 + ?v\\<^sub>2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "have \"?rhs = (\\<Sum>p\\<in>{p. p permutes ?n}. \n    signof p * (\\<Prod>i\\<in>?n. ?m a c p i)) + (\\<Sum>p\\<in>{p. p permutes ?n}. signof p * (\\<Prod>i\\<in>?n. ?m b c p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i)) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, p i))) +\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, p i)))", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) =\n        dim_col (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i))\n     then \\<Sum>p | p permutes\n                    {0..<dim_row\n                          (mat\\<^sub>r n n\n                            (\\<lambda>i. if i = k then a i else c i))}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row\n                             (mat\\<^sub>r n n\n                               (\\<lambda>i. if i = k then a i else c i)).\n                mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n                (i, p i))\n     else (0::'a)) +\n    (if dim_row (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i)) =\n        dim_col (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))\n     then \\<Sum>p | p permutes\n                    {0..<dim_row\n                          (mat\\<^sub>r n n\n                            (\\<lambda>i. if i = k then b i else c i))}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row\n                             (mat\\<^sub>r n n\n                               (\\<lambda>i. if i = k then b i else c i)).\n                mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n                (i, p i))\n     else (0::'a)) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, p i))) +\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, p i)))", "by simp"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i)) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i))) +\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i)))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "also"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i)) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i))) +\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i)))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "have \"\\<dots> = (\\<Sum>p\\<in>{p. p permutes ?n}. signof p * (\\<Prod>i\\<in>?n. ?m a c p i) +  signof p * (\\<Prod>i\\<in>?n. ?m b c p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, p i))) +\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, p i))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, p i)) +\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, p i)))", "by (rule sum.distrib[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i))) +\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i))) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i)) +\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i)))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i))) +\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i))) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i)) +\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i)))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "have \"\\<dots> = (\\<Sum>p\\<in>{p. p permutes ?n}. signof p * (\\<Prod>i\\<in>?n. ?m ?ab c p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, p i)) +\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, p i))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n           (i, p i)))", "proof (rule sum.cong, force)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, x i)) +\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, x i)) =\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n           (i, x i))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, x i)) +\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, x i)) =\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n           (i, x i))", "assume \"p \\<in> {p. p permutes ?n}\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, x i)) +\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, x i)) =\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n           (i, x i))", "hence p: \"p permutes ?n\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. p permutes {0..<n}", "by simp"], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n           (i, x i)) +\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n           (i, x i)) =\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n           (i, x i))", "show \"signof p * (\\<Prod>i\\<in>?n. ?m a c p i) + signof p * (\\<Prod>i\\<in>?n. ?m b c p i) = \n      signof p * (\\<Prod>i\\<in>?n. ?m ?ab c p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p *\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    signof p *\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    signof p *\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "unfolding distrib_left[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p *\n    ((\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i)) +\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i))) =\n    signof p *\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "proof (rule arg_cong[of _ _ \"\\<lambda> a. signof p * a\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "from k"], ["proof (chain)\npicking this:\n  k < n", "have f: \"finite ?n\" and k': \"k \\<in> ?n\""], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. finite {0..<n} &&& k \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  finite {0..<n}\n  k \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "let ?nk = \"?n - {k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "note split = prod.remove[OF f k']"], ["proof (state)\nthis:\n  prod ?g {0..<n} = ?g k * prod ?g ({0..<n} - {k})\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "have id1: \"(\\<Prod>i\\<in>?n. ?m a c p i) = ?m a c p k * (\\<Prod>i\\<in>?nk. ?m a c p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) =\n    mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$ (k, p k) *\n    (\\<Prod>i\\<in>{0..<n} - {k}.\n       mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$ (i, p i))", "by (rule split)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n      (i, p i)) =\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$ (k, p k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}.\n     mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$ (i, p i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "have id2: \"(\\<Prod>i\\<in>?n. ?m b c p i) = ?m b c p k * (\\<Prod>i\\<in>?nk. ?m b c p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$ (k, p k) *\n    (\\<Prod>i\\<in>{0..<n} - {k}.\n       mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$ (i, p i))", "by (rule split)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n      (i, p i)) =\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$ (k, p k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}.\n     mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$ (i, p i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "have id3: \"(\\<Prod>i\\<in>?n. ?m ?ab c p i) = ?m ?ab c p k * (\\<Prod>i\\<in>?nk. ?m ?ab c p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i)) =\n    mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n    (k, p k) *\n    (\\<Prod>i\\<in>{0..<n} - {k}.\n       mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n       (i, p i))", "by (rule split)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n      (i, p i)) =\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n  (k, p k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}.\n     mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n     (i, p i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "have id: \"\\<And> a. (\\<Prod>i\\<in>?nk. ?m a c p i) = (\\<Prod>i\\<in>?nk. ?c p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<Prod>i\\<in>{0..<n} - {k}.\n          mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n          (i, p i)) =\n       (\\<Prod>i\\<in>{0..<n} - {k}. mat\\<^sub>r n n c $$ (i, p i))", "by (rule prod.cong, insert abc k p, auto intro!: intros)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<n} - {k}.\n     mat\\<^sub>r n n (\\<lambda>i. if i = k then ?a1 i else c i) $$\n     (i, p i)) =\n  (\\<Prod>i\\<in>{0..<n} - {k}. mat\\<^sub>r n n c $$ (i, p i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "have ab: \"?ab k \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a k + b k \\<in> carrier_vec n", "using abc"], ["proof (prove)\nusing this:\n  a k \\<in> carrier_vec n\n  b k \\<in> carrier_vec n\n  c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. a k + b k \\<in> carrier_vec n", "by (auto intro: intros)"], ["proof (state)\nthis:\n  a k + b k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "{"], ["proof (state)\nthis:\n  a k + b k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "assume \"f k \\<in> (carrier_vec n :: 'a vec set)\""], ["proof (state)\nthis:\n  f k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "hence \"mat\\<^sub>r n n (\\<lambda>i. if i = k then f i else c i) $$ (k, p k) = f k $ p k\""], ["proof (prove)\nusing this:\n  f k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat\\<^sub>r n n (\\<lambda>i. if i = k then f i else c i) $$ (k, p k) =\n    f k $ p k", "by (insert p k abc, auto)"], ["proof (state)\nthis:\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then f i else c i) $$ (k, p k) =\n  f k $ p k\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "}"], ["proof (state)\nthis:\n  ?f3 k \\<in> carrier_vec n \\<Longrightarrow>\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then ?f3 i else c i) $$ (k, p k) =\n  ?f3 k $ p k\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "note first = this"], ["proof (state)\nthis:\n  ?f3 k \\<in> carrier_vec n \\<Longrightarrow>\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then ?f3 i else c i) $$ (k, p k) =\n  ?f3 k $ p k\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "note id' = id1 id2 id3"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n      (i, p i)) =\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$ (k, p k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}.\n     mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$ (i, p i))\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n      (i, p i)) =\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$ (k, p k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}.\n     mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$ (i, p i))\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n      (i, p i)) =\n  mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n  (k, p k) *\n  (\\<Prod>i\\<in>{0..<n} - {k}.\n     mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n     (i, p i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "have dist: \"(a k + b k) $ p k = a k $ p k + b k $ p k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a k + b k) $ p k = a k $ p k + b k $ p k", "by (rule index_add_vec(1), insert p k abc, force)"], ["proof (state)\nthis:\n  (a k + b k) $ p k = a k $ p k + b k $ p k\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "show \"(\\<Prod>i\\<in>?n. ?m a c p i) + (\\<Prod>i\\<in>?n. ?m b c p i) = (\\<Prod>i\\<in>?n. ?m ?ab c p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n        (i, p i)) +\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n        (i, p i)) =\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n        (i, p i))", "unfolding id' id first[of a, OF abc(1)] first[of b, OF abc(2)] first[of ?ab, OF ab] dist"], ["proof (prove)\ngoal (1 subgoal):\n 1. a k $ p k *\n    (\\<Prod>i\\<in>{0..<n} - {k}. mat\\<^sub>r n n c $$ (i, p i)) +\n    b k $ p k *\n    (\\<Prod>i\\<in>{0..<n} - {k}. mat\\<^sub>r n n c $$ (i, p i)) =\n    (a k $ p k + b k $ p k) *\n    (\\<Prod>i\\<in>{0..<n} - {k}. mat\\<^sub>r n n c $$ (i, p i))", "by (rule distrib_right[symmetric])"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n      (i, p i)) +\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n      (i, p i)) =\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n      (i, p i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signof p *\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n      (i, p i)) +\n  signof p *\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n      (i, p i)) =\n  signof p *\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n      (i, p i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i)) +\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i))) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n         (i, p i)))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i) $$\n         (i, p i)) +\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i) $$\n         (i, p i))) =\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n         (i, p i)))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "have \"\\<dots> = ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n           (i, p i))) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i))", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n           (i, p i))) =\n    (if dim_row\n         (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n        dim_col\n         (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i))\n     then \\<Sum>p | p permutes\n                    {0..<dim_row\n                          (mat\\<^sub>r n n\n                            (\\<lambda>i.\n                                if i = k then a i + b i else c i))}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row\n                             (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k then a i + b i else c i)).\n                mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i + b i else c i) $$\n                (i, p i))\n     else (0::'a))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     signof p *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i) $$\n         (i, p i))) =\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "finally"], ["proof (chain)\npicking this:\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i)) =\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i))", "show ?thesis"], ["proof (prove)\nusing this:\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i)) =\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))", "by simp"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i + b i else c i)) =\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i else c i)) +\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then b i else c i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_linear_row_finsum:\n  assumes fS: \"finite S\" and c: \"c \\<in> {0..<n} \\<rightarrow> carrier_vec n\" and k: \"k < n\"\n  and a: \"a k \\<in> S \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda> i. if i = k then finsum_vec TYPE('a :: comm_ring_1) n (a i) S else c i)) =\n    sum (\\<lambda>j. det (mat\\<^sub>r n n (\\<lambda> i. if i = k then a  i j else c i))) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "let ?sum = \"finsum_vec TYPE('a) n\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "using a"], ["proof (prove)\nusing this:\n  a k \\<in> S \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "proof (induct rule: finite_induct[OF fS])"], ["proof (state)\ngoal (2 subgoals):\n 1. a k \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) {} else c i)) =\n    (\\<Sum>j\\<in>{}.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "case 1"], ["proof (state)\nthis:\n  a k \\<in> {} \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. a k \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) {} else c i)) =\n    (\\<Sum>j\\<in>{}.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) {} else c i)) =\n    (\\<Sum>j\\<in>{}.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "by (simp, unfold finsum_vec_empty, rule det_row_0[OF k c])"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = k then finsum_vec TYPE('a) n (a i) {} else c i)) =\n  (\\<Sum>j\\<in>{}.\n     det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "case (2 x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n  (\\<Sum>j\\<in>F.\n     det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n  a k \\<in> insert x F \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "from 2(4)"], ["proof (chain)\npicking this:\n  a k \\<in> insert x F \\<rightarrow> carrier_vec n", "have ak: \"a k \\<in> F \\<rightarrow> carrier_vec n\" and akx: \"a k x \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  a k \\<in> insert x F \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. a k \\<in> F \\<rightarrow> carrier_vec n &&& a k x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  a k \\<in> F \\<rightarrow> carrier_vec n\n  a k x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "{"], ["proof (state)\nthis:\n  a k \\<in> F \\<rightarrow> carrier_vec n\n  a k x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "note if_cong[OF refl finsum_vec_insert[OF 2(1-2)],\n        of _ \"a i\" n \"c i\" \"c i\"]"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<Longrightarrow> a i \\<in> F \\<rightarrow> carrier_vec n;\n   ?b \\<Longrightarrow> a i x \\<in> carrier_vec n;\n   \\<not> ?b \\<Longrightarrow> c i = c i\\<rbrakk>\n  \\<Longrightarrow> (if ?b then finsum_vec TYPE('a) n (a i) (insert x F)\n                     else c i) =\n                    (if ?b then a i x + finsum_vec TYPE('a) n (a i) F\n                     else c i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<Longrightarrow> a ?i3 \\<in> F \\<rightarrow> carrier_vec n;\n   ?b \\<Longrightarrow> a ?i3 x \\<in> carrier_vec n;\n   \\<not> ?b \\<Longrightarrow> c ?i3 = c ?i3\\<rbrakk>\n  \\<Longrightarrow> (if ?b then finsum_vec TYPE('a) n (a ?i3) (insert x F)\n                     else c ?i3) =\n                    (if ?b then a ?i3 x + finsum_vec TYPE('a) n (a ?i3) F\n                     else c ?i3)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<Longrightarrow> a ?i3 \\<in> F \\<rightarrow> carrier_vec n;\n   ?b \\<Longrightarrow> a ?i3 x \\<in> carrier_vec n;\n   \\<not> ?b \\<Longrightarrow> c ?i3 = c ?i3\\<rbrakk>\n  \\<Longrightarrow> (if ?b then finsum_vec TYPE('a) n (a ?i3) (insert x F)\n                     else c ?i3) =\n                    (if ?b then a ?i3 x + finsum_vec TYPE('a) n (a ?i3) F\n                     else c ?i3)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        a k \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        det (mat\\<^sub>r n n\n              (\\<lambda>i.\n                  if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n        (\\<Sum>j\\<in>F.\n           det (mat\\<^sub>r n n\n                 (\\<lambda>i. if i = k then a i j else c i)));\n        a k \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i = k\n                                   then finsum_vec TYPE('a) n (a i)\n   (insert x F)\n                                   else c i)) =\n                         (\\<Sum>j\\<in>insert x F.\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i = k then a i j else c i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) (insert x F)\n              else c i)) =\n    (\\<Sum>j\\<in>insert x F.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "proof (subst *)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i. i = k \\<Longrightarrow> a i \\<in> F \\<rightarrow> carrier_vec n\n 2. \\<And>i. i = k \\<Longrightarrow> a i x \\<in> carrier_vec n\n 3. \\<And>i. i \\<noteq> k \\<Longrightarrow> c i = c i\n 4. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then a i x + finsum_vec TYPE('a) n (a i) F\n              else c i)) =\n    (\\<Sum>j\\<in>insert x F.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "show \"det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i x + ?sum (a i) F else c i)) =\n        (\\<Sum>j\\<in>insert x F. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then a i x + finsum_vec TYPE('a) n (a i) F\n              else c i)) =\n    (\\<Sum>j\\<in>insert x F.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "proof (subst det_row_add)"], ["proof (state)\ngoal (5 subgoals):\n 1. a k x \\<in> carrier_vec n\n 2. finsum_vec TYPE('a) n (a k) F \\<in> carrier_vec n\n 3. c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n 4. k < n\n 5. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i x else c i)) +\n    det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n    (\\<Sum>j\\<in>insert x F.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "show \"det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i x else c i)) +\n          det (mat\\<^sub>r n n (\\<lambda>i. if i = k then ?sum (a i) F else c i)) =\n        (\\<Sum>j\\<in>insert x F. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i x else c i)) +\n    det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n    (\\<Sum>j\\<in>insert x F.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "unfolding 2(3)[OF ak] sum.insert[OF 2(1-2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i x else c i)) +\n    (\\<Sum>j\\<in>F.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i))) =\n    det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i x else c i)) +\n    (\\<Sum>j\\<in>F.\n       det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))", "by simp"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i x else c i)) +\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = k then finsum_vec TYPE('a) n (a i) F else c i)) =\n  (\\<Sum>j\\<in>insert x F.\n     det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n\ngoal (4 subgoals):\n 1. a k x \\<in> carrier_vec n\n 2. finsum_vec TYPE('a) n (a k) F \\<in> carrier_vec n\n 3. c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n 4. k < n", "qed (insert c k ak akx 2(1), \n        auto intro!: finsum_vec_closed)"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = k then a i x + finsum_vec TYPE('a) n (a i) F else c i)) =\n  (\\<Sum>j\\<in>insert x F.\n     det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n\ngoal (3 subgoals):\n 1. \\<And>i. i = k \\<Longrightarrow> a i \\<in> F \\<rightarrow> carrier_vec n\n 2. \\<And>i. i = k \\<Longrightarrow> a i x \\<in> carrier_vec n\n 3. \\<And>i. i \\<noteq> k \\<Longrightarrow> c i = c i", "qed (insert akx ak, force+)"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = k then finsum_vec TYPE('a) n (a i) (insert x F)\n            else c i)) =\n  (\\<Sum>j\\<in>insert x F.\n     det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = k then finsum_vec TYPE('a) n (a i) S else c i)) =\n  (\\<Sum>j\\<in>S.\n     det (mat\\<^sub>r n n (\\<lambda>i. if i = k then a i j else c i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_linear_rows_finsum_lemma:\n  assumes fS: \"finite S\"\n    and fT: \"finite T\" and c: \"c \\<in> {0..<n} \\<rightarrow> carrier_vec n\"\n    and T: \"T \\<subseteq> {0 ..< n}\"\n    and a: \"a \\<in> T \\<rightarrow> S \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then finsum_vec TYPE('a :: comm_ring_1) n (a i) S else c i)) =\n    sum (\\<lambda>f. det(mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then a i (f i) else c i)))\n      {f. (\\<forall>i \\<in> T. f i \\<in> S) \\<and> (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> T then a i (f i) else c i)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> T then a i (f i) else c i)))", "let ?sum = \"finsum_vec TYPE('a) n\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> T then a i (f i) else c i)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> T then a i (f i) else c i)))", "using fT c a T"], ["proof (prove)\nusing this:\n  finite T\n  c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n  a \\<in> T \\<rightarrow> S \\<rightarrow> carrier_vec n\n  T \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> T then a i (f i) else c i)))", "proof (induct T arbitrary: a c set: finite)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> {} \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        {} \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> {}\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>{}. f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> {} \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> {} then a i (f i) else c i)))\n 2. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "case empty"], ["proof (state)\nthis:\n  c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n  a \\<in> {} \\<rightarrow> S \\<rightarrow> carrier_vec n\n  {} \\<subseteq> {0..<n}\n\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> {} \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        {} \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> {}\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>{}. f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> {} \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> {} then a i (f i) else c i)))\n 2. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "let ?f = \"(\\<lambda> i. i) :: nat \\<Rightarrow> nat\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> {} \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        {} \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> {}\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>{}. f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> {} \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> {} then a i (f i) else c i)))\n 2. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "have [simp]: \"{f. \\<forall>i. f i = i} = {?f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. \\<forall>i. f i = i} = {\\<lambda>i. i}", "by auto"], ["proof (state)\nthis:\n  {f. \\<forall>i. f i = i} = {\\<lambda>i. i}\n\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> {} \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        {} \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> {}\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>{}. f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> {} \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> {} then a i (f i) else c i)))\n 2. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> {} then finsum_vec TYPE('a) n (a i) S else c i)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> {} then a i (f i) else c i)))", "by simp"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> {} then finsum_vec TYPE('a) n (a i) S else c i)) =\n  (\\<Sum>f | (\\<forall>i\\<in>{}. f i \\<in> S) \\<and>\n             (\\<forall>i. i \\<notin> {} \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. if i \\<in> {} then a i (f i) else c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "case (insert z T a c)"], ["proof (state)\nthis:\n  finite T\n  z \\<notin> T\n  \\<lbrakk>?c1 \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n   ?a1 \\<in> T \\<rightarrow> S \\<rightarrow> carrier_vec n;\n   T \\<subseteq> {0..<n}\\<rbrakk>\n  \\<Longrightarrow> det (mat\\<^sub>r n n\n                          (\\<lambda>i.\n                              if i \\<in> T\n                              then finsum_vec TYPE('a) n (?a1 i) S\n                              else ?c1 i)) =\n                    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                               (\\<forall>i.\n                                   i \\<notin> T \\<longrightarrow> f i = i).\n                       det (mat\\<^sub>r n n\n                             (\\<lambda>i.\n                                 if i \\<in> T then ?a1 i (f i) else ?c1 i)))\n  c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n  a \\<in> insert z T \\<rightarrow> S \\<rightarrow> carrier_vec n\n  insert z T \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "hence z: \"z < n\" and azS: \"a z \\<in> S \\<rightarrow> carrier_vec n\""], ["proof (prove)\nusing this:\n  finite T\n  z \\<notin> T\n  \\<lbrakk>?c1 \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n   ?a1 \\<in> T \\<rightarrow> S \\<rightarrow> carrier_vec n;\n   T \\<subseteq> {0..<n}\\<rbrakk>\n  \\<Longrightarrow> det (mat\\<^sub>r n n\n                          (\\<lambda>i.\n                              if i \\<in> T\n                              then finsum_vec TYPE('a) n (?a1 i) S\n                              else ?c1 i)) =\n                    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                               (\\<forall>i.\n                                   i \\<notin> T \\<longrightarrow> f i = i).\n                       det (mat\\<^sub>r n n\n                             (\\<lambda>i.\n                                 if i \\<in> T then ?a1 i (f i) else ?c1 i)))\n  c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n  a \\<in> insert z T \\<rightarrow> S \\<rightarrow> carrier_vec n\n  insert z T \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. z < n &&& a z \\<in> S \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  z < n\n  a z \\<in> S \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "let ?F = \"\\<lambda>T. {f. (\\<forall>i \\<in> T. f i \\<in> S) \\<and> (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "let ?h = \"\\<lambda>(y,g) i. if i = z then y else g i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "let ?k = \"\\<lambda>h. (h(z),(\\<lambda>i. if i = z then i else h i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "let ?s = \"\\<lambda> k a c f. det(mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then a i (f i) else c i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "let ?c = \"\\<lambda>j i. if i = z then a i j else c i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "have thif: \"\\<And>a b c d. (if a \\<or> b then c else d) = (if a then c else if b then c else d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       (if a \\<or> b then c else d) = (if a then c else if b then c else d)", "by simp"], ["proof (state)\nthis:\n  (if ?a3 \\<or> ?b3 then ?c3 else ?d3) =\n  (if ?a3 then ?c3 else if ?b3 then ?c3 else ?d3)\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "have thif2: \"\\<And>a b c d e. (if a then b else if c then d else e) =\n       (if c then (if a then b else d) else (if a then b else e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d e.\n       (if a then b else if c then d else e) =\n       (if c then if a then b else d else if a then b else e)", "by simp"], ["proof (state)\nthis:\n  (if ?a4 then ?b4 else if ?c4 then ?d4 else ?e4) =\n  (if ?c4 then if ?a4 then ?b4 else ?d4 else if ?a4 then ?b4 else ?e4)\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "from \\<open>z \\<notin> T\\<close>"], ["proof (chain)\npicking this:\n  z \\<notin> T", "have nz: \"\\<And>i. i \\<in> T \\<Longrightarrow> i = z \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  z \\<notin> T\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> T \\<Longrightarrow> (i = z) = False", "by auto"], ["proof (state)\nthis:\n  ?i5 \\<in> T \\<Longrightarrow> (?i5 = z) = False\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "from insert"], ["proof (chain)\npicking this:\n  finite T\n  z \\<notin> T\n  \\<lbrakk>?c1 \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n   ?a1 \\<in> T \\<rightarrow> S \\<rightarrow> carrier_vec n;\n   T \\<subseteq> {0..<n}\\<rbrakk>\n  \\<Longrightarrow> det (mat\\<^sub>r n n\n                          (\\<lambda>i.\n                              if i \\<in> T\n                              then finsum_vec TYPE('a) n (?a1 i) S\n                              else ?c1 i)) =\n                    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                               (\\<forall>i.\n                                   i \\<notin> T \\<longrightarrow> f i = i).\n                       det (mat\\<^sub>r n n\n                             (\\<lambda>i.\n                                 if i \\<in> T then ?a1 i (f i) else ?c1 i)))\n  c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n  a \\<in> insert z T \\<rightarrow> S \\<rightarrow> carrier_vec n\n  insert z T \\<subseteq> {0..<n}", "have c: \"\\<And> i. i < n \\<Longrightarrow> c i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  finite T\n  z \\<notin> T\n  \\<lbrakk>?c1 \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n   ?a1 \\<in> T \\<rightarrow> S \\<rightarrow> carrier_vec n;\n   T \\<subseteq> {0..<n}\\<rbrakk>\n  \\<Longrightarrow> det (mat\\<^sub>r n n\n                          (\\<lambda>i.\n                              if i \\<in> T\n                              then finsum_vec TYPE('a) n (?a1 i) S\n                              else ?c1 i)) =\n                    (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                               (\\<forall>i.\n                                   i \\<notin> T \\<longrightarrow> f i = i).\n                       det (mat\\<^sub>r n n\n                             (\\<lambda>i.\n                                 if i \\<in> T then ?a1 i (f i) else ?c1 i)))\n  c \\<in> {0..<n} \\<rightarrow> carrier_vec n\n  a \\<in> insert z T \\<rightarrow> S \\<rightarrow> carrier_vec n\n  insert z T \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> c i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i5 < n \\<Longrightarrow> c ?i5 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "have fin: \"finite {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and> (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n         (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}", "by (rule finite_bounded_functions[OF fS insert(1)])"], ["proof (state)\nthis:\n  finite\n   {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n       (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "have \"det (mat\\<^sub>r n n (\\<lambda> i. if i \\<in> insert z T then ?sum (a i) S else c i)) =\n      det (mat\\<^sub>r n n (\\<lambda> i. if i = z then ?sum (a i) S else if i \\<in> T then ?sum (a i) S else c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n              else c i)) =\n    det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = z then finsum_vec TYPE('a) n (a i) S\n              else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                   else c i))", "unfolding insert_iff thif"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = z then finsum_vec TYPE('a) n (a i) S\n              else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                   else c i)) =\n    det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = z then finsum_vec TYPE('a) n (a i) S\n              else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                   else c i))", ".."], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n            else c i)) =\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = z then finsum_vec TYPE('a) n (a i) S\n            else if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i))\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "also"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n            else c i)) =\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = z then finsum_vec TYPE('a) n (a i) S\n            else if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i))\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "have \"\\<dots> = (\\<Sum>j\\<in>S. det (mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then ?sum (a i) S else if i = z then a i j else c i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i = z then finsum_vec TYPE('a) n (a i) S\n              else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                   else c i)) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i)))", "apply (subst det_linear_row_finsum[OF fS _ z])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>i. if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)\n    \\<in> {0..<n} \\<rightarrow> carrier_vec n\n 2. a z \\<in> S \\<rightarrow> carrier_vec n\n 3. (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i = z then a i j\n                 else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                      else c i))) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i)))", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i = z then a i j\n                 else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                      else c i))) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i)))\n 2. (\\<lambda>i. if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)\n    \\<in> {0..<n} \\<rightarrow> carrier_vec n\n 3. a z \\<in> S \\<rightarrow> carrier_vec n", "apply (subst thif2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T\n                 then if i = z then a i j else finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i))) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i)))\n 2. (\\<lambda>i. if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)\n    \\<in> {0..<n} \\<rightarrow> carrier_vec n\n 3. a z \\<in> S \\<rightarrow> carrier_vec n", "using nz"], ["proof (prove)\nusing this:\n  ?i5 \\<in> T \\<Longrightarrow> (?i5 = z) = False\n\ngoal (3 subgoals):\n 1. (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T\n                 then if i = z then a i j else finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i))) =\n    (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i)))\n 2. (\\<lambda>i. if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)\n    \\<in> {0..<n} \\<rightarrow> carrier_vec n\n 3. a z \\<in> S \\<rightarrow> carrier_vec n", "apply (simp cong del: if_weak_cong cong add: if_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>i. if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)\n    \\<in> {0..<n} \\<rightarrow> carrier_vec n\n 2. a z \\<in> S \\<rightarrow> carrier_vec n", "apply (insert azS c fS insert(5), (force intro!: finsum_vec_closed)+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = z then finsum_vec TYPE('a) n (a i) S\n            else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else c i)) =\n  (\\<Sum>j\\<in>S.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i.\n               if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n               else if i = z then a i j else c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "also"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i = z then finsum_vec TYPE('a) n (a i) S\n            else if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else c i)) =\n  (\\<Sum>j\\<in>S.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i.\n               if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n               else if i = z then a i j else c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "have \"\\<dots> = (sum (\\<lambda> (j, f). det (mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then a i (f i)\n      else if i = z then a i j\n      else c i))) (S \\<times> ?F T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i))) =\n    (\\<Sum>(j, f)\n           \\<in>S \\<times>\n                {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                    (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then a i (f i)\n                 else if i = z then a i j else c i)))", "unfolding sum.cartesian_product[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>S.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n                 else if i = z then a i j else c i))) =\n    (\\<Sum>x\\<in>S.\n       \\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                 (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i).\n         det (mat\\<^sub>r n n\n               (\\<lambda>i.\n                   if i \\<in> T then a i (f i)\n                   else if i = z then a i x else c i)))", "by (rule sum.cong[OF refl], subst insert.hyps(3), \n        insert azS c fin z insert(5-6), auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>S.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i.\n               if i \\<in> T then finsum_vec TYPE('a) n (a i) S\n               else if i = z then a i j else c i))) =\n  (\\<Sum>(j, f)\n         \\<in>S \\<times>\n              {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                  (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i.\n               if i \\<in> T then a i (f i)\n               else if i = z then a i j else c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "finally"], ["proof (chain)\npicking this:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n            else c i)) =\n  (\\<Sum>(j, f)\n         \\<in>S \\<times>\n              {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                  (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i.\n               if i \\<in> T then a i (f i)\n               else if i = z then a i j else c i)))", "have tha:\n      \"det (mat\\<^sub>r n n (\\<lambda> i. if i \\<in> insert z T then ?sum (a i) S else c i)) =\n       (sum (\\<lambda> (j, f). det (mat\\<^sub>r n n (\\<lambda> i. if i \\<in> T then a i (f i)\n          else if i = z then a i j\n          else c i))) (S \\<times> ?F T))\""], ["proof (prove)\nusing this:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n            else c i)) =\n  (\\<Sum>(j, f)\n         \\<in>S \\<times>\n              {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                  (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i.\n               if i \\<in> T then a i (f i)\n               else if i = z then a i j else c i)))\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n              else c i)) =\n    (\\<Sum>(j, f)\n           \\<in>S \\<times>\n                {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                    (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then a i (f i)\n                 else if i = z then a i j else c i)))", "."], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n            else c i)) =\n  (\\<Sum>(j, f)\n         \\<in>S \\<times>\n              {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                  (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i.\n               if i \\<in> T then a i (f i)\n               else if i = z then a i j else c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x F a c.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>a c.\n           \\<lbrakk>c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n            a \\<in> F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n            F \\<subseteq> {0..<n}\\<rbrakk>\n           \\<Longrightarrow> det (mat\\<^sub>r n n\n                                   (\\<lambda>i.\n if i \\<in> F then finsum_vec TYPE('a) n (a i) S else c i)) =\n                             (\\<Sum>f | (\\<forall>i\\<in>F.\n      f i \\<in> S) \\<and>\n  (\\<forall>i. i \\<notin> F \\<longrightarrow> f i = i).\n                                det (mat\\<^sub>r n n\n(\\<lambda>i. if i \\<in> F then a i (f i) else c i)));\n        c \\<in> {0..<n} \\<rightarrow> carrier_vec n;\n        a \\<in> insert x F \\<rightarrow> S \\<rightarrow> carrier_vec n;\n        insert x F \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> det (mat\\<^sub>r n n\n                               (\\<lambda>i.\n                                   if i \\<in> insert x F\n                                   then finsum_vec TYPE('a) n (a i) S\n                                   else c i)) =\n                         (\\<Sum>f | (\\<forall>i\\<in>insert x F.\n  f i \\<in> S) \\<and>\n                                    (\\<forall>i.\n  i \\<notin> insert x F \\<longrightarrow> f i = i).\n                            det (mat\\<^sub>r n n\n                                  (\\<lambda>i.\nif i \\<in> insert x F then a i (f i) else c i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n              else c i)) =\n    (\\<Sum>f | (\\<forall>i\\<in>insert z T. f i \\<in> S) \\<and>\n               (\\<forall>i.\n                   i \\<notin> insert z T \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> insert z T then a i (f i) else c i)))", "unfolding tha"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(j, f)\n           \\<in>S \\<times>\n                {f. (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n                    (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i)}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i.\n                 if i \\<in> T then a i (f i)\n                 else if i = z then a i j else c i))) =\n    (\\<Sum>f | (\\<forall>i\\<in>insert z T. f i \\<in> S) \\<and>\n               (\\<forall>i.\n                   i \\<notin> insert z T \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. if i \\<in> insert z T then a i (f i) else c i)))", "by (rule sum.reindex_bij_witness[where i=\"?k\" and j=\"?h\"], insert \\<open>z \\<notin> T\\<close>\n      azS c fS insert(5-6) z fin, \n      auto intro!: arg_cong[of _ _ det])"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> insert z T then finsum_vec TYPE('a) n (a i) S\n            else c i)) =\n  (\\<Sum>f | (\\<forall>i\\<in>insert z T. f i \\<in> S) \\<and>\n             (\\<forall>i. i \\<notin> insert z T \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. if i \\<in> insert z T then a i (f i) else c i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i.\n            if i \\<in> T then finsum_vec TYPE('a) n (a i) S else c i)) =\n  (\\<Sum>f | (\\<forall>i\\<in>T. f i \\<in> S) \\<and>\n             (\\<forall>i. i \\<notin> T \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. if i \\<in> T then a i (f i) else c i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_linear_rows_sum:\n  assumes fS: \"finite S\"\n  and a: \"a \\<in> {0..<n} \\<rightarrow> S \\<rightarrow> carrier_vec n\"\n  shows \"det (mat\\<^sub>r n n (\\<lambda> i. finsum_vec TYPE('a :: comm_ring_1) n (a i) S)) =\n    sum (\\<lambda>f. det (mat\\<^sub>r n n (\\<lambda> i. a i (f i)))) \n    {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and> (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))", "let ?T = \"{0..<n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))", "have fT: \"finite ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<n}", "by auto"], ["proof (state)\nthis:\n  finite {0..<n}\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))", "have th0: \"\\<And>x y. mat\\<^sub>r n n (\\<lambda> i. if i \\<in> ?T then x i else y i) = mat\\<^sub>r n n (\\<lambda> i. x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       mat\\<^sub>r n n (\\<lambda>i. if i \\<in> {0..<n} then x i else y i) =\n       mat\\<^sub>r n n x", "by (rule eq_rowI, auto)"], ["proof (state)\nthis:\n  mat\\<^sub>r n n (\\<lambda>i. if i \\<in> {0..<n} then ?x i else ?y i) =\n  mat\\<^sub>r n n ?x\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))", "have c: \"(\\<lambda> _. 0\\<^sub>v n) \\<in> ?T \\<rightarrow> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. 0\\<^sub>v n) \\<in> {0..<n} \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>_. 0\\<^sub>v n) \\<in> {0..<n} \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))", "by (rule det_linear_rows_finsum_lemma[OF fS fT c subset_refl a, unfolded th0])"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n (\\<lambda>i. finsum_vec TYPE('a) n (a i) S)) =\n  (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> S) \\<and>\n             (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n (\\<lambda>i. a i (f i))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_rows_mul:\n  assumes a: \"a \\<in> {0..<n} \\<rightarrow> carrier_vec n\"\n  shows \"det(mat\\<^sub>r n n (\\<lambda> i. c i \\<cdot>\\<^sub>v a i)) =\n    prod c {0..<n} * det(mat\\<^sub>r n n (\\<lambda> i. a i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)) =\n    prod c {0..<n} * det (mat\\<^sub>r n n a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)) =\n    prod c {0..<n} * det (mat\\<^sub>r n n a)", "have A: \"mat\\<^sub>r n n (\\<lambda> i. c i \\<cdot>\\<^sub>v a i) \\<in> carrier_mat n n\" \n  and A': \"mat\\<^sub>r n n (\\<lambda> i. a i) \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)\n    \\<in> carrier_mat n n &&&\n    mat\\<^sub>r n n a \\<in> carrier_mat n n", "using a"], ["proof (prove)\nusing this:\n  a \\<in> {0..<n} \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)\n    \\<in> carrier_mat n n &&&\n    mat\\<^sub>r n n a \\<in> carrier_mat n n", "unfolding carrier_mat_def"], ["proof (prove)\nusing this:\n  a \\<in> {0..<n} \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)\n    \\<in> {m. dim_row m = n \\<and> dim_col m = n} &&&\n    mat\\<^sub>r n n a \\<in> {m. dim_row m = n \\<and> dim_col m = n}", "by auto"], ["proof (state)\nthis:\n  mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)\n  \\<in> carrier_mat n n\n  mat\\<^sub>r n n a \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)) =\n    prod c {0..<n} * det (mat\\<^sub>r n n a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)) =\n    prod c {0..<n} * det (mat\\<^sub>r n n a)", "unfolding det_def'[OF A] det_def'[OF A']"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       signof p *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n           (i, p i))) =\n    prod c {0..<n} *\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. mat\\<^sub>r n n a $$ (i, p i)))", "proof (rule trans[OF sum.cong sum_distrib_left[symmetric]])"], ["proof (state)\ngoal (2 subgoals):\n 1. {p. p permutes {0..<n}} = {p. p permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n           (i, x i)) =\n       prod c {0..<n} *\n       (signof x * (\\<Prod>i = 0..<n. mat\\<^sub>r n n a $$ (i, x i)))", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. {p. p permutes {0..<n}} = {p. p permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n           (i, x i)) =\n       prod c {0..<n} *\n       (signof x * (\\<Prod>i = 0..<n. mat\\<^sub>r n n a $$ (i, x i)))", "assume p: \"p \\<in> {p. p permutes {0..<n}}\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (2 subgoals):\n 1. {p. p permutes {0..<n}} = {p. p permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n           (i, x i)) =\n       prod c {0..<n} *\n       (signof x * (\\<Prod>i = 0..<n. mat\\<^sub>r n n a $$ (i, x i)))", "have id: \"(\\<Prod>ia\\<in>{0..<n}. mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$ (ia, p ia))\n      = prod c {0..<n} * (\\<Prod>ia\\<in>{0..<n}. mat\\<^sub>r n n a $$ (ia, p ia))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n        (ia, p ia)) =\n    prod c {0..<n} * (\\<Prod>ia = 0..<n. mat\\<^sub>r n n a $$ (ia, p ia))", "unfolding prod.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n        (ia, p ia)) =\n    (\\<Prod>x = 0..<n. c x * mat\\<^sub>r n n a $$ (x, p x))", "by (rule prod.cong, insert p a, force+)"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$ (ia, p ia)) =\n  prod c {0..<n} * (\\<Prod>ia = 0..<n. mat\\<^sub>r n n a $$ (ia, p ia))\n\ngoal (2 subgoals):\n 1. {p. p permutes {0..<n}} = {p. p permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n           (i, x i)) =\n       prod c {0..<n} *\n       (signof x * (\\<Prod>i = 0..<n. mat\\<^sub>r n n a $$ (i, x i)))", "show \"signof p * (\\<Prod>ia\\<in>{0..<n}. mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$ (ia, p ia)) =\n           prod c {0..<n} * (signof p * (\\<Prod>ia\\<in>{0..<n}. mat\\<^sub>r n n a $$ (ia, p ia)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p *\n    (\\<Prod>ia = 0..<n.\n        mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$\n        (ia, p ia)) =\n    prod c {0..<n} *\n    (signof p * (\\<Prod>ia = 0..<n. mat\\<^sub>r n n a $$ (ia, p ia)))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p *\n    (prod c {0..<n} *\n     (\\<Prod>ia = 0..<n. mat\\<^sub>r n n a $$ (ia, p ia))) =\n    prod c {0..<n} *\n    (signof p * (\\<Prod>ia = 0..<n. mat\\<^sub>r n n a $$ (ia, p ia)))", "by auto"], ["proof (state)\nthis:\n  signof p *\n  (\\<Prod>ia = 0..<n.\n      mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i) $$ (ia, p ia)) =\n  prod c {0..<n} *\n  (signof p * (\\<Prod>ia = 0..<n. mat\\<^sub>r n n a $$ (ia, p ia)))\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n}} = {p. p permutes {0..<n}}", "qed simp"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n (\\<lambda>i. c i \\<cdot>\\<^sub>v a i)) =\n  prod c {0..<n} * det (mat\\<^sub>r n n a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mul_finsum_alt:\n  assumes A: \"A \\<in> carrier_mat nr n\" and B: \"B \\<in> carrier_mat n nc\"\n  shows \"A * B = mat\\<^sub>r nr nc (\\<lambda> i. finsum_vec TYPE('a :: semiring_0) nc (\\<lambda>k. A $$ (i,k) \\<cdot>\\<^sub>v row B k) {0 ..< n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B =\n    mat\\<^sub>r nr nc\n     (\\<lambda>i.\n         finsum_vec TYPE('a) nc\n          (\\<lambda>k. A $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<n})", "by (rule eq_matI, insert A B, auto, subst index_finsum_vec, auto simp: scalar_prod_def intro: sum.cong)"], ["", "lemma det_mult:\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"det (A * B) = det A * det (B :: 'a :: comm_ring_1 mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?U = \"{0 ..< n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?F = \"{f. (\\<forall>i\\<in> ?U. f i \\<in> ?U) \\<and> (\\<forall>i. i \\<notin> ?U \\<longrightarrow> f i = i)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?PU = \"{p. p permutes ?U}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have fU: \"finite ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<n}", "by blast"], ["proof (state)\nthis:\n  finite {0..<n}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have fF: \"finite ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n         (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}", "by (rule finite_bounded_functions, auto)"], ["proof (state)\nthis:\n  finite\n   {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n       (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "{"], ["proof (state)\nthis:\n  finite\n   {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n       (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "assume p: \"p permutes ?U\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"p \\<in> ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}", "unfolding mem_Collect_eq permutes_in_image[OF p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{0..<n}. i \\<in> {0..<n}) \\<and>\n    (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> p i = i)", "using p[unfolded permutes_def]"], ["proof (prove)\nusing this:\n  (\\<forall>x. x \\<notin> {0..<n} \\<longrightarrow> p x = x) \\<and>\n  (\\<forall>y. \\<exists>!x. p x = y)\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{0..<n}. i \\<in> {0..<n}) \\<and>\n    (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> p i = i)", "by simp"], ["proof (state)\nthis:\n  p \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "}"], ["proof (state)\nthis:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  ?p2\n  \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n            (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "then"], ["proof (chain)\npicking this:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  ?p2\n  \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n            (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}", "have PUF: \"?PU \\<subseteq> ?F\""], ["proof (prove)\nusing this:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  ?p2\n  \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n            (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n}}\n    \\<subseteq> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                    (\\<forall>i.\n                        i \\<notin> {0..<n} \\<longrightarrow> f i = i)}", "by blast"], ["proof (state)\nthis:\n  {p. p permutes {0..<n}}\n  \\<subseteq> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                  (\\<forall>i.\n                      i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "{"], ["proof (state)\nthis:\n  {p. p permutes {0..<n}}\n  \\<subseteq> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                  (\\<forall>i.\n                      i \\<notin> {0..<n} \\<longrightarrow> f i = i)}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "assume fPU: \"f \\<in> ?F - ?PU\""], ["proof (state)\nthis:\n  f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n          {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have fUU: \"f ` ?U \\<subseteq> ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {0..<n} \\<subseteq> {0..<n}", "using fPU"], ["proof (prove)\nusing this:\n  f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n          {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. f ` {0..<n} \\<subseteq> {0..<n}", "by auto"], ["proof (state)\nthis:\n  f ` {0..<n} \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "from fPU"], ["proof (chain)\npicking this:\n  f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n          {p. p permutes {0..<n}}", "have f: \"\\<forall>i \\<in> ?U. f i \\<in> ?U\" \"\\<forall>i. i \\<notin> ?U \\<longrightarrow> f i = i\" \"\\<not>(\\<forall>y. \\<exists>!x. f x = y)\""], ["proof (prove)\nusing this:\n  f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n          {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n} &&&\n    \\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i &&&\n    \\<not> (\\<forall>y. \\<exists>!x. f x = y)", "unfolding permutes_def"], ["proof (prove)\nusing this:\n  f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n          {p. (\\<forall>x.\n                  x \\<notin> {0..<n} \\<longrightarrow> p x = x) \\<and>\n              (\\<forall>y. \\<exists>!x. p x = y)}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n} &&&\n    \\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i &&&\n    \\<not> (\\<forall>y. \\<exists>!x. f x = y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}\n  \\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i\n  \\<not> (\\<forall>y. \\<exists>!x. f x = y)\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?A = \"mat\\<^sub>r n n (\\<lambda> i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?B = \"mat\\<^sub>r n n (\\<lambda> i. row B (f i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have B': \"?B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat\\<^sub>r n n (\\<lambda>i. row B (f i)) \\<in> carrier_mat n n", "by (intro mat_row_carrierI)"], ["proof (state)\nthis:\n  mat\\<^sub>r n n (\\<lambda>i. row B (f i)) \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "{"], ["proof (state)\nthis:\n  mat\\<^sub>r n n (\\<lambda>i. row B (f i)) \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "assume fi: \"inj_on f ?U\""], ["proof (state)\nthis:\n  inj_on f {0..<n}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "from inj_on_nat_permutes[OF fi] f"], ["proof (chain)\npicking this:\n  \\<lbrakk>f \\<in> {0..<n} \\<rightarrow> {0..<n}; finite {0..<n};\n   \\<And>i. i \\<notin> {0..<n} \\<Longrightarrow> f i = i\\<rbrakk>\n  \\<Longrightarrow> f permutes {0..<n}\n  \\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}\n  \\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i\n  \\<not> (\\<forall>y. \\<exists>!x. f x = y)", "have \"f permutes ?U\""], ["proof (prove)\nusing this:\n  \\<lbrakk>f \\<in> {0..<n} \\<rightarrow> {0..<n}; finite {0..<n};\n   \\<And>i. i \\<notin> {0..<n} \\<Longrightarrow> f i = i\\<rbrakk>\n  \\<Longrightarrow> f permutes {0..<n}\n  \\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}\n  \\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i\n  \\<not> (\\<forall>y. \\<exists>!x. f x = y)\n\ngoal (1 subgoal):\n 1. f permutes {0..<n}", "by auto"], ["proof (state)\nthis:\n  f permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "with fPU"], ["proof (chain)\npicking this:\n  f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n          {p. p permutes {0..<n}}\n  f permutes {0..<n}", "have False"], ["proof (prove)\nusing this:\n  f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n              (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n          {p. p permutes {0..<n}}\n  f permutes {0..<n}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "}"], ["proof (state)\nthis:\n  inj_on f {0..<n} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "hence fni: \"\\<not> inj_on f ?U\""], ["proof (prove)\nusing this:\n  inj_on f {0..<n} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> inj_on f {0..<n}", "by auto"], ["proof (state)\nthis:\n  \\<not> inj_on f {0..<n}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "then"], ["proof (chain)\npicking this:\n  \\<not> inj_on f {0..<n}", "obtain i j where ij: \"f i = f j\" \"i \\<noteq> j\" \"i < n\" \"j < n\""], ["proof (prove)\nusing this:\n  \\<not> inj_on f {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>f i = f j; i \\<noteq> j; i < n; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>{0..<n}.\n             \\<forall>y\\<in>{0..<n}. f x = f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>f i = f j; i \\<noteq> j; i < n; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f i = f j\n  i \\<noteq> j\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "from ij"], ["proof (chain)\npicking this:\n  f i = f j\n  i \\<noteq> j\n  i < n\n  j < n", "have rth: \"row ?B i = row ?B j\""], ["proof (prove)\nusing this:\n  f i = f j\n  i \\<noteq> j\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. row (mat\\<^sub>r n n (\\<lambda>i. row B (f i))) i =\n    row (mat\\<^sub>r n n (\\<lambda>i. row B (f i))) j", "by auto"], ["proof (state)\nthis:\n  row (mat\\<^sub>r n n (\\<lambda>i. row B (f i))) i =\n  row (mat\\<^sub>r n n (\\<lambda>i. row B (f i))) j\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"det ?A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))) =\n    (0::'a)", "by (subst det_rows_mul, unfold det_identical_rows[OF B' ij(2-4) rth], insert f A B, auto)"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "}"], ["proof (state)\nthis:\n  ?f2\n  \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n            (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n        {p. p permutes {0..<n}} \\<Longrightarrow>\n  det (mat\\<^sub>r n n\n        (\\<lambda>i. A $$ (i, ?f2 i) \\<cdot>\\<^sub>v row B (?f2 i))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "then"], ["proof (chain)\npicking this:\n  ?f2\n  \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n            (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n        {p. p permutes {0..<n}} \\<Longrightarrow>\n  det (mat\\<^sub>r n n\n        (\\<lambda>i. A $$ (i, ?f2 i) \\<cdot>\\<^sub>v row B (?f2 i))) =\n  (0::'a)", "have zth: \"\\<And> f. f \\<in> ?F - ?PU \\<Longrightarrow> det (mat\\<^sub>r n n (\\<lambda> i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))) = 0\""], ["proof (prove)\nusing this:\n  ?f2\n  \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n            (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n        {p. p permutes {0..<n}} \\<Longrightarrow>\n  det (mat\\<^sub>r n n\n        (\\<lambda>i. A $$ (i, ?f2 i) \\<cdot>\\<^sub>v row B (?f2 i))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}} \\<Longrightarrow>\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))) =\n       (0::'a)", "by simp"], ["proof (state)\nthis:\n  ?f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n           {p. p permutes {0..<n}} \\<Longrightarrow>\n  det (mat\\<^sub>r n n\n        (\\<lambda>i. A $$ (i, ?f i) \\<cdot>\\<^sub>v row B (?f i))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "{"], ["proof (state)\nthis:\n  ?f \\<in> {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n           {p. p permutes {0..<n}} \\<Longrightarrow>\n  det (mat\\<^sub>r n n\n        (\\<lambda>i. A $$ (i, ?f i) \\<cdot>\\<^sub>v row B (?f i))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "assume pU: \"p \\<in> ?PU\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "from pU"], ["proof (chain)\npicking this:\n  p \\<in> {p. p permutes {0..<n}}", "have p: \"p permutes ?U\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. p permutes {0..<n}", "by blast"], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?s = \"\\<lambda>p. (signof p) :: 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?f = \"\\<lambda>q. ?s p * (\\<Prod> i\\<in> ?U. A $$ (i,p i)) * (?s q * (\\<Prod>i\\<in> ?U. B $$ (i, q i)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"(sum (\\<lambda>q. ?s q *\n        (\\<Prod>i\\<in> ?U. mat\\<^sub>r n n (\\<lambda> i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$ (i, q i))) ?PU) =\n      (sum (\\<lambda>q. ?s p * (\\<Prod> i\\<in> ?U. A $$ (i,p i)) * (?s q * (\\<Prod> i\\<in> ?U. B $$ (i, q i)))) ?PU)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, q i))) =\n    (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof q * (\\<Prod>i = 0..<n. B $$ (i, q i))))", "unfolding sum_permutations_compose_right[OF permutes_inv[OF p], of ?f]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, q i))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (p \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (p \\<circ> inv p) i))))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "assume \"q \\<in> {q. q permutes ?U}\""], ["proof (state)\nthis:\n  q \\<in> {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "hence q: \"q permutes ?U\""], ["proof (prove)\nusing this:\n  q \\<in> {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. q permutes {0..<n}", "by simp"], ["proof (state)\nthis:\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "from p q"], ["proof (chain)\npicking this:\n  p permutes {0..<n}\n  q permutes {0..<n}", "have pp: \"permutation p\" and pq: \"permutation q\""], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. permutation p &&& permutation q", "unfolding permutation_permutes"], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> p permutes S &&&\n    \\<exists>S. finite S \\<and> q permutes S", "by auto"], ["proof (state)\nthis:\n  permutation p\n  permutation q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "note sign = signof_compose[OF q permutes_inv[OF p], unfolded signof_inv[OF fU p]]"], ["proof (state)\nthis:\n  signof (q \\<circ> inv p) = signof q * signof p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "let ?inv = \"Hilbert_Choice.inv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "have th001: \"prod (\\<lambda>i. B$$ (i, q (?inv p i))) ?U = prod ((\\<lambda>i. B$$ (i, q (?inv p i))) \\<circ> p) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. B $$ (i, q (inv p i))) =\n    prod ((\\<lambda>i. B $$ (i, q (inv p i))) \\<circ> p) {0..<n}", "by (rule prod.permute[OF p])"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. B $$ (i, q (inv p i))) =\n  prod ((\\<lambda>i. B $$ (i, q (inv p i))) \\<circ> p) {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "have thp: \"prod (\\<lambda>i. mat\\<^sub>r n n (\\<lambda> i. A$$(i,p i) \\<cdot>\\<^sub>v row B (p i)) $$ (i, q i)) ?U =\n        prod (\\<lambda>i. A$$(i,p i)) ?U * prod (\\<lambda>i. B$$ (i, q (?inv p i))) ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n\n         (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n        (i, q i)) =\n    (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n    (\\<Prod>i = 0..<n. B $$ (i, q (inv p i)))", "unfolding th001 o_def permutes_inverses[OF p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n\n         (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n        (i, q i)) =\n    (\\<Prod>i = 0..<n. A $$ (i, p i)) * (\\<Prod>x = 0..<n. B $$ (p x, q x))", "by (subst prod.distrib[symmetric], insert A p q B, auto intro: prod.cong)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n\n       (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n      (i, q i)) =\n  (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n  (\\<Prod>i = 0..<n. B $$ (i, q (inv p i)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "define AA where \"AA = (\\<Prod>i\\<in>?U. A $$ (i, p i))\""], ["proof (state)\nthis:\n  AA = (\\<Prod>i = 0..<n. A $$ (i, p i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "define BB where \"BB = (\\<Prod>ia\\<in>{0..<n}. B $$ (ia, q (?inv p ia)))\""], ["proof (state)\nthis:\n  BB = (\\<Prod>ia = 0..<n. B $$ (ia, q (inv p ia)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "have \"?s q * (\\<Prod>ia\\<in>{0..<n}. mat\\<^sub>r n n (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$ (ia, q ia)) =\n         ?s p * (\\<Prod>i\\<in>{0..<n}. A $$ (i, p i)) * (?s (q \\<circ> ?inv p) * (\\<Prod>ia\\<in>{0..<n}. B $$ (ia, q (?inv p ia))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof q *\n    (\\<Prod>ia = 0..<n.\n        mat\\<^sub>r n n\n         (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n        (ia, q ia)) =\n    signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n    (signof (q \\<circ> inv p) *\n     (\\<Prod>ia = 0..<n. B $$ (ia, q (inv p ia))))", "unfolding sign thp"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof q *\n    ((\\<Prod>i = 0..<n. A $$ (i, p i)) *\n     (\\<Prod>i = 0..<n. B $$ (i, q (inv p i)))) =\n    signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n    (signof q * signof p * (\\<Prod>ia = 0..<n. B $$ (ia, q (inv p ia))))", "unfolding AA_def[symmetric] BB_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof q * (AA * BB) = signof p * AA * (signof q * signof p * BB)", "by (simp add: ac_simps signof_def)"], ["proof (state)\nthis:\n  signof q *\n  (\\<Prod>ia = 0..<n.\n      mat\\<^sub>r n n\n       (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n      (ia, q ia)) =\n  signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n  (signof (q \\<circ> inv p) * (\\<Prod>ia = 0..<n. B $$ (ia, q (inv p ia))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       signof x *\n       (\\<Prod>i = 0..<n.\n           mat\\<^sub>r n n\n            (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n           (i, x i)) =\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n       (signof (x \\<circ> inv p) *\n        (\\<Prod>i = 0..<n. B $$ (i, (x \\<circ> inv p) i)))", "thus \"?s q * (\\<Prod>i = 0..<n. mat\\<^sub>r n n (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$ (i, q i)) =\n         ?s p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n         (?s (q \\<circ> ?inv p) * (\\<Prod>i = 0..<n. B $$ (i, (q \\<circ> ?inv p) i)))\""], ["proof (prove)\nusing this:\n  signof q *\n  (\\<Prod>ia = 0..<n.\n      mat\\<^sub>r n n\n       (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n      (ia, q ia)) =\n  signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n  (signof (q \\<circ> inv p) * (\\<Prod>ia = 0..<n. B $$ (ia, q (inv p ia))))\n\ngoal (1 subgoal):\n 1. signof q *\n    (\\<Prod>i = 0..<n.\n        mat\\<^sub>r n n\n         (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n        (i, q i)) =\n    signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n    (signof (q \\<circ> inv p) *\n     (\\<Prod>i = 0..<n. B $$ (i, (q \\<circ> inv p) i)))", "by simp"], ["proof (state)\nthis:\n  signof q *\n  (\\<Prod>i = 0..<n.\n      mat\\<^sub>r n n\n       (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n      (i, q i)) =\n  signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n  (signof (q \\<circ> inv p) *\n   (\\<Prod>i = 0..<n. B $$ (i, (q \\<circ> inv p) i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n\n          (\\<lambda>i. A $$ (i, p i) \\<cdot>\\<^sub>v row B (p i)) $$\n         (i, q i))) =\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)) *\n     (signof q * (\\<Prod>i = 0..<n. B $$ (i, q i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "}"], ["proof (state)\nthis:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n\n          (\\<lambda>i. A $$ (i, ?p2 i) \\<cdot>\\<^sub>v row B (?p2 i)) $$\n         (i, q i))) =\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof ?p2 * (\\<Prod>i = 0..<n. A $$ (i, ?p2 i)) *\n     (signof q * (\\<Prod>i = 0..<n. B $$ (i, q i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "note * = this"], ["proof (state)\nthis:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q *\n     (\\<Prod>i = 0..<n.\n         mat\\<^sub>r n n\n          (\\<lambda>i. A $$ (i, ?p2 i) \\<cdot>\\<^sub>v row B (?p2 i)) $$\n         (i, q i))) =\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof ?p2 * (\\<Prod>i = 0..<n. A $$ (i, ?p2 i)) *\n     (signof q * (\\<Prod>i = 0..<n. B $$ (i, q i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have th2: \"sum (\\<lambda>f. det (mat\\<^sub>r n n (\\<lambda> i. A$$(i,f i) \\<cdot>\\<^sub>v row B (f i)))) ?PU = det A * det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>{p. p permutes {0..<n}}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n    det A * det B", "unfolding det_def'[OF A] det_def'[OF B] det_def'[OF mat_row_carrierI]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>{p. p permutes {0..<n}}.\n       \\<Sum>p | p permutes {0..<n}.\n         signof p *\n         (\\<Prod>i = 0..<n.\n             mat\\<^sub>r n n\n              (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)) $$\n             (i, p i))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i))) *\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. B $$ (i, p i)))", "unfolding sum_product dim_row_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>{p. p permutes {0..<n}}.\n       \\<Sum>p | p permutes {0..<n}.\n         signof p *\n         (\\<Prod>i = 0..<n.\n             mat\\<^sub>r n n\n              (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)) $$\n             (i, p i))) =\n    (\\<Sum>i\\<in>{p. p permutes {0..<n}}.\n       \\<Sum>j\\<in>{p. p permutes {0..<n}}.\n         signof i * (\\<Prod>ia = 0..<n. A $$ (ia, i ia)) *\n         (signof j * (\\<Prod>i = 0..<n. B $$ (i, j i))))", "by (rule sum.cong, insert A, force, subst *, insert A B, auto)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>{p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  det A * det B\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "let ?f = \"\\<lambda> f. det (mat\\<^sub>r n n (\\<lambda> i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"det (A * B) = sum ?f ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (A * B) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))", "unfolding mat_mul_finsum_alt[OF A B]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i.\n              finsum_vec TYPE('a) n\n               (\\<lambda>k. A $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<n})) =\n    (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))", "by (rule det_linear_rows_sum[OF fU], insert A B, auto)"], ["proof (state)\nthis:\n  det (A * B) =\n  (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n             (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "also"], ["proof (state)\nthis:\n  det (A * B) =\n  (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n             (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"\\<dots> = sum ?f ((?F - ?PU) \\<union> (?F \\<inter> ?PU))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n               (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n    (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                     (\\<forall>i.\n                         i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n                 {p. p permutes {0..<n}} \\<union>\n                 {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                     (\\<forall>i.\n                         i \\<notin> {0..<n} \\<longrightarrow>\n                         f i = i)} \\<inter>\n                 {p. p permutes {0..<n}}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))", "by (rule arg_cong[where f = \"sum ?f\"], auto)"], ["proof (state)\nthis:\n  (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n             (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}} \\<union>\n               {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow>\n                       f i = i)} \\<inter>\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "also"], ["proof (state)\nthis:\n  (\\<Sum>f | (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n             (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i).\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}} \\<union>\n               {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow>\n                       f i = i)} \\<inter>\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"\\<dots> = sum ?f (?F - ?PU) + sum ?f (?F \\<inter> ?PU)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                     (\\<forall>i.\n                         i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n                 {p. p permutes {0..<n}} \\<union>\n                 {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                     (\\<forall>i.\n                         i \\<notin> {0..<n} \\<longrightarrow>\n                         f i = i)} \\<inter>\n                 {p. p permutes {0..<n}}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n    (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                     (\\<forall>i.\n                         i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n                 {p. p permutes {0..<n}}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) +\n    (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                     (\\<forall>i.\n                         i \\<notin> {0..<n} \\<longrightarrow>\n                         f i = i)} \\<inter>\n                 {p. p permutes {0..<n}}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))", "by (rule sum.union_disjoint, insert A B finite_bounded_functions[OF fU fU], auto)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}} \\<union>\n               {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow>\n                       f i = i)} \\<inter>\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) +\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow>\n                       f i = i)} \\<inter>\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}} \\<union>\n               {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow>\n                       f i = i)} \\<inter>\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) +\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow>\n                       f i = i)} \\<inter>\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i))))\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"sum ?f (?F - ?PU) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                     (\\<forall>i.\n                         i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n                 {p. p permutes {0..<n}}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n    (0::'a)", "by (rule sum.neutral, insert zth, auto)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>{f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n                   (\\<forall>i.\n                       i \\<notin> {0..<n} \\<longrightarrow> f i = i)} -\n               {p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"?F \\<inter> ?PU = ?PU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n        (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} \\<inter>\n    {p. p permutes {0..<n}} =\n    {p. p permutes {0..<n}}", "unfolding permutes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n        (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} \\<inter>\n    {p. (\\<forall>x. x \\<notin> {0..<n} \\<longrightarrow> p x = x) \\<and>\n        (\\<forall>y. \\<exists>!x. p x = y)} =\n    {p. (\\<forall>x. x \\<notin> {0..<n} \\<longrightarrow> p x = x) \\<and>\n        (\\<forall>y. \\<exists>!x. p x = y)}", "by fastforce"], ["proof (state)\nthis:\n  {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n      (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} \\<inter>\n  {p. p permutes {0..<n}} =\n  {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "also"], ["proof (state)\nthis:\n  {f. (\\<forall>i\\<in>{0..<n}. f i \\<in> {0..<n}) \\<and>\n      (\\<forall>i. i \\<notin> {0..<n} \\<longrightarrow> f i = i)} \\<inter>\n  {p. p permutes {0..<n}} =\n  {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "have \"sum ?f ?PU = det A * det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>{p. p permutes {0..<n}}.\n       det (mat\\<^sub>r n n\n             (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n    det A * det B", "unfolding th2"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A * det B = det A * det B", ".."], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>{p. p permutes {0..<n}}.\n     det (mat\\<^sub>r n n\n           (\\<lambda>i. A $$ (i, f i) \\<cdot>\\<^sub>v row B (f i)))) =\n  det A * det B\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "finally"], ["proof (chain)\npicking this:\n  det (A * B) = (0::'a) + det A * det B", "show ?thesis"], ["proof (prove)\nusing this:\n  det (A * B) = (0::'a) + det A * det B\n\ngoal (1 subgoal):\n 1. det (A * B) = det A * det B", "by simp"], ["proof (state)\nthis:\n  det (A * B) = det A * det B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unit_imp_det_non_zero: assumes \"A \\<in> Units (ring_mat TYPE('a :: comm_ring_1) n b)\"\n   shows \"det A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a)", "from assms[unfolded Units_def ring_mat_def]"], ["proof (chain)\npicking this:\n  A \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, monoid.mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                       \\<dots> = b\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat n n,\n                              monoid.mult = (*), one = 1\\<^sub>m n,\n                              zero = 0\\<^sub>m n n, add = (+),\n                              \\<dots> = b\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}", "obtain B where A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\" and BA: \"B * A = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  A \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, monoid.mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                       \\<dots> = b\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat n n,\n                              monoid.mult = (*), one = 1\\<^sub>m n,\n                              zero = 0\\<^sub>m n n, add = (+),\n                              \\<dots> = b\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n         B * A = 1\\<^sub>m n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  B * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a)", "from arg_cong[OF BA, of det, unfolded det_mult[OF B A] det_one]"], ["proof (chain)\npicking this:\n  det B * det A = (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det B * det A = (1::'a)\n\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  det A \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following proof is based on the Gauss-Jordan algorithm.\\<close>"], ["", "lemma det_non_zero_imp_unit: assumes A: \"A \\<in> carrier_mat n n\"\n  and dA: \"det A \\<noteq> (0 :: 'a :: field)\"\n  shows \"A \\<in> Units (ring_mat TYPE('a) n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "let ?g = \"gauss_jordan A (0\\<^sub>m n 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "let ?B = \"fst ?g\""], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "obtain B C where B: \"?g = (B,C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B C.\n        gauss_jordan A (0\\<^sub>m n 0) = (B, C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?g)"], ["proof (state)\nthis:\n  gauss_jordan A (0\\<^sub>m n 0) = (B, C)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  A \\<notin> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "from this[unfolded gauss_jordan_check_invertable[OF A zero_carrier_mat[of n 0]] B]"], ["proof (chain)\npicking this:\n  fst (B, C) \\<noteq> 1\\<^sub>m n", "have \"B \\<noteq> 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  fst (B, C) \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B \\<noteq> 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  B \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "with row_echelon_form_imp_1_or_0_row[OF gauss_jordan_carrier(1)[OF A _ B] gauss_jordan_row_echelon[OF A B], of 0]"], ["proof (chain)\npicking this:\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  B = 1\\<^sub>m n \\<or> 0 < n \\<and> row B (n - 1) = 0\\<^sub>v n\n  B \\<noteq> 1\\<^sub>m n", "have n: \"0 < n\" and row: \"row B (n - 1) = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  B = 1\\<^sub>m n \\<or> 0 < n \\<and> row B (n - 1) = 0\\<^sub>v n\n  B \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. 0 < n &&& row B (n - 1) = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  0 < n\n  row B (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "let ?n = \"n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "from n"], ["proof (chain)\npicking this:\n  0 < n", "have n1: \"?n < n\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n - 1 < n", "by auto"], ["proof (state)\nthis:\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "from gauss_jordan_transform[OF A _ B, of 0 b]"], ["proof (chain)\npicking this:\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b).\n     B = P * A \\<and> C = P * 0\\<^sub>m n 0", "obtain P\n    where P: \"P\\<in>Units (ring_mat TYPE('a) n b)\" and PA: \"B = P * A\""], ["proof (prove)\nusing this:\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b).\n     B = P * A \\<and> C = P * 0\\<^sub>m n 0\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n b); B = P * A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  B = P * A\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "from unit_imp_det_non_zero[OF P]"], ["proof (chain)\npicking this:\n  det P \\<noteq> (0::'a)", "have dP: \"det P \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det P \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. det P \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  det P \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "from P"], ["proof (chain)\npicking this:\n  P \\<in> Units (ring_mat TYPE('a) n b)", "have P: \"P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, monoid.mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                       \\<dots> = b\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat n n,\n                              monoid.mult = (*), one = 1\\<^sub>m n,\n                              zero = 0\\<^sub>m n n, add = (+),\n                              \\<dots> = b\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "from det_mult[OF P A] dP dA"], ["proof (chain)\npicking this:\n  det (P * A) = det P * det A\n  det P \\<noteq> (0::'a)\n  det A \\<noteq> (0::'a)", "have \"det B \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det (P * A) = det P * det A\n  det P \\<noteq> (0::'a)\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. det B \\<noteq> (0::'a)", "unfolding PA"], ["proof (prove)\nusing this:\n  det (P * A) = det P * det A\n  det P \\<noteq> (0::'a)\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. det (P * A) \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  det B \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  det B \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "have \"det B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det B = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det B = (0::'a)", "from gauss_jordan_carrier[OF A _ B, of 0]"], ["proof (chain)\npicking this:\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  B \\<in> carrier_mat n n\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  C \\<in> carrier_mat n 0", "have B: \"B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  B \\<in> carrier_mat n n\n  0\\<^sub>m n 0 \\<in> carrier_mat n 0 \\<Longrightarrow>\n  C \\<in> carrier_mat n 0\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "{"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. det B = (0::'a)", "assume j: \"j < n\""], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "from index_row(1)[symmetric, of ?n B j, unfolded row] B"], ["proof (chain)\npicking this:\n  \\<lbrakk>n - 1 < dim_row B; j < dim_col B\\<rbrakk>\n  \\<Longrightarrow> B $$ (n - 1, j) = 0\\<^sub>v n $ j\n  B \\<in> carrier_mat n n", "have \"B $$ (?n, j) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n - 1 < dim_row B; j < dim_col B\\<rbrakk>\n  \\<Longrightarrow> B $$ (n - 1, j) = 0\\<^sub>v n $ j\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B $$ (n - 1, j) = (0::'a)", "using B n j"], ["proof (prove)\nusing this:\n  \\<lbrakk>n - 1 < dim_row B; j < dim_col B\\<rbrakk>\n  \\<Longrightarrow> B $$ (n - 1, j) = 0\\<^sub>v n $ j\n  B \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  0 < n\n  j < n\n\ngoal (1 subgoal):\n 1. B $$ (n - 1, j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  B $$ (n - 1, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "}"], ["proof (state)\nthis:\n  ?j2 < n \\<Longrightarrow> B $$ (n - 1, ?j2) = (0::'a)\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "hence \"B = mat\\<^sub>r n n (\\<lambda>i. if i = ?n then 0\\<^sub>v n else row B i)\""], ["proof (prove)\nusing this:\n  ?j2 < n \\<Longrightarrow> B $$ (n - 1, ?j2) = (0::'a)\n\ngoal (1 subgoal):\n 1. B =\n    mat\\<^sub>r n n (\\<lambda>i. if i = n - 1 then 0\\<^sub>v n else row B i)", "by (intro eq_matI, insert B, auto)"], ["proof (state)\nthis:\n  B =\n  mat\\<^sub>r n n (\\<lambda>i. if i = n - 1 then 0\\<^sub>v n else row B i)\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "also"], ["proof (state)\nthis:\n  B =\n  mat\\<^sub>r n n (\\<lambda>i. if i = n - 1 then 0\\<^sub>v n else row B i)\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "have \"det \\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat\\<^sub>r n n\n          (\\<lambda>i. if i = n - 1 then 0\\<^sub>v n else row B i)) =\n    (0::'a)", "by (rule det_row_0[OF n1], insert B, auto)"], ["proof (state)\nthis:\n  det (mat\\<^sub>r n n\n        (\\<lambda>i. if i = n - 1 then 0\\<^sub>v n else row B i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  det B = (0::'a)", "show \"det B = 0\""], ["proof (prove)\nusing this:\n  det B = (0::'a)\n\ngoal (1 subgoal):\n 1. det B = (0::'a)", "."], ["proof (state)\nthis:\n  det B = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det B = (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<noteq> (0::'a)", "show False"], ["proof (prove)\nusing this:\n  (0::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mult_left_right_inverse: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" \n  and B: \"B \\<in> carrier_mat n n\" and AB: \"A * B = 1\\<^sub>m n\"\n  shows \"B * A = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "let ?R = \"ring_mat TYPE('a) n undefined\""], ["proof (state)\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "from det_mult[OF A B, unfolded AB]"], ["proof (chain)\npicking this:\n  det (1\\<^sub>m n) = det A * det B", "have \"det A \\<noteq> 0\" \"det B \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det (1\\<^sub>m n) = det A * det B\n\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a) &&& det B \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  det A \\<noteq> (0::'a)\n  det B \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "from det_non_zero_imp_unit[OF A this(1)] det_non_zero_imp_unit[OF B this(2)]"], ["proof (chain)\npicking this:\n  A \\<in> Units (ring_mat TYPE('a) n ?b)\n  B \\<in> Units (ring_mat TYPE('a) n ?b)", "have U: \"A \\<in> Units ?R\" \"B \\<in> Units ?R\""], ["proof (prove)\nusing this:\n  A \\<in> Units (ring_mat TYPE('a) n ?b)\n  B \\<in> Units (ring_mat TYPE('a) n ?b)\n\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) n undefined) &&&\n    B \\<in> Units (ring_mat TYPE('a) n undefined)", "."], ["proof (state)\nthis:\n  A \\<in> Units (ring_mat TYPE('a) n undefined)\n  B \\<in> Units (ring_mat TYPE('a) n undefined)\n\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "interpret ring ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) n undefined)", "by (rule ring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "from Units_inv_comm[unfolded ring_mat_simps, OF AB U]"], ["proof (chain)\npicking this:\n  B * A = 1\\<^sub>m n", "show ?thesis"], ["proof (prove)\nusing this:\n  B * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "."], ["proof (state)\nthis:\n  B * A = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_zero_imp_zero_row: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  and det: \"det A = 0\"\n  shows \"\\<exists> P. P \\<in> Units (ring_mat TYPE('a) n b) \\<and> row (P * A) (n - 1) = 0\\<^sub>v n \\<and> 0 < n\n    \\<and> row_echelon_form (P * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "let ?R = \"ring_mat TYPE('a) n b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "let ?U = \"Units ?R\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "interpret m: ring ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) n b)", "by (rule ring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "let ?g = \"gauss_jordan A A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "obtain A' B' where g: \"?g = (A', B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        gauss_jordan A A = (A', B') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?g)"], ["proof (state)\nthis:\n  gauss_jordan A A = (A', B')\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "from det unit_imp_det_non_zero[of A n b]"], ["proof (chain)\npicking this:\n  det A = (0::'a)\n  A \\<in> Units (ring_mat TYPE('a) n b) \\<Longrightarrow>\n  det A \\<noteq> (0::'a)", "have AU: \"A \\<notin> ?U\""], ["proof (prove)\nusing this:\n  det A = (0::'a)\n  A \\<in> Units (ring_mat TYPE('a) n b) \\<Longrightarrow>\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b)", "by auto"], ["proof (state)\nthis:\n  A \\<notin> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "with gauss_jordan_inverse_one_direction(1)[OF A A, of _ b]"], ["proof (chain)\npicking this:\n  gauss_jordan A A = (1\\<^sub>m n, ?B') \\<Longrightarrow>\n  A \\<in> Units (ring_mat TYPE('a) n b)\n  A \\<notin> Units (ring_mat TYPE('a) n b)", "have A'1: \"A' \\<noteq> 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  gauss_jordan A A = (1\\<^sub>m n, ?B') \\<Longrightarrow>\n  A \\<in> Units (ring_mat TYPE('a) n b)\n  A \\<notin> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. A' \\<noteq> 1\\<^sub>m n", "using g"], ["proof (prove)\nusing this:\n  gauss_jordan A A = (1\\<^sub>m n, ?B') \\<Longrightarrow>\n  A \\<in> Units (ring_mat TYPE('a) n b)\n  A \\<notin> Units (ring_mat TYPE('a) n b)\n  gauss_jordan A A = (A', B')\n\ngoal (1 subgoal):\n 1. A' \\<noteq> 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  A' \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "from gauss_jordan_carrier(1)[OF A A g]"], ["proof (chain)\npicking this:\n  A' \\<in> carrier_mat n n", "have A': \"A' \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "from gauss_jordan_row_echelon[OF A g]"], ["proof (chain)\npicking this:\n  row_echelon_form A'", "have re: \"row_echelon_form A'\""], ["proof (prove)\nusing this:\n  row_echelon_form A'\n\ngoal (1 subgoal):\n 1. row_echelon_form A'", "."], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "from row_echelon_form_imp_1_or_0_row[OF A' this] A'1"], ["proof (chain)\npicking this:\n  A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\n  A' \\<noteq> 1\\<^sub>m n", "have n: \"0 < n\" and row: \"row A' (n - 1) = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\n  A' \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. 0 < n &&& row A' (n - 1) = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  0 < n\n  row A' (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "from gauss_jordan_transform[OF A A g, of b]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b). A' = P * A \\<and> B' = P * A", "obtain P\n    where P: \"P \\<in> ?U\" and A': \"A' = P * A\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b). A' = P * A \\<and> B' = P * A\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n b); A' = P * A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  A' = P * A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  A' = P * A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "using n row re"], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  A' = P * A\n  0 < n\n  row A' (n - 1) = 0\\<^sub>v n\n  row_echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n       row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n       0 < n \\<and> row_echelon_form (P * A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>P.\n     P \\<in> Units (ring_mat TYPE('a) n b) \\<and>\n     row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n     0 < n \\<and> row_echelon_form (P * A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_0_iff_vec_prod_zero_field: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"det A = 0 \\<longleftrightarrow> (\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\" (is \"?l = (\\<exists> v. ?P v)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "let ?R = \"ring_mat TYPE('a) n ()\""], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "let ?U = \"Units ?R\""], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "interpret m: ring ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) n ())", "by (rule ring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "proof (cases \"det A = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "case False"], ["proof (state)\nthis:\n  det A \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "from det_non_zero_imp_unit[OF A this, of \"()\"]"], ["proof (chain)\npicking this:\n  A \\<in> Units (ring_mat TYPE('a) n ())", "have \"A \\<in> ?U\""], ["proof (prove)\nusing this:\n  A \\<in> Units (ring_mat TYPE('a) n ())\n\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) n ())", "."], ["proof (state)\nthis:\n  A \\<in> Units (ring_mat TYPE('a) n ())\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "then"], ["proof (chain)\npicking this:\n  A \\<in> Units (ring_mat TYPE('a) n ())", "obtain B where unit: \"B * A = 1\\<^sub>m n\" and B: \"B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> Units (ring_mat TYPE('a) n ())\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B * A = 1\\<^sub>m n; B \\<in> carrier_mat n n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  A \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, monoid.mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                       add = (+)\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat n n,\n                              monoid.mult = (*), one = 1\\<^sub>m n,\n                              zero = 0\\<^sub>m n n, add = (+)\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B * A = 1\\<^sub>m n; B \\<in> carrier_mat n n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B * A = 1\\<^sub>m n\n  B \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "{"], ["proof (state)\nthis:\n  B * A = 1\\<^sub>m n\n  B \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "assume \"?P v\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n \\<and>\n  v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "hence v: \"v \\<in> carrier_vec n\" \"v \\<noteq> 0\\<^sub>v n\" \"A *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n \\<and>\n  v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&&\n    v \\<noteq> 0\\<^sub>v n &&& A *\\<^sub>v v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"v = (B * A) *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = B * A *\\<^sub>v v", "using v B"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = 0\\<^sub>v n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v = B * A *\\<^sub>v v", "unfolding unit"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = 0\\<^sub>v n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v = 1\\<^sub>m n *\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  v = B * A *\\<^sub>v v\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  v = B * A *\\<^sub>v v\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> = B *\\<^sub>v (A *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * A *\\<^sub>v v = B *\\<^sub>v (A *\\<^sub>v v)", "using B A v"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. B * A *\\<^sub>v v = B *\\<^sub>v (A *\\<^sub>v v)", "by simp"], ["proof (state)\nthis:\n  B * A *\\<^sub>v v = B *\\<^sub>v (A *\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  B * A *\\<^sub>v v = B *\\<^sub>v (A *\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> = B *\\<^sub>v 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>v (A *\\<^sub>v v) = B *\\<^sub>v 0\\<^sub>v n", "unfolding v"], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>v 0\\<^sub>v n = B *\\<^sub>v 0\\<^sub>v n", ".."], ["proof (state)\nthis:\n  B *\\<^sub>v (A *\\<^sub>v v) = B *\\<^sub>v 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  B *\\<^sub>v (A *\\<^sub>v v) = B *\\<^sub>v 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>v 0\\<^sub>v n = 0\\<^sub>v n", "using B"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B *\\<^sub>v 0\\<^sub>v n = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  B *\\<^sub>v 0\\<^sub>v n = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "finally"], ["proof (chain)\npicking this:\n  v = 0\\<^sub>v n", "have False"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "using v"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<and>\n  ?v2 \\<noteq> 0\\<^sub>v n \\<and>\n  A *\\<^sub>v ?v2 = 0\\<^sub>v n \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "with False"], ["proof (chain)\npicking this:\n  det A \\<noteq> (0::'a)\n  ?v2 \\<in> carrier_vec n \\<and>\n  ?v2 \\<noteq> 0\\<^sub>v n \\<and>\n  A *\\<^sub>v ?v2 = 0\\<^sub>v n \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  det A \\<noteq> (0::'a)\n  ?v2 \\<in> carrier_vec n \\<and>\n  ?v2 \\<noteq> 0\\<^sub>v n \\<and>\n  A *\\<^sub>v ?v2 = 0\\<^sub>v n \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "by blast"], ["proof (state)\nthis:\n  (det A = (0::'a)) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "case True"], ["proof (state)\nthis:\n  det A = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "let ?n = \"n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "from det_zero_imp_zero_row[OF A True, of \"()\"]"], ["proof (chain)\npicking this:\n  \\<exists>P.\n     P \\<in> Units (ring_mat TYPE('a) n ()) \\<and>\n     row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n     0 < n \\<and> row_echelon_form (P * A)", "obtain P where PU: \"P \\<in> ?U\" and row: \"row (P * A) ?n = 0\\<^sub>v n\" and n: \"0 < n\" \"?n < n\"\n      and re: \"row_echelon_form (P * A)\""], ["proof (prove)\nusing this:\n  \\<exists>P.\n     P \\<in> Units (ring_mat TYPE('a) n ()) \\<and>\n     row (P * A) (n - 1) = 0\\<^sub>v n \\<and>\n     0 < n \\<and> row_echelon_form (P * A)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n ());\n         row (P * A) (n - 1) = 0\\<^sub>v n; 0 < n; n - 1 < n;\n         row_echelon_form (P * A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) n ())\n  row (P * A) (n - 1) = 0\\<^sub>v n\n  0 < n\n  n - 1 < n\n  row_echelon_form (P * A)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "define PA where \"PA = P * A\""], ["proof (state)\nthis:\n  PA = P * A\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "note row = row[folded PA_def]"], ["proof (state)\nthis:\n  row PA (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "note re = re[folded PA_def]"], ["proof (state)\nthis:\n  row_echelon_form PA\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "from PU"], ["proof (chain)\npicking this:\n  P \\<in> Units (ring_mat TYPE('a) n ())", "obtain Q where P: \"P \\<in> carrier_mat n n\" and Q: \"Q \\<in> carrier_mat n n\"\n      and unit: \"Q * P = 1\\<^sub>m n\" \"P * Q =  1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n ())\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>P \\<in> carrier_mat n n; Q \\<in> carrier_mat n n;\n         Q * P = 1\\<^sub>m n; P * Q = 1\\<^sub>m n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, monoid.mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                       add = (+)\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat n n,\n                              monoid.mult = (*), one = 1\\<^sub>m n,\n                              zero = 0\\<^sub>m n n, add = (+)\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, monoid.mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+)\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>P \\<in> carrier_mat n n; Q \\<in> carrier_mat n n;\n         Q * P = 1\\<^sub>m n; P * Q = 1\\<^sub>m n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  Q * P = 1\\<^sub>m n\n  P * Q = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "from P A"], ["proof (chain)\npicking this:\n  P \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n", "have PA: \"PA \\<in> carrier_mat n n\" and dimPA: \"dim_row PA = n\""], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. PA \\<in> carrier_mat n n &&& dim_row PA = n", "unfolding PA_def"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * A \\<in> carrier_mat n n &&& dim_row (P * A) = n", "by auto"], ["proof (state)\nthis:\n  PA \\<in> carrier_mat n n\n  dim_row PA = n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "from re[unfolded row_echelon_form_def]"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun PA f (dim_col PA)", "obtain p where p: \"pivot_fun PA p n\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun PA f (dim_col PA)\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun PA p n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using PA"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun PA f (dim_col PA)\n  PA \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun PA p n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pivot_fun PA p n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "note piv = pivot_positions[OF PA p]"], ["proof (state)\nthis:\n  set (pivot_positions PA) = {(i, p i) |i. i < n \\<and> p i \\<noteq> n}\n  distinct (map fst (pivot_positions PA))\n  distinct (map snd (pivot_positions PA))\n  length (pivot_positions PA) =\n  card {i. i < n \\<and> row PA i \\<noteq> 0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "note pivot = pivot_funD[OF dimPA p n(2)]"], ["proof (state)\nthis:\n  p (n - 1) \\<le> n\n  ?j < p (n - 1) \\<Longrightarrow> PA $$ (n - 1, ?j) = (0::'a)\n  Suc (n - 1) < n \\<Longrightarrow>\n  p (n - 1) < p (Suc (n - 1)) \\<or> p (Suc (n - 1)) = n\n  p (n - 1) < n \\<Longrightarrow> PA $$ (n - 1, p (n - 1)) = (1::'a)\n  \\<lbrakk>p (n - 1) < n; ?i' < n; ?i' \\<noteq> n - 1\\<rbrakk>\n  \\<Longrightarrow> PA $$ (?i', p (n - 1)) = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "{"], ["proof (state)\nthis:\n  p (n - 1) \\<le> n\n  ?j < p (n - 1) \\<Longrightarrow> PA $$ (n - 1, ?j) = (0::'a)\n  Suc (n - 1) < n \\<Longrightarrow>\n  p (n - 1) < p (Suc (n - 1)) \\<or> p (Suc (n - 1)) = n\n  p (n - 1) < n \\<Longrightarrow> PA $$ (n - 1, p (n - 1)) = (1::'a)\n  \\<lbrakk>p (n - 1) < n; ?i' < n; ?i' \\<noteq> n - 1\\<rbrakk>\n  \\<Longrightarrow> PA $$ (?i', p (n - 1)) = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "assume \"p ?n < n\""], ["proof (state)\nthis:\n  p (n - 1) < n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "with pivot(4)[OF this] n arg_cong[OF row, of \"\\<lambda> v. v $ p ?n\"]"], ["proof (chain)\npicking this:\n  PA $$ (n - 1, p (n - 1)) = (1::'a)\n  0 < n\n  n - 1 < n\n  row PA (n - 1) $ p (n - 1) = 0\\<^sub>v n $ p (n - 1)\n  p (n - 1) < n", "have False"], ["proof (prove)\nusing this:\n  PA $$ (n - 1, p (n - 1)) = (1::'a)\n  0 < n\n  n - 1 < n\n  row PA (n - 1) $ p (n - 1) = 0\\<^sub>v n $ p (n - 1)\n  p (n - 1) < n\n\ngoal (1 subgoal):\n 1. False", "using PA"], ["proof (prove)\nusing this:\n  PA $$ (n - 1, p (n - 1)) = (1::'a)\n  0 < n\n  n - 1 < n\n  row PA (n - 1) $ p (n - 1) = 0\\<^sub>v n $ p (n - 1)\n  p (n - 1) < n\n  PA \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "}"], ["proof (state)\nthis:\n  p (n - 1) < n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "with pivot(1)"], ["proof (chain)\npicking this:\n  p (n - 1) \\<le> n\n  p (n - 1) < n \\<Longrightarrow> False", "have pn: \"p ?n = n\""], ["proof (prove)\nusing this:\n  p (n - 1) \\<le> n\n  p (n - 1) < n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. p (n - 1) = n", "by fastforce"], ["proof (state)\nthis:\n  p (n - 1) = n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "with piv(1)"], ["proof (chain)\npicking this:\n  set (pivot_positions PA) = {(i, p i) |i. i < n \\<and> p i \\<noteq> n}\n  p (n - 1) = n", "have \"set (pivot_positions PA) \\<subseteq>  {(i, p i) |i. i < n \\<and> p i \\<noteq> n} - {(?n,p ?n)}\""], ["proof (prove)\nusing this:\n  set (pivot_positions PA) = {(i, p i) |i. i < n \\<and> p i \\<noteq> n}\n  p (n - 1) = n\n\ngoal (1 subgoal):\n 1. set (pivot_positions PA)\n    \\<subseteq> {(i, p i) |i. i < n \\<and> p i \\<noteq> n} -\n                {(n - 1, p (n - 1))}", "by auto"], ["proof (state)\nthis:\n  set (pivot_positions PA)\n  \\<subseteq> {(i, p i) |i. i < n \\<and> p i \\<noteq> n} -\n              {(n - 1, p (n - 1))}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  set (pivot_positions PA)\n  \\<subseteq> {(i, p i) |i. i < n \\<and> p i \\<noteq> n} -\n              {(n - 1, p (n - 1))}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> \\<subseteq> {(i, p i) | i. i < ?n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, p i) |i. i < n \\<and> p i \\<noteq> n} - {(n - 1, p (n - 1))}\n    \\<subseteq> {(i, p i) |i. i < n - 1}", "using n"], ["proof (prove)\nusing this:\n  0 < n\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. {(i, p i) |i. i < n \\<and> p i \\<noteq> n} - {(n - 1, p (n - 1))}\n    \\<subseteq> {(i, p i) |i. i < n - 1}", "by force"], ["proof (state)\nthis:\n  {(i, p i) |i. i < n \\<and> p i \\<noteq> n} - {(n - 1, p (n - 1))}\n  \\<subseteq> {(i, p i) |i. i < n - 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "finally"], ["proof (chain)\npicking this:\n  set (pivot_positions PA) \\<subseteq> {(i, p i) |i. i < n - 1}", "have \"card (set (pivot_positions PA)) \\<le> card {(i, p i) | i. i < ?n}\""], ["proof (prove)\nusing this:\n  set (pivot_positions PA) \\<subseteq> {(i, p i) |i. i < n - 1}\n\ngoal (1 subgoal):\n 1. card (set (pivot_positions PA)) \\<le> card {(i, p i) |i. i < n - 1}", "by (intro card_mono, auto)"], ["proof (state)\nthis:\n  card (set (pivot_positions PA)) \\<le> card {(i, p i) |i. i < n - 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  card (set (pivot_positions PA)) \\<le> card {(i, p i) |i. i < n - 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"{(i, p i) | i. i < ?n} = (\\<lambda> i. (i, p i)) ` {0 ..< ?n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, p i) |i. i < n - 1} = (\\<lambda>i. (i, p i)) ` {0..<n - 1}", "by auto"], ["proof (state)\nthis:\n  {(i, p i) |i. i < n - 1} = (\\<lambda>i. (i, p i)) ` {0..<n - 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  {(i, p i) |i. i < n - 1} = (\\<lambda>i. (i, p i)) ` {0..<n - 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"card \\<dots> = card {0 ..< ?n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>i. (i, p i)) ` {0..<n - 1}) = card {0..<n - 1}", "by (rule card_image, auto simp: inj_on_def)"], ["proof (state)\nthis:\n  card ((\\<lambda>i. (i, p i)) ` {0..<n - 1}) = card {0..<n - 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  card ((\\<lambda>i. (i, p i)) ` {0..<n - 1}) = card {0..<n - 1}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n - 1} < n", "using n"], ["proof (prove)\nusing this:\n  0 < n\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. card {0..<n - 1} < n", "by simp"], ["proof (state)\nthis:\n  card {0..<n - 1} < n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "finally"], ["proof (chain)\npicking this:\n  card (set (pivot_positions PA)) < n", "have \"card (set (pivot_positions PA)) < n\""], ["proof (prove)\nusing this:\n  card (set (pivot_positions PA)) < n\n\ngoal (1 subgoal):\n 1. card (set (pivot_positions PA)) < n", "."], ["proof (state)\nthis:\n  card (set (pivot_positions PA)) < n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "hence \"card (snd ` (set (pivot_positions PA))) < n\""], ["proof (prove)\nusing this:\n  card (set (pivot_positions PA)) < n\n\ngoal (1 subgoal):\n 1. card (snd ` set (pivot_positions PA)) < n", "using card_image_le[OF finite_set, of snd \"pivot_positions PA\"]"], ["proof (prove)\nusing this:\n  card (set (pivot_positions PA)) < n\n  card (snd ` set (pivot_positions PA))\n  \\<le> card (set (pivot_positions PA))\n\ngoal (1 subgoal):\n 1. card (snd ` set (pivot_positions PA)) < n", "by auto"], ["proof (state)\nthis:\n  card (snd ` set (pivot_positions PA)) < n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "hence neq: \"snd ` (set (pivot_positions PA)) \\<noteq> {0 ..< n}\""], ["proof (prove)\nusing this:\n  card (snd ` set (pivot_positions PA)) < n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions PA) \\<noteq> {0..<n}", "by auto"], ["proof (state)\nthis:\n  snd ` set (pivot_positions PA) \\<noteq> {0..<n}\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "from find_base_vector[OF re PA neq]"], ["proof (chain)\npicking this:\n  find_base_vector PA \\<in> carrier_vec n\n  find_base_vector PA \\<noteq> 0\\<^sub>v n\n  PA *\\<^sub>v find_base_vector PA = 0\\<^sub>v n", "obtain v where v: \"v \\<in> carrier_vec n\"\n      and v0: \"v \\<noteq> 0\\<^sub>v n\" and pav: \"PA *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  find_base_vector PA \\<in> carrier_vec n\n  find_base_vector PA \\<noteq> 0\\<^sub>v n\n  PA *\\<^sub>v find_base_vector PA = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec n; v \\<noteq> 0\\<^sub>v n;\n         PA *\\<^sub>v v = 0\\<^sub>v n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  PA *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"A *\\<^sub>v v = Q * P *\\<^sub>v (A *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = Q * P *\\<^sub>v (A *\\<^sub>v v)", "unfolding unit"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = 1\\<^sub>m n *\\<^sub>v (A *\\<^sub>v v)", "using A v"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = 1\\<^sub>m n *\\<^sub>v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v = Q * P *\\<^sub>v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  A *\\<^sub>v v = Q * P *\\<^sub>v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> = Q *\\<^sub>v (PA *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q * P *\\<^sub>v (A *\\<^sub>v v) = Q *\\<^sub>v (PA *\\<^sub>v v)", "unfolding PA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q * P *\\<^sub>v (A *\\<^sub>v v) = Q *\\<^sub>v (P * A *\\<^sub>v v)", "using Q P A v"], ["proof (prove)\nusing this:\n  Q \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. Q * P *\\<^sub>v (A *\\<^sub>v v) = Q *\\<^sub>v (P * A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  Q * P *\\<^sub>v (A *\\<^sub>v v) = Q *\\<^sub>v (PA *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  Q * P *\\<^sub>v (A *\\<^sub>v v) = Q *\\<^sub>v (PA *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"PA *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PA *\\<^sub>v v = 0\\<^sub>v n", "unfolding pav"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n = 0\\<^sub>v n", ".."], ["proof (state)\nthis:\n  PA *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  PA *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"Q *\\<^sub>v 0\\<^sub>v n = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q *\\<^sub>v 0\\<^sub>v n = 0\\<^sub>v n", "using Q"], ["proof (prove)\nusing this:\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. Q *\\<^sub>v 0\\<^sub>v n = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  Q *\\<^sub>v 0\\<^sub>v n = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "finally"], ["proof (chain)\npicking this:\n  A *\\<^sub>v v = 0\\<^sub>v n", "have Av: \"A *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det A = (0::'a) \\<Longrightarrow>\n    (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "using Av v0 v"], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = 0\\<^sub>v n\n  v \\<noteq> 0\\<^sub>v n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. ((0::'a) = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "by auto"], ["proof (state)\nthis:\n  (det A = (0::'a)) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (det A = (0::'a)) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In order to get the result for integral domains, we embed the domain in its\n  fraction field, and then apply the result for fields.\\<close>"], ["", "lemma det_0_iff_vec_prod_zero: assumes A: \"(A :: 'a :: idom mat) \\<in> carrier_mat n n\"\n  shows \"det A = 0 \\<longleftrightarrow> (\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "let ?h = \"to_fract :: 'a \\<Rightarrow> 'a fract\""], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "let ?A = \"map_mat ?h A\""], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have A': \"?A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat to_fract A \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. map_mat to_fract A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  map_mat to_fract A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "interpret inj_comm_ring_hom ?h"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_ring_hom to_fract", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"(det A = 0) = (?h (det A) = ?h 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) = (to_fract (det A) = to_fract (0::'a))", "by auto"], ["proof (state)\nthis:\n  (det A = (0::'a)) = (to_fract (det A) = to_fract (0::'a))\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  (det A = (0::'a)) = (to_fract (det A) = to_fract (0::'a))\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> = (det ?A = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_fract (det A) = to_fract (0::'a)) = (det (mat_hom A) = 0)", "unfolding hom_zero hom_det"], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_fract (det A) = 0) = (to_fract (det A) = 0)", ".."], ["proof (state)\nthis:\n  (to_fract (det A) = to_fract (0::'a)) = (det (mat_hom A) = 0)\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  (to_fract (det A) = to_fract (0::'a)) = (det (mat_hom A) = 0)\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> = ((\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> ?A *\\<^sub>v v = 0\\<^sub>v n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det (mat_hom A) = 0) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n)", "unfolding det_0_iff_vec_prod_zero_field[OF A']"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n)", ".."], ["proof (state)\nthis:\n  (det (mat_hom A) = 0) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  (det (mat_hom A) = 0) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "have \"\\<dots> = ((\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n 2. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n", "assume ?r"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n 2. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "obtain v where v: \"v \\<in> carrier_vec n\" \"v \\<noteq> 0\\<^sub>v n\" \"A *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec n; v \\<noteq> 0\\<^sub>v n;\n         A *\\<^sub>v v = 0\\<^sub>v n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n 2. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n", "by (rule exI[of _ \"map_vec ?h v\"], insert v, auto simp: mult_mat_vec_hom[symmetric, OF A v(1)])"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "assume ?l"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n", "obtain v where v: \"v \\<in> carrier_vec n\" and v0: \"v \\<noteq> 0\\<^sub>v n\" and Av: \"?A *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec n; v \\<noteq> 0\\<^sub>v n;\n         mat_hom A *\\<^sub>v v = 0\\<^sub>v n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  mat_hom A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "have \"\\<forall> i. \\<exists> a b. v $ i = Fraction_Field.Fract a b \\<and> b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>a b.\n          v $ i = Fraction_Field.Fract a b \\<and> b \\<noteq> (0::'a)", "using Fract_cases[of \"v $ i\" for i]"], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>v $ ?i3 = Fraction_Field.Fract a b;\n       b \\<noteq> (0::'a)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>a b.\n          v $ i = Fraction_Field.Fract a b \\<and> b \\<noteq> (0::'a)", "by metis"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>a b.\n        v $ i = Fraction_Field.Fract a b \\<and> b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        \\<exists>b.\n           v $ x = Fraction_Field.Fract (f x) b \\<and> b \\<noteq> (0::'a)", "obtain a where \"\\<forall> i. \\<exists> b. v $ i = Fraction_Field.Fract (a i) b \\<and> b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        \\<exists>b.\n           v $ x = Fraction_Field.Fract (f x) b \\<and> b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<forall>i.\n           \\<exists>b.\n              v $ i = Fraction_Field.Fract (a i) b \\<and>\n              b \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>b.\n        v $ i = Fraction_Field.Fract (a i) b \\<and> b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        v $ x = Fraction_Field.Fract (a x) (f x) \\<and> f x \\<noteq> (0::'a)", "obtain b where vi: \"\\<And> i. v $ i = Fraction_Field.Fract (a i) (b i)\" and bi: \"\\<And> i. b i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        v $ x = Fraction_Field.Fract (a x) (f x) \\<and> f x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>\\<And>i. v $ i = Fraction_Field.Fract (a i) (b i);\n         \\<And>i. b i \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v $ ?i = Fraction_Field.Fract (a ?i) (b ?i)\n  b ?i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "define m where \"m = prod_list (map b [0..<n])\""], ["proof (state)\nthis:\n  m = prod_list (map b [0..<n])\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "let ?m = \"?h m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "have m0: \"m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> (0::'a)", "unfolding m_def hom_0_iff prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> set (map b [0..<n])", "using bi"], ["proof (prove)\nusing this:\n  b ?i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> set (map b [0..<n])", "by auto"], ["proof (state)\nthis:\n  m \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "from v0[unfolded vec_eq_iff] v"], ["proof (chain)\npicking this:\n  \\<not> (dim_vec v = dim_vec (0\\<^sub>v n) \\<and>\n          (\\<forall>i<dim_vec (0\\<^sub>v n). v $ i = 0\\<^sub>v n $ i))\n  v \\<in> carrier_vec n", "obtain i where i: \"i < n\" \"v $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (dim_vec v = dim_vec (0\\<^sub>v n) \\<and>\n          (\\<forall>i<dim_vec (0\\<^sub>v n). v $ i = 0\\<^sub>v n $ i))\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; v $ i \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  v $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "{"], ["proof (state)\nthis:\n  i < n\n  v $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "hence \"b i \\<in> set (map b [0 ..< n])\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. b i \\<in> set (map b [0..<n])", "by auto"], ["proof (state)\nthis:\n  b i \\<in> set (map b [0..<n])\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "from split_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. map b [0..<n] = ys @ b i # zs", "obtain ys zs where \"map b [0..<n] = ys @ b i # zs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. map b [0..<n] = ys @ b i # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        map b [0..<n] = ys @ b i # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map b [0..<n] = ys @ b i # zs\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "hence \"b i dvd m\""], ["proof (prove)\nusing this:\n  map b [0..<n] = ys @ b i # zs\n\ngoal (1 subgoal):\n 1. b i dvd m", "unfolding m_def"], ["proof (prove)\nusing this:\n  map b [0..<n] = ys @ b i # zs\n\ngoal (1 subgoal):\n 1. b i dvd prod_list (map b [0..<n])", "by auto"], ["proof (state)\nthis:\n  b i dvd m\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  b i dvd m", "obtain c where \"m = b i * c\""], ["proof (prove)\nusing this:\n  b i dvd m\n\ngoal (1 subgoal):\n 1. (\\<And>c. m = b i * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  m = b i * c\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "hence \"?m * v $ i = ?h (a i * c)\""], ["proof (prove)\nusing this:\n  m = b i * c\n\ngoal (1 subgoal):\n 1. to_fract m * v $ i = to_fract (a i * c)", "unfolding vi"], ["proof (prove)\nusing this:\n  m = b i * c\n\ngoal (1 subgoal):\n 1. to_fract m * Fraction_Field.Fract (a i) (b i) = to_fract (a i * c)", "using bi[of i]"], ["proof (prove)\nusing this:\n  m = b i * c\n  b i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. to_fract m * Fraction_Field.Fract (a i) (b i) = to_fract (a i * c)", "by (simp add: eq_fract to_fract_def)"], ["proof (state)\nthis:\n  to_fract m * v $ i = to_fract (a i * c)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "hence \"\\<exists> c. ?m * v $ i = ?h c\""], ["proof (prove)\nusing this:\n  to_fract m * v $ i = to_fract (a i * c)\n\ngoal (1 subgoal):\n 1. \\<exists>c. to_fract m * v $ i = to_fract c", ".."], ["proof (state)\nthis:\n  \\<exists>c. to_fract m * v $ i = to_fract c\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "}"], ["proof (state)\nthis:\n  ?ia2 < n \\<Longrightarrow> \\<exists>c. to_fract m * v $ ?ia2 = to_fract c\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "hence \"\\<forall> i. \\<exists> c. i < n \\<longrightarrow> ?m * v $ i = ?h c\""], ["proof (prove)\nusing this:\n  ?ia2 < n \\<Longrightarrow> \\<exists>c. to_fract m * v $ ?ia2 = to_fract c\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>c. i < n \\<longrightarrow> to_fract m * v $ i = to_fract c", "by auto"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>c. i < n \\<longrightarrow> to_fract m * v $ i = to_fract c\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>x<n. to_fract m * v $ x = to_fract (f x)", "obtain c where c: \"\\<And> i. i < n \\<Longrightarrow> ?m * v $ i = ?h (c i)\""], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>x<n. to_fract m * v $ x = to_fract (f x)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<And>i.\n            i < n \\<Longrightarrow>\n            to_fract m * v $ i = to_fract (c i)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> to_fract m * v $ ?i = to_fract (c ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "define w where \"w = vec n c\""], ["proof (state)\nthis:\n  w = vec n c\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "have w: \"w \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n c \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "have mvw: \"?m \\<cdot>\\<^sub>v v = map_vec ?h w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_fract m \\<cdot>\\<^sub>v v = vec_hom w", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_fract m \\<cdot>\\<^sub>v v = vec_hom (vec n c)", "using c v"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> to_fract m * v $ ?i = to_fract (c ?i)\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. to_fract m \\<cdot>\\<^sub>v v = vec_hom (vec n c)", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  to_fract m \\<cdot>\\<^sub>v v = vec_hom w\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "with m0 i c[OF i(1)]"], ["proof (chain)\npicking this:\n  m \\<noteq> (0::'a)\n  i < n\n  v $ i \\<noteq> 0\n  to_fract m * v $ i = to_fract (c i)\n  to_fract m \\<cdot>\\<^sub>v v = vec_hom w", "have \"w $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> (0::'a)\n  i < n\n  v $ i \\<noteq> 0\n  to_fract m * v $ i = to_fract (c i)\n  to_fract m \\<cdot>\\<^sub>v v = vec_hom w\n\ngoal (1 subgoal):\n 1. w $ i \\<noteq> (0::'a)", "unfolding w_def"], ["proof (prove)\nusing this:\n  m \\<noteq> (0::'a)\n  i < n\n  v $ i \\<noteq> 0\n  to_fract m * v $ i = to_fract (c i)\n  to_fract m \\<cdot>\\<^sub>v v = vec_hom (vec n c)\n\ngoal (1 subgoal):\n 1. vec n c $ i \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  w $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "with i w"], ["proof (chain)\npicking this:\n  i < n\n  v $ i \\<noteq> 0\n  w \\<in> carrier_vec n\n  w $ i \\<noteq> (0::'a)", "have w0: \"w \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  i < n\n  v $ i \\<noteq> 0\n  w \\<in> carrier_vec n\n  w $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  w \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "from arg_cong[OF Av, of \"\\<lambda> v. ?m \\<cdot>\\<^sub>v v\"]"], ["proof (chain)\npicking this:\n  to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) =\n  to_fract m \\<cdot>\\<^sub>v 0\\<^sub>v n", "have \"?m \\<cdot>\\<^sub>v (?A *\\<^sub>v v) = map_vec ?h (0\\<^sub>v n)\""], ["proof (prove)\nusing this:\n  to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) =\n  to_fract m \\<cdot>\\<^sub>v 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) =\n    vec_hom (0\\<^sub>v n)", "by auto"], ["proof (state)\nthis:\n  to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) = vec_hom (0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) = vec_hom (0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "have \"?m \\<cdot>\\<^sub>v (?A *\\<^sub>v v) = ?A *\\<^sub>v (?m \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) =\n    mat_hom A *\\<^sub>v (to_fract m \\<cdot>\\<^sub>v v)", "using A v"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) =\n    mat_hom A *\\<^sub>v (to_fract m \\<cdot>\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) =\n  mat_hom A *\\<^sub>v (to_fract m \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  to_fract m \\<cdot>\\<^sub>v (mat_hom A *\\<^sub>v v) =\n  mat_hom A *\\<^sub>v (to_fract m \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "have \"\\<dots> = ?A *\\<^sub>v (map_vec ?h w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_hom A *\\<^sub>v (to_fract m \\<cdot>\\<^sub>v v) =\n    mat_hom A *\\<^sub>v vec_hom w", "unfolding mvw"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_hom A *\\<^sub>v vec_hom w = mat_hom A *\\<^sub>v vec_hom w", ".."], ["proof (state)\nthis:\n  mat_hom A *\\<^sub>v (to_fract m \\<cdot>\\<^sub>v v) =\n  mat_hom A *\\<^sub>v vec_hom w\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  mat_hom A *\\<^sub>v (to_fract m \\<cdot>\\<^sub>v v) =\n  mat_hom A *\\<^sub>v vec_hom w\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "have \"\\<dots> = map_vec ?h (A *\\<^sub>v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_hom A *\\<^sub>v vec_hom w = vec_hom (A *\\<^sub>v w)", "unfolding mult_mat_vec_hom[OF A w]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_hom A *\\<^sub>v vec_hom w = mat_hom A *\\<^sub>v vec_hom w", ".."], ["proof (state)\nthis:\n  mat_hom A *\\<^sub>v vec_hom w = vec_hom (A *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "finally"], ["proof (chain)\npicking this:\n  vec_hom (A *\\<^sub>v w) = vec_hom (0\\<^sub>v n)", "have \"A *\\<^sub>v w = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  vec_hom (A *\\<^sub>v w) = vec_hom (0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v w = 0\\<^sub>v n", "by (rule vec_hom_inj)"], ["proof (state)\nthis:\n  A *\\<^sub>v w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       mat_hom A *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "with w w0"], ["proof (chain)\npicking this:\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v w = 0\\<^sub>v n", "show ?r"], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "by blast"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> mat_hom A *\\<^sub>v v = 0\\<^sub>v n) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "finally"], ["proof (chain)\npicking this:\n  (det A = (0::'a)) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (det A = (0::'a)) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "."], ["proof (state)\nthis:\n  (det A = (0::'a)) =\n  (\\<exists>v.\n      v \\<in> carrier_vec n \\<and>\n      v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_0_negate: assumes  A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"(det (- A) = 0) = (det A = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have mA: \"- A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. - A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "{"], ["proof (state)\nthis:\n  - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "fix v :: \"'a vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "assume v: \"v \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "hence Av: \"A *\\<^sub>v v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v \\<in> carrier_vec n", "using A"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "have id: \"- A *\\<^sub>v v = - (A *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - A *\\<^sub>v v = - (A *\\<^sub>v v)", "using v A"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. - A *\\<^sub>v v = - (A *\\<^sub>v v)", "by simp"], ["proof (state)\nthis:\n  - A *\\<^sub>v v = - (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "have \"(- A *\\<^sub>v v = 0\\<^sub>v n) = (A *\\<^sub>v v = 0\\<^sub>v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- A *\\<^sub>v v = 0\\<^sub>v n) = (A *\\<^sub>v v = 0\\<^sub>v n)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (A *\\<^sub>v v) = 0\\<^sub>v n) = (A *\\<^sub>v v = 0\\<^sub>v n)", "unfolding uminus_zero_vec_eq[OF Av]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v v = 0\\<^sub>v n) = (A *\\<^sub>v v = 0\\<^sub>v n)", ".."], ["proof (state)\nthis:\n  (- A *\\<^sub>v v = 0\\<^sub>v n) = (A *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  (- A *\\<^sub>v ?v2 = 0\\<^sub>v n) = (A *\\<^sub>v ?v2 = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  (- A *\\<^sub>v ?v2 = 0\\<^sub>v n) = (A *\\<^sub>v ?v2 = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (det (- A) = (0::'a)) = (det A = (0::'a))", "unfolding det_0_iff_vec_prod_zero[OF A] det_0_iff_vec_prod_zero[OF mA]"], ["proof (prove)\nusing this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  (- A *\\<^sub>v ?v2 = 0\\<^sub>v n) = (A *\\<^sub>v ?v2 = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> - A *\\<^sub>v v = 0\\<^sub>v n) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n)", "by auto"], ["proof (state)\nthis:\n  (det (- A) = (0::'a)) = (det A = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_multrow: \n  assumes k: \"k < n\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (multrow k a A) = a * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "have \"multrow k a A = multrow_mat n k a * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow k a A = multrow_mat n k a * A", "by (rule multrow_mat[OF A])"], ["proof (state)\nthis:\n  multrow k a A = multrow_mat n k a * A\n\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "also"], ["proof (state)\nthis:\n  multrow k a A = multrow_mat n k a * A\n\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "have \"det (multrow_mat n k a * A) = det (multrow_mat n k a) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (multrow_mat n k a * A) = det (multrow_mat n k a) * det A", "by (rule det_mult[OF _ A], auto)"], ["proof (state)\nthis:\n  det (multrow_mat n k a * A) = det (multrow_mat n k a) * det A\n\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "also"], ["proof (state)\nthis:\n  det (multrow_mat n k a * A) = det (multrow_mat n k a) * det A\n\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "have \"det (multrow_mat n k a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (multrow_mat n k a) = a", "by (rule det_multrow_mat[OF k])"], ["proof (state)\nthis:\n  det (multrow_mat n k a) = a\n\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "finally"], ["proof (chain)\npicking this:\n  det (multrow k a A) = a * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (multrow k a A) = a * det A\n\ngoal (1 subgoal):\n 1. det (multrow k a A) = a * det A", "."], ["proof (state)\nthis:\n  det (multrow k a A) = a * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_multrow_div:\n  assumes k: \"k < n\" and A: \"A \\<in> carrier_mat n n\" and a0: \"a \\<noteq> 0\"\n  shows \"det (multrow k a A :: 'a :: idom_divide mat) div a = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = det A", "have \"det (multrow k a A) div a = a * det A div a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = a * det A div a", "using k A"], ["proof (prove)\nusing this:\n  k < n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = a * det A div a", "by (simp add: det_multrow)"], ["proof (state)\nthis:\n  det (multrow k a A) div a = a * det A div a\n\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = det A", "also"], ["proof (state)\nthis:\n  det (multrow k a A) div a = a * det A div a\n\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = det A", "have \"... = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * det A div a = det A", "using a0"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a * det A div a = det A", "by auto"], ["proof (state)\nthis:\n  a * det A div a = det A\n\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = det A", "finally"], ["proof (chain)\npicking this:\n  det (multrow k a A) div a = det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (multrow k a A) div a = det A\n\ngoal (1 subgoal):\n 1. det (multrow k a A) div a = det A", "."], ["proof (state)\nthis:\n  det (multrow k a A) div a = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_addrow: \n  assumes l: \"l < n\" and k: \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (addrow a k l A) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "have \"addrow a k l A = addrow_mat n a k l * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow a k l A = addrow_mat n a k l * A", "by (rule addrow_mat[OF A l])"], ["proof (state)\nthis:\n  addrow a k l A = addrow_mat n a k l * A\n\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "also"], ["proof (state)\nthis:\n  addrow a k l A = addrow_mat n a k l * A\n\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "have \"det (addrow_mat n a k l * A) = det (addrow_mat n a k l) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l * A) = det (addrow_mat n a k l) * det A", "by (rule det_mult[OF _ A], auto)"], ["proof (state)\nthis:\n  det (addrow_mat n a k l * A) = det (addrow_mat n a k l) * det A\n\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "also"], ["proof (state)\nthis:\n  det (addrow_mat n a k l * A) = det (addrow_mat n a k l) * det A\n\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "have \"det (addrow_mat n a k l) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow_mat n a k l) = (1::'a)", "by (rule det_addrow_mat[OF k])"], ["proof (state)\nthis:\n  det (addrow_mat n a k l) = (1::'a)\n\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "finally"], ["proof (chain)\npicking this:\n  det (addrow a k l A) = (1::'a) * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (addrow a k l A) = (1::'a) * det A\n\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "using A"], ["proof (prove)\nusing this:\n  det (addrow a k l A) = (1::'a) * det A\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (addrow a k l A) = det A", "by simp"], ["proof (state)\nthis:\n  det (addrow a k l A) = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swaprows: \n  assumes *: \"k < n\" \"l < n\" and k: \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (swaprows k l A) = - det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "have \"swaprows k l A = swaprows_mat n k l * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l A = swaprows_mat n k l * A", "by (rule swaprows_mat[OF A *])"], ["proof (state)\nthis:\n  swaprows k l A = swaprows_mat n k l * A\n\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "also"], ["proof (state)\nthis:\n  swaprows k l A = swaprows_mat n k l * A\n\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "have \"det (swaprows_mat n k l * A) = det (swaprows_mat n k l) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l * A) = det (swaprows_mat n k l) * det A", "by (rule det_mult[OF _ A], insert A, auto)"], ["proof (state)\nthis:\n  det (swaprows_mat n k l * A) = det (swaprows_mat n k l) * det A\n\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "also"], ["proof (state)\nthis:\n  det (swaprows_mat n k l * A) = det (swaprows_mat n k l) * det A\n\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "have \"det (swaprows_mat n k l) = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swaprows_mat n k l) = - (1::'b)", "by (rule det_swaprows_mat[OF * k])"], ["proof (state)\nthis:\n  det (swaprows_mat n k l) = - (1::?'b1)\n\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "finally"], ["proof (chain)\npicking this:\n  det (swaprows k l A) = - (1::'a) * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (swaprows k l A) = - (1::'a) * det A\n\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "using A"], ["proof (prove)\nusing this:\n  det (swaprows k l A) = - (1::'a) * det A\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (swaprows k l A) = - det A", "by simp"], ["proof (state)\nthis:\n  det (swaprows k l A) = - det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_similar: assumes \"similar_mat A B\" \n  shows \"det A = det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = det B", "from similar_matD[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>n P Q.\n     {A, B, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * B * Q", "obtain n P Q where\n  carr: \"{A, B, P, Q} \\<subseteq> carrier_mat n n\" (is \"_ \\<subseteq> ?C\")\n  and PQ: \"P * Q = 1\\<^sub>m n\" \n  and AB: \"A = P * B * Q\""], ["proof (prove)\nusing this:\n  \\<exists>n P Q.\n     {A, B, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * B * Q\n\ngoal (1 subgoal):\n 1. (\\<And>P Q n.\n        \\<lbrakk>{A, B, P, Q} \\<subseteq> carrier_mat n n;\n         P * Q = 1\\<^sub>m n; A = P * B * Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {A, B, P, Q} \\<subseteq> carrier_mat n n\n  P * Q = 1\\<^sub>m n\n  A = P * B * Q\n\ngoal (1 subgoal):\n 1. det A = det B", "hence A: \"A \\<in> ?C\" and B: \"B \\<in> ?C\" and P: \"P \\<in> ?C\" and Q: \"Q \\<in> ?C\""], ["proof (prove)\nusing this:\n  {A, B, P, Q} \\<subseteq> carrier_mat n n\n  P * Q = 1\\<^sub>m n\n  A = P * B * Q\n\ngoal (1 subgoal):\n 1. (A \\<in> carrier_mat n n &&& B \\<in> carrier_mat n n) &&&\n    P \\<in> carrier_mat n n &&& Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det A = det B", "from det_mult[OF P Q, unfolded PQ]"], ["proof (chain)\npicking this:\n  det (1\\<^sub>m n) = det P * det Q", "have PQ: \"det P * det Q = 1\""], ["proof (prove)\nusing this:\n  det (1\\<^sub>m n) = det P * det Q\n\ngoal (1 subgoal):\n 1. det P * det Q = (1::'a)", "by auto"], ["proof (state)\nthis:\n  det P * det Q = (1::'a)\n\ngoal (1 subgoal):\n 1. det A = det B", "from det_mult[OF _ Q, of \"P * B\", unfolded det_mult[OF P B] AB[symmetric]] P B"], ["proof (chain)\npicking this:\n  P * B \\<in> carrier_mat n n \\<Longrightarrow>\n  det A = det P * det B * det Q\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n", "have \"det A = det P * det B * det Q\""], ["proof (prove)\nusing this:\n  P * B \\<in> carrier_mat n n \\<Longrightarrow>\n  det A = det P * det B * det Q\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det A = det P * det B * det Q", "by auto"], ["proof (state)\nthis:\n  det A = det P * det B * det Q\n\ngoal (1 subgoal):\n 1. det A = det B", "also"], ["proof (state)\nthis:\n  det A = det P * det B * det Q\n\ngoal (1 subgoal):\n 1. det A = det B", "have \"\\<dots> = (det P * det Q) * det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det P * det B * det Q = det P * det Q * det B", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  det P * det B * det Q = det P * det Q * det B\n\ngoal (1 subgoal):\n 1. det A = det B", "also"], ["proof (state)\nthis:\n  det P * det B * det Q = det P * det Q * det B\n\ngoal (1 subgoal):\n 1. det A = det B", "have \"\\<dots> = det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det P * det Q * det B = det B", "unfolding PQ"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) * det B = det B", "by simp"], ["proof (state)\nthis:\n  det P * det Q * det B = det B\n\ngoal (1 subgoal):\n 1. det A = det B", "finally"], ["proof (chain)\npicking this:\n  det A = det B", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = det B\n\ngoal (1 subgoal):\n 1. det A = det B", "."], ["proof (state)\nthis:\n  det A = det B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_four_block_mat_upper_right_zero_col: assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A20: \"A2 = (0\\<^sub>m n 1)\" and A3: \"A3 \\<in> carrier_mat 1 n\"\n  and A4: \"A4 \\<in> carrier_mat 1 1\"\n  shows \"det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\" (is \"det ?A = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?A = \"four_block_mat A1 A2 A3 A4\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from A20"], ["proof (chain)\npicking this:\n  A2 = 0\\<^sub>m n 1", "have A2: \"A2 \\<in> carrier_mat n 1\""], ["proof (prove)\nusing this:\n  A2 = 0\\<^sub>m n 1\n\ngoal (1 subgoal):\n 1. A2 \\<in> carrier_mat n 1", "by auto"], ["proof (state)\nthis:\n  A2 \\<in> carrier_mat n 1\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "define A where \"A = ?A\""], ["proof (state)\nthis:\n  A = four_block_mat A1 A2 A3 A4\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from four_block_carrier_mat[OF A1 A4] A1"], ["proof (chain)\npicking this:\n  four_block_mat A1 ?B ?C A4 \\<in> carrier_mat (n + 1) (n + 1)\n  A1 \\<in> carrier_mat n n", "have A: \"A \\<in> carrier_mat (Suc n) (Suc n)\" and dim: \"dim_row A1 = n\""], ["proof (prove)\nusing this:\n  four_block_mat A1 ?B ?C A4 \\<in> carrier_mat (n + 1) (n + 1)\n  A1 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (Suc n) (Suc n) &&& dim_row A1 = n", "unfolding A_def"], ["proof (prove)\nusing this:\n  four_block_mat A1 ?B ?C A4 \\<in> carrier_mat (n + 1) (n + 1)\n  A1 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 \\<in> carrier_mat (Suc n) (Suc n) &&&\n    dim_row A1 = n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (Suc n) (Suc n)\n  dim_row A1 = n\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?Pn = \"\\<lambda> p. p permutes {0 ..< n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?Psn = \"\\<lambda> p. p permutes {0 ..< Suc n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?perm = \"{p. ?Psn p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?permn = \"{p. ?Pn p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?prod = \"\\<lambda> p. signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?prod' = \"\\<lambda> p. A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?prod'' = \"\\<lambda> p. signof p * (\\<Prod>i = 0..< n. A $$ (p i, i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?prod''' = \"\\<lambda> p. signof p * (\\<Prod>i = 0..< n. A1 $$ (p i, i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?p0 = \"{p. p 0 = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have [simp]: \"{0..<Suc n} - {n} = {0..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc n} - {n} = {0..<n}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc n} - {n} = {0..<n}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "{"], ["proof (state)\nthis:\n  {0..<Suc n} - {n} = {0..<n}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "assume \"?Psn p\""], ["proof (state)\nthis:\n  p permutes {0..<Suc n}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"?prod p = signof p * (A $$ (p n, n) * (\\<Prod> i \\<in> {0..< n}. A $$ (p i, i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)) =\n    signof p * (A $$ (p n, n) * (\\<Prod>i = 0..<n. A $$ (p i, i)))", "by (subst prod.remove[of _ n], auto)"], ["proof (state)\nthis:\n  signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)) =\n  signof p * (A $$ (p n, n) * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)) =\n  signof p * (A $$ (p n, n) * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"\\<dots> = A $$ (p n, n) * signof p * (\\<Prod> i \\<in> {0..< n}. A $$ (p i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p * (A $$ (p n, n) * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n    A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))", "by simp"], ["proof (state)\nthis:\n  signof p * (A $$ (p n, n) * (\\<Prod>i = 0..<n. A $$ (p i, i))) =\n  A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "finally"], ["proof (chain)\npicking this:\n  signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)) =\n  A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))", "have \"?prod p = ?prod' p\""], ["proof (prove)\nusing this:\n  signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)) =\n  A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))\n\ngoal (1 subgoal):\n 1. signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)) =\n    A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))", "."], ["proof (state)\nthis:\n  signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)) =\n  A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "}"], ["proof (state)\nthis:\n  ?p3 permutes {0..<Suc n} \\<Longrightarrow>\n  signof ?p3 * (\\<Prod>i = 0..<Suc n. A $$ (?p3 i, i)) =\n  A $$ (?p3 n, n) * signof ?p3 * (\\<Prod>i = 0..<n. A $$ (?p3 i, i))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "note prod_id = this"], ["proof (state)\nthis:\n  ?p3 permutes {0..<Suc n} \\<Longrightarrow>\n  signof ?p3 * (\\<Prod>i = 0..<Suc n. A $$ (?p3 i, i)) =\n  A $$ (?p3 n, n) * signof ?p3 * (\\<Prod>i = 0..<n. A $$ (?p3 i, i))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "define prod' where \"prod' = ?prod'\""], ["proof (state)\nthis:\n  prod' =\n  (\\<lambda>p. A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "{"], ["proof (state)\nthis:\n  prod' =\n  (\\<lambda>p. A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "fix i q"], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "assume i: \"i \\<in> {0..< n}\" \"q permutes {0 ..< n}\""], ["proof (state)\nthis:\n  i \\<in> {0..<n}\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "hence \"Fun.swap n i id (q n) < n\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<n}\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. Fun.swap n i id (q n) < n", "unfolding permutes_def"], ["proof (prove)\nusing this:\n  i \\<in> {0..<n}\n  (\\<forall>x. x \\<notin> {0..<n} \\<longrightarrow> q x = x) \\<and>\n  (\\<forall>y. \\<exists>!x. q x = y)\n\ngoal (1 subgoal):\n 1. Fun.swap n i id (q n) < n", "by auto"], ["proof (state)\nthis:\n  Fun.swap n i id (q n) < n\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "hence \"A $$ (Fun.swap n i id (q n), n) = 0\""], ["proof (prove)\nusing this:\n  Fun.swap n i id (q n) < n\n\ngoal (1 subgoal):\n 1. A $$ (Fun.swap n i id (q n), n) = (0::'a)", "unfolding A_def"], ["proof (prove)\nusing this:\n  Fun.swap n i id (q n) < n\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 $$ (Fun.swap n i id (q n), n) = (0::'a)", "using A1 A20 A3 A4"], ["proof (prove)\nusing this:\n  Fun.swap n i id (q n) < n\n  A1 \\<in> carrier_mat n n\n  A2 = 0\\<^sub>m n 1\n  A3 \\<in> carrier_mat 1 n\n  A4 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 $$ (Fun.swap n i id (q n), n) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $$ (Fun.swap n i id (q n), n) = (0::'a)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "hence \"prod' (Fun.swap n i id \\<circ> q) = 0\""], ["proof (prove)\nusing this:\n  A $$ (Fun.swap n i id (q n), n) = (0::'a)\n\ngoal (1 subgoal):\n 1. prod' (Fun.swap n i id \\<circ> q) = (0::'a)", "unfolding prod'_def"], ["proof (prove)\nusing this:\n  A $$ (Fun.swap n i id (q n), n) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ ((Fun.swap n i id \\<circ> q) n, n) *\n    signof (Fun.swap n i id \\<circ> q) *\n    (\\<Prod>ia = 0..<n. A $$ ((Fun.swap n i id \\<circ> q) ia, ia)) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  prod' (Fun.swap n i id \\<circ> q) = (0::'a)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<in> {0..<n}; ?q3 permutes {0..<n}\\<rbrakk>\n  \\<Longrightarrow> prod' (Fun.swap n ?i3 id \\<circ> ?q3) = (0::'a)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "note zero = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<in> {0..<n}; ?q3 permutes {0..<n}\\<rbrakk>\n  \\<Longrightarrow> prod' (Fun.swap n ?i3 id \\<circ> ?q3) = (0::'a)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have cong: \"\\<And> a b c. b = c \\<Longrightarrow> a * b = a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. b = c \\<Longrightarrow> a * b = a * c", "by auto"], ["proof (state)\nthis:\n  ?b1 = ?c1 \\<Longrightarrow> ?a1 * ?b1 = ?a1 * ?c1\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"det ?A = sum ?prod ?perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) =\n    (\\<Sum>p | p permutes {0..<Suc n}.\n       signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)))", "unfolding A_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<Suc n}.\n       signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)))", "using mat_det_left_def[OF A] A"], ["proof (prove)\nusing this:\n  det A =\n  (\\<Sum>p | p permutes {0..<dim_row A}.\n     signof p * (\\<Prod>i = 0..<dim_row A. A $$ (p i, i)))\n  A \\<in> carrier_mat (Suc n) (Suc n)\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<Suc n}.\n       signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)))", "by simp"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) =\n  (\\<Sum>p | p permutes {0..<Suc n}.\n     signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) =\n  (\\<Sum>p | p permutes {0..<Suc n}.\n     signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"\\<dots> = sum prod' ?perm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<Suc n}.\n       signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i))) =\n    sum prod' {p. p permutes {0..<Suc n}}", "unfolding prod'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<Suc n}.\n       signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i))) =\n    (\\<Sum>p | p permutes {0..<Suc n}.\n       A $$ (p n, n) * signof p * (\\<Prod>i = 0..<n. A $$ (p i, i)))", "by (rule sum.cong[OF refl], insert prod_id, auto)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<Suc n}.\n     signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i))) =\n  sum prod' {p. p permutes {0..<Suc n}}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<Suc n}.\n     signof p * (\\<Prod>i = 0..<Suc n. A $$ (p i, i))) =\n  sum prod' {p. p permutes {0..<Suc n}}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"{0 ..< Suc n} = insert n {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc n} = insert n {0..<n}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc n} = insert n {0..<n}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  {0..<Suc n} = insert n {0..<n}\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"sum prod' {p. p permutes \\<dots>} = \n    (\\<Sum>i\\<in>insert n {0..<n}. \\<Sum>q\\<in>?permn. prod' (Fun.swap n i id \\<circ> q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum prod' {p. p permutes insert n {0..<n}} =\n    (\\<Sum>i\\<in>insert n {0..<n}.\n       \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n         prod' (Fun.swap n i id \\<circ> q))", "by (subst sum_over_permutations_insert, auto)"], ["proof (state)\nthis:\n  sum prod' {p. p permutes insert n {0..<n}} =\n  (\\<Sum>i\\<in>insert n {0..<n}.\n     \\<Sum>q\\<in>{p. p permutes {0..<n}}. prod' (Fun.swap n i id \\<circ> q))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  sum prod' {p. p permutes insert n {0..<n}} =\n  (\\<Sum>i\\<in>insert n {0..<n}.\n     \\<Sum>q\\<in>{p. p permutes {0..<n}}. prod' (Fun.swap n i id \\<circ> q))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"\\<dots> = (\\<Sum>q\\<in>?permn. prod' q) +\n    (\\<Sum>i\\<in>{0..<n}. \\<Sum>q\\<in>?permn. prod' (Fun.swap n i id \\<circ> q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert n {0..<n}.\n       \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n         prod' (Fun.swap n i id \\<circ> q)) =\n    sum prod' {p. p permutes {0..<n}} +\n    (\\<Sum>i = 0..<n.\n        \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n          prod' (Fun.swap n i id \\<circ> q))", "by (subst sum.insert, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert n {0..<n}.\n     \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       prod' (Fun.swap n i id \\<circ> q)) =\n  sum prod' {p. p permutes {0..<n}} +\n  (\\<Sum>i = 0..<n.\n      \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n        prod' (Fun.swap n i id \\<circ> q))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert n {0..<n}.\n     \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       prod' (Fun.swap n i id \\<circ> q)) =\n  sum prod' {p. p permutes {0..<n}} +\n  (\\<Sum>i = 0..<n.\n      \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n        prod' (Fun.swap n i id \\<circ> q))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"(\\<Sum>i\\<in>{0..<n}. \\<Sum>q\\<in>?permn. prod' (Fun.swap n i id \\<circ> q)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n          prod' (Fun.swap n i id \\<circ> q)) =\n    (0::'a)", "by (rule sum.neutral, intro ballI, rule sum.neutral, intro ballI, rule zero, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n        prod' (Fun.swap n i id \\<circ> q)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      \\<Sum>q\\<in>{p. p permutes {0..<n}}.\n        prod' (Fun.swap n i id \\<circ> q)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"(\\<Sum>q\\<in> ?permn. prod' q) = A $$ (n,n) * (\\<Sum>q\\<in> ?permn. ?prod'' q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum prod' {p. p permutes {0..<n}} =\n    A $$ (n, n) *\n    (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q * (\\<Prod>i = 0..<n. A $$ (q i, i)))", "unfolding prod'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       A $$ (q n, n) * signof q * (\\<Prod>i = 0..<n. A $$ (q i, i))) =\n    A $$ (n, n) *\n    (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q * (\\<Prod>i = 0..<n. A $$ (q i, i)))", "by (subst sum_distrib_left, rule sum.cong[OF refl], auto simp: permutes_def ac_simps)"], ["proof (state)\nthis:\n  sum prod' {p. p permutes {0..<n}} =\n  A $$ (n, n) *\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A $$ (q i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  sum prod' {p. p permutes {0..<n}} =\n  A $$ (n, n) *\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A $$ (q i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"A $$ (n,n) = A4 $$ (0,0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (n, n) = A4 $$ (0, 0)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 $$ (n, n) = A4 $$ (0, 0)", "using A1 A2 A3 A4"], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n 1\n  A3 \\<in> carrier_mat 1 n\n  A4 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 $$ (n, n) = A4 $$ (0, 0)", "by auto"], ["proof (state)\nthis:\n  A $$ (n, n) = A4 $$ (0, 0)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  A $$ (n, n) = A4 $$ (0, 0)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"(\\<Sum>q\\<in> ?permn. ?prod'' q) = (\\<Sum>q\\<in> ?permn. ?prod''' q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q * (\\<Prod>i = 0..<n. A $$ (q i, i))) =\n    (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q * (\\<Prod>i = 0..<n. A1 $$ (q i, i)))", "by (rule sum.cong[OF refl], rule cong, rule prod.cong,\n    insert A1 A2 A3 A4, auto simp: permutes_def A_def)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A $$ (q i, i))) =\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A1 $$ (q i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A $$ (q i, i))) =\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A1 $$ (q i, i)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"\\<dots> = det A1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q * (\\<Prod>i = 0..<n. A1 $$ (q i, i))) =\n    det A1", "unfolding mat_det_left_def[OF A1] dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n       signof q * (\\<Prod>i = 0..<n. A1 $$ (q i, i))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A1 $$ (p i, i)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A1 $$ (q i, i))) =\n  det A1\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>{p. p permutes {0..<n}}.\n     signof q * (\\<Prod>i = 0..<n. A1 $$ (q i, i))) =\n  det A1\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"A4 $$ (0,0) = det A4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A4 $$ (0, 0) = det A4", "using A4"], ["proof (prove)\nusing this:\n  A4 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. A4 $$ (0, 0) = det A4", "unfolding det_def[of A4]"], ["proof (prove)\nusing this:\n  A4 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. A4 $$ (0, 0) =\n    (if dim_row A4 = dim_col A4\n     then \\<Sum>p | p permutes {0..<dim_row A4}.\n            signof p * (\\<Prod>i = 0..<dim_row A4. A4 $$ (i, p i))\n     else (0::'a))", "by (auto simp: signof_def sign_def)"], ["proof (state)\nthis:\n  A4 $$ (0, 0) = det A4\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "finally"], ["proof (chain)\npicking this:\n  det (four_block_mat A1 A2 A3 A4) = det A4 * det A1 + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (four_block_mat A1 A2 A3 A4) = det A4 * det A1 + (0::'a)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "by simp"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swap_initial_rows: assumes A: \"A \\<in> carrier_mat m m\" \n  and lt: \"k + n \\<le> m\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (if i < n then i + k else if i < k + n then i - n else i, j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "define sw where \"sw = (\\<lambda> (A :: 'a mat) xs. fold (\\<lambda> (i,j). swaprows i j) xs A)\""], ["proof (state)\nthis:\n  sw = (\\<lambda>A xs. fold (\\<lambda>(i, j). swaprows i j) xs A)\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "have dim_sw[simp]: \"dim_row (sw A xs) = dim_row A\" \"dim_col (sw A xs) = dim_col A\" for xs A"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (sw A xs) = dim_row A &&& dim_col (sw A xs) = dim_col A", "unfolding sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (fold (\\<lambda>(x, y). swaprows x y) xs A) = dim_row A &&&\n    dim_col (fold (\\<lambda>(x, y). swaprows x y) xs A) = dim_col A", "by (induct xs arbitrary: A, auto)"], ["proof (state)\nthis:\n  dim_row (sw ?A ?xs) = dim_row ?A\n  dim_col (sw ?A ?xs) = dim_col ?A\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "{"], ["proof (state)\nthis:\n  dim_row (sw ?A ?xs) = dim_row ?A\n  dim_col (sw ?A ?xs) = dim_col ?A\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "fix xs and A :: \"'a mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "assume \"dim_row A = dim_col A\" \"\\<And> i j. (i,j) \\<in> set xs \\<Longrightarrow> i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\""], ["proof (state)\nthis:\n  dim_row A = dim_col A\n  (?i, ?j) \\<in> set xs \\<Longrightarrow>\n  ?i < dim_col A \\<and> ?j < dim_col A \\<and> ?i \\<noteq> ?j\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "hence \"det (sw A xs) = (-1)^(length xs) * det A\""], ["proof (prove)\nusing this:\n  dim_row A = dim_col A\n  (?i, ?j) \\<in> set xs \\<Longrightarrow>\n  ?i < dim_col A \\<and> ?j < dim_col A \\<and> ?i \\<noteq> ?j\n\ngoal (1 subgoal):\n 1. det (sw A xs) = (- (1::'a)) ^ length xs * det A", "unfolding sw_def"], ["proof (prove)\nusing this:\n  dim_row A = dim_col A\n  (?i, ?j) \\<in> set xs \\<Longrightarrow>\n  ?i < dim_col A \\<and> ?j < dim_col A \\<and> ?i \\<noteq> ?j\n\ngoal (1 subgoal):\n 1. det (fold (\\<lambda>(x, y). swaprows x y) xs A) =\n    (- (1::'a)) ^ length xs * det A", "proof (induct xs arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set [] \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) [] A) =\n                         (- (1::'a)) ^ length [] * det A\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>dim_row A = dim_col A;\n                    \\<And>i j.\n                       (i, j) \\<in> set xs \\<Longrightarrow>\n                       i < dim_col A \\<and>\n                       j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> det\n(fold (\\<lambda>(x, y). swaprows x y) xs A) =\n                                     (- (1::'a)) ^ length xs * det A;\n        dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set (a # xs) \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) (a # xs)\n                               A) =\n                         (- (1::'a)) ^ length (a # xs) * det A", "case (Cons xy xs A)"], ["proof (state)\nthis:\n  \\<lbrakk>dim_row ?A = dim_col ?A;\n   \\<And>i j.\n      (i, j) \\<in> set xs \\<Longrightarrow>\n      i < dim_col ?A \\<and> j < dim_col ?A \\<and> i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> det (fold\n                          (\\<lambda>a.\n                              case a of (a, b) \\<Rightarrow> swaprows a b)\n                          xs ?A) =\n                    (- (1::'a)) ^ length xs * det ?A\n  dim_row A = dim_col A\n  (?i, ?j) \\<in> set (xy # xs) \\<Longrightarrow>\n  ?i < dim_col A \\<and> ?j < dim_col A \\<and> ?i \\<noteq> ?j\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set [] \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) [] A) =\n                         (- (1::'a)) ^ length [] * det A\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>dim_row A = dim_col A;\n                    \\<And>i j.\n                       (i, j) \\<in> set xs \\<Longrightarrow>\n                       i < dim_col A \\<and>\n                       j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> det\n(fold (\\<lambda>(x, y). swaprows x y) xs A) =\n                                     (- (1::'a)) ^ length xs * det A;\n        dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set (a # xs) \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) (a # xs)\n                               A) =\n                         (- (1::'a)) ^ length (a # xs) * det A", "obtain x y where xy: \"xy = (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. xy = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xy = (x, y)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set [] \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) [] A) =\n                         (- (1::'a)) ^ length [] * det A\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>dim_row A = dim_col A;\n                    \\<And>i j.\n                       (i, j) \\<in> set xs \\<Longrightarrow>\n                       i < dim_col A \\<and>\n                       j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> det\n(fold (\\<lambda>(x, y). swaprows x y) xs A) =\n                                     (- (1::'a)) ^ length xs * det A;\n        dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set (a # xs) \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) (a # xs)\n                               A) =\n                         (- (1::'a)) ^ length (a # xs) * det A", "from Cons(3)[unfolded xy, of x y] Cons(2)"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set ((x, y) # xs) \\<Longrightarrow>\n  x < dim_col A \\<and> y < dim_col A \\<and> x \\<noteq> y\n  dim_row A = dim_col A", "have [simp]: \"det (swaprows x y A) = - det A\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set ((x, y) # xs) \\<Longrightarrow>\n  x < dim_col A \\<and> y < dim_col A \\<and> x \\<noteq> y\n  dim_row A = dim_col A\n\ngoal (1 subgoal):\n 1. det (swaprows x y A) = - det A", "by (intro det_swaprows, auto)"], ["proof (state)\nthis:\n  det (swaprows x y A) = - det A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set [] \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) [] A) =\n                         (- (1::'a)) ^ length [] * det A\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>dim_row A = dim_col A;\n                    \\<And>i j.\n                       (i, j) \\<in> set xs \\<Longrightarrow>\n                       i < dim_col A \\<and>\n                       j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> det\n(fold (\\<lambda>(x, y). swaprows x y) xs A) =\n                                     (- (1::'a)) ^ length xs * det A;\n        dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set (a # xs) \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) (a # xs)\n                               A) =\n                         (- (1::'a)) ^ length (a # xs) * det A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> swaprows a b)\n          (xy # xs) A) =\n    (- (1::'a)) ^ length (xy # xs) * det A", "unfolding xy"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> swaprows a b)\n          ((x, y) # xs) A) =\n    (- (1::'a)) ^ length ((x, y) # xs) * det A", "by (simp, insert Cons(2-), (subst Cons(1), auto)+)"], ["proof (state)\nthis:\n  det (fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> swaprows a b)\n        (xy # xs) A) =\n  (- (1::'a)) ^ length (xy # xs) * det A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>dim_row A = dim_col A;\n        \\<And>i j.\n           (i, j) \\<in> set [] \\<Longrightarrow>\n           i < dim_col A \\<and> j < dim_col A \\<and> i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> det (fold (\\<lambda>(x, y). swaprows x y) [] A) =\n                         (- (1::'a)) ^ length [] * det A", "qed simp"], ["proof (state)\nthis:\n  det (sw A xs) = (- (1::'a)) ^ length xs * det A\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>dim_row ?Aa2 = dim_col ?Aa2;\n   \\<And>i j.\n      (i, j) \\<in> set ?xs2 \\<Longrightarrow>\n      i < dim_col ?Aa2 \\<and> j < dim_col ?Aa2 \\<and> i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> det (sw ?Aa2 ?xs2) =\n                    (- (1::'a)) ^ length ?xs2 * det ?Aa2\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "note sw = this"], ["proof (state)\nthis:\n  \\<lbrakk>dim_row ?Aa2 = dim_col ?Aa2;\n   \\<And>i j.\n      (i, j) \\<in> set ?xs2 \\<Longrightarrow>\n      i < dim_col ?Aa2 \\<and> j < dim_col ?Aa2 \\<and> i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> det (sw ?Aa2 ?xs2) =\n                    (- (1::'a)) ^ length ?xs2 * det ?Aa2\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "define swb where \"swb = (\\<lambda> A i n. sw A (map (\\<lambda> j. (j,Suc j)) [i ..< i + n]))\""], ["proof (state)\nthis:\n  swb = (\\<lambda>A i n. sw A (map (\\<lambda>j. (j, Suc j)) [i..<i + n]))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "{"], ["proof (state)\nthis:\n  swb = (\\<lambda>A i n. sw A (map (\\<lambda>j. (j, Suc j)) [i..<i + n]))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "fix k n and A :: \"'a mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "assume k_n: \"k + n < dim_row A\""], ["proof (state)\nthis:\n  k + n < dim_row A\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "hence \"swb A k n = mat (dim_row A) (dim_col A) (\\<lambda> (i,j). let r = \n      (if i < k \\<or> i > k + n then i else if i = k + n then k else Suc i)\n      in A $$ (r,j))\""], ["proof (prove)\nusing this:\n  k + n < dim_row A\n\ngoal (1 subgoal):\n 1. swb A k n =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         let r = if i < k \\<or> k + n < i then i\n                 else if i = k + n then k else Suc i\n         in A $$ (r, j))", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. k + 0 < dim_row A \\<Longrightarrow>\n    swb A k 0 =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         let r = if i < k \\<or> k + 0 < i then i\n                 else if i = k + 0 then k else Suc i\n         in A $$ (r, j))\n 2. \\<And>n.\n       \\<lbrakk>k + n < dim_row A \\<Longrightarrow>\n                swb A k n =\n                mat (dim_row A) (dim_col A)\n                 (\\<lambda>(i, j).\n                     let r = if i < k \\<or> k + n < i then i\n                             else if i = k + n then k else Suc i\n                     in A $$ (r, j));\n        k + Suc n < dim_row A\\<rbrakk>\n       \\<Longrightarrow> swb A k (Suc n) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < k \\<or> k + Suc n < i then i\nelse if i = k + Suc n then k else Suc i\n                              in A $$ (r, j))", "case 0"], ["proof (state)\nthis:\n  k + 0 < dim_row A\n\ngoal (2 subgoals):\n 1. k + 0 < dim_row A \\<Longrightarrow>\n    swb A k 0 =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         let r = if i < k \\<or> k + 0 < i then i\n                 else if i = k + 0 then k else Suc i\n         in A $$ (r, j))\n 2. \\<And>n.\n       \\<lbrakk>k + n < dim_row A \\<Longrightarrow>\n                swb A k n =\n                mat (dim_row A) (dim_col A)\n                 (\\<lambda>(i, j).\n                     let r = if i < k \\<or> k + n < i then i\n                             else if i = k + n then k else Suc i\n                     in A $$ (r, j));\n        k + Suc n < dim_row A\\<rbrakk>\n       \\<Longrightarrow> swb A k (Suc n) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < k \\<or> k + Suc n < i then i\nelse if i = k + Suc n then k else Suc i\n                              in A $$ (r, j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. swb A k 0 =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < k \\<or> k + 0 < i then i\n                   else if i = k + 0 then k else Suc i\n           in A $$ (r, j))", "unfolding swb_def sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y). swaprows x y)\n     (map (\\<lambda>j. (j, Suc j)) [k..<k + 0]) A =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < k \\<or> k + 0 < i then i\n                   else if i = k + 0 then k else Suc i\n           in A $$ (r, j))", "by (rule eq_matI, auto)"], ["proof (state)\nthis:\n  swb A k 0 =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < k \\<or> k + 0 < i then i\n                 else if i = k + 0 then k else Suc i\n         in A $$ (r, j))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>k + n < dim_row A \\<Longrightarrow>\n                swb A k n =\n                mat (dim_row A) (dim_col A)\n                 (\\<lambda>(i, j).\n                     let r = if i < k \\<or> k + n < i then i\n                             else if i = k + n then k else Suc i\n                     in A $$ (r, j));\n        k + Suc n < dim_row A\\<rbrakk>\n       \\<Longrightarrow> swb A k (Suc n) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < k \\<or> k + Suc n < i then i\nelse if i = k + Suc n then k else Suc i\n                              in A $$ (r, j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>k + n < dim_row A \\<Longrightarrow>\n                swb A k n =\n                mat (dim_row A) (dim_col A)\n                 (\\<lambda>(i, j).\n                     let r = if i < k \\<or> k + n < i then i\n                             else if i = k + n then k else Suc i\n                     in A $$ (r, j));\n        k + Suc n < dim_row A\\<rbrakk>\n       \\<Longrightarrow> swb A k (Suc n) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < k \\<or> k + Suc n < i then i\nelse if i = k + Suc n then k else Suc i\n                              in A $$ (r, j))", "case (Suc n)"], ["proof (state)\nthis:\n  k + n < dim_row A \\<Longrightarrow>\n  swb A k n =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < k \\<or> k + n < i then i\n                 else if i = k + n then k else Suc i\n         in A $$ (r, j))\n  k + Suc n < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>k + n < dim_row A \\<Longrightarrow>\n                swb A k n =\n                mat (dim_row A) (dim_col A)\n                 (\\<lambda>(i, j).\n                     let r = if i < k \\<or> k + n < i then i\n                             else if i = k + n then k else Suc i\n                     in A $$ (r, j));\n        k + Suc n < dim_row A\\<rbrakk>\n       \\<Longrightarrow> swb A k (Suc n) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < k \\<or> k + Suc n < i then i\nelse if i = k + Suc n then k else Suc i\n                              in A $$ (r, j))", "hence dim: \"k + n < dim_row A\""], ["proof (prove)\nusing this:\n  k + n < dim_row A \\<Longrightarrow>\n  swb A k n =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < k \\<or> k + n < i then i\n                 else if i = k + n then k else Suc i\n         in A $$ (r, j))\n  k + Suc n < dim_row A\n\ngoal (1 subgoal):\n 1. k + n < dim_row A", "by auto"], ["proof (state)\nthis:\n  k + n < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>k + n < dim_row A \\<Longrightarrow>\n                swb A k n =\n                mat (dim_row A) (dim_col A)\n                 (\\<lambda>(i, j).\n                     let r = if i < k \\<or> k + n < i then i\n                             else if i = k + n then k else Suc i\n                     in A $$ (r, j));\n        k + Suc n < dim_row A\\<rbrakk>\n       \\<Longrightarrow> swb A k (Suc n) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < k \\<or> k + Suc n < i then i\nelse if i = k + Suc n then k else Suc i\n                              in A $$ (r, j))", "have id: \"swb A k (Suc n) = swaprows (k + n) (Suc k + n) (swb A k n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swb A k (Suc n) = swaprows (k + n) (Suc k + n) (swb A k n)", "unfolding swb_def sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y). swaprows x y)\n     (map (\\<lambda>j. (j, Suc j)) [k..<k + Suc n]) A =\n    swaprows (k + n) (Suc k + n)\n     (fold (\\<lambda>(x, y). swaprows x y)\n       (map (\\<lambda>j. (j, Suc j)) [k..<k + n]) A)", "by simp"], ["proof (state)\nthis:\n  swb A k (Suc n) = swaprows (k + n) (Suc k + n) (swb A k n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>k + n < dim_row A \\<Longrightarrow>\n                swb A k n =\n                mat (dim_row A) (dim_col A)\n                 (\\<lambda>(i, j).\n                     let r = if i < k \\<or> k + n < i then i\n                             else if i = k + n then k else Suc i\n                     in A $$ (r, j));\n        k + Suc n < dim_row A\\<rbrakk>\n       \\<Longrightarrow> swb A k (Suc n) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < k \\<or> k + Suc n < i then i\nelse if i = k + Suc n then k else Suc i\n                              in A $$ (r, j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. swb A k (Suc n) =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < k \\<or> k + Suc n < i then i\n                   else if i = k + Suc n then k else Suc i\n           in A $$ (r, j))", "unfolding id Suc(1)[OF dim]"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows (k + n) (Suc k + n)\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           let r = if i < k \\<or> k + n < i then i\n                   else if i = k + n then k else Suc i\n           in A $$ (r, j))) =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < k \\<or> k + Suc n < i then i\n                   else if i = k + Suc n then k else Suc i\n           in A $$ (r, j))", "by (rule eq_matI, insert Suc(2), auto)"], ["proof (state)\nthis:\n  swb A k (Suc n) =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < k \\<or> k + Suc n < i then i\n                 else if i = k + Suc n then k else Suc i\n         in A $$ (r, j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  swb A k n =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>(i, j).\n       let r = if i < k \\<or> k + n < i then i\n               else if i = k + n then k else Suc i\n       in A $$ (r, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "}"], ["proof (state)\nthis:\n  ?ka2 + ?na2 < dim_row ?Aa2 \\<Longrightarrow>\n  swb ?Aa2 ?ka2 ?na2 =\n  mat (dim_row ?Aa2) (dim_col ?Aa2)\n   (\\<lambda>(i, j).\n       let r = if i < ?ka2 \\<or> ?ka2 + ?na2 < i then i\n               else if i = ?ka2 + ?na2 then ?ka2 else Suc i\n       in ?Aa2 $$ (r, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "note swb = this"], ["proof (state)\nthis:\n  ?ka2 + ?na2 < dim_row ?Aa2 \\<Longrightarrow>\n  swb ?Aa2 ?ka2 ?na2 =\n  mat (dim_row ?Aa2) (dim_col ?Aa2)\n   (\\<lambda>(i, j).\n       let r = if i < ?ka2 \\<or> ?ka2 + ?na2 < i then i\n               else if i = ?ka2 + ?na2 then ?ka2 else Suc i\n       in ?Aa2 $$ (r, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "define swbl where \"swbl = (\\<lambda> A k n. fold (\\<lambda> i A. swb A i n) (rev [0 ..< k]) A)\""], ["proof (state)\nthis:\n  swbl = (\\<lambda>A k n. fold (\\<lambda>i A. swb A i n) (rev [0..<k]) A)\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "{"], ["proof (state)\nthis:\n  swbl = (\\<lambda>A k n. fold (\\<lambda>i A. swb A i n) (rev [0..<k]) A)\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "fix k n and A :: \"'a mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "assume k_n: \"k + n \\<le> dim_row A\""], ["proof (state)\nthis:\n  k + n \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "hence \"swbl A k n = mat (dim_row A) (dim_col A) (\\<lambda> (i,j). let r = \n      (if i < n then i + k else if i < k + n then i - n else i)\n      in A $$ (r,j))\""], ["proof (prove)\nusing this:\n  k + n \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. swbl A k n =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         let r = if i < n then i + k else if i < k + n then i - n else i\n         in A $$ (r, j))", "proof (induct k arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 + n \\<le> dim_row A \\<Longrightarrow>\n       swbl A 0 n =\n       mat (dim_row A) (dim_col A)\n        (\\<lambda>(i, j).\n            let r = if i < n then i + 0 else if i < 0 + n then i - n else i\n            in A $$ (r, j))\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   k + n \\<le> dim_row A \\<Longrightarrow>\n                   swbl A k n =\n                   mat (dim_row A) (dim_col A)\n                    (\\<lambda>(i, j).\n                        let r = if i < n then i + k\n                                else if i < k + n then i - n else i\n                        in A $$ (r, j));\n        Suc k + n \\<le> dim_row A\\<rbrakk>\n       \\<Longrightarrow> swbl A (Suc k) n =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < n then i + Suc k\nelse if i < Suc k + n then i - n else i\n                              in A $$ (r, j))", "case 0"], ["proof (state)\nthis:\n  0 + n \\<le> dim_row A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 + n \\<le> dim_row A \\<Longrightarrow>\n       swbl A 0 n =\n       mat (dim_row A) (dim_col A)\n        (\\<lambda>(i, j).\n            let r = if i < n then i + 0 else if i < 0 + n then i - n else i\n            in A $$ (r, j))\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   k + n \\<le> dim_row A \\<Longrightarrow>\n                   swbl A k n =\n                   mat (dim_row A) (dim_col A)\n                    (\\<lambda>(i, j).\n                        let r = if i < n then i + k\n                                else if i < k + n then i - n else i\n                        in A $$ (r, j));\n        Suc k + n \\<le> dim_row A\\<rbrakk>\n       \\<Longrightarrow> swbl A (Suc k) n =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < n then i + Suc k\nelse if i < Suc k + n then i - n else i\n                              in A $$ (r, j))", "thus ?case"], ["proof (prove)\nusing this:\n  0 + n \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. swbl A 0 n =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < n then i + 0 else if i < 0 + n then i - n else i\n           in A $$ (r, j))", "unfolding swbl_def"], ["proof (prove)\nusing this:\n  0 + n \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>i A. swb A i n) (rev [0..<0]) A =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < n then i + 0 else if i < 0 + n then i - n else i\n           in A $$ (r, j))", "by (intro eq_matI, auto simp: swb)"], ["proof (state)\nthis:\n  swbl A 0 n =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < n then i + 0 else if i < 0 + n then i - n else i\n         in A $$ (r, j))\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   k + n \\<le> dim_row A \\<Longrightarrow>\n                   swbl A k n =\n                   mat (dim_row A) (dim_col A)\n                    (\\<lambda>(i, j).\n                        let r = if i < n then i + k\n                                else if i < k + n then i - n else i\n                        in A $$ (r, j));\n        Suc k + n \\<le> dim_row A\\<rbrakk>\n       \\<Longrightarrow> swbl A (Suc k) n =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < n then i + Suc k\nelse if i < Suc k + n then i - n else i\n                              in A $$ (r, j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   k + n \\<le> dim_row A \\<Longrightarrow>\n                   swbl A k n =\n                   mat (dim_row A) (dim_col A)\n                    (\\<lambda>(i, j).\n                        let r = if i < n then i + k\n                                else if i < k + n then i - n else i\n                        in A $$ (r, j));\n        Suc k + n \\<le> dim_row A\\<rbrakk>\n       \\<Longrightarrow> swbl A (Suc k) n =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < n then i + Suc k\nelse if i < Suc k + n then i - n else i\n                              in A $$ (r, j))", "case (Suc k)"], ["proof (state)\nthis:\n  k + n \\<le> dim_row ?A \\<Longrightarrow>\n  swbl ?A k n =\n  mat (dim_row ?A) (dim_col ?A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < n then i + k else if i < k + n then i - n else i\n         in ?A $$ (r, j))\n  Suc k + n \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   k + n \\<le> dim_row A \\<Longrightarrow>\n                   swbl A k n =\n                   mat (dim_row A) (dim_col A)\n                    (\\<lambda>(i, j).\n                        let r = if i < n then i + k\n                                else if i < k + n then i - n else i\n                        in A $$ (r, j));\n        Suc k + n \\<le> dim_row A\\<rbrakk>\n       \\<Longrightarrow> swbl A (Suc k) n =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < n then i + Suc k\nelse if i < Suc k + n then i - n else i\n                              in A $$ (r, j))", "hence dim: \"k + n < dim_row A\""], ["proof (prove)\nusing this:\n  k + n \\<le> dim_row ?A \\<Longrightarrow>\n  swbl ?A k n =\n  mat (dim_row ?A) (dim_col ?A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < n then i + k else if i < k + n then i - n else i\n         in ?A $$ (r, j))\n  Suc k + n \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. k + n < dim_row A", "by auto"], ["proof (state)\nthis:\n  k + n < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   k + n \\<le> dim_row A \\<Longrightarrow>\n                   swbl A k n =\n                   mat (dim_row A) (dim_col A)\n                    (\\<lambda>(i, j).\n                        let r = if i < n then i + k\n                                else if i < k + n then i - n else i\n                        in A $$ (r, j));\n        Suc k + n \\<le> dim_row A\\<rbrakk>\n       \\<Longrightarrow> swbl A (Suc k) n =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < n then i + Suc k\nelse if i < Suc k + n then i - n else i\n                              in A $$ (r, j))", "have id: \"swbl A (Suc k) n = swbl (swb A k n) k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swbl A (Suc k) n = swbl (swb A k n) k n", "unfolding swbl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>i A. swb A i n) (rev [0..<Suc k]) A =\n    fold (\\<lambda>i A. swb A i n) (rev [0..<k]) (swb A k n)", "by simp"], ["proof (state)\nthis:\n  swbl A (Suc k) n = swbl (swb A k n) k n\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   k + n \\<le> dim_row A \\<Longrightarrow>\n                   swbl A k n =\n                   mat (dim_row A) (dim_col A)\n                    (\\<lambda>(i, j).\n                        let r = if i < n then i + k\n                                else if i < k + n then i - n else i\n                        in A $$ (r, j));\n        Suc k + n \\<le> dim_row A\\<rbrakk>\n       \\<Longrightarrow> swbl A (Suc k) n =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              let r = if i < n then i + Suc k\nelse if i < Suc k + n then i - n else i\n                              in A $$ (r, j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. swbl A (Suc k) n =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < n then i + Suc k\n                   else if i < Suc k + n then i - n else i\n           in A $$ (r, j))", "unfolding id swb[OF dim]"], ["proof (prove)\ngoal (1 subgoal):\n 1. swbl\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           let r = if i < k \\<or> k + n < i then i\n                   else if i = k + n then k else Suc i\n           in A $$ (r, j)))\n     k n =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           let r = if i < n then i + Suc k\n                   else if i < Suc k + n then i - n else i\n           in A $$ (r, j))", "by (subst Suc(1), insert dim, force, intro eq_matI, auto simp: less_Suc_eq_le)"], ["proof (state)\nthis:\n  swbl A (Suc k) n =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         let r = if i < n then i + Suc k\n                 else if i < Suc k + n then i - n else i\n         in A $$ (r, j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  swbl A k n =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>(i, j).\n       let r = if i < n then i + k else if i < k + n then i - n else i\n       in A $$ (r, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "}"], ["proof (state)\nthis:\n  ?ka2 + ?na2 \\<le> dim_row ?Aa2 \\<Longrightarrow>\n  swbl ?Aa2 ?ka2 ?na2 =\n  mat (dim_row ?Aa2) (dim_col ?Aa2)\n   (\\<lambda>(i, j).\n       let r = if i < ?na2 then i + ?ka2\n               else if i < ?ka2 + ?na2 then i - ?na2 else i\n       in ?Aa2 $$ (r, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "note swbl = this"], ["proof (state)\nthis:\n  ?ka2 + ?na2 \\<le> dim_row ?Aa2 \\<Longrightarrow>\n  swbl ?Aa2 ?ka2 ?na2 =\n  mat (dim_row ?Aa2) (dim_col ?Aa2)\n   (\\<lambda>(i, j).\n       let r = if i < ?na2 then i + ?ka2\n               else if i < ?ka2 + ?na2 then i - ?na2 else i\n       in ?Aa2 $$ (r, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "{"], ["proof (state)\nthis:\n  ?ka2 + ?na2 \\<le> dim_row ?Aa2 \\<Longrightarrow>\n  swbl ?Aa2 ?ka2 ?na2 =\n  mat (dim_row ?Aa2) (dim_col ?Aa2)\n   (\\<lambda>(i, j).\n       let r = if i < ?na2 then i + ?ka2\n               else if i < ?ka2 + ?na2 then i - ?na2 else i\n       in ?Aa2 $$ (r, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "fix k n and A :: \"'a mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "assume k_n: \"k + n \\<le> dim_col A\" \"dim_row A = dim_col A\""], ["proof (state)\nthis:\n  k + n \\<le> dim_col A\n  dim_row A = dim_col A\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "hence \"det (swbl A k n) = (-1)^(k*n) * det A\""], ["proof (prove)\nusing this:\n  k + n \\<le> dim_col A\n  dim_row A = dim_col A\n\ngoal (1 subgoal):\n 1. det (swbl A k n) = (- (1::'a)) ^ (k * n) * det A", "proof (induct k arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A 0 n) = (- (1::'a)) ^ (0 * n) * det A\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "case 0"], ["proof (state)\nthis:\n  0 + n \\<le> dim_col A\n  dim_row A = dim_col A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A 0 n) = (- (1::'a)) ^ (0 * n) * det A\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "thus ?case"], ["proof (prove)\nusing this:\n  0 + n \\<le> dim_col A\n  dim_row A = dim_col A\n\ngoal (1 subgoal):\n 1. det (swbl A 0 n) = (- (1::'a)) ^ (0 * n) * det A", "unfolding swbl_def"], ["proof (prove)\nusing this:\n  0 + n \\<le> dim_col A\n  dim_row A = dim_col A\n\ngoal (1 subgoal):\n 1. det (fold (\\<lambda>i A. swb A i n) (rev [0..<0]) A) =\n    (- (1::'a)) ^ (0 * n) * det A", "by auto"], ["proof (state)\nthis:\n  det (swbl A 0 n) = (- (1::'a)) ^ (0 * n) * det A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>k + n \\<le> dim_col ?A; dim_row ?A = dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> det (swbl ?A k n) = (- (1::'a)) ^ (k * n) * det ?A\n  Suc k + n \\<le> dim_col A\n  dim_row A = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "hence dim: \"k + n < dim_row A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>k + n \\<le> dim_col ?A; dim_row ?A = dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> det (swbl ?A k n) = (- (1::'a)) ^ (k * n) * det ?A\n  Suc k + n \\<le> dim_col A\n  dim_row A = dim_col A\n\ngoal (1 subgoal):\n 1. k + n < dim_row A", "by auto"], ["proof (state)\nthis:\n  k + n < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "have id: \"swbl A (Suc k) n = swbl (swb A k n) k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swbl A (Suc k) n = swbl (swb A k n) k n", "unfolding swbl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>i A. swb A i n) (rev [0..<Suc k]) A =\n    fold (\\<lambda>i A. swb A i n) (rev [0..<k]) (swb A k n)", "by simp"], ["proof (state)\nthis:\n  swbl A (Suc k) n = swbl (swb A k n) k n\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "have det: \"det (swb A k n) = (-1)^n * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swb A k n) = (- (1::'a)) ^ n * det A", "unfolding swb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (sw A (map (\\<lambda>j. (j, Suc j)) [k..<k + n])) =\n    (- (1::'a)) ^ n * det A", "by (subst sw, insert Suc(2-), auto)"], ["proof (state)\nthis:\n  det (swb A k n) = (- (1::'a)) ^ n * det A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k + n \\<le> dim_col A;\n                    dim_row A = dim_col A\\<rbrakk>\n                   \\<Longrightarrow> det (swbl A k n) =\n                                     (- (1::'a)) ^ (k * n) * det A;\n        Suc k + n \\<le> dim_col A; dim_row A = dim_col A\\<rbrakk>\n       \\<Longrightarrow> det (swbl A (Suc k) n) =\n                         (- (1::'a)) ^ (Suc k * n) * det A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swbl A (Suc k) n) = (- (1::'a)) ^ (Suc k * n) * det A", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swbl (swb A k n) k n) = (- (1::'a)) ^ (Suc k * n) * det A", "by (subst Suc(1), insert Suc(2-), auto simp: det, auto simp: swb power_add)"], ["proof (state)\nthis:\n  det (swbl A (Suc k) n) = (- (1::'a)) ^ (Suc k * n) * det A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (swbl A k n) = (- (1::'a)) ^ (k * n) * det A\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ka2 + ?na2 \\<le> dim_col ?Aa2;\n   dim_row ?Aa2 = dim_col ?Aa2\\<rbrakk>\n  \\<Longrightarrow> det (swbl ?Aa2 ?ka2 ?na2) =\n                    (- (1::'a)) ^ (?ka2 * ?na2) * det ?Aa2\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "note det_swbl = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ka2 + ?na2 \\<le> dim_col ?Aa2;\n   dim_row ?Aa2 = dim_col ?Aa2\\<rbrakk>\n  \\<Longrightarrow> det (swbl ?Aa2 ?ka2 ?na2) =\n                    (- (1::'a)) ^ (?ka2 * ?na2) * det ?Aa2\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "from assms"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat m m\n  k + n \\<le> m", "have dim: \"dim_row A = dim_col A\" \"k + n \\<le> dim_col A\" \"k + n \\<le> dim_row A\" \"dim_col A = m\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m m\n  k + n \\<le> m\n\ngoal (1 subgoal):\n 1. (dim_row A = dim_col A &&& k + n \\<le> dim_col A) &&&\n    k + n \\<le> dim_row A &&& dim_col A = m", "by auto"], ["proof (state)\nthis:\n  dim_row A = dim_col A\n  k + n \\<le> dim_col A\n  k + n \\<le> dim_row A\n  dim_col A = m\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "from arg_cong[OF det_swbl[OF dim(2,1), unfolded swbl[OF dim(3)], unfolded Let_def dim], \n      of  \"\\<lambda> x. (-1)^(k*n) * x\"]"], ["proof (chain)\npicking this:\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < n then i + k else if i < k + n then i - n else i, j))) =\n  (- (1::'a)) ^ (k * n) * ((- (1::'a)) ^ (k * n) * det A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < n then i + k else if i < k + n then i - n else i, j))) =\n  (- (1::'a)) ^ (k * n) * ((- (1::'a)) ^ (k * n) * det A)\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k else if i < k + n then i - n else i, j)))", "by simp"], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < n then i + k else if i < k + n then i - n else i, j)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swap_rows: assumes A: \"A \\<in> carrier_mat (k + n) (k + n)\" \n  shows \"det A = (-1)^(k * n) * det (mat (k + n) (k + n) (\\<lambda> (i,j). \n    A $$ ((if i < k then i + n else i - k),j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (if i < k then i + n else i - k, j)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (if i < k then i + n else i - k, j)))", "have le: \"n + k \\<le> k + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + k \\<le> k + n", "by simp"], ["proof (state)\nthis:\n  n + k \\<le> k + n\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (if i < k then i + n else i - k, j)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (if i < k then i + n else i - k, j)))", "unfolding det_swap_initial_rows[OF A le]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (n * k) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j).\n              A $$\n              (if i < k then i + n else if i < n + k then i - k else i,\n               j))) =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (if i < k then i + n else i - k, j)))", "by (intro arg_cong2[of _ _ _ _ \"\\<lambda> x y. ((-1)^x * det y)\"], force, intro eq_matI, auto)"], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat (k + n) (k + n)\n        (\\<lambda>(i, j). A $$ (if i < k then i + n else i - k, j)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swap_final_rows: assumes A: \"A \\<in> carrier_mat m m\"\n  and m: \"m = l + k + n\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (if i < l then i else if i < l + n then i + k else i - n, j)))\" \n    (is \"_ = _ * det ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "(* l k n -swap-rows\\<rightarrow> k n l -swap-initial\\<rightarrow> n k l -swap-rows\\<rightarrow> l n k *)"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have m1: \"m = (k + n) + l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = k + n + l", "using m"], ["proof (prove)\nusing this:\n  m = l + k + n\n\ngoal (1 subgoal):\n 1. m = k + n + l", "by simp"], ["proof (state)\nthis:\n  m = k + n + l\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have m2: \"k + n \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k + n \\<le> m", "using m"], ["proof (prove)\nusing this:\n  m = l + k + n\n\ngoal (1 subgoal):\n 1. k + n \\<le> m", "by simp"], ["proof (state)\nthis:\n  k + n \\<le> m\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have m3: \"m = l + (n + k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = l + (n + k)", "using m"], ["proof (prove)\nusing this:\n  m = l + k + n\n\ngoal (1 subgoal):\n 1. m = l + (n + k)", "by simp"], ["proof (state)\nthis:\n  m = l + (n + k)\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "define M where \"M = ?M\""], ["proof (state)\nthis:\n  M =\n  mat m m\n   (\\<lambda>(i, j).\n       A $$ (if i < l then i else if i < l + n then i + k else i - n, j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "let ?M1 = \"mat m m (\\<lambda>(i, j). A $$ (if i < k + n then i + l else i - (k + n), j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "let ?M2 = \"mat m m\n          (\\<lambda>(i, j). A $$ (if i < n then i + k + l else if i < k + n then i - n + l else i - (k + n), j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have M2: \"?M2 \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat m m\n     (\\<lambda>(i, j).\n         A $$\n         (if i < n then i + k + l\n          else if i < k + n then i - n + l else i - (k + n),\n          j))\n    \\<in> carrier_mat m m", "by auto"], ["proof (state)\nthis:\n  mat m m\n   (\\<lambda>(i, j).\n       A $$\n       (if i < n then i + k + l\n        else if i < k + n then i - n + l else i - (k + n),\n        j))\n  \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have \"det A = (- 1) ^ ((k + n) * l) * det ?M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ ((k + n) * l) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$ (if i < k + n then i + l else i - (k + n), j)))", "unfolding det_swap_rows[OF A[unfolded m1]] m1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ ((k + n) * l) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$ (if i < k + n then i + l else i - (k + n), j))) =\n    (- (1::'a)) ^ ((k + n) * l) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$ (if i < k + n then i + l else i - (k + n), j)))", "by simp"], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ ((k + n) * l) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$ (if i < k + n then i + l else i - (k + n), j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "also"], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ ((k + n) * l) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$ (if i < k + n then i + l else i - (k + n), j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have \"det ?M1 = (- 1) ^ (k * n) * det ?M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat m m\n          (\\<lambda>(i, j).\n              A $$ (if i < k + n then i + l else i - (k + n), j))) =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k + l\n               else if i < k + n then i - n + l else i - (k + n),\n               j)))", "by (subst det_swap_initial_rows[OF _ m2], force, rule arg_cong[of _ _ \"\\<lambda> x. _ * det x\"],\n    rule eq_matI, auto simp: m)"], ["proof (state)\nthis:\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$ (if i < k + n then i + l else i - (k + n), j))) =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < n then i + k + l\n             else if i < k + n then i - n + l else i - (k + n),\n             j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "also"], ["proof (state)\nthis:\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$ (if i < k + n then i + l else i - (k + n), j))) =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < n then i + k + l\n             else if i < k + n then i - n + l else i - (k + n),\n             j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have \"det ?M2 = (- 1) ^ (l * (n + k)) * det M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < n then i + k + l\n               else if i < k + n then i - n + l else i - (k + n),\n               j))) =\n    (- (1::'a)) ^ (l * (n + k)) * det M", "unfolding M_def det_swap_rows[OF M2[unfolded m3], folded m3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (l * (n + k)) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              mat m m\n               (\\<lambda>(i, j).\n                   A $$\n                   (if i < n then i + k + l\n                    else if i < k + n then i - n + l else i - (k + n),\n                    j)) $$\n              (if i < l then i + (n + k) else i - l, j))) =\n    (- (1::'a)) ^ (l * (n + k)) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "by (rule arg_cong[of _ _ \"\\<lambda> x. _ * det x\"], rule eq_matI, auto simp: m)"], ["proof (state)\nthis:\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < n then i + k + l\n             else if i < k + n then i - n + l else i - (k + n),\n             j))) =\n  (- (1::'a)) ^ (l * (n + k)) * det M\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "finally"], ["proof (chain)\npicking this:\n  det A =\n  (- (1::'a)) ^ ((k + n) * l) *\n  ((- (1::'a)) ^ (k * n) * ((- (1::'a)) ^ (l * (n + k)) * det M))", "have \"det A = (-1) ^ ((k + n) * l + (k * n) + l * (n + k)) * det M\" (is \"_ = ?b ^ _ * _\")"], ["proof (prove)\nusing this:\n  det A =\n  (- (1::'a)) ^ ((k + n) * l) *\n  ((- (1::'a)) ^ (k * n) * ((- (1::'a)) ^ (l * (n + k)) * det M))\n\ngoal (1 subgoal):\n 1. det A = (- (1::'a)) ^ ((k + n) * l + k * n + l * (n + k)) * det M", "by (simp add: power_add)"], ["proof (state)\nthis:\n  det A = (- (1::'a)) ^ ((k + n) * l + k * n + l * (n + k)) * det M\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "also"], ["proof (state)\nthis:\n  det A = (- (1::'a)) ^ ((k + n) * l + k * n + l * (n + k)) * det M\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have \"(k + n) * l + (k * n) + l * (n + k) = 2 * (l * (n + k)) + k * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k + n) * l + k * n + l * (n + k) = 2 * (l * (n + k)) + k * n", "by simp"], ["proof (state)\nthis:\n  (k + n) * l + k * n + l * (n + k) = 2 * (l * (n + k)) + k * n\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "also"], ["proof (state)\nthis:\n  (k + n) * l + k * n + l * (n + k) = 2 * (l * (n + k)) + k * n\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "have \"?b ^ \\<dots> = ?b ^ (k * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (2 * (l * (n + k)) + k * n) = (- (1::'a)) ^ (k * n)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  (- (1::'a)) ^ (2 * (l * (n + k)) + k * n) = (- (1::'a)) ^ (k * n)\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "finally"], ["proof (chain)\npicking this:\n  det A = (- (1::'a)) ^ (k * n) * det M", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = (- (1::'a)) ^ (k * n) * det M\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "unfolding M_def"], ["proof (prove)\nusing this:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < l then i else if i < l + n then i + k else i - n, j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "."], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (if i < l then i else if i < l + n then i + k else i - n, j)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swap_final_cols: assumes A: \"A \\<in> carrier_mat m m\"\n  and m: \"m = l + k + n\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (i, if j < l then j else if j < l + n then j + k else j - n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "have \"det A = det (A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", "unfolding det_transpose[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A", ".."], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "also"], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "have \"\\<dots> = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A\\<^sup>T $$ (if i < l then i else if i < l + n then i + k else i - n, j)))\" \n    (is \"_ = _ * det ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A\\<^sup>T =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A\\<^sup>T $$\n              (if i < l then i else if i < l + n then i + k else i - n, j)))", "by (rule det_swap_final_rows[OF _ m], insert A, auto)"], ["proof (state)\nthis:\n  det A\\<^sup>T =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A\\<^sup>T $$\n            (if i < l then i else if i < l + n then i + k else i - n, j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "also"], ["proof (state)\nthis:\n  det A\\<^sup>T =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A\\<^sup>T $$\n            (if i < l then i else if i < l + n then i + k else i - n, j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "have \"det ?M = det (?M\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat m m\n          (\\<lambda>(i, j).\n              A\\<^sup>T $$\n              (if i < l then i else if i < l + n then i + k else i - n,\n               j))) =\n    det (mat m m\n          (\\<lambda>(i, j).\n              A\\<^sup>T $$\n              (if i < l then i else if i < l + n then i + k else i - n,\n               j)))\\<^sup>T", "by (subst det_transpose, auto)"], ["proof (state)\nthis:\n  det (mat m m\n        (\\<lambda>(i, j).\n            A\\<^sup>T $$\n            (if i < l then i else if i < l + n then i + k else i - n, j))) =\n  det (mat m m\n        (\\<lambda>(i, j).\n            A\\<^sup>T $$\n            (if i < l then i else if i < l + n then i + k else i - n,\n             j)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "also"], ["proof (state)\nthis:\n  det (mat m m\n        (\\<lambda>(i, j).\n            A\\<^sup>T $$\n            (if i < l then i else if i < l + n then i + k else i - n, j))) =\n  det (mat m m\n        (\\<lambda>(i, j).\n            A\\<^sup>T $$\n            (if i < l then i else if i < l + n then i + k else i - n,\n             j)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "have \"?M\\<^sup>T = mat m m (\\<lambda>(i, j). A $$ (i, if j < l then j else if j < l + n then j + k else j - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat m m\n      (\\<lambda>(i, j).\n          A\\<^sup>T $$\n          (if i < l then i else if i < l + n then i + k else i - n,\n           j)))\\<^sup>T =\n    mat m m\n     (\\<lambda>(i, j).\n         A $$ (i, if j < l then j else if j < l + n then j + k else j - n))", "unfolding transpose_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_col\n          (mat m m\n            (\\<lambda>(i, j).\n                mat (dim_col A) (dim_row A)\n                 (\\<lambda>(i, j). A $$ (j, i)) $$\n                (if i < l then i else if i < l + n then i + k else i - n,\n                 j))))\n     (dim_row\n       (mat m m\n         (\\<lambda>(i, j).\n             mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n             (if i < l then i else if i < l + n then i + k else i - n, j))))\n     (\\<lambda>(i, j).\n         mat m m\n          (\\<lambda>(i, j).\n              mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n              (if i < l then i else if i < l + n then i + k else i - n,\n               j)) $$\n         (j, i)) =\n    mat m m\n     (\\<lambda>(i, j).\n         A $$ (i, if j < l then j else if j < l + n then j + k else j - n))", "using A m"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m m\n  m = l + k + n\n\ngoal (1 subgoal):\n 1. mat (dim_col\n          (mat m m\n            (\\<lambda>(i, j).\n                mat (dim_col A) (dim_row A)\n                 (\\<lambda>(i, j). A $$ (j, i)) $$\n                (if i < l then i else if i < l + n then i + k else i - n,\n                 j))))\n     (dim_row\n       (mat m m\n         (\\<lambda>(i, j).\n             mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n             (if i < l then i else if i < l + n then i + k else i - n, j))))\n     (\\<lambda>(i, j).\n         mat m m\n          (\\<lambda>(i, j).\n              mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n              (if i < l then i else if i < l + n then i + k else i - n,\n               j)) $$\n         (j, i)) =\n    mat m m\n     (\\<lambda>(i, j).\n         A $$ (i, if j < l then j else if j < l + n then j + k else j - n))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  (mat m m\n    (\\<lambda>(i, j).\n        A\\<^sup>T $$\n        (if i < l then i else if i < l + n then i + k else i - n,\n         j)))\\<^sup>T =\n  mat m m\n   (\\<lambda>(i, j).\n       A $$ (i, if j < l then j else if j < l + n then j + k else j - n))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "finally"], ["proof (chain)\npicking this:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (i, if j < l then j else if j < l + n then j + k else j - n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (i, if j < l then j else if j < l + n then j + k else j - n)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < l then j else if j < l + n then j + k else j - n)))", "."], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (i, if j < l then j else if j < l + n then j + k else j - n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swap_initial_cols: assumes A: \"A \\<in> carrier_mat m m\" \n  and lt: \"k + n \\<le> m\" \n  shows \"det A = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(i, j). A $$ (i, if j < n then j + k else if j < k + n then j - n else j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "have \"det A = det (A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", "unfolding det_transpose[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A", ".."], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "also"], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "have \"\\<dots> = (- 1) ^ (k * n) *\n    det (mat m m (\\<lambda>(j, i). A\\<^sup>T $$ (if j < n then j + k else if j < k + n then j - n else j,i)))\" \n    (is \"_ = _ * det ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A\\<^sup>T =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(j, i).\n              A\\<^sup>T $$\n              (if j < n then j + k else if j < k + n then j - n else j, i)))", "by (rule det_swap_initial_rows[OF _ lt], insert A, auto)"], ["proof (state)\nthis:\n  det A\\<^sup>T =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(j, i).\n            A\\<^sup>T $$\n            (if j < n then j + k else if j < k + n then j - n else j, i)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "also"], ["proof (state)\nthis:\n  det A\\<^sup>T =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(j, i).\n            A\\<^sup>T $$\n            (if j < n then j + k else if j < k + n then j - n else j, i)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "have \"det ?M = det (?M\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat m m\n          (\\<lambda>(j, i).\n              A\\<^sup>T $$\n              (if j < n then j + k else if j < k + n then j - n else j,\n               i))) =\n    det (mat m m\n          (\\<lambda>(j, i).\n              A\\<^sup>T $$\n              (if j < n then j + k else if j < k + n then j - n else j,\n               i)))\\<^sup>T", "by (subst det_transpose, auto)"], ["proof (state)\nthis:\n  det (mat m m\n        (\\<lambda>(j, i).\n            A\\<^sup>T $$\n            (if j < n then j + k else if j < k + n then j - n else j, i))) =\n  det (mat m m\n        (\\<lambda>(j, i).\n            A\\<^sup>T $$\n            (if j < n then j + k else if j < k + n then j - n else j,\n             i)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "also"], ["proof (state)\nthis:\n  det (mat m m\n        (\\<lambda>(j, i).\n            A\\<^sup>T $$\n            (if j < n then j + k else if j < k + n then j - n else j, i))) =\n  det (mat m m\n        (\\<lambda>(j, i).\n            A\\<^sup>T $$\n            (if j < n then j + k else if j < k + n then j - n else j,\n             i)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "have \"?M\\<^sup>T = mat m m (\\<lambda>(i, j). A $$ (i, if j < n then j + k else if j < k + n then j - n else j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat m m\n      (\\<lambda>(j, i).\n          A\\<^sup>T $$\n          (if j < n then j + k else if j < k + n then j - n else j,\n           i)))\\<^sup>T =\n    mat m m\n     (\\<lambda>(i, j).\n         A $$ (i, if j < n then j + k else if j < k + n then j - n else j))", "unfolding transpose_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_col\n          (mat m m\n            (\\<lambda>(j, i).\n                mat (dim_col A) (dim_row A)\n                 (\\<lambda>(i, j). A $$ (j, i)) $$\n                (if j < n then j + k else if j < k + n then j - n else j,\n                 i))))\n     (dim_row\n       (mat m m\n         (\\<lambda>(j, i).\n             mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n             (if j < n then j + k else if j < k + n then j - n else j, i))))\n     (\\<lambda>(i, j).\n         mat m m\n          (\\<lambda>(j, i).\n              mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n              (if j < n then j + k else if j < k + n then j - n else j,\n               i)) $$\n         (j, i)) =\n    mat m m\n     (\\<lambda>(i, j).\n         A $$ (i, if j < n then j + k else if j < k + n then j - n else j))", "using A lt"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m m\n  k + n \\<le> m\n\ngoal (1 subgoal):\n 1. mat (dim_col\n          (mat m m\n            (\\<lambda>(j, i).\n                mat (dim_col A) (dim_row A)\n                 (\\<lambda>(i, j). A $$ (j, i)) $$\n                (if j < n then j + k else if j < k + n then j - n else j,\n                 i))))\n     (dim_row\n       (mat m m\n         (\\<lambda>(j, i).\n             mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n             (if j < n then j + k else if j < k + n then j - n else j, i))))\n     (\\<lambda>(i, j).\n         mat m m\n          (\\<lambda>(j, i).\n              mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)) $$\n              (if j < n then j + k else if j < k + n then j - n else j,\n               i)) $$\n         (j, i)) =\n    mat m m\n     (\\<lambda>(i, j).\n         A $$ (i, if j < n then j + k else if j < k + n then j - n else j))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  (mat m m\n    (\\<lambda>(j, i).\n        A\\<^sup>T $$\n        (if j < n then j + k else if j < k + n then j - n else j,\n         i)))\\<^sup>T =\n  mat m m\n   (\\<lambda>(i, j).\n       A $$ (i, if j < n then j + k else if j < k + n then j - n else j))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "finally"], ["proof (chain)\npicking this:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (i, if j < n then j + k else if j < k + n then j - n else j)))", "show ?thesis"], ["proof (prove)\nusing this:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (i, if j < n then j + k else if j < k + n then j - n else j)))\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat m m\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < n then j + k else if j < k + n then j - n else j)))", "."], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat m m\n        (\\<lambda>(i, j).\n            A $$\n            (i, if j < n then j + k else if j < k + n then j - n else j)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swap_cols: assumes A: \"A \\<in> carrier_mat (k + n) (k + n)\" \n  shows \"det A = (-1)^(k * n) * det (mat (k + n) (k + n) (\\<lambda> (i,j). \n   A $$ (i,(if j < k then j + n else j - k))))\" (is \"_ = _ * det ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (i, if j < k then j + n else j - k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (i, if j < k then j + n else j - k)))", "have le: \"n + k \\<le> k + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + k \\<le> k + n", "by simp"], ["proof (state)\nthis:\n  n + k \\<le> k + n\n\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (i, if j < k then j + n else j - k)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (i, if j < k then j + n else j - k)))", "unfolding det_swap_initial_cols[OF A le]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (n * k) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j).\n              A $$\n              (i, if j < k then j + n\n                  else if j < n + k then j - k else j))) =\n    (- (1::'a)) ^ (k * n) *\n    det (mat (k + n) (k + n)\n          (\\<lambda>(i, j). A $$ (i, if j < k then j + n else j - k)))", "by (intro arg_cong2[of _ _ _ _ \"\\<lambda> x y. ((-1)^x * det y)\"], force, intro eq_matI, auto)"], ["proof (state)\nthis:\n  det A =\n  (- (1::'a)) ^ (k * n) *\n  det (mat (k + n) (k + n)\n        (\\<lambda>(i, j). A $$ (i, if j < k then j + n else j - k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_four_block_mat_upper_right_zero: fixes A1 :: \"'a :: idom mat\" \n  assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A20: \"A2 = (0\\<^sub>m n m)\" and A3: \"A3 \\<in> carrier_mat m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"  \nshows \"det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "using assms(2-)"], ["proof (prove)\nusing this:\n  A2 = 0\\<^sub>m n m\n  A3 \\<in> carrier_mat m n\n  A4 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "proof (induct m arbitrary: A2 A3 A4)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A2 A3 A4.\n       \\<lbrakk>A2 = 0\\<^sub>m n 0; A3 \\<in> carrier_mat 0 n;\n        A4 \\<in> carrier_mat 0 0\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n 2. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "case (0 A2 A3 A4)"], ["proof (state)\nthis:\n  A2 = 0\\<^sub>m n 0\n  A3 \\<in> carrier_mat 0 n\n  A4 \\<in> carrier_mat 0 0\n\ngoal (2 subgoals):\n 1. \\<And>A2 A3 A4.\n       \\<lbrakk>A2 = 0\\<^sub>m n 0; A3 \\<in> carrier_mat 0 n;\n        A4 \\<in> carrier_mat 0 0\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n 2. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "hence *: \"four_block_mat A1 A2 A3 A4 = A1\""], ["proof (prove)\nusing this:\n  A2 = 0\\<^sub>m n 0\n  A3 \\<in> carrier_mat 0 n\n  A4 \\<in> carrier_mat 0 0\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 = A1", "using A1"], ["proof (prove)\nusing this:\n  A2 = 0\\<^sub>m n 0\n  A3 \\<in> carrier_mat 0 n\n  A4 \\<in> carrier_mat 0 0\n  A1 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 = A1", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  four_block_mat A1 A2 A3 A4 = A1\n\ngoal (2 subgoals):\n 1. \\<And>A2 A3 A4.\n       \\<lbrakk>A2 = 0\\<^sub>m n 0; A3 \\<in> carrier_mat 0 n;\n        A4 \\<in> carrier_mat 0 0\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n 2. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from 0"], ["proof (chain)\npicking this:\n  A2 = 0\\<^sub>m n 0\n  A3 \\<in> carrier_mat 0 n\n  A4 \\<in> carrier_mat 0 0", "have 4: \"A4 = 1\\<^sub>m 0\""], ["proof (prove)\nusing this:\n  A2 = 0\\<^sub>m n 0\n  A3 \\<in> carrier_mat 0 n\n  A4 \\<in> carrier_mat 0 0\n\ngoal (1 subgoal):\n 1. A4 = 1\\<^sub>m 0", "by auto"], ["proof (state)\nthis:\n  A4 = 1\\<^sub>m 0\n\ngoal (2 subgoals):\n 1. \\<And>A2 A3 A4.\n       \\<lbrakk>A2 = 0\\<^sub>m n 0; A3 \\<in> carrier_mat 0 n;\n        A4 \\<in> carrier_mat 0 0\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n 2. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A1 = det A1 * det A4", "unfolding 4"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A1 = det A1 * det (1\\<^sub>m 0)", "by simp"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "case (Suc m A2 A3 A4)"], ["proof (state)\nthis:\n  \\<lbrakk>?A2.0 = 0\\<^sub>m n m; ?A3.0 \\<in> carrier_mat m n;\n   ?A4.0 \\<in> carrier_mat m m\\<rbrakk>\n  \\<Longrightarrow> det (four_block_mat A1 ?A2.0 ?A3.0 ?A4.0) =\n                    det A1 * det ?A4.0\n  A2 = 0\\<^sub>m n (Suc m)\n  A3 \\<in> carrier_mat (Suc m) n\n  A4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?m = \"Suc m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>?A2.0 = 0\\<^sub>m n m; ?A3.0 \\<in> carrier_mat m n;\n   ?A4.0 \\<in> carrier_mat m m\\<rbrakk>\n  \\<Longrightarrow> det (four_block_mat A1 ?A2.0 ?A3.0 ?A4.0) =\n                    det A1 * det ?A4.0\n  A2 = 0\\<^sub>m n (Suc m)\n  A3 \\<in> carrier_mat (Suc m) n\n  A4 \\<in> carrier_mat (Suc m) (Suc m)", "have A2: \"A2 \\<in> carrier_mat n ?m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?A2.0 = 0\\<^sub>m n m; ?A3.0 \\<in> carrier_mat m n;\n   ?A4.0 \\<in> carrier_mat m m\\<rbrakk>\n  \\<Longrightarrow> det (four_block_mat A1 ?A2.0 ?A3.0 ?A4.0) =\n                    det A1 * det ?A4.0\n  A2 = 0\\<^sub>m n (Suc m)\n  A3 \\<in> carrier_mat (Suc m) n\n  A4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. A2 \\<in> carrier_mat n (Suc m)", "by auto"], ["proof (state)\nthis:\n  A2 \\<in> carrier_mat n (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "note A20 = Suc(2)"], ["proof (state)\nthis:\n  A2 = 0\\<^sub>m n (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "note A34 = Suc(3-4)"], ["proof (state)\nthis:\n  A3 \\<in> carrier_mat (Suc m) n\n  A4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?A = \"four_block_mat A1 A2 A3 A4\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?P = \"\\<lambda> B3 B4 v k. v \\<noteq> 0 \\<and> v * det ?A = det (four_block_mat A1 A2 B3 B4)\n    \\<and> v * det A4 = det B4 \\<and> B3 \\<in> carrier_mat ?m n \\<and> B4 \\<in> carrier_mat ?m ?m \\<and> (\\<forall> i < k. B4 $$ (i,m) = 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"k \\<le> m \\<Longrightarrow> \\<exists> B3 B4 v. ?P B3 B4 v k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> m \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<k. B4 $$ (i, m) = (0::'a))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> m \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<0. B4 $$ (i, m) = (0::'a))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<exists>B3 B4 v.\n                   v \\<noteq> (0::'a) \\<and>\n                   v * det (four_block_mat A1 A2 A3 A4) =\n                   det (four_block_mat A1 A2 B3 B4) \\<and>\n                   v * det A4 = det B4 \\<and>\n                   B3 \\<in> carrier_mat (Suc m) n \\<and>\n                   B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                   (\\<forall>i<k. B4 $$ (i, m) = (0::'a));\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B3 B4 v.\n                            v \\<noteq> (0::'a) \\<and>\n                            v * det (four_block_mat A1 A2 A3 A4) =\n                            det (four_block_mat A1 A2 B3 B4) \\<and>\n                            v * det A4 = det B4 \\<and>\n                            B3 \\<in> carrier_mat (Suc m) n \\<and>\n                            B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                            (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. 0 \\<le> m \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<0. B4 $$ (i, m) = (0::'a))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<exists>B3 B4 v.\n                   v \\<noteq> (0::'a) \\<and>\n                   v * det (four_block_mat A1 A2 A3 A4) =\n                   det (four_block_mat A1 A2 B3 B4) \\<and>\n                   v * det A4 = det B4 \\<and>\n                   B3 \\<in> carrier_mat (Suc m) n \\<and>\n                   B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                   (\\<forall>i<k. B4 $$ (i, m) = (0::'a));\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B3 B4 v.\n                            v \\<noteq> (0::'a) \\<and>\n                            v * det (four_block_mat A1 A2 A3 A4) =\n                            det (four_block_mat A1 A2 B3 B4) \\<and>\n                            v * det A4 = det B4 \\<and>\n                            B3 \\<in> carrier_mat (Suc m) n \\<and>\n                            B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                            (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have \"?P A3 A4 1 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<noteq> (0::'a) \\<and>\n    (1::'a) * det (four_block_mat A1 A2 A3 A4) =\n    det (four_block_mat A1 A2 A3 A4) \\<and>\n    (1::'a) * det A4 = det A4 \\<and>\n    A3 \\<in> carrier_mat (Suc m) n \\<and>\n    A4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n    (\\<forall>i<0. A4 $$ (i, m) = (0::'a))", "using A34"], ["proof (prove)\nusing this:\n  A3 \\<in> carrier_mat (Suc m) n\n  A4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. (1::'a) \\<noteq> (0::'a) \\<and>\n    (1::'a) * det (four_block_mat A1 A2 A3 A4) =\n    det (four_block_mat A1 A2 A3 A4) \\<and>\n    (1::'a) * det A4 = det A4 \\<and>\n    A3 \\<in> carrier_mat (Suc m) n \\<and>\n    A4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n    (\\<forall>i<0. A4 $$ (i, m) = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (1::'a) \\<noteq> (0::'a) \\<and>\n  (1::'a) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 A3 A4) \\<and>\n  (1::'a) * det A4 = det A4 \\<and>\n  A3 \\<in> carrier_mat (Suc m) n \\<and>\n  A4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<0. A4 $$ (i, m) = (0::'a))\n\ngoal (2 subgoals):\n 1. 0 \\<le> m \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<0. B4 $$ (i, m) = (0::'a))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<exists>B3 B4 v.\n                   v \\<noteq> (0::'a) \\<and>\n                   v * det (four_block_mat A1 A2 A3 A4) =\n                   det (four_block_mat A1 A2 B3 B4) \\<and>\n                   v * det A4 = det B4 \\<and>\n                   B3 \\<in> carrier_mat (Suc m) n \\<and>\n                   B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                   (\\<forall>i<k. B4 $$ (i, m) = (0::'a));\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B3 B4 v.\n                            v \\<noteq> (0::'a) \\<and>\n                            v * det (four_block_mat A1 A2 A3 A4) =\n                            det (four_block_mat A1 A2 B3 B4) \\<and>\n                            v * det A4 = det B4 \\<and>\n                            B3 \\<in> carrier_mat (Suc m) n \\<and>\n                            B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                            (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "thus ?case"], ["proof (prove)\nusing this:\n  (1::'a) \\<noteq> (0::'a) \\<and>\n  (1::'a) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 A3 A4) \\<and>\n  (1::'a) * det A4 = det A4 \\<and>\n  A3 \\<in> carrier_mat (Suc m) n \\<and>\n  A4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<0. A4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<0. B4 $$ (i, m) = (0::'a))", "by blast"], ["proof (state)\nthis:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<0. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<exists>B3 B4 v.\n                   v \\<noteq> (0::'a) \\<and>\n                   v * det (four_block_mat A1 A2 A3 A4) =\n                   det (four_block_mat A1 A2 B3 B4) \\<and>\n                   v * det A4 = det B4 \\<and>\n                   B3 \\<in> carrier_mat (Suc m) n \\<and>\n                   B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                   (\\<forall>i<k. B4 $$ (i, m) = (0::'a));\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B3 B4 v.\n                            v \\<noteq> (0::'a) \\<and>\n                            v * det (four_block_mat A1 A2 A3 A4) =\n                            det (four_block_mat A1 A2 B3 B4) \\<and>\n                            v * det A4 = det B4 \\<and>\n                            B3 \\<in> carrier_mat (Suc m) n \\<and>\n                            B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                            (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<exists>B3 B4 v.\n                   v \\<noteq> (0::'a) \\<and>\n                   v * det (four_block_mat A1 A2 A3 A4) =\n                   det (four_block_mat A1 A2 B3 B4) \\<and>\n                   v * det A4 = det B4 \\<and>\n                   B3 \\<in> carrier_mat (Suc m) n \\<and>\n                   B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                   (\\<forall>i<k. B4 $$ (i, m) = (0::'a));\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B3 B4 v.\n                            v \\<noteq> (0::'a) \\<and>\n                            v * det (four_block_mat A1 A2 A3 A4) =\n                            det (four_block_mat A1 A2 B3 B4) \\<and>\n                            v * det A4 = det B4 \\<and>\n                            B3 \\<in> carrier_mat (Suc m) n \\<and>\n                            B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                            (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> m \\<Longrightarrow>\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<k. B4 $$ (i, m) = (0::'a))\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<exists>B3 B4 v.\n                   v \\<noteq> (0::'a) \\<and>\n                   v * det (four_block_mat A1 A2 A3 A4) =\n                   det (four_block_mat A1 A2 B3 B4) \\<and>\n                   v * det A4 = det B4 \\<and>\n                   B3 \\<in> carrier_mat (Suc m) n \\<and>\n                   B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                   (\\<forall>i<k. B4 $$ (i, m) = (0::'a));\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B3 B4 v.\n                            v \\<noteq> (0::'a) \\<and>\n                            v * det (four_block_mat A1 A2 A3 A4) =\n                            det (four_block_mat A1 A2 B3 B4) \\<and>\n                            v * det A4 = det B4 \\<and>\n                            B3 \\<in> carrier_mat (Suc m) n \\<and>\n                            B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                            (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "then"], ["proof (chain)\npicking this:\n  k \\<le> m \\<Longrightarrow>\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<k. B4 $$ (i, m) = (0::'a))\n  Suc k \\<le> m", "obtain B3 B4 v where v: \"v \\<noteq> 0\" and det: \"v * det ?A = \n      det (four_block_mat A1 A2 B3 B4)\" \"v * det A4 = det B4\" \n     and B3: \"B3 \\<in> carrier_mat ?m n\" and B4: \"B4 \\<in> carrier_mat ?m ?m\"  and 0: \"\\<forall> i < k. B4 $$ (i,m) = 0\""], ["proof (prove)\nusing this:\n  k \\<le> m \\<Longrightarrow>\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<k. B4 $$ (i, m) = (0::'a))\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<And>v B3 B4.\n        \\<lbrakk>v \\<noteq> (0::'a);\n         v * det (four_block_mat A1 A2 A3 A4) =\n         det (four_block_mat A1 A2 B3 B4);\n         v * det A4 = det B4; B3 \\<in> carrier_mat (Suc m) n;\n         B4 \\<in> carrier_mat (Suc m) (Suc m);\n         \\<forall>i<k. B4 $$ (i, m) = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> (0::'a)\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<exists>B3 B4 v.\n                   v \\<noteq> (0::'a) \\<and>\n                   v * det (four_block_mat A1 A2 A3 A4) =\n                   det (four_block_mat A1 A2 B3 B4) \\<and>\n                   v * det A4 = det B4 \\<and>\n                   B3 \\<in> carrier_mat (Suc m) n \\<and>\n                   B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                   (\\<forall>i<k. B4 $$ (i, m) = (0::'a));\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B3 B4 v.\n                            v \\<noteq> (0::'a) \\<and>\n                            v * det (four_block_mat A1 A2 A3 A4) =\n                            det (four_block_mat A1 A2 B3 B4) \\<and>\n                            v * det A4 = det B4 \\<and>\n                            B3 \\<in> carrier_mat (Suc m) n \\<and>\n                            B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n                            (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "proof (cases \"B4 $$ (k,m) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B4 $$ (k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "case True"], ["proof (state)\nthis:\n  B4 $$ (k, m) = (0::'a)\n\ngoal (2 subgoals):\n 1. B4 $$ (k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "with 0"], ["proof (chain)\npicking this:\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  B4 $$ (k, m) = (0::'a)", "have 0: \"\\<forall> i < Suc k. B4 $$ (i,m) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  B4 $$ (k, m) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc k. B4 $$ (i, m) = (0::'a)", "using less_Suc_eq"], ["proof (prove)\nusing this:\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  B4 $$ (k, m) = (0::'a)\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc k. B4 $$ (i, m) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<Suc k. B4 $$ (i, m) = (0::'a)\n\ngoal (2 subgoals):\n 1. B4 $$ (k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "with v det B3 B4"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'a)\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  \\<forall>i<Suc k. B4 $$ (i, m) = (0::'a)", "have \"?P B3 B4 v (Suc k)\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'a)\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  \\<forall>i<Suc k. B4 $$ (i, m) = (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'a) \\<and>\n    v * det (four_block_mat A1 A2 A3 A4) =\n    det (four_block_mat A1 A2 B3 B4) \\<and>\n    v * det A4 = det B4 \\<and>\n    B3 \\<in> carrier_mat (Suc m) n \\<and>\n    B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n    (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> (0::'a) \\<and>\n  v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 B3 B4) \\<and>\n  v * det A4 = det B4 \\<and>\n  B3 \\<in> carrier_mat (Suc m) n \\<and>\n  B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n\ngoal (2 subgoals):\n 1. B4 $$ (k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'a) \\<and>\n  v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 B3 B4) \\<and>\n  v * det A4 = det B4 \\<and>\n  B3 \\<in> carrier_mat (Suc m) n \\<and>\n  B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "by blast"], ["proof (state)\nthis:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "case Bk: False"], ["proof (state)\nthis:\n  B4 $$ (k, m) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?k = \"Suc k\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from Suc(2)"], ["proof (chain)\npicking this:\n  Suc k \\<le> m", "have k: \"k < ?m\" \"Suc k < ?m\" \"k \\<noteq> Suc k\""], ["proof (prove)\nusing this:\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. k < Suc m &&& Suc k < Suc m &&& k \\<noteq> Suc k", "by auto"], ["proof (state)\nthis:\n  k < Suc m\n  Suc k < Suc m\n  k \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. B4 $$ (k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "proof (cases \"B4 $$ (?k,m) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "case True"], ["proof (state)\nthis:\n  B4 $$ (Suc k, m) = (0::'a)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?B4 = \"swaprows k (Suc k) B4\""], ["proof (state)\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?B3 = \"swaprows k (Suc k) B3\""], ["proof (state)\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?B = \"four_block_mat A1 A2 ?B3 ?B4\""], ["proof (state)\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?v = \"-v\""], ["proof (state)\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from det_swaprows[OF k B4] det"], ["proof (chain)\npicking this:\n  det (swaprows k (Suc k) B4) = - det B4\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4", "have det1: \"?v * det A4 = det ?B4\""], ["proof (prove)\nusing this:\n  det (swaprows k (Suc k) B4) = - det B4\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4\n\ngoal (1 subgoal):\n 1. - v * det A4 = det (swaprows k (Suc k) B4)", "by simp"], ["proof (state)\nthis:\n  - v * det A4 = det (swaprows k (Suc k) B4)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from v"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'a)", "have v: \"?v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. - v \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  - v \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from B3"], ["proof (chain)\npicking this:\n  B3 \\<in> carrier_mat (Suc m) n", "have B3': \"?B3 \\<in> carrier_mat ?m n\""], ["proof (prove)\nusing this:\n  B3 \\<in> carrier_mat (Suc m) n\n\ngoal (1 subgoal):\n 1. swaprows k (Suc k) B3 \\<in> carrier_mat (Suc m) n", "by auto"], ["proof (state)\nthis:\n  swaprows k (Suc k) B3 \\<in> carrier_mat (Suc m) n\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from B4"], ["proof (chain)\npicking this:\n  B4 \\<in> carrier_mat (Suc m) (Suc m)", "have B4': \"?B4 \\<in> carrier_mat ?m ?m\""], ["proof (prove)\nusing this:\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. swaprows k (Suc k) B4 \\<in> carrier_mat (Suc m) (Suc m)", "by auto"], ["proof (state)\nthis:\n  swaprows k (Suc k) B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have \"?v * det ?A = - det (four_block_mat A1 A2 B3 B4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - v * det (four_block_mat A1 A2 A3 A4) =\n    - det (four_block_mat A1 A2 B3 B4)", "using det"], ["proof (prove)\nusing this:\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4\n\ngoal (1 subgoal):\n 1. - v * det (four_block_mat A1 A2 A3 A4) =\n    - det (four_block_mat A1 A2 B3 B4)", "by simp"], ["proof (state)\nthis:\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  - det (four_block_mat A1 A2 B3 B4)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "also"], ["proof (state)\nthis:\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  - det (four_block_mat A1 A2 B3 B4)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have \"\\<dots> = det (swaprows (n + k) (n + ?k) (four_block_mat A1 A2 B3 B4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - det (four_block_mat A1 A2 B3 B4) =\n    det (swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4))", "by (rule sym, rule det_swaprows[of _ \"n + ?m\"], insert A1 A2 B3 B4 k, auto)"], ["proof (state)\nthis:\n  - det (four_block_mat A1 A2 B3 B4) =\n  det (swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4))\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "also"], ["proof (state)\nthis:\n  - det (four_block_mat A1 A2 B3 B4) =\n  det (swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4))\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have \"swaprows (n + k) (n + ?k) (four_block_mat A1 A2 B3 B4) = ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4)", "proof (rule eq_matI, unfold index_mat_four_block index_mat_swaprows, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A1 + dim_row B4;\n        j < dim_col A1 + dim_col B4\\<rbrakk>\n       \\<Longrightarrow> swaprows (n + k) (n + Suc k)\n                          (four_block_mat A1 A2 B3 B4) $$\n                         (i, j) =\n                         four_block_mat A1 A2 (swaprows k (Suc k) B3)\n                          (swaprows k (Suc k) B4) $$\n                         (i, j)\n 2. dim_row A1 + dim_row B4 = dim_row A1 + dim_row B4\n 3. dim_col A1 + dim_col B4 = dim_col A1 + dim_col B4", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row A1 + dim_row B4\n  j < dim_col A1 + dim_col B4\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A1 + dim_row B4;\n        j < dim_col A1 + dim_col B4\\<rbrakk>\n       \\<Longrightarrow> swaprows (n + k) (n + Suc k)\n                          (four_block_mat A1 A2 B3 B4) $$\n                         (i, j) =\n                         four_block_mat A1 A2 (swaprows k (Suc k) B3)\n                          (swaprows k (Suc k) B4) $$\n                         (i, j)\n 2. dim_row A1 + dim_row B4 = dim_row A1 + dim_row B4\n 3. dim_col A1 + dim_col B4 = dim_col A1 + dim_col B4", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "proof (cases \"i < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)\n 2. \\<not> i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "case True"], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)\n 2. \\<not> i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "using 1(2) A1 A2 B3 B4"], ["proof (prove)\nusing this:\n  i < n\n  j < dim_col A1 + dim_col B4\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n  four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "case False"], ["proof (state)\nthis:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "hence \"i = n + (i - n)\""], ["proof (prove)\nusing this:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. i = n + (i - n)", "by simp"], ["proof (state)\nthis:\n  i = n + (i - n)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "then"], ["proof (chain)\npicking this:\n  i = n + (i - n)", "obtain d where \"i = n + d\""], ["proof (prove)\nusing this:\n  i = n + (i - n)\n\ngoal (1 subgoal):\n 1. (\\<And>d. i = n + d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  i = n + d\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = n + d\n\ngoal (1 subgoal):\n 1. swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "using 1 A1 A2 B3 B4 k(2)"], ["proof (prove)\nusing this:\n  i = n + d\n  i < dim_row A1 + dim_row B4\n  j < dim_col A1 + dim_col B4\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  Suc k < Suc m\n\ngoal (1 subgoal):\n 1. swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n    four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n  four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n  (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) $$ (i, j) =\n  four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row A1 + dim_row B4 = dim_row A1 + dim_row B4\n 2. dim_col A1 + dim_col B4 = dim_col A1 + dim_col B4", "qed auto"], ["proof (state)\nthis:\n  swaprows (n + k) (n + Suc k) (four_block_mat A1 A2 B3 B4) =\n  four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "finally"], ["proof (chain)\npicking this:\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4))", "have det2: \"?v * det ?A = det ?B\""], ["proof (prove)\nusing this:\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4))\n\ngoal (1 subgoal):\n 1. - v * det (four_block_mat A1 A2 A3 A4) =\n    det (four_block_mat A1 A2 (swaprows k (Suc k) B3)\n          (swaprows k (Suc k) B4))", "."], ["proof (state)\nthis:\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4))\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from True 0 B4 k(2)"], ["proof (chain)\npicking this:\n  B4 $$ (Suc k, m) = (0::'a)\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  Suc k < Suc m", "have \"\\<forall> i < Suc k. ?B4 $$ (i,m) = 0\""], ["proof (prove)\nusing this:\n  B4 $$ (Suc k, m) = (0::'a)\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  Suc k < Suc m\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc k. swaprows k (Suc k) B4 $$ (i, m) = (0::'a)", "unfolding less_Suc_eq"], ["proof (prove)\nusing this:\n  B4 $$ (Suc k, m) = (0::'a)\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  Suc k < m \\<or> Suc k = m\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i < k \\<or> i = k \\<longrightarrow>\n       swaprows k (Suc k) B4 $$ (i, m) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<Suc k. swaprows k (Suc k) B4 $$ (i, m) = (0::'a)\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "with det1 det2 B3' B4' v"], ["proof (chain)\npicking this:\n  - v * det A4 = det (swaprows k (Suc k) B4)\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4))\n  swaprows k (Suc k) B3 \\<in> carrier_mat (Suc m) n\n  swaprows k (Suc k) B4 \\<in> carrier_mat (Suc m) (Suc m)\n  - v \\<noteq> (0::'a)\n  \\<forall>i<Suc k. swaprows k (Suc k) B4 $$ (i, m) = (0::'a)", "have \"?P ?B3 ?B4 ?v (Suc k)\""], ["proof (prove)\nusing this:\n  - v * det A4 = det (swaprows k (Suc k) B4)\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 (swaprows k (Suc k) B3) (swaprows k (Suc k) B4))\n  swaprows k (Suc k) B3 \\<in> carrier_mat (Suc m) n\n  swaprows k (Suc k) B4 \\<in> carrier_mat (Suc m) (Suc m)\n  - v \\<noteq> (0::'a)\n  \\<forall>i<Suc k. swaprows k (Suc k) B4 $$ (i, m) = (0::'a)\n\ngoal (1 subgoal):\n 1. - v \\<noteq> (0::'a) \\<and>\n    - v * det (four_block_mat A1 A2 A3 A4) =\n    det (four_block_mat A1 A2 (swaprows k (Suc k) B3)\n          (swaprows k (Suc k) B4)) \\<and>\n    - v * det A4 = det (swaprows k (Suc k) B4) \\<and>\n    swaprows k (Suc k) B3 \\<in> carrier_mat (Suc m) n \\<and>\n    swaprows k (Suc k) B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n    (\\<forall>i<Suc k. swaprows k (Suc k) B4 $$ (i, m) = (0::'a))", "by auto"], ["proof (state)\nthis:\n  - v \\<noteq> (0::'a) \\<and>\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 (swaprows k (Suc k) B3)\n        (swaprows k (Suc k) B4)) \\<and>\n  - v * det A4 = det (swaprows k (Suc k) B4) \\<and>\n  swaprows k (Suc k) B3 \\<in> carrier_mat (Suc m) n \\<and>\n  swaprows k (Suc k) B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<Suc k. swaprows k (Suc k) B4 $$ (i, m) = (0::'a))\n\ngoal (2 subgoals):\n 1. B4 $$ (Suc k, m) = (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n 2. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  - v \\<noteq> (0::'a) \\<and>\n  - v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 (swaprows k (Suc k) B3)\n        (swaprows k (Suc k) B4)) \\<and>\n  - v * det A4 = det (swaprows k (Suc k) B4) \\<and>\n  swaprows k (Suc k) B3 \\<in> carrier_mat (Suc m) n \\<and>\n  swaprows k (Suc k) B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<Suc k. swaprows k (Suc k) B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "by blast"], ["proof (state)\nthis:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "case False"], ["proof (state)\nthis:\n  B4 $$ (Suc k, m) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?bk = \"B4 $$ (?k,m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?b = \"B4 $$ (k,m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?v = \"v * ?bk\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?B3 = \"addrow (- ?b) k ?k (multrow k ?bk B3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?B4 = \"addrow (- ?b) k ?k (multrow k ?bk B4)\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have *: \"det ?B4 = ?bk * det B4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4)) =\n    B4 $$ (Suc k, m) * det B4", "by (subst det_addrow[OF k(2-3)], force simp: B4, rule det_multrow[OF k(1) B4])"], ["proof (state)\nthis:\n  det (addrow (- B4 $$ (k, m)) k (Suc k)\n        (multrow k (B4 $$ (Suc k, m)) B4)) =\n  B4 $$ (Suc k, m) * det B4\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "with det(2)[symmetric]"], ["proof (chain)\npicking this:\n  det B4 = v * det A4\n  det (addrow (- B4 $$ (k, m)) k (Suc k)\n        (multrow k (B4 $$ (Suc k, m)) B4)) =\n  B4 $$ (Suc k, m) * det B4", "have det2: \"?v * det A4 = det ?B4\""], ["proof (prove)\nusing this:\n  det B4 = v * det A4\n  det (addrow (- B4 $$ (k, m)) k (Suc k)\n        (multrow k (B4 $$ (Suc k, m)) B4)) =\n  B4 $$ (Suc k, m) * det B4\n\ngoal (1 subgoal):\n 1. v * B4 $$ (Suc k, m) * det A4 =\n    det (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4))", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  v * B4 $$ (Suc k, m) * det A4 =\n  det (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4))\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from 0 k(2) B4"], ["proof (chain)\npicking this:\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  Suc k < Suc m\n  B4 \\<in> carrier_mat (Suc m) (Suc m)", "have 0: \"\\<forall> i < Suc k. ?B4 $$ (i,m) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  Suc k < Suc m\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc k.\n       addrow (- B4 $$ (k, m)) k (Suc k)\n        (multrow k (B4 $$ (Suc k, m)) B4) $$\n       (i, m) =\n       (0::'a)", "unfolding less_Suc_eq"], ["proof (prove)\nusing this:\n  \\<forall>i<k. B4 $$ (i, m) = (0::'a)\n  Suc k < m \\<or> Suc k = m\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i < k \\<or> i = k \\<longrightarrow>\n       addrow (- B4 $$ (k, m)) k (Suc k)\n        (multrow k (B4 $$ (Suc k, m)) B4) $$\n       (i, m) =\n       (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<Suc k.\n     addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4) $$\n     (i, m) =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from False v"], ["proof (chain)\npicking this:\n  B4 $$ (Suc k, m) \\<noteq> (0::'a)\n  v \\<noteq> (0::'a)", "have v: \"?v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  B4 $$ (Suc k, m) \\<noteq> (0::'a)\n  v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. v * B4 $$ (Suc k, m) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  v * B4 $$ (Suc k, m) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from B3"], ["proof (chain)\npicking this:\n  B3 \\<in> carrier_mat (Suc m) n", "have B3': \"?B3 \\<in> carrier_mat ?m n\""], ["proof (prove)\nusing this:\n  B3 \\<in> carrier_mat (Suc m) n\n\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3)\n    \\<in> carrier_mat (Suc m) n", "by auto"], ["proof (state)\nthis:\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3)\n  \\<in> carrier_mat (Suc m) n\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from B4"], ["proof (chain)\npicking this:\n  B4 \\<in> carrier_mat (Suc m) (Suc m)", "have B4': \"?B4 \\<in> carrier_mat ?m ?m\""], ["proof (prove)\nusing this:\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)\n    \\<in> carrier_mat (Suc m) (Suc m)", "by auto"], ["proof (state)\nthis:\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)\n  \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?B' = \"multrow (n + k) ?bk (four_block_mat A1 A2 B3 B4)\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have B': \"?B' \\<in> carrier_mat (n + ?m) (n + ?m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)\n    \\<in> carrier_mat (n + Suc m) (n + Suc m)", "using A1 A2 B3 B4 k"], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  k < Suc m\n  Suc k < Suc m\n  k \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)\n    \\<in> carrier_mat (n + Suc m) (n + Suc m)", "by auto"], ["proof (state)\nthis:\n  multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)\n  \\<in> carrier_mat (n + Suc m) (n + Suc m)\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "let ?B = \"four_block_mat A1 A2 ?B3 ?B4\""], ["proof (state)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have \"?v * det ?A = ?bk * det (four_block_mat A1 A2 B3 B4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n    B4 $$ (Suc k, m) * det (four_block_mat A1 A2 B3 B4)", "using det"], ["proof (prove)\nusing this:\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4\n\ngoal (1 subgoal):\n 1. v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n    B4 $$ (Suc k, m) * det (four_block_mat A1 A2 B3 B4)", "by simp"], ["proof (state)\nthis:\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  B4 $$ (Suc k, m) * det (four_block_mat A1 A2 B3 B4)\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "also"], ["proof (state)\nthis:\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  B4 $$ (Suc k, m) * det (four_block_mat A1 A2 B3 B4)\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have \"\\<dots> = det (addrow (- ?b) (n + k) (n + ?k) ?B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) * det (four_block_mat A1 A2 B3 B4) =\n    det (addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n          (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)))", "by (subst det_addrow[OF _ _ B'], insert k(2), force, force, rule sym, rule det_multrow[of _ \"n + ?m\"],\n          insert A1 A2 B3 B4 k, auto)"], ["proof (state)\nthis:\n  B4 $$ (Suc k, m) * det (four_block_mat A1 A2 B3 B4) =\n  det (addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n        (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)))\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "also"], ["proof (state)\nthis:\n  B4 $$ (Suc k, m) * det (four_block_mat A1 A2 B3 B4) =\n  det (addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n        (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)))\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "have \"addrow (- ?b) (n + k) (n + ?k) ?B' = ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4))", "proof (rule eq_matI, unfold index_mat_four_block index_mat_multrow index_mat_addrow, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A1 + dim_row B4;\n        j < dim_col A1 + dim_col B4\\<rbrakk>\n       \\<Longrightarrow> addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n                          (multrow (n + k) (B4 $$ (Suc k, m))\n                            (four_block_mat A1 A2 B3 B4)) $$\n                         (i, j) =\n                         four_block_mat A1 A2\n                          (addrow (- B4 $$ (k, m)) k (Suc k)\n                            (multrow k (B4 $$ (Suc k, m)) B3))\n                          (addrow (- B4 $$ (k, m)) k (Suc k)\n                            (multrow k (B4 $$ (Suc k, m)) B4)) $$\n                         (i, j)\n 2. dim_row A1 + dim_row B4 = dim_row A1 + dim_row B4\n 3. dim_col A1 + dim_col B4 = dim_col A1 + dim_col B4", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row A1 + dim_row B4\n  j < dim_col A1 + dim_col B4\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A1 + dim_row B4;\n        j < dim_col A1 + dim_col B4\\<rbrakk>\n       \\<Longrightarrow> addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n                          (multrow (n + k) (B4 $$ (Suc k, m))\n                            (four_block_mat A1 A2 B3 B4)) $$\n                         (i, j) =\n                         four_block_mat A1 A2\n                          (addrow (- B4 $$ (k, m)) k (Suc k)\n                            (multrow k (B4 $$ (Suc k, m)) B3))\n                          (addrow (- B4 $$ (k, m)) k (Suc k)\n                            (multrow k (B4 $$ (Suc k, m)) B4)) $$\n                         (i, j)\n 2. dim_row A1 + dim_row B4 = dim_row A1 + dim_row B4\n 3. dim_col A1 + dim_col B4 = dim_col A1 + dim_col B4", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "proof (cases \"i < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)\n 2. \\<not> i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "case True"], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)\n 2. \\<not> i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "using 1(2) A1 A2 B3 B4"], ["proof (prove)\nusing this:\n  i < n\n  j < dim_col A1 + dim_col B4\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n   (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n  (i, j) =\n  four_block_mat A1 A2\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "case False"], ["proof (state)\nthis:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "hence \"i = n + (i - n)\""], ["proof (prove)\nusing this:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. i = n + (i - n)", "by simp"], ["proof (state)\nthis:\n  i = n + (i - n)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "then"], ["proof (chain)\npicking this:\n  i = n + (i - n)", "obtain d where \"i = n + d\""], ["proof (prove)\nusing this:\n  i = n + (i - n)\n\ngoal (1 subgoal):\n 1. (\\<And>d. i = n + d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  i = n + d\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = n + d\n\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "using 1 A1 A2 B3 B4 k(2)"], ["proof (prove)\nusing this:\n  i = n + d\n  i < dim_row A1 + dim_row B4\n  j < dim_col A1 + dim_col B4\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  Suc k < Suc m\n\ngoal (1 subgoal):\n 1. addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n     (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n    (i, j) =\n    four_block_mat A1 A2\n     (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n     (addrow (- B4 $$ (k, m)) k (Suc k)\n       (multrow k (B4 $$ (Suc k, m)) B4)) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n   (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n  (i, j) =\n  four_block_mat A1 A2\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)) $$\n  (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n   (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) $$\n  (i, j) =\n  four_block_mat A1 A2\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row A1 + dim_row B4 = dim_row A1 + dim_row B4\n 2. dim_col A1 + dim_col B4 = dim_col A1 + dim_col B4", "qed auto"], ["proof (state)\nthis:\n  addrow (- B4 $$ (k, m)) (n + k) (n + Suc k)\n   (multrow (n + k) (B4 $$ (Suc k, m)) (four_block_mat A1 A2 B3 B4)) =\n  four_block_mat A1 A2\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3))\n   (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4))\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "finally"], ["proof (chain)\npicking this:\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B3))\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4)))", "have det1: \"?v * det ?A = det ?B\""], ["proof (prove)\nusing this:\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B3))\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4)))\n\ngoal (1 subgoal):\n 1. v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n    det (four_block_mat A1 A2\n          (addrow (- B4 $$ (k, m)) k (Suc k)\n            (multrow k (B4 $$ (Suc k, m)) B3))\n          (addrow (- B4 $$ (k, m)) k (Suc k)\n            (multrow k (B4 $$ (Suc k, m)) B4)))", "."], ["proof (state)\nthis:\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B3))\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4)))\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "from det1 det2 B3' B4' v 0"], ["proof (chain)\npicking this:\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B3))\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4)))\n  v * B4 $$ (Suc k, m) * det A4 =\n  det (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4))\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3)\n  \\<in> carrier_mat (Suc m) n\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)\n  \\<in> carrier_mat (Suc m) (Suc m)\n  v * B4 $$ (Suc k, m) \\<noteq> (0::'a)\n  \\<forall>i<Suc k.\n     addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4) $$\n     (i, m) =\n     (0::'a)", "have \"?P ?B3 ?B4 ?v (Suc k)\""], ["proof (prove)\nusing this:\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B3))\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4)))\n  v * B4 $$ (Suc k, m) * det A4 =\n  det (addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4))\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3)\n  \\<in> carrier_mat (Suc m) n\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)\n  \\<in> carrier_mat (Suc m) (Suc m)\n  v * B4 $$ (Suc k, m) \\<noteq> (0::'a)\n  \\<forall>i<Suc k.\n     addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4) $$\n     (i, m) =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. v * B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<and>\n    v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n    det (four_block_mat A1 A2\n          (addrow (- B4 $$ (k, m)) k (Suc k)\n            (multrow k (B4 $$ (Suc k, m)) B3))\n          (addrow (- B4 $$ (k, m)) k (Suc k)\n            (multrow k (B4 $$ (Suc k, m)) B4))) \\<and>\n    v * B4 $$ (Suc k, m) * det A4 =\n    det (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4)) \\<and>\n    addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3)\n    \\<in> carrier_mat (Suc m) n \\<and>\n    addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)\n    \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n    (\\<forall>i<Suc k.\n        addrow (- B4 $$ (k, m)) k (Suc k)\n         (multrow k (B4 $$ (Suc k, m)) B4) $$\n        (i, m) =\n        (0::'a))", "by auto"], ["proof (state)\nthis:\n  v * B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<and>\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B3))\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4))) \\<and>\n  v * B4 $$ (Suc k, m) * det A4 =\n  det (addrow (- B4 $$ (k, m)) k (Suc k)\n        (multrow k (B4 $$ (Suc k, m)) B4)) \\<and>\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3)\n  \\<in> carrier_mat (Suc m) n \\<and>\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)\n  \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<Suc k.\n      addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4) $$\n      (i, m) =\n      (0::'a))\n\ngoal (1 subgoal):\n 1. B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v * B4 $$ (Suc k, m) \\<noteq> (0::'a) \\<and>\n  v * B4 $$ (Suc k, m) * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B3))\n        (addrow (- B4 $$ (k, m)) k (Suc k)\n          (multrow k (B4 $$ (Suc k, m)) B4))) \\<and>\n  v * B4 $$ (Suc k, m) * det A4 =\n  det (addrow (- B4 $$ (k, m)) k (Suc k)\n        (multrow k (B4 $$ (Suc k, m)) B4)) \\<and>\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B3)\n  \\<in> carrier_mat (Suc m) n \\<and>\n  addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4)\n  \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<Suc k.\n      addrow (- B4 $$ (k, m)) k (Suc k) (multrow k (B4 $$ (Suc k, m)) B4) $$\n      (i, m) =\n      (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>B3 B4 v.\n       v \\<noteq> (0::'a) \\<and>\n       v * det (four_block_mat A1 A2 A3 A4) =\n       det (four_block_mat A1 A2 B3 B4) \\<and>\n       v * det A4 = det B4 \\<and>\n       B3 \\<in> carrier_mat (Suc m) n \\<and>\n       B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n       (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))", "by blast"], ["proof (state)\nthis:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<Suc k. B4 $$ (i, m) = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k \\<le> m \\<Longrightarrow>\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<?k. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from this[OF le_refl]"], ["proof (chain)\npicking this:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<m. B4 $$ (i, m) = (0::'a))", "obtain B3 B4 v where P: \"?P B3 B4 v m\""], ["proof (prove)\nusing this:\n  \\<exists>B3 B4 v.\n     v \\<noteq> (0::'a) \\<and>\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) \\<and>\n     v * det A4 = det B4 \\<and>\n     B3 \\<in> carrier_mat (Suc m) n \\<and>\n     B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n     (\\<forall>i<m. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>v B3 B4.\n        v \\<noteq> (0::'a) \\<and>\n        v * det (four_block_mat A1 A2 A3 A4) =\n        det (four_block_mat A1 A2 B3 B4) \\<and>\n        v * det A4 = det B4 \\<and>\n        B3 \\<in> carrier_mat (Suc m) n \\<and>\n        B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n        (\\<forall>i<m. B4 $$ (i, m) = (0::'a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<noteq> (0::'a) \\<and>\n  v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 B3 B4) \\<and>\n  v * det A4 = det B4 \\<and>\n  B3 \\<in> carrier_mat (Suc m) n \\<and>\n  B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<m. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?B = \"four_block_mat A1 A2 B3 B4\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from P"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'a) \\<and>\n  v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 B3 B4) \\<and>\n  v * det A4 = det B4 \\<and>\n  B3 \\<in> carrier_mat (Suc m) n \\<and>\n  B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<m. B4 $$ (i, m) = (0::'a))", "have v: \"v \\<noteq> 0\" and det: \"v * det ?A = det ?B\" \"v * det A4 = det B4\" \n    and B3: \"B3 \\<in> carrier_mat ?m n\" and B4: \"B4 \\<in> carrier_mat ?m ?m\" and 0: \"\\<And> i. i < m \\<Longrightarrow> B4 $$ (i, m) = 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'a) \\<and>\n  v * det (four_block_mat A1 A2 A3 A4) =\n  det (four_block_mat A1 A2 B3 B4) \\<and>\n  v * det A4 = det B4 \\<and>\n  B3 \\<in> carrier_mat (Suc m) n \\<and>\n  B4 \\<in> carrier_mat (Suc m) (Suc m) \\<and>\n  (\\<forall>i<m. B4 $$ (i, m) = (0::'a))\n\ngoal (1 subgoal):\n 1. (v \\<noteq> (0::'a) &&&\n     v * det (four_block_mat A1 A2 A3 A4) =\n     det (four_block_mat A1 A2 B3 B4) &&&\n     v * det A4 = det B4) &&&\n    B3 \\<in> carrier_mat (Suc m) n &&&\n    B4 \\<in> carrier_mat (Suc m) (Suc m) &&&\n    (\\<And>i. i < m \\<Longrightarrow> B4 $$ (i, m) = (0::'a))", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> (0::'a)\n  v * det (four_block_mat A1 A2 A3 A4) = det (four_block_mat A1 A2 B3 B4)\n  v * det A4 = det B4\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  ?i < m \\<Longrightarrow> B4 $$ (?i, m) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?A2 = \"0\\<^sub>m n m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?A3 = \"mat m n (\\<lambda> ij. B3 $$ ij)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?A4 = \"mat m m (\\<lambda> ij. B4 $$ ij)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?B1 = \"four_block_mat A1 ?A2 ?A3 ?A4\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?B2 = \"0\\<^sub>m (n + m) 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?B3 = \"mat 1 (n + m) (\\<lambda> (i,j). if j < n then B3 $$ (m,j) else B4 $$ (m,j - n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?B4 = \"mat 1 1 (\\<lambda> _. B4 $$ (m,m))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have B44: \"B4 = four_block_mat ?A4 (0\\<^sub>m m 1) (mat 1 m (\\<lambda> (i,j). B4 $$ (m,j))) ?B4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B4 =\n    four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n     (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))", "proof (rule eq_matI, unfold index_mat_four_block dim_col_mat dim_row_mat, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m + 1; j < m + 1\\<rbrakk>\n       \\<Longrightarrow> B4 $$ (i, j) =\n                         four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n                          (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n                          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                         (i, j)\n 2. dim_row B4 = m + 1\n 3. dim_col B4 = m + 1", "case (1 i j)"], ["proof (state)\nthis:\n  i < m + 1\n  j < m + 1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m + 1; j < m + 1\\<rbrakk>\n       \\<Longrightarrow> B4 $$ (i, j) =\n                         four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n                          (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n                          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                         (i, j)\n 2. dim_row B4 = m + 1\n 3. dim_col B4 = m + 1", "hence [simp]: \"\\<not> i < m \\<Longrightarrow> i = m\" \"\\<not> j < m \\<Longrightarrow> j = m\""], ["proof (prove)\nusing this:\n  i < m + 1\n  j < m + 1\n\ngoal (1 subgoal):\n 1. (\\<not> i < m \\<Longrightarrow> i = m) &&&\n    (\\<not> j < m \\<Longrightarrow> j = m)", "by auto"], ["proof (state)\nthis:\n  \\<not> i < m \\<Longrightarrow> i = m\n  \\<not> j < m \\<Longrightarrow> j = m\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m + 1; j < m + 1\\<rbrakk>\n       \\<Longrightarrow> B4 $$ (i, j) =\n                         four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n                          (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n                          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                         (i, j)\n 2. dim_row B4 = m + 1\n 3. dim_col B4 = m + 1", "from 1"], ["proof (chain)\npicking this:\n  i < m + 1\n  j < m + 1", "show ?case"], ["proof (prove)\nusing this:\n  i < m + 1\n  j < m + 1\n\ngoal (1 subgoal):\n 1. B4 $$ (i, j) =\n    four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n     (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "using B4 0"], ["proof (prove)\nusing this:\n  i < m + 1\n  j < m + 1\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n  ?i < m \\<Longrightarrow> B4 $$ (?i, m) = (0::'a)\n\ngoal (1 subgoal):\n 1. B4 $$ (i, j) =\n    four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n     (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "by auto"], ["proof (state)\nthis:\n  B4 $$ (i, j) =\n  four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n   (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row B4 = m + 1\n 2. dim_col B4 = m + 1", "qed (insert B4, auto)"], ["proof (state)\nthis:\n  B4 =\n  four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n   (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"?B = four_block_mat ?B1 ?B2 ?B3 ?B4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))", "proof (rule eq_matI, unfold index_mat_four_block dim_col_mat dim_row_mat, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A1 + m + 1; j < dim_col A1 + m + 1\\<rbrakk>\n       \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                         four_block_mat\n                          (four_block_mat A1 (0\\<^sub>m n m)\n                            (mat m n (($$) B3)) (mat m m (($$) B4)))\n                          (0\\<^sub>m (n + m) 1)\n                          (mat 1 (n + m)\n                            (\\<lambda>(i, j).\n                                if j < n then B3 $$ (m, j)\n                                else B4 $$ (m, j - n)))\n                          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                         (i, j)\n 2. dim_row A1 + dim_row B4 = dim_row A1 + m + 1\n 3. dim_col A1 + dim_col B4 = dim_col A1 + m + 1", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row A1 + m + 1\n  j < dim_col A1 + m + 1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A1 + m + 1; j < dim_col A1 + m + 1\\<rbrakk>\n       \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                         four_block_mat\n                          (four_block_mat A1 (0\\<^sub>m n m)\n                            (mat m n (($$) B3)) (mat m m (($$) B4)))\n                          (0\\<^sub>m (n + m) 1)\n                          (mat 1 (n + m)\n                            (\\<lambda>(i, j).\n                                if j < n then B3 $$ (m, j)\n                                else B4 $$ (m, j - n)))\n                          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                         (i, j)\n 2. dim_row A1 + dim_row B4 = dim_row A1 + m + 1\n 3. dim_col A1 + dim_col B4 = dim_col A1 + m + 1", "then"], ["proof (chain)\npicking this:\n  i < dim_row A1 + m + 1\n  j < dim_col A1 + m + 1", "consider (UL) \"i < n + m\" \"j < n + m\" | (UR) \"i < n + m\" \"j = n + m\" \n        | (LL) \"i = n + m\" \"j < n + m\" | (LR) \"i = n + m\" \"j = n + m\""], ["proof (prove)\nusing this:\n  i < dim_row A1 + m + 1\n  j < dim_col A1 + m + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>i < n + m; j = n + m\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>i = n + m; j < n + m\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using A1"], ["proof (prove)\nusing this:\n  i < dim_row A1 + m + 1\n  j < dim_col A1 + m + 1\n  A1 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>i < n + m; j = n + m\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>i = n + m; j < n + m\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n           \\<Longrightarrow> ?thesis2;\n   \\<lbrakk>i < n + m; j = n + m\\<rbrakk> \\<Longrightarrow> ?thesis2;\n   \\<lbrakk>i = n + m; j < n + m\\<rbrakk> \\<Longrightarrow> ?thesis2;\n   \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n   \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A1 + m + 1; j < dim_col A1 + m + 1\\<rbrakk>\n       \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                         four_block_mat\n                          (four_block_mat A1 (0\\<^sub>m n m)\n                            (mat m n (($$) B3)) (mat m m (($$) B4)))\n                          (0\\<^sub>m (n + m) 1)\n                          (mat 1 (n + m)\n                            (\\<lambda>(i, j).\n                                if j < n then B3 $$ (m, j)\n                                else B4 $$ (m, j - n)))\n                          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                         (i, j)\n 2. dim_row A1 + dim_row B4 = dim_row A1 + m + 1\n 3. dim_col A1 + dim_col B4 = dim_col A1 + m + 1", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n           \\<Longrightarrow> ?thesis2;\n   \\<lbrakk>i < n + m; j = n + m\\<rbrakk> \\<Longrightarrow> ?thesis2;\n   \\<lbrakk>i = n + m; j < n + m\\<rbrakk> \\<Longrightarrow> ?thesis2;\n   \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n   \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 3. \\<lbrakk>i = n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 4. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "case UL"], ["proof (state)\nthis:\n  i < n + m\n  j < n + m\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 3. \\<lbrakk>i = n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 4. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "hence [simp]: \"\\<not> i < n \\<Longrightarrow> i - n < m\" \n         \"\\<not> j < n \\<Longrightarrow> j - n < m\" \"\\<not> j < n \\<Longrightarrow> j - n < Suc m\""], ["proof (prove)\nusing this:\n  i < n + m\n  j < n + m\n\ngoal (1 subgoal):\n 1. (\\<not> i < n \\<Longrightarrow> i - n < m) &&&\n    (\\<not> j < n \\<Longrightarrow> j - n < m) &&&\n    (\\<not> j < n \\<Longrightarrow> j - n < Suc m)", "by auto"], ["proof (state)\nthis:\n  \\<not> i < n \\<Longrightarrow> i - n < m\n  \\<not> j < n \\<Longrightarrow> j - n < m\n  \\<not> j < n \\<Longrightarrow> j - n < Suc m\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 3. \\<lbrakk>i = n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 4. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "from UL"], ["proof (chain)\npicking this:\n  i < n + m\n  j < n + m", "show ?thesis"], ["proof (prove)\nusing this:\n  i < n + m\n  j < n + m\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "using A1 A20 B3 B4"], ["proof (prove)\nusing this:\n  i < n + m\n  j < n + m\n  A1 \\<in> carrier_mat n n\n  A2 = 0\\<^sub>m n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  four_block_mat A1 A2 B3 B4 $$ (i, j) =\n  four_block_mat\n   (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n     (mat m m (($$) B4)))\n   (0\\<^sub>m (n + m) 1)\n   (mat 1 (n + m)\n     (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n  (i, j)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i = n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 3. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i = n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 3. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "case LL"], ["proof (state)\nthis:\n  i = n + m\n  j < n + m\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i = n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 3. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "hence [simp]: \"\\<not> j < n \\<Longrightarrow> j - n < m\" \"\\<not> j < n \\<Longrightarrow> j - n < Suc m\""], ["proof (prove)\nusing this:\n  i = n + m\n  j < n + m\n\ngoal (1 subgoal):\n 1. (\\<not> j < n \\<Longrightarrow> j - n < m) &&&\n    (\\<not> j < n \\<Longrightarrow> j - n < Suc m)", "by auto"], ["proof (state)\nthis:\n  \\<not> j < n \\<Longrightarrow> j - n < m\n  \\<not> j < n \\<Longrightarrow> j - n < Suc m\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i = n + m; j < n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 3. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "from LL"], ["proof (chain)\npicking this:\n  i = n + m\n  j < n + m", "show ?thesis"], ["proof (prove)\nusing this:\n  i = n + m\n  j < n + m\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "using A1 A2 B3 B4"], ["proof (prove)\nusing this:\n  i = n + m\n  j < n + m\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  four_block_mat A1 A2 B3 B4 $$ (i, j) =\n  four_block_mat\n   (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n     (mat m m (($$) B4)))\n   (0\\<^sub>m (n + m) 1)\n   (mat 1 (n + m)\n     (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "case LR"], ["proof (state)\nthis:\n  i = n + m\n  j = n + m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)\n 2. \\<lbrakk>i = n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = n + m\n  j = n + m\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "using A1 A2 B3 B4"], ["proof (prove)\nusing this:\n  i = n + m\n  j = n + m\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n (Suc m)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  four_block_mat A1 A2 B3 B4 $$ (i, j) =\n  four_block_mat\n   (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n     (mat m m (($$) B4)))\n   (0\\<^sub>m (n + m) 1)\n   (mat 1 (n + m)\n     (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "case UR"], ["proof (state)\nthis:\n  i < n + m\n  j = n + m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "hence [simp]: \"\\<not> i < n \\<Longrightarrow> i - n < m\""], ["proof (prove)\nusing this:\n  i < n + m\n  j = n + m\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow> i - n < m", "by auto"], ["proof (state)\nthis:\n  \\<not> i < n \\<Longrightarrow> i - n < m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n + m; j = n + m\\<rbrakk>\n    \\<Longrightarrow> four_block_mat A1 A2 B3 B4 $$ (i, j) =\n                      four_block_mat\n                       (four_block_mat A1 (0\\<^sub>m n m)\n                         (mat m n (($$) B3)) (mat m m (($$) B4)))\n                       (0\\<^sub>m (n + m) 1)\n                       (mat 1 (n + m)\n                         (\\<lambda>(i, j).\n                             if j < n then B3 $$ (m, j)\n                             else B4 $$ (m, j - n)))\n                       (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n                      (i, j)", "from UR"], ["proof (chain)\npicking this:\n  i < n + m\n  j = n + m", "show ?thesis"], ["proof (prove)\nusing this:\n  i < n + m\n  j = n + m\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "using A1 A20 0 B3 B4"], ["proof (prove)\nusing this:\n  i < n + m\n  j = n + m\n  A1 \\<in> carrier_mat n n\n  A2 = 0\\<^sub>m n (Suc m)\n  ?i < m \\<Longrightarrow> B4 $$ (?i, m) = (0::'a)\n  B3 \\<in> carrier_mat (Suc m) n\n  B4 \\<in> carrier_mat (Suc m) (Suc m)\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 B3 B4 $$ (i, j) =\n    four_block_mat\n     (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n       (mat m m (($$) B4)))\n     (0\\<^sub>m (n + m) 1)\n     (mat 1 (n + m)\n       (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n     (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  four_block_mat A1 A2 B3 B4 $$ (i, j) =\n  four_block_mat\n   (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n     (mat m m (($$) B4)))\n   (0\\<^sub>m (n + m) 1)\n   (mat 1 (n + m)\n     (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n  (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  four_block_mat A1 A2 B3 B4 $$ (i, j) =\n  four_block_mat\n   (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n     (mat m m (($$) B4)))\n   (0\\<^sub>m (n + m) 1)\n   (mat 1 (n + m)\n     (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row A1 + dim_row B4 = dim_row A1 + m + 1\n 2. dim_col A1 + dim_col B4 = dim_col A1 + m + 1", "qed (insert B4, auto)"], ["proof (state)\nthis:\n  four_block_mat A1 A2 B3 B4 =\n  four_block_mat\n   (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n     (mat m m (($$) B4)))\n   (0\\<^sub>m (n + m) 1)\n   (mat 1 (n + m)\n     (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "hence \"det ?B = det (four_block_mat ?B1 ?B2 ?B3 ?B4)\""], ["proof (prove)\nusing this:\n  four_block_mat A1 A2 B3 B4 =\n  four_block_mat\n   (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n     (mat m m (($$) B4)))\n   (0\\<^sub>m (n + m) 1)\n   (mat 1 (n + m)\n     (\\<lambda>(i, j). if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n   (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 B3 B4) =\n    det (four_block_mat\n          (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n            (mat m m (($$) B4)))\n          (0\\<^sub>m (n + m) 1)\n          (mat 1 (n + m)\n            (\\<lambda>(i, j).\n                if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))))", "by simp"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 B3 B4) =\n  det (four_block_mat\n        (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n          (mat m m (($$) B4)))\n        (0\\<^sub>m (n + m) 1)\n        (mat 1 (n + m)\n          (\\<lambda>(i, j).\n              if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n        (mat 1 1 (\\<lambda>_. B4 $$ (m, m))))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 B3 B4) =\n  det (four_block_mat\n        (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n          (mat m m (($$) B4)))\n        (0\\<^sub>m (n + m) 1)\n        (mat 1 (n + m)\n          (\\<lambda>(i, j).\n              if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n        (mat 1 1 (\\<lambda>_. B4 $$ (m, m))))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"\\<dots> = det ?B1 * det ?B4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat\n          (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n            (mat m m (($$) B4)))\n          (0\\<^sub>m (n + m) 1)\n          (mat 1 (n + m)\n            (\\<lambda>(i, j).\n                if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n          (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))) =\n    det (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n          (mat m m (($$) B4))) *\n    det (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))", "by (rule det_four_block_mat_upper_right_zero_col[of _ \"n + m\"], insert A1 A2 B3 B4, auto)"], ["proof (state)\nthis:\n  det (four_block_mat\n        (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n          (mat m m (($$) B4)))\n        (0\\<^sub>m (n + m) 1)\n        (mat 1 (n + m)\n          (\\<lambda>(i, j).\n              if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n        (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))) =\n  det (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n        (mat m m (($$) B4))) *\n  det (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  det (four_block_mat\n        (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n          (mat m m (($$) B4)))\n        (0\\<^sub>m (n + m) 1)\n        (mat 1 (n + m)\n          (\\<lambda>(i, j).\n              if j < n then B3 $$ (m, j) else B4 $$ (m, j - n)))\n        (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))) =\n  det (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n        (mat m m (($$) B4))) *\n  det (mat 1 1 (\\<lambda>_. B4 $$ (m, m)))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"det ?B1 = det A1 * det (mat m m (($$) B4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n          (mat m m (($$) B4))) =\n    det A1 * det (mat m m (($$) B4))", "by (rule Suc(1), insert B3 B4, auto)"], ["proof (state)\nthis:\n  det (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n        (mat m m (($$) B4))) =\n  det A1 * det (mat m m (($$) B4))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  det (four_block_mat A1 (0\\<^sub>m n m) (mat m n (($$) B3))\n        (mat m m (($$) B4))) =\n  det A1 * det (mat m m (($$) B4))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"\\<dots> * det ?B4 = det A1 * (det (mat m m (($$) B4)) * det ?B4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A1 * det (mat m m (($$) B4)) *\n    det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) =\n    det A1 *\n    (det (mat m m (($$) B4)) * det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))))", "by simp"], ["proof (state)\nthis:\n  det A1 * det (mat m m (($$) B4)) *\n  det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) =\n  det A1 *\n  (det (mat m m (($$) B4)) * det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  det A1 * det (mat m m (($$) B4)) *\n  det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) =\n  det A1 *\n  (det (mat m m (($$) B4)) * det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))))\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"det (mat m m (($$) B4)) * det ?B4 = det B4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat m m (($$) B4)) * det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) =\n    det B4", "unfolding arg_cong[OF B44, of det]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat m m (($$) B4)) * det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) =\n    det (four_block_mat (mat m m (($$) B4)) (0\\<^sub>m m 1)\n          (mat 1 m (\\<lambda>(i, j). B4 $$ (m, j)))\n          (mat 1 1 (\\<lambda>_. B4 $$ (m, m))))", "by (subst det_four_block_mat_upper_right_zero_col[OF _ refl], auto)"], ["proof (state)\nthis:\n  det (mat m m (($$) B4)) * det (mat 1 1 (\\<lambda>_. B4 $$ (m, m))) =\n  det B4\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "finally"], ["proof (chain)\npicking this:\n  det (four_block_mat A1 A2 B3 B4) = det A1 * det B4", "have id: \"det ?B = det A1 * det B4\""], ["proof (prove)\nusing this:\n  det (four_block_mat A1 A2 B3 B4) = det A1 * det B4\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 B3 B4) = det A1 * det B4", "."], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 B3 B4) = det A1 * det B4\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from this[folded det]"], ["proof (chain)\npicking this:\n  v * det (four_block_mat A1 A2 A3 A4) = det A1 * (v * det A4)", "have \"v * det ?A = v * (det A1 * det A4)\""], ["proof (prove)\nusing this:\n  v * det (four_block_mat A1 A2 A3 A4) = det A1 * (v * det A4)\n\ngoal (1 subgoal):\n 1. v * det (four_block_mat A1 A2 A3 A4) = v * (det A1 * det A4)", "by simp"], ["proof (state)\nthis:\n  v * det (four_block_mat A1 A2 A3 A4) = v * (det A1 * det A4)\n\ngoal (1 subgoal):\n 1. \\<And>m A2 A3 A4.\n       \\<lbrakk>\\<And>A2 A3 A4.\n                   \\<lbrakk>A2 = 0\\<^sub>m n m; A3 \\<in> carrier_mat m n;\n                    A4 \\<in> carrier_mat m m\\<rbrakk>\n                   \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) =\n                                     det A1 * det A4;\n        A2 = 0\\<^sub>m n (Suc m); A3 \\<in> carrier_mat (Suc m) n;\n        A4 \\<in> carrier_mat (Suc m) (Suc m)\\<rbrakk>\n       \\<Longrightarrow> det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "with v"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'a)\n  v * det (four_block_mat A1 A2 A3 A4) = v * (det A1 * det A4)", "show \"det ?A = det A1 * det A4\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'a)\n  v * det (four_block_mat A1 A2 A3 A4) = v * (det A1 * det A4)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "by simp"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_swapcols: \n  assumes *: \"k < n\" \"l < n\" \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (swapcols k l A) = - det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swapcols k l A) = - det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (swapcols k l A) = - det A", "let ?B = \"transpose_mat A\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (swapcols k l A) = - det A", "let ?C = \"swaprows k l ?B\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (swapcols k l A) = - det A", "let ?D = \"transpose_mat ?C\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (swapcols k l A) = - det A", "have C: \"?C \\<in> carrier_mat n n\" and B: \"?B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l A\\<^sup>T \\<in> carrier_mat n n &&&\n    A\\<^sup>T \\<in> carrier_mat n n", "unfolding transpose_carrier_mat swaprows_carrier"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n &&& A \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n &&& A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  swaprows k l A\\<^sup>T \\<in> carrier_mat n n\n  A\\<^sup>T \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (swapcols k l A) = - det A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swapcols k l A) = - det A", "unfolding \n      swapcols_is_transp_swap_rows[OF A *(1-2)]\n      det_transpose[OF C] det_swaprows[OF * B] det_transpose[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. - det A = - det A", ".."], ["proof (state)\nthis:\n  det (swapcols k l A) = - det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_row_to_front_det: \"A \\<in> carrier_mat n n \\<Longrightarrow> I < n \\<Longrightarrow> det (swap_row_to_front A I)\n  = (-1)^I * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n    \\<Longrightarrow> det (swap_row_to_front A I) = (- (1::'a)) ^ I * det A", "proof (induct I arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "case (Suc I A)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n n; I < n\\<rbrakk>\n  \\<Longrightarrow> det (swap_row_to_front ?A I) = (- (1::'a)) ^ I * det ?A\n  A \\<in> carrier_mat n n\n  Suc I < n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "from Suc(3)"], ["proof (chain)\npicking this:\n  Suc I < n", "have I: \"I < n\""], ["proof (prove)\nusing this:\n  Suc I < n\n\ngoal (1 subgoal):\n 1. I < n", "by auto"], ["proof (state)\nthis:\n  I < n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "let ?I = \"Suc I\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "let ?A = \"swaprows I ?I A\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have AA: \"?A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows I (Suc I) A \\<in> carrier_mat n n", "using Suc(2)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. swaprows I (Suc I) A \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  swaprows I (Suc I) A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have \"det (swap_row_to_front A (Suc I)) = det (swap_row_to_front ?A I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swap_row_to_front A (Suc I)) =\n    det (swap_row_to_front (swaprows I (Suc I) A) I)", "by simp"], ["proof (state)\nthis:\n  det (swap_row_to_front A (Suc I)) =\n  det (swap_row_to_front (swaprows I (Suc I) A) I)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "also"], ["proof (state)\nthis:\n  det (swap_row_to_front A (Suc I)) =\n  det (swap_row_to_front (swaprows I (Suc I) A) I)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have \"\\<dots> = (-1)^I * det ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swap_row_to_front (swaprows I (Suc I) A) I) =\n    (- (1::'a)) ^ I * det (swaprows I (Suc I) A)", "by (rule Suc(1)[OF AA I])"], ["proof (state)\nthis:\n  det (swap_row_to_front (swaprows I (Suc I) A) I) =\n  (- (1::'a)) ^ I * det (swaprows I (Suc I) A)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "also"], ["proof (state)\nthis:\n  det (swap_row_to_front (swaprows I (Suc I) A) I) =\n  (- (1::'a)) ^ I * det (swaprows I (Suc I) A)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have \"det ?A = -1 * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swaprows I (Suc I) A) = - (1::'a) * det A", "using det_swaprows[OF I Suc(3) _ Suc(2)]"], ["proof (prove)\nusing this:\n  I \\<noteq> Suc I \\<Longrightarrow> det (swaprows I (Suc I) A) = - det A\n\ngoal (1 subgoal):\n 1. det (swaprows I (Suc I) A) = - (1::'a) * det A", "by simp"], ["proof (state)\nthis:\n  det (swaprows I (Suc I) A) = - (1::'a) * det A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_row_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "finally"], ["proof (chain)\npicking this:\n  det (swap_row_to_front A (Suc I)) = (- (1::'a)) ^ I * (- (1::'a) * det A)", "show ?case"], ["proof (prove)\nusing this:\n  det (swap_row_to_front A (Suc I)) = (- (1::'a)) ^ I * (- (1::'a) * det A)\n\ngoal (1 subgoal):\n 1. det (swap_row_to_front A (Suc I)) = (- (1::'a)) ^ Suc I * det A", "by simp"], ["proof (state)\nthis:\n  det (swap_row_to_front A (Suc I)) = (- (1::'a)) ^ Suc I * det A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_row_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A", "qed simp"], ["", "lemma swap_col_to_front_det: \"A \\<in> carrier_mat n n \\<Longrightarrow> I < n \\<Longrightarrow> det (swap_col_to_front A I)\n  = (-1)^I * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n    \\<Longrightarrow> det (swap_col_to_front A I) = (- (1::'a)) ^ I * det A", "proof (induct I arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "case (Suc I A)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n n; I < n\\<rbrakk>\n  \\<Longrightarrow> det (swap_col_to_front ?A I) = (- (1::'a)) ^ I * det ?A\n  A \\<in> carrier_mat n n\n  Suc I < n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "from Suc(3)"], ["proof (chain)\npicking this:\n  Suc I < n", "have I: \"I < n\""], ["proof (prove)\nusing this:\n  Suc I < n\n\ngoal (1 subgoal):\n 1. I < n", "by auto"], ["proof (state)\nthis:\n  I < n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "let ?I = \"Suc I\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "let ?A = \"swapcols I ?I A\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have AA: \"?A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swapcols I (Suc I) A \\<in> carrier_mat n n", "using Suc(2)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. swapcols I (Suc I) A \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  swapcols I (Suc I) A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have \"det (swap_col_to_front A (Suc I)) = det (swap_col_to_front ?A I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swap_col_to_front A (Suc I)) =\n    det (swap_col_to_front (swapcols I (Suc I) A) I)", "by simp"], ["proof (state)\nthis:\n  det (swap_col_to_front A (Suc I)) =\n  det (swap_col_to_front (swapcols I (Suc I) A) I)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "also"], ["proof (state)\nthis:\n  det (swap_col_to_front A (Suc I)) =\n  det (swap_col_to_front (swapcols I (Suc I) A) I)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have \"\\<dots> = (-1)^I * det ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swap_col_to_front (swapcols I (Suc I) A) I) =\n    (- (1::'a)) ^ I * det (swapcols I (Suc I) A)", "by (rule Suc(1)[OF AA I])"], ["proof (state)\nthis:\n  det (swap_col_to_front (swapcols I (Suc I) A) I) =\n  (- (1::'a)) ^ I * det (swapcols I (Suc I) A)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "also"], ["proof (state)\nthis:\n  det (swap_col_to_front (swapcols I (Suc I) A) I) =\n  (- (1::'a)) ^ I * det (swapcols I (Suc I) A)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "have \"det ?A = -1 * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (swapcols I (Suc I) A) = - (1::'a) * det A", "using det_swapcols[OF I Suc(3) _ Suc(2)]"], ["proof (prove)\nusing this:\n  I \\<noteq> Suc I \\<Longrightarrow> det (swapcols I (Suc I) A) = - det A\n\ngoal (1 subgoal):\n 1. det (swapcols I (Suc I) A) = - (1::'a) * det A", "by simp"], ["proof (state)\nthis:\n  det (swapcols I (Suc I) A) = - (1::'a) * det A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n n; I < n\\<rbrakk>\n                   \\<Longrightarrow> det (swap_col_to_front A I) =\n                                     (- (1::'a)) ^ I * det A;\n        A \\<in> carrier_mat n n; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A (Suc I)) =\n                         (- (1::'a)) ^ Suc I * det A", "finally"], ["proof (chain)\npicking this:\n  det (swap_col_to_front A (Suc I)) = (- (1::'a)) ^ I * (- (1::'a) * det A)", "show ?case"], ["proof (prove)\nusing this:\n  det (swap_col_to_front A (Suc I)) = (- (1::'a)) ^ I * (- (1::'a) * det A)\n\ngoal (1 subgoal):\n 1. det (swap_col_to_front A (Suc I)) = (- (1::'a)) ^ Suc I * det A", "by simp"], ["proof (state)\nthis:\n  det (swap_col_to_front A (Suc I)) = (- (1::'a)) ^ Suc I * det A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> det (swap_col_to_front A 0) =\n                         (- (1::'a)) ^ 0 * det A", "qed simp"], ["", "lemma swap_row_to_front_four_block: assumes A1: \"A1 \\<in> carrier_mat n m1\"\n  and A2: \"A2 \\<in> carrier_mat n m2\" \n  and A3: \"A3 \\<in> carrier_mat 1 m1\" \n  and A4: \"A4 \\<in> carrier_mat 1 m2\"\n  shows \"swap_row_to_front (four_block_mat A1 A2 A3 A4) n = four_block_mat A3 A4 A1 A2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_row_to_front (four_block_mat A1 A2 A3 A4) n =\n    four_block_mat A3 A4 A1 A2", "by (subst swap_row_to_front_result[OF four_block_carrier_mat[OF A1 A4]], force,\n  rule eq_matI, insert A1 A2 A3 A4, auto)"], ["", "lemma swap_col_to_front_four_block: assumes A1: \"A1 \\<in> carrier_mat n1 m\"\n  and A2: \"A2 \\<in> carrier_mat n1 1\" \n  and A3: \"A3 \\<in> carrier_mat n2 m\" \n  and A4: \"A4 \\<in> carrier_mat n2 1\"\n  shows \"swap_col_to_front (four_block_mat A1 A2 A3 A4) m = four_block_mat A2 A1 A4 A3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_col_to_front (four_block_mat A1 A2 A3 A4) m =\n    four_block_mat A2 A1 A4 A3", "by (subst swap_col_to_front_result[OF four_block_carrier_mat[OF A1 A4]], force,\n  rule eq_matI, insert A1 A2 A3 A4, auto)"], ["", "lemma det_four_block_mat_lower_right_zero_col: assumes A1: \"A1 \\<in> carrier_mat 1 n\"\n  and A2: \"A2 \\<in> carrier_mat 1 1\"\n  and A3: \"A3 \\<in> carrier_mat n n\"\n  and A40: \"A4 = (0\\<^sub>m n 1)\" \n  shows \"det (four_block_mat A1 A2 A3 A4) = (-1)^n * det A2 * det A3\" (is \"det ?A = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "let ?B = \"four_block_mat A3 A4 A1 A2\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "from four_block_carrier_mat[OF A3 A2]"], ["proof (chain)\npicking this:\n  four_block_mat A3 ?B ?C A2 \\<in> carrier_mat (n + 1) (n + 1)", "have B: \"?B \\<in> carrier_mat (Suc n) (Suc n)\""], ["proof (prove)\nusing this:\n  four_block_mat A3 ?B ?C A2 \\<in> carrier_mat (n + 1) (n + 1)\n\ngoal (1 subgoal):\n 1. four_block_mat A3 A4 A1 A2 \\<in> carrier_mat (Suc n) (Suc n)", "by simp"], ["proof (state)\nthis:\n  four_block_mat A3 A4 A1 A2 \\<in> carrier_mat (Suc n) (Suc n)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "from A40"], ["proof (chain)\npicking this:\n  A4 = 0\\<^sub>m n 1", "have A4: \"A4 \\<in> carrier_mat n 1\""], ["proof (prove)\nusing this:\n  A4 = 0\\<^sub>m n 1\n\ngoal (1 subgoal):\n 1. A4 \\<in> carrier_mat n 1", "by auto"], ["proof (state)\nthis:\n  A4 \\<in> carrier_mat n 1\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "from arg_cong[OF swap_row_to_front_four_block[OF A3 A4 A1 A2], of det]\n    swap_row_to_front_det[OF B, of n]"], ["proof (chain)\npicking this:\n  det (swap_row_to_front (four_block_mat A3 A4 A1 A2) n) =\n  det (four_block_mat A1 A2 A3 A4)\n  n < Suc n \\<Longrightarrow>\n  det (swap_row_to_front (four_block_mat A3 A4 A1 A2) n) =\n  (- (1::'a)) ^ n * det (four_block_mat A3 A4 A1 A2)", "have \"det ?A = (-1)^n * det ?B\""], ["proof (prove)\nusing this:\n  det (swap_row_to_front (four_block_mat A3 A4 A1 A2) n) =\n  det (four_block_mat A1 A2 A3 A4)\n  n < Suc n \\<Longrightarrow>\n  det (swap_row_to_front (four_block_mat A3 A4 A1 A2) n) =\n  (- (1::'a)) ^ n * det (four_block_mat A3 A4 A1 A2)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) =\n    (- (1::'a)) ^ n * det (four_block_mat A3 A4 A1 A2)", "by auto"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) =\n  (- (1::'a)) ^ n * det (four_block_mat A3 A4 A1 A2)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "also"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) =\n  (- (1::'a)) ^ n * det (four_block_mat A3 A4 A1 A2)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "have \"det ?B = det A3 * det A2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A3 A4 A1 A2) = det A3 * det A2", "by (rule det_four_block_mat_upper_right_zero_col[OF A3 A40 A1 A2])"], ["proof (state)\nthis:\n  det (four_block_mat A3 A4 A1 A2) = det A3 * det A2\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "finally"], ["proof (chain)\npicking this:\n  det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * (det A3 * det A2)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * (det A3 * det A2)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3", "by simp"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) = (- (1::'a)) ^ n * det A2 * det A3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_four_block_mat_lower_left_zero_col: assumes A1: \"A1 \\<in> carrier_mat 1 1\"\n  and A2: \"A2 \\<in> carrier_mat 1 n\"\n  and A30: \"A3 = (0\\<^sub>m n 1)\" \n  and A4: \"A4 \\<in> carrier_mat n n\"\n  shows \"det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\" (is \"det ?A = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from A30"], ["proof (chain)\npicking this:\n  A3 = 0\\<^sub>m n 1", "have A3: \"A3 \\<in> carrier_mat n 1\""], ["proof (prove)\nusing this:\n  A3 = 0\\<^sub>m n 1\n\ngoal (1 subgoal):\n 1. A3 \\<in> carrier_mat n 1", "by auto"], ["proof (state)\nthis:\n  A3 \\<in> carrier_mat n 1\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "let ?B = \"four_block_mat A2 A1 A4 A3\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from four_block_carrier_mat[OF A2 A3]"], ["proof (chain)\npicking this:\n  four_block_mat A2 ?B ?C A3 \\<in> carrier_mat (1 + n) (n + 1)", "have B: \"?B \\<in> carrier_mat (Suc n) (Suc n)\""], ["proof (prove)\nusing this:\n  four_block_mat A2 ?B ?C A3 \\<in> carrier_mat (1 + n) (n + 1)\n\ngoal (1 subgoal):\n 1. four_block_mat A2 A1 A4 A3 \\<in> carrier_mat (Suc n) (Suc n)", "by simp"], ["proof (state)\nthis:\n  four_block_mat A2 A1 A4 A3 \\<in> carrier_mat (Suc n) (Suc n)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "from arg_cong[OF swap_col_to_front_four_block[OF A2 A1 A4 A3], of det]\n    swap_col_to_front_det[OF B, of n]"], ["proof (chain)\npicking this:\n  det (swap_col_to_front (four_block_mat A2 A1 A4 A3) n) =\n  det (four_block_mat A1 A2 A3 A4)\n  n < Suc n \\<Longrightarrow>\n  det (swap_col_to_front (four_block_mat A2 A1 A4 A3) n) =\n  (- (1::'a)) ^ n * det (four_block_mat A2 A1 A4 A3)", "have \"det ?A = (-1)^n * det ?B\""], ["proof (prove)\nusing this:\n  det (swap_col_to_front (four_block_mat A2 A1 A4 A3) n) =\n  det (four_block_mat A1 A2 A3 A4)\n  n < Suc n \\<Longrightarrow>\n  det (swap_col_to_front (four_block_mat A2 A1 A4 A3) n) =\n  (- (1::'a)) ^ n * det (four_block_mat A2 A1 A4 A3)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) =\n    (- (1::'a)) ^ n * det (four_block_mat A2 A1 A4 A3)", "by auto"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) =\n  (- (1::'a)) ^ n * det (four_block_mat A2 A1 A4 A3)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) =\n  (- (1::'a)) ^ n * det (four_block_mat A2 A1 A4 A3)\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"det ?B = (- 1) ^ n * det A1 * det A4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat A2 A1 A4 A3) = (- (1::'a)) ^ n * det A1 * det A4", "by (rule det_four_block_mat_lower_right_zero_col[OF A2 A1 A4 A30])"], ["proof (state)\nthis:\n  det (four_block_mat A2 A1 A4 A3) = (- (1::'a)) ^ n * det A1 * det A4\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "also"], ["proof (state)\nthis:\n  det (four_block_mat A2 A1 A4 A3) = (- (1::'a)) ^ n * det A1 * det A4\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "have \"(-1)^n * \\<dots> = (-1 * -1)^n * det A1 * det A4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ n * ((- (1::'a)) ^ n * det A1 * det A4) =\n    (- (1::'a) * - (1::'a)) ^ n * det A1 * det A4", "unfolding power_mult_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ n * ((- (1::'a)) ^ n * det A1 * det A4) =\n    (- (1::'a)) ^ n * (- (1::'a)) ^ n * det A1 * det A4", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (- (1::'a)) ^ n * ((- (1::'a)) ^ n * det A1 * det A4) =\n  (- (1::'a) * - (1::'a)) ^ n * det A1 * det A4\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "finally"], ["proof (chain)\npicking this:\n  det (four_block_mat A1 A2 A3 A4) =\n  (- (1::'a) * - (1::'a)) ^ n * det A1 * det A4", "show ?thesis"], ["proof (prove)\nusing this:\n  det (four_block_mat A1 A2 A3 A4) =\n  (- (1::'a) * - (1::'a)) ^ n * det A1 * det A4\n\ngoal (1 subgoal):\n 1. det (four_block_mat A1 A2 A3 A4) = det A1 * det A4", "by simp"], ["proof (state)\nthis:\n  det (four_block_mat A1 A2 A3 A4) = det A1 * det A4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_addcol[simp]: \n  assumes l: \"l < n\" and k: \"k \\<noteq> l\" and A: \"A \\<in> carrier_mat n n\"\n  shows \"det (addcol a k l A) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "have \"addcol a k l A = A * addrow_mat n a l k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addcol a k l A = A * addrow_mat n a l k", "using addcol_mat[OF A l]"], ["proof (prove)\nusing this:\n  addcol ?a ?l l A = A * addrow_mat n ?a l ?l\n\ngoal (1 subgoal):\n 1. addcol a k l A = A * addrow_mat n a l k", "."], ["proof (state)\nthis:\n  addcol a k l A = A * addrow_mat n a l k\n\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "also"], ["proof (state)\nthis:\n  addcol a k l A = A * addrow_mat n a l k\n\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "have \"det (A * addrow_mat n a l k) = det A * det (addrow_mat n a l k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (A * addrow_mat n a l k) = det A * det (addrow_mat n a l k)", "by(rule det_mult[OF A], auto)"], ["proof (state)\nthis:\n  det (A * addrow_mat n a l k) = det A * det (addrow_mat n a l k)\n\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "also"], ["proof (state)\nthis:\n  det (A * addrow_mat n a l k) = det A * det (addrow_mat n a l k)\n\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "have \"det (addrow_mat n a l k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addrow_mat n a l k) = (1::'a)", "using det_addrow_mat[OF k[symmetric]]"], ["proof (prove)\nusing this:\n  det (addrow_mat ?n ?a l k) = (1::?'a)\n\ngoal (1 subgoal):\n 1. det (addrow_mat n a l k) = (1::'a)", "."], ["proof (state)\nthis:\n  det (addrow_mat n a l k) = (1::'a)\n\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "finally"], ["proof (chain)\npicking this:\n  det (addcol a k l A) = det A * (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (addcol a k l A) = det A * (1::'a)\n\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "using A"], ["proof (prove)\nusing this:\n  det (addcol a k l A) = det A * (1::'a)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (addcol a k l A) = det A", "by simp"], ["proof (state)\nthis:\n  det (addcol a k l A) = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"insert_index i \\<equiv> \\<lambda>i'. if i' < i then i' else Suc i'\""], ["", "definition \"delete_index i \\<equiv> \\<lambda>i'. if i' < i then i' else i' - Suc 0\""], ["", "lemma insert_index[simp]:\n  \"i' < i \\<Longrightarrow> insert_index i i' = i'\"\n  \"i' \\<ge> i \\<Longrightarrow> insert_index i i' = Suc i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i' < i \\<Longrightarrow> insert_index i i' = i') &&&\n    (i \\<le> i' \\<Longrightarrow> insert_index i i' = Suc i')", "unfolding insert_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i' < i \\<Longrightarrow> (if i' < i then i' else Suc i') = i') &&&\n    (i \\<le> i' \\<Longrightarrow> (if i' < i then i' else Suc i') = Suc i')", "by auto"], ["", "lemma delete_insert_index[simp]:\n  \"delete_index i (insert_index i i') = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_index i (insert_index i i') = i'", "unfolding insert_index_def delete_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if i' < i then i' else Suc i') < i\n     then if i' < i then i' else Suc i'\n     else (if i' < i then i' else Suc i') - Suc 0) =\n    i'", "by auto"], ["", "lemma insert_delete_index:\n  assumes i'i: \"i' \\<noteq> i\"\n  shows \"insert_index i (delete_index i i') = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index i (delete_index i i') = i'", "unfolding insert_index_def delete_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if i' < i then i' else i' - Suc 0) < i\n     then if i' < i then i' else i' - Suc 0\n     else Suc (if i' < i then i' else i' - Suc 0)) =\n    i'", "using i'i"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. (if (if i' < i then i' else i' - Suc 0) < i\n     then if i' < i then i' else i' - Suc 0\n     else Suc (if i' < i then i' else i' - Suc 0)) =\n    i'", "by auto"], ["", "definition \"delete_dom p i \\<equiv> \\<lambda>i'. p (insert_index i i')\""], ["", "definition \"delete_ran p j \\<equiv> \\<lambda>i. delete_index j (p i)\""], ["", "definition \"permutation_delete p i = delete_ran (delete_dom p i) (p i)\""], ["", "definition \"insert_ran p j \\<equiv> \\<lambda>i. insert_index j (p i)\""], ["", "definition \"insert_dom p i j \\<equiv>\n  \\<lambda>i'. if i' < i then p i' else if i' = i then j else p (i'-1)\""], ["", "definition \"permutation_insert i j p \\<equiv> insert_dom (insert_ran p j) i j\""], ["", "lemmas permutation_delete_expand =\n  permutation_delete_def[unfolded delete_dom_def delete_ran_def insert_index_def delete_index_def]"], ["", "lemmas permutation_insert_expand =\n  permutation_insert_def[unfolded insert_dom_def insert_ran_def insert_index_def delete_index_def]"], ["", "lemma permutation_insert_inserted[simp]:\n  \"permutation_insert (i::nat) j p i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i j p i = j", "unfolding permutation_insert_expand"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < i then if p i < j then p i else Suc (p i)\n     else if i = i then j\n          else if p (i - 1) < j then p (i - 1) else Suc (p (i - 1))) =\n    j", "by auto"], ["", "lemma permutation_insert_base:\n  assumes p: \"p permutes {0..<n}\"\n  shows \"permutation_insert n n p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert n n p = p", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. permutation_insert n n p x = p x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. permutation_insert n n p x = p x", "show \"permutation_insert n n p x = p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert n n p x = p x", "apply (cases rule: linorder_cases[of \"x\" \"n\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. x < n \\<Longrightarrow> permutation_insert n n p x = p x\n 2. x = n \\<Longrightarrow> permutation_insert n n p x = p x\n 3. n < x \\<Longrightarrow> permutation_insert n n p x = p x", "unfolding permutation_insert_expand"], ["proof (prove)\ngoal (3 subgoals):\n 1. x < n \\<Longrightarrow>\n    (if x < n then if p x < n then p x else Suc (p x)\n     else if x = n then n\n          else if p (x - 1) < n then p (x - 1) else Suc (p (x - 1))) =\n    p x\n 2. x = n \\<Longrightarrow>\n    (if x < n then if p x < n then p x else Suc (p x)\n     else if x = n then n\n          else if p (x - 1) < n then p (x - 1) else Suc (p (x - 1))) =\n    p x\n 3. n < x \\<Longrightarrow>\n    (if x < n then if p x < n then p x else Suc (p x)\n     else if x = n then n\n          else if p (x - 1) < n then p (x - 1) else Suc (p (x - 1))) =\n    p x", "using permutes_others[OF p] p"], ["proof (prove)\nusing this:\n  ?x \\<notin> {0..<n} \\<Longrightarrow> p ?x = ?x\n  p permutes {0..<n}\n\ngoal (3 subgoals):\n 1. x < n \\<Longrightarrow>\n    (if x < n then if p x < n then p x else Suc (p x)\n     else if x = n then n\n          else if p (x - 1) < n then p (x - 1) else Suc (p (x - 1))) =\n    p x\n 2. x = n \\<Longrightarrow>\n    (if x < n then if p x < n then p x else Suc (p x)\n     else if x = n then n\n          else if p (x - 1) < n then p (x - 1) else Suc (p (x - 1))) =\n    p x\n 3. n < x \\<Longrightarrow>\n    (if x < n then if p x < n then p x else Suc (p x)\n     else if x = n then n\n          else if p (x - 1) < n then p (x - 1) else Suc (p (x - 1))) =\n    p x", "by auto"], ["proof (state)\nthis:\n  permutation_insert n n p x = p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_insert_row_step:\n  shows \"permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id = permutation_insert i j p\"\n    (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id =\n    permutation_insert i j p", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id) x =\n       permutation_insert i j p x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id) x =\n       permutation_insert i j p x", "show \"?l x = ?r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id) x =\n    permutation_insert i j p x", "apply (cases rule: linorder_cases[of \"x\" \"i\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. x < i \\<Longrightarrow>\n    (permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id) x =\n    permutation_insert i j p x\n 2. x = i \\<Longrightarrow>\n    (permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id) x =\n    permutation_insert i j p x\n 3. i < x \\<Longrightarrow>\n    (permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id) x =\n    permutation_insert i j p x", "unfolding permutation_insert_expand swap_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. x < i \\<Longrightarrow>\n    ((\\<lambda>i'.\n         if i' < Suc i then if p i' < j then p i' else Suc (p i')\n         else if i' = Suc i then j\n              else if p (i' - 1) < j then p (i' - 1)\n                   else Suc (p (i' - 1))) \\<circ>\n     id(i := id (Suc i), Suc i := id i))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 2. x = i \\<Longrightarrow>\n    ((\\<lambda>i'.\n         if i' < Suc i then if p i' < j then p i' else Suc (p i')\n         else if i' = Suc i then j\n              else if p (i' - 1) < j then p (i' - 1)\n                   else Suc (p (i' - 1))) \\<circ>\n     id(i := id (Suc i), Suc i := id i))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 3. i < x \\<Longrightarrow>\n    ((\\<lambda>i'.\n         if i' < Suc i then if p i' < j then p i' else Suc (p i')\n         else if i' = Suc i then j\n              else if p (i' - 1) < j then p (i' - 1)\n                   else Suc (p (i' - 1))) \\<circ>\n     id(i := id (Suc i), Suc i := id i))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))", "by auto"], ["proof (state)\nthis:\n  (permutation_insert (Suc i) j p \\<circ> Fun.swap i (Suc i) id) x =\n  permutation_insert i j p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_insert_column_step:\n  assumes p: \"p permutes {0..<n}\" and \"j < n\"\n  shows \"(Fun.swap j (Suc j) id) \\<circ> (permutation_insert i (Suc j) p) = permutation_insert i j p\"\n    (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p =\n    permutation_insert i j p", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n       permutation_insert i j p x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n       permutation_insert i j p x", "show \"?l x = ?r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "proof (cases rule: linorder_cases[of \"x\" \"i\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. x < i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. x = i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 3. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "case less"], ["proof (state)\nthis:\n  x < i\n\ngoal (3 subgoals):\n 1. x < i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. x = i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 3. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "note x = this"], ["proof (state)\nthis:\n  x < i\n\ngoal (3 subgoals):\n 1. x < i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. x = i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 3. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "apply (cases rule: linorder_cases[of \"p x\" \"j\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. p x < j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. p x = j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 3. j < p x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "unfolding permutation_insert_expand"], ["proof (prove)\ngoal (3 subgoals):\n 1. p x < j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 2. p x = j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 3. j < p x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))", "using x"], ["proof (prove)\nusing this:\n  x < i\n\ngoal (3 subgoals):\n 1. p x < j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 2. p x = j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 3. j < p x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))", "by simp+"], ["proof (state)\nthis:\n  (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n  permutation_insert i j p x\n\ngoal (2 subgoals):\n 1. x = i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x = i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "case equal"], ["proof (state)\nthis:\n  x = i\n\ngoal (2 subgoals):\n 1. x = i \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = i\n\ngoal (1 subgoal):\n 1. (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "by simp"], ["proof (state)\nthis:\n  (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n  permutation_insert i j p x\n\ngoal (1 subgoal):\n 1. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "case greater"], ["proof (state)\nthis:\n  i < x\n\ngoal (1 subgoal):\n 1. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "note x = this"], ["proof (state)\nthis:\n  i < x\n\ngoal (1 subgoal):\n 1. i < x \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "apply (cases rule: linorder_cases[of \"p (x-1)\" \"j\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. p (x - 1) < j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 2. p (x - 1) = j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x\n 3. j < p (x - 1) \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n    permutation_insert i j p x", "unfolding permutation_insert_expand"], ["proof (prove)\ngoal (3 subgoals):\n 1. p (x - 1) < j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 2. p (x - 1) = j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 3. j < p (x - 1) \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))", "using x"], ["proof (prove)\nusing this:\n  i < x\n\ngoal (3 subgoals):\n 1. p (x - 1) < j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 2. p (x - 1) = j \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))\n 3. j < p (x - 1) \\<Longrightarrow>\n    (Fun.swap j (Suc j) id \\<circ>\n     (\\<lambda>i'.\n         if i' < i then if p i' < Suc j then p i' else Suc (p i')\n         else if i' = i then Suc j\n              else if p (i' - 1) < Suc j then p (i' - 1)\n                   else Suc (p (i' - 1))))\n     x =\n    (if x < i then if p x < j then p x else Suc (p x)\n     else if x = i then j\n          else if p (x - 1) < j then p (x - 1) else Suc (p (x - 1)))", "by simp+"], ["proof (state)\nthis:\n  (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n  permutation_insert i j p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Fun.swap j (Suc j) id \\<circ> permutation_insert i (Suc j) p) x =\n  permutation_insert i j p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_dom_image:\n  assumes i: \"i \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes iff: \"\\<forall>i' \\<in> ?N. f i' = f i \\<longrightarrow> i' = i\"\n  shows \"delete_dom f i ` {0..<n} = f ` ?N - {f i}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_dom f i ` {0..<n} = f ` {0..<Suc n} - {f i}", "proof(unfold set_eq_iff, intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_dom f i ` {0..<n} \\<Longrightarrow>\n       x \\<in> f ` {0..<Suc n} - {f i}\n 2. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "fix j'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_dom f i ` {0..<n} \\<Longrightarrow>\n       x \\<in> f ` {0..<Suc n} - {f i}\n 2. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_dom f i ` {0..<n} \\<Longrightarrow>\n       x \\<in> f ` {0..<Suc n} - {f i}\n 2. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "assume L: \"j' \\<in> ?L\""], ["proof (state)\nthis:\n  j' \\<in> delete_dom f i ` {0..<n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_dom f i ` {0..<n} \\<Longrightarrow>\n       x \\<in> f ` {0..<Suc n} - {f i}\n 2. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "then"], ["proof (chain)\npicking this:\n  j' \\<in> delete_dom f i ` {0..<n}", "obtain i' where i': \"i' \\<in> {0..<n}\" and dj': \"delete_dom f i i' = j'\""], ["proof (prove)\nusing this:\n  j' \\<in> delete_dom f i ` {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i' \\<in> {0..<n}; delete_dom f i i' = j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' \\<in> {0..<n}\n  delete_dom f i i' = j'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_dom f i ` {0..<n} \\<Longrightarrow>\n       x \\<in> f ` {0..<Suc n} - {f i}\n 2. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "show \"j' \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> f ` {0..<Suc n} - {f i}", "proof(cases \"i' < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> f ` {0..<Suc n} - {f i}\n 2. \\<not> i' < i \\<Longrightarrow> j' \\<in> f ` {0..<Suc n} - {f i}", "case True"], ["proof (state)\nthis:\n  i' < i\n\ngoal (2 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> f ` {0..<Suc n} - {f i}\n 2. \\<not> i' < i \\<Longrightarrow> j' \\<in> f ` {0..<Suc n} - {f i}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> f ` {0..<Suc n} - {f i}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> {y. \\<exists>x\\<in>{0..<Suc n}. y = f x} - {f i}", "unfolding Diff_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> {y. \\<exists>x\\<in>{0..<Suc n}. y = f x} \\<and>\n    j' \\<notin> {f i}", "unfolding mem_Collect_eq singleton_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>{0..<Suc n}. j' = f x) \\<and> j' \\<noteq> f i", "proof(intro conjI bexI)"], ["proof (state)\ngoal (3 subgoals):\n 1. j' = f ?x1\n 2. ?x1 \\<in> {0..<Suc n}\n 3. j' \\<noteq> f i", "show \"j' \\<noteq> f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<noteq> f i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. j' = f i \\<Longrightarrow> False", "assume j': \"j' = f i\""], ["proof (state)\nthis:\n  j' = f i\n\ngoal (1 subgoal):\n 1. j' = f i \\<Longrightarrow> False", "hence \"f i' = f i\""], ["proof (prove)\nusing this:\n  j' = f i\n\ngoal (1 subgoal):\n 1. f i' = f i", "using dj'[unfolded delete_dom_def insert_index_def]"], ["proof (prove)\nusing this:\n  j' = f i\n  f (if i' < i then i' else Suc i') = j'\n\ngoal (1 subgoal):\n 1. f i' = f i", "using True"], ["proof (prove)\nusing this:\n  j' = f i\n  f (if i' < i then i' else Suc i') = j'\n  i' < i\n\ngoal (1 subgoal):\n 1. f i' = f i", "by simp"], ["proof (state)\nthis:\n  f i' = f i\n\ngoal (1 subgoal):\n 1. j' = f i \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  f i' = f i\n\ngoal (1 subgoal):\n 1. False", "using iff i True"], ["proof (prove)\nusing this:\n  f i' = f i\n  \\<forall>i'\\<in>{0..<Suc n}. f i' = f i \\<longrightarrow> i' = i\n  i \\<in> {0..<Suc n}\n  i' < i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<noteq> f i\n\ngoal (2 subgoals):\n 1. j' = f ?x1\n 2. ?x1 \\<in> {0..<Suc n}", "show \"j' = f i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' = f i'", "using dj' True"], ["proof (prove)\nusing this:\n  delete_dom f i i' = j'\n  i' < i\n\ngoal (1 subgoal):\n 1. j' = f i'", "unfolding delete_dom_def insert_index_def"], ["proof (prove)\nusing this:\n  f (if i' < i then i' else Suc i') = j'\n  i' < i\n\ngoal (1 subgoal):\n 1. j' = f i'", "by simp"], ["proof (state)\nthis:\n  j' = f i'\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<Suc n}", "qed (insert i',simp)"], ["proof (state)\nthis:\n  j' \\<in> f ` {0..<Suc n} - {f i}\n\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> f ` {0..<Suc n} - {f i}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> f ` {0..<Suc n} - {f i}", "case False"], ["proof (state)\nthis:\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> f ` {0..<Suc n} - {f i}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> f ` {0..<Suc n} - {f i}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> {y. \\<exists>x\\<in>{0..<Suc n}. y = f x} - {f i}", "unfolding Diff_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> {y. \\<exists>x\\<in>{0..<Suc n}. y = f x} \\<and>\n    j' \\<notin> {f i}", "unfolding mem_Collect_eq singleton_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>{0..<Suc n}. j' = f x) \\<and> j' \\<noteq> f i", "proof(intro conjI bexI)"], ["proof (state)\ngoal (3 subgoals):\n 1. j' = f ?x1\n 2. ?x1 \\<in> {0..<Suc n}\n 3. j' \\<noteq> f i", "show Si': \"Suc i' \\<in> ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i' \\<in> {0..<Suc n}", "using i'"], ["proof (prove)\nusing this:\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. Suc i' \\<in> {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  Suc i' \\<in> {0..<Suc n}\n\ngoal (2 subgoals):\n 1. j' = f (Suc i')\n 2. j' \\<noteq> f i", "show \"j' \\<noteq> f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<noteq> f i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. j' = f i \\<Longrightarrow> False", "assume j': \"j' = f i\""], ["proof (state)\nthis:\n  j' = f i\n\ngoal (1 subgoal):\n 1. j' = f i \\<Longrightarrow> False", "hence \"f (Suc i') = f i\""], ["proof (prove)\nusing this:\n  j' = f i\n\ngoal (1 subgoal):\n 1. f (Suc i') = f i", "using dj'[unfolded delete_dom_def insert_index_def] j' False"], ["proof (prove)\nusing this:\n  j' = f i\n  f (if i' < i then i' else Suc i') = j'\n  j' = f i\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. f (Suc i') = f i", "by simp"], ["proof (state)\nthis:\n  f (Suc i') = f i\n\ngoal (1 subgoal):\n 1. j' = f i \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  f (Suc i') = f i\n\ngoal (1 subgoal):\n 1. False", "using iff Si' False"], ["proof (prove)\nusing this:\n  f (Suc i') = f i\n  \\<forall>i'\\<in>{0..<Suc n}. f i' = f i \\<longrightarrow> i' = i\n  Suc i' \\<in> {0..<Suc n}\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<noteq> f i\n\ngoal (1 subgoal):\n 1. j' = f (Suc i')", "show \"j' = f (Suc i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' = f (Suc i')", "using dj' False"], ["proof (prove)\nusing this:\n  delete_dom f i i' = j'\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. j' = f (Suc i')", "unfolding delete_dom_def insert_index_def"], ["proof (prove)\nusing this:\n  f (if i' < i then i' else Suc i') = j'\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. j' = f (Suc i')", "by simp"], ["proof (state)\nthis:\n  j' = f (Suc i')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> f ` {0..<Suc n} - {f i}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> f ` {0..<Suc n} - {f i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "}"], ["proof (state)\nthis:\n  j' \\<in> delete_dom f i ` {0..<n} \\<Longrightarrow>\n  j' \\<in> f ` {0..<Suc n} - {f i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "{"], ["proof (state)\nthis:\n  j' \\<in> delete_dom f i ` {0..<n} \\<Longrightarrow>\n  j' \\<in> f ` {0..<Suc n} - {f i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "assume R: \"j' \\<in> ?R\""], ["proof (state)\nthis:\n  j' \\<in> f ` {0..<Suc n} - {f i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "then"], ["proof (chain)\npicking this:\n  j' \\<in> f ` {0..<Suc n} - {f i}", "obtain i'\n      where i': \"i' \\<in> ?N\" and j'fi: \"j' \\<noteq> f i\" and j'fi': \"j' = f i'\""], ["proof (prove)\nusing this:\n  j' \\<in> f ` {0..<Suc n} - {f i}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i' \\<in> {0..<Suc n}; j' \\<noteq> f i; j' = f i'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' \\<in> {0..<Suc n}\n  j' \\<noteq> f i\n  j' = f i'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "hence i'i: \"i' \\<noteq> i\""], ["proof (prove)\nusing this:\n  i' \\<in> {0..<Suc n}\n  j' \\<noteq> f i\n  j' = f i'\n\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "using iff"], ["proof (prove)\nusing this:\n  i' \\<in> {0..<Suc n}\n  j' \\<noteq> f i\n  j' = f i'\n  \\<forall>i'\\<in>{0..<Suc n}. f i' = f i \\<longrightarrow> i' = i\n\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "by auto"], ["proof (state)\nthis:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "hence n: \"n > 0\""], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. 0 < n", "using i i'"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  i \\<in> {0..<Suc n}\n  i' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n       x \\<in> delete_dom f i ` {0..<n}", "show \"j' \\<in> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> delete_dom f i ` {0..<n}", "proof (cases \"i' < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> delete_dom f i ` {0..<n}\n 2. \\<not> i' < i \\<Longrightarrow> j' \\<in> delete_dom f i ` {0..<n}", "case True"], ["proof (state)\nthis:\n  i' < i\n\ngoal (2 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> delete_dom f i ` {0..<n}\n 2. \\<not> i' < i \\<Longrightarrow> j' \\<in> delete_dom f i ` {0..<n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> delete_dom f i ` {0..<n}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. j' = delete_dom f i ?x\n 2. ?x \\<in> {0..<n}", "show \"j' = delete_dom f i i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' = delete_dom f i i'", "unfolding delete_dom_def insert_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' = f (if i' < i then i' else Suc i')", "using True j'fi'"], ["proof (prove)\nusing this:\n  i' < i\n  j' = f i'\n\ngoal (1 subgoal):\n 1. j' = f (if i' < i then i' else Suc i')", "by simp"], ["proof (state)\nthis:\n  j' = delete_dom f i i'\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<n}", "qed (insert True i, simp)"], ["proof (state)\nthis:\n  j' \\<in> delete_dom f i ` {0..<n}\n\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> delete_dom f i ` {0..<n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> delete_dom f i ` {0..<n}", "case False"], ["proof (state)\nthis:\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> delete_dom f i ` {0..<n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> delete_dom f i ` {0..<n}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. j' = delete_dom f i ?x\n 2. ?x \\<in> {0..<n}", "show \"i'-1 \\<in> {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' - 1 \\<in> {0..<n}", "using i' n"], ["proof (prove)\nusing this:\n  i' \\<in> {0..<Suc n}\n  0 < n\n\ngoal (1 subgoal):\n 1. i' - 1 \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  i' - 1 \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. j' = delete_dom f i (i' - 1)", "show \"j' = delete_dom f i (i'-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' = delete_dom f i (i' - 1)", "unfolding delete_dom_def insert_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' = f (if i' - 1 < i then i' - 1 else Suc (i' - 1))", "using False j'fi' i'i"], ["proof (prove)\nusing this:\n  \\<not> i' < i\n  j' = f i'\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. j' = f (if i' - 1 < i then i' - 1 else Suc (i' - 1))", "by auto"], ["proof (state)\nthis:\n  j' = delete_dom f i (i' - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> delete_dom f i ` {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> delete_dom f i ` {0..<n}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  j' \\<in> f ` {0..<Suc n} - {f i} \\<Longrightarrow>\n  j' \\<in> delete_dom f i ` {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_ran_image:\n  assumes j: \"j \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes fimg: \"f ` {0..<n} =  ?N - {j}\"\n  shows \"delete_ran f j ` {0..<n} = {0..<n}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_ran f j ` {0..<n} = {0..<n}", "proof(unfold set_eq_iff, intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> x \\<in> {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "fix j'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> x \\<in> {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> x \\<in> {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "assume L: \"j' \\<in> ?L\""], ["proof (state)\nthis:\n  j' \\<in> delete_ran f j ` {0..<n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> x \\<in> {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "then"], ["proof (chain)\npicking this:\n  j' \\<in> delete_ran f j ` {0..<n}", "obtain i where i: \"i \\<in> {0..<n}\" and ij': \"delete_ran f j i = j'\""], ["proof (prove)\nusing this:\n  j' \\<in> delete_ran f j ` {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> {0..<n}; delete_ran f j i = j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> {0..<n}\n  delete_ran f j i = j'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> x \\<in> {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "have \"f i \\<in> ?N - {j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<in> {0..<Suc n} - {j}", "using fimg i"], ["proof (prove)\nusing this:\n  f ` {0..<n} = {0..<Suc n} - {j}\n  i \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. f i \\<in> {0..<Suc n} - {j}", "by blast"], ["proof (state)\nthis:\n  f i \\<in> {0..<Suc n} - {j}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> x \\<in> {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "thus \"j' \\<in> ?R\""], ["proof (prove)\nusing this:\n  f i \\<in> {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<n}", "using ij' j"], ["proof (prove)\nusing this:\n  f i \\<in> {0..<Suc n} - {j}\n  delete_ran f j i = j'\n  j \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<n}", "unfolding delete_ran_def delete_index_def"], ["proof (prove)\nusing this:\n  f i \\<in> {0..<Suc n} - {j}\n  (if f i < j then f i else f i - Suc 0) = j'\n  j \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "}"], ["proof (state)\nthis:\n  j' \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> j' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "{"], ["proof (state)\nthis:\n  j' \\<in> delete_ran f j ` {0..<n} \\<Longrightarrow> j' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "assume R: \"j' \\<in> ?R\""], ["proof (state)\nthis:\n  j' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow> x \\<in> delete_ran f j ` {0..<n}", "show \"j' \\<in> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> delete_ran f j ` {0..<n}", "proof (cases \"j' < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}\n 2. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "case True"], ["proof (state)\nthis:\n  j' < j\n\ngoal (2 subgoals):\n 1. j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}\n 2. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "hence \"j' \\<in> ?N - {j}\""], ["proof (prove)\nusing this:\n  j' < j\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n} - {j}", "using R"], ["proof (prove)\nusing this:\n  j' < j\n  j' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n} - {j}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n} - {j}\n\ngoal (2 subgoals):\n 1. j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}\n 2. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "then"], ["proof (chain)\npicking this:\n  j' \\<in> {0..<Suc n} - {j}", "obtain i where fij': \"f i = j'\" and i: \"i \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  j' \\<in> {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>f i = j'; i \\<in> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fimg[symmetric]"], ["proof (prove)\nusing this:\n  j' \\<in> f ` {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>f i = j'; i \\<in> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f i = j'\n  i \\<in> {0..<n}\n\ngoal (2 subgoals):\n 1. j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}\n 2. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "have \"delete_ran f j i = j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_ran f j i = j'", "unfolding delete_ran_def delete_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if f i < j then f i else f i - Suc 0) = j'", "unfolding fij'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j' < j then j' else j' - Suc 0) = j'", "using True"], ["proof (prove)\nusing this:\n  j' < j\n\ngoal (1 subgoal):\n 1. (if j' < j then j' else j' - Suc 0) = j'", "by simp"], ["proof (state)\nthis:\n  delete_ran f j i = j'\n\ngoal (2 subgoals):\n 1. j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}\n 2. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  delete_ran f j i = j'\n\ngoal (1 subgoal):\n 1. j' \\<in> delete_ran f j ` {0..<n}", "using i"], ["proof (prove)\nusing this:\n  delete_ran f j i = j'\n  i \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. j' \\<in> delete_ran f j ` {0..<n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> delete_ran f j ` {0..<n}\n\ngoal (1 subgoal):\n 1. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "case False"], ["proof (state)\nthis:\n  \\<not> j' < j\n\ngoal (1 subgoal):\n 1. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "hence \"Suc j' \\<in> ?N - {j}\""], ["proof (prove)\nusing this:\n  \\<not> j' < j\n\ngoal (1 subgoal):\n 1. Suc j' \\<in> {0..<Suc n} - {j}", "using R"], ["proof (prove)\nusing this:\n  \\<not> j' < j\n  j' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. Suc j' \\<in> {0..<Suc n} - {j}", "by auto"], ["proof (state)\nthis:\n  Suc j' \\<in> {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "then"], ["proof (chain)\npicking this:\n  Suc j' \\<in> {0..<Suc n} - {j}", "obtain i where fij': \"f i = Suc j'\" and i: \"i \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  Suc j' \\<in> {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>f i = Suc j'; i \\<in> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fimg[symmetric]"], ["proof (prove)\nusing this:\n  Suc j' \\<in> f ` {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>f i = Suc j'; i \\<in> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f i = Suc j'\n  i \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "have \"delete_ran f j i = j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_ran f j i = j'", "unfolding delete_ran_def delete_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if f i < j then f i else f i - Suc 0) = j'", "unfolding fij'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc j' < j then Suc j' else Suc j' - Suc 0) = j'", "using False"], ["proof (prove)\nusing this:\n  \\<not> j' < j\n\ngoal (1 subgoal):\n 1. (if Suc j' < j then Suc j' else Suc j' - Suc 0) = j'", "by simp"], ["proof (state)\nthis:\n  delete_ran f j i = j'\n\ngoal (1 subgoal):\n 1. \\<not> j' < j \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  delete_ran f j i = j'\n\ngoal (1 subgoal):\n 1. j' \\<in> delete_ran f j ` {0..<n}", "using i"], ["proof (prove)\nusing this:\n  delete_ran f j i = j'\n  i \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. j' \\<in> delete_ran f j ` {0..<n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> delete_ran f j ` {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> delete_ran f j ` {0..<n}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  j' \\<in> {0..<n} \\<Longrightarrow> j' \\<in> delete_ran f j ` {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_index_inj_on:\n  assumes iS: \"i \\<notin> S\"\n  shows \"inj_on (delete_index i) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (delete_index i) S", "proof(intro inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        delete_index i x = delete_index i y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        delete_index i x = delete_index i y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume eq: \"delete_index i x = delete_index i y\" and x: \"x \\<in> S\" and y: \"y \\<in> S\""], ["proof (state)\nthis:\n  delete_index i x = delete_index i y\n  x \\<in> S\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        delete_index i x = delete_index i y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"x \\<noteq> i\" \"y \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> i &&& y \\<noteq> i", "using x y iS"], ["proof (prove)\nusing this:\n  x \\<in> S\n  y \\<in> S\n  i \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<noteq> i &&& y \\<noteq> i", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> i\n  y \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        delete_index i x = delete_index i y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  x \\<noteq> i\n  y \\<noteq> i\n\ngoal (1 subgoal):\n 1. x = y", "using eq"], ["proof (prove)\nusing this:\n  x \\<noteq> i\n  y \\<noteq> i\n  delete_index i x = delete_index i y\n\ngoal (1 subgoal):\n 1. x = y", "unfolding delete_index_def"], ["proof (prove)\nusing this:\n  x \\<noteq> i\n  y \\<noteq> i\n  (if x < i then x else x - Suc 0) = (if y < i then y else y - Suc 0)\n\ngoal (1 subgoal):\n 1. x = y", "by(cases \"x < i\"; cases \"y < i\";simp)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_index_inj_on:\n  shows \"inj_on (insert_index i) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (insert_index i) S", "proof(intro inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        insert_index i x = insert_index i y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        insert_index i x = insert_index i y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume eq: \"insert_index i x = insert_index i y\" and x: \"x \\<in> S\" and y: \"y \\<in> S\""], ["proof (state)\nthis:\n  insert_index i x = insert_index i y\n  x \\<in> S\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        insert_index i x = insert_index i y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using eq"], ["proof (prove)\nusing this:\n  insert_index i x = insert_index i y\n\ngoal (1 subgoal):\n 1. x = y", "unfolding insert_index_def"], ["proof (prove)\nusing this:\n  (if x < i then x else Suc x) = (if y < i then y else Suc y)\n\ngoal (1 subgoal):\n 1. x = y", "by(cases \"x < i\"; cases \"y < i\";simp)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_dom_inj_on:\n  assumes i: \"i \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes inj: \"inj_on f ?N\"\n  shows \"inj_on (delete_dom f i) {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (delete_dom f i) {0..<n}", "proof (rule eq_card_imp_inj_on)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {0..<n}\n 2. card (delete_dom f i ` {0..<n}) = card {0..<n}", "have \"card ?N = card (f ` ?N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<Suc n} = card (f ` {0..<Suc n})", "using card_image[OF inj]"], ["proof (prove)\nusing this:\n  card (f ` {0..<Suc n}) = card {0..<Suc n}\n\ngoal (1 subgoal):\n 1. card {0..<Suc n} = card (f ` {0..<Suc n})", ".."], ["proof (state)\nthis:\n  card {0..<Suc n} = card (f ` {0..<Suc n})\n\ngoal (2 subgoals):\n 1. finite {0..<n}\n 2. card (delete_dom f i ` {0..<n}) = card {0..<n}", "hence \"card {0..<n} = card (f ` ?N - {f i})\""], ["proof (prove)\nusing this:\n  card {0..<Suc n} = card (f ` {0..<Suc n})\n\ngoal (1 subgoal):\n 1. card {0..<n} = card (f ` {0..<Suc n} - {f i})", "using i"], ["proof (prove)\nusing this:\n  card {0..<Suc n} = card (f ` {0..<Suc n})\n  i \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. card {0..<n} = card (f ` {0..<Suc n} - {f i})", "by auto"], ["proof (state)\nthis:\n  card {0..<n} = card (f ` {0..<Suc n} - {f i})\n\ngoal (2 subgoals):\n 1. finite {0..<n}\n 2. card (delete_dom f i ` {0..<n}) = card {0..<n}", "also"], ["proof (state)\nthis:\n  card {0..<n} = card (f ` {0..<Suc n} - {f i})\n\ngoal (2 subgoals):\n 1. finite {0..<n}\n 2. card (delete_dom f i ` {0..<n}) = card {0..<n}", "have \"... = card (delete_dom f i ` {0..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` {0..<Suc n} - {f i}) = card (delete_dom f i ` {0..<n})", "apply(subst delete_dom_image[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. \\<forall>i'\\<in>{0..<Suc n}. f i' = f i \\<longrightarrow> i' = i\n 3. card (delete_dom f i ` {0..<n}) = card (delete_dom f i ` {0..<n})", "using i inj"], ["proof (prove)\nusing this:\n  i \\<in> {0..<Suc n}\n  inj_on f {0..<Suc n}\n\ngoal (3 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. \\<forall>i'\\<in>{0..<Suc n}. f i' = f i \\<longrightarrow> i' = i\n 3. card (delete_dom f i ` {0..<n}) = card (delete_dom f i ` {0..<n})", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  i \\<in> {0..<Suc n}\n  \\<forall>x\\<in>{0..<Suc n}.\n     \\<forall>y\\<in>{0..<Suc n}. f x = f y \\<longrightarrow> x = y\n\ngoal (3 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. \\<forall>i'\\<in>{0..<Suc n}. f i' = f i \\<longrightarrow> i' = i\n 3. card (delete_dom f i ` {0..<n}) = card (delete_dom f i ` {0..<n})", "by auto"], ["proof (state)\nthis:\n  card (f ` {0..<Suc n} - {f i}) = card (delete_dom f i ` {0..<n})\n\ngoal (2 subgoals):\n 1. finite {0..<n}\n 2. card (delete_dom f i ` {0..<n}) = card {0..<n}", "finally"], ["proof (chain)\npicking this:\n  card {0..<n} = card (delete_dom f i ` {0..<n})", "show \"card (delete_dom f i ` {0..<n}) = card {0..<n}\""], ["proof (prove)\nusing this:\n  card {0..<n} = card (delete_dom f i ` {0..<n})\n\ngoal (1 subgoal):\n 1. card (delete_dom f i ` {0..<n}) = card {0..<n}", ".."], ["proof (state)\nthis:\n  card (delete_dom f i ` {0..<n}) = card {0..<n}\n\ngoal (1 subgoal):\n 1. finite {0..<n}", "qed simp"], ["", "lemma delete_ran_inj_on:\n  assumes j: \"j \\<in> {0..<Suc n}\" (is \"_ \\<in> ?N\")\n  assumes img: \"f ` {0..<n} =  ?N - {j}\"\n  shows \"inj_on (delete_ran f j) {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (delete_ran f j) {0..<n}", "apply (rule eq_card_imp_inj_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {0..<n}\n 2. card (delete_ran f j ` {0..<n}) = card {0..<n}", "unfolding delete_ran_image[OF j img]"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {0..<n}\n 2. card {0..<n} = card {0..<n}", "by simp+"], ["", "lemma permutation_delete_bij_betw:\n  assumes i: \"i \\<in> {0 ..< Suc n}\" (is \"_ \\<in> ?N\")\n  assumes bij: \"bij_betw p ?N ?N\"\n  shows \"bij_betw (permutation_delete p i) {0..<n} {0..<n}\" (is \"bij_betw ?p _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "have inj: \"inj_on p ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on p {0..<Suc n}", "using bij_betw_imp_inj_on[OF bij]"], ["proof (prove)\nusing this:\n  inj_on p {0..<Suc n}\n\ngoal (1 subgoal):\n 1. inj_on p {0..<Suc n}", "."], ["proof (state)\nthis:\n  inj_on p {0..<Suc n}\n\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "have ran: \"p ` ?N = ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ` {0..<Suc n} = {0..<Suc n}", "using bij_betw_imp_surj_on[OF bij]"], ["proof (prove)\nusing this:\n  p ` {0..<Suc n} = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. p ` {0..<Suc n} = {0..<Suc n}", "."], ["proof (state)\nthis:\n  p ` {0..<Suc n} = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "hence j: \"p i \\<in> ?N\""], ["proof (prove)\nusing this:\n  p ` {0..<Suc n} = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. p i \\<in> {0..<Suc n}", "using i"], ["proof (prove)\nusing this:\n  p ` {0..<Suc n} = {0..<Suc n}\n  i \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. p i \\<in> {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  p i \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "have \"\\<forall>i'\\<in>?N. p i' = p i \\<longrightarrow> i' = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i'\\<in>{0..<Suc n}. p i' = p i \\<longrightarrow> i' = i", "using inj i"], ["proof (prove)\nusing this:\n  inj_on p {0..<Suc n}\n  i \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<forall>i'\\<in>{0..<Suc n}. p i' = p i \\<longrightarrow> i' = i", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..<Suc n}.\n     \\<forall>y\\<in>{0..<Suc n}. p x = p y \\<longrightarrow> x = y\n  i \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<forall>i'\\<in>{0..<Suc n}. p i' = p i \\<longrightarrow> i' = i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i'\\<in>{0..<Suc n}. p i' = p i \\<longrightarrow> i' = i\n\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "from delete_dom_image[OF i this]"], ["proof (chain)\npicking this:\n  delete_dom p i ` {0..<n} = p ` {0..<Suc n} - {p i}", "have \"delete_dom p i ` {0..<n} = ?N - {p i}\""], ["proof (prove)\nusing this:\n  delete_dom p i ` {0..<n} = p ` {0..<Suc n} - {p i}\n\ngoal (1 subgoal):\n 1. delete_dom p i ` {0..<n} = {0..<Suc n} - {p i}", "unfolding ran"], ["proof (prove)\nusing this:\n  delete_dom p i ` {0..<n} = {0..<Suc n} - {p i}\n\ngoal (1 subgoal):\n 1. delete_dom p i ` {0..<n} = {0..<Suc n} - {p i}", "."], ["proof (state)\nthis:\n  delete_dom p i ` {0..<n} = {0..<Suc n} - {p i}\n\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "from delete_ran_inj_on[OF j this] delete_ran_image[OF j this]"], ["proof (chain)\npicking this:\n  inj_on (delete_ran (delete_dom p i) (p i)) {0..<n}\n  delete_ran (delete_dom p i) (p i) ` {0..<n} = {0..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on (delete_ran (delete_dom p i) (p i)) {0..<n}\n  delete_ran (delete_dom p i) (p i) ` {0..<n} = {0..<n}\n\ngoal (1 subgoal):\n 1. bij_betw (permutation_delete p i) {0..<n} {0..<n}", "unfolding permutation_delete_def"], ["proof (prove)\nusing this:\n  inj_on (delete_ran (delete_dom p i) (p i)) {0..<n}\n  delete_ran (delete_dom p i) (p i) ` {0..<n} = {0..<n}\n\ngoal (1 subgoal):\n 1. bij_betw (delete_ran (delete_dom p i) (p i)) {0..<n} {0..<n}", "using bij_betw_imageI"], ["proof (prove)\nusing this:\n  inj_on (delete_ran (delete_dom p i) (p i)) {0..<n}\n  delete_ran (delete_dom p i) (p i) ` {0..<n} = {0..<n}\n  \\<lbrakk>inj_on ?f ?A; ?f ` ?A = ?B\\<rbrakk>\n  \\<Longrightarrow> bij_betw ?f ?A ?B\n\ngoal (1 subgoal):\n 1. bij_betw (delete_ran (delete_dom p i) (p i)) {0..<n} {0..<n}", "by blast"], ["proof (state)\nthis:\n  bij_betw (permutation_delete p i) {0..<n} {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_delete_permutes:\n  assumes p: \"p permutes {0 ..< Suc n}\" (is \"_ permutes ?N\")\n      and i: \"i < Suc n\"\n  shows \"permutation_delete p i permutes {0..<n}\" (is \"?p permutes ?N'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_delete p i permutes {0..<n}", "proof (rule bij_imp_permutes, rule permutation_delete_bij_betw)"], ["proof (state)\ngoal (3 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. bij_betw p {0..<Suc n} {0..<Suc n}\n 3. \\<And>x.\n       x \\<notin> {0..<n} \\<Longrightarrow> permutation_delete p i x = x", "have pi: \"p i < Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p i < Suc n", "using p i"], ["proof (prove)\nusing this:\n  p permutes {0..<Suc n}\n  i < Suc n\n\ngoal (1 subgoal):\n 1. p i < Suc n", "by auto"], ["proof (state)\nthis:\n  p i < Suc n\n\ngoal (3 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. bij_betw p {0..<Suc n} {0..<Suc n}\n 3. \\<And>x.\n       x \\<notin> {0..<n} \\<Longrightarrow> permutation_delete p i x = x", "show \"bij_betw p ?N ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw p {0..<Suc n} {0..<Suc n}", "using permutes_imp_bij[OF p]"], ["proof (prove)\nusing this:\n  bij_betw p {0..<Suc n} {0..<Suc n}\n\ngoal (1 subgoal):\n 1. bij_betw p {0..<Suc n} {0..<Suc n}", "."], ["proof (state)\nthis:\n  bij_betw p {0..<Suc n} {0..<Suc n}\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<notin> {0..<n} \\<Longrightarrow> permutation_delete p i x = x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<notin> {0..<n} \\<Longrightarrow> permutation_delete p i x = x", "assume \"x \\<notin> {0..<n}\""], ["proof (state)\nthis:\n  x \\<notin> {0..<n}\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<notin> {0..<n} \\<Longrightarrow> permutation_delete p i x = x", "hence x: \"x \\<ge> n\""], ["proof (prove)\nusing this:\n  x \\<notin> {0..<n}\n\ngoal (1 subgoal):\n 1. n \\<le> x", "by simp"], ["proof (state)\nthis:\n  n \\<le> x\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<notin> {0..<n} \\<Longrightarrow> permutation_delete p i x = x", "show \"?p x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_delete p i x = x", "proof(cases \"x < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> permutation_delete p i x = x\n 2. \\<not> x < i \\<Longrightarrow> permutation_delete p i x = x", "case True"], ["proof (state)\nthis:\n  x < i\n\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> permutation_delete p i x = x\n 2. \\<not> x < i \\<Longrightarrow> permutation_delete p i x = x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < i\n\ngoal (1 subgoal):\n 1. permutation_delete p i x = x", "unfolding permutation_delete_def"], ["proof (prove)\nusing this:\n  x < i\n\ngoal (1 subgoal):\n 1. delete_ran (delete_dom p i) (p i) x = x", "using x i"], ["proof (prove)\nusing this:\n  x < i\n  n \\<le> x\n  i < Suc n\n\ngoal (1 subgoal):\n 1. delete_ran (delete_dom p i) (p i) x = x", "by simp"], ["proof (state)\nthis:\n  permutation_delete p i x = x\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> permutation_delete p i x = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> permutation_delete p i x = x", "case False"], ["proof (state)\nthis:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> permutation_delete p i x = x", "hence \"p (Suc x) = Suc x\""], ["proof (prove)\nusing this:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. p (Suc x) = Suc x", "using x permutes_others[OF p]"], ["proof (prove)\nusing this:\n  \\<not> x < i\n  n \\<le> x\n  ?x \\<notin> {0..<Suc n} \\<Longrightarrow> p ?x = ?x\n\ngoal (1 subgoal):\n 1. p (Suc x) = Suc x", "by auto"], ["proof (state)\nthis:\n  p (Suc x) = Suc x\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> permutation_delete p i x = x", "thus ?thesis"], ["proof (prove)\nusing this:\n  p (Suc x) = Suc x\n\ngoal (1 subgoal):\n 1. permutation_delete p i x = x", "unfolding permutation_delete_expand"], ["proof (prove)\nusing this:\n  p (Suc x) = Suc x\n\ngoal (1 subgoal):\n 1. (if p (if x < i then x else Suc x) < p i\n     then p (if x < i then x else Suc x)\n     else p (if x < i then x else Suc x) - Suc 0) =\n    x", "using False pi x"], ["proof (prove)\nusing this:\n  p (Suc x) = Suc x\n  \\<not> x < i\n  p i < Suc n\n  n \\<le> x\n\ngoal (1 subgoal):\n 1. (if p (if x < i then x else Suc x) < p i\n     then p (if x < i then x else Suc x)\n     else p (if x < i then x else Suc x) - Suc 0) =\n    x", "by simp"], ["proof (state)\nthis:\n  permutation_delete p i x = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  permutation_delete p i x = x\n\ngoal (1 subgoal):\n 1. i \\<in> {0..<Suc n}", "qed (insert i,auto)"], ["", "lemma permutation_insert_delete:\n  assumes p: \"p permutes {0..<Suc n}\"\n      and i: \"i < Suc n\"\n  shows \"permutation_insert i (p i) (permutation_delete p i) = p\"\n    (is \"?l = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) = p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. permutation_insert i (p i) (permutation_delete p i) x = p x", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. permutation_insert i (p i) (permutation_delete p i) x = p x", "show \"?l i' = p i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "proof (cases rule: linorder_cases[of \"i'\" \"i\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. i' = i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 3. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case less"], ["proof (state)\nthis:\n  i' < i\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. i' = i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 3. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "note i'i = this"], ["proof (state)\nthis:\n  i' < i\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. i' = i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 3. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "proof (cases \"p i = p i'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p i = p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i \\<noteq> p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case True"], ["proof (state)\nthis:\n  p i = p i'\n\ngoal (2 subgoals):\n 1. p i = p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i \\<noteq> p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence \"i = i'\""], ["proof (prove)\nusing this:\n  p i = p i'\n\ngoal (1 subgoal):\n 1. i = i'", "using permutes_inj[OF p] injD"], ["proof (prove)\nusing this:\n  p i = p i'\n  inj p\n  \\<lbrakk>inj ?f; ?f ?x = ?f ?y\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. i = i'", "by metis"], ["proof (state)\nthis:\n  i = i'\n\ngoal (2 subgoals):\n 1. p i = p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i \\<noteq> p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence False"], ["proof (prove)\nusing this:\n  i = i'\n\ngoal (1 subgoal):\n 1. False", "using i'i"], ["proof (prove)\nusing this:\n  i = i'\n  i' < i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. p i = p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i \\<noteq> p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "by auto"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal (1 subgoal):\n 1. p i \\<noteq> p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p i \\<noteq> p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case False"], ["proof (state)\nthis:\n  p i \\<noteq> p i'\n\ngoal (1 subgoal):\n 1. p i \\<noteq> p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "thus ?thesis"], ["proof (prove)\nusing this:\n  p i \\<noteq> p i'\n\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "unfolding permutation_insert_expand permutation_delete_expand"], ["proof (prove)\nusing this:\n  p i \\<noteq> p i'\n\ngoal (1 subgoal):\n 1. (if i' < i\n     then if (if p (if i' < i then i' else Suc i') < p i\n              then p (if i' < i then i' else Suc i')\n              else p (if i' < i then i' else Suc i') - Suc 0)\n             < p i\n          then if p (if i' < i then i' else Suc i') < p i\n               then p (if i' < i then i' else Suc i')\n               else p (if i' < i then i' else Suc i') - Suc 0\n          else Suc (if p (if i' < i then i' else Suc i') < p i\n                    then p (if i' < i then i' else Suc i')\n                    else p (if i' < i then i' else Suc i') - Suc 0)\n     else if i' = i then p i\n          else if (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n                   then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n                   else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) -\n                        Suc 0)\n                  < p i\n               then if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n                    then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n                    else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) -\n                         Suc 0\n               else Suc (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n                            < p i\n                         then p (if i' - 1 < i then i' - 1\n                                 else Suc (i' - 1))\n                         else p (if i' - 1 < i then i' - 1\n                                 else Suc (i' - 1)) -\n                              Suc 0)) =\n    p i'", "using i'i"], ["proof (prove)\nusing this:\n  p i \\<noteq> p i'\n  i' < i\n\ngoal (1 subgoal):\n 1. (if i' < i\n     then if (if p (if i' < i then i' else Suc i') < p i\n              then p (if i' < i then i' else Suc i')\n              else p (if i' < i then i' else Suc i') - Suc 0)\n             < p i\n          then if p (if i' < i then i' else Suc i') < p i\n               then p (if i' < i then i' else Suc i')\n               else p (if i' < i then i' else Suc i') - Suc 0\n          else Suc (if p (if i' < i then i' else Suc i') < p i\n                    then p (if i' < i then i' else Suc i')\n                    else p (if i' < i then i' else Suc i') - Suc 0)\n     else if i' = i then p i\n          else if (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n                   then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n                   else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) -\n                        Suc 0)\n                  < p i\n               then if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n                    then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n                    else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) -\n                         Suc 0\n               else Suc (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n                            < p i\n                         then p (if i' - 1 < i then i' - 1\n                                 else Suc (i' - 1))\n                         else p (if i' - 1 < i then i' - 1\n                                 else Suc (i' - 1)) -\n                              Suc 0)) =\n    p i'", "by auto"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case equal"], ["proof (state)\nthis:\n  i' = i\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "thus ?thesis"], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "unfolding permutation_insert_expand"], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. (if i' < i\n     then if permutation_delete p i i' < p i then permutation_delete p i i'\n          else Suc (permutation_delete p i i')\n     else if i' = i then p i\n          else if permutation_delete p i (i' - 1) < p i\n               then permutation_delete p i (i' - 1)\n               else Suc (permutation_delete p i (i' - 1))) =\n    p i'", "by simp"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case greater"], ["proof (state)\nthis:\n  i < i'\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence i'i: \"i' > i\""], ["proof (prove)\nusing this:\n  i < i'\n\ngoal (1 subgoal):\n 1. i < i'", "by auto"], ["proof (state)\nthis:\n  i < i'\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence cond: \"\\<not> i' - 1 < i\""], ["proof (prove)\nusing this:\n  i < i'\n\ngoal (1 subgoal):\n 1. \\<not> i' - 1 < i", "using i'i"], ["proof (prove)\nusing this:\n  i < i'\n  i < i'\n\ngoal (1 subgoal):\n 1. \\<not> i' - 1 < i", "by simp"], ["proof (state)\nthis:\n  \\<not> i' - 1 < i\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "proof (cases rule: linorder_cases[of \"p i'\" \"p i\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. p i' < p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 3. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case less"], ["proof (state)\nthis:\n  p i' < p i\n\ngoal (3 subgoals):\n 1. p i' < p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 3. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence pd: \"permutation_delete p i (i'-1) = p i'\""], ["proof (prove)\nusing this:\n  p i' < p i\n\ngoal (1 subgoal):\n 1. permutation_delete p i (i' - 1) = p i'", "unfolding permutation_delete_expand"], ["proof (prove)\nusing this:\n  p i' < p i\n\ngoal (1 subgoal):\n 1. (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n     then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n     else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) - Suc 0) =\n    p i'", "using i'i cond"], ["proof (prove)\nusing this:\n  p i' < p i\n  i < i'\n  \\<not> i' - 1 < i\n\ngoal (1 subgoal):\n 1. (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n     then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n     else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) - Suc 0) =\n    p i'", "by auto"], ["proof (state)\nthis:\n  permutation_delete p i (i' - 1) = p i'\n\ngoal (3 subgoals):\n 1. p i' < p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 3. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "unfolding permutation_insert_expand pd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i' < i\n     then if permutation_delete p i i' < p i then permutation_delete p i i'\n          else Suc (permutation_delete p i i')\n     else if i' = i then p i else if p i' < p i then p i' else Suc (p i')) =\n    p i'", "using i'i less"], ["proof (prove)\nusing this:\n  i < i'\n  p i' < p i\n\ngoal (1 subgoal):\n 1. (if i' < i\n     then if permutation_delete p i i' < p i then permutation_delete p i i'\n          else Suc (permutation_delete p i i')\n     else if i' = i then p i else if p i' < p i then p i' else Suc (p i')) =\n    p i'", "by simp"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal (2 subgoals):\n 1. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case equal"], ["proof (state)\nthis:\n  p i' = p i\n\ngoal (2 subgoals):\n 1. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence \"i = i'\""], ["proof (prove)\nusing this:\n  p i' = p i\n\ngoal (1 subgoal):\n 1. i = i'", "using permutes_inj[OF p] injD"], ["proof (prove)\nusing this:\n  p i' = p i\n  inj p\n  \\<lbrakk>inj ?f; ?f ?x = ?f ?y\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. i = i'", "by metis"], ["proof (state)\nthis:\n  i = i'\n\ngoal (2 subgoals):\n 1. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence False"], ["proof (prove)\nusing this:\n  i = i'\n\ngoal (1 subgoal):\n 1. False", "using i'i"], ["proof (prove)\nusing this:\n  i = i'\n  i < i'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. p i' = p i \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'\n 2. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "by auto"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal (1 subgoal):\n 1. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "case greater"], ["proof (state)\nthis:\n  p i < p i'\n\ngoal (1 subgoal):\n 1. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "hence pd: \"permutation_delete p i (i'-1) = p i' - 1\""], ["proof (prove)\nusing this:\n  p i < p i'\n\ngoal (1 subgoal):\n 1. permutation_delete p i (i' - 1) = p i' - 1", "unfolding permutation_delete_expand"], ["proof (prove)\nusing this:\n  p i < p i'\n\ngoal (1 subgoal):\n 1. (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n     then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n     else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) - Suc 0) =\n    p i' - 1", "using i'i cond"], ["proof (prove)\nusing this:\n  p i < p i'\n  i < i'\n  \\<not> i' - 1 < i\n\ngoal (1 subgoal):\n 1. (if p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) < p i\n     then p (if i' - 1 < i then i' - 1 else Suc (i' - 1))\n     else p (if i' - 1 < i then i' - 1 else Suc (i' - 1)) - Suc 0) =\n    p i' - 1", "by simp"], ["proof (state)\nthis:\n  permutation_delete p i (i' - 1) = p i' - 1\n\ngoal (1 subgoal):\n 1. p i < p i' \\<Longrightarrow>\n    permutation_insert i (p i) (permutation_delete p i) i' = p i'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i (p i) (permutation_delete p i) i' = p i'", "unfolding permutation_insert_expand pd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i' < i\n     then if permutation_delete p i i' < p i then permutation_delete p i i'\n          else Suc (permutation_delete p i i')\n     else if i' = i then p i\n          else if p i' - 1 < p i then p i' - 1 else Suc (p i' - 1)) =\n    p i'", "using i'i greater"], ["proof (prove)\nusing this:\n  i < i'\n  p i < p i'\n\ngoal (1 subgoal):\n 1. (if i' < i\n     then if permutation_delete p i i' < p i then permutation_delete p i i'\n          else Suc (permutation_delete p i i')\n     else if i' = i then p i\n          else if p i' - 1 < p i then p i' - 1 else Suc (p i' - 1)) =\n    p i'", "by auto"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  permutation_insert i (p i) (permutation_delete p i) i' = p i'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_index_exclude[simp]:\n  \"insert_index i i' \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index i i' \\<noteq> i", "unfolding insert_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i' < i then i' else Suc i') \\<noteq> i", "by auto"], ["", "lemma insert_index_image:\n  assumes i: \"i < Suc n\"\n  shows \"insert_index i ` {0..<n} = {0..<Suc n} - {i}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index i ` {0..<n} = {0..<Suc n} - {i}", "proof(unfold set_eq_iff, intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n} - {i}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "let ?N = \"{0..<Suc n}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n} - {i}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "fix i'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n} - {i}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n} - {i}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "assume L: \"i' \\<in> ?L\""], ["proof (state)\nthis:\n  i' \\<in> insert_index i ` {0..<n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n} - {i}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "then"], ["proof (chain)\npicking this:\n  i' \\<in> insert_index i ` {0..<n}", "obtain i''\n      where ins: \"i' = insert_index i i''\" and i'': \"i'' \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  i' \\<in> insert_index i ` {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i''.\n        \\<lbrakk>i' = insert_index i i''; i'' \\<in> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' = insert_index i i''\n  i'' \\<in> {0..<n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n} - {i}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "show \"i' \\<in> ?N - {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<in> {0..<Suc n} - {i}", "proof(rule DiffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. i' \\<in> {0..<Suc n}\n 2. i' \\<notin> {i}", "show \"i' \\<in> ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<in> {0..<Suc n}", "using ins"], ["proof (prove)\nusing this:\n  i' = insert_index i i''\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<Suc n}", "unfolding insert_index_def"], ["proof (prove)\nusing this:\n  i' = (if i'' < i then i'' else Suc i'')\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<Suc n}", "using i''"], ["proof (prove)\nusing this:\n  i' = (if i'' < i then i'' else Suc i'')\n  i'' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  i' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. i' \\<notin> {i}", "show \"i' \\<notin> {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<notin> {i}", "unfolding singleton_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "unfolding ins"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index i i'' \\<noteq> i", "unfolding insert_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i'' < i then i'' else Suc i'') \\<noteq> i", "by auto"], ["proof (state)\nthis:\n  i' \\<notin> {i}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i' \\<in> {0..<Suc n} - {i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "}"], ["proof (state)\nthis:\n  i' \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n  i' \\<in> {0..<Suc n} - {i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "{"], ["proof (state)\nthis:\n  i' \\<in> insert_index i ` {0..<n} \\<Longrightarrow>\n  i' \\<in> {0..<Suc n} - {i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "assume R: \"i' \\<in> ?R\""], ["proof (state)\nthis:\n  i' \\<in> {0..<Suc n} - {i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n       x \\<in> insert_index i ` {0..<n}", "show \"i' \\<in> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<in> insert_index i ` {0..<n}", "proof(cases rule: linorder_cases[of \"i'\" \"i\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 3. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "case less"], ["proof (state)\nthis:\n  i' < i\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 3. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "hence i': \"i' \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  i' < i\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<n}", "using i"], ["proof (prove)\nusing this:\n  i' < i\n  i < Suc n\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  i' \\<in> {0..<n}\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 3. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "hence \"insert_index i i' = i'\""], ["proof (prove)\nusing this:\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. insert_index i i' = i'", "unfolding insert_index_def"], ["proof (prove)\nusing this:\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. (if i' < i then i' else Suc i') = i'", "using less"], ["proof (prove)\nusing this:\n  i' \\<in> {0..<n}\n  i' < i\n\ngoal (1 subgoal):\n 1. (if i' < i then i' else Suc i') = i'", "by auto"], ["proof (state)\nthis:\n  insert_index i i' = i'\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 3. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  insert_index i i' = i'\n\ngoal (1 subgoal):\n 1. i' \\<in> insert_index i ` {0..<n}", "using i'"], ["proof (prove)\nusing this:\n  insert_index i i' = i'\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. i' \\<in> insert_index i ` {0..<n}", "by force"], ["proof (state)\nthis:\n  i' \\<in> insert_index i ` {0..<n}\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "case equal"], ["proof (state)\nthis:\n  i' = i\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "hence False"], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. False", "using R"], ["proof (prove)\nusing this:\n  i' = i\n  i' \\<in> {0..<Suc n} - {i}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}\n 2. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. i' \\<in> insert_index i ` {0..<n}", "by auto"], ["proof (state)\nthis:\n  i' \\<in> insert_index i ` {0..<n}\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "case greater"], ["proof (state)\nthis:\n  i < i'\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "hence i'': \"i'-1 \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  i < i'\n\ngoal (1 subgoal):\n 1. i' - 1 \\<in> {0..<n}", "using i R"], ["proof (prove)\nusing this:\n  i < i'\n  i < Suc n\n  i' \\<in> {0..<Suc n} - {i}\n\ngoal (1 subgoal):\n 1. i' - 1 \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  i' - 1 \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "hence \"insert_index i (i'-1) = i'\""], ["proof (prove)\nusing this:\n  i' - 1 \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. insert_index i (i' - 1) = i'", "unfolding insert_index_def"], ["proof (prove)\nusing this:\n  i' - 1 \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. (if i' - 1 < i then i' - 1 else Suc (i' - 1)) = i'", "using greater"], ["proof (prove)\nusing this:\n  i' - 1 \\<in> {0..<n}\n  i < i'\n\ngoal (1 subgoal):\n 1. (if i' - 1 < i then i' - 1 else Suc (i' - 1)) = i'", "by auto"], ["proof (state)\nthis:\n  insert_index i (i' - 1) = i'\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> i' \\<in> insert_index i ` {0..<n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  insert_index i (i' - 1) = i'\n\ngoal (1 subgoal):\n 1. i' \\<in> insert_index i ` {0..<n}", "using i''"], ["proof (prove)\nusing this:\n  insert_index i (i' - 1) = i'\n  i' - 1 \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. i' \\<in> insert_index i ` {0..<n}", "by force"], ["proof (state)\nthis:\n  i' \\<in> insert_index i ` {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i' \\<in> insert_index i ` {0..<n}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  i' \\<in> {0..<Suc n} - {i} \\<Longrightarrow>\n  i' \\<in> insert_index i ` {0..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_ran_image:\n  assumes j: \"j < Suc n\"\n  assumes img: \"f ` {0..<n} = {0..<n}\"\n  shows \"insert_ran f j ` {0..<n} = {0..<Suc n} - {j}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "have \"?L = (\\<lambda>i. insert_index j (f i)) ` {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = (\\<lambda>i. insert_index j (f i)) ` {0..<n}", "unfolding insert_ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. insert_index j (f i)) ` {0..<n} =\n    (\\<lambda>i. insert_index j (f i)) ` {0..<n}", ".."], ["proof (state)\nthis:\n  insert_ran f j ` {0..<n} = (\\<lambda>i. insert_index j (f i)) ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "also"], ["proof (state)\nthis:\n  insert_ran f j ` {0..<n} = (\\<lambda>i. insert_index j (f i)) ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "have \"... = (insert_index j \\<circ> f) ` {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. insert_index j (f i)) ` {0..<n} =\n    (insert_index j \\<circ> f) ` {0..<n}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i. insert_index j (f i)) ` {0..<n} =\n  (insert_index j \\<circ> f) ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. insert_index j (f i)) ` {0..<n} =\n  (insert_index j \\<circ> f) ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "have \"... = insert_index j ` f ` {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert_index j \\<circ> f) ` {0..<n} = insert_index j ` f ` {0..<n}", "by auto"], ["proof (state)\nthis:\n  (insert_index j \\<circ> f) ` {0..<n} = insert_index j ` f ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "also"], ["proof (state)\nthis:\n  (insert_index j \\<circ> f) ` {0..<n} = insert_index j ` f ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "have \"... = insert_index j ` {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index j ` f ` {0..<n} = insert_index j ` {0..<n}", "unfolding img"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index j ` {0..<n} = insert_index j ` {0..<n}", "by auto"], ["proof (state)\nthis:\n  insert_index j ` f ` {0..<n} = insert_index j ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "finally"], ["proof (chain)\npicking this:\n  insert_ran f j ` {0..<n} = insert_index j ` {0..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  insert_ran f j ` {0..<n} = insert_index j ` {0..<n}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "using insert_index_image[OF j]"], ["proof (prove)\nusing this:\n  insert_ran f j ` {0..<n} = insert_index j ` {0..<n}\n  insert_index j ` {0..<n} = {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. insert_ran f j ` {0..<n} = {0..<Suc n} - {j}", "by auto"], ["proof (state)\nthis:\n  insert_ran f j ` {0..<n} = {0..<Suc n} - {j}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_dom_image:\n  assumes i: \"i < Suc n\" and j: \"j < Suc n\"\n    and img: \"f ` {0..<n} = {0..<Suc n} - {j}\" (is \"_ = ?N - _\")\n  shows \"insert_dom f i j ` ?N = ?N\" (is \"?f ` _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_dom f i j ` {0..<Suc n} = {0..<Suc n}", "proof(unfold set_eq_iff,intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_dom f i j ` {0..<Suc n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "fix j'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_dom f i j ` {0..<Suc n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_dom f i j ` {0..<Suc n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "assume \"j' \\<in> ?f ` ?N\""], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_dom f i j ` {0..<Suc n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "then"], ["proof (chain)\npicking this:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}", "obtain i' where i': \"i' \\<in> ?N\" and j': \"j' = ?f i'\""], ["proof (prove)\nusing this:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i' \\<in> {0..<Suc n}; j' = insert_dom f i j i'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' \\<in> {0..<Suc n}\n  j' = insert_dom f i j i'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> insert_dom f i j ` {0..<Suc n} \\<Longrightarrow>\n       x \\<in> {0..<Suc n}\n 2. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "show \"j' \\<in> ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n}", "proof (cases rule:linorder_cases[of \"i'\" \"i\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 2. i' = i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 3. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "case less"], ["proof (state)\nthis:\n  i' < i\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 2. i' = i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 3. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "hence \"i' \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  i' < i\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<n}", "using i"], ["proof (prove)\nusing this:\n  i' < i\n  i < Suc n\n\ngoal (1 subgoal):\n 1. i' \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  i' \\<in> {0..<n}\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 2. i' = i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 3. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "hence \"f i' < Suc n\""], ["proof (prove)\nusing this:\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. f i' < Suc n", "using imageI[of i' \"{0..<n}\" f] img"], ["proof (prove)\nusing this:\n  i' \\<in> {0..<n}\n  i' \\<in> {0..<n} \\<Longrightarrow> f i' \\<in> f ` {0..<n}\n  f ` {0..<n} = {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. f i' < Suc n", "by auto"], ["proof (state)\nthis:\n  f i' < Suc n\n\ngoal (3 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 2. i' = i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 3. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  f i' < Suc n\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n}", "unfolding j'"], ["proof (prove)\nusing this:\n  f i' < Suc n\n\ngoal (1 subgoal):\n 1. insert_dom f i j i' \\<in> {0..<Suc n}", "unfolding insert_dom_def"], ["proof (prove)\nusing this:\n  f i' < Suc n\n\ngoal (1 subgoal):\n 1. (if i' < i then f i' else if i' = i then j else f (i' - 1))\n    \\<in> {0..<Suc n}", "using less"], ["proof (prove)\nusing this:\n  f i' < Suc n\n  i' < i\n\ngoal (1 subgoal):\n 1. (if i' < i then f i' else if i' = i then j else f (i' - 1))\n    \\<in> {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n}\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 2. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 2. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "case equal"], ["proof (state)\nthis:\n  i' = i\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow> j' \\<in> {0..<Suc n}\n 2. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n}", "unfolding j' insert_dom_def"], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. (if i' < i then f i' else if i' = i then j else f (i' - 1))\n    \\<in> {0..<Suc n}", "using j"], ["proof (prove)\nusing this:\n  i' = i\n  j < Suc n\n\ngoal (1 subgoal):\n 1. (if i' < i then f i' else if i' = i then j else f (i' - 1))\n    \\<in> {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "case greater"], ["proof (state)\nthis:\n  i < i'\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "hence \"i'-1 \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  i < i'\n\ngoal (1 subgoal):\n 1. i' - 1 \\<in> {0..<n}", "using i'"], ["proof (prove)\nusing this:\n  i < i'\n  i' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. i' - 1 \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  i' - 1 \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "hence \"f (i'-1) < Suc n\""], ["proof (prove)\nusing this:\n  i' - 1 \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. f (i' - 1) < Suc n", "using imageI[of \"i'-1\" \"{0..<n}\" f] img"], ["proof (prove)\nusing this:\n  i' - 1 \\<in> {0..<n}\n  i' - 1 \\<in> {0..<n} \\<Longrightarrow> f (i' - 1) \\<in> f ` {0..<n}\n  f ` {0..<n} = {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. f (i' - 1) < Suc n", "by auto"], ["proof (state)\nthis:\n  f (i' - 1) < Suc n\n\ngoal (1 subgoal):\n 1. i < i' \\<Longrightarrow> j' \\<in> {0..<Suc n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (i' - 1) < Suc n\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n}", "unfolding j' insert_dom_def"], ["proof (prove)\nusing this:\n  f (i' - 1) < Suc n\n\ngoal (1 subgoal):\n 1. (if i' < i then f i' else if i' = i then j else f (i' - 1))\n    \\<in> {0..<Suc n}", "using greater"], ["proof (prove)\nusing this:\n  f (i' - 1) < Suc n\n  i < i'\n\ngoal (1 subgoal):\n 1. (if i' < i then f i' else if i' = i then j else f (i' - 1))\n    \\<in> {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "}"], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n} \\<Longrightarrow>\n  j' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "{"], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n} \\<Longrightarrow>\n  j' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "assume j': \"j' \\<in> ?N\""], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<Suc n} \\<Longrightarrow>\n       x \\<in> insert_dom f i j ` {0..<Suc n}", "show \"j' \\<in> ?f ` ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> insert_dom f i j ` {0..<Suc n}", "proof (cases \"j' = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j' = j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}\n 2. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "case True"], ["proof (state)\nthis:\n  j' = j\n\ngoal (2 subgoals):\n 1. j' = j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}\n 2. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "hence \"?f i = j'\""], ["proof (prove)\nusing this:\n  j' = j\n\ngoal (1 subgoal):\n 1. insert_dom f i j i = j'", "unfolding insert_dom_def"], ["proof (prove)\nusing this:\n  j' = j\n\ngoal (1 subgoal):\n 1. (if i < i then f i else if i = i then j else f (i - 1)) = j'", "by auto"], ["proof (state)\nthis:\n  insert_dom f i j i = j'\n\ngoal (2 subgoals):\n 1. j' = j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}\n 2. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  insert_dom f i j i = j'\n\ngoal (1 subgoal):\n 1. j' \\<in> insert_dom f i j ` {0..<Suc n}", "using i"], ["proof (prove)\nusing this:\n  insert_dom f i j i = j'\n  i < Suc n\n\ngoal (1 subgoal):\n 1. j' \\<in> insert_dom f i j ` {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal (1 subgoal):\n 1. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "case False"], ["proof (state)\nthis:\n  j' \\<noteq> j\n\ngoal (1 subgoal):\n 1. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "hence j': \"j' \\<in> ?N - {j}\""], ["proof (prove)\nusing this:\n  j' \\<noteq> j\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n} - {j}", "using j j'"], ["proof (prove)\nusing this:\n  j' \\<noteq> j\n  j < Suc n\n  j' \\<in> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. j' \\<in> {0..<Suc n} - {j}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "then"], ["proof (chain)\npicking this:\n  j' \\<in> {0..<Suc n} - {j}", "obtain i' where j'fi: \"j' = f i'\" and i': \"i' \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  j' \\<in> {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>j' = f i'; i' \\<in> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding img[symmetric]"], ["proof (prove)\nusing this:\n  j' \\<in> f ` {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>j' = f i'; i' \\<in> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j' = f i'\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. j' \\<noteq> j \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. j' \\<in> insert_dom f i j ` {0..<Suc n}", "proof(cases \"i' < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}\n 2. \\<not> i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "case True"], ["proof (state)\nthis:\n  i' < i\n\ngoal (2 subgoals):\n 1. i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}\n 2. \\<not> i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  i' < i\n\ngoal (1 subgoal):\n 1. j' \\<in> insert_dom f i j ` {0..<Suc n}", "unfolding j'fi insert_dom_def"], ["proof (prove)\nusing this:\n  i' < i\n\ngoal (1 subgoal):\n 1. f i'\n    \\<in> (\\<lambda>i'.\n              if i' < i then f i' else if i' = i then j else f (i' - 1)) `\n          {0..<Suc n}", "using i'"], ["proof (prove)\nusing this:\n  i' < i\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. f i'\n    \\<in> (\\<lambda>i'.\n              if i' < i then f i' else if i' = i then j else f (i' - 1)) `\n          {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "case False"], ["proof (state)\nthis:\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "hence \"?f (Suc i') = j'\""], ["proof (prove)\nusing this:\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. insert_dom f i j (Suc i') = j'", "unfolding j'fi insert_dom_def"], ["proof (prove)\nusing this:\n  \\<not> i' < i\n\ngoal (1 subgoal):\n 1. (if Suc i' < i then f (Suc i')\n     else if Suc i' = i then j else f (Suc i' - 1)) =\n    f i'", "using i'"], ["proof (prove)\nusing this:\n  \\<not> i' < i\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. (if Suc i' < i then f (Suc i')\n     else if Suc i' = i then j else f (Suc i' - 1)) =\n    f i'", "by auto"], ["proof (state)\nthis:\n  insert_dom f i j (Suc i') = j'\n\ngoal (1 subgoal):\n 1. \\<not> i' < i \\<Longrightarrow> j' \\<in> insert_dom f i j ` {0..<Suc n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  insert_dom f i j (Suc i') = j'\n\ngoal (1 subgoal):\n 1. j' \\<in> insert_dom f i j ` {0..<Suc n}", "using i'"], ["proof (prove)\nusing this:\n  insert_dom f i j (Suc i') = j'\n  i' \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. j' \\<in> insert_dom f i j ` {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  j' \\<in> {0..<Suc n} \\<Longrightarrow>\n  j' \\<in> insert_dom f i j ` {0..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_ran_inj_on:\n  assumes inj: \"inj_on f {0..<n}\" and j: \"j < Suc n\"\n  shows \"inj_on (insert_ran f j) {0..<n}\" (is \"inj_on ?f _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (insert_ran f j) {0..<n}", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        insert_ran f j x = insert_ran f j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix i i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        insert_ran f j x = insert_ran f j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume i: \"i \\<in> {0..<n}\" and i': \"i' \\<in> {0..<n}\" and eq: \"?f i = ?f i'\""], ["proof (state)\nthis:\n  i \\<in> {0..<n}\n  i' \\<in> {0..<n}\n  insert_ran f j i = insert_ran f j i'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        insert_ran f j x = insert_ran f j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "note eq2 = eq[unfolded insert_ran_def insert_index_def]"], ["proof (state)\nthis:\n  (if f i < j then f i else Suc (f i)) =\n  (if f i' < j then f i' else Suc (f i'))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        insert_ran f j x = insert_ran f j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"f i = f i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i = f i'", "proof (cases \"f i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f i < j \\<Longrightarrow> f i = f i'\n 2. \\<not> f i < j \\<Longrightarrow> f i = f i'", "case True"], ["proof (state)\nthis:\n  f i < j\n\ngoal (2 subgoals):\n 1. f i < j \\<Longrightarrow> f i = f i'\n 2. \\<not> f i < j \\<Longrightarrow> f i = f i'", "moreover"], ["proof (state)\nthis:\n  f i < j\n\ngoal (2 subgoals):\n 1. f i < j \\<Longrightarrow> f i = f i'\n 2. \\<not> f i < j \\<Longrightarrow> f i = f i'", "have \"f i' < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i' < j", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f i' < j \\<Longrightarrow> False", "using eq2 True"], ["proof (prove)\nusing this:\n  (if f i < j then f i else Suc (f i)) =\n  (if f i' < j then f i' else Suc (f i'))\n  f i < j\n\ngoal (1 subgoal):\n 1. \\<not> f i' < j \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  f i' < j\n\ngoal (2 subgoals):\n 1. f i < j \\<Longrightarrow> f i = f i'\n 2. \\<not> f i < j \\<Longrightarrow> f i = f i'", "ultimately"], ["proof (chain)\npicking this:\n  f i < j\n  f i' < j", "show ?thesis"], ["proof (prove)\nusing this:\n  f i < j\n  f i' < j\n\ngoal (1 subgoal):\n 1. f i = f i'", "using eq2"], ["proof (prove)\nusing this:\n  f i < j\n  f i' < j\n  (if f i < j then f i else Suc (f i)) =\n  (if f i' < j then f i' else Suc (f i'))\n\ngoal (1 subgoal):\n 1. f i = f i'", "by auto"], ["proof (state)\nthis:\n  f i = f i'\n\ngoal (1 subgoal):\n 1. \\<not> f i < j \\<Longrightarrow> f i = f i'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f i < j \\<Longrightarrow> f i = f i'", "case False"], ["proof (state)\nthis:\n  \\<not> f i < j\n\ngoal (1 subgoal):\n 1. \\<not> f i < j \\<Longrightarrow> f i = f i'", "moreover"], ["proof (state)\nthis:\n  \\<not> f i < j\n\ngoal (1 subgoal):\n 1. \\<not> f i < j \\<Longrightarrow> f i = f i'", "have \"\\<not> f i' < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f i' < j", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<not> f i' < j \\<Longrightarrow> False", "using eq2 False"], ["proof (prove)\nusing this:\n  (if f i < j then f i else Suc (f i)) =\n  (if f i' < j then f i' else Suc (f i'))\n  \\<not> f i < j\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> f i' < j \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<not> f i' < j\n\ngoal (1 subgoal):\n 1. \\<not> f i < j \\<Longrightarrow> f i = f i'", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> f i < j\n  \\<not> f i' < j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> f i < j\n  \\<not> f i' < j\n\ngoal (1 subgoal):\n 1. f i = f i'", "using eq2"], ["proof (prove)\nusing this:\n  \\<not> f i < j\n  \\<not> f i' < j\n  (if f i < j then f i else Suc (f i)) =\n  (if f i' < j then f i' else Suc (f i'))\n\ngoal (1 subgoal):\n 1. f i = f i'", "by auto"], ["proof (state)\nthis:\n  f i = f i'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i = f i'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        insert_ran f j x = insert_ran f j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from inj_onD[OF inj this i i']"], ["proof (chain)\npicking this:\n  i = i'", "show \"i = i'\""], ["proof (prove)\nusing this:\n  i = i'\n\ngoal (1 subgoal):\n 1. i = i'", "."], ["proof (state)\nthis:\n  i = i'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_dom_inj_on:\n  assumes inj: \"inj_on f {0..<n}\"\n      and i: \"i < Suc n\" and j: \"j < Suc n\"\n      and img: \"f ` {0..<n} = {0..<Suc n} - {j}\" (is \"_ = ?N - _\")\n  shows \"inj_on (insert_dom f i j) ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (insert_dom f i j) {0..<Suc n}", "apply(rule eq_card_imp_inj_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {0..<Suc n}\n 2. card (insert_dom f i j ` {0..<Suc n}) = card {0..<Suc n}", "unfolding insert_dom_image[OF i j img]"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {0..<Suc n}\n 2. card {0..<Suc n} = card {0..<Suc n}", "by simp+"], ["", "lemma permutation_insert_bij_betw:\n  assumes q: \"q permutes {0..<n}\" and i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"bij_betw (permutation_insert i j q) {0..<Suc n} {0..<Suc n}\"\n    (is \"bij_betw ?q ?N _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (permutation_insert i j q) {0..<Suc n} {0..<Suc n}", "proof (rule bij_betw_imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (permutation_insert i j q) {0..<Suc n}\n 2. permutation_insert i j q ` {0..<Suc n} = {0..<Suc n}", "have img: \"q ` {0..<n} = {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q ` {0..<n} = {0..<n}", "using permutes_image[OF q]"], ["proof (prove)\nusing this:\n  q ` {0..<n} = {0..<n}\n\ngoal (1 subgoal):\n 1. q ` {0..<n} = {0..<n}", "."], ["proof (state)\nthis:\n  q ` {0..<n} = {0..<n}\n\ngoal (2 subgoals):\n 1. inj_on (permutation_insert i j q) {0..<Suc n}\n 2. permutation_insert i j q ` {0..<Suc n} = {0..<Suc n}", "show \"?q ` ?N = ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i j q ` {0..<Suc n} = {0..<Suc n}", "unfolding permutation_insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_dom (insert_ran q j) i j ` {0..<Suc n} = {0..<Suc n}", "using insert_dom_image[OF i j insert_ran_image[OF j permutes_image[OF q]]]"], ["proof (prove)\nusing this:\n  insert_dom (insert_ran q j) i j ` {0..<Suc n} = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. insert_dom (insert_ran q j) i j ` {0..<Suc n} = {0..<Suc n}", "."], ["proof (state)\nthis:\n  permutation_insert i j q ` {0..<Suc n} = {0..<Suc n}\n\ngoal (1 subgoal):\n 1. inj_on (permutation_insert i j q) {0..<Suc n}", "have inj: \"inj_on q {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on q {0..<n}", "apply(rule subset_inj_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on q ?B\n 2. {0..<n} \\<subseteq> ?B", "using permutes_inj[OF q]"], ["proof (prove)\nusing this:\n  inj q\n\ngoal (2 subgoals):\n 1. inj_on q ?B\n 2. {0..<n} \\<subseteq> ?B", "by auto"], ["proof (state)\nthis:\n  inj_on q {0..<n}\n\ngoal (1 subgoal):\n 1. inj_on (permutation_insert i j q) {0..<Suc n}", "show \"inj_on ?q ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (permutation_insert i j q) {0..<Suc n}", "unfolding permutation_insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (insert_dom (insert_ran q j) i j) {0..<Suc n}", "using insert_dom_inj_on[OF _ i j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?f {0..<n}; ?f ` {0..<n} = {0..<Suc n} - {j}\\<rbrakk>\n  \\<Longrightarrow> inj_on (insert_dom ?f i j) {0..<Suc n}\n\ngoal (1 subgoal):\n 1. inj_on (insert_dom (insert_ran q j) i j) {0..<Suc n}", "using insert_ran_inj_on[OF inj j] insert_ran_image[OF j img]"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?f {0..<n}; ?f ` {0..<n} = {0..<Suc n} - {j}\\<rbrakk>\n  \\<Longrightarrow> inj_on (insert_dom ?f i j) {0..<Suc n}\n  inj_on (insert_ran q j) {0..<n}\n  insert_ran q j ` {0..<n} = {0..<Suc n} - {j}\n\ngoal (1 subgoal):\n 1. inj_on (insert_dom (insert_ran q j) i j) {0..<Suc n}", "by auto"], ["proof (state)\nthis:\n  inj_on (permutation_insert i j q) {0..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_insert_permutes:\n  assumes q: \"q permutes {0..<n}\"\n      and i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"permutation_insert i j q permutes {0..<Suc n}\" (is \"?p permutes ?N\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert i j q permutes {0..<Suc n}", "using permutation_insert_bij_betw[OF q i j]"], ["proof (prove)\nusing this:\n  bij_betw (permutation_insert i j q) {0..<Suc n} {0..<Suc n}\n\ngoal (1 subgoal):\n 1. permutation_insert i j q permutes {0..<Suc n}", "proof (rule bij_imp_permutes)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> {0..<Suc n} \\<Longrightarrow>\n       permutation_insert i j q x = x", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> {0..<Suc n} \\<Longrightarrow>\n       permutation_insert i j q x = x", "assume \"i' \\<notin> ?N\""], ["proof (state)\nthis:\n  i' \\<notin> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> {0..<Suc n} \\<Longrightarrow>\n       permutation_insert i j q x = x", "moreover"], ["proof (state)\nthis:\n  i' \\<notin> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> {0..<Suc n} \\<Longrightarrow>\n       permutation_insert i j q x = x", "hence \"q (i'-1) = i'-1\""], ["proof (prove)\nusing this:\n  i' \\<notin> {0..<Suc n}\n\ngoal (1 subgoal):\n 1. q (i' - 1) = i' - 1", "using permutes_others[OF q]"], ["proof (prove)\nusing this:\n  i' \\<notin> {0..<Suc n}\n  ?x \\<notin> {0..<n} \\<Longrightarrow> q ?x = ?x\n\ngoal (1 subgoal):\n 1. q (i' - 1) = i' - 1", "by auto"], ["proof (state)\nthis:\n  q (i' - 1) = i' - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> {0..<Suc n} \\<Longrightarrow>\n       permutation_insert i j q x = x", "ultimately"], ["proof (chain)\npicking this:\n  i' \\<notin> {0..<Suc n}\n  q (i' - 1) = i' - 1", "show \"?p i' = i'\""], ["proof (prove)\nusing this:\n  i' \\<notin> {0..<Suc n}\n  q (i' - 1) = i' - 1\n\ngoal (1 subgoal):\n 1. permutation_insert i j q i' = i'", "unfolding permutation_insert_expand"], ["proof (prove)\nusing this:\n  i' \\<notin> {0..<Suc n}\n  q (i' - 1) = i' - 1\n\ngoal (1 subgoal):\n 1. (if i' < i then if q i' < j then q i' else Suc (q i')\n     else if i' = i then j\n          else if q (i' - 1) < j then q (i' - 1) else Suc (q (i' - 1))) =\n    i'", "using i j"], ["proof (prove)\nusing this:\n  i' \\<notin> {0..<Suc n}\n  q (i' - 1) = i' - 1\n  i < Suc n\n  j < Suc n\n\ngoal (1 subgoal):\n 1. (if i' < i then if q i' < j then q i' else Suc (q i')\n     else if i' = i then j\n          else if q (i' - 1) < j then q (i' - 1) else Suc (q (i' - 1))) =\n    i'", "by auto"], ["proof (state)\nthis:\n  permutation_insert i j q i' = i'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_fix:\n  assumes i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"{ p. p permutes {0..<Suc n} \\<and> p i = j } =\n         permutation_insert i j ` { q. q permutes {0..<n} }\"\n    (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<Suc n} \\<and> p i = j} =\n    permutation_insert i j ` {q. q permutes {0..<n}}", "unfolding set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}) =\n       (x \\<in> permutation_insert i j ` {q. q permutes {0..<n}})", "proof(intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n       x \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "let ?N = \"{0..<Suc n}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n       x \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n       x \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n       x \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "assume \"p \\<in> ?L\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n       x \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "hence p: \"p permutes ?N\" and pij: \"p i = j\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}\n\ngoal (1 subgoal):\n 1. p permutes {0..<Suc n} &&& p i = j", "by auto"], ["proof (state)\nthis:\n  p permutes {0..<Suc n}\n  p i = j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n       x \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n 2. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "show \"p \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}", "unfolding mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}", "using permutation_delete_permutes[OF p i]"], ["proof (prove)\nusing this:\n  permutation_delete p i permutes {0..<n}\n\ngoal (1 subgoal):\n 1. p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}", "using permutation_insert_delete[OF p i,symmetric]"], ["proof (prove)\nusing this:\n  permutation_delete p i permutes {0..<n}\n  p = permutation_insert i (p i) (permutation_delete p i)\n\ngoal (1 subgoal):\n 1. p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}", "unfolding pij"], ["proof (prove)\nusing this:\n  permutation_delete p i permutes {0..<n}\n  p = permutation_insert i j (permutation_delete p i)\n\ngoal (1 subgoal):\n 1. p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}", "by auto"], ["proof (state)\nthis:\n  p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "}"], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n  p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "{"], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j} \\<Longrightarrow>\n  p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "assume \"p \\<in> ?R\""], ["proof (state)\nthis:\n  p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "then"], ["proof (chain)\npicking this:\n  p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}", "obtain q where pq: \"p = permutation_insert i j q\" and q: \"q permutes {0..<n}\""], ["proof (prove)\nusing this:\n  p \\<in> permutation_insert i j ` {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>p = permutation_insert i j q; q permutes {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = permutation_insert i j q\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "hence \"p i = j\""], ["proof (prove)\nusing this:\n  p = permutation_insert i j q\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. p i = j", "unfolding permutation_insert_expand"], ["proof (prove)\nusing this:\n  p =\n  (\\<lambda>i'.\n      if i' < i then if q i' < j then q i' else Suc (q i')\n      else if i' = i then j\n           else if q (i' - 1) < j then q (i' - 1) else Suc (q (i' - 1)))\n  q permutes {0..<n}\n\ngoal (1 subgoal):\n 1. p i = j", "by simp"], ["proof (state)\nthis:\n  p i = j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutation_insert i j `\n               {q. q permutes {0..<n}} \\<Longrightarrow>\n       x \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "thus \"p \\<in> ?L\""], ["proof (prove)\nusing this:\n  p i = j\n\ngoal (1 subgoal):\n 1. p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "using pq permutation_insert_permutes[OF q i j]"], ["proof (prove)\nusing this:\n  p i = j\n  p = permutation_insert i j q\n  permutation_insert i j q permutes {0..<Suc n}\n\ngoal (1 subgoal):\n 1. p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}", "by auto"], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  p \\<in> permutation_insert i j ` {q. q permutes {0..<n}} \\<Longrightarrow>\n  p \\<in> {p. p permutes {0..<Suc n} \\<and> p i = j}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_split_ran:\n  assumes j: \"j \\<in> S\"\n  shows \"{ p. p permutes S } = (\\<Union>i \\<in> S. { p. p permutes S \\<and> p i = j })\"\n  (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes S} = (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})", "unfolding set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> {p. p permutes S}) =\n       (x \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j}))", "proof(intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes S} \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes S} \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes S} \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "assume \"p \\<in> ?L\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes S}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes S} \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "hence p: \"p permutes S\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes S}\n\ngoal (1 subgoal):\n 1. p permutes S", "by auto"], ["proof (state)\nthis:\n  p permutes S\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes S} \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "obtain i where i: \"i \\<in> S\" and pij: \"p i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> S; p i = j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using j permutes_image[OF p]"], ["proof (prove)\nusing this:\n  j \\<in> S\n  p ` S = S\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> S; p i = j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  i \\<in> S\n  p i = j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {p. p permutes S} \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "thus \"p \\<in> ?R\""], ["proof (prove)\nusing this:\n  i \\<in> S\n  p i = j\n\ngoal (1 subgoal):\n 1. p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})", "using p"], ["proof (prove)\nusing this:\n  i \\<in> S\n  p i = j\n  p permutes S\n\ngoal (1 subgoal):\n 1. p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})", "by auto"], ["proof (state)\nthis:\n  p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "}"], ["proof (state)\nthis:\n  p \\<in> {p. p permutes S} \\<Longrightarrow>\n  p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "{"], ["proof (state)\nthis:\n  p \\<in> {p. p permutes S} \\<Longrightarrow>\n  p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "assume \"p \\<in> ?R\""], ["proof (state)\nthis:\n  p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "then"], ["proof (chain)\npicking this:\n  p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})", "obtain i\n      where p: \"p permutes S\" and i: \"i \\<in> S\" and pij: \"p i = j\""], ["proof (prove)\nusing this:\n  p \\<in> (\\<Union>i\\<in>S. {p. p permutes S \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>p permutes S; i \\<in> S; p i = j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p permutes S\n  i \\<in> S\n  p i = j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>S.\n                   {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n       x \\<in> {p. p permutes S}", "show \"p \\<in> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> {p. p permutes S}", "unfolding mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. p permutes S", "using p"], ["proof (prove)\nusing this:\n  p permutes S\n\ngoal (1 subgoal):\n 1. p permutes S", "."], ["proof (state)\nthis:\n  p \\<in> {p. p permutes S}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  p \\<in> (\\<Union>i\\<in>S.\n              {p. p permutes S \\<and> p i = j}) \\<Longrightarrow>\n  p \\<in> {p. p permutes S}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_disjoint_dom:\n  assumes i: \"i \\<in> S\" and i': \"i' \\<in> S\" and j: \"j \\<in> S\" and ii': \"i \\<noteq> i'\"\n  shows \"{ p. p permutes S \\<and> p i = j } \\<inter> { p. p permutes S \\<and> p i' = j } = {}\"\n    (is \"?L \\<inter> ?R = {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "assume \"p \\<in> ?L \\<inter> ?R\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n          {p. p permutes S \\<and> p i' = j}\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "hence p: \"p permutes S\" and \"p i = j\" and \"p i' = j\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n          {p. p permutes S \\<and> p i' = j}\n\ngoal (1 subgoal):\n 1. p permutes S &&& p i = j &&& p i' = j", "by auto"], ["proof (state)\nthis:\n  p permutes S\n  p i = j\n  p i' = j\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "hence \"p i = p i'\""], ["proof (prove)\nusing this:\n  p permutes S\n  p i = j\n  p i' = j\n\ngoal (1 subgoal):\n 1. p i = p i'", "by auto"], ["proof (state)\nthis:\n  p i = p i'\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "note injD[OF permutes_inj[OF p] this]"], ["proof (state)\nthis:\n  i = i'\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "hence False"], ["proof (prove)\nusing this:\n  i = i'\n\ngoal (1 subgoal):\n 1. False", "using ii'"], ["proof (prove)\nusing this:\n  i = i'\n  i \\<noteq> i'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "}"], ["proof (state)\nthis:\n  ?p2\n  \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n        {p. p permutes S \\<and> p i' = j} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?p2\n  \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n        {p. p permutes S \\<and> p i' = j} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i' = j} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {p. p permutes S \\<and> p i = j} \\<inter>\n  {p. p permutes S \\<and> p i' = j} =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_disjoint_ran:\n  assumes i: \"i \\<in> S\" and j: \"j \\<in> S\" and j': \"j' \\<in> S\" and jj': \"j \\<noteq> j'\"\n  shows \"{ p. p permutes S \\<and> p i = j } \\<inter> { p. p permutes S \\<and> p i = j' } = {}\"\n    (is \"?L \\<inter> ?R = {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "assume \"p \\<in> ?L \\<inter> ?R\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n          {p. p permutes S \\<and> p i = j'}\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "hence \"p permutes S\" and \"p i = j\" and \"p i = j'\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n          {p. p permutes S \\<and> p i = j'}\n\ngoal (1 subgoal):\n 1. p permutes S &&& p i = j &&& p i = j'", "by auto"], ["proof (state)\nthis:\n  p permutes S\n  p i = j\n  p i = j'\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "hence False"], ["proof (prove)\nusing this:\n  p permutes S\n  p i = j\n  p i = j'\n\ngoal (1 subgoal):\n 1. False", "using jj'"], ["proof (prove)\nusing this:\n  p permutes S\n  p i = j\n  p i = j'\n  j \\<noteq> j'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "}"], ["proof (state)\nthis:\n  ?p2\n  \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n        {p. p permutes S \\<and> p i = j'} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?p2\n  \\<in> {p. p permutes S \\<and> p i = j} \\<inter>\n        {p. p permutes S \\<and> p i = j'} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. {p. p permutes S \\<and> p i = j} \\<inter>\n    {p. p permutes S \\<and> p i = j'} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {p. p permutes S \\<and> p i = j} \\<inter>\n  {p. p permutes S \\<and> p i = j'} =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_insert_inj_on:\n  assumes \"i < Suc n\"\n  assumes \"j < Suc n\"\n  shows \"inj_on (permutation_insert i j) { q. q permutes {0..<n} }\"\n  (is \"inj_on ?f ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (permutation_insert i j) {q. q permutes {0..<n}}", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {q. q permutes {0..<n}};\n        y \\<in> {q. q permutes {0..<n}};\n        permutation_insert i j x = permutation_insert i j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix q q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {q. q permutes {0..<n}};\n        y \\<in> {q. q permutes {0..<n}};\n        permutation_insert i j x = permutation_insert i j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"q \\<in> ?S\" \"q' \\<in> ?S\""], ["proof (state)\nthis:\n  q \\<in> {q. q permutes {0..<n}}\n  q' \\<in> {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {q. q permutes {0..<n}};\n        y \\<in> {q. q permutes {0..<n}};\n        permutation_insert i j x = permutation_insert i j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence q: \"q permutes {0..<n}\" and q': \"q' permutes {0..<n}\""], ["proof (prove)\nusing this:\n  q \\<in> {q. q permutes {0..<n}}\n  q' \\<in> {q. q permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. q permutes {0..<n} &&& q' permutes {0..<n}", "by auto"], ["proof (state)\nthis:\n  q permutes {0..<n}\n  q' permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {q. q permutes {0..<n}};\n        y \\<in> {q. q permutes {0..<n}};\n        permutation_insert i j x = permutation_insert i j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"?f q = ?f q'\""], ["proof (state)\nthis:\n  permutation_insert i j q = permutation_insert i j q'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {q. q permutes {0..<n}};\n        y \\<in> {q. q permutes {0..<n}};\n        permutation_insert i j x = permutation_insert i j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence eq: \"permutation_insert i j q = permutation_insert i j q'\""], ["proof (prove)\nusing this:\n  permutation_insert i j q = permutation_insert i j q'\n\ngoal (1 subgoal):\n 1. permutation_insert i j q = permutation_insert i j q'", "by auto"], ["proof (state)\nthis:\n  permutation_insert i j q = permutation_insert i j q'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {q. q permutes {0..<n}};\n        y \\<in> {q. q permutes {0..<n}};\n        permutation_insert i j x = permutation_insert i j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "note eq = cong[OF eq refl, unfolded permutation_insert_expand]"], ["proof (state)\nthis:\n  (if ?x < i then if q ?x < j then q ?x else Suc (q ?x)\n   else if ?x = i then j\n        else if q (?x - 1) < j then q (?x - 1) else Suc (q (?x - 1))) =\n  (if ?x < i then if q' ?x < j then q' ?x else Suc (q' ?x)\n   else if ?x = i then j\n        else if q' (?x - 1) < j then q' (?x - 1) else Suc (q' (?x - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {q. q permutes {0..<n}};\n        y \\<in> {q. q permutes {0..<n}};\n        permutation_insert i j x = permutation_insert i j y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show qq': \"q = q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = q'", "proof(rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. q x = q' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. q x = q' x", "have foo: \"Suc x - 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc x - 1 = x", "by auto"], ["proof (state)\nthis:\n  Suc x - 1 = x\n\ngoal (1 subgoal):\n 1. \\<And>x. q x = q' x", "show \"q x = q' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q x = q' x", "proof(cases \"x < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> q x = q' x\n 2. \\<not> x < i \\<Longrightarrow> q x = q' x", "case True"], ["proof (state)\nthis:\n  x < i\n\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> q x = q' x\n 2. \\<not> x < i \\<Longrightarrow> q x = q' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < i\n\ngoal (1 subgoal):\n 1. q x = q' x", "apply(cases \"q x < j\";cases \"q' x < j\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x < i; q x < j; x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 2. \\<lbrakk>x < i; q x < j; x < i; \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 3. \\<lbrakk>x < i; \\<not> q x < j; x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 4. \\<lbrakk>x < i; \\<not> q x < j; x < i; \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x", "using eq[of x]"], ["proof (prove)\nusing this:\n  (if x < i then if q x < j then q x else Suc (q x)\n   else if x = i then j\n        else if q (x - 1) < j then q (x - 1) else Suc (q (x - 1))) =\n  (if x < i then if q' x < j then q' x else Suc (q' x)\n   else if x = i then j\n        else if q' (x - 1) < j then q' (x - 1) else Suc (q' (x - 1)))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x < i; q x < j; x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 2. \\<lbrakk>x < i; q x < j; x < i; \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 3. \\<lbrakk>x < i; \\<not> q x < j; x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 4. \\<lbrakk>x < i; \\<not> q x < j; x < i; \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x", "by auto"], ["proof (state)\nthis:\n  q x = q' x\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> q x = q' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> q x = q' x", "case False"], ["proof (state)\nthis:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> q x = q' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. q x = q' x", "apply(cases \"q x < j\";cases \"q' x < j\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> x < i; q x < j; \\<not> x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 2. \\<lbrakk>\\<not> x < i; q x < j; \\<not> x < i; \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 3. \\<lbrakk>\\<not> x < i; \\<not> q x < j; \\<not> x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 4. \\<lbrakk>\\<not> x < i; \\<not> q x < j; \\<not> x < i;\n     \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x", "using eq[of \"Suc x\"]"], ["proof (prove)\nusing this:\n  (if Suc x < i then if q (Suc x) < j then q (Suc x) else Suc (q (Suc x))\n   else if Suc x = i then j\n        else if q (Suc x - 1) < j then q (Suc x - 1)\n             else Suc (q (Suc x - 1))) =\n  (if Suc x < i then if q' (Suc x) < j then q' (Suc x) else Suc (q' (Suc x))\n   else if Suc x = i then j\n        else if q' (Suc x - 1) < j then q' (Suc x - 1)\n             else Suc (q' (Suc x - 1)))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> x < i; q x < j; \\<not> x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 2. \\<lbrakk>\\<not> x < i; q x < j; \\<not> x < i; \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 3. \\<lbrakk>\\<not> x < i; \\<not> q x < j; \\<not> x < i; q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x\n 4. \\<lbrakk>\\<not> x < i; \\<not> q x < j; \\<not> x < i;\n     \\<not> q' x < j\\<rbrakk>\n    \\<Longrightarrow> q x = q' x", "by auto"], ["proof (state)\nthis:\n  q x = q' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q x = q' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = q'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma signof_permutation_insert:\n  assumes p: \"p permutes {0..<n}\" and i: \"i < Suc n\" and j: \"j < Suc n\"\n  shows \"signof (permutation_insert i j p) = (-1::'a::ring_1)^(i+j) * signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "assume \"j \\<le> n\""], ["proof (state)\nthis:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "hence \"signof (permutation_insert n (n-j) p) = (-1::'a)^(n+(n-j)) * signof p\""], ["proof (prove)\nusing this:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - j) p) =\n    (- (1::'a)) ^ (n + (n - j)) * signof p", "proof(induct \"j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    signof (permutation_insert n (n - 0) p) =\n    (- (1::'a)) ^ (n + (n - 0)) * signof p\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "case 0"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    signof (permutation_insert n (n - 0) p) =\n    (- (1::'a)) ^ (n + (n - 0)) * signof p\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - 0) p) =\n    (- (1::'a)) ^ (n + (n - 0)) * signof p", "using permutation_insert_base[OF p]"], ["proof (prove)\nusing this:\n  permutation_insert n n p = p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - 0) p) =\n    (- (1::'a)) ^ (n + (n - 0)) * signof p", "by (simp add: mult_2[symmetric])"], ["proof (state)\nthis:\n  signof (permutation_insert n (n - 0) p) =\n  (- (1::'a)) ^ (n + (n - 0)) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "case (Suc j)"], ["proof (state)\nthis:\n  j \\<le> n \\<Longrightarrow>\n  signof (permutation_insert n (n - j) p) =\n  (- (1::'a)) ^ (n + (n - j)) * signof p\n  Suc j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "hence Sjn: \"Suc j \\<le> n\" and j: \"j < n\" and Sj: \"n - Suc j < n\""], ["proof (prove)\nusing this:\n  j \\<le> n \\<Longrightarrow>\n  signof (permutation_insert n (n - j) p) =\n  (- (1::'a)) ^ (n + (n - j)) * signof p\n  Suc j \\<le> n\n\ngoal (1 subgoal):\n 1. Suc j \\<le> n &&& j < n &&& n - Suc j < n", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> n\n  j < n\n  n - Suc j < n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "hence n0: \"n > 0\""], ["proof (prove)\nusing this:\n  Suc j \\<le> n\n  j < n\n  n - Suc j < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have ease: \"Suc (n - Suc j) = n - j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (n - Suc j) = n - j", "using j"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. Suc (n - Suc j) = n - j", "by auto"], ["proof (state)\nthis:\n  Suc (n - Suc j) = n - j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "let ?swap = \"Fun.swap (n - Suc j) (n - j) id\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "let ?prev = \"permutation_insert n (n - j) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"signof (permutation_insert n (n - Suc j) p) = signof (?swap \\<circ> ?prev)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - Suc j) p) =\n    signof\n     (Fun.swap (n - Suc j) (n - j) id \\<circ>\n      permutation_insert n (n - j) p)", "unfolding permutation_insert_column_step[OF p Sj, unfolded ease]"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - Suc j) p) =\n    signof (permutation_insert n (n - Suc j) p)", ".."], ["proof (state)\nthis:\n  signof (permutation_insert n (n - Suc j) p) =\n  signof\n   (Fun.swap (n - Suc j) (n - j) id \\<circ> permutation_insert n (n - j) p)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  signof (permutation_insert n (n - Suc j) p) =\n  signof\n   (Fun.swap (n - Suc j) (n - j) id \\<circ> permutation_insert n (n - j) p)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"... = signof ?swap * signof ?prev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof\n     (Fun.swap (n - Suc j) (n - j) id \\<circ>\n      permutation_insert n (n - j) p) =\n    signof (Fun.swap (n - Suc j) (n - j) id) *\n    signof (permutation_insert n (n - j) p)", "proof(rule signof_compose)"], ["proof (state)\ngoal (2 subgoals):\n 1. Fun.swap (n - Suc j) (n - j) id permutes {0..<?n}\n 2. permutation_insert n (n - j) p permutes {0..<?m}", "show \"?swap permutes {0..<Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap (n - Suc j) (n - j) id permutes {0..<Suc n}", "by (rule permutes_swap_id,auto)"], ["proof (state)\nthis:\n  Fun.swap (n - Suc j) (n - j) id permutes {0..<Suc n}\n\ngoal (1 subgoal):\n 1. permutation_insert n (n - j) p permutes {0..<?m}", "show \"?prev permutes {0..<Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert n (n - j) p permutes {0..<Suc n}", "by (rule permutation_insert_permutes[OF p],auto)"], ["proof (state)\nthis:\n  permutation_insert n (n - j) p permutes {0..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signof\n   (Fun.swap (n - Suc j) (n - j) id \\<circ>\n    permutation_insert n (n - j) p) =\n  signof (Fun.swap (n - Suc j) (n - j) id) *\n  signof (permutation_insert n (n - j) p)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  signof\n   (Fun.swap (n - Suc j) (n - j) id \\<circ>\n    permutation_insert n (n - j) p) =\n  signof (Fun.swap (n - Suc j) (n - j) id) *\n  signof (permutation_insert n (n - j) p)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"signof ?swap = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc j) (n - j) id) = - (1::'b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc j) (n - j) id) = - (1::'b)", "have \"n - Suc j < n - j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc j < n - j", "using Sjn"], ["proof (prove)\nusing this:\n  Suc j \\<le> n\n\ngoal (1 subgoal):\n 1. n - Suc j < n - j", "by simp"], ["proof (state)\nthis:\n  n - Suc j < n - j\n\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc j) (n - j) id) = - (1::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n - Suc j < n - j\n\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc j) (n - j) id) = - (1::'b)", "unfolding signof_def sign_swap_id"], ["proof (prove)\nusing this:\n  n - Suc j < n - j\n\ngoal (1 subgoal):\n 1. (if (if n - Suc j = n - j then 1 else - 1) = 1 then 1::'b\n     else - (1::'b)) =\n    - (1::'b)", "by simp"], ["proof (state)\nthis:\n  signof (Fun.swap (n - Suc j) (n - j) id) = - (1::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signof (Fun.swap (n - Suc j) (n - j) id) = - (1::?'b3)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  signof (Fun.swap (n - Suc j) (n - j) id) = - (1::?'b3)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"signof ?prev = (-1::'a) ^ (n + (n - j)) * signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - j) p) =\n    (- (1::'a)) ^ (n + (n - j)) * signof p", "using Suc(1) j"], ["proof (prove)\nusing this:\n  j \\<le> n \\<Longrightarrow>\n  signof (permutation_insert n (n - j) p) =\n  (- (1::'a)) ^ (n + (n - j)) * signof p\n  j < n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - j) p) =\n    (- (1::'a)) ^ (n + (n - j)) * signof p", "by auto"], ["proof (state)\nthis:\n  signof (permutation_insert n (n - j) p) =\n  (- (1::'a)) ^ (n + (n - j)) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  signof (permutation_insert n (n - j) p) =\n  (- (1::'a)) ^ (n + (n - j)) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"(-1) * ... =  (-1) ^ (1 + n + (n - j)) * signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (1::'a) * ((- (1::'a)) ^ (n + (n - j)) * signof p) =\n    (- (1::'a)) ^ (1 + n + (n - j)) * signof p", "by simp"], ["proof (state)\nthis:\n  - (1::'a) * ((- (1::'a)) ^ (n + (n - j)) * signof p) =\n  (- (1::'a)) ^ (1 + n + (n - j)) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  - (1::'a) * ((- (1::'a)) ^ (n + (n - j)) * signof p) =\n  (- (1::'a)) ^ (1 + n + (n - j)) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"n - j = 1 + (n - Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - j = 1 + (n - Suc j)", "using j"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. n - j = 1 + (n - Suc j)", "by simp"], ["proof (state)\nthis:\n  n - j = 1 + (n - Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  n - j = 1 + (n - Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"1 + n + ... = 2 + (n + (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + n + (1 + (n - Suc j)) = 2 + (n + (n - Suc j))", "by simp"], ["proof (state)\nthis:\n  1 + n + (1 + (n - Suc j)) = 2 + (n + (n - Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  1 + n + (1 + (n - Suc j)) = 2 + (n + (n - Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"(-1::'a) ^ ... = (-1) ^ 2 * (-1) ^ (n + (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (2 + (n + (n - Suc j))) =\n    (- (1::'a))\\<^sup>2 * (- (1::'a)) ^ (n + (n - Suc j))", "by simp"], ["proof (state)\nthis:\n  (- (1::'a)) ^ (2 + (n + (n - Suc j))) =\n  (- (1::'a))\\<^sup>2 * (- (1::'a)) ^ (n + (n - Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "also"], ["proof (state)\nthis:\n  (- (1::'a)) ^ (2 + (n + (n - Suc j))) =\n  (- (1::'a))\\<^sup>2 * (- (1::'a)) ^ (n + (n - Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "have \"... = (-1) ^ (n + (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a))\\<^sup>2 * (- (1::'a)) ^ (n + (n - Suc j)) =\n    (- (1::'a)) ^ (n + (n - Suc j))", "by simp"], ["proof (state)\nthis:\n  (- (1::'a))\\<^sup>2 * (- (1::'a)) ^ (n + (n - Suc j)) =\n  (- (1::'a)) ^ (n + (n - Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> n \\<Longrightarrow>\n                signof (permutation_insert n (n - j) p) =\n                (- (1::'a)) ^ (n + (n - j)) * signof p;\n        Suc j \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert n (n - Suc j) p) =\n                         (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "finally"], ["proof (chain)\npicking this:\n  signof (permutation_insert n (n - Suc j) p) =\n  (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "show ?case"], ["proof (prove)\nusing this:\n  signof (permutation_insert n (n - Suc j) p) =\n  (- (1::'a)) ^ (n + (n - Suc j)) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert n (n - Suc j) p) =\n    (- (1::'a)) ^ (n + (n - Suc j)) * signof p", "."], ["proof (state)\nthis:\n  signof (permutation_insert n (n - Suc j) p) =\n  (- (1::'a)) ^ (n + (n - Suc j)) * signof p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signof (permutation_insert n (n - j) p) =\n  (- (1::'a)) ^ (n + (n - j)) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "}"], ["proof (state)\nthis:\n  ?ja2 \\<le> n \\<Longrightarrow>\n  signof (permutation_insert n (n - ?ja2) p) =\n  (- (1::'a)) ^ (n + (n - ?ja2)) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "note col = this"], ["proof (state)\nthis:\n  ?ja2 \\<le> n \\<Longrightarrow>\n  signof (permutation_insert n (n - ?ja2) p) =\n  (- (1::'a)) ^ (n + (n - ?ja2)) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "have nj: \"n - j \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - j \\<le> n", "using j"], ["proof (prove)\nusing this:\n  j < Suc n\n\ngoal (1 subgoal):\n 1. n - j \\<le> n", "by auto"], ["proof (state)\nthis:\n  n - j \\<le> n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "have row_base: \"signof (permutation_insert n j p) = (-1::'a)^(n+j) * signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert n j p) = (- (1::'a)) ^ (n + j) * signof p", "using col[OF nj]"], ["proof (prove)\nusing this:\n  signof (permutation_insert n (n - (n - j)) p) =\n  (- (1::'a)) ^ (n + (n - (n - j))) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert n j p) = (- (1::'a)) ^ (n + j) * signof p", "using j"], ["proof (prove)\nusing this:\n  signof (permutation_insert n (n - (n - j)) p) =\n  (- (1::'a)) ^ (n + (n - (n - j))) * signof p\n  j < Suc n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert n j p) = (- (1::'a)) ^ (n + j) * signof p", "by simp"], ["proof (state)\nthis:\n  signof (permutation_insert n j p) = (- (1::'a)) ^ (n + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "{"], ["proof (state)\nthis:\n  signof (permutation_insert n j p) = (- (1::'a)) ^ (n + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "assume \"i \\<le> n\""], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "hence \"signof (permutation_insert (n-i) j p) = (-1::'a)^((n-i)+j) * signof p\""], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - i) j p) =\n    (- (1::'a)) ^ (n - i + j) * signof p", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    signof (permutation_insert (n - 0) j p) =\n    (- (1::'a)) ^ (n - 0 + j) * signof p\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "case 0"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    signof (permutation_insert (n - 0) j p) =\n    (- (1::'a)) ^ (n - 0 + j) * signof p\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - 0) j p) =\n    (- (1::'a)) ^ (n - 0 + j) * signof p", "using row_base"], ["proof (prove)\nusing this:\n  signof (permutation_insert n j p) = (- (1::'a)) ^ (n + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - 0) j p) =\n    (- (1::'a)) ^ (n - 0 + j) * signof p", "by auto"], ["proof (state)\nthis:\n  signof (permutation_insert (n - 0) j p) =\n  (- (1::'a)) ^ (n - 0 + j) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "case (Suc i)"], ["proof (state)\nthis:\n  i \\<le> n \\<Longrightarrow>\n  signof (permutation_insert (n - i) j p) =\n  (- (1::'a)) ^ (n - i + j) * signof p\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "hence Sin: \"Suc i \\<le> n\" and i: \"i \\<le> n\" and Si: \"n - Suc i < n\""], ["proof (prove)\nusing this:\n  i \\<le> n \\<Longrightarrow>\n  signof (permutation_insert (n - i) j p) =\n  (- (1::'a)) ^ (n - i + j) * signof p\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. Suc i \\<le> n &&& i \\<le> n &&& n - Suc i < n", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> n\n  i \\<le> n\n  n - Suc i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have ease: \"Suc (n - Suc i) = n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (n - Suc i) = n - i", "using Sin"], ["proof (prove)\nusing this:\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. Suc (n - Suc i) = n - i", "by auto"], ["proof (state)\nthis:\n  Suc (n - Suc i) = n - i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "let ?prev = \"permutation_insert (n-i) j p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "let ?swap = \"Fun.swap (n - Suc i) (n-i) id\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have \"signof (permutation_insert (n - Suc i) j p) = signof (?prev \\<circ> ?swap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - Suc i) j p) =\n    signof\n     (permutation_insert (n - i) j p \\<circ>\n      Fun.swap (n - Suc i) (n - i) id)", "using permutation_insert_row_step[of \"n - Suc i\"]"], ["proof (prove)\nusing this:\n  permutation_insert (Suc (n - Suc i)) ?j ?p \\<circ>\n  Fun.swap (n - Suc i) (Suc (n - Suc i)) id =\n  permutation_insert (n - Suc i) ?j ?p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - Suc i) j p) =\n    signof\n     (permutation_insert (n - i) j p \\<circ>\n      Fun.swap (n - Suc i) (n - i) id)", "unfolding ease"], ["proof (prove)\nusing this:\n  permutation_insert (n - i) ?j ?p \\<circ> Fun.swap (n - Suc i) (n - i) id =\n  permutation_insert (n - Suc i) ?j ?p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - Suc i) j p) =\n    signof\n     (permutation_insert (n - i) j p \\<circ>\n      Fun.swap (n - Suc i) (n - i) id)", "by auto"], ["proof (state)\nthis:\n  signof (permutation_insert (n - Suc i) j p) =\n  signof\n   (permutation_insert (n - i) j p \\<circ> Fun.swap (n - Suc i) (n - i) id)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "also"], ["proof (state)\nthis:\n  signof (permutation_insert (n - Suc i) j p) =\n  signof\n   (permutation_insert (n - i) j p \\<circ> Fun.swap (n - Suc i) (n - i) id)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have \"... = signof ?prev * signof ?swap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof\n     (permutation_insert (n - i) j p \\<circ>\n      Fun.swap (n - Suc i) (n - i) id) =\n    signof (permutation_insert (n - i) j p) *\n    signof (Fun.swap (n - Suc i) (n - i) id)", "proof(rule signof_compose)"], ["proof (state)\ngoal (2 subgoals):\n 1. permutation_insert (n - i) j p permutes {0..<?n}\n 2. Fun.swap (n - Suc i) (n - i) id permutes {0..<?m}", "show \"?swap permutes {0..<Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap (n - Suc i) (n - i) id permutes {0..<Suc n}", "by (rule permutes_swap_id,auto)"], ["proof (state)\nthis:\n  Fun.swap (n - Suc i) (n - i) id permutes {0..<Suc n}\n\ngoal (1 subgoal):\n 1. permutation_insert (n - i) j p permutes {0..<?n}", "show \"?prev permutes {0..<Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_insert (n - i) j p permutes {0..<Suc n}", "apply(rule permutation_insert_permutes[OF p])"], ["proof (prove)\ngoal (2 subgoals):\n 1. n - i < Suc n\n 2. j < Suc n", "using j"], ["proof (prove)\nusing this:\n  j < Suc n\n\ngoal (2 subgoals):\n 1. n - i < Suc n\n 2. j < Suc n", "by auto"], ["proof (state)\nthis:\n  permutation_insert (n - i) j p permutes {0..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signof\n   (permutation_insert (n - i) j p \\<circ>\n    Fun.swap (n - Suc i) (n - i) id) =\n  signof (permutation_insert (n - i) j p) *\n  signof (Fun.swap (n - Suc i) (n - i) id)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "also"], ["proof (state)\nthis:\n  signof\n   (permutation_insert (n - i) j p \\<circ>\n    Fun.swap (n - Suc i) (n - i) id) =\n  signof (permutation_insert (n - i) j p) *\n  signof (Fun.swap (n - Suc i) (n - i) id)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have \"signof ?swap = (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc i) (n - i) id) = - (1::'b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc i) (n - i) id) = - (1::'b)", "have \"n - Suc i < n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc i < n - i", "using Sin"], ["proof (prove)\nusing this:\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. n - Suc i < n - i", "by simp"], ["proof (state)\nthis:\n  n - Suc i < n - i\n\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc i) (n - i) id) = - (1::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n - Suc i < n - i\n\ngoal (1 subgoal):\n 1. signof (Fun.swap (n - Suc i) (n - i) id) = - (1::'b)", "unfolding signof_def sign_swap_id"], ["proof (prove)\nusing this:\n  n - Suc i < n - i\n\ngoal (1 subgoal):\n 1. (if (if n - Suc i = n - i then 1 else - 1) = 1 then 1::'b\n     else - (1::'b)) =\n    - (1::'b)", "by simp"], ["proof (state)\nthis:\n  signof (Fun.swap (n - Suc i) (n - i) id) = - (1::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signof (Fun.swap (n - Suc i) (n - i) id) = - (1::?'b3)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "also"], ["proof (state)\nthis:\n  signof (Fun.swap (n - Suc i) (n - i) id) = - (1::?'b3)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have \"signof ?prev = (-1::'a) ^ (n - i + j) * signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - i) j p) =\n    (- (1::'a)) ^ (n - i + j) * signof p", "using Suc(1)[OF i]"], ["proof (prove)\nusing this:\n  signof (permutation_insert (n - i) j p) =\n  (- (1::'a)) ^ (n - i + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - i) j p) =\n    (- (1::'a)) ^ (n - i + j) * signof p", "."], ["proof (state)\nthis:\n  signof (permutation_insert (n - i) j p) =\n  (- (1::'a)) ^ (n - i + j) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "also"], ["proof (state)\nthis:\n  signof (permutation_insert (n - i) j p) =\n  (- (1::'a)) ^ (n - i + j) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have \"... * (-1) = (-1) ^ Suc (n - i + j) * signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (n - i + j) * signof p * - (1::'a) =\n    (- (1::'a)) ^ Suc (n - i + j) * signof p", "by auto"], ["proof (state)\nthis:\n  (- (1::'a)) ^ (n - i + j) * signof p * - (1::'a) =\n  (- (1::'a)) ^ Suc (n - i + j) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "also"], ["proof (state)\nthis:\n  (- (1::'a)) ^ (n - i + j) * signof p * - (1::'a) =\n  (- (1::'a)) ^ Suc (n - i + j) * signof p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have \"Suc (n - i + j) = Suc (Suc (n - Suc i + j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (n - i + j) = Suc (Suc (n - Suc i + j))", "using Sin"], ["proof (prove)\nusing this:\n  Suc i \\<le> n\n\ngoal (1 subgoal):\n 1. Suc (n - i + j) = Suc (Suc (n - Suc i + j))", "by auto"], ["proof (state)\nthis:\n  Suc (n - i + j) = Suc (Suc (n - Suc i + j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "also"], ["proof (state)\nthis:\n  Suc (n - i + j) = Suc (Suc (n - Suc i + j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "have \"(-1::int) ^ ... = (-1) ^ (n - Suc i + j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ Suc (Suc (n - Suc i + j)) = (- 1) ^ (n - Suc i + j)", "by auto"], ["proof (state)\nthis:\n  (- 1) ^ Suc (Suc (n - Suc i + j)) = (- 1) ^ (n - Suc i + j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n \\<Longrightarrow>\n                signof (permutation_insert (n - i) j p) =\n                (- (1::'a)) ^ (n - i + j) * signof p;\n        Suc i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> signof (permutation_insert (n - Suc i) j p) =\n                         (- (1::'a)) ^ (n - Suc i + j) * signof p", "ultimately"], ["proof (chain)\npicking this:\n  signof (permutation_insert (n - Suc i) j p) =\n  (- (1::'a)) ^ Suc (Suc (n - Suc i + j)) * signof p\n  (- 1) ^ Suc (Suc (n - Suc i + j)) = (- 1) ^ (n - Suc i + j)", "show ?case"], ["proof (prove)\nusing this:\n  signof (permutation_insert (n - Suc i) j p) =\n  (- (1::'a)) ^ Suc (Suc (n - Suc i + j)) * signof p\n  (- 1) ^ Suc (Suc (n - Suc i + j)) = (- 1) ^ (n - Suc i + j)\n\ngoal (1 subgoal):\n 1. signof (permutation_insert (n - Suc i) j p) =\n    (- (1::'a)) ^ (n - Suc i + j) * signof p", "by auto"], ["proof (state)\nthis:\n  signof (permutation_insert (n - Suc i) j p) =\n  (- (1::'a)) ^ (n - Suc i + j) * signof p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signof (permutation_insert (n - i) j p) =\n  (- (1::'a)) ^ (n - i + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "}"], ["proof (state)\nthis:\n  ?ia2 \\<le> n \\<Longrightarrow>\n  signof (permutation_insert (n - ?ia2) j p) =\n  (- (1::'a)) ^ (n - ?ia2 + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "note row = this"], ["proof (state)\nthis:\n  ?ia2 \\<le> n \\<Longrightarrow>\n  signof (permutation_insert (n - ?ia2) j p) =\n  (- (1::'a)) ^ (n - ?ia2 + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "have ni: \"n - i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - i \\<le> n", "using i"], ["proof (prove)\nusing this:\n  i < Suc n\n\ngoal (1 subgoal):\n 1. n - i \\<le> n", "by auto"], ["proof (state)\nthis:\n  n - i \\<le> n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "using row[OF ni]"], ["proof (prove)\nusing this:\n  signof (permutation_insert (n - (n - i)) j p) =\n  (- (1::'a)) ^ (n - (n - i) + j) * signof p\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "using i"], ["proof (prove)\nusing this:\n  signof (permutation_insert (n - (n - i)) j p) =\n  (- (1::'a)) ^ (n - (n - i) + j) * signof p\n  i < Suc n\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p", "by simp"], ["proof (state)\nthis:\n  signof (permutation_insert i j p) = (- (1::'a)) ^ (i + j) * signof p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foo:\n  assumes i: \"i < Suc n\" and j: \"j < Suc n\"\n  assumes q: \"q permutes {0..<n}\"\n  shows \"{(i', permutation_insert i j q i') | i'. i' \\<in> {0..<Suc n} - {i} } =\n  { (insert_index i i'', insert_index j (q i'')) | i''. i'' < n }\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc n} - {i}} =\n    {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}", "unfolding set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> {(i', permutation_insert i j q i') |i'.\n                 i' \\<in> {0..<Suc n} - {i}}) =\n       (x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                 i'' < n})", "proof(intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}} \\<Longrightarrow>\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n 2. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "fix ij"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}} \\<Longrightarrow>\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n 2. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}} \\<Longrightarrow>\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n 2. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "assume \"ij \\<in> ?L\""], ["proof (state)\nthis:\n  ij \\<in> {(i', permutation_insert i j q i') |i'.\n            i' \\<in> {0..<Suc n} - {i}}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}} \\<Longrightarrow>\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n 2. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "then"], ["proof (chain)\npicking this:\n  ij \\<in> {(i', permutation_insert i j q i') |i'.\n            i' \\<in> {0..<Suc n} - {i}}", "obtain i'\n      where ij: \"ij = (i', permutation_insert i j q i')\" and i': \"i' < Suc n\" and i'i: \"i' \\<noteq> i\""], ["proof (prove)\nusing this:\n  ij \\<in> {(i', permutation_insert i j q i') |i'.\n            i' \\<in> {0..<Suc n} - {i}}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>ij = (i', permutation_insert i j q i'); i' < Suc n;\n         i' \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ij = (i', permutation_insert i j q i')\n  i' < Suc n\n  i' \\<noteq> i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}} \\<Longrightarrow>\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n 2. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "show \"ij \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}", "unfolding mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i''.\n       ij = (insert_index i i'', insert_index j (q i'')) \\<and> i'' < n", "proof(intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ij = (insert_index i ?i'', insert_index j (q ?i''))\n 2. ?i'' < n", "show \"ij = (insert_index i (delete_index i i'), insert_index j (q (delete_index i i')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ij =\n    (insert_index i (delete_index i i'),\n     insert_index j (q (delete_index i i')))", "using ij"], ["proof (prove)\nusing this:\n  ij = (i', permutation_insert i j q i')\n\ngoal (1 subgoal):\n 1. ij =\n    (insert_index i (delete_index i i'),\n     insert_index j (q (delete_index i i')))", "unfolding insert_delete_index[OF i'i]"], ["proof (prove)\nusing this:\n  ij = (i', permutation_insert i j q i')\n\ngoal (1 subgoal):\n 1. ij = (i', insert_index j (q (delete_index i i')))", "using i'i"], ["proof (prove)\nusing this:\n  ij = (i', permutation_insert i j q i')\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. ij = (i', insert_index j (q (delete_index i i')))", "unfolding permutation_insert_expand insert_index_def delete_index_def"], ["proof (prove)\nusing this:\n  ij =\n  (i',\n   if i' < i then if q i' < j then q i' else Suc (q i')\n   else if i' = i then j\n        else if q (i' - 1) < j then q (i' - 1) else Suc (q (i' - 1)))\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. ij =\n    (i',\n     if q (if i' < i then i' else i' - Suc 0) < j\n     then q (if i' < i then i' else i' - Suc 0)\n     else Suc (q (if i' < i then i' else i' - Suc 0)))", "by auto"], ["proof (state)\nthis:\n  ij =\n  (insert_index i (delete_index i i'),\n   insert_index j (q (delete_index i i')))\n\ngoal (1 subgoal):\n 1. delete_index i i' < n", "show \"delete_index i i' < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_index i i' < n", "using i' i i'i"], ["proof (prove)\nusing this:\n  i' < Suc n\n  i < Suc n\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. delete_index i i' < n", "unfolding delete_index_def"], ["proof (prove)\nusing this:\n  i' < Suc n\n  i < Suc n\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. (if i' < i then i' else i' - Suc 0) < n", "by auto"], ["proof (state)\nthis:\n  delete_index i i' < n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "}"], ["proof (state)\nthis:\n  ij \\<in> {(i', permutation_insert i j q i') |i'.\n            i' \\<in> {0..<Suc n} - {i}} \\<Longrightarrow>\n  ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "{"], ["proof (state)\nthis:\n  ij \\<in> {(i', permutation_insert i j q i') |i'.\n            i' \\<in> {0..<Suc n} - {i}} \\<Longrightarrow>\n  ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "assume \"ij \\<in> ?R\""], ["proof (state)\nthis:\n  ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "then"], ["proof (chain)\npicking this:\n  ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}", "obtain i''\n      where ij: \"ij = (insert_index i i'', insert_index j (q i''))\" and i'': \"i'' < n\""], ["proof (prove)\nusing this:\n  ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''. i'' < n}\n\ngoal (1 subgoal):\n 1. (\\<And>i''.\n        \\<lbrakk>ij = (insert_index i i'', insert_index j (q i''));\n         i'' < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ij = (insert_index i i'', insert_index j (q i''))\n  i'' < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n                i'' < n} \\<Longrightarrow>\n       x \\<in> {(i', permutation_insert i j q i') |i'.\n                i' \\<in> {0..<Suc n} - {i}}", "show \"ij \\<in> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ij \\<in> {(i', permutation_insert i j q i') |i'.\n              i' \\<in> {0..<Suc n} - {i}}", "unfolding mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i'.\n       ij = (i', permutation_insert i j q i') \\<and>\n       i' \\<in> {0..<Suc n} - {i}", "proof(intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ij = (?i', permutation_insert i j q ?i')\n 2. ?i' \\<in> {0..<Suc n} - {i}", "show \"insert_index i i'' \\<in> {0..<Suc n} - {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index i i'' \\<in> {0..<Suc n} - {i}", "unfolding insert_index_image[OF i,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index i i'' \\<in> insert_index i ` {0..<n}", "using i''"], ["proof (prove)\nusing this:\n  i'' < n\n\ngoal (1 subgoal):\n 1. insert_index i i'' \\<in> insert_index i ` {0..<n}", "by auto"], ["proof (state)\nthis:\n  insert_index i i'' \\<in> {0..<Suc n} - {i}\n\ngoal (1 subgoal):\n 1. ij = (insert_index i i'', permutation_insert i j q (insert_index i i''))", "have \"insert_index j (q i'') = permutation_insert i j q (insert_index i i'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_index j (q i'') = permutation_insert i j q (insert_index i i'')", "unfolding permutation_insert_expand insert_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if q i'' < j then q i'' else Suc (q i'')) =\n    (if (if i'' < i then i'' else Suc i'') < i\n     then if q (if i'' < i then i'' else Suc i'') < j\n          then q (if i'' < i then i'' else Suc i'')\n          else Suc (q (if i'' < i then i'' else Suc i''))\n     else if (if i'' < i then i'' else Suc i'') = i then j\n          else if q ((if i'' < i then i'' else Suc i'') - 1) < j\n               then q ((if i'' < i then i'' else Suc i'') - 1)\n               else Suc (q ((if i'' < i then i'' else Suc i'') - 1)))", "by auto"], ["proof (state)\nthis:\n  insert_index j (q i'') = permutation_insert i j q (insert_index i i'')\n\ngoal (1 subgoal):\n 1. ij = (insert_index i i'', permutation_insert i j q (insert_index i i''))", "thus \"ij = (insert_index i i'', permutation_insert i j q (insert_index i i''))\""], ["proof (prove)\nusing this:\n  insert_index j (q i'') = permutation_insert i j q (insert_index i i'')\n\ngoal (1 subgoal):\n 1. ij = (insert_index i i'', permutation_insert i j q (insert_index i i''))", "unfolding ij"], ["proof (prove)\nusing this:\n  insert_index j (q i'') = permutation_insert i j q (insert_index i i'')\n\ngoal (1 subgoal):\n 1. (insert_index i i'', insert_index j (q i'')) =\n    (insert_index i i'', permutation_insert i j q (insert_index i i''))", "by auto"], ["proof (state)\nthis:\n  ij = (insert_index i i'', permutation_insert i j q (insert_index i i''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ij \\<in> {(i', permutation_insert i j q i') |i'.\n            i' \\<in> {0..<Suc n} - {i}}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ij \\<in> {(insert_index i i'', insert_index j (q i'')) |i''.\n            i'' < n} \\<Longrightarrow>\n  ij \\<in> {(i', permutation_insert i j q i') |i'.\n            i' \\<in> {0..<Suc n} - {i}}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"mat_delete A i j \\<equiv>\n  mat (dim_row A - 1) (dim_col A - 1) (\\<lambda>(i',j').\n    A $$ (if i' < i then i' else Suc i', if j' < j then j' else Suc j'))\""], ["", "lemma mat_delete_dim[simp]:\n  \"dim_row (mat_delete A i j) = dim_row A - 1\"\n  \"dim_col (mat_delete A i j) = dim_col A - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_delete A i j) = dim_row A - 1 &&&\n    dim_col (mat_delete A i j) = dim_col A - 1", "unfolding mat_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (dim_row A - 1) (dim_col A - 1)\n       (\\<lambda>(i', j').\n           A $$\n           (if i' < i then i' else Suc i',\n            if j' < j then j' else Suc j'))) =\n    dim_row A - 1 &&&\n    dim_col\n     (mat (dim_row A - 1) (dim_col A - 1)\n       (\\<lambda>(i', j').\n           A $$\n           (if i' < i then i' else Suc i',\n            if j' < j then j' else Suc j'))) =\n    dim_col A - 1", "by auto"], ["", "lemma mat_delete_carrier:\n  assumes A: \"A \\<in> carrier_mat m n\"\n  shows \"mat_delete A i j \\<in> carrier_mat (m-1) (n-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_delete A i j \\<in> carrier_mat (m - 1) (n - 1)", "unfolding mat_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j'))\n    \\<in> carrier_mat (m - 1) (n - 1)", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j'))\n    \\<in> carrier_mat (m - 1) (n - 1)", "by auto"], ["", "lemma \"mat_delete_index\":\n  assumes A: \"A \\<in> carrier_mat (Suc n) (Suc n)\"\n      and i: \"i < Suc n\" and j: \"j < Suc n\"\n      and i': \"i' < n\" and j': \"j' < n\"\n  shows \"A $$ (insert_index i i', insert_index j j') = mat_delete A i j $$ (i', j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (insert_index i i', insert_index j j') =\n    mat_delete A i j $$ (i', j')", "unfolding mat_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (insert_index i i', insert_index j j') =\n    mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j')) $$\n    (i', j')", "unfolding permutation_insert_expand"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (insert_index i i', insert_index j j') =\n    mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j')) $$\n    (i', j')", "unfolding insert_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (if i' < i then i' else Suc i', if j' < j then j' else Suc j') =\n    mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j')) $$\n    (i', j')", "using A i j i' j'"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (Suc n) (Suc n)\n  i < Suc n\n  j < Suc n\n  i' < n\n  j' < n\n\ngoal (1 subgoal):\n 1. A $$ (if i' < i then i' else Suc i', if j' < j then j' else Suc j') =\n    mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j')) $$\n    (i', j')", "by auto"], ["", "definition \"cofactor A i j = (-1)^(i+j) * det (mat_delete A i j)\""], ["", "lemma laplace_expansion_column:\n  assumes A: \"(A :: 'a :: comm_ring_1 mat) \\<in> carrier_mat n n\"\n      and j: \"j < n\"\n  shows \"det A = (\\<Sum>i<n. A $$ (i,j) * cofactor A i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "define l where \"l = n-1\""], ["proof (state)\nthis:\n  l = n - 1\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have A: \"A \\<in> carrier_mat (Suc l) (Suc l)\"\n   and jl: \"j < Suc l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (Suc l) (Suc l) &&& j < Suc l", "using A j"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  j < n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (Suc l) (Suc l) &&& j < Suc l", "unfolding l_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  j < n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (Suc (n - 1)) (Suc (n - 1)) &&& j < Suc (n - 1)", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (Suc l) (Suc l)\n  j < Suc l\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "let ?N = \"{0 ..< Suc l}\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "define f where \"f = (\\<lambda>p i. A $$ (i, p i))\""], ["proof (state)\nthis:\n  f = (\\<lambda>p i. A $$ (i, p i))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "define g where \"g = (\\<lambda>p. prod (f p) ?N)\""], ["proof (state)\nthis:\n  g = (\\<lambda>p. prod (f p) {0..<Suc l})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "define h where \"h = (\\<lambda>p. signof p * g p)\""], ["proof (state)\nthis:\n  h = (\\<lambda>p. signof p * g p)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "define Q where \"Q = { q . q permutes {0..<l} }\""], ["proof (state)\nthis:\n  Q = {q. q permutes {0..<l}}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have jN: \"j \\<in> ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> {0..<Suc l}", "using jl"], ["proof (prove)\nusing this:\n  j < Suc l\n\ngoal (1 subgoal):\n 1. j \\<in> {0..<Suc l}", "by auto"], ["proof (state)\nthis:\n  j \\<in> {0..<Suc l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have disj: \"\\<forall>i \\<in> ?N. \\<forall>i' \\<in> ?N. i \\<noteq> i' \\<longrightarrow>\n    {p. p permutes ?N \\<and> p i = j} \\<inter> {p. p permutes ?N \\<and> p i' = j} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<Suc l}.\n       \\<forall>i'\\<in>{0..<Suc l}.\n          i \\<noteq> i' \\<longrightarrow>\n          {p. p permutes {0..<Suc l} \\<and> p i = j} \\<inter>\n          {p. p permutes {0..<Suc l} \\<and> p i' = j} =\n          {}", "using permutation_disjoint_dom[OF _ _ jN]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> {0..<Suc l}; ?i' \\<in> {0..<Suc l};\n   ?i \\<noteq> ?i'\\<rbrakk>\n  \\<Longrightarrow> {p. p permutes {0..<Suc l} \\<and> p ?i = j} \\<inter>\n                    {p. p permutes {0..<Suc l} \\<and> p ?i' = j} =\n                    {}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<Suc l}.\n       \\<forall>i'\\<in>{0..<Suc l}.\n          i \\<noteq> i' \\<longrightarrow>\n          {p. p permutes {0..<Suc l} \\<and> p i = j} \\<inter>\n          {p. p permutes {0..<Suc l} \\<and> p i' = j} =\n          {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..<Suc l}.\n     \\<forall>i'\\<in>{0..<Suc l}.\n        i \\<noteq> i' \\<longrightarrow>\n        {p. p permutes {0..<Suc l} \\<and> p i = j} \\<inter>\n        {p. p permutes {0..<Suc l} \\<and> p i' = j} =\n        {}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have fin: \"\\<forall>i\\<in>?N. finite {p. p permutes ?N \\<and> p i = j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<Suc l}.\n       finite {p. p permutes {0..<Suc l} \\<and> p i = j}", "using finite_permutations[of ?N]"], ["proof (prove)\nusing this:\n  finite {0..<Suc l} \\<Longrightarrow> finite {p. p permutes {0..<Suc l}}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<Suc l}.\n       finite {p. p permutes {0..<Suc l} \\<and> p i = j}", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..<Suc l}.\n     finite {p. p permutes {0..<Suc l} \\<and> p i = j}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"det A = sum h { p. p permutes ?N }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = sum h {p. p permutes {0..<Suc l}}", "using det_def'[OF A]"], ["proof (prove)\nusing this:\n  det A =\n  (\\<Sum>p | p permutes {0..<Suc l}.\n     signof p * (\\<Prod>i = 0..<Suc l. A $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. det A = sum h {p. p permutes {0..<Suc l}}", "unfolding h_def g_def f_def"], ["proof (prove)\nusing this:\n  det A =\n  (\\<Sum>p | p permutes {0..<Suc l}.\n     signof p * (\\<Prod>i = 0..<Suc l. A $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<Suc l}.\n       signof p * (\\<Prod>i = 0..<Suc l. A $$ (i, p i)))", "using atLeast0LessThan"], ["proof (prove)\nusing this:\n  det A =\n  (\\<Sum>p | p permutes {0..<Suc l}.\n     signof p * (\\<Prod>i = 0..<Suc l. A $$ (i, p i)))\n  {0..<?n} = {..<?n}\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Sum>p | p permutes {0..<Suc l}.\n       signof p * (\\<Prod>i = 0..<Suc l. A $$ (i, p i)))", "by auto"], ["proof (state)\nthis:\n  det A = sum h {p. p permutes {0..<Suc l}}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  det A = sum h {p. p permutes {0..<Suc l}}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = sum h (\\<Union>i\\<in>?N. {p. p permutes ?N \\<and> p i = j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h {p. p permutes {0..<Suc l}} =\n    sum h\n     (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j})", "unfolding permutation_split_ran[OF jN]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h\n     (\\<Union>i\\<in>{0..<Suc l}.\n         {p. p permutes {0..<Suc l} \\<and> p i = j}) =\n    sum h\n     (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j})", ".."], ["proof (state)\nthis:\n  sum h {p. p permutes {0..<Suc l}} =\n  sum h\n   (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  sum h {p. p permutes {0..<Suc l}} =\n  sum h\n   (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = (\\<Sum>i\\<in>?N. sum h { p | p. p permutes ?N \\<and> p i = j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h\n     (\\<Union>i\\<in>{0..<Suc l}.\n         {p. p permutes {0..<Suc l} \\<and> p i = j}) =\n    (\\<Sum>i = 0..<Suc l.\n        sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j})", "using sum.UNION_disjoint[OF _ fin disj]"], ["proof (prove)\nusing this:\n  finite {0..<Suc l} \\<Longrightarrow>\n  sum ?g\n   (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j}) =\n  (\\<Sum>x = 0..<Suc l. sum ?g {p. p permutes {0..<Suc l} \\<and> p x = j})\n\ngoal (1 subgoal):\n 1. sum h\n     (\\<Union>i\\<in>{0..<Suc l}.\n         {p. p permutes {0..<Suc l} \\<and> p i = j}) =\n    (\\<Sum>i = 0..<Suc l.\n        sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j})", "by auto"], ["proof (state)\nthis:\n  sum h\n   (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j}) =\n  (\\<Sum>i = 0..<Suc l. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  sum h\n   (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j}) =\n  (\\<Sum>i = 0..<Suc l. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "{"], ["proof (state)\nthis:\n  sum h\n   (\\<Union>i\\<in>{0..<Suc l}. {p. p permutes {0..<Suc l} \\<and> p i = j}) =\n  (\\<Sum>i = 0..<Suc l. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "assume \"i \\<in> ?N\""], ["proof (state)\nthis:\n  i \\<in> {0..<Suc l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "hence i: \"i < Suc l\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<Suc l}\n\ngoal (1 subgoal):\n 1. i < Suc l", "by auto"], ["proof (state)\nthis:\n  i < Suc l\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"sum h { p | p. p permutes ?N \\<and> p i = j} = sum h (permutation_insert i j ` Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n    sum h (permutation_insert i j ` Q)", "using permutation_fix[OF i jl]"], ["proof (prove)\nusing this:\n  {p. p permutes {0..<Suc l} \\<and> p i = j} =\n  permutation_insert i j ` {q. q permutes {0..<l}}\n\ngoal (1 subgoal):\n 1. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n    sum h (permutation_insert i j ` Q)", "unfolding Q_def"], ["proof (prove)\nusing this:\n  {p. p permutes {0..<Suc l} \\<and> p i = j} =\n  permutation_insert i j ` {q. q permutes {0..<l}}\n\ngoal (1 subgoal):\n 1. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n    sum h (permutation_insert i j ` {q. q permutes {0..<l}})", "by auto"], ["proof (state)\nthis:\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n  sum h (permutation_insert i j ` Q)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n  sum h (permutation_insert i j ` Q)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = sum (h \\<circ> permutation_insert i j) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h (permutation_insert i j ` Q) =\n    sum (h \\<circ> permutation_insert i j) Q", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h (permutation_insert i j ` {q. q permutes {0..<l}}) =\n    sum (h \\<circ> permutation_insert i j) {q. q permutes {0..<l}}", "using sum.reindex[OF permutation_insert_inj_on[OF i jl]]"], ["proof (prove)\nusing this:\n  sum ?g (permutation_insert i j ` {q. q permutes {0..<l}}) =\n  sum (?g \\<circ> permutation_insert i j) {q. q permutes {0..<l}}\n\ngoal (1 subgoal):\n 1. sum h (permutation_insert i j ` {q. q permutes {0..<l}}) =\n    sum (h \\<circ> permutation_insert i j) {q. q permutes {0..<l}}", "."], ["proof (state)\nthis:\n  sum h (permutation_insert i j ` Q) =\n  sum (h \\<circ> permutation_insert i j) Q\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  sum h (permutation_insert i j ` Q) =\n  sum (h \\<circ> permutation_insert i j) Q\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = (\\<Sum> q \\<in> Q.\n      signof (permutation_insert i j q) * prod (f (permutation_insert i j q)) ?N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (h \\<circ> permutation_insert i j) Q =\n    (\\<Sum>q\\<in>Q.\n       signof (permutation_insert i j q) *\n       prod (f (permutation_insert i j q)) {0..<Suc l})", "unfolding h_def g_def Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>p. signof p * prod (f p) {0..<Suc l}) \\<circ>\n         permutation_insert i j)\n     {q. q permutes {0..<l}} =\n    (\\<Sum>q | q permutes {0..<l}.\n       signof (permutation_insert i j q) *\n       prod (f (permutation_insert i j q)) {0..<Suc l})", "by simp"], ["proof (state)\nthis:\n  sum (h \\<circ> permutation_insert i j) Q =\n  (\\<Sum>q\\<in>Q.\n     signof (permutation_insert i j q) *\n     prod (f (permutation_insert i j q)) {0..<Suc l})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  sum (h \\<circ> permutation_insert i j) Q =\n  (\\<Sum>q\\<in>Q.\n     signof (permutation_insert i j q) *\n     prod (f (permutation_insert i j q)) {0..<Suc l})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "{"], ["proof (state)\nthis:\n  sum (h \\<circ> permutation_insert i j) Q =\n  (\\<Sum>q\\<in>Q.\n     signof (permutation_insert i j q) *\n     prod (f (permutation_insert i j q)) {0..<Suc l})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "assume \"q \\<in> Q\""], ["proof (state)\nthis:\n  q \\<in> Q\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "hence q: \"q permutes {0..<l}\""], ["proof (prove)\nusing this:\n  q \\<in> Q\n\ngoal (1 subgoal):\n 1. q permutes {0..<l}", "unfolding Q_def"], ["proof (prove)\nusing this:\n  q \\<in> {q. q permutes {0..<l}}\n\ngoal (1 subgoal):\n 1. q permutes {0..<l}", "by auto"], ["proof (state)\nthis:\n  q permutes {0..<l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "let ?p = \"permutation_insert i j q\""], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have fin: \"finite (?N - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({0..<Suc l} - {i})", "by auto"], ["proof (state)\nthis:\n  finite ({0..<Suc l} - {i})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have notin: \"i \\<notin> ?N - {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> {0..<Suc l} - {i}", "by auto"], ["proof (state)\nthis:\n  i \\<notin> {0..<Suc l} - {i}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have close: \"insert i (?N - {i}) = ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert i ({0..<Suc l} - {i}) = {0..<Suc l}", "using notin i"], ["proof (prove)\nusing this:\n  i \\<notin> {0..<Suc l} - {i}\n  i < Suc l\n\ngoal (1 subgoal):\n 1. insert i ({0..<Suc l} - {i}) = {0..<Suc l}", "by auto"], ["proof (state)\nthis:\n  insert i ({0..<Suc l} - {i}) = {0..<Suc l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"prod (f ?p) ?N = f ?p i * prod (f ?p) (?N-{i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (f (permutation_insert i j q)) {0..<Suc l} =\n    f (permutation_insert i j q) i *\n    prod (f (permutation_insert i j q)) ({0..<Suc l} - {i})", "unfolding prod.insert[OF fin notin, unfolded close]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (permutation_insert i j q) i *\n    prod (f (permutation_insert i j q)) ({0..<Suc l} - {i}) =\n    f (permutation_insert i j q) i *\n    prod (f (permutation_insert i j q)) ({0..<Suc l} - {i})", "by auto"], ["proof (state)\nthis:\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  f (permutation_insert i j q) i *\n  prod (f (permutation_insert i j q)) ({0..<Suc l} - {i})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  f (permutation_insert i j q) i *\n  prod (f (permutation_insert i j q)) ({0..<Suc l} - {i})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = A $$ (i, j) * prod (f ?p) (?N-{i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (permutation_insert i j q) i *\n    prod (f (permutation_insert i j q)) ({0..<Suc l} - {i}) =\n    A $$ (i, j) * prod (f (permutation_insert i j q)) ({0..<Suc l} - {i})", "unfolding f_def Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, permutation_insert i j q i) *\n    (\\<Prod>ia\\<in>{0..<Suc l} - {i}.\n       A $$ (ia, permutation_insert i j q ia)) =\n    A $$ (i, j) *\n    (\\<Prod>ia\\<in>{0..<Suc l} - {i}.\n       A $$ (ia, permutation_insert i j q ia))", "using permutation_insert_inserted"], ["proof (prove)\nusing this:\n  permutation_insert ?i ?j ?p ?i = ?j\n\ngoal (1 subgoal):\n 1. A $$ (i, permutation_insert i j q i) *\n    (\\<Prod>ia\\<in>{0..<Suc l} - {i}.\n       A $$ (ia, permutation_insert i j q ia)) =\n    A $$ (i, j) *\n    (\\<Prod>ia\\<in>{0..<Suc l} - {i}.\n       A $$ (ia, permutation_insert i j q ia))", "by simp"], ["proof (state)\nthis:\n  f (permutation_insert i j q) i *\n  prod (f (permutation_insert i j q)) ({0..<Suc l} - {i}) =\n  A $$ (i, j) * prod (f (permutation_insert i j q)) ({0..<Suc l} - {i})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  f (permutation_insert i j q) i *\n  prod (f (permutation_insert i j q)) ({0..<Suc l} - {i}) =\n  A $$ (i, j) * prod (f (permutation_insert i j q)) ({0..<Suc l} - {i})\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"prod (f ?p) (?N-{i}) = prod (\\<lambda>i'. A $$ (i', permutation_insert i j q i')) (?N-{i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (f (permutation_insert i j q)) ({0..<Suc l} - {i}) =\n    (\\<Prod>i'\\<in>{0..<Suc l} - {i}.\n       A $$ (i', permutation_insert i j q i'))", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia\\<in>{0..<Suc l} - {i}.\n       A $$ (ia, permutation_insert i j q ia)) =\n    (\\<Prod>i'\\<in>{0..<Suc l} - {i}.\n       A $$ (i', permutation_insert i j q i'))", ".."], ["proof (state)\nthis:\n  prod (f (permutation_insert i j q)) ({0..<Suc l} - {i}) =\n  (\\<Prod>i'\\<in>{0..<Suc l} - {i}. A $$ (i', permutation_insert i j q i'))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  prod (f (permutation_insert i j q)) ({0..<Suc l} - {i}) =\n  (\\<Prod>i'\\<in>{0..<Suc l} - {i}. A $$ (i', permutation_insert i j q i'))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = prod (\\<lambda>ij. A $$ ij) ((\\<lambda>i'. (i', permutation_insert i j q i')) ` (?N-{i}))\"\n        (is \"_ = prod _ ?part\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i'\\<in>{0..<Suc l} - {i}.\n       A $$ (i', permutation_insert i j q i')) =\n    prod (($$) A)\n     ((\\<lambda>i'. (i', permutation_insert i j q i')) `\n      ({0..<Suc l} - {i}))", "unfolding prod.reindex[OF inj_on_convol_ident] o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i'\\<in>{0..<Suc l} - {i}.\n       A $$ (i', permutation_insert i j q i')) =\n    (\\<Prod>x\\<in>{0..<Suc l} - {i}. A $$ (x, permutation_insert i j q x))", ".."], ["proof (state)\nthis:\n  (\\<Prod>i'\\<in>{0..<Suc l} - {i}.\n     A $$ (i', permutation_insert i j q i')) =\n  prod (($$) A)\n   ((\\<lambda>i'. (i', permutation_insert i j q i')) ` ({0..<Suc l} - {i}))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i'\\<in>{0..<Suc l} - {i}.\n     A $$ (i', permutation_insert i j q i')) =\n  prod (($$) A)\n   ((\\<lambda>i'. (i', permutation_insert i j q i')) ` ({0..<Suc l} - {i}))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"?part = {(i', permutation_insert i j q i') | i'. i' \\<in> ?N-{i} }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i'. (i', permutation_insert i j q i')) ` ({0..<Suc l} - {i}) =\n    {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc l} - {i}}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{0..<Suc l} - {i}.\n           y = (x, permutation_insert i j q x)} =\n    {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc l} - {i}}", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>i'. (i', permutation_insert i j q i')) ` ({0..<Suc l} - {i}) =\n  {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc l} - {i}}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  (\\<lambda>i'. (i', permutation_insert i j q i')) ` ({0..<Suc l} - {i}) =\n  {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc l} - {i}}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = {(insert_index i i'', insert_index j (q i'')) | i''. i'' < l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc l} - {i}} =\n    {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l}", "unfolding foo[OF i jl q]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l} =\n    {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l}", ".."], ["proof (state)\nthis:\n  {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc l} - {i}} =\n  {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  {(i', permutation_insert i j q i') |i'. i' \\<in> {0..<Suc l} - {i}} =\n  {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) ` {0..<l})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l} =\n    (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) ` {0..<l}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l} =\n    {y. \\<exists>x\\<in>{0..<l}.\n           y = (insert_index i x, insert_index j (q x))}", "by auto"], ["proof (state)\nthis:\n  {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l} =\n  (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) ` {0..<l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  {(insert_index i i'', insert_index j (q i'')) |i''. i'' < l} =\n  (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) ` {0..<l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"prod (\\<lambda>ij. A $$ ij)... = prod ((\\<lambda>ij. A $$ ij) \\<circ> (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))) {0..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l}) =\n    prod\n     (($$) A \\<circ>\n      (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))))\n     {0..<l}", "proof(subst prod.reindex[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n     {0..<l}\n 2. prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l}) =\n    prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l})", "have 1: \"inj (\\<lambda>i''. (i'', insert_index j (q i'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>i''. (i'', insert_index j (q i'')))", "using inj_on_convol_ident"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>x. (x, ?f x)) ?X\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>i''. (i'', insert_index j (q i'')))", "."], ["proof (state)\nthis:\n  inj (\\<lambda>i''. (i'', insert_index j (q i'')))\n\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n     {0..<l}\n 2. prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l}) =\n    prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l})", "have 2: \"inj (\\<lambda>(i'',j). (insert_index i i'', j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>(i'', j). (insert_index i i'', j))", "apply (intro injI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (case x of (i'', j) \\<Rightarrow> (insert_index i i'', j)) =\n       (case y of\n        (i'', j) \\<Rightarrow> (insert_index i i'', j)) \\<Longrightarrow>\n       x = y", "using injD[OF insert_index_inj_on[of _ UNIV]]"], ["proof (prove)\nusing this:\n  insert_index ?i1 ?x = insert_index ?i1 ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (case x of (i'', j) \\<Rightarrow> (insert_index i i'', j)) =\n       (case y of\n        (i'', j) \\<Rightarrow> (insert_index i i'', j)) \\<Longrightarrow>\n       x = y", "by auto"], ["proof (state)\nthis:\n  inj (\\<lambda>(i'', j). (insert_index i i'', j))\n\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n     {0..<l}\n 2. prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l}) =\n    prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l})", "have \"inj (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))", "using inj_compose[OF 2 1]"], ["proof (prove)\nusing this:\n  inj ((\\<lambda>(i'', j). (insert_index i i'', j)) \\<circ>\n       (\\<lambda>i''. (i'', insert_index j (q i''))))\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))", "unfolding o_def"], ["proof (prove)\nusing this:\n  inj (\\<lambda>x.\n          case (x, insert_index j (q x)) of\n          (i'', x) \\<Rightarrow> (insert_index i i'', x))\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))", "by auto"], ["proof (state)\nthis:\n  inj (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n     {0..<l}\n 2. prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l}) =\n    prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l})", "thus \"inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) {0..<l}\""], ["proof (prove)\nusing this:\n  inj (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n     {0..<l}", "using subset_inj_on"], ["proof (prove)\nusing this:\n  inj (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n  \\<lbrakk>inj_on ?f ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n     {0..<l}", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>i''. (insert_index i i'', insert_index j (q i'')))\n   {0..<l}\n\ngoal (1 subgoal):\n 1. prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l}) =\n    prod (($$) A)\n     ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n      {0..<l})", "qed auto"], ["proof (state)\nthis:\n  prod (($$) A)\n   ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n    {0..<l}) =\n  prod\n   (($$) A \\<circ>\n    (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))))\n   {0..<l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  prod (($$) A)\n   ((\\<lambda>i''. (insert_index i i'', insert_index j (q i''))) `\n    {0..<l}) =\n  prod\n   (($$) A \\<circ>\n    (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))))\n   {0..<l}\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = prod (\\<lambda>i''. A $$ (insert_index i i'', insert_index j (q i''))) {0..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod\n     (($$) A \\<circ>\n      (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))))\n     {0..<l} =\n    (\\<Prod>i'' = 0..<l. A $$ (insert_index i i'', insert_index j (q i'')))", "by auto"], ["proof (state)\nthis:\n  prod\n   (($$) A \\<circ>\n    (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))))\n   {0..<l} =\n  (\\<Prod>i'' = 0..<l. A $$ (insert_index i i'', insert_index j (q i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  prod\n   (($$) A \\<circ>\n    (\\<lambda>i''. (insert_index i i'', insert_index j (q i''))))\n   {0..<l} =\n  (\\<Prod>i'' = 0..<l. A $$ (insert_index i i'', insert_index j (q i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = prod (\\<lambda>i''. mat_delete A i j $$ (i'', q i'')) {0..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i'' = 0..<l.\n        A $$ (insert_index i i'', insert_index j (q i''))) =\n    (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))", "proof (rule prod.cong[OF refl], unfold atLeastLessThan_iff, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < l\\<rbrakk>\n       \\<Longrightarrow> A $$ (insert_index i x, insert_index j (q x)) =\n                         mat_delete A i j $$ (x, q x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < l\\<rbrakk>\n       \\<Longrightarrow> A $$ (insert_index i x, insert_index j (q x)) =\n                         mat_delete A i j $$ (x, q x)", "assume x: \"x < l\""], ["proof (state)\nthis:\n  x < l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < l\\<rbrakk>\n       \\<Longrightarrow> A $$ (insert_index i x, insert_index j (q x)) =\n                         mat_delete A i j $$ (x, q x)", "show \"A $$ (insert_index i x, insert_index j (q x)) = mat_delete A i j $$ (x, q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (insert_index i x, insert_index j (q x)) =\n    mat_delete A i j $$ (x, q x)", "apply(rule mat_delete_index[OF A i jl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < l\n 2. q x < l", "using q x"], ["proof (prove)\nusing this:\n  q permutes {0..<l}\n  x < l\n\ngoal (2 subgoals):\n 1. x < l\n 2. q x < l", "by auto"], ["proof (state)\nthis:\n  A $$ (insert_index i x, insert_index j (q x)) =\n  mat_delete A i j $$ (x, q x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i'' = 0..<l. A $$ (insert_index i i'', insert_index j (q i''))) =\n  (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "finally"], ["proof (chain)\npicking this:\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))", "have \"prod (f ?p) ?N =\n        A $$ (i, j) * (\\<Prod>i'' = 0..< l. mat_delete A i j $$ (i'', q i''))\""], ["proof (prove)\nusing this:\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))\n\ngoal (1 subgoal):\n 1. prod (f (permutation_insert i j q)) {0..<Suc l} =\n    A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))", "by auto"], ["proof (state)\nthis:\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "hence \"signof ?p * prod (f ?p) ?N  = (-1::'a)^(i+j) * signof q * ...\""], ["proof (prove)\nusing this:\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))\n\ngoal (1 subgoal):\n 1. signof (permutation_insert i j q) *\n    prod (f (permutation_insert i j q)) {0..<Suc l} =\n    (- (1::'a)) ^ (i + j) * signof q *\n    (A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))", "unfolding signof_permutation_insert[OF q i jl]"], ["proof (prove)\nusing this:\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))\n\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (i + j) * signof q *\n    prod (f (permutation_insert i j q)) {0..<Suc l} =\n    (- (1::'a)) ^ (i + j) * signof q *\n    (A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))", "by auto"], ["proof (state)\nthis:\n  signof (permutation_insert i j q) *\n  prod (f (permutation_insert i j q)) {0..<Suc l} =\n  (- (1::'a)) ^ (i + j) * signof q *\n  (A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> Q \\<Longrightarrow>\n  signof (permutation_insert i j ?q2) *\n  prod (f (permutation_insert i j ?q2)) {0..<Suc l} =\n  (- (1::'a)) ^ (i + j) * signof ?q2 *\n  (A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', ?q2 i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "hence \"... = (\\<Sum> q \\<in> Q. (-1)^(i+j) * signof q *\n      A $$ (i, j) * (\\<Prod>i'' = 0 ..< l. mat_delete A i j $$ (i'', q i'')))\""], ["proof (prove)\nusing this:\n  ?q2 \\<in> Q \\<Longrightarrow>\n  signof (permutation_insert i j ?q2) *\n  prod (f (permutation_insert i j ?q2)) {0..<Suc l} =\n  (- (1::'a)) ^ (i + j) * signof ?q2 *\n  (A $$ (i, j) * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', ?q2 i'')))\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>Q.\n       signof (permutation_insert i j q) *\n       prod (f (permutation_insert i j q)) {0..<Suc l}) =\n    (\\<Sum>q\\<in>Q.\n       (- (1::'a)) ^ (i + j) * signof q * A $$ (i, j) *\n       (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))", "by(intro sum.cong[OF refl],auto)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>Q.\n     signof (permutation_insert i j q) *\n     prod (f (permutation_insert i j q)) {0..<Suc l}) =\n  (\\<Sum>q\\<in>Q.\n     (- (1::'a)) ^ (i + j) * signof q * A $$ (i, j) *\n     (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>Q.\n     signof (permutation_insert i j q) *\n     prod (f (permutation_insert i j q)) {0..<Suc l}) =\n  (\\<Sum>q\\<in>Q.\n     (- (1::'a)) ^ (i + j) * signof q * A $$ (i, j) *\n     (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = ( \\<Sum> q \\<in> Q. A $$ (i, j) * (-1)^(i+j) *\n       ( signof q * (\\<Prod>i'' = 0..< l. mat_delete A i j $$ (i'', q i'')) ) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>Q.\n       (- (1::'a)) ^ (i + j) * signof q * A $$ (i, j) *\n       (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))) =\n    (\\<Sum>q\\<in>Q.\n       A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n       (signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))))", "by (intro sum.cong[OF refl],auto)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>Q.\n     (- (1::'a)) ^ (i + j) * signof q * A $$ (i, j) *\n     (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))) =\n  (\\<Sum>q\\<in>Q.\n     A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n     (signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>Q.\n     (- (1::'a)) ^ (i + j) * signof q * A $$ (i, j) *\n     (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))) =\n  (\\<Sum>q\\<in>Q.\n     A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n     (signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = A $$ (i, j) * (-1)^(i+j) *\n      ( \\<Sum> q \\<in> Q. signof q * (\\<Prod>i''= 0 ..< l. mat_delete A i j $$ (i'', q i'')) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>Q.\n       A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n       (signof q *\n        (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))) =\n    A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n    (\\<Sum>q\\<in>Q.\n       signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))", "unfolding sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>Q.\n       A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n       (signof q *\n        (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))) =\n    (\\<Sum>n\\<in>Q.\n       A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n       (signof n * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', n i''))))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>Q.\n     A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n     (signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))) =\n  A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n  (\\<Sum>q\\<in>Q.\n     signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>Q.\n     A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n     (signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))) =\n  A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n  (\\<Sum>q\\<in>Q.\n     signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i'')))\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "have \"... = (A $$ (i, j) * (-1)^(i+j) * det (mat_delete A i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n    (\\<Sum>q\\<in>Q.\n       signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))) =\n    A $$ (i, j) * (- (1::'a)) ^ (i + j) * det (mat_delete A i j)", "unfolding det_def'[OF mat_delete_carrier[OF A]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n    (\\<Sum>q\\<in>Q.\n       signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))) =\n    A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n    (\\<Sum>p | p permutes {0..<Suc l - 1}.\n       signof p *\n       (\\<Prod>ia = 0..<Suc l - 1. mat_delete A i j $$ (ia, p ia)))", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n    (\\<Sum>q | q permutes {0..<l}.\n       signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))) =\n    A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n    (\\<Sum>p | p permutes {0..<Suc l - 1}.\n       signof p *\n       (\\<Prod>ia = 0..<Suc l - 1. mat_delete A i j $$ (ia, p ia)))", "by auto"], ["proof (state)\nthis:\n  A $$ (i, j) * (- (1::'a)) ^ (i + j) *\n  (\\<Sum>q\\<in>Q.\n     signof q * (\\<Prod>i'' = 0..<l. mat_delete A i j $$ (i'', q i''))) =\n  A $$ (i, j) * (- (1::'a)) ^ (i + j) * det (mat_delete A i j)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "finally"], ["proof (chain)\npicking this:\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n  A $$ (i, j) * (- (1::'a)) ^ (i + j) * det (mat_delete A i j)", "have \"sum h {p | p. p permutes ?N \\<and> p i = j} = A $$ (i, j) * cofactor A i j\""], ["proof (prove)\nusing this:\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n  A $$ (i, j) * (- (1::'a)) ^ (i + j) * det (mat_delete A i j)\n\ngoal (1 subgoal):\n 1. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n    A $$ (i, j) * cofactor A i j", "unfolding cofactor_def"], ["proof (prove)\nusing this:\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n  A $$ (i, j) * (- (1::'a)) ^ (i + j) * det (mat_delete A i j)\n\ngoal (1 subgoal):\n 1. sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n    A $$ (i, j) * ((- (1::'a)) ^ (i + j) * det (mat_delete A i j))", "by auto"], ["proof (state)\nthis:\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j} =\n  A $$ (i, j) * cofactor A i j\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> {0..<Suc l} \\<Longrightarrow>\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p ?i2 = j} =\n  A $$ (?i2, j) * cofactor A ?i2 j\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "hence \"... = (\\<Sum>i\\<in>?N. A $$ (i,j) * cofactor A i j)\""], ["proof (prove)\nusing this:\n  ?i2 \\<in> {0..<Suc l} \\<Longrightarrow>\n  sum h {p |p. p permutes {0..<Suc l} \\<and> p ?i2 = j} =\n  A $$ (?i2, j) * cofactor A ?i2 j\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<Suc l.\n        sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j}) =\n    (\\<Sum>i = 0..<Suc l. A $$ (i, j) * cofactor A i j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<Suc l.\n      sum h {p |p. p permutes {0..<Suc l} \\<and> p i = j}) =\n  (\\<Sum>i = 0..<Suc l. A $$ (i, j) * cofactor A i j)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "finally"], ["proof (chain)\npicking this:\n  det A = (\\<Sum>i = 0..<Suc l. A $$ (i, j) * cofactor A i j)", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = (\\<Sum>i = 0..<Suc l. A $$ (i, j) * cofactor A i j)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "unfolding atLeast0LessThan"], ["proof (prove)\nusing this:\n  det A = (\\<Sum>i<Suc l. A $$ (i, j) * cofactor A i j)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "using A j"], ["proof (prove)\nusing this:\n  det A = (\\<Sum>i<Suc l. A $$ (i, j) * cofactor A i j)\n  A \\<in> carrier_mat (Suc l) (Suc l)\n  j < n\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "unfolding l_def"], ["proof (prove)\nusing this:\n  det A = (\\<Sum>i<Suc (n - 1). A $$ (i, j) * cofactor A i j)\n  A \\<in> carrier_mat (Suc (n - 1)) (Suc (n - 1))\n  j < n\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)", "by auto"], ["proof (state)\nthis:\n  det A = (\\<Sum>i<n. A $$ (i, j) * cofactor A i j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma laplace_expansion_row:\n  assumes A: \"(A :: 'a :: comm_ring_1 mat) \\<in> carrier_mat n n\"\n      and i: \"i < n\"\n    shows \"det A = (\\<Sum>j<n. A $$ (i,j) * cofactor A i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "have \"det A = det (A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", "using det_transpose[OF A]"], ["proof (prove)\nusing this:\n  det A\\<^sup>T = det A\n\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "have \"\\<dots> = (\\<Sum>j<n. A\\<^sup>T $$ (j, i) * cofactor A\\<^sup>T j i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A\\<^sup>T =\n    (\\<Sum>j<n. A\\<^sup>T $$ (j, i) * cofactor A\\<^sup>T j i)", "by (rule laplace_expansion_column[OF _ i], insert A, auto)"], ["proof (state)\nthis:\n  det A\\<^sup>T = (\\<Sum>j<n. A\\<^sup>T $$ (j, i) * cofactor A\\<^sup>T j i)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "also"], ["proof (state)\nthis:\n  det A\\<^sup>T = (\\<Sum>j<n. A\\<^sup>T $$ (j, i) * cofactor A\\<^sup>T j i)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "have \"\\<dots> = (\\<Sum>j<n. A $$ (i,j) * cofactor A i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<n. A\\<^sup>T $$ (j, i) * cofactor A\\<^sup>T j i) =\n    (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "unfolding cofactor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<n.\n        A\\<^sup>T $$ (j, i) *\n        ((- (1::'a)) ^ (j + i) * det (mat_delete A\\<^sup>T j i))) =\n    (\\<Sum>j<n.\n        A $$ (i, j) * ((- (1::'a)) ^ (i + j) * det (mat_delete A i j)))", "proof (rule sum.cong[OF refl], rule arg_cong2[of _ _ _ _ \"\\<lambda> x y. x * y\"], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow> A\\<^sup>T $$ (x, i) = A $$ (i, x)\n 2. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "case (1 j)"], ["proof (state)\nthis:\n  j \\<in> {..<n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow> A\\<^sup>T $$ (x, i) = A $$ (i, x)\n 2. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "thus ?case"], ["proof (prove)\nusing this:\n  j \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. A\\<^sup>T $$ (j, i) = A $$ (i, j)", "using A i"], ["proof (prove)\nusing this:\n  j \\<in> {..<n}\n  A \\<in> carrier_mat n n\n  i < n\n\ngoal (1 subgoal):\n 1. A\\<^sup>T $$ (j, i) = A $$ (i, j)", "by auto"], ["proof (state)\nthis:\n  A\\<^sup>T $$ (j, i) = A $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "case (2 j)"], ["proof (state)\nthis:\n  j \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "have \"det (mat_delete A\\<^sup>T j i) = det ((mat_delete A\\<^sup>T j i)\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_delete A\\<^sup>T j i) = det (mat_delete A\\<^sup>T j i)\\<^sup>T", "by (subst det_transpose, insert A, auto simp: mat_delete_def)"], ["proof (state)\nthis:\n  det (mat_delete A\\<^sup>T j i) = det (mat_delete A\\<^sup>T j i)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "also"], ["proof (state)\nthis:\n  det (mat_delete A\\<^sup>T j i) = det (mat_delete A\\<^sup>T j i)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "have \"(mat_delete A\\<^sup>T j i)\\<^sup>T = mat_delete A i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_delete A\\<^sup>T j i)\\<^sup>T = mat_delete A i j", "unfolding mat_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (dim_row A\\<^sup>T - 1) (dim_col A\\<^sup>T - 1)\n      (\\<lambda>(i', j').\n          A\\<^sup>T $$\n          (if i' < j then i' else Suc i',\n           if j' < i then j' else Suc j')))\\<^sup>T =\n    mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j'))", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (mat (dim_row A\\<^sup>T - 1) (dim_col A\\<^sup>T - 1)\n      (\\<lambda>(i', j').\n          A\\<^sup>T $$\n          (if i' < j then i' else Suc i',\n           if j' < i then j' else Suc j')))\\<^sup>T =\n    mat (dim_row A - 1) (dim_col A - 1)\n     (\\<lambda>(i', j').\n         A $$\n         (if i' < i then i' else Suc i', if j' < j then j' else Suc j'))", "by auto"], ["proof (state)\nthis:\n  (mat_delete A\\<^sup>T j i)\\<^sup>T = mat_delete A i j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       (- (1::'a)) ^ (x + i) * det (mat_delete A\\<^sup>T x i) =\n       (- (1::'a)) ^ (i + x) * det (mat_delete A i x)", "finally"], ["proof (chain)\npicking this:\n  det (mat_delete A\\<^sup>T j i) = det (mat_delete A i j)", "show ?case"], ["proof (prove)\nusing this:\n  det (mat_delete A\\<^sup>T j i) = det (mat_delete A i j)\n\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ (j + i) * det (mat_delete A\\<^sup>T j i) =\n    (- (1::'a)) ^ (i + j) * det (mat_delete A i j)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (- (1::'a)) ^ (j + i) * det (mat_delete A\\<^sup>T j i) =\n  (- (1::'a)) ^ (i + j) * det (mat_delete A i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j<n. A\\<^sup>T $$ (j, i) * cofactor A\\<^sup>T j i) =\n  (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "finally"], ["proof (chain)\npicking this:\n  det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)\n\ngoal (1 subgoal):\n 1. det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)", "."], ["proof (state)\nthis:\n  det A = (\\<Sum>j<n. A $$ (i, j) * cofactor A i j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_det_le: assumes \"\\<And> i j. i < n \\<Longrightarrow> j < n \\<Longrightarrow> degree (A $$ (i,j)) \\<le> k\"\n  and A: \"A \\<in> carrier_mat n n\" \nshows \"degree (det A) \\<le> k * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "assume p: \"p permutes {0..<n}\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "have \"(\\<Sum>x = 0..<n. degree (A $$ (x, p x))) \\<le> (\\<Sum>x = 0..<n. k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<n. degree (A $$ (x, p x))) \\<le> (\\<Sum>x = 0..<n. k)", "by (rule sum_mono[OF assms(1)], insert p, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<n. degree (A $$ (x, p x))) \\<le> (\\<Sum>x = 0..<n. k)\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<n. degree (A $$ (x, p x))) \\<le> (\\<Sum>x = 0..<n. k)\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "have \"\\<dots> = k * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<n. k) = k * n", "unfolding sum_constant"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (card {0..<n}) * k = k * n", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<n. k) = k * n\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<n. k) = k * n\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "note calculation"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<n. degree (A $$ (x, p x))) \\<le> k * n\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "}"], ["proof (state)\nthis:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  (\\<Sum>x = 0..<n. degree (A $$ (x, ?p2 x))) \\<le> k * n\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "note * = this"], ["proof (state)\nthis:\n  ?p2 permutes {0..<n} \\<Longrightarrow>\n  (\\<Sum>x = 0..<n. degree (A $$ (x, ?p2 x))) \\<le> k * n\n\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (det A) \\<le> k * n", "unfolding det_def'[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Sum>p | p permutes {0..<n}.\n        signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))\n    \\<le> k * n", "by (rule degree_sum_le, insert *, auto simp: finite_permutations signof_def \n      intro!: order.trans[OF degree_prod_sum_le])"], ["proof (state)\nthis:\n  degree (det A) \\<le> k * n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_triangular_imp_det_eq_0_iff:\n  fixes A :: \"'a :: idom mat\"\n  assumes \"A \\<in> carrier_mat n n\" and \"upper_triangular A\"\n  shows \"det A = 0 \\<longleftrightarrow> 0 \\<in> set (diag_mat A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (det A = (0::'a)) = ((0::'a) \\<in> set (diag_mat A))", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  upper_triangular A\n\ngoal (1 subgoal):\n 1. (det A = (0::'a)) = ((0::'a) \\<in> set (diag_mat A))", "by (auto simp: det_upper_triangular)"], ["", "lemma det_identical_columns:\n  assumes A: \"A \\<in> carrier_mat n n\"  \n    and ij: \"i \\<noteq> j\"\n    and i: \"i < n\" and j: \"j < n\"\n    and r: \"col A i = col A j\"\n  shows \"det A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"det A = det A\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", "using det_transpose[OF A]"], ["proof (prove)\nusing this:\n  det A\\<^sup>T = det A\n\ngoal (1 subgoal):\n 1. det A = det A\\<^sup>T", ".."], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "also"], ["proof (state)\nthis:\n  det A = det A\\<^sup>T\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A\\<^sup>T = (0::'a)", "proof (rule det_identical_rows[of _ n i j])"], ["proof (state)\ngoal (5 subgoals):\n 1. A\\<^sup>T \\<in> carrier_mat n n\n 2. i \\<noteq> j\n 3. i < n\n 4. j < n\n 5. row A\\<^sup>T i = row A\\<^sup>T j", "show \"row (transpose_mat A) i = row (transpose_mat A) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A\\<^sup>T i = row A\\<^sup>T j", "using A i j r"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  i < n\n  j < n\n  col A i = col A j\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T i = row A\\<^sup>T j", "by auto"], ["proof (state)\nthis:\n  row A\\<^sup>T i = row A\\<^sup>T j\n\ngoal (4 subgoals):\n 1. A\\<^sup>T \\<in> carrier_mat n n\n 2. i \\<noteq> j\n 3. i < n\n 4. j < n", "qed (auto simp add: assms)"], ["proof (state)\nthis:\n  det A\\<^sup>T = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  det A = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det A = (0::'a)\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "."], ["proof (state)\nthis:\n  det A = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition adj_mat :: \"'a :: comm_ring_1 mat \\<Rightarrow> 'a mat\" where\n  \"adj_mat A = mat (dim_row A) (dim_col A) (\\<lambda> (i,j). cofactor A j i)\""], ["", "lemma adj_mat: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"adj_mat A \\<in> carrier_mat n n\"\n  \"A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\" \n  \"adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_mat A \\<in> carrier_mat n n &&&\n    A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n &&&\n    adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. adj_mat A \\<in> carrier_mat n n\n 2. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 3. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dims: \"dim_row A = n\" \"dim_col A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n &&& dim_col A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n\ngoal (3 subgoals):\n 1. adj_mat A \\<in> carrier_mat n n\n 2. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 3. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "show aA: \"adj_mat A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_mat A \\<in> carrier_mat n n", "unfolding adj_mat_def dims"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i, j). cofactor A j i) \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  adj_mat A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "{"], ["proof (state)\nthis:\n  adj_mat A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "assume ij: \"i < n\" \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "define B where \"B = mat n n (\\<lambda> (i',j'). if i' = j then A $$ (i,j') else A $$ (i',j'))\""], ["proof (state)\nthis:\n  B =\n  mat n n\n   (\\<lambda>(i', j'). if i' = j then A $$ (i, j') else A $$ (i', j'))\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"(A * adj_mat A) $$ (i,j) = (\\<Sum> k < n. A $$ (i,k) * cofactor A j k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * adj_mat A) $$ (i, j) = (\\<Sum>k<n. A $$ (i, k) * cofactor A j k)", "unfolding times_mat_def scalar_prod_def adj_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row A)\n     (dim_col\n       (mat (dim_row A) (dim_col A) (\\<lambda>(i, j). cofactor A j i)))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<dim_vec\n                         (col (mat (dim_row A) (dim_col A)\n                                (\\<lambda>(i, j). cofactor A j i))\n                           j).\n            row A i $ ia *\n            col (mat (dim_row A) (dim_col A)\n                  (\\<lambda>(i, j). cofactor A j i))\n             j $\n            ia) $$\n    (i, j) =\n    (\\<Sum>k<n. A $$ (i, k) * cofactor A j k)", "using ij A"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat (dim_row A)\n     (dim_col\n       (mat (dim_row A) (dim_col A) (\\<lambda>(i, j). cofactor A j i)))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<dim_vec\n                         (col (mat (dim_row A) (dim_col A)\n                                (\\<lambda>(i, j). cofactor A j i))\n                           j).\n            row A i $ ia *\n            col (mat (dim_row A) (dim_col A)\n                  (\\<lambda>(i, j). cofactor A j i))\n             j $\n            ia) $$\n    (i, j) =\n    (\\<Sum>k<n. A $$ (i, k) * cofactor A j k)", "by (auto intro: sum.cong)"], ["proof (state)\nthis:\n  (A * adj_mat A) $$ (i, j) = (\\<Sum>k<n. A $$ (i, k) * cofactor A j k)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (A * adj_mat A) $$ (i, j) = (\\<Sum>k<n. A $$ (i, k) * cofactor A j k)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (\\<Sum> k < n. A $$ (i,k) * (-1)^(j + k) * det (mat_delete A j k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. A $$ (i, k) * cofactor A j k) =\n    (\\<Sum>k<n.\n        A $$ (i, k) * (- (1::'a)) ^ (j + k) * det (mat_delete A j k))", "unfolding cofactor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        A $$ (i, k) * ((- (1::'a)) ^ (j + k) * det (mat_delete A j k))) =\n    (\\<Sum>k<n.\n        A $$ (i, k) * (- (1::'a)) ^ (j + k) * det (mat_delete A j k))", "by (auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>k<n. A $$ (i, k) * cofactor A j k) =\n  (\\<Sum>k<n. A $$ (i, k) * (- (1::'a)) ^ (j + k) * det (mat_delete A j k))\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. A $$ (i, k) * cofactor A j k) =\n  (\\<Sum>k<n. A $$ (i, k) * (- (1::'a)) ^ (j + k) * det (mat_delete A j k))\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (\\<Sum> k < n. B $$ (j,k) * (-1)^(j + k) * det (mat_delete B j k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        A $$ (i, k) * (- (1::'a)) ^ (j + k) * det (mat_delete A j k)) =\n    (\\<Sum>k<n.\n        B $$ (j, k) * (- (1::'a)) ^ (j + k) * det (mat_delete B j k))", "by (rule sum.cong[OF refl], intro arg_cong2[of _ _ _ _ \"\\<lambda> x y. y * _ * det x\"], insert A ij,\n        auto simp: B_def mat_delete_def)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      A $$ (i, k) * (- (1::'a)) ^ (j + k) * det (mat_delete A j k)) =\n  (\\<Sum>k<n. B $$ (j, k) * (- (1::'a)) ^ (j + k) * det (mat_delete B j k))\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      A $$ (i, k) * (- (1::'a)) ^ (j + k) * det (mat_delete A j k)) =\n  (\\<Sum>k<n. B $$ (j, k) * (- (1::'a)) ^ (j + k) * det (mat_delete B j k))\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (\\<Sum> k < n. B $$ (j,k) * cofactor B j k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        B $$ (j, k) * (- (1::'a)) ^ (j + k) * det (mat_delete B j k)) =\n    (\\<Sum>k<n. B $$ (j, k) * cofactor B j k)", "unfolding cofactor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        B $$ (j, k) * (- (1::'a)) ^ (j + k) * det (mat_delete B j k)) =\n    (\\<Sum>k<n.\n        B $$ (j, k) * ((- (1::'a)) ^ (j + k) * det (mat_delete B j k)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      B $$ (j, k) * (- (1::'a)) ^ (j + k) * det (mat_delete B j k)) =\n  (\\<Sum>k<n. B $$ (j, k) * cofactor B j k)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      B $$ (j, k) * (- (1::'a)) ^ (j + k) * det (mat_delete B j k)) =\n  (\\<Sum>k<n. B $$ (j, k) * cofactor B j k)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. B $$ (j, k) * cofactor B j k) = det B", "by (rule laplace_expansion_row[symmetric], insert ij, auto simp: B_def)"], ["proof (state)\nthis:\n  (\\<Sum>k<n. B $$ (j, k) * cofactor B j k) = det B\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. B $$ (j, k) * cofactor B j k) = det B\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (if i = j then det A else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det B = (if i = j then det A else (0::'a))", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> det B = (if i = j then det A else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> det B = (if i = j then det A else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "hence \"B = A\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. B = A", "using A"], ["proof (prove)\nusing this:\n  i = j\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B = A", "by (auto simp add: B_def)"], ["proof (state)\nthis:\n  B = A\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> det B = (if i = j then det A else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "with True"], ["proof (chain)\npicking this:\n  i = j\n  B = A", "show ?thesis"], ["proof (prove)\nusing this:\n  i = j\n  B = A\n\ngoal (1 subgoal):\n 1. det B = (if i = j then det A else (0::'a))", "by simp"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "have \"det B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det B = (0::'a)", "by (rule Determinant.det_identical_rows[OF _ False ij], insert A ij, auto simp: B_def)"], ["proof (state)\nthis:\n  det B = (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "with False"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  det B = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  det B = (0::'a)\n\ngoal (1 subgoal):\n 1. det B = (if i = j then det A else (0::'a))", "by simp"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = j then det A else (0::'a)) =\n    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "using ij"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. (if i = j then det A else (0::'a)) =\n    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "by auto"], ["proof (state)\nthis:\n  (if i = j then det A else (0::'a)) =\n  (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  (A * adj_mat A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "have \"(A * adj_mat A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\""], ["proof (prove)\nusing this:\n  (A * adj_mat A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\n\ngoal (1 subgoal):\n 1. (A * adj_mat A) $$ (i, j) =\n    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "."], ["proof (state)\nthis:\n  (A * adj_mat A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (A * adj_mat A) $$ (?i2, ?j2) =\n                    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (?i2, ?j2)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (A * adj_mat A) $$ (?i2, ?j2) =\n                    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (?i2, ?j2)\n\ngoal (2 subgoals):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n 2. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "show \"A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "by (rule eq_matI[OF main], insert A aA, auto)"], ["proof (state)\nthis:\n  A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "(* now the completely symmetric version *)"], ["proof (state)\nthis:\n  A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "{"], ["proof (state)\nthis:\n  A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "assume ij: \"i < n\" \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "define B where \"B = mat n n (\\<lambda> (i',j'). if j' = i then A $$ (i',j) else A $$ (i',j'))\""], ["proof (state)\nthis:\n  B =\n  mat n n\n   (\\<lambda>(i', j'). if j' = i then A $$ (i', j) else A $$ (i', j'))\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"(adj_mat A * A) $$ (i,j) = (\\<Sum> k < n. A $$ (k,j) * cofactor A k i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (adj_mat A * A) $$ (i, j) = (\\<Sum>k<n. A $$ (k, j) * cofactor A k i)", "unfolding times_mat_def scalar_prod_def adj_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row\n          (mat (dim_row A) (dim_col A) (\\<lambda>(i, j). cofactor A j i)))\n     (dim_col A)\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<dim_vec (col A j).\n            row (mat (dim_row A) (dim_col A)\n                  (\\<lambda>(i, j). cofactor A j i))\n             i $\n            ia *\n            col A j $ ia) $$\n    (i, j) =\n    (\\<Sum>k<n. A $$ (k, j) * cofactor A k i)", "using ij A"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat (dim_row\n          (mat (dim_row A) (dim_col A) (\\<lambda>(i, j). cofactor A j i)))\n     (dim_col A)\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<dim_vec (col A j).\n            row (mat (dim_row A) (dim_col A)\n                  (\\<lambda>(i, j). cofactor A j i))\n             i $\n            ia *\n            col A j $ ia) $$\n    (i, j) =\n    (\\<Sum>k<n. A $$ (k, j) * cofactor A k i)", "by (auto intro: sum.cong)"], ["proof (state)\nthis:\n  (adj_mat A * A) $$ (i, j) = (\\<Sum>k<n. A $$ (k, j) * cofactor A k i)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (adj_mat A * A) $$ (i, j) = (\\<Sum>k<n. A $$ (k, j) * cofactor A k i)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (\\<Sum> k < n. A $$ (k,j) * (-1)^(k + i) * det (mat_delete A k i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. A $$ (k, j) * cofactor A k i) =\n    (\\<Sum>k<n.\n        A $$ (k, j) * (- (1::'a)) ^ (k + i) * det (mat_delete A k i))", "unfolding cofactor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        A $$ (k, j) * ((- (1::'a)) ^ (k + i) * det (mat_delete A k i))) =\n    (\\<Sum>k<n.\n        A $$ (k, j) * (- (1::'a)) ^ (k + i) * det (mat_delete A k i))", "by (auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>k<n. A $$ (k, j) * cofactor A k i) =\n  (\\<Sum>k<n. A $$ (k, j) * (- (1::'a)) ^ (k + i) * det (mat_delete A k i))\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. A $$ (k, j) * cofactor A k i) =\n  (\\<Sum>k<n. A $$ (k, j) * (- (1::'a)) ^ (k + i) * det (mat_delete A k i))\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (\\<Sum> k < n. B $$ (k,i) * (-1)^(k + i) * det (mat_delete B k i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        A $$ (k, j) * (- (1::'a)) ^ (k + i) * det (mat_delete A k i)) =\n    (\\<Sum>k<n.\n        B $$ (k, i) * (- (1::'a)) ^ (k + i) * det (mat_delete B k i))", "by (rule sum.cong[OF refl], intro arg_cong2[of _ _ _ _ \"\\<lambda> x y. y * _ * det x\"], insert A ij,\n        auto simp: B_def mat_delete_def)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      A $$ (k, j) * (- (1::'a)) ^ (k + i) * det (mat_delete A k i)) =\n  (\\<Sum>k<n. B $$ (k, i) * (- (1::'a)) ^ (k + i) * det (mat_delete B k i))\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      A $$ (k, j) * (- (1::'a)) ^ (k + i) * det (mat_delete A k i)) =\n  (\\<Sum>k<n. B $$ (k, i) * (- (1::'a)) ^ (k + i) * det (mat_delete B k i))\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (\\<Sum> k < n. B $$ (k,i) * cofactor B k i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        B $$ (k, i) * (- (1::'a)) ^ (k + i) * det (mat_delete B k i)) =\n    (\\<Sum>k<n. B $$ (k, i) * cofactor B k i)", "unfolding cofactor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        B $$ (k, i) * (- (1::'a)) ^ (k + i) * det (mat_delete B k i)) =\n    (\\<Sum>k<n.\n        B $$ (k, i) * ((- (1::'a)) ^ (k + i) * det (mat_delete B k i)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      B $$ (k, i) * (- (1::'a)) ^ (k + i) * det (mat_delete B k i)) =\n  (\\<Sum>k<n. B $$ (k, i) * cofactor B k i)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      B $$ (k, i) * (- (1::'a)) ^ (k + i) * det (mat_delete B k i)) =\n  (\\<Sum>k<n. B $$ (k, i) * cofactor B k i)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. B $$ (k, i) * cofactor B k i) = det B", "by (rule laplace_expansion_column[symmetric], insert ij, auto simp: B_def)"], ["proof (state)\nthis:\n  (\\<Sum>k<n. B $$ (k, i) * cofactor B k i) = det B\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. B $$ (k, i) * cofactor B k i) = det B\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (if i = j then det A else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det B = (if i = j then det A else (0::'a))", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> det B = (if i = j then det A else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> det B = (if i = j then det A else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "hence \"B = A\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. B = A", "using A"], ["proof (prove)\nusing this:\n  i = j\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B = A", "by (auto simp add: B_def)"], ["proof (state)\nthis:\n  B = A\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> det B = (if i = j then det A else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "with True"], ["proof (chain)\npicking this:\n  i = j\n  B = A", "show ?thesis"], ["proof (prove)\nusing this:\n  i = j\n  B = A\n\ngoal (1 subgoal):\n 1. det B = (if i = j then det A else (0::'a))", "by simp"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "have \"det B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det B = (0::'a)", "by (rule Determinant.det_identical_columns[OF _ False ij], insert A ij, auto simp: B_def)"], ["proof (state)\nthis:\n  det B = (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    det B = (if i = j then det A else (0::'a))", "with False"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  det B = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  det B = (0::'a)\n\ngoal (1 subgoal):\n 1. det B = (if i = j then det A else (0::'a))", "by simp"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  det B = (if i = j then det A else (0::'a))\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "have \"\\<dots> = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = j then det A else (0::'a)) =\n    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "using ij"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. (if i = j then det A else (0::'a)) =\n    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "by auto"], ["proof (state)\nthis:\n  (if i = j then det A else (0::'a)) =\n  (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  (adj_mat A * A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "have \"(adj_mat A * A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\""], ["proof (prove)\nusing this:\n  (adj_mat A * A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\n\ngoal (1 subgoal):\n 1. (adj_mat A * A) $$ (i, j) =\n    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)", "."], ["proof (state)\nthis:\n  (adj_mat A * A) $$ (i, j) = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (i, j)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adj_mat A * A) $$ (?i2, ?j2) =\n                    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (?i2, ?j2)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adj_mat A * A) $$ (?i2, ?j2) =\n                    (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) $$ (?i2, ?j2)\n\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "show \"adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n", "by (rule eq_matI[OF main], insert A aA, auto)"], ["proof (state)\nthis:\n  adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"replace_col A b k = mat (dim_row A) (dim_col A) (\\<lambda> (i,j). if j = k then b $ i else A $$ (i,j))\""], ["", "lemma cramer_lemma_mat:  \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and x: \"x \\<in> carrier_vec n\" \n  and k: \"k < n\" \nshows \"det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "define b where \"b = A *\\<^sub>v x\""], ["proof (state)\nthis:\n  b = A *\\<^sub>v x\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have b: \"b \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> carrier_vec n", "using A x"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. b \\<in> carrier_vec n", "unfolding b_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  b \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "let ?Ab = \"replace_col A b k\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have Ab: \"?Ab \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_col A b k \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. replace_col A b k \\<in> carrier_mat n n", "by (auto simp: replace_col_def)"], ["proof (state)\nthis:\n  replace_col A b k \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have \"x $ k * det A = (det A \\<cdot>\\<^sub>v x) $ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ k * det A = (det A \\<cdot>\\<^sub>v x) $ k", "using A k x"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  k < n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x $ k * det A = (det A \\<cdot>\\<^sub>v x) $ k", "by auto"], ["proof (state)\nthis:\n  x $ k * det A = (det A \\<cdot>\\<^sub>v x) $ k\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "also"], ["proof (state)\nthis:\n  x $ k * det A = (det A \\<cdot>\\<^sub>v x) $ k\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have \"det A \\<cdot>\\<^sub>v x = det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<cdot>\\<^sub>v x =\n    det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. det A \\<cdot>\\<^sub>v x =\n    det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x)", "by auto"], ["proof (state)\nthis:\n  det A \\<cdot>\\<^sub>v x = det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x)\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "also"], ["proof (state)\nthis:\n  det A \\<cdot>\\<^sub>v x = det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x)\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have \"\\<dots> = (det A \\<cdot>\\<^sub>m 1\\<^sub>m n) *\\<^sub>v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x) =\n    det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x", "using A x"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x) =\n    det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x", "by auto"], ["proof (state)\nthis:\n  det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x) =\n  det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "also"], ["proof (state)\nthis:\n  det A \\<cdot>\\<^sub>v (1\\<^sub>m n *\\<^sub>v x) =\n  det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have \"\\<dots> = (adj_mat A * A) *\\<^sub>v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x =\n    adj_mat A * A *\\<^sub>v x", "using adj_mat[OF A]"], ["proof (prove)\nusing this:\n  adj_mat A \\<in> carrier_mat n n\n  A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n  adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x =\n    adj_mat A * A *\\<^sub>v x", "by simp"], ["proof (state)\nthis:\n  det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x = adj_mat A * A *\\<^sub>v x\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "also"], ["proof (state)\nthis:\n  det A \\<cdot>\\<^sub>m 1\\<^sub>m n *\\<^sub>v x = adj_mat A * A *\\<^sub>v x\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have \"\\<dots> = adj_mat A *\\<^sub>v b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_mat A * A *\\<^sub>v x = adj_mat A *\\<^sub>v b", "using adj_mat[OF A] A x"], ["proof (prove)\nusing this:\n  adj_mat A \\<in> carrier_mat n n\n  A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n  adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n  A \\<in> carrier_mat n n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. adj_mat A * A *\\<^sub>v x = adj_mat A *\\<^sub>v b", "unfolding b_def"], ["proof (prove)\nusing this:\n  adj_mat A \\<in> carrier_mat n n\n  A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n  adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n  A \\<in> carrier_mat n n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. adj_mat A * A *\\<^sub>v x = adj_mat A *\\<^sub>v (A *\\<^sub>v x)", "by (metis assoc_mult_mat_vec)"], ["proof (state)\nthis:\n  adj_mat A * A *\\<^sub>v x = adj_mat A *\\<^sub>v b\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "also"], ["proof (state)\nthis:\n  adj_mat A * A *\\<^sub>v x = adj_mat A *\\<^sub>v b\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have \"\\<dots> $ k = row (adj_mat A) k \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (adj_mat A *\\<^sub>v b) $ k = row (adj_mat A) k \\<bullet> b", "using adj_mat[OF A] b k"], ["proof (prove)\nusing this:\n  adj_mat A \\<in> carrier_mat n n\n  A * adj_mat A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n  adj_mat A * A = det A \\<cdot>\\<^sub>m 1\\<^sub>m n\n  b \\<in> carrier_vec n\n  k < n\n\ngoal (1 subgoal):\n 1. (adj_mat A *\\<^sub>v b) $ k = row (adj_mat A) k \\<bullet> b", "by auto"], ["proof (state)\nthis:\n  (adj_mat A *\\<^sub>v b) $ k = row (adj_mat A) k \\<bullet> b\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "also"], ["proof (state)\nthis:\n  (adj_mat A *\\<^sub>v b) $ k = row (adj_mat A) k \\<bullet> b\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "have \"\\<dots> = det (replace_col A b k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (adj_mat A) k \\<bullet> b = det (replace_col A b k)", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec b. row (adj_mat A) k $ i * b $ i) =\n    det (replace_col A b k)", "using b k A"], ["proof (prove)\nusing this:\n  b \\<in> carrier_vec n\n  k < n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec b. row (adj_mat A) k $ i * b $ i) =\n    det (replace_col A b k)", "by (subst laplace_expansion_column[OF Ab k], auto intro!: sum.cong arg_cong[of _ _ det] \n      arg_cong[of _ _ \"\\<lambda> x. _ * x\"] eq_matI\n      simp: replace_col_def adj_mat_def Matrix.row_def cofactor_def mat_delete_def ac_simps)"], ["proof (state)\nthis:\n  row (adj_mat A) k \\<bullet> b = det (replace_col A b k)\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "finally"], ["proof (chain)\npicking this:\n  x $ k * det A = det (replace_col A b k)", "show ?thesis"], ["proof (prove)\nusing this:\n  x $ k * det A = det (replace_col A b k)\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "unfolding b_def"], ["proof (prove)\nusing this:\n  x $ k * det A = det (replace_col A (A *\\<^sub>v x) k)\n\ngoal (1 subgoal):\n 1. det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A", "by simp"], ["proof (state)\nthis:\n  det (replace_col A (A *\\<^sub>v x) k) = x $ k * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}