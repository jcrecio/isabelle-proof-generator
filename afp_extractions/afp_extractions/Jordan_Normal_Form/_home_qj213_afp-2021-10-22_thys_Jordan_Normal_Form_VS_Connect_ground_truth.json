{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/VS_Connect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma class_field: \"field (class_ring :: 'a :: field ring)\" (is \"field ?r\")", "lemmas matrix_vs_simps = module_mat_simps class_ring_simps", "lemma matrix_vs: \"vectorspace (class_ring :: 'a :: field ring) (module_mat TYPE('a) nr nc)\"", "lemma vec_module: \"module (class_ring :: 'a :: field ring) (module_vec TYPE('a) n)\"", "lemma vec_vs: \"vectorspace (class_ring :: 'a :: field ring) (module_vec TYPE('a) n)\"", "lemma finsum_vec[simp]: \"finsum_vec TYPE('a) n = finsum V\"", "lemma finsum_scalar_prod_sum:\n  assumes f: \"f : U \\<rightarrow> carrier_vec n\"\n      and w: \"w: carrier_vec n\"\n  shows \"finsum V f U \\<bullet> w = sum (\\<lambda>u. f u \\<bullet> w) U\"", "lemma vec_neg[simp]: assumes \"x : carrier_vec n\" shows \"\\<ominus>\\<^bsub>V\\<^esub> x = - x\"", "lemma finsum_dim:\n  \"finite A \\<Longrightarrow> f \\<in> A \\<rightarrow> carrier_vec n \\<Longrightarrow> dim_vec (finsum V f A) = n\"", "lemma lincomb_dim:\n  assumes fin: \"finite X\"\n    and X: \"X \\<subseteq> carrier_vec n\"\n  shows \"dim_vec (lincomb a X) = n\"", "lemma finsum_index:\n  assumes i: \"i < n\"\n    and f: \"f \\<in> X \\<rightarrow> carrier_vec n\"\n    and X: \"X \\<subseteq> carrier_vec n\"\n  shows \"finsum V f X $ i = sum (\\<lambda>x. f x $ i) X\"", "lemma lincomb_index:\n  assumes i: \"i < n\"\n    and X: \"X \\<subseteq> carrier_vec n\"\n  shows \"lincomb a X $ i = sum (\\<lambda>x. a x * x $ i) X\"", "lemma append_insert: \"set (xs @ [x]) = insert x (set xs)\"", "lemma lincomb_units:\n  assumes i: \"i < n\" \n  shows \"lincomb a (set (unit_vecs n)) $ i = a (unit_vec n i)\"", "lemma lincomb_coordinates:\n  assumes v: \"v : carrier_vec n\"\n  defines \"a \\<equiv> (\\<lambda>u. v $ (THE i. u = unit_vec n i))\"\n  shows \"lincomb a (set (unit_vecs n)) = v\"", "lemma span_unit_vecs_is_carrier: \"span (set (unit_vecs n)) = carrier_vec n\" (is \"?L = ?R\")", "lemma fin_dim[simp]: \"fin_dim\"", "lemma unit_vecs_basis: \"basis (set (unit_vecs n))\"", "lemma unit_vecs_length[simp]: \"length (unit_vecs n) = n\"", "lemma unit_vecs_distinct: \"distinct (unit_vecs n)\"", "lemma dim_is_n: \"dim = n\"", "lemma fin_dim_span:\nassumes \"finite A\" \"A \\<subseteq> carrier V\"\nshows \"vectorspace.fin_dim class_ring (vs (span A))\"", "lemma fin_dim_span_cols:\nassumes \"A \\<in> carrier_mat n nc\"\nshows \"vectorspace.fin_dim class_ring (vs (span (set (cols A))))\"", "lemma lincomb_list_as_mat_mult:\n  assumes \"\\<forall>w \\<in> set ws. dim_vec w = n\"\n  shows \"lincomb_list c ws = mat_of_cols n ws *\\<^sub>v vec (length ws) c\" (is \"?l ws c = ?r ws c\")", "lemma lincomb_vec_diff_add:\n    assumes A: \"A \\<subseteq> carrier_vec n\"\n    and BA: \"B \\<subseteq> A\" and fin_A: \"finite A\" \n    and f: \"f \\<in> A \\<rightarrow> UNIV\" shows \"lincomb f A = lincomb f (A-B) + lincomb f B\"", "lemma dim_sumlist:\n  assumes \"\\<forall>x\\<in>set xs. dim_vec x = n\"\n  shows \"dim_vec (M.sumlist xs) = n\"", "lemma sumlist_nth:\n  assumes \"\\<forall>x\\<in>set xs. dim_vec x = n\" and \"i<n\"\n  shows \"(M.sumlist xs) $ i= sum (\\<lambda>j. (xs ! j) $ i) {0..<length xs}\"", "lemma lincomb_as_lincomb_list_distinct:\n  assumes s: \"set ws \\<subseteq> carrier_vec n\" and d: \"distinct ws\"\n  shows \"lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws\"", "lemma lin_dep_cols_imp_det_0':\n  fixes ws\n  defines \"A \\<equiv> mat_of_cols n ws\"\n  assumes dimv_ws: \"\\<forall>w\\<in>set ws. dim_vec w = n\"\n  assumes A: \"A \\<in> carrier_mat n n\" and ld_cols: \"lin_dep (set (cols A))\"\n  shows  \"det A = 0\"", "lemma lin_dep_cols_imp_det_0:\n  assumes A: \"A \\<in> carrier_mat n n\" and ld: \"lin_dep (set (cols A))\"\n  shows \"det A = 0\"", "lemma det_not_0_imp_lin_indpt_rows:\n  assumes A: \"A \\<in> carrier_mat n n\" and det: \"det A \\<noteq> 0\"  \n  shows \"lin_indpt (set (rows A))\"", "lemma upper_triangular_imp_lin_indpt_rows:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and diag: \"0 \\<notin> set (diag_mat A)\"\n  shows \"lin_indpt (set (rows A))\"", "lemma lincomb_as_lincomb_list:\n  fixes ws f\n  assumes s: \"set ws \\<subseteq> carrier_vec n\"\n  shows \"lincomb f (set ws) = lincomb_list (\\<lambda>i. if \\<exists>j<i. ws!i = ws!j then 0 else f (ws ! i)) ws\"", "lemma span_list_as_span:\n  assumes \"set vs \\<subseteq> carrier_vec n\"\n  shows \"span_list vs = span (set vs)\"", "lemma in_spanI[intro]:\n  assumes \"v = lincomb a A\" \"finite A\" \"A \\<subseteq> W\"\n  shows \"v \\<in> span W\"", "lemma in_spanE:\n  assumes \"v \\<in> span W\"\n  shows \"\\<exists> a A. v = lincomb a A \\<and> finite A \\<and> A \\<subseteq> W\"", "lemma smult_in_span:\n  assumes \"W \\<subseteq> carrier_vec n\" and insp: \"x \\<in> span W\"\n  shows \"c \\<cdot>\\<^sub>v x \\<in> span W\"", "lemma span_subsetI: assumes ws: \"ws \\<subseteq> carrier_vec n\" \n  \"us \\<subseteq> span ws\" \nshows \"span us \\<subseteq> span ws\"", "lemma sumlist_in_span: assumes W: \"W \\<subseteq> carrier_vec n\"  \n  shows \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> span W) \\<Longrightarrow> sumlist xs \\<in> span W\"", "lemma span_span[simp]:\n  assumes \"W \\<subseteq> carrier_vec n\"\n  shows \"span (span W) = span W\"", "lemma upper_triangular_imp_basis:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and diag: \"0 \\<notin> set (diag_mat A)\"\n  shows \"basis (set (rows A))\"", "lemma fin_dim_span_rows:\nassumes A: \"A \\<in> carrier_mat nr n\"\nshows \"vectorspace.fin_dim class_ring (vs (span (set (rows A))))\"", "lemma row_space_eq_col_space_transpose:\n  shows \"row_space A = col_space A\\<^sup>T\"", "lemma col_space_eq_row_space_transpose:\n  shows \"col_space A = row_space A\\<^sup>T\"", "lemma col_space_eq:\n  assumes A: \"A \\<in> carrier_mat n nc\"\n  shows \"col_space A = {y\\<in>carrier_vec (dim_row A). \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}\"", "lemma vector_space_row_space: \n  assumes A: \"A \\<in> carrier_mat nr n\"\n  shows \"vectorspace class_ring (vs (row_space A))\"", "lemma row_space_eq:\n  assumes A: \"A \\<in> carrier_mat nr n\"\n  shows \"row_space A = {w\\<in>carrier_vec (dim_col A). \\<exists>y\\<in>carrier_vec (dim_row A). A\\<^sup>T *\\<^sub>v y = w}\"", "lemma row_space_is_preserved:\n  assumes inv_P: \"invertible_mat P\" and P: \"P \\<in> carrier_mat m m\" and A: \"A \\<in> carrier_mat m n\"\n  shows \"row_space (P*A) = row_space A\"", "lemma R_sumlist[simp]: \"R.sumlist = sum_list\"", "lemma sumlist_dim: assumes \"\\<And> x. x \\<in> set xs \\<Longrightarrow> x \\<in> carrier_vec n\"\n  shows \"dim_vec (sumlist xs) = n\"", "lemma sumlist_vec_index: assumes \"\\<And> x. x \\<in> set xs \\<Longrightarrow> x \\<in> carrier_vec n\"\n  and \"i < n\" \nshows \"sumlist xs $ i = sum_list (map (\\<lambda> x. x $ i) xs)\"", "lemma scalar_prod_left_sum_distrib: \n  assumes vs: \"\\<And> v. v \\<in> set vvs \\<Longrightarrow> v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\" \n  shows \"sumlist vvs \\<bullet> w = sum_list (map (\\<lambda> v. v \\<bullet> w) vvs)\"", "lemma scalar_prod_right_sum_distrib: \n  assumes vs: \"\\<And> v. v \\<in> set vvs \\<Longrightarrow> v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\" \n  shows \"w \\<bullet> sumlist vvs = sum_list (map (\\<lambda> v. w \\<bullet> v) vvs)\"", "lemma lincomb_list_add_vec_2: assumes us: \"set us \\<subseteq> carrier_vec n\" \n  and x: \"x = lincomb_list lc (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j])\"\n  and i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \nshows \"x = lincomb_list (lc (j := lc j + lc i * c)) us\" (is \"_ = ?x\")", "lemma lincomb_list_add_vec_1: assumes us: \"set us \\<subseteq> carrier_vec n\" \n  and x: \"x = lincomb_list lc us\"\n  and i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \nshows \"x = lincomb_list (lc (j := lc j - lc i * c)) (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j])\" (is \"_ = ?x\")", "lemma add_vec_span: assumes us: \"set us \\<subseteq> carrier_vec n\" \n  and i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \nshows \"span (set us) = span (set (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\" (is \"_ = span (set ?ws)\")", "lemma prod_in_span[intro!]:\n  assumes \"b \\<in> carrier_vec n\" \"S \\<subseteq> carrier_vec n\" \"a = 0 \\<or> b \\<in> span S\"\n  shows \"a \\<cdot>\\<^sub>v b \\<in> span S\"", "lemma det_nonzero_congruence:\n  assumes eq:\"A * M = B * M\" and det:\"det (M::'a mat) \\<noteq> 0\"\n  and M: \"M \\<in> carrier_mat n n\" and carr:\"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"A = B\"", "lemma mat_of_rows_mult_as_finsum:\n  assumes \"v \\<in> carrier_vec (length lst)\" \"\\<And> i. i < length lst \\<Longrightarrow> lst ! i \\<in> carrier_vec n\"\n  defines \"f l \\<equiv> sum (\\<lambda> i. if l = lst ! i then v $ i else 0) {0..<length lst}\"\n  shows mat_of_cols_mult_as_finsum:\"mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)\""], "translations": [["", "lemma class_field: \"field (class_ring :: 'a :: field ring)\" (is \"field ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. field class_ring", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. field class_ring", "interpret cring ?r"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring class_ring", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. field class_ring", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. field class_ring", "fix x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. field class_ring", "have \"x \\<noteq> 0 \\<Longrightarrow> \\<exists>xa. xa * x = 1 \\<and> x * xa = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>xa. xa * x = (1::'a) \\<and> x * xa = (1::'a)", "by (intro exI[of _ \"inverse x\"], auto)"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  \\<exists>xa. xa * x = (1::'a) \\<and> x * xa = (1::'a)\n\ngoal (1 subgoal):\n 1. field class_ring", "}"], ["proof (state)\nthis:\n  ?x2 \\<noteq> (0::'a) \\<Longrightarrow>\n  \\<exists>xa. xa * ?x2 = (1::'a) \\<and> ?x2 * xa = (1::'a)\n\ngoal (1 subgoal):\n 1. field class_ring", "note [simp] = this"], ["proof (state)\nthis:\n  ?x2 \\<noteq> (0::'a) \\<Longrightarrow>\n  \\<exists>xa. xa * ?x2 = (1::'a) \\<and> ?x2 * xa = (1::'a)\n\ngoal (1 subgoal):\n 1. field class_ring", "show \"field ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field class_ring", "by (unfold_locales, auto simp: Units_def)"], ["proof (state)\nthis:\n  field class_ring\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation class_field: field \"class_ring :: 'a :: field ring\"\n  rewrites \"carrier class_ring = UNIV\"\n    and \"mult class_ring = (*)\"\n    and \"add class_ring = (+)\"\n    and \"one class_ring = 1\"\n    and \"zero class_ring = 0\"\n    and \"a_inv class_ring = uminus\"\n    and \"a_minus class_ring = minus\"\n    and \"pow class_ring = (^)\"\n    and \"finsum class_ring = sum\"\n    and \"finprod class_ring = prod\"\n    and [class_ring_simps]: \"m_inv (class_ring :: 'a ring) x = \n      (if x = 0 then div0 else inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((field class_ring &&&\n      carrier class_ring = UNIV &&&\n      (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)) &&&\n     (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+) &&&\n     \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e) &&&\n     \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)) &&&\n    (a_inv class_ring = uminus &&&\n     a_minus class_ring = (-) &&& ([^]\\<^bsub>class_ring\\<^esub>) = (^)) &&&\n    finsum class_ring = sum &&&\n    finprod class_ring = prod &&&\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "(* problem that m_inv ?r 0 = inverse 0 is not guaranteed  *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((field class_ring &&&\n      carrier class_ring = UNIV &&&\n      (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)) &&&\n     (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+) &&&\n     \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e) &&&\n     \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)) &&&\n    (a_inv class_ring = uminus &&&\n     a_minus class_ring = (-) &&& ([^]\\<^bsub>class_ring\\<^esub>) = (^)) &&&\n    finsum class_ring = sum &&&\n    finprod class_ring = prod &&&\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "proof -"], ["proof (state)\ngoal (12 subgoals):\n 1. field class_ring\n 2. carrier class_ring = UNIV\n 3. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 4. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 5. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n 6. \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n 7. a_inv class_ring = uminus\n 8. a_minus class_ring = (-)\n 9. ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n 10. finsum class_ring = sum\nA total of 12 subgoals...", "let ?r = \"class_ring :: 'a ring\""], ["proof (state)\ngoal (12 subgoals):\n 1. field class_ring\n 2. carrier class_ring = UNIV\n 3. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 4. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 5. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n 6. \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n 7. a_inv class_ring = uminus\n 8. a_minus class_ring = (-)\n 9. ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n 10. finsum class_ring = sum\nA total of 12 subgoals...", "show \"field ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field class_ring", "using class_field"], ["proof (prove)\nusing this:\n  field class_ring\n\ngoal (1 subgoal):\n 1. field class_ring", "."], ["proof (state)\nthis:\n  field class_ring\n\ngoal (11 subgoals):\n 1. carrier class_ring = UNIV\n 2. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 3. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 4. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n 5. \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n 6. a_inv class_ring = uminus\n 7. a_minus class_ring = (-)\n 8. ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n 9. finsum class_ring = sum\n 10. finprod class_ring = prod\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  field class_ring", "interpret field ?r"], ["proof (prove)\nusing this:\n  field class_ring\n\ngoal (1 subgoal):\n 1. field class_ring", "."], ["proof (state)\ngoal (11 subgoals):\n 1. carrier class_ring = UNIV\n 2. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 3. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 4. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n 5. \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n 6. a_inv class_ring = uminus\n 7. a_minus class_ring = (-)\n 8. ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n 9. finsum class_ring = sum\n 10. finprod class_ring = prod\nA total of 11 subgoals...", "show \"a_inv ?r = uminus\"\n    and \"a_minus ?r = minus\"\n    and \"pow ?r = (^)\"\n    and \"finsum ?r = sum\"\n    and \"finprod ?r = prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_inv class_ring = uminus &&& a_minus class_ring = (-)) &&&\n    ([^]\\<^bsub>class_ring\\<^esub>) = (^) &&&\n    finsum class_ring = sum &&& finprod class_ring = prod", "by (fact class_ring_simps)+"], ["proof (state)\nthis:\n  a_inv class_ring = uminus\n  a_minus class_ring = (-)\n  ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n  finsum class_ring = sum\n  finprod class_ring = prod\n\ngoal (6 subgoals):\n 1. carrier class_ring = UNIV\n 2. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 3. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 4. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n 5. \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n 6. inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "show \"inv\\<^bsub>?r\\<^esub> x = (if x = 0 then div0 else inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "case True"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "unfolding div0_def"], ["proof (prove)\nusing this:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then inv\\<^bsub>class_ring\\<^esub> (0::'a)\n     else inverse x)", "by simp"], ["proof (state)\nthis:\n  inv\\<^bsub>class_ring\\<^esub> x =\n  (if x = (0::'a) then div0 else inverse x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "unfolding m_inv_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (THE y.\n        y \\<in> carrier class_ring \\<and>\n        x \\<otimes>\\<^bsub>class_ring\\<^esub> y =\n        \\<one>\\<^bsub>class_ring\\<^esub> \\<and>\n        y \\<otimes>\\<^bsub>class_ring\\<^esub> x =\n        \\<one>\\<^bsub>class_ring\\<^esub>) =\n    (if x = (0::'a) then div0 else inverse x)", "by (intro the1_equality ex1I[of _ \"inverse x\"], auto simp: inverse_unique)"], ["proof (state)\nthis:\n  inv\\<^bsub>class_ring\\<^esub> x =\n  (if x = (0::'a) then div0 else inverse x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv\\<^bsub>class_ring\\<^esub> x =\n  (if x = (0::'a) then div0 else inverse x)\n\ngoal (5 subgoals):\n 1. carrier class_ring = UNIV\n 2. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 3. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 4. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n 5. \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)", "qed (auto simp: class_ring_simps)"], ["", "lemmas matrix_vs_simps = module_mat_simps class_ring_simps"], ["", "definition class_field :: \"'a :: field ring\"\n  where [class_ring_simps]: \"class_field \\<equiv> class_ring\""], ["", "locale matrix_ring = \n  fixes n :: nat\n    and field_type :: \"'a :: field itself\"\nbegin"], ["", "abbreviation R where \"R \\<equiv> ring_mat TYPE('a) n n\""], ["", "sublocale ring R\n  rewrites \"carrier R = carrier_mat n n\"\n    and \"add R = (+)\"\n    and \"mult R = (*)\"\n    and \"one R = 1\\<^sub>m n\"\n    and \"zero R = 0\\<^sub>m n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ring R &&&\n     carrier R = carrier_mat n n &&& (\\<oplus>\\<^bsub>R\\<^esub>) = (+)) &&&\n    (\\<otimes>\\<^bsub>R\\<^esub>) = (*) &&&\n    \\<one>\\<^bsub>R\\<^esub> = 1\\<^sub>m n &&&\n    \\<zero>\\<^bsub>R\\<^esub> = 0\\<^sub>m n n", "using ring_mat"], ["proof (prove)\nusing this:\n  ring (ring_mat TYPE(?'a) ?n ?b)\n\ngoal (1 subgoal):\n 1. (ring R &&&\n     carrier R = carrier_mat n n &&& (\\<oplus>\\<^bsub>R\\<^esub>) = (+)) &&&\n    (\\<otimes>\\<^bsub>R\\<^esub>) = (*) &&&\n    \\<one>\\<^bsub>R\\<^esub> = 1\\<^sub>m n &&&\n    \\<zero>\\<^bsub>R\\<^esub> = 0\\<^sub>m n n", "by (auto simp: ring_mat_simps)"], ["", "end"], ["", "lemma matrix_vs: \"vectorspace (class_ring :: 'a :: field ring) (module_mat TYPE('a) nr nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (module_mat TYPE('a) nr nc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace class_ring (module_mat TYPE('a) nr nc)", "interpret abelian_group \"module_mat TYPE('a) nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_group (module_mat TYPE('a) nr nc)", "by (rule abelian_group_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace class_ring (module_mat TYPE('a) nr nc)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (module_mat TYPE('a) nr nc)", "unfolding class_field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (module_mat TYPE('a) nr nc)", "by (unfold_locales, unfold matrix_vs_simps, \n      auto simp: add_smult_distrib_left_mat add_smult_distrib_right_mat)"], ["proof (state)\nthis:\n  vectorspace class_ring (module_mat TYPE('a) nr nc)\n\ngoal:\nNo subgoals!", "qed"], ["", "locale vec_module =\n  fixes f_ty::\"'a::comm_ring_1 itself\"\n  and n::\"nat\"\nbegin"], ["", "abbreviation V where \"V \\<equiv> module_vec TYPE('a) n\""], ["", "sublocale Module.module \"class_ring :: 'a ring\" V\n  rewrites \"carrier V = carrier_vec n\"\n    and \"add V = (+)\"\n    and \"zero V = 0\\<^sub>v n\"\n    and \"module.smult V = (\\<cdot>\\<^sub>v)\"\n    and \"carrier class_ring = UNIV\"\n    and \"monoid.mult class_ring = (*)\"\n    and \"add class_ring = (+)\"\n    and \"one class_ring = 1\"\n    and \"zero class_ring = 0\"\n    and \"a_inv (class_ring :: 'a ring) = uminus\"\n    and \"a_minus (class_ring :: 'a ring) = (-)\"\n    and \"pow (class_ring :: 'a ring) = (^)\"\n    and \"finsum (class_ring :: 'a ring) = sum\"\n    and \"finprod (class_ring :: 'a ring) = prod\"\n    and \"\\<And>X. X \\<subseteq> UNIV = True\" (* These rewrite rules will clean lemmas *)\n    and \"\\<And>x. x \\<in> UNIV = True\"\n    and \"\\<And>a A. a \\<in> A \\<rightarrow> UNIV \\<equiv> True\"\n    and \"\\<And>P. P \\<and> True \\<equiv> P\"\n    and \"\\<And>P. (True \\<Longrightarrow> P) \\<equiv> Trueprop P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((module class_ring V &&& carrier V = carrier_vec n) &&&\n      (\\<oplus>\\<^bsub>V\\<^esub>) = (+) &&&\n      \\<zero>\\<^bsub>V\\<^esub> = 0\\<^sub>v n &&&\n      (\\<odot>\\<^bsub>V\\<^esub>) = (\\<cdot>\\<^sub>v)) &&&\n     (carrier class_ring = UNIV &&&\n      (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)) &&&\n     (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+) &&&\n     \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e) &&&\n     \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)) &&&\n    ((a_inv class_ring = uminus &&& a_minus class_ring = (-)) &&&\n     ([^]\\<^bsub>class_ring\\<^esub>) = (^) &&&\n     finsum class_ring = sum &&& finprod class_ring = prod) &&&\n    ((\\<And>X. (X \\<subseteq> UNIV) = True) &&&\n     (\\<And>x. (x \\<in> UNIV) = True)) &&&\n    (\\<And>a A. a \\<in> A \\<rightarrow> UNIV \\<equiv> True) &&&\n    (\\<And>P. P \\<and> True \\<equiv> P) &&&\n    (\\<And>P. (True \\<Longrightarrow> P) \\<equiv> P)", "apply unfold_locales"], ["proof (prove)\ngoal (31 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid V);\n        y \\<in> carrier (add_monoid V)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid V\\<^esub> y\n                         \\<in> carrier (add_monoid V)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid V);\n        y \\<in> carrier (add_monoid V);\n        z \\<in> carrier (add_monoid V)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid V\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid V\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid V\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid V\\<^esub> z)\n 3. \\<one>\\<^bsub>add_monoid V\\<^esub> \\<in> carrier (add_monoid V)\n 4. \\<And>x.\n       x \\<in> carrier (add_monoid V) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid V\\<^esub> \\<otimes>\\<^bsub>add_monoid V\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier (add_monoid V) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid V\\<^esub>\n       \\<one>\\<^bsub>add_monoid V\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid V);\n        y \\<in> carrier (add_monoid V)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid V\\<^esub> y =\n                         y \\<otimes>\\<^bsub>add_monoid V\\<^esub> x\n 7. carrier (add_monoid V) \\<subseteq> Units (add_monoid V)\n 8. \\<And>a x.\n       \\<lbrakk>a \\<in> carrier class_ring; x \\<in> carrier V\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>V\\<^esub> x \\<in> carrier V\n 9. \\<And>a b x.\n       \\<lbrakk>a \\<in> carrier class_ring; b \\<in> carrier class_ring;\n        x \\<in> carrier V\\<rbrakk>\n       \\<Longrightarrow> (a \\<oplus>\\<^bsub>class_ring\\<^esub>\n                          b) \\<odot>\\<^bsub>V\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>V\\<^esub>\n                         x \\<oplus>\\<^bsub>V\\<^esub>\n                         b \\<odot>\\<^bsub>V\\<^esub> x\n 10. \\<And>a x y.\n        \\<lbrakk>a \\<in> carrier class_ring; x \\<in> carrier V;\n         y \\<in> carrier V\\<rbrakk>\n        \\<Longrightarrow> a \\<odot>\\<^bsub>V\\<^esub>\n                          (x \\<oplus>\\<^bsub>V\\<^esub> y) =\n                          a \\<odot>\\<^bsub>V\\<^esub>\n                          x \\<oplus>\\<^bsub>V\\<^esub>\n                          a \\<odot>\\<^bsub>V\\<^esub> y\nA total of 31 subgoals...", "apply (auto simp: module_vec_simps class_ring_simps Units_def add_smult_distrib_vec \n      smult_add_distrib_vec intro!:bexI[of _ \"- _\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale matrix_vs = \n  fixes nr :: nat\n    and nc :: nat\n    and field_type :: \"'a :: field itself\"\nbegin"], ["", "abbreviation V where \"V \\<equiv> module_mat TYPE('a) nr nc\""], ["", "sublocale  \n  vectorspace class_ring V\n  rewrites \"carrier V = carrier_mat nr nc\"\n    and \"add V = (+)\"\n    and \"mult V = (*)\"\n    and \"one V = 1\\<^sub>m nr\"\n    and \"zero V = 0\\<^sub>m nr nc\"\n    and \"smult V = (\\<cdot>\\<^sub>m)\"\n    and \"carrier class_ring = UNIV\"\n    and \"mult class_ring = (*)\"\n    and \"add class_ring = (+)\"\n    and \"one class_ring = 1\"\n    and \"zero class_ring = 0\"\n    and \"a_inv (class_ring :: 'a ring) = uminus\"\n    and \"a_minus (class_ring :: 'a ring) = minus\"\n    and \"pow (class_ring :: 'a ring) = (^)\"\n    and \"finsum (class_ring :: 'a ring) = sum\"\n    and \"finprod (class_ring :: 'a ring) = prod\"\n    and \"m_inv (class_ring :: 'a ring) x = \n      (if x = 0 then div0 else inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((vectorspace class_ring V &&& carrier V = carrier_mat nr nc) &&&\n      (\\<oplus>\\<^bsub>V\\<^esub>) = (+) &&&\n      (\\<otimes>\\<^bsub>V\\<^esub>) = (*)) &&&\n     (\\<one>\\<^bsub>V\\<^esub> = 1\\<^sub>m nr &&&\n      \\<zero>\\<^bsub>V\\<^esub> = 0\\<^sub>m nr nc) &&&\n     (\\<odot>\\<^bsub>V\\<^esub>) = (\\<cdot>\\<^sub>m) &&&\n     carrier class_ring = UNIV &&&\n     (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)) &&&\n    (((\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+) &&&\n      \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)) &&&\n     \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f) &&&\n     a_inv class_ring = uminus) &&&\n    (a_minus class_ring = (-) &&& ([^]\\<^bsub>class_ring\\<^esub>) = (^)) &&&\n    finsum class_ring = sum &&&\n    finprod class_ring = prod &&&\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "by (rule matrix_vs, auto simp: matrix_vs_simps class_field_def)"], ["", "end"], ["", "lemma vec_module: \"module (class_ring :: 'a :: field ring) (module_vec TYPE('a) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring (module_vec TYPE('a) n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. module class_ring (module_vec TYPE('a) n)", "interpret abelian_group \"module_vec TYPE('a) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_group (module_vec TYPE('a) n)", "apply (unfold_locales)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (module_vec TYPE('a) n));\n        y \\<in> carrier (add_monoid (module_vec TYPE('a) n))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n                         y\n                         \\<in> carrier (add_monoid (module_vec TYPE('a) n))\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid (module_vec TYPE('a) n));\n        y \\<in> carrier (add_monoid (module_vec TYPE('a) n));\n        z \\<in> carrier (add_monoid (module_vec TYPE('a) n))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n    \\<in> carrier (add_monoid (module_vec TYPE('a) n))\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (module_vec TYPE('a) n)) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub> \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (module_vec TYPE('a) n)) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n       \\<one>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (module_vec TYPE('a) n));\n        y \\<in> carrier (add_monoid (module_vec TYPE('a) n))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) n)\\<^esub>\n                         x\n 7. carrier (add_monoid (module_vec TYPE('a) n))\n    \\<subseteq> Units (add_monoid (module_vec TYPE('a) n))", "unfolding module_vec_def Units_def"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           \\<lparr>carrier = carrier_vec n,\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v n, add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        y \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid\n                                  \\<lparr>carrier = carrier_vec n,\n                                     mult = undefined, one = undefined,\n                                     zero = 0\\<^sub>v n, add = (+),\n                                     smult = (\\<cdot>\\<^sub>v)\\<rparr>)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           \\<lparr>carrier = carrier_vec n,\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v n, add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        y \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        z \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n    \\<in> carrier\n           (add_monoid\n             \\<lparr>carrier = carrier_vec n, mult = undefined,\n                one = undefined, zero = 0\\<^sub>v n, add = (+),\n                smult = (\\<cdot>\\<^sub>v)\\<rparr>)\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid\n                  \\<lparr>carrier = carrier_vec n, mult = undefined,\n                     one = undefined, zero = 0\\<^sub>v n, add = (+),\n                     smult = (\\<cdot>\\<^sub>v)\\<rparr>) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub> \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid\n                  \\<lparr>carrier = carrier_vec n, mult = undefined,\n                     one = undefined, zero = 0\\<^sub>v n, add = (+),\n                     smult = (\\<cdot>\\<^sub>v)\\<rparr>) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n       \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           \\<lparr>carrier = carrier_vec n,\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v n, add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        y \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         x\n 7. carrier\n     (add_monoid\n       \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined,\n          zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>)\n    \\<subseteq> {y \\<in> carrier\n                          (add_monoid\n                            \\<lparr>carrier = carrier_vec n,\n                               mult = undefined, one = undefined,\n                               zero = 0\\<^sub>v n, add = (+),\n                               smult = (\\<cdot>\\<^sub>v)\\<rparr>).\n                 \\<exists>x\\<in>carrier\n                                 (add_monoid\n                                   \\<lparr>carrier = carrier_vec n,\nmult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+),\nsmult = (\\<cdot>\\<^sub>v)\\<rparr>).\n                    x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                    y =\n                    \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub> \\<and>\n                    y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                    x =\n                    \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>}", "using add_inv_exists_vec"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow>\n  \\<exists>w\\<in>carrier_vec ?n.\n     w + ?v = 0\\<^sub>v ?n \\<and> ?v + w = 0\\<^sub>v ?n\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           \\<lparr>carrier = carrier_vec n,\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v n, add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        y \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid\n                                  \\<lparr>carrier = carrier_vec n,\n                                     mult = undefined, one = undefined,\n                                     zero = 0\\<^sub>v n, add = (+),\n                                     smult = (\\<cdot>\\<^sub>v)\\<rparr>)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           \\<lparr>carrier = carrier_vec n,\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v n, add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        y \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        z \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n    \\<in> carrier\n           (add_monoid\n             \\<lparr>carrier = carrier_vec n, mult = undefined,\n                one = undefined, zero = 0\\<^sub>v n, add = (+),\n                smult = (\\<cdot>\\<^sub>v)\\<rparr>)\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid\n                  \\<lparr>carrier = carrier_vec n, mult = undefined,\n                     one = undefined, zero = 0\\<^sub>v n, add = (+),\n                     smult = (\\<cdot>\\<^sub>v)\\<rparr>) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub> \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid\n                  \\<lparr>carrier = carrier_vec n, mult = undefined,\n                     one = undefined, zero = 0\\<^sub>v n, add = (+),\n                     smult = (\\<cdot>\\<^sub>v)\\<rparr>) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n       \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           \\<lparr>carrier = carrier_vec n,\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v n, add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>);\n        y \\<in> carrier\n                 (add_monoid\n                   \\<lparr>carrier = carrier_vec n, mult = undefined,\n                      one = undefined, zero = 0\\<^sub>v n, add = (+),\n                      smult = (\\<cdot>\\<^sub>v)\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                         x\n 7. carrier\n     (add_monoid\n       \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined,\n          zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>)\n    \\<subseteq> {y \\<in> carrier\n                          (add_monoid\n                            \\<lparr>carrier = carrier_vec n,\n                               mult = undefined, one = undefined,\n                               zero = 0\\<^sub>v n, add = (+),\n                               smult = (\\<cdot>\\<^sub>v)\\<rparr>).\n                 \\<exists>x\\<in>carrier\n                                 (add_monoid\n                                   \\<lparr>carrier = carrier_vec n,\nmult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+),\nsmult = (\\<cdot>\\<^sub>v)\\<rparr>).\n                    x \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                    y =\n                    \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub> \\<and>\n                    y \\<otimes>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n                    x =\n                    \\<one>\\<^bsub>add_monoid \\<lparr>carrier = carrier_vec n, mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>}", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. module class_ring (module_vec TYPE('a) n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring (module_vec TYPE('a) n)", "unfolding class_field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring (module_vec TYPE('a) n)", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>a \\<in> carrier class_ring;\n        x \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> x\n                         \\<in> carrier (module_vec TYPE('a) n)\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<in> carrier class_ring; b \\<in> carrier class_ring;\n        x \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> (a \\<oplus>\\<^bsub>class_ring\\<^esub>\n                          b) \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         b \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> x\n 3. \\<And>a x y.\n       \\<lbrakk>a \\<in> carrier class_ring;\n        x \\<in> carrier (module_vec TYPE('a) n);\n        y \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         (x \\<oplus>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                          y) =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> y\n 4. \\<And>a b x.\n       \\<lbrakk>a \\<in> carrier class_ring; b \\<in> carrier class_ring;\n        x \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> a \\<otimes>\\<^bsub>class_ring\\<^esub>\n                         b \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         (b \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> x)\n 5. \\<And>x.\n       x \\<in> carrier (module_vec TYPE('a) n) \\<Longrightarrow>\n       \\<one>\\<^bsub>class_ring\\<^esub> \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n       x =\n       x", "unfolding class_ring_simps"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>a \\<in> UNIV;\n        x \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> x\n                         \\<in> carrier (module_vec TYPE('a) n)\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV;\n        x \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> (a +\n                          b) \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         b \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> x\n 3. \\<And>a x y.\n       \\<lbrakk>a \\<in> UNIV; x \\<in> carrier (module_vec TYPE('a) n);\n        y \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         (x \\<oplus>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                          y) =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> y\n 4. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV;\n        x \\<in> carrier (module_vec TYPE('a) n)\\<rbrakk>\n       \\<Longrightarrow> a * b \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub>\n                         (b \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> x)\n 5. \\<And>x.\n       x \\<in> carrier (module_vec TYPE('a) n) \\<Longrightarrow>\n       (1::'a) \\<odot>\\<^bsub>module_vec TYPE('a) n\\<^esub> x = x", "unfolding module_vec_simps"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>a \\<in> UNIV; x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x \\<in> carrier_vec n\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV; x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> (a + b) \\<cdot>\\<^sub>v x =\n                         a \\<cdot>\\<^sub>v x + b \\<cdot>\\<^sub>v x\n 3. \\<And>a x y.\n       \\<lbrakk>a \\<in> UNIV; x \\<in> carrier_vec n;\n        y \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y\n 4. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV; x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> a * b \\<cdot>\\<^sub>v x =\n                         a \\<cdot>\\<^sub>v (b \\<cdot>\\<^sub>v x)\n 5. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow> (1::'a) \\<cdot>\\<^sub>v x = x", "using add_smult_distrib_vec"], ["proof (prove)\nusing this:\n  (?a + ?b) \\<cdot>\\<^sub>v ?v =\n  ?a \\<cdot>\\<^sub>v ?v + ?b \\<cdot>\\<^sub>v ?v\n\ngoal (5 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>a \\<in> UNIV; x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x \\<in> carrier_vec n\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV; x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> (a + b) \\<cdot>\\<^sub>v x =\n                         a \\<cdot>\\<^sub>v x + b \\<cdot>\\<^sub>v x\n 3. \\<And>a x y.\n       \\<lbrakk>a \\<in> UNIV; x \\<in> carrier_vec n;\n        y \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y\n 4. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV; x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> a * b \\<cdot>\\<^sub>v x =\n                         a \\<cdot>\\<^sub>v (b \\<cdot>\\<^sub>v x)\n 5. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow> (1::'a) \\<cdot>\\<^sub>v x = x", "by (auto simp: smult_add_distrib_vec)"], ["proof (state)\nthis:\n  module class_ring (module_vec TYPE('a) n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_vs: \"vectorspace (class_ring :: 'a :: field ring) (module_vec TYPE('a) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (module_vec TYPE('a) n)", "unfolding vectorspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring (module_vec TYPE('a) n) \\<and> field class_ring", "using vec_module class_field"], ["proof (prove)\nusing this:\n  module class_ring (module_vec TYPE(?'a) ?n)\n  field class_ring\n\ngoal (1 subgoal):\n 1. module class_ring (module_vec TYPE('a) n) \\<and> field class_ring", "by (auto simp: class_field_def)"], ["", "locale vec_space =\n  fixes f_ty::\"'a::field itself\"\n  and n::\"nat\"\nbegin"], ["", "sublocale vec_module f_ty n"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale vectorspace class_ring V \n  rewrites cV[simp]: \"carrier V = carrier_vec n\"\n    and [simp]: \"add V = (+)\"\n    and [simp]: \"zero V = 0\\<^sub>v n\"\n    and [simp]: \"smult V = (\\<cdot>\\<^sub>v)\"\n    and \"carrier class_ring = UNIV\"\n    and \"mult class_ring = (*)\"\n    and \"add class_ring = (+)\"\n    and \"one class_ring = 1\"\n    and \"zero class_ring = 0\"\n    and \"a_inv (class_ring :: 'a ring) = uminus\"\n    and \"a_minus (class_ring :: 'a ring) = minus\"\n    and \"pow (class_ring :: 'a ring) = (^)\"\n    and \"finsum (class_ring :: 'a ring) = sum\"\n    and \"finprod (class_ring :: 'a ring) = prod\"\n    and \"m_inv (class_ring :: 'a ring) x = (if x = 0 then div0 else inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((vectorspace class_ring V &&& carrier V = carrier_vec n) &&&\n      (\\<oplus>\\<^bsub>V\\<^esub>) = (+) &&&\n      \\<zero>\\<^bsub>V\\<^esub> = 0\\<^sub>v n) &&&\n     ((\\<odot>\\<^bsub>V\\<^esub>) = (\\<cdot>\\<^sub>v) &&&\n      carrier class_ring = UNIV) &&&\n     (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*) &&&\n     (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)) &&&\n    ((\\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e1) &&&\n      \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f1)) &&&\n     a_inv class_ring = uminus &&& a_minus class_ring = (-)) &&&\n    (([^]\\<^bsub>class_ring\\<^esub>) = (^) &&& finsum class_ring = sum) &&&\n    finprod class_ring = prod &&&\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. (((vectorspace class_ring V &&& carrier V = carrier_vec n) &&&\n      (\\<oplus>\\<^bsub>V\\<^esub>) = (+) &&&\n      \\<zero>\\<^bsub>V\\<^esub> = 0\\<^sub>v n) &&&\n     ((\\<odot>\\<^bsub>V\\<^esub>) = (\\<cdot>\\<^sub>v) &&&\n      carrier class_ring = UNIV) &&&\n     (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*) &&&\n     (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)) &&&\n    ((\\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e1) &&&\n      \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f1)) &&&\n     a_inv class_ring = uminus &&& a_minus class_ring = (-)) &&&\n    (([^]\\<^bsub>class_ring\\<^esub>) = (^) &&& finsum class_ring = sum) &&&\n    finprod class_ring = prod &&&\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "unfolding class_field_def"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. (((vectorspace class_ring V &&& carrier V = carrier_vec n) &&&\n      (\\<oplus>\\<^bsub>V\\<^esub>) = (+) &&&\n      \\<zero>\\<^bsub>V\\<^esub> = 0\\<^sub>v n) &&&\n     ((\\<odot>\\<^bsub>V\\<^esub>) = (\\<cdot>\\<^sub>v) &&&\n      carrier class_ring = UNIV) &&&\n     (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*) &&&\n     (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)) &&&\n    ((\\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e1) &&&\n      \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f1)) &&&\n     a_inv class_ring = uminus &&& a_minus class_ring = (-)) &&&\n    (([^]\\<^bsub>class_ring\\<^esub>) = (^) &&& finsum class_ring = sum) &&&\n    finprod class_ring = prod &&&\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "by (auto simp: module_vec_simps class_ring_simps)"], ["", "lemma finsum_vec[simp]: \"finsum_vec TYPE('a) n = finsum V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum_vec TYPE('a) n = finsum V", "by (force simp: finsum_vec_def monoid_vec_def finsum_def finprod_def)"], ["", "lemma finsum_scalar_prod_sum:\n  assumes f: \"f : U \\<rightarrow> carrier_vec n\"\n      and w: \"w: carrier_vec n\"\n  shows \"finsum V f U \\<bullet> w = sum (\\<lambda>u. f u \\<bullet> w) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum V f U \\<bullet> w = (\\<Sum>u\\<in>U. f u \\<bullet> w)", "using w f"], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  f \\<in> U \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. finsum V f U \\<bullet> w = (\\<Sum>u\\<in>U. f u \\<bullet> w)", "proof (induct U rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; w \\<in> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A \\<bullet> w =\n                         (\\<Sum>u\\<in>A. f u \\<bullet> w)\n 2. \\<lbrakk>w \\<in> carrier_vec n;\n     f \\<in> {} \\<rightarrow> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f {} \\<bullet> w =\n                      (\\<Sum>u\\<in>{}. f u \\<bullet> w)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>w \\<in> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F \\<bullet> w =\n                          (\\<Sum>u\\<in>F. f u \\<bullet> w);\n        w \\<in> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) \\<bullet> w =\n                         (\\<Sum>u\\<in>insert x F. f u \\<bullet> w)", "case (insert u U)"], ["proof (state)\nthis:\n  finite U\n  u \\<notin> U\n  \\<lbrakk>w \\<in> carrier_vec n;\n   f \\<in> U \\<rightarrow> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> finsum V f U \\<bullet> w =\n                    (\\<Sum>u\\<in>U. f u \\<bullet> w)\n  w \\<in> carrier_vec n\n  f \\<in> insert u U \\<rightarrow> carrier_vec n\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; w \\<in> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A \\<bullet> w =\n                         (\\<Sum>u\\<in>A. f u \\<bullet> w)\n 2. \\<lbrakk>w \\<in> carrier_vec n;\n     f \\<in> {} \\<rightarrow> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f {} \\<bullet> w =\n                      (\\<Sum>u\\<in>{}. f u \\<bullet> w)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>w \\<in> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F \\<bullet> w =\n                          (\\<Sum>u\\<in>F. f u \\<bullet> w);\n        w \\<in> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) \\<bullet> w =\n                         (\\<Sum>u\\<in>insert x F. f u \\<bullet> w)", "hence f: \"f : U \\<rightarrow> carrier_vec n\" \"f u : carrier_vec n\""], ["proof (prove)\nusing this:\n  finite U\n  u \\<notin> U\n  \\<lbrakk>w \\<in> carrier_vec n;\n   f \\<in> U \\<rightarrow> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> finsum V f U \\<bullet> w =\n                    (\\<Sum>u\\<in>U. f u \\<bullet> w)\n  w \\<in> carrier_vec n\n  f \\<in> insert u U \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f \\<in> U \\<rightarrow> carrier_vec n &&& f u \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  f \\<in> U \\<rightarrow> carrier_vec n\n  f u \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; w \\<in> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A \\<bullet> w =\n                         (\\<Sum>u\\<in>A. f u \\<bullet> w)\n 2. \\<lbrakk>w \\<in> carrier_vec n;\n     f \\<in> {} \\<rightarrow> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f {} \\<bullet> w =\n                      (\\<Sum>u\\<in>{}. f u \\<bullet> w)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>w \\<in> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F \\<bullet> w =\n                          (\\<Sum>u\\<in>F. f u \\<bullet> w);\n        w \\<in> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) \\<bullet> w =\n                         (\\<Sum>u\\<in>insert x F. f u \\<bullet> w)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum V f (insert u U) \\<bullet> w =\n    (\\<Sum>u\\<in>insert u U. f u \\<bullet> w)", "unfolding finsum_insert[OF insert(1) insert(2) f]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f u + finsum V f U) \\<bullet> w =\n    (\\<Sum>u\\<in>insert u U. f u \\<bullet> w)", "apply (subst add_scalar_prod_distrib)"], ["proof (prove)\ngoal (4 subgoals):\n 1. f u \\<in> carrier_vec ?n1\n 2. finsum V f U \\<in> carrier_vec ?n1\n 3. w \\<in> carrier_vec ?n1\n 4. f u \\<bullet> w + finsum V f U \\<bullet> w =\n    (\\<Sum>u\\<in>insert u U. f u \\<bullet> w)", "using insert"], ["proof (prove)\nusing this:\n  finite U\n  u \\<notin> U\n  \\<lbrakk>w \\<in> carrier_vec n;\n   f \\<in> U \\<rightarrow> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> finsum V f U \\<bullet> w =\n                    (\\<Sum>u\\<in>U. f u \\<bullet> w)\n  w \\<in> carrier_vec n\n  f \\<in> insert u U \\<rightarrow> carrier_vec n\n\ngoal (4 subgoals):\n 1. f u \\<in> carrier_vec ?n1\n 2. finsum V f U \\<in> carrier_vec ?n1\n 3. w \\<in> carrier_vec ?n1\n 4. f u \\<bullet> w + finsum V f U \\<bullet> w =\n    (\\<Sum>u\\<in>insert u U. f u \\<bullet> w)", "by auto"], ["proof (state)\nthis:\n  finsum V f (insert u U) \\<bullet> w =\n  (\\<Sum>u\\<in>insert u U. f u \\<bullet> w)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; w \\<in> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A \\<bullet> w =\n                         (\\<Sum>u\\<in>A. f u \\<bullet> w)\n 2. \\<lbrakk>w \\<in> carrier_vec n;\n     f \\<in> {} \\<rightarrow> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f {} \\<bullet> w =\n                      (\\<Sum>u\\<in>{}. f u \\<bullet> w)", "qed auto"], ["", "lemma vec_neg[simp]: assumes \"x : carrier_vec n\" shows \"\\<ominus>\\<^bsub>V\\<^esub> x = - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>V\\<^esub> x = - x", "unfolding a_inv_def m_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE y.\n        y \\<in> carrier (add_monoid V) \\<and>\n        x \\<otimes>\\<^bsub>add_monoid V\\<^esub> y =\n        \\<one>\\<^bsub>add_monoid V\\<^esub> \\<and>\n        y \\<otimes>\\<^bsub>add_monoid V\\<^esub> x =\n        \\<one>\\<^bsub>add_monoid V\\<^esub>) =\n    - x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE y.\n        y \\<in> carrier_vec n \\<and>\n        x + y = 0\\<^sub>v n \\<and> y + x = 0\\<^sub>v n) =\n    - x", "apply (rule the_equality, intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. - x \\<in> carrier_vec n\n 2. x + - x = 0\\<^sub>v n\n 3. - x + x = 0\\<^sub>v n\n 4. \\<And>y.\n       y \\<in> carrier_vec n \\<and>\n       x + y = 0\\<^sub>v n \\<and> y + x = 0\\<^sub>v n \\<Longrightarrow>\n       y = - x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec n\n\ngoal (4 subgoals):\n 1. - x \\<in> carrier_vec n\n 2. x + - x = 0\\<^sub>v n\n 3. - x + x = 0\\<^sub>v n\n 4. \\<And>y.\n       y \\<in> carrier_vec n \\<and>\n       x + y = 0\\<^sub>v n \\<and> y + x = 0\\<^sub>v n \\<Longrightarrow>\n       y = - x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x \\<in> carrier_vec n; y \\<in> carrier_vec n;\n        x + y = 0\\<^sub>v n; y + x = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> y = - x", "using M.minus_unique uminus_carrier_vec uminus_r_inv_vec"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y + ?x = 0\\<^sub>v n; ?x + ?y' = 0\\<^sub>v n;\n   ?x \\<in> carrier_vec n; ?y \\<in> carrier_vec n;\n   ?y' \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> ?y = ?y'\n  (- ?v \\<in> carrier_vec ?n) = (?v \\<in> carrier_vec ?n)\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> ?v + - ?v = 0\\<^sub>v ?n\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x \\<in> carrier_vec n; y \\<in> carrier_vec n;\n        x + y = 0\\<^sub>v n; y + x = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> y = - x", "by blast"], ["", "lemma finsum_dim:\n  \"finite A \\<Longrightarrow> f \\<in> A \\<rightarrow> carrier_vec n \\<Longrightarrow> dim_vec (finsum V f A) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> dim_vec (finsum V f A) = n", "proof(induct set:finite)"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    dim_vec (finsum V f {}) = n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        dim_vec (finsum V f F) = n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec (finsum V f (insert x F)) = n", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  f \\<in> A \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  dim_vec (finsum V f A) = n\n  f \\<in> insert a A \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    dim_vec (finsum V f {}) = n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        dim_vec (finsum V f F) = n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec (finsum V f (insert x F)) = n", "hence dfa: \"dim_vec (f a) = n\""], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  f \\<in> A \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  dim_vec (finsum V f A) = n\n  f \\<in> insert a A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (f a) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec (f a) = n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    dim_vec (finsum V f {}) = n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        dim_vec (finsum V f F) = n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec (finsum V f (insert x F)) = n", "have f: \"f \\<in> A \\<rightarrow> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> A \\<rightarrow> carrier_vec n", "using insert"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  f \\<in> A \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  dim_vec (finsum V f A) = n\n  f \\<in> insert a A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f \\<in> A \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  f \\<in> A \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    dim_vec (finsum V f {}) = n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        dim_vec (finsum V f F) = n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec (finsum V f (insert x F)) = n", "hence fa: \"f a \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  f \\<in> A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<in> carrier_vec n", "using insert"], ["proof (prove)\nusing this:\n  f \\<in> A \\<rightarrow> carrier_vec n\n  finite A\n  a \\<notin> A\n  f \\<in> A \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  dim_vec (finsum V f A) = n\n  f \\<in> insert a A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  f a \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    dim_vec (finsum V f {}) = n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        dim_vec (finsum V f F) = n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec (finsum V f (insert x F)) = n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (finsum V f (insert a A)) = n", "unfolding finsum_insert[OF insert(1) insert(2) f fa]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (f a + finsum V f A) = n", "using insert"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  f \\<in> A \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  dim_vec (finsum V f A) = n\n  f \\<in> insert a A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (f a + finsum V f A) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec (finsum V f (insert a A)) = n\n\ngoal (1 subgoal):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    dim_vec (finsum V f {}) = n", "qed simp"], ["", "lemma lincomb_dim:\n  assumes fin: \"finite X\"\n    and X: \"X \\<subseteq> carrier_vec n\"\n  shows \"dim_vec (lincomb a X) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (lincomb a X) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_vec (lincomb a X) = n", "let ?f = \"\\<lambda>v. a v \\<cdot>\\<^sub>v v\""], ["proof (state)\ngoal (1 subgoal):\n 1. dim_vec (lincomb a X) = n", "have f: \"?f \\<in> X \\<rightarrow> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> X \\<rightarrow> carrier_vec n", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> a x \\<cdot>\\<^sub>v x \\<in> carrier_vec n", "using X"], ["proof (prove)\nusing this:\n  X \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> a x \\<cdot>\\<^sub>v x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> X \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (lincomb a X) = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (lincomb a X) = n", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>X. a v \\<cdot>\\<^sub>v v) = n", "using finsum_dim[OF fin f]"], ["proof (prove)\nusing this:\n  dim_vec (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>X. a v \\<cdot>\\<^sub>v v) = n\n\ngoal (1 subgoal):\n 1. dim_vec (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>X. a v \\<cdot>\\<^sub>v v) = n", "."], ["proof (state)\nthis:\n  dim_vec (lincomb a X) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finsum_index:\n  assumes i: \"i < n\"\n    and f: \"f \\<in> X \\<rightarrow> carrier_vec n\"\n    and X: \"X \\<subseteq> carrier_vec n\"\n  shows \"finsum V f X $ i = sum (\\<lambda>x. f x $ i) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum V f X $ i = (\\<Sum>x\\<in>X. f x $ i)", "using X f"], ["proof (prove)\nusing this:\n  X \\<subseteq> carrier_vec n\n  f \\<in> X \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. finsum V f X $ i = (\\<Sum>x\\<in>X. f x $ i)", "proof (induct X rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<lbrakk>{} \\<subseteq> carrier_vec n;\n     f \\<in> {} \\<rightarrow> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f {} $ i = (\\<Sum>x\\<in>{}. f x $ i)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> carrier_vec n\n  f \\<in> {} \\<rightarrow> carrier_vec n\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<lbrakk>{} \\<subseteq> carrier_vec n;\n     f \\<in> {} \\<rightarrow> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f {} $ i = (\\<Sum>x\\<in>{}. f x $ i)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "then"], ["proof (chain)\npicking this:\n  {} \\<subseteq> carrier_vec n\n  f \\<in> {} \\<rightarrow> carrier_vec n", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> carrier_vec n\n  f \\<in> {} \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. finsum V f {} $ i = (\\<Sum>x\\<in>{}. f x $ i)", "using i"], ["proof (prove)\nusing this:\n  {} \\<subseteq> carrier_vec n\n  f \\<in> {} \\<rightarrow> carrier_vec n\n  i < n\n\ngoal (1 subgoal):\n 1. finsum V f {} $ i = (\\<Sum>x\\<in>{}. f x $ i)", "by simp"], ["proof (state)\nthis:\n  finsum V f {} $ i = (\\<Sum>x\\<in>{}. f x $ i)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "case (insert x X)"], ["proof (state)\nthis:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X \\<subseteq> carrier_vec n;\n   f \\<in> X \\<rightarrow> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> finsum V f X $ i = (\\<Sum>x\\<in>X. f x $ i)\n  insert x X \\<subseteq> carrier_vec n\n  f \\<in> insert x X \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "then"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X \\<subseteq> carrier_vec n;\n   f \\<in> X \\<rightarrow> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> finsum V f X $ i = (\\<Sum>x\\<in>X. f x $ i)\n  insert x X \\<subseteq> carrier_vec n\n  f \\<in> insert x X \\<rightarrow> carrier_vec n", "have Xf: \"finite X\"\n      and xX: \"x \\<notin> X\"\n      and x: \"x \\<in> carrier_vec n\"\n      and X: \"X \\<subseteq> carrier_vec n\"\n      and fx: \"f x \\<in> carrier_vec n\"\n      and f: \"f \\<in> X \\<rightarrow> carrier_vec n\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X \\<subseteq> carrier_vec n;\n   f \\<in> X \\<rightarrow> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> finsum V f X $ i = (\\<Sum>x\\<in>X. f x $ i)\n  insert x X \\<subseteq> carrier_vec n\n  f \\<in> insert x X \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. (finite X &&& x \\<notin> X &&& x \\<in> carrier_vec n) &&&\n    X \\<subseteq> carrier_vec n &&&\n    f x \\<in> carrier_vec n &&& f \\<in> X \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  finite X\n  x \\<notin> X\n  x \\<in> carrier_vec n\n  X \\<subseteq> carrier_vec n\n  f x \\<in> carrier_vec n\n  f \\<in> X \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "have i2: \"i < dim_vec (finsum V f X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec (finsum V f X)", "using i finsum_closed[OF f]"], ["proof (prove)\nusing this:\n  i < n\n  finsum V f X \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < dim_vec (finsum V f X)", "by auto"], ["proof (state)\nthis:\n  i < dim_vec (finsum V f X)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "have ix: \"i < dim_vec x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec x", "using x i"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec n\n  i < n\n\ngoal (1 subgoal):\n 1. i < dim_vec x", "by auto"], ["proof (state)\nthis:\n  i < dim_vec x\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> finsum V f F $ i = (\\<Sum>x\\<in>F. f x $ i);\n        insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f (insert x F) $ i =\n                         (\\<Sum>x\\<in>insert x F. f x $ i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum V f (insert x X) $ i = (\\<Sum>x\\<in>insert x X. f x $ i)", "unfolding finsum_insert[OF Xf xX f fx]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x + finsum V f X) $ i = (\\<Sum>x\\<in>insert x X. f x $ i)", "unfolding sum.insert[OF Xf xX]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x + finsum V f X) $ i = f x $ i + (\\<Sum>x\\<in>X. f x $ i)", "unfolding index_add_vec(1)[OF i2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x $ i + finsum V f X $ i = f x $ i + (\\<Sum>x\\<in>X. f x $ i)", "using insert lincomb_def"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X \\<subseteq> carrier_vec n;\n   f \\<in> X \\<rightarrow> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> finsum V f X $ i = (\\<Sum>x\\<in>X. f x $ i)\n  insert x X \\<subseteq> carrier_vec n\n  f \\<in> insert x X \\<rightarrow> carrier_vec n\n  lincomb ?a ?A =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>?A. ?a v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. f x $ i + finsum V f X $ i = f x $ i + (\\<Sum>x\\<in>X. f x $ i)", "by auto"], ["proof (state)\nthis:\n  finsum V f (insert x X) $ i = (\\<Sum>x\\<in>insert x X. f x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; A \\<subseteq> carrier_vec n;\n        f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> finsum V f A $ i = (\\<Sum>x\\<in>A. f x $ i)", "qed (insert i, auto)"], ["", "lemma lincomb_index:\n  assumes i: \"i < n\"\n    and X: \"X \\<subseteq> carrier_vec n\"\n  shows \"lincomb a X $ i = sum (\\<lambda>x. a x * x $ i) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "let ?f = \"\\<lambda>x. a x \\<cdot>\\<^sub>v x\""], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "have f: \"?f : X \\<rightarrow> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. a x \\<cdot>\\<^sub>v x) \\<in> X \\<rightarrow> carrier_vec n", "using X"], ["proof (prove)\nusing this:\n  X \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. a x \\<cdot>\\<^sub>v x) \\<in> X \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. a x \\<cdot>\\<^sub>v x) \\<in> X \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "have point: \"\\<And>v. v \\<in> X \\<Longrightarrow> (a v \\<cdot>\\<^sub>v v) $ i = a v * v $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> X \\<Longrightarrow> (a v \\<cdot>\\<^sub>v v) $ i = a v * v $ i", "using i X"], ["proof (prove)\nusing this:\n  i < n\n  X \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> X \\<Longrightarrow> (a v \\<cdot>\\<^sub>v v) $ i = a v * v $ i", "by auto"], ["proof (state)\nthis:\n  ?v1 \\<in> X \\<Longrightarrow>\n  (a ?v1 \\<cdot>\\<^sub>v ?v1) $ i = a ?v1 * ?v1 $ i\n\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>X. a v \\<cdot>\\<^sub>v v) $ i =\n    (\\<Sum>x\\<in>X. a x * x $ i)", "unfolding finsum_index[OF i f X]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>X. (a v \\<cdot>\\<^sub>v v) $ i) =\n    (\\<Sum>x\\<in>X. a x * x $ i)", "using point X"], ["proof (prove)\nusing this:\n  ?v1 \\<in> X \\<Longrightarrow>\n  (a ?v1 \\<cdot>\\<^sub>v ?v1) $ i = a ?v1 * ?v1 $ i\n  X \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>X. (a v \\<cdot>\\<^sub>v v) $ i) =\n    (\\<Sum>x\\<in>X. a x * x $ i)", "by simp"], ["proof (state)\nthis:\n  lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_insert: \"set (xs @ [x]) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs @ [x]) = insert x (set xs)", "by simp"], ["", "lemma lincomb_units:\n  assumes i: \"i < n\" \n  shows \"lincomb a (set (unit_vecs n)) $ i = a (unit_vec n i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a (set (unit_vecs n)) $ i = a (unit_vec n i)", "unfolding lincomb_index[OF i unit_vecs_carrier]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs n). a x * x $ i) = a (unit_vec n i)", "unfolding unit_vecs_first"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "let ?f = \"\\<lambda>m i. \\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "have zero:\"\\<And>m j. m \\<le> j \\<Longrightarrow> j < n \\<Longrightarrow> ?f m j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m j.\n       \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n                            a x * x $ j) =\n                         (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m j.\n       \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n                            a x * x $ j) =\n                         (0::'a)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m j.\n       \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n                            a x * x $ j) =\n                         (0::'a)", "show \"\\<And>j. m \\<le> j \\<Longrightarrow> j < n \\<Longrightarrow> ?f m j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n                            a x * x $ j) =\n                         (0::'a)", "proof (induction m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ j) =\n                         (0::'a)\n 2. \\<And>m j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ j) =\n                                     (0::'a);\n        Suc m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ j) =\n                         (0::'a)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>m \\<le> ?j1; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ ?j1) =\n                    (0::'a)\n  Suc m \\<le> j\n  j < n\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ j) =\n                         (0::'a)\n 2. \\<And>m j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ j) =\n                                     (0::'a);\n        Suc m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ j) =\n                         (0::'a)", "hence mj:\"m\\<le>j\" and mj':\"m\\<noteq>j\" and jn:\"j<n\" and mn:\"m<n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<le> ?j1; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ ?j1) =\n                    (0::'a)\n  Suc m \\<le> j\n  j < n\n\ngoal (1 subgoal):\n 1. (m \\<le> j &&& m \\<noteq> j) &&& j < n &&& m < n", "by auto"], ["proof (state)\nthis:\n  m \\<le> j\n  m \\<noteq> j\n  j < n\n  m < n\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ j) =\n                         (0::'a)\n 2. \\<And>m j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ j) =\n                                     (0::'a);\n        Suc m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ j) =\n                         (0::'a)", "hence mem: \"unit_vec n m \\<notin> set (unit_vecs_first n m)\""], ["proof (prove)\nusing this:\n  m \\<le> j\n  m \\<noteq> j\n  j < n\n  m < n\n\ngoal (1 subgoal):\n 1. unit_vec n m \\<notin> set (unit_vecs_first n m)", "apply(subst unit_vecs_first_distinct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>m \\<le> j; m \\<noteq> j; j < n; m < n\\<rbrakk>\n    \\<Longrightarrow> m \\<le> m\n 2. \\<lbrakk>m \\<le> j; m \\<noteq> j; j < n; m < n\\<rbrakk>\n    \\<Longrightarrow> m < n\n 3. \\<lbrakk>m \\<le> j; m \\<noteq> j; j < n; m < n\\<rbrakk>\n    \\<Longrightarrow> \\<not> False", "by auto"], ["proof (state)\nthis:\n  unit_vec n m \\<notin> set (unit_vecs_first n m)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ j) =\n                         (0::'a)\n 2. \\<And>m j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>m \\<le> j; j < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ j) =\n                                     (0::'a);\n        Suc m \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ j) =\n                         (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)). a x * x $ j) = (0::'a)", "unfolding unit_vecs_first.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n m @ [unit_vec n m]). a x * x $ j) =\n    (0::'a)", "unfolding append_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>insert (unit_vec n m) (set (unit_vecs_first n m)).\n       a x * x $ j) =\n    (0::'a)", "unfolding sum.insert[OF finite_set mem]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a (unit_vec n m) * unit_vec n m $ j +\n    (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ j) =\n    (0::'a)", "unfolding index_unit_vec(1)[OF mn jn]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a (unit_vec n m) * (if j = m then 1::'a else (0::'a)) +\n    (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ j) =\n    (0::'a)", "unfolding Suc(1)[OF mj jn]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a (unit_vec n m) * (if j = m then 1::'a else (0::'a)) + (0::'a) =\n    (0::'a)", "using mj'"], ["proof (prove)\nusing this:\n  m \\<noteq> j\n\ngoal (1 subgoal):\n 1. a (unit_vec n m) * (if j = m then 1::'a else (0::'a)) + (0::'a) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)). a x * x $ j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 \\<le> j; j < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ j) =\n                         (0::'a)", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>m \\<le> ?j1; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ ?j1) =\n                    (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?m1 \\<le> ?j1; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n ?m1).\n                       a x * x $ ?j1) =\n                    (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?m1 \\<le> ?j1; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n ?m1).\n                       a x * x $ ?j1) =\n                    (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "have \"i < m \\<Longrightarrow> m \\<le> n \\<Longrightarrow> ?f m i = a (unit_vec n i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ i) =\n                      a (unit_vec n i)", "proof (induction m arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 0; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ i) =\n                         a (unit_vec n i)\n 2. \\<And>m i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < m; m \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ i) =\n                                     a (unit_vec n i);\n        i < Suc m; Suc m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ i) =\n                         a (unit_vec n i)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < m; m \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ ?i1) =\n                    a (unit_vec n ?i1)\n  i < Suc m\n  Suc m \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 0; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ i) =\n                         a (unit_vec n i)\n 2. \\<And>m i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < m; m \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ i) =\n                                     a (unit_vec n i);\n        i < Suc m; Suc m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ i) =\n                         a (unit_vec n i)", "hence iSm: \"i < Suc m\" and i:\"i<n\" and mn: \"m<n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < m; m \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ ?i1) =\n                    a (unit_vec n ?i1)\n  i < Suc m\n  Suc m \\<le> n\n\ngoal (1 subgoal):\n 1. i < Suc m &&& i < n &&& m < n", "by auto"], ["proof (state)\nthis:\n  i < Suc m\n  i < n\n  m < n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 0; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ i) =\n                         a (unit_vec n i)\n 2. \\<And>m i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < m; m \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ i) =\n                                     a (unit_vec n i);\n        i < Suc m; Suc m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ i) =\n                         a (unit_vec n i)", "hence mem: \"unit_vec n m \\<notin> set (unit_vecs_first n m)\""], ["proof (prove)\nusing this:\n  i < Suc m\n  i < n\n  m < n\n\ngoal (1 subgoal):\n 1. unit_vec n m \\<notin> set (unit_vecs_first n m)", "apply(subst unit_vecs_first_distinct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>i < Suc m; i < n; m < n\\<rbrakk> \\<Longrightarrow> m \\<le> m\n 2. \\<lbrakk>i < Suc m; i < n; m < n\\<rbrakk> \\<Longrightarrow> m < n\n 3. \\<lbrakk>i < Suc m; i < n; m < n\\<rbrakk> \\<Longrightarrow> \\<not> False", "by auto"], ["proof (state)\nthis:\n  unit_vec n m \\<notin> set (unit_vecs_first n m)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < 0; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ i) =\n                         a (unit_vec n i)\n 2. \\<And>m i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < m; m \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m).\n  a x * x $ i) =\n                                     a (unit_vec n i);\n        i < Suc m; Suc m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)).\n                            a x * x $ i) =\n                         a (unit_vec n i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)). a x * x $ i) =\n    a (unit_vec n i)", "unfolding unit_vecs_first.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n m @ [unit_vec n m]). a x * x $ i) =\n    a (unit_vec n i)", "unfolding append_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>insert (unit_vec n m) (set (unit_vecs_first n m)).\n       a x * x $ i) =\n    a (unit_vec n i)", "unfolding sum.insert[OF finite_set mem]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a (unit_vec n m) * unit_vec n m $ i +\n    (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ i) =\n    a (unit_vec n i)", "unfolding index_unit_vec(1)[OF mn i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a (unit_vec n m) * (if i = m then 1::'a else (0::'a)) +\n    (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ i) =\n    a (unit_vec n i)", "using zero Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m1 \\<le> ?j1; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n ?m1).\n                       a x * x $ ?j1) =\n                    (0::'a)\n  \\<lbrakk>?i1 < m; m \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ ?i1) =\n                    a (unit_vec n ?i1)\n  i < Suc m\n  Suc m \\<le> n\n\ngoal (1 subgoal):\n 1. a (unit_vec n m) * (if i = m then 1::'a else (0::'a)) +\n    (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ i) =\n    a (unit_vec n i)", "by (cases \"i = m\",auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (unit_vecs_first n (Suc m)). a x * x $ i) =\n  a (unit_vec n i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < 0; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n 0).\n                            a x * x $ i) =\n                         a (unit_vec n i)", "qed auto"], ["proof (state)\nthis:\n  \\<lbrakk>i < m; m \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n m). a x * x $ i) =\n                    a (unit_vec n i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?m3; ?m3 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n ?m3). a x * x $ i) =\n                    a (unit_vec n i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "thus \"?f n i = a (unit_vec n i)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < ?m3; ?m3 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n ?m3). a x * x $ i) =\n                    a (unit_vec n i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < ?m3; ?m3 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>set (unit_vecs_first n ?m3). a x * x $ i) =\n                    a (unit_vec n i)\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (unit_vecs_first n n). a x * x $ i) = a (unit_vec n i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lincomb_coordinates:\n  assumes v: \"v : carrier_vec n\"\n  defines \"a \\<equiv> (\\<lambda>u. v $ (THE i. u = unit_vec n i))\"\n  shows \"lincomb a (set (unit_vecs n)) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a (set (unit_vecs n)) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb a (set (unit_vecs n)) = v", "have a: \"a \\<in> set (unit_vecs n) \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (unit_vecs n) \\<rightarrow> UNIV", "by auto"], ["proof (state)\nthis:\n  a \\<in> set (unit_vecs n) \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. lincomb a (set (unit_vecs n)) = v", "have fvu: \"\\<And>i. i < n \\<Longrightarrow> v $ i = a (unit_vec n i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> v $ i = a (unit_vec n i)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       v $ i = v $ (THE ia. unit_vec n i = unit_vec n ia)", "using unit_vec_eq"], ["proof (prove)\nusing this:\n  ?i < ?n \\<Longrightarrow> (unit_vec ?n ?i = unit_vec ?n ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       v $ i = v $ (THE ia. unit_vec n i = unit_vec n ia)", "by auto"], ["proof (state)\nthis:\n  ?i1 < n \\<Longrightarrow> v $ ?i1 = a (unit_vec n ?i1)\n\ngoal (1 subgoal):\n 1. lincomb a (set (unit_vecs n)) = v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a (set (unit_vecs n)) = v", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       lincomb a (set (unit_vecs n)) $ i = v $ i\n 2. dim_vec (lincomb a (set (unit_vecs n))) = dim_vec v", "unfolding lincomb_dim[OF finite_set unit_vecs_carrier]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       lincomb a (set (unit_vecs n)) $ i = v $ i\n 2. n = dim_vec v", "using v lincomb_units fvu"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  ?i < n \\<Longrightarrow>\n  lincomb ?a (set (unit_vecs n)) $ ?i = ?a (unit_vec n ?i)\n  ?i1 < n \\<Longrightarrow> v $ ?i1 = a (unit_vec n ?i1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       lincomb a (set (unit_vecs n)) $ i = v $ i\n 2. n = dim_vec v", "by auto"], ["proof (state)\nthis:\n  lincomb a (set (unit_vecs n)) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_unit_vecs_is_carrier: \"span (set (unit_vecs n)) = carrier_vec n\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (unit_vecs n)) = carrier_vec n", "proof (rule;rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> local.span (set (unit_vecs n)) \\<Longrightarrow>\n       x \\<in> carrier_vec n\n 2. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       x \\<in> local.span (set (unit_vecs n))", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> local.span (set (unit_vecs n)) \\<Longrightarrow>\n       x \\<in> carrier_vec n\n 2. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       x \\<in> local.span (set (unit_vecs n))", "assume vsU: \"v \\<in> ?L\""], ["proof (state)\nthis:\n  v \\<in> local.span (set (unit_vecs n))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> local.span (set (unit_vecs n)) \\<Longrightarrow>\n       x \\<in> carrier_vec n\n 2. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       x \\<in> local.span (set (unit_vecs n))", "show \"v \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "obtain a\n      where v: \"v = lincomb a (set (unit_vecs n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        v = lincomb a (set (unit_vecs n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using vsU"], ["proof (prove)\nusing this:\n  v \\<in> local.span (set (unit_vecs n))\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        v = lincomb a (set (unit_vecs n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finite_span[OF finite_set unit_vecs_carrier]"], ["proof (prove)\nusing this:\n  v \\<in> {uu_. \\<exists>a. uu_ = lincomb a (set (unit_vecs n))}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        v = lincomb a (set (unit_vecs n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v = lincomb a (set (unit_vecs n))\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = lincomb a (set (unit_vecs n))\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using lincomb_closed[OF unit_vecs_carrier]"], ["proof (prove)\nusing this:\n  v = lincomb a (set (unit_vecs n))\n  lincomb ?a (set (unit_vecs n)) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       x \\<in> local.span (set (unit_vecs n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       x \\<in> local.span (set (unit_vecs n))", "fix v::\"'a vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       x \\<in> local.span (set (unit_vecs n))", "assume v: \"v \\<in> ?R\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       x \\<in> local.span (set (unit_vecs n))", "show \"v \\<in> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> local.span (set (unit_vecs n))", "unfolding span_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {lincomb a A |a A.\n             finite A \\<and> A \\<subseteq> set (unit_vecs n)}", "using lincomb_coordinates[OF v,symmetric]"], ["proof (prove)\nusing this:\n  v =\n  lincomb (\\<lambda>u. v $ (THE i. u = unit_vec n i)) (set (unit_vecs n))\n\ngoal (1 subgoal):\n 1. v \\<in> {lincomb a A |a A.\n             finite A \\<and> A \\<subseteq> set (unit_vecs n)}", "by auto"], ["proof (state)\nthis:\n  v \\<in> local.span (set (unit_vecs n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_dim[simp]: \"fin_dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_dim", "unfolding fin_dim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       finite A \\<and>\n       A \\<subseteq> carrier_vec n \\<and> local.span A = carrier_vec n", "apply (intro eqTrueI exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite ?A\n 2. ?A \\<subseteq> carrier_vec n\n 3. local.span ?A = carrier_vec n", "using span_unit_vecs_is_carrier unit_vecs_carrier"], ["proof (prove)\nusing this:\n  local.span (set (unit_vecs n)) = carrier_vec n\n  set (unit_vecs ?n) \\<subseteq> carrier_vec ?n\n\ngoal (3 subgoals):\n 1. finite ?A\n 2. ?A \\<subseteq> carrier_vec n\n 3. local.span ?A = carrier_vec n", "by auto"], ["", "lemma unit_vecs_basis: \"basis (set (unit_vecs n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis (set (unit_vecs n))", "unfolding basis_def span_unit_vecs_is_carrier"], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set (unit_vecs n)) \\<and>\n    carrier_vec n = carrier_vec n \\<and>\n    set (unit_vecs n) \\<subseteq> carrier_vec n", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. lin_indpt (set (unit_vecs n))\n 2. carrier_vec n = carrier_vec n\n 3. set (unit_vecs n) \\<subseteq> carrier_vec n", "show \"\\<not> lin_dep (set (unit_vecs n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set (unit_vecs n))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "assume \"lin_dep (set (unit_vecs n))\""], ["proof (state)\nthis:\n  lin_dep (set (unit_vecs n))\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "from this[unfolded lin_dep_def]"], ["proof (chain)\npicking this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> set (unit_vecs n) \\<and>\n     True \\<and>\n     lincomb a A = 0\\<^sub>v n \\<and> v \\<in> A \\<and> a v \\<noteq> (0::'a)", "obtain A a v where\n      fin: \"finite A\" and A: \"A \\<subseteq> set (unit_vecs n)\"  \n      and lc: \"lincomb a A = 0\\<^sub>v n\" and v: \"v \\<in> A\" and av: \"a v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> set (unit_vecs n) \\<and>\n     True \\<and>\n     lincomb a A = 0\\<^sub>v n \\<and> v \\<in> A \\<and> a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>A a v.\n        \\<lbrakk>finite A; A \\<subseteq> set (unit_vecs n);\n         lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> set (unit_vecs n)\n  lincomb a A = 0\\<^sub>v n\n  v \\<in> A\n  a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "from v A"], ["proof (chain)\npicking this:\n  v \\<in> A\n  A \\<subseteq> set (unit_vecs n)", "obtain i where i: \"i < n\" and vu: \"v = unit_vec n i\""], ["proof (prove)\nusing this:\n  v \\<in> A\n  A \\<subseteq> set (unit_vecs n)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; v = unit_vec n i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding unit_vecs_def"], ["proof (prove)\nusing this:\n  v \\<in> A\n  A \\<subseteq> set (map (unit_vec n) [0..<n])\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; v = unit_vec n i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  v = unit_vec n i\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "define b where \"b = (\\<lambda> x. if x \\<in> A then a x else 0)\""], ["proof (state)\nthis:\n  b = (\\<lambda>x. if x \\<in> A then a x else (0::'a))\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "have id: \"A \\<union> (set (unit_vecs n) - A) = set (unit_vecs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> (set (unit_vecs n) - A) = set (unit_vecs n)", "using A"], ["proof (prove)\nusing this:\n  A \\<subseteq> set (unit_vecs n)\n\ngoal (1 subgoal):\n 1. A \\<union> (set (unit_vecs n) - A) = set (unit_vecs n)", "by auto"], ["proof (state)\nthis:\n  A \\<union> (set (unit_vecs n) - A) = set (unit_vecs n)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "from lincomb_index[OF i unit_vecs_carrier]"], ["proof (chain)\npicking this:\n  lincomb ?a (set (unit_vecs n)) $ i =\n  (\\<Sum>x\\<in>set (unit_vecs n). ?a x * x $ i)", "have \"lincomb b (set (unit_vecs n)) $ i = (\\<Sum>x\\<in> (A \\<union> (set (unit_vecs n) - A)). b x * x $ i)\""], ["proof (prove)\nusing this:\n  lincomb ?a (set (unit_vecs n)) $ i =\n  (\\<Sum>x\\<in>set (unit_vecs n). ?a x * x $ i)\n\ngoal (1 subgoal):\n 1. lincomb b (set (unit_vecs n)) $ i =\n    (\\<Sum>x\\<in>A \\<union> (set (unit_vecs n) - A). b x * x $ i)", "unfolding id"], ["proof (prove)\nusing this:\n  lincomb ?a (set (unit_vecs n)) $ i =\n  (\\<Sum>x\\<in>set (unit_vecs n). ?a x * x $ i)\n\ngoal (1 subgoal):\n 1. lincomb b (set (unit_vecs n)) $ i =\n    (\\<Sum>x\\<in>set (unit_vecs n). b x * x $ i)", "."], ["proof (state)\nthis:\n  lincomb b (set (unit_vecs n)) $ i =\n  (\\<Sum>x\\<in>A \\<union> (set (unit_vecs n) - A). b x * x $ i)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lincomb b (set (unit_vecs n)) $ i =\n  (\\<Sum>x\\<in>A \\<union> (set (unit_vecs n) - A). b x * x $ i)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>x\\<in> A. b x * x $ i) + (\\<Sum>x\\<in> set (unit_vecs n) - A. b x * x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A \\<union> (set (unit_vecs n) - A). b x * x $ i) =\n    (\\<Sum>x\\<in>A. b x * x $ i) +\n    (\\<Sum>x\\<in>set (unit_vecs n) - A. b x * x $ i)", "by (rule sum.union_disjoint, insert fin, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A \\<union> (set (unit_vecs n) - A). b x * x $ i) =\n  (\\<Sum>x\\<in>A. b x * x $ i) +\n  (\\<Sum>x\\<in>set (unit_vecs n) - A. b x * x $ i)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A \\<union> (set (unit_vecs n) - A). b x * x $ i) =\n  (\\<Sum>x\\<in>A. b x * x $ i) +\n  (\\<Sum>x\\<in>set (unit_vecs n) - A. b x * x $ i)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "have \"(\\<Sum>x\\<in> A. b x * x $ i) = (\\<Sum>x\\<in> A. a x * x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. b x * x $ i) = (\\<Sum>x\\<in>A. a x * x $ i)", "by (rule sum.cong, auto simp: b_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. b x * x $ i) = (\\<Sum>x\\<in>A. a x * x $ i)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. b x * x $ i) = (\\<Sum>x\\<in>A. a x * x $ i)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "have \"\\<dots> = lincomb a A $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. a x * x $ i) = lincomb a A $ i", "by (subst lincomb_index[OF i], insert A unit_vecs_carrier, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. a x * x $ i) = lincomb a A $ i\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. a x * x $ i) = lincomb a A $ i\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a A $ i = (0::'a)", "unfolding lc"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n $ i = (0::'a)", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n $ i = (0::'a)", "by simp"], ["proof (state)\nthis:\n  lincomb a A $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lincomb a A $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "have \"(\\<Sum>x\\<in> set (unit_vecs n) - A. b x * x $ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (unit_vecs n) - A. b x * x $ i) = (0::'a)", "by (rule sum.neutral, auto simp: b_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (unit_vecs n) - A. b x * x $ i) = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lincomb b (set (unit_vecs n)) $ i = (0::'a) + (0::'a)", "have \"lincomb b (set (unit_vecs n)) $ i = 0\""], ["proof (prove)\nusing this:\n  lincomb b (set (unit_vecs n)) $ i = (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. lincomb b (set (unit_vecs n)) $ i = (0::'a)", "by simp"], ["proof (state)\nthis:\n  lincomb b (set (unit_vecs n)) $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "from lincomb_units[OF i, of b, unfolded this]"], ["proof (chain)\npicking this:\n  (0::'a) = b (unit_vec n i)", "have \"b v = 0\""], ["proof (prove)\nusing this:\n  (0::'a) = b (unit_vec n i)\n\ngoal (1 subgoal):\n 1. b v = (0::'a)", "unfolding vu"], ["proof (prove)\nusing this:\n  (0::'a) = b (unit_vec n i)\n\ngoal (1 subgoal):\n 1. b (unit_vec n i) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  b v = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_dep (set (unit_vecs n)) \\<Longrightarrow> False", "with v av"], ["proof (chain)\npicking this:\n  v \\<in> A\n  a v \\<noteq> (0::'a)\n  b v = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  v \\<in> A\n  a v \\<noteq> (0::'a)\n  b v = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "unfolding b_def"], ["proof (prove)\nusing this:\n  v \\<in> A\n  a v \\<noteq> (0::'a)\n  (if v \\<in> A then a v else (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lin_indpt (set (unit_vecs n))\n\ngoal (2 subgoals):\n 1. carrier_vec n = carrier_vec n\n 2. set (unit_vecs n) \\<subseteq> carrier_vec n", "qed (insert unit_vecs_carrier, auto)"], ["", "lemma unit_vecs_length[simp]: \"length (unit_vecs n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (unit_vecs n) = n", "unfolding unit_vecs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (unit_vec n) [0..<n]) = n", "by auto"], ["", "lemma unit_vecs_distinct: \"distinct (unit_vecs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (unit_vecs n)", "unfolding distinct_conv_nth unit_vecs_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<forall>j<n.\n          i \\<noteq> j \\<longrightarrow>\n          unit_vecs n ! i \\<noteq> unit_vecs n ! j", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> unit_vecs n ! i \\<noteq> unit_vecs n ! j", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> unit_vecs n ! i \\<noteq> unit_vecs n ! j", "assume *: \"i < n\" \"j < n\" \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i < n\n  j < n\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> unit_vecs n ! i \\<noteq> unit_vecs n ! j", "show \"unit_vecs n ! i \\<noteq> unit_vecs n ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vecs n ! i \\<noteq> unit_vecs n ! j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. unit_vecs n ! i = unit_vecs n ! j \\<Longrightarrow> False", "assume \"unit_vecs n ! i = unit_vecs n ! j\""], ["proof (state)\nthis:\n  unit_vecs n ! i = unit_vecs n ! j\n\ngoal (1 subgoal):\n 1. unit_vecs n ! i = unit_vecs n ! j \\<Longrightarrow> False", "from arg_cong[OF this, of \"\\<lambda> v. v $ i\"]"], ["proof (chain)\npicking this:\n  unit_vecs n ! i $ i = unit_vecs n ! j $ i", "show False"], ["proof (prove)\nusing this:\n  unit_vecs n ! i $ i = unit_vecs n ! j $ i\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  unit_vecs n ! i $ i = unit_vecs n ! j $ i\n  i < n\n  j < n\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. False", "unfolding unit_vecs_def"], ["proof (prove)\nusing this:\n  map (unit_vec n) [0..<n] ! i $ i = map (unit_vec n) [0..<n] ! j $ i\n  i < n\n  j < n\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unit_vecs n ! i \\<noteq> unit_vecs n ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_is_n: \"dim = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim = n", "unfolding dim_basis[OF finite_set unit_vecs_basis]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (unit_vecs n)) = n", "unfolding distinct_card[OF unit_vecs_distinct]"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (unit_vecs n) = n", "by simp"], ["", "end"], ["", "locale mat_space =\n  vec_space f_ty nc for f_ty::\"'a::field itself\" and nc::\"nat\" +\n  fixes nr :: \"nat\"\nbegin"], ["", "abbreviation M where \"M \\<equiv> ring_mat TYPE('a) nc nr\""], ["", "end"], ["", "context vec_space\nbegin"], ["", "lemma fin_dim_span:\nassumes \"finite A\" \"A \\<subseteq> carrier V\"\nshows \"vectorspace.fin_dim class_ring (vs (span A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span A))", "have \"vectorspace class_ring (span_vs A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (local.span A))", "using assms span_is_subspace subspace_def subspace_is_vs"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> carrier V\n  ?S \\<subseteq> carrier_vec n \\<Longrightarrow>\n  subspace class_ring (local.span ?S) V\n  subspace ?K ?W ?V \\<equiv>\n  vectorspace ?K ?V \\<and> LinearCombinations.submodule ?K ?W ?V\n  subspace class_ring ?W V \\<Longrightarrow> vectorspace class_ring (vs ?W)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (local.span A))", "by simp"], ["proof (state)\nthis:\n  vectorspace class_ring (vs (local.span A))\n\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span A))", "have \"A \\<subseteq> span A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> local.span A", "using assms in_own_span"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> carrier V\n  ?S \\<subseteq> carrier_vec n \\<Longrightarrow>\n  ?S \\<subseteq> local.span ?S\n\ngoal (1 subgoal):\n 1. A \\<subseteq> local.span A", "by simp"], ["proof (state)\nthis:\n  A \\<subseteq> local.span A\n\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span A))", "have \"submodule class_ring (span A) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LinearCombinations.submodule class_ring (local.span A) V", "using assms span_is_submodule"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> carrier V\n  ?S \\<subseteq> carrier_vec n \\<Longrightarrow>\n  LinearCombinations.submodule class_ring (local.span ?S) V\n\ngoal (1 subgoal):\n 1. LinearCombinations.submodule class_ring (local.span A) V", "by simp"], ["proof (state)\nthis:\n  LinearCombinations.submodule class_ring (local.span A) V\n\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span A))", "have \"LinearCombinations.module.span class_ring (vs (span A)) A = carrier (vs (span A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LinearCombinations.module.span class_ring (vs (local.span A)) A =\n    carrier (vs (local.span A))", "using  span_li_not_depend(1)[OF \\<open>A \\<subseteq> span A\\<close> \\<open>submodule class_ring (span A) V\\<close>]"], ["proof (prove)\nusing this:\n  LinearCombinations.module.span class_ring (vs (local.span A)) A =\n  local.span A\n\ngoal (1 subgoal):\n 1. LinearCombinations.module.span class_ring (vs (local.span A)) A =\n    carrier (vs (local.span A))", "by auto"], ["proof (state)\nthis:\n  LinearCombinations.module.span class_ring (vs (local.span A)) A =\n  carrier (vs (local.span A))\n\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span A))", "then"], ["proof (chain)\npicking this:\n  LinearCombinations.module.span class_ring (vs (local.span A)) A =\n  carrier (vs (local.span A))", "show ?thesis"], ["proof (prove)\nusing this:\n  LinearCombinations.module.span class_ring (vs (local.span A)) A =\n  carrier (vs (local.span A))\n\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span A))", "unfolding vectorspace.fin_dim_def[OF \\<open>vectorspace class_ring (span_vs A)\\<close>]"], ["proof (prove)\nusing this:\n  LinearCombinations.module.span class_ring (vs (local.span A)) A =\n  carrier (vs (local.span A))\n\ngoal (1 subgoal):\n 1. \\<exists>Aa.\n       finite Aa \\<and>\n       Aa \\<subseteq> carrier (vs (local.span A)) \\<and>\n       LinearCombinations.module.span class_ring (vs (local.span A)) Aa =\n       carrier (vs (local.span A))", "using List.finite_set \\<open>A \\<subseteq> span A\\<close> \\<open>vectorspace class_ring (vs (span A))\\<close>\n    vec_vs vectorspace.carrier_vs_is_self[OF \\<open>vectorspace class_ring (span_vs A)\\<close>]"], ["proof (prove)\nusing this:\n  LinearCombinations.module.span class_ring (vs (local.span A)) A =\n  carrier (vs (local.span A))\n  finite (set ?xs)\n  A \\<subseteq> local.span A\n  vectorspace class_ring (vs (local.span A))\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n  carrier (vs (local.span A)\\<lparr>carrier := ?W\\<rparr>) = ?W\n\ngoal (1 subgoal):\n 1. \\<exists>Aa.\n       finite Aa \\<and>\n       Aa \\<subseteq> carrier (vs (local.span A)) \\<and>\n       LinearCombinations.module.span class_ring (vs (local.span A)) Aa =\n       carrier (vs (local.span A))", "using assms(1)"], ["proof (prove)\nusing this:\n  LinearCombinations.module.span class_ring (vs (local.span A)) A =\n  carrier (vs (local.span A))\n  finite (set ?xs)\n  A \\<subseteq> local.span A\n  vectorspace class_ring (vs (local.span A))\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n  carrier (vs (local.span A)\\<lparr>carrier := ?W\\<rparr>) = ?W\n  finite A\n\ngoal (1 subgoal):\n 1. \\<exists>Aa.\n       finite Aa \\<and>\n       Aa \\<subseteq> carrier (vs (local.span A)) \\<and>\n       LinearCombinations.module.span class_ring (vs (local.span A)) Aa =\n       carrier (vs (local.span A))", "by auto"], ["proof (state)\nthis:\n  vectorspace.fin_dim class_ring (vs (local.span A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_dim_span_cols:\nassumes \"A \\<in> carrier_mat n nc\"\nshows \"vectorspace.fin_dim class_ring (vs (span (set (cols A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span (set (cols A))))", "using fin_dim_span cols_dim List.finite_set assms carrier_matD(1) module_vec_simps(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?A \\<subseteq> carrier V\\<rbrakk>\n  \\<Longrightarrow> vectorspace.fin_dim class_ring (vs (local.span ?A))\n  set (cols ?A) \\<subseteq> carrier_vec (dim_row ?A)\n  finite (set ?xs)\n  A \\<in> carrier_mat n nc\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_row ?A = ?nr\n  carrier (module_vec ?ty ?n) = carrier_vec ?n\n\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span (set (cols A))))", "by force"], ["", "end"], ["", "context vec_module\nbegin"], ["", "lemma lincomb_list_as_mat_mult:\n  assumes \"\\<forall>w \\<in> set ws. dim_vec w = n\"\n  shows \"lincomb_list c ws = mat_of_cols n ws *\\<^sub>v vec (length ws) c\" (is \"?l ws c = ?r ws c\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list c ws = mat_of_cols n ws *\\<^sub>v vec (length ws) c", "proof (insert assms, induct ws arbitrary: c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<forall>w\\<in>set []. dim_vec w = n \\<Longrightarrow>\n       lincomb_list c [] = mat_of_cols n [] *\\<^sub>v vec (length []) c\n 2. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "case Nil"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set []. dim_vec w = n\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<forall>w\\<in>set []. dim_vec w = n \\<Longrightarrow>\n       lincomb_list c [] = mat_of_cols n [] *\\<^sub>v vec (length []) c\n 2. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "then"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set []. dim_vec w = n", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set []. dim_vec w = n\n\ngoal (1 subgoal):\n 1. lincomb_list c [] = mat_of_cols n [] *\\<^sub>v vec (length []) c", "by (auto simp: mult_mat_vec_def scalar_prod_def)"], ["proof (state)\nthis:\n  lincomb_list c [] = mat_of_cols n [] *\\<^sub>v vec (length []) c\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "case (Cons w ws)"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n  lincomb_list ?c1 ws = mat_of_cols n ws *\\<^sub>v vec (length ws) ?c1\n  \\<forall>w\\<in>set (w # ws). dim_vec w = n\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "{"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n  lincomb_list ?c1 ws = mat_of_cols n ws *\\<^sub>v vec (length ws) ?c1\n  \\<forall>w\\<in>set (w # ws). dim_vec w = n\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "have \"?l (w#ws) c = c 0 \\<cdot>\\<^sub>v w + mat_of_cols n ws *\\<^sub>v vec (length ws) (c \\<circ> Suc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list c (w # ws) =\n    c 0 \\<cdot>\\<^sub>v w +\n    mat_of_cols n ws *\\<^sub>v vec (length ws) (c \\<circ> Suc)", "by (simp add: Cons o_def)"], ["proof (state)\nthis:\n  lincomb_list c (w # ws) =\n  c 0 \\<cdot>\\<^sub>v w +\n  mat_of_cols n ws *\\<^sub>v vec (length ws) (c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "also"], ["proof (state)\nthis:\n  lincomb_list c (w # ws) =\n  c 0 \\<cdot>\\<^sub>v w +\n  mat_of_cols n ws *\\<^sub>v vec (length ws) (c \\<circ> Suc)\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "have \"\\<dots> $ i = ?r (w#ws) c $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c 0 \\<cdot>\\<^sub>v w +\n     mat_of_cols n ws *\\<^sub>v vec (length ws) (c \\<circ> Suc)) $\n    i =\n    (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ i", "using Cons i index_smult_vec"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n  lincomb_list ?c1 ws = mat_of_cols n ws *\\<^sub>v vec (length ws) ?c1\n  \\<forall>w\\<in>set (w # ws). dim_vec w = n\n  i < n\n  ?i < dim_vec ?v \\<Longrightarrow>\n  (?a \\<cdot>\\<^sub>v ?v) $ ?i = ?a * ?v $ ?i\n  dim_vec (?a \\<cdot>\\<^sub>v ?v) = dim_vec ?v\n\ngoal (1 subgoal):\n 1. (c 0 \\<cdot>\\<^sub>v w +\n     mat_of_cols n ws *\\<^sub>v vec (length ws) (c \\<circ> Suc)) $\n    i =\n    (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ i", "by (simp add: mat_of_cols_Cons_index_0 mat_of_cols_Cons_index_Suc o_def vec_Suc mult_mat_vec_def row_def length_Cons)"], ["proof (state)\nthis:\n  (c 0 \\<cdot>\\<^sub>v w +\n   mat_of_cols n ws *\\<^sub>v vec (length ws) (c \\<circ> Suc)) $\n  i =\n  (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ i\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "finally"], ["proof (chain)\npicking this:\n  lincomb_list c (w # ws) $ i =\n  (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ i", "have \"?l (w#ws) c $ i = \\<dots>\""], ["proof (prove)\nusing this:\n  lincomb_list c (w # ws) $ i =\n  (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ i\n\ngoal (1 subgoal):\n 1. lincomb_list c (w # ws) $ i =\n    (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ i", "."], ["proof (state)\nthis:\n  lincomb_list c (w # ws) $ i =\n  (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ i\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "}"], ["proof (state)\nthis:\n  ?i3 < n \\<Longrightarrow>\n  lincomb_list c (w # ws) $ ?i3 =\n  (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ ?i3\n\ngoal (1 subgoal):\n 1. \\<And>a ws c.\n       \\<lbrakk>\\<And>c.\n                   \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n                   lincomb_list c ws =\n                   mat_of_cols n ws *\\<^sub>v vec (length ws) c;\n        \\<forall>w\\<in>set (a # ws). dim_vec w = n\\<rbrakk>\n       \\<Longrightarrow> lincomb_list c (a # ws) =\n                         mat_of_cols n (a # ws) *\\<^sub>v\n                         vec (length (a # ws)) c", "with Cons"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n  lincomb_list ?c1 ws = mat_of_cols n ws *\\<^sub>v vec (length ws) ?c1\n  \\<forall>w\\<in>set (w # ws). dim_vec w = n\n  ?i3 < n \\<Longrightarrow>\n  lincomb_list c (w # ws) $ ?i3 =\n  (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ ?i3", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set ws. dim_vec w = n \\<Longrightarrow>\n  lincomb_list ?c1 ws = mat_of_cols n ws *\\<^sub>v vec (length ws) ?c1\n  \\<forall>w\\<in>set (w # ws). dim_vec w = n\n  ?i3 < n \\<Longrightarrow>\n  lincomb_list c (w # ws) $ ?i3 =\n  (mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c) $ ?i3\n\ngoal (1 subgoal):\n 1. lincomb_list c (w # ws) =\n    mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  lincomb_list c (w # ws) =\n  mat_of_cols n (w # ws) *\\<^sub>v vec (length (w # ws)) c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lincomb_vec_diff_add:\n    assumes A: \"A \\<subseteq> carrier_vec n\"\n    and BA: \"B \\<subseteq> A\" and fin_A: \"finite A\" \n    and f: \"f \\<in> A \\<rightarrow> UNIV\" shows \"lincomb f A = lincomb f (A-B) + lincomb f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B) + lincomb f B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B) + lincomb f B", "have \"A - B \\<union> B = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B \\<union> B = A", "using BA"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. A - B \\<union> B = A", "by auto"], ["proof (state)\nthis:\n  A - B \\<union> B = A\n\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B) + lincomb f B", "hence \"lincomb f A = lincomb f (A - B \\<union> B)\""], ["proof (prove)\nusing this:\n  A - B \\<union> B = A\n\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B \\<union> B)", "by simp"], ["proof (state)\nthis:\n  lincomb f A = lincomb f (A - B \\<union> B)\n\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B) + lincomb f B", "also"], ["proof (state)\nthis:\n  lincomb f A = lincomb f (A - B \\<union> B)\n\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B) + lincomb f B", "have \"... = lincomb f (A-B) + lincomb f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (A - B \\<union> B) = lincomb f (A - B) + lincomb f B", "by (rule lincomb_union, insert assms, auto intro: finite_subset)"], ["proof (state)\nthis:\n  lincomb f (A - B \\<union> B) = lincomb f (A - B) + lincomb f B\n\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B) + lincomb f B", "finally"], ["proof (chain)\npicking this:\n  lincomb f A = lincomb f (A - B) + lincomb f B", "show ?thesis"], ["proof (prove)\nusing this:\n  lincomb f A = lincomb f (A - B) + lincomb f B\n\ngoal (1 subgoal):\n 1. lincomb f A = lincomb f (A - B) + lincomb f B", "."], ["proof (state)\nthis:\n  lincomb f A = lincomb f (A - B) + lincomb f B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_sumlist:\n  assumes \"\\<forall>x\\<in>set xs. dim_vec x = n\"\n  shows \"dim_vec (M.sumlist xs) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (M.sumlist xs) = n", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. dim_vec x = n\n\ngoal (1 subgoal):\n 1. dim_vec (M.sumlist xs) = n", "by (induct xs, auto)"], ["", "lemma sumlist_nth:\n  assumes \"\\<forall>x\\<in>set xs. dim_vec x = n\" and \"i<n\"\n  shows \"(M.sumlist xs) $ i= sum (\\<lambda>j. (xs ! j) $ i) {0..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist xs $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. dim_vec x = n\n  i < n\n\ngoal (1 subgoal):\n 1. M.sumlist xs $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i)", "proof (induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "case (snoc a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n; i < n\\<rbrakk>\n  \\<Longrightarrow> M.sumlist xs $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i)\n  \\<forall>x\\<in>set (xs @ [a]). dim_vec x = n\n  i < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have [simp]: \"x \\<in> carrier_vec n\" if x: \"x\\<in>set xs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec n", "using snoc.prems x"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (xs @ [a]). dim_vec x = n\n  i < n\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec n", "unfolding carrier_vec_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (xs @ [a]). dim_vec x = n\n  i < n\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> {v. dim_vec v = n}", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> set xs \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have [simp]: \"a \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec n", "using snoc.prems"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (xs @ [a]). dim_vec x = n\n  i < n\n\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec n", "unfolding carrier_vec_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (xs @ [a]). dim_vec x = n\n  i < n\n\ngoal (1 subgoal):\n 1. a \\<in> {v. dim_vec v = n}", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have hyp: \"M.sumlist xs $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist xs $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i)", "by (rule snoc.hyps, auto simp add: snoc.prems)"], ["proof (state)\nthis:\n  M.sumlist xs $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have \"M.sumlist (xs @ [a]) = M.sumlist xs + M.sumlist [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (xs @ [a]) = M.sumlist xs + M.sumlist [a]", "by (rule M.sumlist_append, auto simp add: snoc.prems)"], ["proof (state)\nthis:\n  M.sumlist (xs @ [a]) = M.sumlist xs + M.sumlist [a]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "also"], ["proof (state)\nthis:\n  M.sumlist (xs @ [a]) = M.sumlist xs + M.sumlist [a]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have \"... = M.sumlist xs + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist xs + M.sumlist [a] = M.sumlist xs + a", "by auto"], ["proof (state)\nthis:\n  M.sumlist xs + M.sumlist [a] = M.sumlist xs + a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "also"], ["proof (state)\nthis:\n  M.sumlist xs + M.sumlist [a] = M.sumlist xs + a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have \"... $ i = (M.sumlist xs $ i) + (a $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist xs + a) $ i = M.sumlist xs $ i + a $ i", "by (rule index_add_vec(1), auto simp add: snoc.prems)"], ["proof (state)\nthis:\n  (M.sumlist xs + a) $ i = M.sumlist xs $ i + a $ i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "also"], ["proof (state)\nthis:\n  (M.sumlist xs + a) $ i = M.sumlist xs $ i + a $ i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have \"... =  (\\<Sum>j = 0..<length xs. xs ! j $ i) + (a $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist xs $ i + a $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i) + a $ i", "unfolding hyp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<length xs. xs ! j $ i) + a $ i =\n    (\\<Sum>j = 0..<length xs. xs ! j $ i) + a $ i", "by simp"], ["proof (state)\nthis:\n  M.sumlist xs $ i + a $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i) + a $ i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "also"], ["proof (state)\nthis:\n  M.sumlist xs $ i + a $ i = (\\<Sum>j = 0..<length xs. xs ! j $ i) + a $ i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "have \"... = (\\<Sum>j = 0..<length (xs @ [a]). (xs @ [a]) ! j $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<length xs. xs ! j $ i) + a $ i =\n    (\\<Sum>j = 0..<length (xs @ [a]). (xs @ [a]) ! j $ i)", "by (auto, rule sum.cong, auto simp add: nth_append)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<length xs. xs ! j $ i) + a $ i =\n  (\\<Sum>j = 0..<length (xs @ [a]). (xs @ [a]) ! j $ i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set xs. dim_vec x = n;\n                 i < n\\<rbrakk>\n                \\<Longrightarrow> M.sumlist xs $ i =\n                                  (\\<Sum>j = 0..<length xs. xs ! j $ i);\n        \\<forall>x\\<in>set (xs @ [x]). dim_vec x = n; i < n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (xs @ [x]) $ i =\n                         (\\<Sum>j = 0..<length (xs @ [x]).\n                             (xs @ [x]) ! j $ i)", "finally"], ["proof (chain)\npicking this:\n  M.sumlist (xs @ [a]) $ i =\n  (\\<Sum>j = 0..<length (xs @ [a]). (xs @ [a]) ! j $ i)", "show ?case"], ["proof (prove)\nusing this:\n  M.sumlist (xs @ [a]) $ i =\n  (\\<Sum>j = 0..<length (xs @ [a]). (xs @ [a]) ! j $ i)\n\ngoal (1 subgoal):\n 1. M.sumlist (xs @ [a]) $ i =\n    (\\<Sum>j = 0..<length (xs @ [a]). (xs @ [a]) ! j $ i)", "."], ["proof (state)\nthis:\n  M.sumlist (xs @ [a]) $ i =\n  (\\<Sum>j = 0..<length (xs @ [a]). (xs @ [a]) ! j $ i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. dim_vec x = n; i < n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist [] $ i =\n                      (\\<Sum>j = 0..<length []. [] ! j $ i)", "qed auto"], ["", "lemma lincomb_as_lincomb_list_distinct:\n  assumes s: \"set ws \\<subseteq> carrier_vec n\" and d: \"distinct ws\"\n  shows \"lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws", "proof (insert assms, induct ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> carrier_vec n; distinct []\\<rbrakk>\n    \\<Longrightarrow> lincomb f (set []) =\n                      lincomb_list (\\<lambda>i. f ([] ! i)) []\n 2. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> carrier_vec n\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> carrier_vec n; distinct []\\<rbrakk>\n    \\<Longrightarrow> lincomb f (set []) =\n                      lincomb_list (\\<lambda>i. f ([] ! i)) []\n 2. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> carrier_vec n\n  distinct []", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> carrier_vec n\n  distinct []\n\ngoal (1 subgoal):\n 1. lincomb f (set []) = lincomb_list (\\<lambda>i. f ([] ! i)) []", "by auto"], ["proof (state)\nthis:\n  lincomb f (set []) = lincomb_list (\\<lambda>i. f ([] ! i)) []\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "case (Cons a ws)"], ["proof (state)\nthis:\n  \\<lbrakk>set ws \\<subseteq> carrier_vec n; distinct ws\\<rbrakk>\n  \\<Longrightarrow> lincomb f (set ws) =\n                    lincomb_list (\\<lambda>i. f (ws ! i)) ws\n  set (a # ws) \\<subseteq> carrier_vec n\n  distinct (a # ws)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have [simp]: \"\\<And>v. v \\<in> set ws \\<Longrightarrow> v \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set ws \\<Longrightarrow> v \\<in> carrier_vec n", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  set (a # ws) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set ws \\<Longrightarrow> v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?v1 \\<in> set ws \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "then"], ["proof (chain)\npicking this:\n  ?v1 \\<in> set ws \\<Longrightarrow> ?v1 \\<in> carrier_vec n", "have ws: \"set ws \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?v1 \\<in> set ws \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set ws \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set ws \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have hyp: \"lincomb f (set (ws)) = lincomb_list (\\<lambda>i. f (ws ! i)) ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws", "proof (intro Cons.hyps ws)"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ws", "show \"distinct ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ws", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  distinct (a # ws)\n\ngoal (1 subgoal):\n 1. distinct ws", "by auto"], ["proof (state)\nthis:\n  distinct ws\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"(map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws]) = (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws] =\n    map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws", "by (intro nth_equalityI, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws] =\n  map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "with ws"], ["proof (chain)\npicking this:\n  set ws \\<subseteq> carrier_vec n\n  map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws] =\n  map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws", "have sumlist_rw: \"sumlist (map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws])\n    = sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\""], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws] =\n  map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws]) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)", "by (subst (1 2) sumlist_as_summset, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. f (ws ! i) \\<cdot>\\<^sub>v ws ! i) [0..<length ws]) =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"lincomb f (set (a # ws)) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (a # ws)) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)", ".."], ["proof (state)\nthis:\n  lincomb f (set (a # ws)) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "also"], ["proof (state)\nthis:\n  lincomb f (set (a # ws)) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"... = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in> insert a (set ws). f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                     (set ws). f v \\<cdot>\\<^sub>v v)", "by simp"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a (set ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a (set ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"... = (f a \\<cdot>\\<^sub>v a) + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in> (set ws). f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                     (set ws). f v \\<cdot>\\<^sub>v v) =\n    f a \\<cdot>\\<^sub>v a +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)", "by (rule finsum_insert, insert Cons.prems, auto)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                   (set ws). f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                   (set ws). f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"... = f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n    f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws", "using hyp lincomb_def"], ["proof (prove)\nusing this:\n  lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws\n  lincomb ?a ?A =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>?A. ?a v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n    f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "also"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"... = f a \\<cdot>\\<^sub>v a + sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws =\n    f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)", "unfolding lincomb_list_def sumlist_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws =\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "also"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a + lincomb_list (\\<lambda>i. f (ws ! i)) ws =\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"... = sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "let ?a = \"(map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a])\""], ["proof (state)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "have a: \"a \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec n", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  set (a # ws) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "have \"f a \\<cdot>\\<^sub>v a = sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a])", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  set (a # ws) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a])", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a])\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "hence \"f a \\<cdot>\\<^sub>v a + sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) \n      = sumlist ?a + sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\""], ["proof (prove)\nusing this:\n  f a \\<cdot>\\<^sub>v a =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a])\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a]) +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)", "by simp"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a]) +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "also"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a]) +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "have \"... = sumlist (?a @ (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a]) +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist\n     (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a] @\n      map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)", "by (rule sumlist_append[symmetric], auto simp add: a)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a]) +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist\n   (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a] @\n    map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "finally"], ["proof (chain)\npicking this:\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist\n   (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a] @\n    map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)", "show ?thesis"], ["proof (prove)\nusing this:\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist\n   (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) [a] @\n    map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws)\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "also"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) ws) =\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"... = sumlist (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i) [0..<length (a # ws)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n    M.sumlist\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n    M.sumlist\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)])", "have u: \"(map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i) [0..<length (a # ws)]) \n        = (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n     [0..<length (a # ws)] =\n    map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)", "proof (intro nth_equalityI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)]) =\n    length (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n              [0..<length (a # ws)]) \\<Longrightarrow>\n       map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n        [0..<length (a # ws)] !\n       i =\n       map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws) ! i", "case (2 i)"], ["proof (state)\nthis:\n  i < length\n       (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n         [0..<length (a # ws)])\n\ngoal (2 subgoals):\n 1. length\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)]) =\n    length (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n              [0..<length (a # ws)]) \\<Longrightarrow>\n       map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n        [0..<length (a # ws)] !\n       i =\n       map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws) ! i", "thus ?case"], ["proof (prove)\nusing this:\n  i < length\n       (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n         [0..<length (a # ws)])\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n     [0..<length (a # ws)] !\n    i =\n    map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws) ! i", "by (smt length_map map_nth nth_map)"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n   [0..<length (a # ws)] !\n  i =\n  map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws) ! i\n\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)]) =\n    length (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", "qed auto"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n   [0..<length (a # ws)] =\n  map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n    M.sumlist\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n    M.sumlist\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)])", "unfolding u"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n    M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws))", ".."], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n  M.sumlist\n   (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n     [0..<length (a # ws)])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n  M.sumlist\n   (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n     [0..<length (a # ws)])\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "also"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>v. f v \\<cdot>\\<^sub>v v) (a # ws)) =\n  M.sumlist\n   (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n     [0..<length (a # ws)])\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "have \"... = lincomb_list (\\<lambda>i. f ((a # ws) ! i)) (a # ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)]) =\n    lincomb_list (\\<lambda>i. f ((a # ws) ! i)) (a # ws)", "unfolding lincomb_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)]) =\n    M.sumlist\n     (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n       [0..<length (a # ws)])", ".."], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. f ((a # ws) ! i) \\<cdot>\\<^sub>v (a # ws) ! i)\n     [0..<length (a # ws)]) =\n  lincomb_list (\\<lambda>i. f ((a # ws) ! i)) (a # ws)\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       \\<lbrakk>\\<lbrakk>set ws \\<subseteq> carrier_vec n;\n                 distinct ws\\<rbrakk>\n                \\<Longrightarrow> lincomb f (set ws) =\n                                  lincomb_list (\\<lambda>i. f (ws ! i)) ws;\n        set (a # ws) \\<subseteq> carrier_vec n; distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (a # ws)) =\n                         lincomb_list (\\<lambda>i. f ((a # ws) ! i))\n                          (a # ws)", "finally"], ["proof (chain)\npicking this:\n  lincomb f (set (a # ws)) =\n  lincomb_list (\\<lambda>i. f ((a # ws) ! i)) (a # ws)", "show ?case"], ["proof (prove)\nusing this:\n  lincomb f (set (a # ws)) =\n  lincomb_list (\\<lambda>i. f ((a # ws) ! i)) (a # ws)\n\ngoal (1 subgoal):\n 1. lincomb f (set (a # ws)) =\n    lincomb_list (\\<lambda>i. f ((a # ws) ! i)) (a # ws)", "."], ["proof (state)\nthis:\n  lincomb f (set (a # ws)) =\n  lincomb_list (\\<lambda>i. f ((a # ws) ! i)) (a # ws)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale idom_vec = vec_module f_ty for f_ty :: \"'a :: idom itself\"\nbegin"], ["", "lemma lin_dep_cols_imp_det_0':\n  fixes ws\n  defines \"A \\<equiv> mat_of_cols n ws\"\n  assumes dimv_ws: \"\\<forall>w\\<in>set ws. dim_vec w = n\"\n  assumes A: \"A \\<in> carrier_mat n n\" and ld_cols: \"lin_dep (set (cols A))\"\n  shows  \"det A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "proof (cases \"distinct ws\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)\n 2. \\<not> distinct ws \\<Longrightarrow> det A = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> distinct ws\n\ngoal (2 subgoals):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)\n 2. \\<not> distinct ws \\<Longrightarrow> det A = (0::'a)", "obtain i j where ij: \"i\\<noteq>j\" and c: \"col A i = col A j\" and i: \"i<n\" and j: \"j<n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; col A i = col A j; i < n; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False A"], ["proof (prove)\nusing this:\n  \\<not> distinct ws\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; col A i = col A j; i < n; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding A_def"], ["proof (prove)\nusing this:\n  \\<not> distinct ws\n  mat_of_cols n ws \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j;\n         col (mat_of_cols n ws) i = col (mat_of_cols n ws) j; i < n;\n         j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dimv_ws distinct_conv_nth carrier_matD(2) \n        col_mat_of_cols mat_of_cols_carrier(3) nth_mem carrier_vecI)"], ["proof (state)\nthis:\n  i \\<noteq> j\n  col A i = col A j\n  i < n\n  j < n\n\ngoal (2 subgoals):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)\n 2. \\<not> distinct ws \\<Longrightarrow> det A = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "by (rule det_identical_columns[OF A ij i j c])"], ["proof (state)\nthis:\n  det A = (0::'a)\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "case True"], ["proof (state)\nthis:\n  distinct ws\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have d1[simp]: \"\\<And>x. x \\<in> set ws \\<Longrightarrow> x \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set ws \\<Longrightarrow> x \\<in> carrier_vec n", "using dimv_ws"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set ws. dim_vec w = n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set ws \\<Longrightarrow> x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> set ws \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "obtain A' f' v where f'_in: \"f' \\<in> A' \\<rightarrow> UNIV\" \n    and lc_f': \"lincomb f' A' = 0\\<^sub>v n\" and f'_v: \"f' v \\<noteq> 0\"\n    and v_A': \"v \\<in> A'\" and A'_in_rows: \"A' \\<subseteq> set (cols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f' A' v.\n        \\<lbrakk>f' \\<in> A' \\<rightarrow> UNIV;\n         lincomb f' A' = 0\\<^sub>v n; f' v \\<noteq> (0::'a); v \\<in> A';\n         A' \\<subseteq> set (cols A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ld_cols"], ["proof (prove)\nusing this:\n  lin_dep (set (cols A))\n\ngoal (1 subgoal):\n 1. (\\<And>f' A' v.\n        \\<lbrakk>f' \\<in> A' \\<rightarrow> UNIV;\n         lincomb f' A' = 0\\<^sub>v n; f' v \\<noteq> (0::'a); v \\<in> A';\n         A' \\<subseteq> set (cols A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lin_dep_def"], ["proof (prove)\nusing this:\n  \\<exists>Aa a v.\n     finite Aa \\<and>\n     Aa \\<subseteq> set (cols A) \\<and>\n     True \\<and>\n     lincomb a Aa = 0\\<^sub>v n \\<and>\n     v \\<in> Aa \\<and> a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>f' A' v.\n        \\<lbrakk>f' \\<in> A' \\<rightarrow> UNIV;\n         lincomb f' A' = 0\\<^sub>v n; f' v \\<noteq> (0::'a); v \\<in> A';\n         A' \\<subseteq> set (cols A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f' \\<in> A' \\<rightarrow> UNIV\n  lincomb f' A' = 0\\<^sub>v n\n  f' v \\<noteq> (0::'a)\n  v \\<in> A'\n  A' \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "define f where \"f \\<equiv> \\<lambda>x. if x \\<notin> A' then 0 else f' x\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>x. if x \\<notin> A' then 0::'a else f' x\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have f_in: \"f \\<in> (set (cols A)) \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (cols A) \\<rightarrow> UNIV", "using f'_in"], ["proof (prove)\nusing this:\n  f' \\<in> A' \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. f \\<in> set (cols A) \\<rightarrow> UNIV", "by auto"], ["proof (state)\nthis:\n  f \\<in> set (cols A) \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have A'_in_carrier: \"A' \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<subseteq> carrier_vec n", "by (metis (no_types) A'_in_rows A_def cols_dim carrier_matD(1) mat_of_cols_carrier(1) subset_trans)"], ["proof (state)\nthis:\n  A' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have lc_f: \"lincomb f (set (cols A)) = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "have l1: \"lincomb f (set (cols A) - A') = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (cols A) - A') = 0\\<^sub>v n", "by (rule lincomb_zero, auto simp add: f_def, insert A cols_dim, blast)"], ["proof (state)\nthis:\n  lincomb f (set (cols A) - A') = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "have l2: \"lincomb f A' = 0\\<^sub>v n \""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f A' = 0\\<^sub>v n", "using lc_f'"], ["proof (prove)\nusing this:\n  lincomb f' A' = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f A' = 0\\<^sub>v n", "unfolding f_def"], ["proof (prove)\nusing this:\n  lincomb f' A' = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>x. if x \\<notin> A' then 0::'a else f' x) A' =\n    0\\<^sub>v n", "using A'_in_carrier"], ["proof (prove)\nusing this:\n  lincomb f' A' = 0\\<^sub>v n\n  A' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>x. if x \\<notin> A' then 0::'a else f' x) A' =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  lincomb f A' = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "have \"lincomb f (set (cols A)) = lincomb f (set (cols A) - A') + lincomb f A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = lincomb f (set (cols A) - A') + lincomb f A'", "proof (rule lincomb_vec_diff_add)"], ["proof (state)\ngoal (4 subgoals):\n 1. set (cols A) \\<subseteq> carrier_vec n\n 2. A' \\<subseteq> set (cols A)\n 3. finite (set (cols A))\n 4. f \\<in> set (cols A) \\<rightarrow> UNIV", "show \"set (cols A) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols A) \\<subseteq> carrier_vec n", "using A cols_dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  set (cols ?A) \\<subseteq> carrier_vec (dim_row ?A)\n\ngoal (1 subgoal):\n 1. set (cols A) \\<subseteq> carrier_vec n", "by blast"], ["proof (state)\nthis:\n  set (cols A) \\<subseteq> carrier_vec n\n\ngoal (3 subgoals):\n 1. A' \\<subseteq> set (cols A)\n 2. finite (set (cols A))\n 3. f \\<in> set (cols A) \\<rightarrow> UNIV", "show \"A' \\<subseteq> set (cols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<subseteq> set (cols A)", "using A'_in_rows"], ["proof (prove)\nusing this:\n  A' \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. A' \\<subseteq> set (cols A)", "by blast"], ["proof (state)\nthis:\n  A' \\<subseteq> set (cols A)\n\ngoal (2 subgoals):\n 1. finite (set (cols A))\n 2. f \\<in> set (cols A) \\<rightarrow> UNIV", "qed auto"], ["proof (state)\nthis:\n  lincomb f (set (cols A)) = lincomb f (set (cols A) - A') + lincomb f A'\n\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  lincomb f (set (cols A)) = lincomb f (set (cols A) - A') + lincomb f A'\n\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "have \"... =  0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (cols A) - A') + lincomb f A' = 0\\<^sub>v n", "using l1 l2"], ["proof (prove)\nusing this:\n  lincomb f (set (cols A) - A') = 0\\<^sub>v n\n  lincomb f A' = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set (cols A) - A') + lincomb f A' = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  lincomb f (set (cols A) - A') + lincomb f A' = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "finally"], ["proof (chain)\npicking this:\n  lincomb f (set (cols A)) = 0\\<^sub>v n", "show ?thesis"], ["proof (prove)\nusing this:\n  lincomb f (set (cols A)) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set (cols A)) = 0\\<^sub>v n", "."], ["proof (state)\nthis:\n  lincomb f (set (cols A)) = 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lincomb f (set (cols A)) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have v_in: \"v \\<in> (set (cols A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (cols A)", "using v_A' A'_in_rows"], ["proof (prove)\nusing this:\n  v \\<in> A'\n  A' \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. v \\<in> set (cols A)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (cols A)\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have fv: \"f v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v \\<noteq> (0::'a)", "using f'_v v_A'"], ["proof (prove)\nusing this:\n  f' v \\<noteq> (0::'a)\n  v \\<in> A'\n\ngoal (1 subgoal):\n 1. f v \\<noteq> (0::'a)", "unfolding f_def"], ["proof (prove)\nusing this:\n  f' v \\<noteq> (0::'a)\n  v \\<in> A'\n\ngoal (1 subgoal):\n 1. (if v \\<notin> A' then 0::'a else f' v) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  f v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "let ?c = \"(\\<lambda>i. f (ws ! i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have \"lincomb f (set ws) = lincomb_list ?c ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws", "by (rule lincomb_as_lincomb_list_distinct[OF _ True], auto)"], ["proof (state)\nthis:\n  lincomb f (set ws) = lincomb_list (\\<lambda>i. f (ws ! i)) ws\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "have \"\\<exists>v.  v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "proof (rule exI[of _ \" vec (length ws) ?c\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<in> carrier_vec n\n 2. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "show \"vec (length ws) ?c \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<in> carrier_vec n", "using A A_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  A \\<equiv> mat_of_cols n ws\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "have vec_not0: \"vec (length ws) ?c \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "obtain i where ws_i: \"(ws ! i) = v\" and i: \"i<length ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>ws ! i = v; i < length ws\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v_in"], ["proof (prove)\nusing this:\n  v \\<in> set (cols A)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>ws ! i = v; i < length ws\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding A_def"], ["proof (prove)\nusing this:\n  v \\<in> set (cols (mat_of_cols n ws))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>ws ! i = v; i < length ws\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis d1 cols_mat_of_cols in_set_conv_nth subset_eq)"], ["proof (state)\nthis:\n  ws ! i = v\n  i < length ws\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "have \"vec (length ws) ?c $ i = ?c i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) $ i = f (ws ! i)", "by (rule index_vec[OF i])"], ["proof (state)\nthis:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) $ i = f (ws ! i)\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) $ i = f (ws ! i)\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "have \"... = f v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (ws ! i) = f v", "using ws_i"], ["proof (prove)\nusing this:\n  ws ! i = v\n\ngoal (1 subgoal):\n 1. f (ws ! i) = f v", "by simp"], ["proof (state)\nthis:\n  f (ws ! i) = f v\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  f (ws ! i) = f v\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v \\<noteq> (0::'a)", "using fv"], ["proof (prove)\nusing this:\n  f v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. f v \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  f v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "finally"], ["proof (chain)\npicking this:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) $ i \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "using A A_def i"], ["proof (prove)\nusing this:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) $ i \\<noteq> (0::'a)\n  A \\<in> carrier_mat n n\n  A \\<equiv> mat_of_cols n ws\n  i < length ws\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n", "by fastforce"], ["proof (state)\nthis:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "have \"A *\\<^sub>v vec (length ws) ?c = mat_of_cols n ws *\\<^sub>v vec (length ws) ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) =\n    mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i))", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) =\n    mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i))", ".."], ["proof (state)\nthis:\n  A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) =\n  mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i))\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) =\n  mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i))\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "have \"... = lincomb_list ?c ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) =\n    lincomb_list (\\<lambda>i. f (ws ! i)) ws", "by (rule lincomb_list_as_mat_mult[symmetric, OF dimv_ws])"], ["proof (state)\nthis:\n  mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) =\n  lincomb_list (\\<lambda>i. f (ws ! i)) ws\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  mat_of_cols n ws *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) =\n  lincomb_list (\\<lambda>i. f (ws ! i)) ws\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "have \"... = lincomb f (set ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list (\\<lambda>i. f (ws ! i)) ws = lincomb f (set ws)", "by (rule lincomb_as_lincomb_list_distinct[symmetric, OF _ True], auto)"], ["proof (state)\nthis:\n  lincomb_list (\\<lambda>i. f (ws ! i)) ws = lincomb f (set ws)\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  lincomb_list (\\<lambda>i. f (ws ! i)) ws = lincomb f (set ws)\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "have \"... =  0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set ws) = 0\\<^sub>v n", "using lc_f"], ["proof (prove)\nusing this:\n  lincomb f (set (cols A)) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set ws) = 0\\<^sub>v n", "unfolding A_def"], ["proof (prove)\nusing this:\n  lincomb f (set (cols (mat_of_cols n ws))) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set ws) = 0\\<^sub>v n", "using A"], ["proof (prove)\nusing this:\n  lincomb f (set (cols (mat_of_cols n ws))) = 0\\<^sub>v n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. lincomb f (set ws) = 0\\<^sub>v n", "by (simp add: subset_code(1))"], ["proof (state)\nthis:\n  lincomb f (set ws) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "finally"], ["proof (chain)\npicking this:\n  A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "show \"vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "using vec_not0"], ["proof (prove)\nusing this:\n  A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n\n  vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n    A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n", "by fast"], ["proof (state)\nthis:\n  vec (length ws) (\\<lambda>i. f (ws ! i)) \\<noteq> 0\\<^sub>v n \\<and>\n  A *\\<^sub>v vec (length ws) (\\<lambda>i. f (ws ! i)) = 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. distinct ws \\<Longrightarrow> det A = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "unfolding det_0_iff_vec_prod_zero[OF A]"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = 0\\<^sub>v n", "."], ["proof (state)\nthis:\n  det A = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lin_dep_cols_imp_det_0:\n  assumes A: \"A \\<in> carrier_mat n n\" and ld: \"lin_dep (set (cols A))\"\n  shows \"det A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have col_rw: \"(cols (mat_of_cols n (cols A))) = cols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols (mat_of_cols n (cols A)) = cols A", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. cols (mat_of_cols n (cols A)) = cols A", "by auto"], ["proof (state)\nthis:\n  cols (mat_of_cols n (cols A)) = cols A\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "have m: \"mat_of_cols n (cols A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n (cols A) = A", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat_of_cols n (cols A) = A", "by auto"], ["proof (state)\nthis:\n  mat_of_cols n (cols A) = A\n\ngoal (1 subgoal):\n 1. det A = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "by (rule A lin_dep_cols_imp_det_0'[of \"cols A\", unfolded col_rw, unfolded m, OF _ A ld])\n     (metis A cols_dim carrier_matD(1) subsetCE carrier_vecD)"], ["proof (state)\nthis:\n  det A = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lin_dep_rows_imp_det_0:\n  assumes A: \"A \\<in> carrier_mat n n\" and ld: \"lin_dep (set (rows A))\"\n  shows \"det A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = (0::'a)", "by (subst det_transpose[OF A, symmetric], rule lin_dep_cols_imp_det_0, auto simp add: ld A)"], ["", "lemma det_not_0_imp_lin_indpt_rows:\n  assumes A: \"A \\<in> carrier_mat n n\" and det: \"det A \\<noteq> 0\"  \n  shows \"lin_indpt (set (rows A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set (rows A))", "using lin_dep_rows_imp_det_0[OF A] det"], ["proof (prove)\nusing this:\n  lin_dep (set (rows A)) \\<Longrightarrow> det A = (0::'a)\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (rows A))", "by auto"], ["", "lemma upper_triangular_imp_lin_indpt_rows:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and diag: \"0 \\<notin> set (diag_mat A)\"\n  shows \"lin_indpt (set (rows A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set (rows A))", "using det_not_0_imp_lin_indpt_rows upper_triangular_imp_det_eq_0_iff assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat n n; det ?A \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> lin_indpt (set (rows ?A))\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; upper_triangular ?A\\<rbrakk>\n  \\<Longrightarrow> (det ?A = (0::?'a)) = ((0::?'a) \\<in> set (diag_mat ?A))\n  A \\<in> carrier_mat n n\n  upper_triangular A\n  (0::'a) \\<notin> set (diag_mat A)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (rows A))", "by auto"], ["", "(* Connection from set-based to list-based *)"], ["", "lemma lincomb_as_lincomb_list:\n  fixes ws f\n  assumes s: \"set ws \\<subseteq> carrier_vec n\"\n  shows \"lincomb f (set ws) = lincomb_list (\\<lambda>i. if \\<exists>j<i. ws!i = ws!j then 0 else f (ws ! i)) ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set ws) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws", "using assms"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lincomb f (set ws) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws", "proof (induct ws rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "case (snoc a ws)"], ["proof (state)\nthis:\n  set ws \\<subseteq> carrier_vec n \\<Longrightarrow>\n  lincomb f (set ws) =\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws\n  set (ws @ [a]) \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "let ?f = \"\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0 else f (ws ! i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "let ?g = \"\\<lambda>i. (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0 else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v (ws @ [a]) ! i\""], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "let ?g2= \"(\\<lambda>i. (if \\<exists>j<i. ws ! i = ws ! j then 0 else f (ws ! i)) \\<cdot>\\<^sub>v ws ! i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "have [simp]: \"\\<And>v. v \\<in> set ws \\<Longrightarrow> v \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set ws \\<Longrightarrow> v \\<in> carrier_vec n", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  set (ws @ [a]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set ws \\<Longrightarrow> v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?v1 \\<in> set ws \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  ?v1 \\<in> set ws \\<Longrightarrow> ?v1 \\<in> carrier_vec n", "have ws: \"set ws \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?v1 \\<in> set ws \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set ws \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set ws \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "have hyp: \"lincomb f (set ws) = lincomb_list ?f ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set ws) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws", "by (intro snoc.hyps ws)"], ["proof (state)\nthis:\n  lincomb f (set ws) =\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                lincomb f (set xs) =\n                lincomb_list\n                 (\\<lambda>i.\n                     if \\<exists>j<i. xs ! i = xs ! j then 0::'a\n                     else f (xs ! i))\n                 xs;\n        set (xs @ [x]) \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> lincomb f (set (xs @ [x])) =\n                         lincomb_list\n                          (\\<lambda>i.\n                              if \\<exists>j<i.\n                                    (xs @ [x]) ! i = (xs @ [x]) ! j\n                              then 0::'a else f ((xs @ [x]) ! i))\n                          (xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "proof (cases \"a\\<in>set ws\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "case True"], ["proof (state)\nthis:\n  a \\<in> set ws\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have g_length: \"?g (length ws) = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n     then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n    (ws @ [a]) ! length ws =\n    0\\<^sub>v n", "using True"], ["proof (prove)\nusing this:\n  a \\<in> set ws\n\ngoal (1 subgoal):\n 1. (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n     then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n    (ws @ [a]) ! length ws =\n    0\\<^sub>v n", "by (auto, metis in_set_conv_nth nth_append)"], ["proof (state)\nthis:\n  (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n   then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n  (ws @ [a]) ! length ws =\n  0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"(map ?g [0..<length (ws @ [a])]) = (map ?g [0..<length ws]) @ [?g (length ws)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length (ws @ [a])] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n      then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n     (ws @ [a]) ! length ws]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n    then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n   (ws @ [a]) ! length ws]\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n    then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n   (ws @ [a]) ! length ws]\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = (map ?g [0..<length ws]) @ [0\\<^sub>v n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n      then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n     (ws @ [a]) ! length ws] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n]", "using g_length"], ["proof (prove)\nusing this:\n  (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n   then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n  (ws @ [a]) ! length ws =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n      then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n     (ws @ [a]) ! length ws] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n    then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n   (ws @ [a]) ! length ws] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [0\\<^sub>v n]\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [0\\<^sub>v n]", "have map_rw: \"(map ?g [0..<length (ws @ [a])]) = (map ?g [0..<length ws]) @ [0\\<^sub>v n]\""], ["proof (prove)\nusing this:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [0\\<^sub>v n]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length (ws @ [a])] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n]", "."], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [0\\<^sub>v n]\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"M.sumlist (map ?g2 [0..<length ws]) = M.sumlist (map ?g [0..<length ws])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n               else f (ws ! i)) \\<cdot>\\<^sub>v\n              ws ! i)\n       [0..<length ws]) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws])", "by (rule arg_cong[of _ _ \"M.sumlist\"], intro nth_equalityI, auto simp add: nth_append)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n             else f (ws ! i)) \\<cdot>\\<^sub>v\n            ws ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws])\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n             else f (ws ! i)) \\<cdot>\\<^sub>v\n            ws ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws])\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... =  M.sumlist (map ?g [0..<length ws]) + 0\\<^sub>v n \""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws]) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws]) +\n    0\\<^sub>v n", "by (metis M.r_zero calculation hyp lincomb_closed lincomb_list_def ws)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws]) +\n  0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws]) +\n  0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = M.sumlist (map ?g [0..<length ws] @ [0\\<^sub>v n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws]) +\n    0\\<^sub>v n =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws] @\n      [0\\<^sub>v n])", "by (rule M.sumlist_snoc[symmetric], auto simp add: nth_append)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws]) +\n  0\\<^sub>v n =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n])\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "finally"], ["proof (chain)\npicking this:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n             else f (ws ! i)) \\<cdot>\\<^sub>v\n            ws ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n])", "have summlist_rw: \"M.sumlist (map ?g2 [0..<length ws]) \n      = M.sumlist (map ?g [0..<length ws] @ [0\\<^sub>v n])\""], ["proof (prove)\nusing this:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n             else f (ws ! i)) \\<cdot>\\<^sub>v\n            ws ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n               else f (ws ! i)) \\<cdot>\\<^sub>v\n              ws ! i)\n       [0..<length ws]) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws] @\n      [0\\<^sub>v n])", "."], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n             else f (ws ! i)) \\<cdot>\\<^sub>v\n            ws ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n])\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"lincomb f (set (ws @ [a])) = lincomb f (set ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (ws @ [a])) = lincomb f (set ws)", "using True"], ["proof (prove)\nusing this:\n  a \\<in> set ws\n\ngoal (1 subgoal):\n 1. lincomb f (set (ws @ [a])) = lincomb f (set ws)", "unfolding lincomb_def"], ["proof (prove)\nusing this:\n  a \\<in> set ws\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (ws @ [a]). f v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  lincomb f (set (ws @ [a])) = lincomb f (set ws)\n\ngoal (2 subgoals):\n 1. a \\<in> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])\n 2. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "thus ?thesis"], ["proof (prove)\nusing this:\n  lincomb f (set (ws @ [a])) = lincomb f (set ws)\n\ngoal (1 subgoal):\n 1. lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "unfolding hyp lincomb_list_def map_rw summlist_rw"], ["proof (prove)\nusing this:\n  lincomb f (set (ws @ [a])) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [0\\<^sub>v n])\n\ngoal (1 subgoal):\n 1. lincomb f (set (ws @ [a])) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws] @\n      [0\\<^sub>v n])", "by auto"], ["proof (state)\nthis:\n  lincomb f (set (ws @ [a])) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n       else f ((ws @ [a]) ! i))\n   (ws @ [a])\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "case False"], ["proof (state)\nthis:\n  a \\<notin> set ws\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have g_length: \"?g (length ws) = f a \\<cdot>\\<^sub>v a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n     then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n    (ws @ [a]) ! length ws =\n    f a \\<cdot>\\<^sub>v a", "using False"], ["proof (prove)\nusing this:\n  a \\<notin> set ws\n\ngoal (1 subgoal):\n 1. (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n     then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n    (ws @ [a]) ! length ws =\n    f a \\<cdot>\\<^sub>v a", "by (auto simp add: nth_append)"], ["proof (state)\nthis:\n  (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n   then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n  (ws @ [a]) ! length ws =\n  f a \\<cdot>\\<^sub>v a\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"(map ?g [0..<length (ws @ [a])]) = (map ?g [0..<length ws]) @ [?g (length ws)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length (ws @ [a])] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n      then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n     (ws @ [a]) ! length ws]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n    then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n   (ws @ [a]) ! length ws]\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n    then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n   (ws @ [a]) ! length ws]\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = (map ?g [0..<length ws]) @ [(f a \\<cdot>\\<^sub>v a)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n      then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n     (ws @ [a]) ! length ws] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [f a \\<cdot>\\<^sub>v a]", "using g_length"], ["proof (prove)\nusing this:\n  (if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n   then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n  (ws @ [a]) ! length ws =\n  f a \\<cdot>\\<^sub>v a\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n      then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n     (ws @ [a]) ! length ws] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [f a \\<cdot>\\<^sub>v a]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [(if \\<exists>j<length ws. (ws @ [a]) ! length ws = (ws @ [a]) ! j\n    then 0::'a else f ((ws @ [a]) ! length ws)) \\<cdot>\\<^sub>v\n   (ws @ [a]) ! length ws] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [f a \\<cdot>\\<^sub>v a]\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [f a \\<cdot>\\<^sub>v a]", "have map_rw: \"(map ?g [0..<length (ws @ [a])]) = (map ?g [0..<length ws]) @ [(f a \\<cdot>\\<^sub>v a)]\""], ["proof (prove)\nusing this:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [f a \\<cdot>\\<^sub>v a]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length (ws @ [a])] =\n    map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws] @\n    [f a \\<cdot>\\<^sub>v a]", "."], ["proof (state)\nthis:\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length (ws @ [a])] =\n  map (\\<lambda>i.\n          (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n           else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n          (ws @ [a]) ! i)\n   [0..<length ws] @\n  [f a \\<cdot>\\<^sub>v a]\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have summlist_rw: \"M.sumlist (map ?g2 [0..<length ws]) = M.sumlist (map ?g [0..<length ws])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n               else f (ws ! i)) \\<cdot>\\<^sub>v\n              ws ! i)\n       [0..<length ws]) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n               else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n              (ws @ [a]) ! i)\n       [0..<length ws])", "by (rule arg_cong[of _ _ \"M.sumlist\"], intro nth_equalityI, auto simp add: nth_append)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. ws ! i = ws ! j then 0::'a\n             else f (ws ! i)) \\<cdot>\\<^sub>v\n            ws ! i)\n     [0..<length ws]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n             else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n            (ws @ [a]) ! i)\n     [0..<length ws])\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"lincomb f (set (ws @ [a])) = lincomb f (set (a # ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (ws @ [a])) = lincomb f (set (a # ws))", "by auto"], ["proof (state)\nthis:\n  lincomb f (set (ws @ [a])) = lincomb f (set (a # ws))\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  lincomb f (set (ws @ [a])) = lincomb f (set (a # ws))\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f (set (a # ws)) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)", ".."], ["proof (state)\nthis:\n  lincomb f (set (a # ws)) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  lincomb f (set (a # ws)) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in> insert a (set ws). f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                     (set ws). f v \\<cdot>\\<^sub>v v)", "by simp"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a (set ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set (a # ws). f v \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a (set ws). f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = (f a \\<cdot>\\<^sub>v a) + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in> (set ws). f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                     (set ws). f v \\<cdot>\\<^sub>v v) =\n    f a \\<cdot>\\<^sub>v a +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)", "proof (rule finsum_insert)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (set ws)\n 2. a \\<notin> set ws\n 3. (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n    \\<in> set ws \\<rightarrow> carrier_vec n\n 4. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "show \"finite (set ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set ws)", "by auto"], ["proof (state)\nthis:\n  finite (set ws)\n\ngoal (3 subgoals):\n 1. a \\<notin> set ws\n 2. (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n    \\<in> set ws \\<rightarrow> carrier_vec n\n 3. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "show \"a \\<notin> set ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> set ws", "using False"], ["proof (prove)\nusing this:\n  a \\<notin> set ws\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set ws\n\ngoal (2 subgoals):\n 1. (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n    \\<in> set ws \\<rightarrow> carrier_vec n\n 2. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "show \"(\\<lambda>v. f v \\<cdot>\\<^sub>v v) \\<in> set ws \\<rightarrow> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n    \\<in> set ws \\<rightarrow> carrier_vec n", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  set (ws @ [a]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n    \\<in> set ws \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n  \\<in> set ws \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "show \"f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "using snoc.prems"], ["proof (prove)\nusing this:\n  set (ws @ [a]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                   (set ws). f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert a\n                                   (set ws). f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = (f a \\<cdot>\\<^sub>v a) + lincomb f (set ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n    f a \\<cdot>\\<^sub>v a + lincomb f (set ws)", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n    f a \\<cdot>\\<^sub>v a +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v)", ".."], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a + lincomb f (set ws)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set ws. f v \\<cdot>\\<^sub>v v) =\n  f a \\<cdot>\\<^sub>v a + lincomb f (set ws)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = (f a \\<cdot>\\<^sub>v a) + lincomb_list ?f ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a + lincomb f (set ws) =\n    f a \\<cdot>\\<^sub>v a +\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws", "using hyp"], ["proof (prove)\nusing this:\n  lincomb f (set ws) =\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a + lincomb f (set ws) =\n    f a \\<cdot>\\<^sub>v a +\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a + lincomb f (set ws) =\n  f a \\<cdot>\\<^sub>v a +\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a + lincomb f (set ws) =\n  f a \\<cdot>\\<^sub>v a +\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... =  lincomb_list ?f ws  + (f a \\<cdot>\\<^sub>v a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws +\n    f a \\<cdot>\\<^sub>v a", "using M.add.m_comm lincomb_list_carrier snoc.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier_vec n; ?y \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y = ?y + ?x\n  set ?vs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  lincomb_list ?c ?vs \\<in> carrier_vec n\n  set (ws @ [a]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a +\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws +\n    f a \\<cdot>\\<^sub>v a", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws =\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws +\n  f a \\<cdot>\\<^sub>v a\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "also"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a +\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws =\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws +\n  f a \\<cdot>\\<^sub>v a\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "have \"... = lincomb_list (\\<lambda>i. if \\<exists>j<i. (ws @ [a]) ! i \n      = (ws @ [a]) ! j then 0 else f ((ws @ [a]) ! i)) (ws @ [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n     ws +\n    f a \\<cdot>\\<^sub>v a =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "proof (unfold lincomb_list_def map_rw summlist_rw, rule M.sumlist_snoc[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. set (map (\\<lambda>i.\n                 (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j\n                  then 0::'a else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n                 (ws @ [a]) ! i)\n          [0..<length ws])\n    \\<subseteq> carrier_vec n\n 2. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "show \"set (map ?g [0..<length ws]) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j\n                  then 0::'a else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n                 (ws @ [a]) ! i)\n          [0..<length ws])\n    \\<subseteq> carrier_vec n", "using snoc.prems"], ["proof (prove)\nusing this:\n  set (ws @ [a]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j\n                  then 0::'a else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n                 (ws @ [a]) ! i)\n          [0..<length ws])\n    \\<subseteq> carrier_vec n", "by (auto simp add: nth_append)"], ["proof (state)\nthis:\n  set (map (\\<lambda>i.\n               (if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n                else f ((ws @ [a]) ! i)) \\<cdot>\\<^sub>v\n               (ws @ [a]) ! i)\n        [0..<length ws])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "show \"f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "using snoc.prems"], ["proof (prove)\nusing this:\n  set (ws @ [a]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  f a \\<cdot>\\<^sub>v a \\<in> carrier_vec n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>i. if \\<exists>j<i. ws ! i = ws ! j then 0::'a else f (ws ! i))\n   ws +\n  f a \\<cdot>\\<^sub>v a =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n       else f ((ws @ [a]) ! i))\n   (ws @ [a])\n\ngoal (1 subgoal):\n 1. a \\<notin> set ws \\<Longrightarrow>\n    lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "finally"], ["proof (chain)\npicking this:\n  lincomb f (set (ws @ [a])) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n       else f ((ws @ [a]) ! i))\n   (ws @ [a])", "show ?thesis"], ["proof (prove)\nusing this:\n  lincomb f (set (ws @ [a])) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n       else f ((ws @ [a]) ! i))\n   (ws @ [a])\n\ngoal (1 subgoal):\n 1. lincomb f (set (ws @ [a])) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n         else f ((ws @ [a]) ! i))\n     (ws @ [a])", "."], ["proof (state)\nthis:\n  lincomb f (set (ws @ [a])) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n       else f ((ws @ [a]) ! i))\n   (ws @ [a])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lincomb f (set (ws @ [a])) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. (ws @ [a]) ! i = (ws @ [a]) ! j then 0::'a\n       else f ((ws @ [a]) ! i))\n   (ws @ [a])\n\ngoal (1 subgoal):\n 1. set [] \\<subseteq> carrier_vec n \\<Longrightarrow>\n    lincomb f (set []) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. [] ! i = [] ! j then 0::'a else f ([] ! i))\n     []", "qed auto"], ["", "lemma span_list_as_span:\n  assumes \"set vs \\<subseteq> carrier_vec n\"\n  shows \"span_list vs = span (set vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span_list vs = local.span (set vs)", "using assms"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. span_list vs = local.span (set vs)", "proof (auto simp: span_list_def span_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       set vs \\<subseteq> carrier_vec n \\<Longrightarrow>\n       \\<exists>a A.\n          lincomb_list c vs = lincomb a A \\<and>\n          finite A \\<and> A \\<subseteq> set vs\n 2. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       set vs \\<subseteq> carrier_vec n \\<Longrightarrow>\n       \\<exists>a A.\n          lincomb_list c vs = lincomb a A \\<and>\n          finite A \\<and> A \\<subseteq> set vs\n 2. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "show \"\\<exists>a A. lincomb_list f vs = lincomb a A \\<and> finite A \\<and> A \\<subseteq> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a A.\n       lincomb_list f vs = lincomb a A \\<and>\n       finite A \\<and> A \\<subseteq> set vs", "using assms lincomb_list_as_lincomb"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n  set ?vs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  lincomb_list ?c ?vs = lincomb (mk_coeff ?vs ?c) (set ?vs)\n\ngoal (1 subgoal):\n 1. \\<exists>a A.\n       lincomb_list f vs = lincomb a A \\<and>\n       finite A \\<and> A \\<subseteq> set vs", "by auto"], ["proof (state)\nthis:\n  \\<exists>a A.\n     lincomb_list f vs = lincomb a A \\<and>\n     finite A \\<and> A \\<subseteq> set vs\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "fix f::\"'a vec \\<Rightarrow>'a\" and A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "assume fA: \"finite A\" and A: \"A \\<subseteq> set vs\""], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> set vs\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have [simp]: \"x \\<in> carrier_vec n\" if x: \"x \\<in> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec n", "using A x assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> set vs\n  x \\<in> A\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have [simp]:  \"v \\<in> carrier_vec n\" if v: \"v \\<in> set vs\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using assms v"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?v1 \\<in> set vs \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have set_vs_Un: \"((set vs) - A) \\<union> A = set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set vs - A \\<union> A = set vs", "using A"], ["proof (prove)\nusing this:\n  A \\<subseteq> set vs\n\ngoal (1 subgoal):\n 1. set vs - A \\<union> A = set vs", "by auto"], ["proof (state)\nthis:\n  set vs - A \\<union> A = set vs\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "let ?f = \"(\\<lambda>x. if x\\<in>(set vs) - A then 0 else f x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have f0: \"(\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>(set vs) - A. ?f v \\<cdot>\\<^sub>v v) = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                    A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v) =\n    0\\<^sub>v n", "by (rule M.finsum_all0, auto)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                  A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have \"lincomb f A = lincomb ?f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f A =\n    lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) A", "by (auto simp add: lincomb_def intro!: finsum_cong2)"], ["proof (state)\nthis:\n  lincomb f A =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) A\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "also"], ["proof (state)\nthis:\n  lincomb f A =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) A\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have \"... = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>(set vs) - A. ?f v \\<cdot>\\<^sub>v v) + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. ?f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) A =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                    A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v) +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v)", "unfolding f0 lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v) =\n    0\\<^sub>v n +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v)", "by auto"], ["proof (state)\nthis:\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) A =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                  A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v) +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v)\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "also"], ["proof (state)\nthis:\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) A =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                  A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v) +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v)\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have \"... = lincomb ?f (((set vs) - A) \\<union> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                    A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v) +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v) =\n    lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x)\n     (set vs - A \\<union> A)", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                    A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v) +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs - A \\<union>\n                                    A. (if v \\<in> set vs - A then 0::'a\n  else f v) \\<cdot>\\<^sub>v\n v)", "by (rule M.finsum_Un_disjoint[symmetric], auto simp add: fA)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                  A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v) +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v) =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x)\n   (set vs - A \\<union> A)\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs -\n                                  A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v) +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. (if v \\<in> set vs - A then 0::'a\nelse f v) \\<cdot>\\<^sub>v\n                                     v) =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x)\n   (set vs - A \\<union> A)\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "have \"... = lincomb ?f (set vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x)\n     (set vs - A \\<union> A) =\n    lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)", "using set_vs_Un"], ["proof (prove)\nusing this:\n  set vs - A \\<union> A = set vs\n\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x)\n     (set vs - A \\<union> A) =\n    lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)", "by auto"], ["proof (state)\nthis:\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x)\n   (set vs - A \\<union> A) =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "finally"], ["proof (chain)\npicking this:\n  lincomb f A =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)", "have \"lincomb f A = lincomb ?f (set vs)\""], ["proof (prove)\nusing this:\n  lincomb f A =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)\n\ngoal (1 subgoal):\n 1. lincomb f A =\n    lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)", "."], ["proof (state)\nthis:\n  lincomb f A =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; finite A;\n        A \\<subseteq> set vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. lincomb a A = lincomb_list c vs", "with lincomb_as_lincomb_list[OF assms]"], ["proof (chain)\npicking this:\n  lincomb ?f (set vs) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. vs ! i = vs ! j then 0::'a else ?f (vs ! i))\n   vs\n  lincomb f A =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)", "show \"\\<exists>c. lincomb f A = lincomb_list c vs\""], ["proof (prove)\nusing this:\n  lincomb ?f (set vs) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. vs ! i = vs ! j then 0::'a else ?f (vs ! i))\n   vs\n  lincomb f A =\n  lincomb (\\<lambda>x. if x \\<in> set vs - A then 0::'a else f x) (set vs)\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb f A = lincomb_list c vs", "by auto"], ["proof (state)\nthis:\n  \\<exists>c. lincomb f A = lincomb_list c vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_spanI[intro]:\n  assumes \"v = lincomb a A\" \"finite A\" \"A \\<subseteq> W\"\n  shows \"v \\<in> span W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> local.span W", "unfolding span_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {lincomb a A |a A. finite A \\<and> A \\<subseteq> W}", "using assms"], ["proof (prove)\nusing this:\n  v = lincomb a A\n  finite A\n  A \\<subseteq> W\n\ngoal (1 subgoal):\n 1. v \\<in> {lincomb a A |a A. finite A \\<and> A \\<subseteq> W}", "by auto"], ["", "lemma in_spanE:\n  assumes \"v \\<in> span W\"\n  shows \"\\<exists> a A. v = lincomb a A \\<and> finite A \\<and> A \\<subseteq> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a A. v = lincomb a A \\<and> finite A \\<and> A \\<subseteq> W", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<exists>a A. v = lincomb a A \\<and> finite A \\<and> A \\<subseteq> W", "unfolding span_def"], ["proof (prove)\nusing this:\n  v \\<in> {lincomb a A |a A. finite A \\<and> A \\<subseteq> W}\n\ngoal (1 subgoal):\n 1. \\<exists>a A. v = lincomb a A \\<and> finite A \\<and> A \\<subseteq> W", "by auto"], ["", "declare in_own_span[intro]"], ["", "lemma smult_in_span:\n  assumes \"W \\<subseteq> carrier_vec n\" and insp: \"x \\<in> span W\"\n  shows \"c \\<cdot>\\<^sub>v x \\<in> span W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x \\<in> local.span W", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x \\<in> local.span W", "from in_spanE[OF insp]"], ["proof (chain)\npicking this:\n  \\<exists>a A. x = lincomb a A \\<and> finite A \\<and> A \\<subseteq> W", "obtain a A where a: \"x = lincomb a A\" \"finite A\" \"A \\<subseteq> W\""], ["proof (prove)\nusing this:\n  \\<exists>a A. x = lincomb a A \\<and> finite A \\<and> A \\<subseteq> W\n\ngoal (1 subgoal):\n 1. (\\<And>a A.\n        \\<lbrakk>x = lincomb a A; finite A; A \\<subseteq> W\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = lincomb a A\n  finite A\n  A \\<subseteq> W\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x \\<in> local.span W", "have \"c \\<cdot>\\<^sub>v x = lincomb (\\<lambda> x. c * a x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x = lincomb (\\<lambda>x. c * a x) A", "using a(1)"], ["proof (prove)\nusing this:\n  x = lincomb a A\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x = lincomb (\\<lambda>x. c * a x) A", "unfolding lincomb_def a"], ["proof (prove)\nusing this:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. c * a v \\<cdot>\\<^sub>v v)", "apply(subst finsum_smult)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v\n v) \\<Longrightarrow>\n    True\n 2. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v\n v) \\<Longrightarrow>\n    (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\n 3. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v\n v) \\<Longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>A. c \\<cdot>\\<^sub>v\n (a x \\<cdot>\\<^sub>v x)) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. c * a v \\<cdot>\\<^sub>v v)", "using assms a"], ["proof (prove)\nusing this:\n  W \\<subseteq> carrier_vec n\n  x \\<in> local.span W\n  x = lincomb a A\n  finite A\n  A \\<subseteq> W\n\ngoal (3 subgoals):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v\n v) \\<Longrightarrow>\n    True\n 2. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v\n v) \\<Longrightarrow>\n    (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\n 3. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v\n v) \\<Longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>A. c \\<cdot>\\<^sub>v\n (a x \\<cdot>\\<^sub>v x)) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. c * a v \\<cdot>\\<^sub>v v)", "by (auto simp:smult_smult_assoc)"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>v x = lincomb (\\<lambda>x. c * a x) A\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x \\<in> local.span W", "thus \"c \\<cdot>\\<^sub>v x \\<in> span W\""], ["proof (prove)\nusing this:\n  c \\<cdot>\\<^sub>v x = lincomb (\\<lambda>x. c * a x) A\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x \\<in> local.span W", "using a(2,3)"], ["proof (prove)\nusing this:\n  c \\<cdot>\\<^sub>v x = lincomb (\\<lambda>x. c * a x) A\n  finite A\n  A \\<subseteq> W\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v x \\<in> local.span W", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>v x \\<in> local.span W\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_subsetI: assumes ws: \"ws \\<subseteq> carrier_vec n\" \n  \"us \\<subseteq> span ws\" \nshows \"span us \\<subseteq> span ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span us \\<subseteq> local.span ws", "by (simp add: assms(1) span_is_submodule span_is_subset subsetI ws)"], ["", "end"], ["", "context vec_space begin"], ["", "sublocale idom_vec"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma sumlist_in_span: assumes W: \"W \\<subseteq> carrier_vec n\"  \n  shows \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> span W) \\<Longrightarrow> sumlist xs \\<in> span W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow>\n        x \\<in> local.span W) \\<Longrightarrow>\n    M.sumlist xs \\<in> local.span W", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> local.span W) \\<Longrightarrow>\n    M.sumlist [] \\<in> local.span W\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "case Nil"], ["proof (state)\nthis:\n  ?x1 \\<in> set [] \\<Longrightarrow> ?x1 \\<in> local.span W\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> local.span W) \\<Longrightarrow>\n    M.sumlist [] \\<in> local.span W\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "thus ?case"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set [] \\<Longrightarrow> ?x1 \\<in> local.span W\n\ngoal (1 subgoal):\n 1. M.sumlist [] \\<in> local.span W", "using W"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set [] \\<Longrightarrow> ?x1 \\<in> local.span W\n  W \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist [] \\<in> local.span W", "by force"], ["proof (state)\nthis:\n  M.sumlist [] \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "case (Cons x xs)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> set xs \\<Longrightarrow>\n      x \\<in> local.span W) \\<Longrightarrow>\n  M.sumlist xs \\<in> local.span W\n  ?x1 \\<in> set (x # xs) \\<Longrightarrow> ?x1 \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "from span_is_subset2[OF W] Cons(2)"], ["proof (chain)\npicking this:\n  local.span W \\<subseteq> carrier_vec n\n  ?x1 \\<in> set (x # xs) \\<Longrightarrow> ?x1 \\<in> local.span W", "have xs: \"x \\<in> carrier_vec n\" \"set xs \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  local.span W \\<subseteq> carrier_vec n\n  ?x1 \\<in> set (x # xs) \\<Longrightarrow> ?x1 \\<in> local.span W\n\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec n &&& set xs \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  x \\<in> carrier_vec n\n  set xs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "from span_add1[OF W Cons(2)[of x] Cons(1)[OF Cons(2)]]"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set (x # xs);\n   \\<And>xa.\n      xa \\<in> set xs \\<Longrightarrow> xa \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> x + M.sumlist xs \\<in> local.span W", "have \"x + sumlist xs \\<in> span W\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set (x # xs);\n   \\<And>xa.\n      xa \\<in> set xs \\<Longrightarrow> xa \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> x + M.sumlist xs \\<in> local.span W\n\ngoal (1 subgoal):\n 1. x + M.sumlist xs \\<in> local.span W", "by auto"], ["proof (state)\nthis:\n  x + M.sumlist xs \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "also"], ["proof (state)\nthis:\n  x + M.sumlist xs \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "have \"x + sumlist xs = sumlist ([x] @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + M.sumlist xs = M.sumlist ([x] @ xs)", "by (subst sumlist_append, insert xs, auto)"], ["proof (state)\nthis:\n  x + M.sumlist xs = M.sumlist ([x] @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> local.span W) \\<Longrightarrow>\n                M.sumlist xs \\<in> local.span W;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # xs) \\<in> local.span W", "finally"], ["proof (chain)\npicking this:\n  M.sumlist ([x] @ xs) \\<in> local.span W", "show ?case"], ["proof (prove)\nusing this:\n  M.sumlist ([x] @ xs) \\<in> local.span W\n\ngoal (1 subgoal):\n 1. M.sumlist (x # xs) \\<in> local.span W", "by simp"], ["proof (state)\nthis:\n  M.sumlist (x # xs) \\<in> local.span W\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_span[simp]:\n  assumes \"W \\<subseteq> carrier_vec n\"\n  shows \"span (span W) = span W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (local.span W) = local.span W", "proof(standard,standard,goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> local.span (local.span W) \\<Longrightarrow>\n       x \\<in> local.span W\n 2. local.span W \\<subseteq> local.span (local.span W)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> local.span (local.span W)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> local.span (local.span W) \\<Longrightarrow>\n       x \\<in> local.span W\n 2. local.span W \\<subseteq> local.span (local.span W)", "with in_spanE"], ["proof (chain)\npicking this:\n  ?v \\<in> local.span ?W \\<Longrightarrow>\n  \\<exists>a A. ?v = lincomb a A \\<and> finite A \\<and> A \\<subseteq> ?W\n  x \\<in> local.span (local.span W)", "obtain a A where a: \"x = lincomb a A\" \"finite A\" \"A \\<subseteq> span W\""], ["proof (prove)\nusing this:\n  ?v \\<in> local.span ?W \\<Longrightarrow>\n  \\<exists>a A. ?v = lincomb a A \\<and> finite A \\<and> A \\<subseteq> ?W\n  x \\<in> local.span (local.span W)\n\ngoal (1 subgoal):\n 1. (\\<And>a A.\n        \\<lbrakk>x = lincomb a A; finite A;\n         A \\<subseteq> local.span W\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = lincomb a A\n  finite A\n  A \\<subseteq> local.span W\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> local.span (local.span W) \\<Longrightarrow>\n       x \\<in> local.span W\n 2. local.span W \\<subseteq> local.span (local.span W)", "from a(3) assms"], ["proof (chain)\npicking this:\n  A \\<subseteq> local.span W\n  W \\<subseteq> carrier_vec n", "have AC:\"A \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  A \\<subseteq> local.span W\n  W \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> local.span (local.span W) \\<Longrightarrow>\n       x \\<in> local.span W\n 2. local.span W \\<subseteq> local.span (local.span W)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> local.span W", "unfolding a(1)[unfolded lincomb_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "proof(insert a(3),atomize (full),rule finite_induct[OF a(2)],goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> local.span W \\<longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{}. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {} \\<subseteq> local.span W \\<longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{}. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> local.span W \\<longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{}. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "using span_zero"], ["proof (prove)\nusing this:\n  0\\<^sub>v n \\<in> local.span ?U\n\ngoal (1 subgoal):\n 1. {} \\<subseteq> local.span W \\<longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{}. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "by auto"], ["proof (state)\nthis:\n  {} \\<subseteq> local.span W \\<longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{}. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "case (2 x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> local.span W \\<longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "{"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> local.span W \\<longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "assume F:\"insert x F \\<subseteq> span W\""], ["proof (state)\nthis:\n  insert x F \\<subseteq> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "hence \"a x \\<cdot>\\<^sub>v x \\<in> span W\""], ["proof (prove)\nusing this:\n  insert x F \\<subseteq> local.span W\n\ngoal (1 subgoal):\n 1. a x \\<cdot>\\<^sub>v x \\<in> local.span W", "by (intro smult_in_span[OF assms],auto)"], ["proof (state)\nthis:\n  a x \\<cdot>\\<^sub>v x \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "hence \"a x \\<cdot>\\<^sub>v x + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v) \\<in> span W\""], ["proof (prove)\nusing this:\n  a x \\<cdot>\\<^sub>v x \\<in> local.span W\n\ngoal (1 subgoal):\n 1. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "using span_add1 F 2 assms"], ["proof (prove)\nusing this:\n  a x \\<cdot>\\<^sub>v x \\<in> local.span W\n  \\<lbrakk>?U \\<subseteq> carrier_vec n; ?v \\<in> local.span ?U;\n   ?w \\<in> local.span ?U\\<rbrakk>\n  \\<Longrightarrow> ?v + ?w \\<in> local.span ?U\n  insert x F \\<subseteq> local.span W\n  finite F\n  x \\<notin> F\n  F \\<subseteq> local.span W \\<longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n  W \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "by auto"], ["proof (state)\nthis:\n  a x \\<cdot>\\<^sub>v x +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "hence \"(\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v) \\<in> span W\""], ["proof (prove)\nusing this:\n  a x \\<cdot>\\<^sub>v x +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "apply(subst M.finsum_insert[OF 2(1,2)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W \\<Longrightarrow>\n    (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> F \\<rightarrow> carrier_vec n\n 2. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W \\<Longrightarrow>\n    a x \\<cdot>\\<^sub>v x \\<in> carrier_vec n\n 3. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W \\<Longrightarrow>\n    a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "using F assms"], ["proof (prove)\nusing this:\n  insert x F \\<subseteq> local.span W\n  W \\<subseteq> carrier_vec n\n\ngoal (3 subgoals):\n 1. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W \\<Longrightarrow>\n    (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> F \\<rightarrow> carrier_vec n\n 2. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W \\<Longrightarrow>\n    a x \\<cdot>\\<^sub>v x \\<in> carrier_vec n\n 3. a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W \\<Longrightarrow>\n    a x \\<cdot>\\<^sub>v x +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "by auto"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "}"], ["proof (state)\nthis:\n  insert x F \\<subseteq> local.span W \\<Longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> local.span W \\<longrightarrow>\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>F. a v \\<cdot>\\<^sub>v v)\n        \\<in> local.span W\\<rbrakk>\n       \\<Longrightarrow> insert x F\n                         \\<subseteq> local.span W \\<longrightarrow>\n                         (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x\n                    F. a v \\<cdot>\\<^sub>v v)\n                         \\<in> local.span W", "then"], ["proof (chain)\npicking this:\n  insert x F \\<subseteq> local.span W \\<Longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W", "show ?case"], ["proof (prove)\nusing this:\n  insert x F \\<subseteq> local.span W \\<Longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal (1 subgoal):\n 1. insert x F \\<subseteq> local.span W \\<longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v)\n    \\<in> local.span W", "by auto"], ["proof (state)\nthis:\n  insert x F \\<subseteq> local.span W \\<longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert x F. a v \\<cdot>\\<^sub>v v)\n  \\<in> local.span W\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> local.span W\n\ngoal (1 subgoal):\n 1. local.span W \\<subseteq> local.span (local.span W)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. local.span W \\<subseteq> local.span (local.span W)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. local.span W \\<subseteq> local.span (local.span W)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span W \\<subseteq> local.span (local.span W)", "using assms"], ["proof (prove)\nusing this:\n  W \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span W \\<subseteq> local.span (local.span W)", "by(intro in_own_span, auto)"], ["proof (state)\nthis:\n  local.span W \\<subseteq> local.span (local.span W)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_triangular_imp_basis:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and diag: \"0 \\<notin> set (diag_mat A)\"\n  shows \"basis (set (rows A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis (set (rows A))", "using upper_triangular_imp_distinct[OF assms]"], ["proof (prove)\nusing this:\n  distinct (rows A)\n\ngoal (1 subgoal):\n 1. basis (set (rows A))", "using upper_triangular_imp_lin_indpt_rows[OF assms] A"], ["proof (prove)\nusing this:\n  distinct (rows A)\n  lin_indpt (set (rows A))\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. basis (set (rows A))", "by (auto intro: dim_li_is_basis simp: distinct_card dim_is_n set_rows_carrier)"], ["", "lemma fin_dim_span_rows:\nassumes A: \"A \\<in> carrier_mat nr n\"\nshows \"vectorspace.fin_dim class_ring (vs (span (set (rows A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.fin_dim class_ring (vs (local.span (set (rows A))))", "proof (rule fin_dim_span)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (set (rows A))\n 2. set (rows A) \\<subseteq> carrier V", "show \"set (rows A) \\<subseteq> carrier V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows A) \\<subseteq> carrier V", "using A rows_carrier[of A]"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n  set (rows A) \\<subseteq> carrier_vec (dim_col A)\n\ngoal (1 subgoal):\n 1. set (rows A) \\<subseteq> carrier V", "unfolding carrier_mat_def"], ["proof (prove)\nusing this:\n  A \\<in> {m. dim_row m = nr \\<and> dim_col m = n}\n  set (rows A) \\<subseteq> carrier_vec (dim_col A)\n\ngoal (1 subgoal):\n 1. set (rows A) \\<subseteq> carrier V", "by auto"], ["proof (state)\nthis:\n  set (rows A) \\<subseteq> carrier V\n\ngoal (1 subgoal):\n 1. finite (set (rows A))", "show \"finite (set (rows A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (rows A))", "by auto"], ["proof (state)\nthis:\n  finite (set (rows A))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"row_space B = span (set (rows B))\""], ["", "definition \"col_space B = span (set (cols B))\""], ["", "lemma row_space_eq_col_space_transpose:\n  shows \"row_space A = col_space A\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space A = col_space A\\<^sup>T", "unfolding col_space_def row_space_def cols_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (rows A)) = local.span (set (rows A))", ".."], ["", "lemma col_space_eq_row_space_transpose:\n  shows \"col_space A = row_space A\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_space A = row_space A\\<^sup>T", "unfolding col_space_def row_space_def Matrix.rows_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (cols A)) = local.span (set (cols A))", ".."], ["", "lemma col_space_eq:\n  assumes A: \"A \\<in> carrier_mat n nc\"\n  shows \"col_space A = {y\\<in>carrier_vec (dim_row A). \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "let ?ws = \"cols A\""], ["proof (state)\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "have set_cols_in: \"set (cols A) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols A) \\<subseteq> carrier_vec n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. set (cols A) \\<subseteq> carrier_vec n", "unfolding cols_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. set (map (col A) [0..<dim_col A]) \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (cols A) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "have \"lincomb f S \\<in> carrier_vec (dim_row A)\" if \"finite S\" and S: \"S \\<subseteq> set (cols A)\" for f S"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f S \\<in> carrier_vec (dim_row A)", "using lincomb_closed A"], ["proof (prove)\nusing this:\n  ?S \\<subseteq> carrier_vec n \\<Longrightarrow>\n  lincomb ?a ?S \\<in> carrier_vec n\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. lincomb f S \\<in> carrier_vec (dim_row A)", "by (metis (full_types) S carrier_matD(1) cols_dim lincomb_closed subsetCE subsetI)"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> lincomb ?f1 ?S1 \\<in> carrier_vec (dim_row A)\n\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> lincomb ?f1 ?S1 \\<in> carrier_vec (dim_row A)\n\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "have \"\\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S\" \n    if fin_S: \"finite S\" and S: \"S \\<subseteq> set (cols A)\" for f S"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "let ?g = \"(\\<lambda>v. if v \\<in> S then f v else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "let ?g' = \"(\\<lambda>i. if \\<exists>j<i. ?ws ! i = ?ws ! j then 0 else ?g (?ws ! i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "let ?Z = \"set ?ws - S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have union: \"set ?ws = S \\<union> ?Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols A) = S \\<union> (set (cols A) - S)", "using S"], ["proof (prove)\nusing this:\n  S \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. set (cols A) = S \\<union> (set (cols A) - S)", "by auto"], ["proof (state)\nthis:\n  set (cols A) = S \\<union> (set (cols A) - S)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have inter: \"S \\<inter> ?Z = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> (set (cols A) - S) = {}", "by auto"], ["proof (state)\nthis:\n  S \\<inter> (set (cols A) - S) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have \"lincomb f S = lincomb ?g S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb f S = lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) S", "by (rule lincomb_cong, insert set_cols_in A S, auto)"], ["proof (state)\nthis:\n  lincomb f S = lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) S\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "also"], ["proof (state)\nthis:\n  lincomb f S = lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) S\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have \"... = lincomb ?g (S \\<union> ?Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) S =\n    lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n     (S \\<union> (set (cols A) - S))", "by (rule lincomb_clean[symmetric],insert set_cols_in A S fin_S, auto)"], ["proof (state)\nthis:\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) S =\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n   (S \\<union> (set (cols A) - S))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "also"], ["proof (state)\nthis:\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) S =\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n   (S \\<union> (set (cols A) - S))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have \"... = lincomb ?g (set ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n     (S \\<union> (set (cols A) - S)) =\n    lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) (set (cols A))", "using union"], ["proof (prove)\nusing this:\n  set (cols A) = S \\<union> (set (cols A) - S)\n\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n     (S \\<union> (set (cols A) - S)) =\n    lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) (set (cols A))", "by auto"], ["proof (state)\nthis:\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n   (S \\<union> (set (cols A) - S)) =\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) (set (cols A))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "also"], ["proof (state)\nthis:\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n   (S \\<union> (set (cols A) - S)) =\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) (set (cols A))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have \"... = lincomb_list ?g' ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a))\n     (set (cols A)) =\n    lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n         else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n     (cols A)", "by (rule lincomb_as_lincomb_list[OF set_cols_in])"], ["proof (state)\nthis:\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) (set (cols A)) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n   (cols A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "also"], ["proof (state)\nthis:\n  lincomb (\\<lambda>v. if v \\<in> S then f v else (0::'a)) (set (cols A)) =\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n   (cols A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have \"... = mat_of_cols n ?ws *\\<^sub>v vec (length ?ws) ?g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n         else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n     (cols A) =\n    mat_of_cols n (cols A) *\\<^sub>v\n    vec (length (cols A))\n     (\\<lambda>i.\n         if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n         else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))", "by (rule lincomb_list_as_mat_mult, insert set_cols_in A, auto)"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n   (cols A) =\n  mat_of_cols n (cols A) *\\<^sub>v\n  vec (length (cols A))\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "also"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n   (cols A) =\n  mat_of_cols n (cols A) *\\<^sub>v\n  vec (length (cols A))\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "have \"... = A *\\<^sub>v (vec (length ?ws) ?g')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n (cols A) *\\<^sub>v\n    vec (length (cols A))\n     (\\<lambda>i.\n         if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n         else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a)) =\n    A *\\<^sub>v\n    vec (length (cols A))\n     (\\<lambda>i.\n         if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n         else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))", "using mat_of_cols_cols A"], ["proof (prove)\nusing this:\n  mat_of_cols (dim_row ?A) (cols ?A) = ?A\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. mat_of_cols n (cols A) *\\<^sub>v\n    vec (length (cols A))\n     (\\<lambda>i.\n         if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n         else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a)) =\n    A *\\<^sub>v\n    vec (length (cols A))\n     (\\<lambda>i.\n         if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n         else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))", "by auto"], ["proof (state)\nthis:\n  mat_of_cols n (cols A) *\\<^sub>v\n  vec (length (cols A))\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a)) =\n  A *\\<^sub>v\n  vec (length (cols A))\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "finally"], ["proof (chain)\npicking this:\n  lincomb f S =\n  A *\\<^sub>v\n  vec (length (cols A))\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  lincomb f S =\n  A *\\<^sub>v\n  vec (length (cols A))\n   (\\<lambda>i.\n       if \\<exists>j<i. cols A ! i = cols A ! j then 0::'a\n       else if cols A ! i \\<in> S then f (cols A ! i) else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = lincomb f S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>carrier_vec (dim_col A).\n                       A *\\<^sub>v x = lincomb ?f1 ?S1\n\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>carrier_vec (dim_col A).\n                       A *\\<^sub>v x = lincomb ?f1 ?S1\n\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "have \"\\<exists>f S. A *\\<^sub>v x = lincomb f S \\<and> finite S \\<and> S \\<subseteq> set (cols A)\" \n    if Ax: \"A *\\<^sub>v x \\<in> carrier_vec (dim_row A)\" and x: \"x \\<in> carrier_vec (dim_col A)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "let ?c = \"\\<lambda>i. x $ i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "have x_vec: \"vec (length ?ws) ?c = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length (cols A)) (($) x) = x", "using x"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec (dim_col A)\n\ngoal (1 subgoal):\n 1. vec (length (cols A)) (($) x) = x", "by auto"], ["proof (state)\nthis:\n  vec (length (cols A)) (($) x) = x\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "have \"A *\\<^sub>v x = mat_of_cols n ?ws *\\<^sub>v vec (length ?ws) ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v x =\n    mat_of_cols n (cols A) *\\<^sub>v vec (length (cols A)) (($) x)", "using mat_of_cols_cols A x_vec"], ["proof (prove)\nusing this:\n  mat_of_cols (dim_row ?A) (cols ?A) = ?A\n  A \\<in> carrier_mat n nc\n  vec (length (cols A)) (($) x) = x\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v x =\n    mat_of_cols n (cols A) *\\<^sub>v vec (length (cols A)) (($) x)", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v x =\n  mat_of_cols n (cols A) *\\<^sub>v vec (length (cols A)) (($) x)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "also"], ["proof (state)\nthis:\n  A *\\<^sub>v x =\n  mat_of_cols n (cols A) *\\<^sub>v vec (length (cols A)) (($) x)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "have \"... = lincomb_list ?c ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n (cols A) *\\<^sub>v vec (length (cols A)) (($) x) =\n    lincomb_list (($) x) (cols A)", "by (rule lincomb_list_as_mat_mult[symmetric], insert set_cols_in A, auto)"], ["proof (state)\nthis:\n  mat_of_cols n (cols A) *\\<^sub>v vec (length (cols A)) (($) x) =\n  lincomb_list (($) x) (cols A)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "also"], ["proof (state)\nthis:\n  mat_of_cols n (cols A) *\\<^sub>v vec (length (cols A)) (($) x) =\n  lincomb_list (($) x) (cols A)\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "have \"... = lincomb (mk_coeff ?ws ?c) (set ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list (($) x) (cols A) =\n    lincomb (mk_coeff (cols A) (($) x)) (set (cols A))", "by (rule lincomb_list_as_lincomb, insert set_cols_in A, auto)"], ["proof (state)\nthis:\n  lincomb_list (($) x) (cols A) =\n  lincomb (mk_coeff (cols A) (($) x)) (set (cols A))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "finally"], ["proof (chain)\npicking this:\n  A *\\<^sub>v x = lincomb (mk_coeff (cols A) (($) x)) (set (cols A))", "show ?thesis"], ["proof (prove)\nusing this:\n  A *\\<^sub>v x = lincomb (mk_coeff (cols A) (($) x)) (set (cols A))\n\ngoal (1 subgoal):\n 1. \\<exists>f S.\n       A *\\<^sub>v x = lincomb f S \\<and>\n       finite S \\<and> S \\<subseteq> set (cols A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f S.\n     A *\\<^sub>v x = lincomb f S \\<and>\n     finite S \\<and> S \\<subseteq> set (cols A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>A *\\<^sub>v ?x1 \\<in> carrier_vec (dim_row A);\n   ?x1 \\<in> carrier_vec (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f S.\n                       A *\\<^sub>v ?x1 = lincomb f S \\<and>\n                       finite S \\<and> S \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> lincomb ?f1 ?S1 \\<in> carrier_vec (dim_row A)\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>carrier_vec (dim_col A).\n                       A *\\<^sub>v x = lincomb ?f1 ?S1\n  \\<lbrakk>A *\\<^sub>v ?x1 \\<in> carrier_vec (dim_row A);\n   ?x1 \\<in> carrier_vec (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f S.\n                       A *\\<^sub>v ?x1 = lincomb f S \\<and>\n                       finite S \\<and> S \\<subseteq> set (cols A)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> lincomb ?f1 ?S1 \\<in> carrier_vec (dim_row A)\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>carrier_vec (dim_col A).\n                       A *\\<^sub>v x = lincomb ?f1 ?S1\n  \\<lbrakk>A *\\<^sub>v ?x1 \\<in> carrier_vec (dim_row A);\n   ?x1 \\<in> carrier_vec (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f S.\n                       A *\\<^sub>v ?x1 = lincomb f S \\<and>\n                       finite S \\<and> S \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. col_space A =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "unfolding col_space_def span_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> lincomb ?f1 ?S1 \\<in> carrier_vec (dim_row A)\n  \\<lbrakk>finite ?S1; ?S1 \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>carrier_vec (dim_col A).\n                       A *\\<^sub>v x = lincomb ?f1 ?S1\n  \\<lbrakk>A *\\<^sub>v ?x1 \\<in> carrier_vec (dim_row A);\n   ?x1 \\<in> carrier_vec (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f S.\n                       A *\\<^sub>v ?x1 = lincomb f S \\<and>\n                       finite S \\<and> S \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. {lincomb a Aa |a Aa. finite Aa \\<and> Aa \\<subseteq> set (cols A)} =\n    {y \\<in> carrier_vec (dim_row A).\n     \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}", "by auto"], ["proof (state)\nthis:\n  col_space A =\n  {y \\<in> carrier_vec (dim_row A).\n   \\<exists>x\\<in>carrier_vec (dim_col A). A *\\<^sub>v x = y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vector_space_row_space: \n  assumes A: \"A \\<in> carrier_mat nr n\"\n  shows \"vectorspace class_ring (vs (row_space A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "have fin: \"finite (set (rows A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (rows A))", "by auto"], ["proof (state)\nthis:\n  finite (set (rows A))\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "have s: \"set (rows A) \\<subseteq> carrier V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows A) \\<subseteq> carrier V", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n\ngoal (1 subgoal):\n 1. set (rows A) \\<subseteq> carrier V", "unfolding rows_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n\ngoal (1 subgoal):\n 1. set (map (row A) [0..<dim_row A]) \\<subseteq> carrier V", "by auto"], ["proof (state)\nthis:\n  set (rows A) \\<subseteq> carrier V\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "have \"span_vs (set (rows A)) = vs (span (set (rows A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs (local.span (set (rows A))) = vs (local.span (set (rows A)))", "by auto"], ["proof (state)\nthis:\n  vs (local.span (set (rows A))) = vs (local.span (set (rows A)))\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "moreover"], ["proof (state)\nthis:\n  vs (local.span (set (rows A))) = vs (local.span (set (rows A)))\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "have \"vectorspace class_ring (span_vs (set (rows A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (local.span (set (rows A))))", "using fin s span_is_subspace subspace_def subspace_is_vs"], ["proof (prove)\nusing this:\n  finite (set (rows A))\n  set (rows A) \\<subseteq> carrier V\n  ?S \\<subseteq> carrier_vec n \\<Longrightarrow>\n  subspace class_ring (local.span ?S) V\n  subspace ?K ?W ?V \\<equiv>\n  vectorspace ?K ?V \\<and> LinearCombinations.submodule ?K ?W ?V\n  subspace class_ring ?W V \\<Longrightarrow> vectorspace class_ring (vs ?W)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (local.span (set (rows A))))", "by simp"], ["proof (state)\nthis:\n  vectorspace class_ring (vs (local.span (set (rows A))))\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "ultimately"], ["proof (chain)\npicking this:\n  vs (local.span (set (rows A))) = vs (local.span (set (rows A)))\n  vectorspace class_ring (vs (local.span (set (rows A))))", "show ?thesis"], ["proof (prove)\nusing this:\n  vs (local.span (set (rows A))) = vs (local.span (set (rows A)))\n  vectorspace class_ring (vs (local.span (set (rows A))))\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (row_space A))", "unfolding row_space_def"], ["proof (prove)\nusing this:\n  vs (local.span (set (rows A))) = vs (local.span (set (rows A)))\n  vectorspace class_ring (vs (local.span (set (rows A))))\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (local.span (set (rows A))))", "by auto"], ["proof (state)\nthis:\n  vectorspace class_ring (vs (row_space A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_space_eq:\n  assumes A: \"A \\<in> carrier_mat nr n\"\n  shows \"row_space A = {w\\<in>carrier_vec (dim_col A). \\<exists>y\\<in>carrier_vec (dim_row A). A\\<^sup>T *\\<^sub>v y = w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space A =\n    {w \\<in> carrier_vec (dim_col A).\n     \\<exists>y\\<in>carrier_vec (dim_row A). A\\<^sup>T *\\<^sub>v y = w}", "using A col_space_eq"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n  ?A \\<in> carrier_mat n ?nc \\<Longrightarrow>\n  col_space ?A =\n  {y \\<in> carrier_vec (dim_row ?A).\n   \\<exists>x\\<in>carrier_vec (dim_col ?A). ?A *\\<^sub>v x = y}\n\ngoal (1 subgoal):\n 1. row_space A =\n    {w \\<in> carrier_vec (dim_col A).\n     \\<exists>y\\<in>carrier_vec (dim_row A). A\\<^sup>T *\\<^sub>v y = w}", "unfolding row_space_eq_col_space_transpose"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n  ?A \\<in> carrier_mat n ?nc \\<Longrightarrow>\n  col_space ?A =\n  {y \\<in> carrier_vec (dim_row ?A).\n   \\<exists>x\\<in>carrier_vec (dim_col ?A). ?A *\\<^sub>v x = y}\n\ngoal (1 subgoal):\n 1. col_space A\\<^sup>T =\n    {w \\<in> carrier_vec (dim_col A).\n     \\<exists>y\\<in>carrier_vec (dim_row A). A\\<^sup>T *\\<^sub>v y = w}", "by auto"], ["", "lemma row_space_is_preserved:\n  assumes inv_P: \"invertible_mat P\" and P: \"P \\<in> carrier_mat m m\" and A: \"A \\<in> carrier_mat m n\"\n  shows \"row_space (P*A) = row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "have At: \"A\\<^sup>T \\<in> carrier_mat n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>T \\<in> carrier_mat n m", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. A\\<^sup>T \\<in> carrier_mat n m", "by auto"], ["proof (state)\nthis:\n  A\\<^sup>T \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "have Pt: \"P\\<^sup>T \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>T \\<in> carrier_mat m m", "using P"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. P\\<^sup>T \\<in> carrier_mat m m", "by auto"], ["proof (state)\nthis:\n  P\\<^sup>T \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "have PA: \"P*A \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * A \\<in> carrier_mat m n", "using P A"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat m m\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. P * A \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  P * A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "have \"w \\<in> row_space A\" if w: \"w \\<in> row_space (P*A)\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "have w_carrier: \"w \\<in> carrier_vec (dim_col (P*A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec (dim_col (P * A))", "using w mult_carrier_mat[OF P A] row_space_eq"], ["proof (prove)\nusing this:\n  w \\<in> row_space (P * A)\n  P * A \\<in> carrier_mat m n\n  ?A \\<in> carrier_mat ?nr n \\<Longrightarrow>\n  row_space ?A =\n  {w \\<in> carrier_vec (dim_col ?A).\n   \\<exists>y\\<in>carrier_vec (dim_row ?A). ?A\\<^sup>T *\\<^sub>v y = w}\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec (dim_col (P * A))", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec (dim_col (P * A))\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "from that and this"], ["proof (chain)\npicking this:\n  w \\<in> row_space (P * A)\n  w \\<in> carrier_vec (dim_col (P * A))", "obtain y where y: \"y \\<in> carrier_vec (dim_row (P * A))\" \n      and w_By: \"w = (P*A)\\<^sup>T *\\<^sub>v y\""], ["proof (prove)\nusing this:\n  w \\<in> row_space (P * A)\n  w \\<in> carrier_vec (dim_col (P * A))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> carrier_vec (dim_row (P * A));\n         w = (P * A)\\<^sup>T *\\<^sub>v y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding row_space_eq[OF PA]"], ["proof (prove)\nusing this:\n  w \\<in> {w \\<in> carrier_vec (dim_col (P * A)).\n           \\<exists>y\\<in>carrier_vec (dim_row (P * A)).\n              (P * A)\\<^sup>T *\\<^sub>v y = w}\n  w \\<in> carrier_vec (dim_col (P * A))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> carrier_vec (dim_row (P * A));\n         w = (P * A)\\<^sup>T *\\<^sub>v y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> carrier_vec (dim_row (P * A))\n  w = (P * A)\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "have ym: \"y \\<in> carrier_vec m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> carrier_vec m", "using y Pt"], ["proof (prove)\nusing this:\n  y \\<in> carrier_vec (dim_row (P * A))\n  P\\<^sup>T \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. y \\<in> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  y \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "have \"w=((P*A)\\<^sup>T) *\\<^sub>v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = (P * A)\\<^sup>T *\\<^sub>v y", "using w_By"], ["proof (prove)\nusing this:\n  w = (P * A)\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w = (P * A)\\<^sup>T *\\<^sub>v y", "."], ["proof (state)\nthis:\n  w = (P * A)\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "also"], ["proof (state)\nthis:\n  w = (P * A)\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "have \"... = (A\\<^sup>T * P\\<^sup>T) *\\<^sub>v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P * A)\\<^sup>T *\\<^sub>v y = A\\<^sup>T * P\\<^sup>T *\\<^sub>v y", "using transpose_mult[OF P A]"], ["proof (prove)\nusing this:\n  (P * A)\\<^sup>T = A\\<^sup>T * P\\<^sup>T\n\ngoal (1 subgoal):\n 1. (P * A)\\<^sup>T *\\<^sub>v y = A\\<^sup>T * P\\<^sup>T *\\<^sub>v y", "by auto"], ["proof (state)\nthis:\n  (P * A)\\<^sup>T *\\<^sub>v y = A\\<^sup>T * P\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "also"], ["proof (state)\nthis:\n  (P * A)\\<^sup>T *\\<^sub>v y = A\\<^sup>T * P\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "have \"... = A\\<^sup>T *\\<^sub>v (P\\<^sup>T *\\<^sub>v y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>T * P\\<^sup>T *\\<^sub>v y =\n    A\\<^sup>T *\\<^sub>v (P\\<^sup>T *\\<^sub>v y)", "by (rule assoc_mult_mat_vec[OF At Pt], insert Pt y, auto)"], ["proof (state)\nthis:\n  A\\<^sup>T * P\\<^sup>T *\\<^sub>v y =\n  A\\<^sup>T *\\<^sub>v (P\\<^sup>T *\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "finally"], ["proof (chain)\npicking this:\n  w = A\\<^sup>T *\\<^sub>v (P\\<^sup>T *\\<^sub>v y)", "show \"w \\<in> row_space A\""], ["proof (prove)\nusing this:\n  w = A\\<^sup>T *\\<^sub>v (P\\<^sup>T *\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. w \\<in> row_space A", "unfolding row_space_eq[OF A]"], ["proof (prove)\nusing this:\n  w = A\\<^sup>T *\\<^sub>v (P\\<^sup>T *\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. w \\<in> {w \\<in> carrier_vec (dim_col A).\n             \\<exists>y\\<in>carrier_vec (dim_row A).\n                A\\<^sup>T *\\<^sub>v y = w}", "using At Pt ym"], ["proof (prove)\nusing this:\n  w = A\\<^sup>T *\\<^sub>v (P\\<^sup>T *\\<^sub>v y)\n  A\\<^sup>T \\<in> carrier_mat n m\n  P\\<^sup>T \\<in> carrier_mat m m\n  y \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. w \\<in> {w \\<in> carrier_vec (dim_col A).\n             \\<exists>y\\<in>carrier_vec (dim_row A).\n                A\\<^sup>T *\\<^sub>v y = w}", "by auto"], ["proof (state)\nthis:\n  w \\<in> row_space A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w1 \\<in> row_space (P * A) \\<Longrightarrow> ?w1 \\<in> row_space A\n\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "moreover"], ["proof (state)\nthis:\n  ?w1 \\<in> row_space (P * A) \\<Longrightarrow> ?w1 \\<in> row_space A\n\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "have \"w \\<in> row_space (P*A)\" if w: \"w \\<in> row_space A\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have w_carrier: \"w \\<in> carrier_vec (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec (dim_col A)", "using w A"], ["proof (prove)\nusing this:\n  w \\<in> row_space A\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec (dim_col A)", "unfolding row_space_eq[OF A]"], ["proof (prove)\nusing this:\n  w \\<in> {w \\<in> carrier_vec (dim_col A).\n           \\<exists>y\\<in>carrier_vec (dim_row A).\n              A\\<^sup>T *\\<^sub>v y = w}\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec (dim_col A)", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec (dim_col A)\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "obtain P' where PP': \"inverts_mat P P'\" and P'P: \"inverts_mat P' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>inverts_mat P P'; inverts_mat P' P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv_P P"], ["proof (prove)\nusing this:\n  invertible_mat P\n  P \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>inverts_mat P P'; inverts_mat P' P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding invertible_mat_def"], ["proof (prove)\nusing this:\n  square_mat P \\<and> (\\<exists>B. inverts_mat P B \\<and> inverts_mat B P)\n  P \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>inverts_mat P P'; inverts_mat P' P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverts_mat P P'\n  inverts_mat P' P\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have P': \"P' \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat m m", "using PP' P'P P"], ["proof (prove)\nusing this:\n  inverts_mat P P'\n  inverts_mat P' P\n  P \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat m m", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  P * P' = 1\\<^sub>m (dim_row P)\n  P' * P = 1\\<^sub>m (dim_row P')\n  P \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat m m", "by (metis carrier_matD(1) carrier_matD(2) carrier_mat_triv index_mult_mat(3) index_one_mat(3))"], ["proof (state)\nthis:\n  P' \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "from that"], ["proof (chain)\npicking this:\n  w \\<in> row_space A", "obtain y where y: \"y \\<in> carrier_vec (dim_row A)\" and \n        w_Ay: \"w = A\\<^sup>T *\\<^sub>v y\""], ["proof (prove)\nusing this:\n  w \\<in> row_space A\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> carrier_vec (dim_row A);\n         w = A\\<^sup>T *\\<^sub>v y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding row_space_eq[OF A]"], ["proof (prove)\nusing this:\n  w \\<in> {w \\<in> carrier_vec (dim_col A).\n           \\<exists>y\\<in>carrier_vec (dim_row A).\n              A\\<^sup>T *\\<^sub>v y = w}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> carrier_vec (dim_row A);\n         w = A\\<^sup>T *\\<^sub>v y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> carrier_vec (dim_row A)\n  w = A\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have Py: \"(P'\\<^sup>T *\\<^sub>v y) \\<in> carrier_vec m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P'\\<^sup>T *\\<^sub>v y \\<in> carrier_vec m", "using P' y A"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat m m\n  y \\<in> carrier_vec (dim_row A)\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. P'\\<^sup>T *\\<^sub>v y \\<in> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  P'\\<^sup>T *\\<^sub>v y \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have \"w = A\\<^sup>T *\\<^sub>v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = A\\<^sup>T *\\<^sub>v y", "using w_Ay"], ["proof (prove)\nusing this:\n  w = A\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w = A\\<^sup>T *\\<^sub>v y", "."], ["proof (state)\nthis:\n  w = A\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "also"], ["proof (state)\nthis:\n  w = A\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have \"... = ((P' * P)*A)\\<^sup>T *\\<^sub>v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>T *\\<^sub>v y = (P' * P * A)\\<^sup>T *\\<^sub>v y", "using P'P left_mult_one_mat A P'"], ["proof (prove)\nusing this:\n  inverts_mat P' P\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> 1\\<^sub>m ?nr * ?A = ?A\n  A \\<in> carrier_mat m n\n  P' \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. A\\<^sup>T *\\<^sub>v y = (P' * P * A)\\<^sup>T *\\<^sub>v y", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  P' * P = 1\\<^sub>m (dim_row P')\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> 1\\<^sub>m ?nr * ?A = ?A\n  A \\<in> carrier_mat m n\n  P' \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. A\\<^sup>T *\\<^sub>v y = (P' * P * A)\\<^sup>T *\\<^sub>v y", "by auto"], ["proof (state)\nthis:\n  A\\<^sup>T *\\<^sub>v y = (P' * P * A)\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "also"], ["proof (state)\nthis:\n  A\\<^sup>T *\\<^sub>v y = (P' * P * A)\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have \"... = ((P' * (P*A))\\<^sup>T) *\\<^sub>v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P' * P * A)\\<^sup>T *\\<^sub>v y = (P' * (P * A))\\<^sup>T *\\<^sub>v y", "using assoc_mult_mat_vec P' P A"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2;\n   ?B \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3;\n   ?v \\<in> carrier_vec ?n\\<^sub>3\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B *\\<^sub>v ?v = ?A *\\<^sub>v (?B *\\<^sub>v ?v)\n  P' \\<in> carrier_mat m m\n  P \\<in> carrier_mat m m\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. (P' * P * A)\\<^sup>T *\\<^sub>v y = (P' * (P * A))\\<^sup>T *\\<^sub>v y", "by auto"], ["proof (state)\nthis:\n  (P' * P * A)\\<^sup>T *\\<^sub>v y = (P' * (P * A))\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "also"], ["proof (state)\nthis:\n  (P' * P * A)\\<^sup>T *\\<^sub>v y = (P' * (P * A))\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have \"... = ((P*A)\\<^sup>T * P'\\<^sup>T) *\\<^sub>v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P' * (P * A))\\<^sup>T *\\<^sub>v y =\n    (P * A)\\<^sup>T * P'\\<^sup>T *\\<^sub>v y", "using transpose_mult P A P' mult_carrier_mat"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> (?A * ?B)\\<^sup>T = ?B\\<^sup>T * ?A\\<^sup>T\n  P \\<in> carrier_mat m m\n  A \\<in> carrier_mat m n\n  P' \\<in> carrier_mat m m\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. (P' * (P * A))\\<^sup>T *\\<^sub>v y =\n    (P * A)\\<^sup>T * P'\\<^sup>T *\\<^sub>v y", "by metis"], ["proof (state)\nthis:\n  (P' * (P * A))\\<^sup>T *\\<^sub>v y =\n  (P * A)\\<^sup>T * P'\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "also"], ["proof (state)\nthis:\n  (P' * (P * A))\\<^sup>T *\\<^sub>v y =\n  (P * A)\\<^sup>T * P'\\<^sup>T *\\<^sub>v y\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "have \"... = (P*A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P * A)\\<^sup>T * P'\\<^sup>T *\\<^sub>v y =\n    (P * A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)", "using assoc_mult_mat_vec A P P' y mult_carrier_mat"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2;\n   ?B \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3;\n   ?v \\<in> carrier_vec ?n\\<^sub>3\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B *\\<^sub>v ?v = ?A *\\<^sub>v (?B *\\<^sub>v ?v)\n  A \\<in> carrier_mat m n\n  P \\<in> carrier_mat m m\n  P' \\<in> carrier_mat m m\n  y \\<in> carrier_vec (dim_row A)\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. (P * A)\\<^sup>T * P'\\<^sup>T *\\<^sub>v y =\n    (P * A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)", "by (smt carrier_matD(1) transpose_carrier_mat)"], ["proof (state)\nthis:\n  (P * A)\\<^sup>T * P'\\<^sup>T *\\<^sub>v y =\n  (P * A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "finally"], ["proof (chain)\npicking this:\n  w = (P * A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)", "show \"w \\<in> row_space (P*A)\""], ["proof (prove)\nusing this:\n  w = (P * A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. w \\<in> row_space (P * A)", "unfolding row_space_eq[OF PA]"], ["proof (prove)\nusing this:\n  w = (P * A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. w \\<in> {w \\<in> carrier_vec (dim_col (P * A)).\n             \\<exists>y\\<in>carrier_vec (dim_row (P * A)).\n                (P * A)\\<^sup>T *\\<^sub>v y = w}", "using Py w_carrier A P"], ["proof (prove)\nusing this:\n  w = (P * A)\\<^sup>T *\\<^sub>v (P'\\<^sup>T *\\<^sub>v y)\n  P'\\<^sup>T *\\<^sub>v y \\<in> carrier_vec m\n  w \\<in> carrier_vec (dim_col A)\n  A \\<in> carrier_mat m n\n  P \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. w \\<in> {w \\<in> carrier_vec (dim_col (P * A)).\n             \\<exists>y\\<in>carrier_vec (dim_row (P * A)).\n                (P * A)\\<^sup>T *\\<^sub>v y = w}", "by fastforce"], ["proof (state)\nthis:\n  w \\<in> row_space (P * A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w1 \\<in> row_space A \\<Longrightarrow> ?w1 \\<in> row_space (P * A)\n\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "ultimately"], ["proof (chain)\npicking this:\n  ?w1 \\<in> row_space (P * A) \\<Longrightarrow> ?w1 \\<in> row_space A\n  ?w1 \\<in> row_space A \\<Longrightarrow> ?w1 \\<in> row_space (P * A)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?w1 \\<in> row_space (P * A) \\<Longrightarrow> ?w1 \\<in> row_space A\n  ?w1 \\<in> row_space A \\<Longrightarrow> ?w1 \\<in> row_space (P * A)\n\ngoal (1 subgoal):\n 1. row_space (P * A) = row_space A", "by auto"], ["proof (state)\nthis:\n  row_space (P * A) = row_space A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context vec_module begin"], ["", "lemma R_sumlist[simp]: \"R.sumlist = sum_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R.sumlist = sum_list", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. R.sumlist x = sum_list x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. R.sumlist x = sum_list x", "show \"R.sumlist xs = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R.sumlist xs = sum_list xs", "by (induct xs, auto)"], ["proof (state)\nthis:\n  R.sumlist xs = sum_list xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumlist_dim: assumes \"\\<And> x. x \\<in> set xs \\<Longrightarrow> x \\<in> carrier_vec n\"\n  shows \"dim_vec (sumlist xs) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (M.sumlist xs) = n", "using sumlist_carrier assms"], ["proof (prove)\nusing this:\n  set ?xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  M.sumlist ?xs \\<in> carrier_vec n\n  ?x1 \\<in> set xs \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (M.sumlist xs) = n", "by fastforce"], ["", "lemma sumlist_vec_index: assumes \"\\<And> x. x \\<in> set xs \\<Longrightarrow> x \\<in> carrier_vec n\"\n  and \"i < n\" \nshows \"sumlist xs $ i = sum_list (map (\\<lambda> x. x $ i) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist xs $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)", "unfolding M.sumlist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)", "using assms(1)"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set xs \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> carrier_vec n) \\<Longrightarrow>\n                foldr (+) xs (0\\<^sub>v n) $ i =\n                (\\<Sum>x\\<leftarrow>xs. x $ i);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> foldr (+) (a # xs) (0\\<^sub>v n) $ i =\n                         (\\<Sum>x\\<leftarrow>a # xs. x $ i)", "case (Cons a xs)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> set xs \\<Longrightarrow>\n      x \\<in> carrier_vec n) \\<Longrightarrow>\n  foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)\n  ?x1 \\<in> set (a # xs) \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> carrier_vec n) \\<Longrightarrow>\n                foldr (+) xs (0\\<^sub>v n) $ i =\n                (\\<Sum>x\\<leftarrow>xs. x $ i);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> foldr (+) (a # xs) (0\\<^sub>v n) $ i =\n                         (\\<Sum>x\\<leftarrow>a # xs. x $ i)", "hence cond:\"\\<And> x. x \\<in> set xs \\<Longrightarrow> x \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set xs \\<Longrightarrow>\n      x \\<in> carrier_vec n) \\<Longrightarrow>\n  foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)\n  ?x1 \\<in> set (a # xs) \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> set xs \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> carrier_vec n) \\<Longrightarrow>\n                foldr (+) xs (0\\<^sub>v n) $ i =\n                (\\<Sum>x\\<leftarrow>xs. x $ i);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> foldr (+) (a # xs) (0\\<^sub>v n) $ i =\n                         (\\<Sum>x\\<leftarrow>a # xs. x $ i)", "from Cons(1)[OF cond]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set xs \\<Longrightarrow> x \\<in> set xs) \\<Longrightarrow>\n  foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)", "have IH:\"foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set xs \\<Longrightarrow> x \\<in> set xs) \\<Longrightarrow>\n  foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)\n\ngoal (1 subgoal):\n 1. foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)", "by auto"], ["proof (state)\nthis:\n  foldr (+) xs (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>xs. x $ i)\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> carrier_vec n) \\<Longrightarrow>\n                foldr (+) xs (0\\<^sub>v n) $ i =\n                (\\<Sum>x\\<leftarrow>xs. x $ i);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> foldr (+) (a # xs) (0\\<^sub>v n) $ i =\n                         (\\<Sum>x\\<leftarrow>a # xs. x $ i)", "have \"(a + foldr (+) xs (0\\<^sub>v n)) $ i = a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + foldr (+) xs (0\\<^sub>v n)) $ i =\n    a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)", "apply(subst index_add_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < dim_vec (foldr (+) xs (0\\<^sub>v n))\n 2. a $ i + foldr (+) xs (0\\<^sub>v n) $ i =\n    a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)", "unfolding IH"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < dim_vec (foldr (+) xs (0\\<^sub>v n))\n 2. a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i) =\n    a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)", "using sumlist_dim[OF cond,unfolded M.sumlist_def] assms"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow> x \\<in> set xs) \\<Longrightarrow>\n  dim_vec (foldr (+) ?xs (0\\<^sub>v n)) = n\n  ?x1 \\<in> set xs \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n  i < n\n\ngoal (2 subgoals):\n 1. i < dim_vec (foldr (+) xs (0\\<^sub>v n))\n 2. a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i) =\n    a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)", "by auto"], ["proof (state)\nthis:\n  (a + foldr (+) xs (0\\<^sub>v n)) $ i =\n  a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    x \\<in> carrier_vec n) \\<Longrightarrow>\n                foldr (+) xs (0\\<^sub>v n) $ i =\n                (\\<Sum>x\\<leftarrow>xs. x $ i);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           x \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> foldr (+) (a # xs) (0\\<^sub>v n) $ i =\n                         (\\<Sum>x\\<leftarrow>a # xs. x $ i)", "then"], ["proof (chain)\npicking this:\n  (a + foldr (+) xs (0\\<^sub>v n)) $ i =\n  a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)", "show ?case"], ["proof (prove)\nusing this:\n  (a + foldr (+) xs (0\\<^sub>v n)) $ i =\n  a $ i + (\\<Sum>x\\<leftarrow>xs. x $ i)\n\ngoal (1 subgoal):\n 1. foldr (+) (a # xs) (0\\<^sub>v n) $ i =\n    (\\<Sum>x\\<leftarrow>a # xs. x $ i)", "by auto"], ["proof (state)\nthis:\n  foldr (+) (a # xs) (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>a # xs. x $ i)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)", "case Nil"], ["proof (state)\nthis:\n  ?x1 \\<in> set [] \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        x \\<in> carrier_vec n) \\<Longrightarrow>\n    foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)", "thus ?case"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set [] \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)", "using assms"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set [] \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n  ?x1 \\<in> set xs \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n  i < n\n\ngoal (1 subgoal):\n 1. foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)", "by auto"], ["proof (state)\nthis:\n  foldr (+) [] (0\\<^sub>v n) $ i = (\\<Sum>x\\<leftarrow>[]. x $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_prod_left_sum_distrib: \n  assumes vs: \"\\<And> v. v \\<in> set vvs \\<Longrightarrow> v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\" \n  shows \"sumlist vvs \\<bullet> w = sum_list (map (\\<lambda> v. v \\<bullet> w) vvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist vvs \\<bullet> w = (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w)", "using vs"], ["proof (prove)\nusing this:\n  ?v1 \\<in> set vvs \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist vvs \\<bullet> w = (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w)", "proof (induct vvs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "case (Cons v vs)"], ["proof (state)\nthis:\n  (\\<And>v.\n      v \\<in> set vs \\<Longrightarrow>\n      v \\<in> carrier_vec n) \\<Longrightarrow>\n  M.sumlist vs \\<bullet> w = (\\<Sum>v\\<leftarrow>vs. v \\<bullet> w)\n  ?v1 \\<in> set (v # vs) \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "from Cons"], ["proof (chain)\npicking this:\n  (\\<And>v.\n      v \\<in> set vs \\<Longrightarrow>\n      v \\<in> carrier_vec n) \\<Longrightarrow>\n  M.sumlist vs \\<bullet> w = (\\<Sum>v\\<leftarrow>vs. v \\<bullet> w)\n  ?v1 \\<in> set (v # vs) \\<Longrightarrow> ?v1 \\<in> carrier_vec n", "have v: \"v \\<in> carrier_vec n\" and vs: \"sumlist vs \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  (\\<And>v.\n      v \\<in> set vs \\<Longrightarrow>\n      v \\<in> carrier_vec n) \\<Longrightarrow>\n  M.sumlist vs \\<bullet> w = (\\<Sum>v\\<leftarrow>vs. v \\<bullet> w)\n  ?v1 \\<in> set (v # vs) \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& M.sumlist vs \\<in> carrier_vec n", "by (auto intro!: sumlist_carrier)"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  M.sumlist vs \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "have \"sumlist (v # vs) \\<bullet> w = sumlist ([v] @ vs) \\<bullet> w \""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (v # vs) \\<bullet> w = M.sumlist ([v] @ vs) \\<bullet> w", "by auto"], ["proof (state)\nthis:\n  M.sumlist (v # vs) \\<bullet> w = M.sumlist ([v] @ vs) \\<bullet> w\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "also"], ["proof (state)\nthis:\n  M.sumlist (v # vs) \\<bullet> w = M.sumlist ([v] @ vs) \\<bullet> w\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "have \"\\<dots> = (v + sumlist vs) \\<bullet> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist ([v] @ vs) \\<bullet> w = (v + M.sumlist vs) \\<bullet> w", "by (subst sumlist_append, insert Cons v vs, auto)"], ["proof (state)\nthis:\n  M.sumlist ([v] @ vs) \\<bullet> w = (v + M.sumlist vs) \\<bullet> w\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "also"], ["proof (state)\nthis:\n  M.sumlist ([v] @ vs) \\<bullet> w = (v + M.sumlist vs) \\<bullet> w\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "have \"\\<dots> = v \\<bullet> w + (sumlist vs \\<bullet> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v + M.sumlist vs) \\<bullet> w =\n    v \\<bullet> w + M.sumlist vs \\<bullet> w", "by (rule add_scalar_prod_distrib[OF v vs w])"], ["proof (state)\nthis:\n  (v + M.sumlist vs) \\<bullet> w = v \\<bullet> w + M.sumlist vs \\<bullet> w\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)\n 2. \\<And>a vvs.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set vvs \\<Longrightarrow>\n                    v \\<in> carrier_vec n) \\<Longrightarrow>\n                M.sumlist vvs \\<bullet> w =\n                (\\<Sum>v\\<leftarrow>vvs. v \\<bullet> w);\n        \\<And>v.\n           v \\<in> set (a # vvs) \\<Longrightarrow>\n           v \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # vvs) \\<bullet> w =\n                         (\\<Sum>v\\<leftarrow>a # vvs. v \\<bullet> w)", "finally"], ["proof (chain)\npicking this:\n  M.sumlist (v # vs) \\<bullet> w = v \\<bullet> w + M.sumlist vs \\<bullet> w", "show ?case"], ["proof (prove)\nusing this:\n  M.sumlist (v # vs) \\<bullet> w = v \\<bullet> w + M.sumlist vs \\<bullet> w\n\ngoal (1 subgoal):\n 1. M.sumlist (v # vs) \\<bullet> w =\n    (\\<Sum>v\\<leftarrow>v # vs. v \\<bullet> w)", "using Cons"], ["proof (prove)\nusing this:\n  M.sumlist (v # vs) \\<bullet> w = v \\<bullet> w + M.sumlist vs \\<bullet> w\n  (\\<And>v.\n      v \\<in> set vs \\<Longrightarrow>\n      v \\<in> carrier_vec n) \\<Longrightarrow>\n  M.sumlist vs \\<bullet> w = (\\<Sum>v\\<leftarrow>vs. v \\<bullet> w)\n  ?v1 \\<in> set (v # vs) \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist (v # vs) \\<bullet> w =\n    (\\<Sum>v\\<leftarrow>v # vs. v \\<bullet> w)", "by auto"], ["proof (state)\nthis:\n  M.sumlist (v # vs) \\<bullet> w =\n  (\\<Sum>v\\<leftarrow>v # vs. v \\<bullet> w)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow>\n        v \\<in> carrier_vec n) \\<Longrightarrow>\n    M.sumlist [] \\<bullet> w = (\\<Sum>v\\<leftarrow>[]. v \\<bullet> w)", "qed (insert w, auto)"], ["", "lemma scalar_prod_right_sum_distrib: \n  assumes vs: \"\\<And> v. v \\<in> set vvs \\<Longrightarrow> v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\" \n  shows \"w \\<bullet> sumlist vvs = sum_list (map (\\<lambda> v. w \\<bullet> v) vvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<bullet> M.sumlist vvs = sum_list (map ((\\<bullet>) w) vvs)", "by (subst comm_scalar_prod[OF w sumlist_carrier], insert vs w, force,\n  subst scalar_prod_left_sum_distrib[OF vs w], force,\n  rule arg_cong[of _ _ sum_list], rule nth_equalityI, \n  auto simp: set_conv_nth intro!: comm_scalar_prod)"], ["", "lemma lincomb_list_add_vec_2: assumes us: \"set us \\<subseteq> carrier_vec n\" \n  and x: \"x = lincomb_list lc (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j])\"\n  and i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \nshows \"x = lincomb_list (lc (j := lc j + lc i * c)) us\" (is \"_ = ?x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "let ?xx = \"lc j + lc i * c\""], ["proof (state)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "let ?i = \"us ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "let ?j = \"us ! j\""], ["proof (state)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "let ?v = \"?i + c \\<cdot>\\<^sub>v ?j\""], ["proof (state)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "let ?ws = \"us [i := us ! i + c \\<cdot>\\<^sub>v us ! j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "from us"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n", "have usk: \"k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n\" for k"], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "from usk i"], ["proof (chain)\npicking this:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j", "have ij: \"?i \\<in> carrier_vec n\" \"?j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! i \\<in> carrier_vec n &&& us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "hence v: \"c \\<cdot>\\<^sub>v ?j \\<in> carrier_vec n\" \"?v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n &&&\n    us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "with us"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n", "have ws: \"set ?ws \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n    \\<subseteq> carrier_vec n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  {us ! i |i. i < length us} \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. {us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia |ia.\n     ia < length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])}\n    \\<subseteq> carrier_vec n", "using i"], ["proof (prove)\nusing this:\n  {us ! i |i. i < length us} \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. {us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia |ia.\n     ia < length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])}\n    \\<subseteq> carrier_vec n", "by (auto, rename_tac k, case_tac \"k = i\", auto)"], ["proof (state)\nthis:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "from us"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n", "have us': \"\\<forall>w\\<in>set us. dim_vec w = n\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set us. dim_vec w = n", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set us. dim_vec w = n\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "from ws"], ["proof (chain)\npicking this:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n", "have ws': \"\\<forall>w\\<in>set ?ws. dim_vec w = n\""], ["proof (prove)\nusing this:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]).\n       dim_vec w = n", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]).\n     dim_vec w = n\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "have mset: \"mset_set {0..<length us} = {#i#} + {#j#} + (mset_set ({0..<length us} - {i,j}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set {0..<length us} =\n    {#i#} + {#j#} + mset_set ({0..<length us} - {i, j})", "by (rule multiset_eqI, insert i, auto, rename_tac x, case_tac \"x \\<in> {0 ..< length us}\", auto)"], ["proof (state)\nthis:\n  mset_set {0..<length us} =\n  {#i#} + {#j#} + mset_set ({0..<length us} - {i, j})\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "define M2 where \"M2 = M.summset\n      {#lc ia \\<cdot>\\<^sub>v ?ws ! ia. ia \\<in># mset_set ({0..<length us} - {i, j})#}\""], ["proof (state)\nthis:\n  M2 =\n  M.summset\n   {#lc ia \\<cdot>\\<^sub>v us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n   . ia \\<in># mset_set ({0..<length us} - {i, j})#}\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "define M1 where \"M1 = M.summset {#(if i = j then ?xx else lc i) \\<cdot>\\<^sub>v us ! i. i \\<in># mset_set ({0..<length us} - {i, j})#}\""], ["proof (state)\nthis:\n  M1 =\n  M.summset\n   {#(if ia = j then lc j + lc i * c else lc ia) \\<cdot>\\<^sub>v us ! ia\n   . ia \\<in># mset_set ({0..<length us} - {i, j})#}\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "have M1: \"M1 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<in> carrier_vec n", "unfolding M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.summset\n     {#(if ia = j then lc j + lc i * c else lc ia) \\<cdot>\\<^sub>v us ! ia\n     . ia \\<in># mset_set ({0..<length us} - {i, j})#}\n    \\<in> carrier_vec n", "using usk"], ["proof (prove)\nusing this:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.summset\n     {#(if ia = j then lc j + lc i * c else lc ia) \\<cdot>\\<^sub>v us ! ia\n     . ia \\<in># mset_set ({0..<length us} - {i, j})#}\n    \\<in> carrier_vec n", "by fastforce"], ["proof (state)\nthis:\n  M1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "have M2: \"M1 = M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 = M2", "unfolding M2_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.summset\n     {#(if ia = j then lc j + lc i * c else lc ia) \\<cdot>\\<^sub>v us ! ia\n     . ia \\<in># mset_set ({0..<length us} - {i, j})#} =\n    M.summset\n     {#lc ia \\<cdot>\\<^sub>v us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n     . ia \\<in># mset_set ({0..<length us} - {i, j})#}", "by (rule arg_cong[of _ _ M.summset], rule multiset.map_cong0, insert i usk, auto)"], ["proof (state)\nthis:\n  M1 = M2\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "have x1: \"x = lc j \\<cdot>\\<^sub>v ?j + (lc i \\<cdot>\\<^sub>v ?i + lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v ?j) + M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    lc j \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M1)", "unfolding x lincomb_list_def M2 M2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ia.\n              lc ia \\<cdot>\\<^sub>v\n              us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia)\n       [0..<length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])]) =\n    lc j \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M.summset\n      {#lc ia \\<cdot>\\<^sub>v\n        us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n      . ia \\<in># mset_set ({0..<length us} - {i, j})#})", "apply (subst sumlist_as_summset, (insert us ws i v ij, auto simp: set_conv_nth)[1], insert i ij v us ws usk, \n      simp add: mset smult_add_distrib_vec[OF ij(1) v(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length us; i < length us; i \\<noteq> j;\n     set us \\<subseteq> carrier_vec n;\n     set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n     \\<subseteq> carrier_vec n;\n     \\<And>k.\n        k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> M.summset\n                       (add_mset (lc j \\<cdot>\\<^sub>v us ! j)\n                         (add_mset\n                           (lc i \\<cdot>\\<^sub>v us ! i +\n                            lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j))\n                           {#lc ia \\<cdot>\\<^sub>v\n                             us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n                           . ia \\<in># mset_set\n  ({0..<length us} - {i, j})#})) =\n                      lc j \\<cdot>\\<^sub>v us ! j +\n                      (lc i \\<cdot>\\<^sub>v us ! i +\n                       lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n                       M.summset\n                        {#lc ia \\<cdot>\\<^sub>v\n                          us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n                        . ia \\<in># mset_set ({0..<length us} - {i, j})#})", "by (subst M.summset_add_mset, auto)+"], ["proof (state)\nthis:\n  x =\n  lc j \\<cdot>\\<^sub>v us ! j +\n  (lc i \\<cdot>\\<^sub>v us ! i +\n   lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n   M1)\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "have x2: \"?x = ?xx \\<cdot>\\<^sub>v ?j + (lc i \\<cdot>\\<^sub>v ?i + M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list (lc(j := lc j + lc i * c)) us =\n    (lc j + lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i + M1)", "unfolding x lincomb_list_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ia.\n              (lc(j := lc j + lc i * c)) ia \\<cdot>\\<^sub>v us ! ia)\n       [0..<length us]) =\n    (lc j + lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     M.summset\n      {#(if ia = j then lc j + lc i * c else lc ia) \\<cdot>\\<^sub>v us ! ia\n      . ia \\<in># mset_set ({0..<length us} - {i, j})#})", "apply (subst sumlist_as_summset, (insert us ws i v ij, auto simp: set_conv_nth)[1], insert i ij v us ws usk, \n      simp add: mset smult_add_distrib_vec[OF ij(1) v(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length us; i < length us; i \\<noteq> j;\n     set us \\<subseteq> carrier_vec n;\n     set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n     \\<subseteq> carrier_vec n;\n     \\<And>k.\n        k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> M.summset\n                       (add_mset ((lc j + lc i * c) \\<cdot>\\<^sub>v us ! j)\n                         (add_mset (lc i \\<cdot>\\<^sub>v us ! i)\n                           {#(if ia = j then lc j + lc i * c\n                              else lc ia) \\<cdot>\\<^sub>v\n                             us ! ia\n                           . ia \\<in># mset_set\n  ({0..<length us} - {i, j})#})) =\n                      (lc j + lc i * c) \\<cdot>\\<^sub>v us ! j +\n                      (lc i \\<cdot>\\<^sub>v us ! i +\n                       M.summset\n                        {#(if ia = j then lc j + lc i * c\n                           else lc ia) \\<cdot>\\<^sub>v\n                          us ! ia\n                        . ia \\<in># mset_set ({0..<length us} - {i, j})#})", "by (subst M.summset_add_mset, auto)+"], ["proof (state)\nthis:\n  lincomb_list (lc(j := lc j + lc i * c)) us =\n  (lc j + lc i * c) \\<cdot>\\<^sub>v us ! j +\n  (lc i \\<cdot>\\<^sub>v us ! i + M1)\n\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = lincomb_list (lc(j := lc j + lc i * c)) us", "unfolding x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. lc j \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M1) =\n    (lc j + lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i + M1)", "using M1 ij"], ["proof (prove)\nusing this:\n  M1 \\<in> carrier_vec n\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lc j \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M1) =\n    (lc j + lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i + M1)", "by (intro eq_vecI, auto simp: field_simps)"], ["proof (state)\nthis:\n  x = lincomb_list (lc(j := lc j + lc i * c)) us\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lincomb_list_add_vec_1: assumes us: \"set us \\<subseteq> carrier_vec n\" \n  and x: \"x = lincomb_list lc us\"\n  and i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \nshows \"x = lincomb_list (lc (j := lc j - lc i * c)) (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j])\" (is \"_ = ?x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "let ?i = \"us ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "let ?j = \"us ! j\""], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "let ?v = \"?i + c \\<cdot>\\<^sub>v ?j\""], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "let ?ws = \"us [i := us ! i + c \\<cdot>\\<^sub>v us ! j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from us"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n", "have usk: \"k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n\" for k"], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from usk i"], ["proof (chain)\npicking this:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j", "have ij: \"?i \\<in> carrier_vec n\" \"?j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! i \\<in> carrier_vec n &&& us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "hence v: \"c \\<cdot>\\<^sub>v ?j \\<in> carrier_vec n\" \"?v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n &&&\n    us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "with us"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n", "have ws: \"set ?ws \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n    \\<subseteq> carrier_vec n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  {us ! i |i. i < length us} \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. {us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia |ia.\n     ia < length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])}\n    \\<subseteq> carrier_vec n", "using i"], ["proof (prove)\nusing this:\n  {us ! i |i. i < length us} \\<subseteq> carrier_vec n\n  c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. {us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia |ia.\n     ia < length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])}\n    \\<subseteq> carrier_vec n", "by (auto, rename_tac k, case_tac \"k = i\", auto)"], ["proof (state)\nthis:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from us"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n", "have us': \"\\<forall>w\\<in>set us. dim_vec w = n\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set us. dim_vec w = n", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set us. dim_vec w = n\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from ws"], ["proof (chain)\npicking this:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n", "have ws': \"\\<forall>w\\<in>set ?ws. dim_vec w = n\""], ["proof (prove)\nusing this:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]).\n       dim_vec w = n", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]).\n     dim_vec w = n\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have mset: \"mset_set {0..<length us} = {#i#} + {#j#} + (mset_set ({0..<length us} - {i,j}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set {0..<length us} =\n    {#i#} + {#j#} + mset_set ({0..<length us} - {i, j})", "by (rule multiset_eqI, insert i, auto, rename_tac x, case_tac \"x \\<in> {0 ..< length us}\", auto)"], ["proof (state)\nthis:\n  mset_set {0..<length us} =\n  {#i#} + {#j#} + mset_set ({0..<length us} - {i, j})\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "define M2 where \"M2 = M.summset\n      {#(if ia = j then lc j - lc i * c else lc ia) \\<cdot>\\<^sub>v ?ws ! ia\n      . ia \\<in># mset_set ({0..<length us} - {i, j})#}\""], ["proof (state)\nthis:\n  M2 =\n  M.summset\n   {#(if ia = j then lc j - lc i * c else lc ia) \\<cdot>\\<^sub>v\n     us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n   . ia \\<in># mset_set ({0..<length us} - {i, j})#}\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "define M1 where \"M1 = M.summset {#lc i \\<cdot>\\<^sub>v us ! i. i \\<in># mset_set ({0..<length us} - {i, j})#}\""], ["proof (state)\nthis:\n  M1 =\n  M.summset\n   {#lc i \\<cdot>\\<^sub>v us ! i\n   . i \\<in># mset_set ({0..<length us} - {i, j})#}\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have M1: \"M1 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<in> carrier_vec n", "unfolding M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.summset\n     {#lc i \\<cdot>\\<^sub>v us ! i\n     . i \\<in># mset_set ({0..<length us} - {i, j})#}\n    \\<in> carrier_vec n", "using usk"], ["proof (prove)\nusing this:\n  ?k1 < length us \\<Longrightarrow> us ! ?k1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.summset\n     {#lc i \\<cdot>\\<^sub>v us ! i\n     . i \\<in># mset_set ({0..<length us} - {i, j})#}\n    \\<in> carrier_vec n", "by fastforce"], ["proof (state)\nthis:\n  M1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have M2: \"M1 = M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 = M2", "unfolding M2_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.summset\n     {#lc i \\<cdot>\\<^sub>v us ! i\n     . i \\<in># mset_set ({0..<length us} - {i, j})#} =\n    M.summset\n     {#(if ia = j then lc j - lc i * c else lc ia) \\<cdot>\\<^sub>v\n       us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n     . ia \\<in># mset_set ({0..<length us} - {i, j})#}", "by (rule arg_cong[of _ _ M.summset], rule multiset.map_cong0, insert i usk, auto)"], ["proof (state)\nthis:\n  M1 = M2\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have x1: \"x = lc j \\<cdot>\\<^sub>v ?j + (lc i \\<cdot>\\<^sub>v ?i + M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = lc j \\<cdot>\\<^sub>v us ! j + (lc i \\<cdot>\\<^sub>v us ! i + M1)", "unfolding x lincomb_list_def M1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. lc i \\<cdot>\\<^sub>v us ! i) [0..<length us]) =\n    lc j \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     M.summset\n      {#lc i \\<cdot>\\<^sub>v us ! i\n      . i \\<in># mset_set ({0..<length us} - {i, j})#})", "apply (subst sumlist_as_summset, (insert us ws i v ij, auto simp: set_conv_nth)[1], insert i ij v us ws usk, \n      simp add: mset smult_add_distrib_vec[OF ij(1) v(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length us; i < length us; i \\<noteq> j;\n     set us \\<subseteq> carrier_vec n;\n     set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n     \\<subseteq> carrier_vec n;\n     \\<And>k.\n        k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> M.summset\n                       (add_mset (lc j \\<cdot>\\<^sub>v us ! j)\n                         (add_mset (lc i \\<cdot>\\<^sub>v us ! i)\n                           {#lc i \\<cdot>\\<^sub>v us ! i\n                           . i \\<in># mset_set\n ({0..<length us} - {i, j})#})) =\n                      lc j \\<cdot>\\<^sub>v us ! j +\n                      (lc i \\<cdot>\\<^sub>v us ! i +\n                       M.summset\n                        {#lc i \\<cdot>\\<^sub>v us ! i\n                        . i \\<in># mset_set ({0..<length us} - {i, j})#})", "by (subst M.summset_add_mset, auto)+"], ["proof (state)\nthis:\n  x = lc j \\<cdot>\\<^sub>v us ! j + (lc i \\<cdot>\\<^sub>v us ! i + M1)\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have x2: \"?x = (lc j - lc i * c) \\<cdot>\\<^sub>v ?j + (lc i \\<cdot>\\<^sub>v ?i + lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v ?j) + M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) =\n    (lc j - lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M1)", "unfolding x lincomb_list_def M2 M2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ia.\n              (lc(j := lc j - lc i * c)) ia \\<cdot>\\<^sub>v\n              us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia)\n       [0..<length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])]) =\n    (lc j - lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M.summset\n      {#(if ia = j then lc j - lc i * c else lc ia) \\<cdot>\\<^sub>v\n        us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n      . ia \\<in># mset_set ({0..<length us} - {i, j})#})", "apply (subst sumlist_as_summset, (insert us ws i v ij, auto simp: set_conv_nth)[1], insert i ij v us ws usk, \n      simp add: mset smult_add_distrib_vec[OF ij(1) v(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length us; i < length us; i \\<noteq> j;\n     set us \\<subseteq> carrier_vec n;\n     set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n     \\<subseteq> carrier_vec n;\n     \\<And>k.\n        k < length us \\<Longrightarrow> us ! k \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> M.summset\n                       (add_mset ((lc j - lc i * c) \\<cdot>\\<^sub>v us ! j)\n                         (add_mset\n                           (lc i \\<cdot>\\<^sub>v us ! i +\n                            lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j))\n                           {#(if ia = j then lc j - lc i * c\n                              else lc ia) \\<cdot>\\<^sub>v\n                             us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n                           . ia \\<in># mset_set\n  ({0..<length us} - {i, j})#})) =\n                      (lc j - lc i * c) \\<cdot>\\<^sub>v us ! j +\n                      (lc i \\<cdot>\\<^sub>v us ! i +\n                       lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n                       M.summset\n                        {#(if ia = j then lc j - lc i * c\n                           else lc ia) \\<cdot>\\<^sub>v\n                          us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia\n                        . ia \\<in># mset_set ({0..<length us} - {i, j})#})", "by (subst M.summset_add_mset, auto)+"], ["proof (state)\nthis:\n  lincomb_list (lc(j := lc j - lc i * c))\n   (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) =\n  (lc j - lc i * c) \\<cdot>\\<^sub>v us ! j +\n  (lc i \\<cdot>\\<^sub>v us ! i +\n   lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n   M1)\n\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    lincomb_list (lc(j := lc j - lc i * c))\n     (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "unfolding x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. lc j \\<cdot>\\<^sub>v us ! j + (lc i \\<cdot>\\<^sub>v us ! i + M1) =\n    (lc j - lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M1)", "using M1 ij"], ["proof (prove)\nusing this:\n  M1 \\<in> carrier_vec n\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lc j \\<cdot>\\<^sub>v us ! j + (lc i \\<cdot>\\<^sub>v us ! i + M1) =\n    (lc j - lc i * c) \\<cdot>\\<^sub>v us ! j +\n    (lc i \\<cdot>\\<^sub>v us ! i +\n     lc i \\<cdot>\\<^sub>v (c \\<cdot>\\<^sub>v us ! j) +\n     M1)", "by (intro eq_vecI, auto simp: field_simps)"], ["proof (state)\nthis:\n  x =\n  lincomb_list (lc(j := lc j - lc i * c))\n   (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context vec_space\nbegin"], ["", "lemma add_vec_span: assumes us: \"set us \\<subseteq> carrier_vec n\" \n  and i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \nshows \"span (set us) = span (set (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\" (is \"_ = span (set ?ws)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "let ?i = \"us ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "let ?j = \"us ! j\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "let ?v = \"?i + c \\<cdot>\\<^sub>v ?j\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "from us i"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j", "have ij: \"?i \\<in> carrier_vec n\" \"?j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! i \\<in> carrier_vec n &&& us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "hence v: \"?v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  us ! i \\<in> carrier_vec n\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "with us"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n", "have ws: \"set ?ws \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n    \\<subseteq> carrier_vec n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  {us ! i |i. i < length us} \\<subseteq> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. {us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia |ia.\n     ia < length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])}\n    \\<subseteq> carrier_vec n", "using i"], ["proof (prove)\nusing this:\n  {us ! i |i. i < length us} \\<subseteq> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. {us[i := us ! i + c \\<cdot>\\<^sub>v us ! j] ! ia |ia.\n     ia < length (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])}\n    \\<subseteq> carrier_vec n", "by (auto, rename_tac k, case_tac \"k = i\", auto)"], ["proof (state)\nthis:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "have \"span (set us) = span_list us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set us) = span_list us", "unfolding span_list_as_span[OF us]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set us) = local.span (set us)", ".."], ["proof (state)\nthis:\n  local.span (set us) = span_list us\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "also"], ["proof (state)\nthis:\n  local.span (set us) = span_list us\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "have \"\\<dots> = span_list ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "assume \"x \\<in> span_list us\""], ["proof (state)\nthis:\n  x \\<in> span_list us\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "then"], ["proof (chain)\npicking this:\n  x \\<in> span_list us", "obtain lc where \"x = lincomb_list lc us\""], ["proof (prove)\nusing this:\n  x \\<in> span_list us\n\ngoal (1 subgoal):\n 1. (\\<And>lc.\n        x = lincomb_list lc us \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_span_listE)"], ["proof (state)\nthis:\n  x = lincomb_list lc us\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from lincomb_list_add_vec_1[OF us this i, of c]"], ["proof (chain)\npicking this:\n  x =\n  lincomb_list (lc(j := lc j - lc i * c))\n   (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have \"x \\<in> span_list ?ws\""], ["proof (prove)\nusing this:\n  x =\n  lincomb_list (lc(j := lc j - lc i * c))\n   (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. x \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "unfolding span_list_def"], ["proof (prove)\nusing this:\n  x =\n  lincomb_list (lc(j := lc j - lc i * c))\n   (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. x \\<in> {uu_.\n             \\<exists>ca.\n                uu_ =\n                lincomb_list ca\n                 (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])}", "by auto"], ["proof (state)\nthis:\n  x \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "}"], ["proof (state)\nthis:\n  ?x3 \\<in> span_list us \\<Longrightarrow>\n  ?x3 \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "moreover"], ["proof (state)\nthis:\n  ?x3 \\<in> span_list us \\<Longrightarrow>\n  ?x3 \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "{"], ["proof (state)\nthis:\n  ?x3 \\<in> span_list us \\<Longrightarrow>\n  ?x3 \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "assume \"x \\<in> span_list ?ws\""], ["proof (state)\nthis:\n  x \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "then"], ["proof (chain)\npicking this:\n  x \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "obtain lc where \"x = lincomb_list lc ?ws\""], ["proof (prove)\nusing this:\n  x \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. (\\<And>lc.\n        x =\n        lincomb_list lc\n         (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis in_span_listE)"], ["proof (state)\nthis:\n  x = lincomb_list lc (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from lincomb_list_add_vec_2[OF us this i]"], ["proof (chain)\npicking this:\n  x = lincomb_list (lc(j := lc j + lc i * c)) us", "have \"x \\<in> span_list us\""], ["proof (prove)\nusing this:\n  x = lincomb_list (lc(j := lc j + lc i * c)) us\n\ngoal (1 subgoal):\n 1. x \\<in> span_list us", "unfolding span_list_def"], ["proof (prove)\nusing this:\n  x = lincomb_list (lc(j := lc j + lc i * c)) us\n\ngoal (1 subgoal):\n 1. x \\<in> {uu_. \\<exists>c. uu_ = lincomb_list c us}", "by auto"], ["proof (state)\nthis:\n  x \\<in> span_list us\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "}"], ["proof (state)\nthis:\n  ?x3\n  \\<in> span_list\n         (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<Longrightarrow>\n  ?x3 \\<in> span_list us\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "ultimately"], ["proof (chain)\npicking this:\n  ?x3 \\<in> span_list us \\<Longrightarrow>\n  ?x3 \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n  ?x3\n  \\<in> span_list\n         (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<Longrightarrow>\n  ?x3 \\<in> span_list us", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x3 \\<in> span_list us \\<Longrightarrow>\n  ?x3 \\<in> span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n  ?x3\n  \\<in> span_list\n         (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<Longrightarrow>\n  ?x3 \\<in> span_list us\n\ngoal (1 subgoal):\n 1. span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "by blast"], ["proof (state)\nthis:\n  span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "also"], ["proof (state)\nthis:\n  span_list us = span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "have \"\\<dots> = span (set ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "unfolding span_list_as_span[OF ws]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", ".."], ["proof (state)\nthis:\n  span_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) =\n  local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "finally"], ["proof (chain)\npicking this:\n  local.span (set us) =\n  local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.span (set us) =\n  local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\n\ngoal (1 subgoal):\n 1. local.span (set us) =\n    local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "."], ["proof (state)\nthis:\n  local.span (set us) =\n  local.span (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_in_span[intro!]:\n  assumes \"b \\<in> carrier_vec n\" \"S \\<subseteq> carrier_vec n\" \"a = 0 \\<or> b \\<in> span S\"\n  shows \"a \\<cdot>\\<^sub>v b \\<in> span S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v b \\<in> local.span S", "proof(cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow> a \\<cdot>\\<^sub>v b \\<in> local.span S\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "case True"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow> a \\<cdot>\\<^sub>v b \\<in> local.span S\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "then"], ["proof (chain)\npicking this:\n  a = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v b \\<in> local.span S", "by (auto simp:lmult_0[OF assms(1)] span_zero)"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v b \\<in> local.span S\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "case False"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "with assms"], ["proof (chain)\npicking this:\n  b \\<in> carrier_vec n\n  S \\<subseteq> carrier_vec n\n  a = (0::'a) \\<or> b \\<in> local.span S\n  a \\<noteq> (0::'a)", "have \"b \\<in> span S\""], ["proof (prove)\nusing this:\n  b \\<in> carrier_vec n\n  S \\<subseteq> carrier_vec n\n  a = (0::'a) \\<or> b \\<in> local.span S\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<in> local.span S", "by auto"], ["proof (state)\nthis:\n  b \\<in> local.span S\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "from this[THEN in_spanE]"], ["proof (chain)\npicking this:\n  \\<exists>a A. b = lincomb a A \\<and> finite A \\<and> A \\<subseteq> S", "obtain aa A where a[intro!]: \"b = lincomb aa A\" \"finite A\" \"A \\<subseteq> S\""], ["proof (prove)\nusing this:\n  \\<exists>a A. b = lincomb a A \\<and> finite A \\<and> A \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<And>aa A.\n        \\<lbrakk>b = lincomb aa A; finite A; A \\<subseteq> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = lincomb aa A\n  finite A\n  A \\<subseteq> S\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "hence [intro!]:\"(\\<lambda>v. aa v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\""], ["proof (prove)\nusing this:\n  b = lincomb aa A\n  finite A\n  A \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. aa v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  b = lincomb aa A\n  finite A\n  A \\<subseteq> S\n  b \\<in> carrier_vec n\n  S \\<subseteq> carrier_vec n\n  a = (0::'a) \\<or> b \\<in> local.span S\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. aa v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. aa v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>v b \\<in> local.span S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v b \\<in> local.span S", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<cdot>\\<^sub>v b = lincomb ?a ?A\n 2. finite ?A\n 3. ?A \\<subseteq> S", "show \"a \\<cdot>\\<^sub>v b = lincomb (\\<lambda> v. a * aa v) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v b = lincomb (\\<lambda>v. a * aa v) A", "using a(1)"], ["proof (prove)\nusing this:\n  b = lincomb aa A\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v b = lincomb (\\<lambda>v. a * aa v) A", "unfolding lincomb_def smult_smult_assoc[symmetric]"], ["proof (prove)\nusing this:\n  b = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. aa v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v b =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a \\<cdot>\\<^sub>v\n (aa v \\<cdot>\\<^sub>v v))", "by(subst finsum_smult[symmetric]) force+"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v b = lincomb (\\<lambda>v. a * aa v) A\n\ngoal (2 subgoals):\n 1. finite A\n 2. A \\<subseteq> S", "qed auto"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v b \\<in> local.span S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_nonzero_congruence:\n  assumes eq:\"A * M = B * M\" and det:\"det (M::'a mat) \\<noteq> 0\"\n  and M: \"M \\<in> carrier_mat n n\" and carr:\"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = B", "have \"1\\<^sub>m n \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = B", "from det_non_zero_imp_unit[OF M det] gauss_jordan_check_invertable[OF M this]"], ["proof (chain)\npicking this:\n  M \\<in> Units (ring_mat TYPE('a) n ?b)\n  (M \\<in> Units (ring_mat TYPE('a) n ?b)) =\n  (fst (gauss_jordan M (1\\<^sub>m n)) = 1\\<^sub>m n)", "have gj_fst:\"(fst (gauss_jordan M (1\\<^sub>m n)) = 1\\<^sub>m n)\""], ["proof (prove)\nusing this:\n  M \\<in> Units (ring_mat TYPE('a) n ?b)\n  (M \\<in> Units (ring_mat TYPE('a) n ?b)) =\n  (fst (gauss_jordan M (1\\<^sub>m n)) = 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan M (1\\<^sub>m n)) = 1\\<^sub>m n", "by metis"], ["proof (state)\nthis:\n  fst (gauss_jordan M (1\\<^sub>m n)) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "define Mi where \"Mi = snd (gauss_jordan M (1\\<^sub>m n))\""], ["proof (state)\nthis:\n  Mi = snd (gauss_jordan M (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. A = B", "with gj_fst"], ["proof (chain)\npicking this:\n  fst (gauss_jordan M (1\\<^sub>m n)) = 1\\<^sub>m n\n  Mi = snd (gauss_jordan M (1\\<^sub>m n))", "have gj:\"gauss_jordan M (1\\<^sub>m n) = (1\\<^sub>m n, Mi)\""], ["proof (prove)\nusing this:\n  fst (gauss_jordan M (1\\<^sub>m n)) = 1\\<^sub>m n\n  Mi = snd (gauss_jordan M (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. gauss_jordan M (1\\<^sub>m n) = (1\\<^sub>m n, Mi)", "unfolding fst_def snd_def"], ["proof (prove)\nusing this:\n  (case gauss_jordan M (1\\<^sub>m n) of (x1, x2) \\<Rightarrow> x1) =\n  1\\<^sub>m n\n  Mi = (case gauss_jordan M (1\\<^sub>m n) of (x1, x2) \\<Rightarrow> x2)\n\ngoal (1 subgoal):\n 1. gauss_jordan M (1\\<^sub>m n) = (1\\<^sub>m n, Mi)", "by (auto split:prod.split)"], ["proof (state)\nthis:\n  gauss_jordan M (1\\<^sub>m n) = (1\\<^sub>m n, Mi)\n\ngoal (1 subgoal):\n 1. A = B", "from gauss_jordan_compute_inverse(1,3)[OF M gj]"], ["proof (chain)\npicking this:\n  M * Mi = 1\\<^sub>m n\n  Mi \\<in> carrier_mat n n", "have Mi: \"Mi \\<in> carrier_mat n n\" and is1:\"M * Mi = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  M * Mi = 1\\<^sub>m n\n  Mi \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. Mi \\<in> carrier_mat n n &&& M * Mi = 1\\<^sub>m n", "by metis+"], ["proof (state)\nthis:\n  Mi \\<in> carrier_mat n n\n  M * Mi = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "from arg_cong[OF eq, of \"\\<lambda> M. M * Mi\"]"], ["proof (chain)\npicking this:\n  A * M * Mi = B * M * Mi", "show \"A = B\""], ["proof (prove)\nusing this:\n  A * M * Mi = B * M * Mi\n\ngoal (1 subgoal):\n 1. A = B", "unfolding carr[THEN assoc_mult_mat[OF _ M Mi]] is1 carr[THEN right_mult_one_mat]"], ["proof (prove)\nusing this:\n  A = B\n\ngoal (1 subgoal):\n 1. A = B", "."], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_rows_mult_as_finsum:\n  assumes \"v \\<in> carrier_vec (length lst)\" \"\\<And> i. i < length lst \\<Longrightarrow> lst ! i \\<in> carrier_vec n\"\n  defines \"f l \\<equiv> sum (\\<lambda> i. if l = lst ! i then v $ i else 0) {0..<length lst}\"\n  shows mat_of_cols_mult_as_finsum:\"mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec (length lst)\n  ?i1 < length lst \\<Longrightarrow> lst ! ?i1 \\<in> carrier_vec n\n  f ?l1 \\<equiv>\n  \\<Sum>i = 0..<length lst. if ?l1 = lst ! i then v $ i else (0::'a)", "have \"\\<forall> i < length lst. lst ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (length lst)\n  ?i1 < length lst \\<Longrightarrow> lst ! ?i1 \\<in> carrier_vec n\n  f ?l1 \\<equiv>\n  \\<Sum>i = 0..<length lst. if ?l1 = lst ! i then v $ i else (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length lst. lst ! i \\<in> carrier_vec n", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<length lst. lst ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "note an = all_nth_imp_all_set[OF this]"], ["proof (state)\nthis:\n  ?x \\<in> set lst \\<Longrightarrow> ?x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "hence slc:\"set lst \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?x \\<in> set lst \\<Longrightarrow> ?x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set lst \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set lst \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "hence dn [simp]:\"\\<And> x. x \\<in> set lst \\<Longrightarrow> dim_vec x = n\""], ["proof (prove)\nusing this:\n  set lst \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set lst \\<Longrightarrow> dim_vec x = n", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> set lst \\<Longrightarrow> dim_vec ?x1 = n\n\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "have dl [simp]:\"dim_vec (lincomb f (set lst)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (lincomb f (set lst)) = n", "using an"], ["proof (prove)\nusing this:\n  ?x \\<in> set lst \\<Longrightarrow> ?x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (lincomb f (set lst)) = n", "by (intro lincomb_dim,auto)"], ["proof (state)\nthis:\n  dim_vec (lincomb f (set lst)) = n\n\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i\n 2. dim_vec (mat_of_cols n lst *\\<^sub>v v) = dim_vec (lincomb f (set lst))", "show \"dim_vec (mat_of_cols n lst *\\<^sub>v v) = dim_vec (lincomb f (set lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (mat_of_cols n lst *\\<^sub>v v) = dim_vec (lincomb f (set lst))", "using assms(1,2)"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (length lst)\n  ?i1 < length lst \\<Longrightarrow> lst ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (mat_of_cols n lst *\\<^sub>v v) = dim_vec (lincomb f (set lst))", "by auto"], ["proof (state)\nthis:\n  dim_vec (mat_of_cols n lst *\\<^sub>v v) = dim_vec (lincomb f (set lst))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "assume i:\"i < dim_vec (lincomb f (set lst))\""], ["proof (state)\nthis:\n  i < dim_vec (lincomb f (set lst))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "hence i':\"i < n\""], ["proof (prove)\nusing this:\n  i < dim_vec (lincomb f (set lst))\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "with an"], ["proof (chain)\npicking this:\n  ?x \\<in> set lst \\<Longrightarrow> ?x \\<in> carrier_vec n\n  i < n", "have fcarr:\"(\\<lambda>v. f v \\<cdot>\\<^sub>v v) \\<in> set lst \\<rightarrow> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?x \\<in> set lst \\<Longrightarrow> ?x \\<in> carrier_vec n\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n    \\<in> set lst \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. f v \\<cdot>\\<^sub>v v)\n  \\<in> set lst \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "from i'"], ["proof (chain)\npicking this:\n  i < n", "have \"(mat_of_cols n lst *\\<^sub>v v) $ i = row (mat_of_cols n lst) i \\<bullet> v\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. (mat_of_cols n lst *\\<^sub>v v) $ i =\n    row (mat_of_cols n lst) i \\<bullet> v", "by auto"], ["proof (state)\nthis:\n  (mat_of_cols n lst *\\<^sub>v v) $ i =\n  row (mat_of_cols n lst) i \\<bullet> v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "also"], ["proof (state)\nthis:\n  (mat_of_cols n lst *\\<^sub>v v) $ i =\n  row (mat_of_cols n lst) i \\<bullet> v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "have \"\\<dots> = (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_cols n lst) i \\<bullet> v =\n    (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia)", "unfolding mat_of_cols_def row_def scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec v.\n        vec (dim_col (mat n (length lst) (\\<lambda>(i, j). lst ! j $ i)))\n         (\\<lambda>j.\n             mat n (length lst) (\\<lambda>(i, j). lst ! j $ i) $$ (i, j)) $\n        ia *\n        v $ ia) =\n    (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia)", "apply(rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec v} \\<Longrightarrow>\n       vec (dim_col (mat n (length lst) (\\<lambda>(i, j). lst ! j $ i)))\n        (\\<lambda>j.\n            mat n (length lst) (\\<lambda>(i, j). lst ! j $ i) $$ (i, j)) $\n       x *\n       v $ x =\n       lst ! x $ i * v $ x", "using i an assms(1)"], ["proof (prove)\nusing this:\n  i < dim_vec (lincomb f (set lst))\n  ?x \\<in> set lst \\<Longrightarrow> ?x \\<in> carrier_vec n\n  v \\<in> carrier_vec (length lst)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec v} \\<Longrightarrow>\n       vec (dim_col (mat n (length lst) (\\<lambda>(i, j). lst ! j $ i)))\n        (\\<lambda>j.\n            mat n (length lst) (\\<lambda>(i, j). lst ! j $ i) $$ (i, j)) $\n       x *\n       v $ x =\n       lst ! x $ i * v $ x", "by auto"], ["proof (state)\nthis:\n  row (mat_of_cols n lst) i \\<bullet> v =\n  (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "also"], ["proof (state)\nthis:\n  row (mat_of_cols n lst) i \\<bullet> v =\n  (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "have \"\\<dots> = (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia) =\n    (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia)", "using assms(1)"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (length lst)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia) =\n    (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia) =\n  (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<dim_vec v. lst ! ia $ i * v $ ia) =\n  (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "have \"\\<dots> = (\\<Sum>x\\<in>set lst. f x * x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia) =\n    (\\<Sum>x\\<in>set lst. f x * x $ i)", "unfolding f_def sum_distrib_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia) =\n    (\\<Sum>x\\<in>set lst.\n       \\<Sum>n = 0..<length lst.\n          (if x = lst ! n then v $ n else (0::'a)) * x $ i)", "apply (subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia) =\n    (\\<Sum>j = 0..<length lst.\n        \\<Sum>ia\\<in>set lst.\n          (if ia = lst ! j then v $ j else (0::'a)) * ia $ i)", "apply(rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<length lst} \\<Longrightarrow>\n       lst ! x $ i * v $ x =\n       (\\<Sum>ia\\<in>set lst.\n          (if ia = lst ! x then v $ x else (0::'a)) * ia $ i)", "unfolding if_distrib if_distribR mult_zero_left sum.delta[OF finite_set]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<length lst} \\<Longrightarrow>\n       if lst ! x \\<in> set lst\n       then lst ! x $ i * v $ x = v $ x * lst ! x $ i\n       else lst ! x $ i * v $ x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia) =\n  (\\<Sum>x\\<in>set lst. f x * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length lst. lst ! ia $ i * v $ ia) =\n  (\\<Sum>x\\<in>set lst. f x * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "have \"\\<dots> = (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set lst. f x * x $ i) =\n    (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i)", "apply(rule sum.cong[OF refl],subst index_smult_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set lst \\<Longrightarrow> i < dim_vec x\n 2. \\<And>x. x \\<in> set lst \\<Longrightarrow> f x * x $ i = f x * x $ i", "using i slc"], ["proof (prove)\nusing this:\n  i < dim_vec (lincomb f (set lst))\n  set lst \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set lst \\<Longrightarrow> i < dim_vec x\n 2. \\<And>x. x \\<in> set lst \\<Longrightarrow> f x * x $ i = f x * x $ i", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set lst. f x * x $ i) =\n  (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set lst. f x * x $ i) =\n  (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "have \"\\<dots> = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set lst. f v \\<cdot>\\<^sub>v v) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set lst. f v \\<cdot>\\<^sub>v v) $ i", "unfolding finsum_index[OF i' fcarr slc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i) =\n    (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set lst. (f x \\<cdot>\\<^sub>v x) $ i) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set lst. f v \\<cdot>\\<^sub>v v) $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (lincomb f (set lst)) \\<Longrightarrow>\n       (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "finally"], ["proof (chain)\npicking this:\n  (mat_of_cols n lst *\\<^sub>v v) $ i =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set lst. f v \\<cdot>\\<^sub>v v) $ i", "show \"(mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i\""], ["proof (prove)\nusing this:\n  (mat_of_cols n lst *\\<^sub>v v) $ i =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set lst. f v \\<cdot>\\<^sub>v v) $ i\n\ngoal (1 subgoal):\n 1. (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i", "by (auto simp:lincomb_def)"], ["proof (state)\nthis:\n  (mat_of_cols n lst *\\<^sub>v v) $ i = lincomb f (set lst) $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_of_cols n lst *\\<^sub>v v = lincomb f (set lst)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}