{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Matrix_Kernel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma mat_kernelI: assumes \"A \\<in> carrier_mat nr nc\" \"v \\<in> carrier_vec nc\" \"A *\\<^sub>v v = 0\\<^sub>v nr\"\n  shows \"v \\<in> mat_kernel A\"", "lemma mat_kernelD: assumes \"A \\<in> carrier_mat nr nc\" \"v \\<in> mat_kernel A\"\n  shows \"v \\<in> carrier_vec nc\" \"A *\\<^sub>v v = 0\\<^sub>v nr\"", "lemma mat_kernel: assumes \"A \\<in> carrier_mat nr nc\" \n  shows \"mat_kernel A = {v. v \\<in> carrier_vec nc \\<and> A *\\<^sub>v v = 0\\<^sub>v nr}\"", "lemma mat_kernel_carrier:\n  assumes \"A \\<in> carrier_mat nr nc\" shows \"mat_kernel A \\<subseteq> carrier_vec nc\"", "lemma mat_kernel_mult_subset: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat n nr\"\n  shows \"mat_kernel A \\<subseteq> mat_kernel (B * A)\"", "lemma mat_kernel_smult: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and v: \"v \\<in> mat_kernel A\"\n  shows \"a \\<cdot>\\<^sub>v v \\<in>  mat_kernel A\"", "lemma mat_kernel_mult_eq: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nr nr\"\n  and C: \"C \\<in> carrier_mat nr nr\"\n  and inv: \"C * B = 1\\<^sub>m nr\"\n  shows \"mat_kernel (B * A) = mat_kernel A\"", "lemma finsum_same:\n  assumes \"f : S \\<rightarrow> mat_kernel A\"\n  shows \"finsum VK f S = finsum NC.V f S\"", "lemma lincomb_same:\n  assumes S_kernel: \"S \\<subseteq> mat_kernel A\"\n  shows \"lincomb a S = NC.lincomb a S\"", "lemma span_same:\n  assumes S_kernel: \"S \\<subseteq> mat_kernel A\"\n  shows \"span S = NC.span S\"", "lemma lindep_same:\n  assumes S_kernel: \"S \\<subseteq> mat_kernel A\"\n  shows \"Ker.lin_dep S = NC.lin_dep S\"", "lemma lincomb_index:\n  assumes i: \"i < nc\"\n    and Xk: \"X \\<subseteq> mat_kernel A\"\n  shows \"lincomb a X $ i = sum (\\<lambda>x. a x * x $ i) X\"", "lemma find_base_vectors: assumes ref: \"row_echelon_form A\" \n  and A: \"A \\<in> carrier_mat nr nc\" shows\n  \"set (find_base_vectors A) \\<subseteq> mat_kernel A\"\n  \"0\\<^sub>v nc \\<notin> set (find_base_vectors A)\"\n  \"kernel.basis nc A (set (find_base_vectors A))\"\n  \"card (set (find_base_vectors A)) = nc - card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\"\n  \"length (pivot_positions A) = card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\"\n  \"kernel.dim nc A = nc - card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\"", "lemma (in kernel) kernel_dim [simp]: \"kernel_dim A = dim\"", "lemma kernel_dim_code[code]: \n  \"kernel_dim A = dim_col A - length (pivot_positions (gauss_jordan_single A))\"", "lemma kernel_one_mat: fixes A :: \"'a :: field mat\" and n :: nat\n  defines A: \"A \\<equiv> 1\\<^sub>m n\"\n  shows \n    \"kernel.dim n A = 0\"\n    \"kernel.basis n A {}\"", "lemma kernel_upper_triangular: assumes A: \"A \\<in> carrier_mat n n\"\n  and ut: \"upper_triangular A\" and 0: \"0 \\<notin> set (diag_mat A)\"\n  shows \"kernel.dim n A = 0\" \"kernel.basis n A {}\"", "lemma kernel_basis_exists: assumes A: \"A \\<in> carrier_mat nr nc\"\n  shows \"\\<exists> B. finite B \\<and> kernel.basis nc A B\"", "lemma mat_kernel_mult_right_gen_set: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nc nc\"\n  and C: \"C \\<in> carrier_mat nc nc\"\n  and inv: \"B * C = 1\\<^sub>m nc\"\n  and gen_set: \"kernel.gen_set nc (A * B) gen\" and gen: \"gen \\<subseteq> mat_kernel (A * B)\"\n  shows \"kernel.gen_set nc A (((*\\<^sub>v) B) ` gen)\" \"(*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\" \"card (((*\\<^sub>v) B) ` gen) = card gen\"", "lemma mat_kernel_mult_right_basis: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nc nc\"\n  and C: \"C \\<in> carrier_mat nc nc\"\n  and inv: \"B * C = 1\\<^sub>m nc\"\n  and fin: \"finite gen\"\n  and basis: \"kernel.basis nc (A * B) gen\"\n  shows \"kernel.basis nc A (((*\\<^sub>v) B) ` gen)\" \n  \"card (((*\\<^sub>v) B) ` gen) = card gen\"", "lemma mat_kernel_dim_mult_eq_right: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nc nc\"\n  and C: \"C \\<in> carrier_mat nc nc\"\n  and BC: \"B * C = 1\\<^sub>m nc\"\n  shows \"kernel.dim nc (A * B) = kernel.dim nc A\"", "lemma unpadr_padr[simp]: \"unpadr m (padr m v) = v\"", "lemma unpadl_padl[simp]: \"unpadl m (padl m v) = v\"", "lemma padr_unpadr[simp]: \"v : padr m ` U \\<Longrightarrow> padr m (unpadr m v) = v\"", "lemma padl_unpadl[simp]: \"v : padl m ` U \\<Longrightarrow> padl m (unpadl m v) = v\"", "lemma padr_image:\n  assumes \"U \\<subseteq> carrier_vec n\" shows \"padr m ` U \\<subseteq> carrier_vec (n + m)\"", "lemma padl_image:\n  assumes \"U \\<subseteq> carrier_vec n\" shows \"padl m ` U \\<subseteq> carrier_vec (m + n)\"", "lemma padr_inj:\n  shows \"inj_on (padr m) (carrier_vec n :: 'a vec set)\"", "lemma padl_inj:\n  shows \"inj_on (padl m) (carrier_vec n :: 'a vec set)\"", "lemma lincomb_pad:\n  fixes m n a\n  assumes U: \"(U :: 'a vec set) \\<subseteq> carrier_vec n\"\n      and finU: \"finite U\"\n  defines \"goal pad unpad W == pad m (lincomb n a W) = lincomb (n+m) (a o unpad m) (pad m ` W)\"\n  shows \"goal padr unpadr U\" (is ?R) and \"goal padl unpadl U\" (is \"?L\")", "lemma span_pad:\n  assumes U: \"(U::'a vec set) \\<subseteq> carrier_vec n\"\n  defines \"goal pad m == pad m ` span n U = span (n+m) (pad m ` U)\"\n  shows \"goal padr m\" \"goal padl m\"", "lemma kernel_padr:\n  assumes aA: \"a : mat_kernel (A :: 'a :: field mat)\"\n      and A: \"A : carrier_mat nr1 nc1\"\n      and B: \"B : carrier_mat nr1 nc2\"\n      and D: \"D : carrier_mat nr2 nc2\"\n  shows \"padr nc2 a : mat_kernel (four_block_mat A B (0\\<^sub>m nr2 nc1) D)\" (is \"_ : mat_kernel ?ABCD\")", "lemma kernel_padl:\n  assumes dD: \"d \\<in> mat_kernel (D :: 'a :: field mat)\"\n      and A: \"A \\<in> carrier_mat nr1 nc1\"\n      and C: \"C \\<in> carrier_mat nr2 nc1\"\n      and D: \"D \\<in> carrier_mat nr2 nc2\"\n  shows \"padl nc1 d \\<in> mat_kernel (four_block_mat A (0\\<^sub>m nr1 nc2) C D)\" (is \"_ \\<in> mat_kernel ?ABCD\")", "lemma mat_kernel_split:\n  assumes A: \"A \\<in> carrier_mat n n\"\n      and D: \"D \\<in> carrier_mat m m\"\n      and kAD: \"k \\<in> mat_kernel (four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D)\"\n           (is \"_ \\<in> mat_kernel ?A00D\")\n  shows \"vec_first k n \\<in> mat_kernel A\" (is \"?a \\<in> _\")\n    and \"vec_last k m \\<in> mat_kernel D\" (is \"?d \\<in> _\")", "lemma padr_padl_eq:\n  assumes v: \"v : carrier_vec n\"\n  shows \"padr m v = padl n u \\<longleftrightarrow> v = 0\\<^sub>v n \\<and> u = 0\\<^sub>v m\"", "lemma pad_disjoint:\n  assumes A: \"A \\<subseteq> carrier_vec n\" and A0: \"0\\<^sub>v n \\<notin> A\" and B: \"B \\<subseteq> carrier_vec m\"\n  shows \"padr m ` A \\<inter> padl n ` B = {}\" (is \"?A \\<inter> ?B = _\")", "lemma padr_padl_lindep:\n  assumes A: \"A \\<subseteq> carrier_vec n\" and liA: \"~ lin_dep n A\"\n      and B: \"B \\<subseteq> carrier_vec m\" and liB: \"~ lin_dep m B\"\n  shows \"~ lin_dep (n+m) (padr m ` A \\<union> padl n ` B)\" (is \"~ lin_dep _ (?A \\<union> ?B)\")", "lemma kernel_four_block_0_mat:\n  assumes Adef: \"(A :: 'a::field mat) = four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and D: \"D \\<in> carrier_mat m m\"\n  shows \"kernel.dim (n + m) A = kernel.dim n B + kernel.dim m D\"", "lemma similar_mat_wit_kernel_dim: assumes A: \"A \\<in> carrier_mat n n\"\n  and wit: \"similar_mat_wit A B P Q\"\n  shows \"kernel.dim n A = kernel.dim n B\""], "translations": [["", "lemma mat_kernelI: assumes \"A \\<in> carrier_mat nr nc\" \"v \\<in> carrier_vec nc\" \"A *\\<^sub>v v = 0\\<^sub>v nr\"\n  shows \"v \\<in> mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> mat_kernel A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. v \\<in> mat_kernel A", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. v \\<in> {v \\<in> carrier_vec (dim_col A).\n             A *\\<^sub>v v = 0\\<^sub>v (dim_row A)}", "by auto"], ["", "lemma mat_kernelD: assumes \"A \\<in> carrier_mat nr nc\" \"v \\<in> mat_kernel A\"\n  shows \"v \\<in> carrier_vec nc\" \"A *\\<^sub>v v = 0\\<^sub>v nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A *\\<^sub>v v = 0\\<^sub>v nr", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  v \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A *\\<^sub>v v = 0\\<^sub>v nr", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  v \\<in> {v \\<in> carrier_vec (dim_col A).\n           A *\\<^sub>v v = 0\\<^sub>v (dim_row A)}\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A *\\<^sub>v v = 0\\<^sub>v nr", "by auto"], ["", "lemma mat_kernel: assumes \"A \\<in> carrier_mat nr nc\" \n  shows \"mat_kernel A = {v. v \\<in> carrier_vec nc \\<and> A *\\<^sub>v v = 0\\<^sub>v nr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A = {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}", "unfolding mat_kernel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec (dim_col A).\n     A *\\<^sub>v v = 0\\<^sub>v (dim_row A)} =\n    {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec (dim_col A).\n     A *\\<^sub>v v = 0\\<^sub>v (dim_row A)} =\n    {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}", "by auto"], ["", "lemma mat_kernel_carrier:\n  assumes \"A \\<in> carrier_mat nr nc\" shows \"mat_kernel A \\<subseteq> carrier_vec nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> carrier_vec nc", "using assms mat_kernel"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow>\n  mat_kernel ?A = {v \\<in> carrier_vec ?nc. ?A *\\<^sub>v v = 0\\<^sub>v ?nr}\n\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> carrier_vec nc", "by auto"], ["", "lemma mat_kernel_mult_subset: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat n nr\"\n  shows \"mat_kernel A \\<subseteq> mat_kernel (B * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> mat_kernel (B * A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> mat_kernel (B * A)", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat n nr", "have BA: \"B * A \\<in> carrier_mat n nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat n nr\n\ngoal (1 subgoal):\n 1. B * A \\<in> carrier_mat n nc", "by auto"], ["proof (state)\nthis:\n  B * A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> mat_kernel (B * A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> mat_kernel (B * A)", "unfolding mat_kernel[OF BA] mat_kernel[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}\n    \\<subseteq> {v \\<in> carrier_vec nc. B * A *\\<^sub>v v = 0\\<^sub>v n}", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat n nr\n\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}\n    \\<subseteq> {v \\<in> carrier_vec nc. B * A *\\<^sub>v v = 0\\<^sub>v n}", "by auto"], ["proof (state)\nthis:\n  mat_kernel A \\<subseteq> mat_kernel (B * A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_kernel_smult: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and v: \"v \\<in> mat_kernel A\"\n  shows \"a \\<cdot>\\<^sub>v v \\<in>  mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "from mat_kernelD[OF A v]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr", "have v: \"v \\<in> carrier_vec nc\"\n    and z: \"A *\\<^sub>v v = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A *\\<^sub>v v = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "from arg_cong[OF z, of \"\\<lambda> v. a \\<cdot>\\<^sub>v v\"] v"], ["proof (chain)\npicking this:\n  a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = a \\<cdot>\\<^sub>v 0\\<^sub>v nr\n  v \\<in> carrier_vec nc", "have \"a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = a \\<cdot>\\<^sub>v 0\\<^sub>v nr\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "also"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "have \"a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = A *\\<^sub>v (a \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = A *\\<^sub>v (a \\<cdot>\\<^sub>v v)", "using A v"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = A *\\<^sub>v (a \\<cdot>\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v (A *\\<^sub>v v) = A *\\<^sub>v (a \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "finally"], ["proof (chain)\npicking this:\n  A *\\<^sub>v (a \\<cdot>\\<^sub>v v) = 0\\<^sub>v nr", "show ?thesis"], ["proof (prove)\nusing this:\n  A *\\<^sub>v (a \\<cdot>\\<^sub>v v) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "using v A"], ["proof (prove)\nusing this:\n  A *\\<^sub>v (a \\<cdot>\\<^sub>v v) = 0\\<^sub>v nr\n  v \\<in> carrier_vec nc\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v v \\<in> mat_kernel A", "by (intro mat_kernelI, auto)"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v v \\<in> mat_kernel A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_kernel_mult_eq: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nr nr\"\n  and C: \"C \\<in> carrier_mat nr nr\"\n  and inv: \"C * B = 1\\<^sub>m nr\"\n  shows \"mat_kernel (B * A) = mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel (B * A) = mat_kernel A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A\n 2. mat_kernel A \\<subseteq> mat_kernel (B * A)", "from B A"], ["proof (chain)\npicking this:\n  B \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc", "have BA: \"B * A \\<in> carrier_mat nr nc\""], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. B * A \\<in> carrier_mat nr nc", "by auto"], ["proof (state)\nthis:\n  B * A \\<in> carrier_mat nr nc\n\ngoal (2 subgoals):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A\n 2. mat_kernel A \\<subseteq> mat_kernel (B * A)", "show \"mat_kernel A \\<subseteq> mat_kernel (B * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> mat_kernel (B * A)", "by (rule mat_kernel_mult_subset[OF A B])"], ["proof (state)\nthis:\n  mat_kernel A \\<subseteq> mat_kernel (B * A)\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "{"], ["proof (state)\nthis:\n  mat_kernel A \\<subseteq> mat_kernel (B * A)\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "assume v: \"v \\<in> mat_kernel (B * A)\""], ["proof (state)\nthis:\n  v \\<in> mat_kernel (B * A)\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "from mat_kernelD[OF BA this]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec nc\n  B * A *\\<^sub>v v = 0\\<^sub>v nr", "have v: \"v \\<in> carrier_vec nc\" and z: \"B * A *\\<^sub>v v = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  B * A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& B * A *\\<^sub>v v = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec nc\n  B * A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "from arg_cong[OF z, of \"\\<lambda> v. C *\\<^sub>v v\"]"], ["proof (chain)\npicking this:\n  C *\\<^sub>v (B * A *\\<^sub>v v) = C *\\<^sub>v 0\\<^sub>v nr", "have \"C *\\<^sub>v (B * A *\\<^sub>v v) = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  C *\\<^sub>v (B * A *\\<^sub>v v) = C *\\<^sub>v 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. C *\\<^sub>v (B * A *\\<^sub>v v) = 0\\<^sub>v nr", "using C v"], ["proof (prove)\nusing this:\n  C *\\<^sub>v (B * A *\\<^sub>v v) = C *\\<^sub>v 0\\<^sub>v nr\n  C \\<in> carrier_mat nr nr\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. C *\\<^sub>v (B * A *\\<^sub>v v) = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  C *\\<^sub>v (B * A *\\<^sub>v v) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "also"], ["proof (state)\nthis:\n  C *\\<^sub>v (B * A *\\<^sub>v v) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "have \"C *\\<^sub>v (B * A *\\<^sub>v v) = ((C * B) * A) *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C *\\<^sub>v (B * A *\\<^sub>v v) = C * B * A *\\<^sub>v v", "unfolding assoc_mult_mat_vec[symmetric, OF C BA v]"], ["proof (prove)\ngoal (1 subgoal):\n 1. C * (B * A) *\\<^sub>v v = C * B * A *\\<^sub>v v", "unfolding assoc_mult_mat[OF C B A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. C * (B * A) *\\<^sub>v v = C * (B * A) *\\<^sub>v v", "by simp"], ["proof (state)\nthis:\n  C *\\<^sub>v (B * A *\\<^sub>v v) = C * B * A *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "also"], ["proof (state)\nthis:\n  C *\\<^sub>v (B * A *\\<^sub>v v) = C * B * A *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "have \"\\<dots> = A *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * B * A *\\<^sub>v v = A *\\<^sub>v v", "unfolding inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m nr * A *\\<^sub>v v = A *\\<^sub>v v", "using A v"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m nr * A *\\<^sub>v v = A *\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  C * B * A *\\<^sub>v v = A *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "finally"], ["proof (chain)\npicking this:\n  A *\\<^sub>v v = 0\\<^sub>v nr", "have \"v \\<in> mat_kernel A\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. v \\<in> mat_kernel A", "by (intro mat_kernelI[OF A v])"], ["proof (state)\nthis:\n  v \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> mat_kernel (B * A) \\<Longrightarrow> ?v2 \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "thus \"mat_kernel (B * A) \\<subseteq> mat_kernel A\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> mat_kernel (B * A) \\<Longrightarrow> ?v2 \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. mat_kernel (B * A) \\<subseteq> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  mat_kernel (B * A) \\<subseteq> mat_kernel A\n\ngoal:\nNo subgoals!", "qed"], ["", "locale kernel =\n  fixes nr :: nat\n    and nc :: nat\n    and A :: \"'a :: field mat\"\n  assumes A: \"A \\<in> carrier_mat nr nc\"\nbegin"], ["", "sublocale NC: vec_space \"TYPE('a)\" nc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation \"VK \\<equiv> NC.V\\<lparr>carrier := mat_kernel A\\<rparr>\""], ["", "sublocale Ker: vectorspace class_ring VK \n  rewrites \"carrier VK = mat_kernel A\"\n    and [simp]: \"add VK = (+)\"\n    and [simp]: \"zero VK = 0\\<^sub>v nc\"\n    and [simp]: \"module.smult VK = (\\<cdot>\\<^sub>v)\"\n    and \"carrier class_ring = UNIV\"\n    and \"monoid.mult class_ring = (*)\"\n    and \"add class_ring = (+)\"\n    and \"one class_ring = 1\"\n    and \"zero class_ring = 0\"\n    and \"a_inv (class_ring :: 'a ring) = uminus\"\n    and \"a_minus (class_ring :: 'a ring) = minus\"\n    and \"pow (class_ring :: 'a ring) = (^)\"\n    and \"finsum (class_ring :: 'a ring) = sum\"\n    and \"finprod (class_ring :: 'a ring) = prod\"\n    and \"m_inv (class_ring :: 'a ring) x = (if x = 0 then div0 else inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((vectorspace class_ring VK &&& carrier VK = mat_kernel A) &&&\n      (\\<oplus>\\<^bsub>VK\\<^esub>) = (+) &&&\n      \\<zero>\\<^bsub>VK\\<^esub> = 0\\<^sub>v nc) &&&\n     ((\\<odot>\\<^bsub>VK\\<^esub>) = (\\<cdot>\\<^sub>v) &&&\n      carrier class_ring = UNIV) &&&\n     (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*) &&&\n     (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)) &&&\n    ((\\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e1) &&&\n      \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f1)) &&&\n     a_inv class_ring = uminus &&& a_minus class_ring = (-)) &&&\n    (([^]\\<^bsub>class_ring\\<^esub>) = (^) &&& finsum class_ring = sum) &&&\n    finprod class_ring = prod &&&\n    inv\\<^bsub>class_ring\\<^esub> x =\n    (if x = (0::'a) then div0 else inverse x)", "apply (intro vectorspace.intro)"], ["proof (prove)\ngoal (17 subgoals):\n 1. module class_ring VK\n 2. field class_ring\n 3. carrier VK = mat_kernel A\n 4. (\\<oplus>\\<^bsub>VK\\<^esub>) = (+)\n 5. \\<zero>\\<^bsub>VK\\<^esub> = 0\\<^sub>v nc\n 6. (\\<odot>\\<^bsub>VK\\<^esub>) = (\\<cdot>\\<^sub>v)\n 7. carrier class_ring = UNIV\n 8. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 9. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 10. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e1)\nA total of 17 subgoals...", "apply (rule NC.submodule_is_module)"], ["proof (prove)\ngoal (17 subgoals):\n 1. LinearCombinations.submodule class_ring (mat_kernel A) NC.V\n 2. field class_ring\n 3. carrier VK = mat_kernel A\n 4. (\\<oplus>\\<^bsub>VK\\<^esub>) = (+)\n 5. \\<zero>\\<^bsub>VK\\<^esub> = 0\\<^sub>v nc\n 6. (\\<odot>\\<^bsub>VK\\<^esub>) = (\\<cdot>\\<^sub>v)\n 7. carrier class_ring = UNIV\n 8. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n 9. (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n 10. \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e1)\nA total of 17 subgoals...", "apply (unfold_locales)"], ["proof (prove)\ngoal (19 subgoals):\n 1. mat_kernel A \\<subseteq> carrier NC.V\n 2. \\<And>v w.\n       \\<lbrakk>v \\<in> mat_kernel A; w \\<in> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus>\\<^bsub>NC.V\\<^esub> w \\<in> mat_kernel A\n 3. \\<zero>\\<^bsub>NC.V\\<^esub> \\<in> mat_kernel A\n 4. \\<And>c v.\n       \\<lbrakk>c \\<in> carrier class_ring; v \\<in> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> c \\<odot>\\<^bsub>NC.V\\<^esub> v \\<in> mat_kernel A\n 5. carrier VK = mat_kernel A\n 6. (\\<oplus>\\<^bsub>VK\\<^esub>) = (+)\n 7. \\<zero>\\<^bsub>VK\\<^esub> = 0\\<^sub>v nc\n 8. (\\<odot>\\<^bsub>VK\\<^esub>) = (\\<cdot>\\<^sub>v)\n 9. carrier class_ring = UNIV\n 10. (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\nA total of 19 subgoals...", "by (insert A mult_add_distrib_mat_vec[OF A] mult_mat_vec[OF A] mat_kernel[OF A], auto simp: class_ring_simps)"], ["", "abbreviation \"basis \\<equiv> Ker.basis\""], ["", "abbreviation \"span \\<equiv> Ker.span\""], ["", "abbreviation \"lincomb \\<equiv> Ker.lincomb\""], ["", "abbreviation \"dim \\<equiv> Ker.dim\""], ["", "abbreviation \"lin_dep \\<equiv> Ker.lin_dep\""], ["", "abbreviation \"lin_indpt \\<equiv> Ker.lin_indpt\""], ["", "abbreviation \"gen_set \\<equiv> Ker.gen_set\""], ["", "lemma finsum_same:\n  assumes \"f : S \\<rightarrow> mat_kernel A\"\n  shows \"finsum VK f S = finsum NC.V f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum VK f S = finsum NC.V f S", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> S \\<rightarrow> mat_kernel A\n\ngoal (1 subgoal):\n 1. finsum VK f S = finsum NC.V f S", "proof (induct S rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>infinite Aa; f \\<in> Aa \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f Aa = finsum NC.V f Aa\n 2. f \\<in> {} \\<rightarrow> mat_kernel A \\<Longrightarrow>\n    finsum VK f {} = finsum NC.V f {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> mat_kernel A \\<Longrightarrow>\n        finsum VK f F = finsum NC.V f F;\n        f \\<in> insert x F \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f (insert x F) =\n                         finsum NC.V f (insert x F)", "case (insert s S)"], ["proof (state)\nthis:\n  finite S\n  s \\<notin> S\n  f \\<in> S \\<rightarrow> mat_kernel A \\<Longrightarrow>\n  finsum VK f S = finsum NC.V f S\n  f \\<in> insert s S \\<rightarrow> mat_kernel A\n\ngoal (3 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>infinite Aa; f \\<in> Aa \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f Aa = finsum NC.V f Aa\n 2. f \\<in> {} \\<rightarrow> mat_kernel A \\<Longrightarrow>\n    finsum VK f {} = finsum NC.V f {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> mat_kernel A \\<Longrightarrow>\n        finsum VK f F = finsum NC.V f F;\n        f \\<in> insert x F \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f (insert x F) =\n                         finsum NC.V f (insert x F)", "hence base: \"finite S\" \"s \\<notin> S\"\n      and f_VK: \"f : S \\<rightarrow> mat_kernel A\" \"f s : mat_kernel A\""], ["proof (prove)\nusing this:\n  finite S\n  s \\<notin> S\n  f \\<in> S \\<rightarrow> mat_kernel A \\<Longrightarrow>\n  finsum VK f S = finsum NC.V f S\n  f \\<in> insert s S \\<rightarrow> mat_kernel A\n\ngoal (1 subgoal):\n 1. (finite S &&& s \\<notin> S) &&&\n    f \\<in> S \\<rightarrow> mat_kernel A &&& f s \\<in> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  finite S\n  s \\<notin> S\n  f \\<in> S \\<rightarrow> mat_kernel A\n  f s \\<in> mat_kernel A\n\ngoal (3 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>infinite Aa; f \\<in> Aa \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f Aa = finsum NC.V f Aa\n 2. f \\<in> {} \\<rightarrow> mat_kernel A \\<Longrightarrow>\n    finsum VK f {} = finsum NC.V f {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> mat_kernel A \\<Longrightarrow>\n        finsum VK f F = finsum NC.V f F;\n        f \\<in> insert x F \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f (insert x F) =\n                         finsum NC.V f (insert x F)", "hence f_NC: \"f : S \\<rightarrow> carrier_vec nc\" \"f s : carrier_vec nc\""], ["proof (prove)\nusing this:\n  finite S\n  s \\<notin> S\n  f \\<in> S \\<rightarrow> mat_kernel A\n  f s \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. f \\<in> S \\<rightarrow> carrier_vec nc &&& f s \\<in> carrier_vec nc", "using mat_kernel[OF A]"], ["proof (prove)\nusing this:\n  finite S\n  s \\<notin> S\n  f \\<in> S \\<rightarrow> mat_kernel A\n  f s \\<in> mat_kernel A\n  mat_kernel A = {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}\n\ngoal (1 subgoal):\n 1. f \\<in> S \\<rightarrow> carrier_vec nc &&& f s \\<in> carrier_vec nc", "by auto"], ["proof (state)\nthis:\n  f \\<in> S \\<rightarrow> carrier_vec nc\n  f s \\<in> carrier_vec nc\n\ngoal (3 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>infinite Aa; f \\<in> Aa \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f Aa = finsum NC.V f Aa\n 2. f \\<in> {} \\<rightarrow> mat_kernel A \\<Longrightarrow>\n    finsum VK f {} = finsum NC.V f {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> mat_kernel A \\<Longrightarrow>\n        finsum VK f F = finsum NC.V f F;\n        f \\<in> insert x F \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f (insert x F) =\n                         finsum NC.V f (insert x F)", "have IH: \"finsum VK f S = finsum NC.V f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum VK f S = finsum NC.V f S", "using insert f_VK"], ["proof (prove)\nusing this:\n  finite S\n  s \\<notin> S\n  f \\<in> S \\<rightarrow> mat_kernel A \\<Longrightarrow>\n  finsum VK f S = finsum NC.V f S\n  f \\<in> insert s S \\<rightarrow> mat_kernel A\n  f \\<in> S \\<rightarrow> mat_kernel A\n  f s \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. finsum VK f S = finsum NC.V f S", "by auto"], ["proof (state)\nthis:\n  finsum VK f S = finsum NC.V f S\n\ngoal (3 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>infinite Aa; f \\<in> Aa \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f Aa = finsum NC.V f Aa\n 2. f \\<in> {} \\<rightarrow> mat_kernel A \\<Longrightarrow>\n    finsum VK f {} = finsum NC.V f {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> mat_kernel A \\<Longrightarrow>\n        finsum VK f F = finsum NC.V f F;\n        f \\<in> insert x F \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f (insert x F) =\n                         finsum NC.V f (insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  finsum VK f S = finsum NC.V f S\n\ngoal (1 subgoal):\n 1. finsum VK f (insert s S) = finsum NC.V f (insert s S)", "unfolding NC.M.finsum_insert[OF base f_NC]"], ["proof (prove)\nusing this:\n  finsum VK f S = finsum NC.V f S\n\ngoal (1 subgoal):\n 1. finsum VK f (insert s S) = f s + finsum NC.V f S", "unfolding Ker.finsum_insert[OF base f_VK]"], ["proof (prove)\nusing this:\n  finsum VK f S = finsum NC.V f S\n\ngoal (1 subgoal):\n 1. f s + finsum VK f S = f s + finsum NC.V f S", "by simp"], ["proof (state)\nthis:\n  finsum VK f (insert s S) = finsum NC.V f (insert s S)\n\ngoal (2 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>infinite Aa; f \\<in> Aa \\<rightarrow> mat_kernel A\\<rbrakk>\n       \\<Longrightarrow> finsum VK f Aa = finsum NC.V f Aa\n 2. f \\<in> {} \\<rightarrow> mat_kernel A \\<Longrightarrow>\n    finsum VK f {} = finsum NC.V f {}", "qed auto"], ["", "lemma lincomb_same:\n  assumes S_kernel: \"S \\<subseteq> mat_kernel A\"\n  shows \"lincomb a S = NC.lincomb a S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a S = NC.lincomb a S", "unfolding Ker.lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>VK\\<^esub>v\\<in>S. a v \\<cdot>\\<^sub>v v) =\n    NC.lincomb a S", "unfolding NC.lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>VK\\<^esub>v\\<in>S. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>NC.V\\<^esub>v\\<in>S. a v \\<cdot>\\<^sub>v v)", "apply(subst finsum_same)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> S \\<rightarrow> mat_kernel A\n 2. (\\<Oplus>\\<^bsub>NC.V\\<^esub>v\\<in>S. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>NC.V\\<^esub>v\\<in>S. a v \\<cdot>\\<^sub>v v)", "using S_kernel Ker.smult_closed[unfolded module_vec_simps class_ring_simps]"], ["proof (prove)\nusing this:\n  S \\<subseteq> mat_kernel A\n  \\<lbrakk>?a \\<in> UNIV; ?x \\<in> mat_kernel A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<cdot>\\<^sub>v ?x \\<in> mat_kernel A\n\ngoal (2 subgoals):\n 1. (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> S \\<rightarrow> mat_kernel A\n 2. (\\<Oplus>\\<^bsub>NC.V\\<^esub>v\\<in>S. a v \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>NC.V\\<^esub>v\\<in>S. a v \\<cdot>\\<^sub>v v)", "by auto"], ["", "lemma span_same:\n  assumes S_kernel: \"S \\<subseteq> mat_kernel A\"\n  shows \"span S = NC.span S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span S = NC.span S", "proof (rule;rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> span S \\<Longrightarrow> x \\<in> NC.span S\n 2. \\<And>x. x \\<in> NC.span S \\<Longrightarrow> x \\<in> span S", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> span S \\<Longrightarrow> x \\<in> NC.span S\n 2. \\<And>x. x \\<in> NC.span S \\<Longrightarrow> x \\<in> span S", "assume L: \"v : span S\""], ["proof (state)\nthis:\n  v \\<in> span S\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> span S \\<Longrightarrow> x \\<in> NC.span S\n 2. \\<And>x. x \\<in> NC.span S \\<Longrightarrow> x \\<in> span S", "show \"v : NC.span S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> NC.span S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> NC.span S", "obtain a U where know: \"finite U\" \"U \\<subseteq> S\" \"a : U \\<rightarrow> UNIV\" \"v = lincomb a U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U a.\n        \\<lbrakk>finite U; U \\<subseteq> S; a \\<in> U \\<rightarrow> UNIV;\n         v = lincomb a U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using L"], ["proof (prove)\nusing this:\n  v \\<in> span S\n\ngoal (1 subgoal):\n 1. (\\<And>U a.\n        \\<lbrakk>finite U; U \\<subseteq> S; a \\<in> U \\<rightarrow> UNIV;\n         v = lincomb a U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ker.span_def"], ["proof (prove)\nusing this:\n  v \\<in> {lincomb a A |a A.\n           finite A \\<and>\n           A \\<subseteq> S \\<and> a \\<in> A \\<rightarrow> UNIV}\n\ngoal (1 subgoal):\n 1. (\\<And>U a.\n        \\<lbrakk>finite U; U \\<subseteq> S; a \\<in> U \\<rightarrow> UNIV;\n         v = lincomb a U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite U\n  U \\<subseteq> S\n  a \\<in> U \\<rightarrow> UNIV\n  v = lincomb a U\n\ngoal (1 subgoal):\n 1. v \\<in> NC.span S", "hence v: \"v = NC.lincomb a U\""], ["proof (prove)\nusing this:\n  finite U\n  U \\<subseteq> S\n  a \\<in> U \\<rightarrow> UNIV\n  v = lincomb a U\n\ngoal (1 subgoal):\n 1. v = NC.lincomb a U", "using lincomb_same S_kernel"], ["proof (prove)\nusing this:\n  finite U\n  U \\<subseteq> S\n  a \\<in> U \\<rightarrow> UNIV\n  v = lincomb a U\n  ?S \\<subseteq> mat_kernel A \\<Longrightarrow>\n  lincomb ?a ?S = NC.lincomb ?a ?S\n  S \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. v = NC.lincomb a U", "by auto"], ["proof (state)\nthis:\n  v = NC.lincomb a U\n\ngoal (1 subgoal):\n 1. v \\<in> NC.span S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> NC.span S", "unfolding NC.span_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {NC.lincomb a A |a A. finite A \\<and> A \\<subseteq> S}", "by (rule,intro exI conjI;fact)"], ["proof (state)\nthis:\n  v \\<in> NC.span S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> NC.span S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> NC.span S \\<Longrightarrow> x \\<in> span S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> NC.span S \\<Longrightarrow> x \\<in> span S", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> NC.span S \\<Longrightarrow> x \\<in> span S", "assume R: \"v : NC.span S\""], ["proof (state)\nthis:\n  v \\<in> NC.span S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> NC.span S \\<Longrightarrow> x \\<in> span S", "show \"v : span S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> span S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> span S", "obtain a U where know: \"finite U\" \"U \\<subseteq> S\" \"v = NC.lincomb a U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U a.\n        \\<lbrakk>finite U; U \\<subseteq> S; v = NC.lincomb a U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R"], ["proof (prove)\nusing this:\n  v \\<in> NC.span S\n\ngoal (1 subgoal):\n 1. (\\<And>U a.\n        \\<lbrakk>finite U; U \\<subseteq> S; v = NC.lincomb a U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding NC.span_def"], ["proof (prove)\nusing this:\n  v \\<in> {NC.lincomb a A |a A. finite A \\<and> A \\<subseteq> S}\n\ngoal (1 subgoal):\n 1. (\\<And>U a.\n        \\<lbrakk>finite U; U \\<subseteq> S; v = NC.lincomb a U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite U\n  U \\<subseteq> S\n  v = NC.lincomb a U\n\ngoal (1 subgoal):\n 1. v \\<in> span S", "hence v: \"v = lincomb a U\""], ["proof (prove)\nusing this:\n  finite U\n  U \\<subseteq> S\n  v = NC.lincomb a U\n\ngoal (1 subgoal):\n 1. v = lincomb a U", "using lincomb_same S_kernel"], ["proof (prove)\nusing this:\n  finite U\n  U \\<subseteq> S\n  v = NC.lincomb a U\n  ?S \\<subseteq> mat_kernel A \\<Longrightarrow>\n  lincomb ?a ?S = NC.lincomb ?a ?S\n  S \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. v = lincomb a U", "by auto"], ["proof (state)\nthis:\n  v = lincomb a U\n\ngoal (1 subgoal):\n 1. v \\<in> span S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> span S", "unfolding Ker.span_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {lincomb a A |a A.\n             finite A \\<and>\n             A \\<subseteq> S \\<and> a \\<in> A \\<rightarrow> UNIV}", "by (rule, intro exI conjI, insert v know, auto)"], ["proof (state)\nthis:\n  v \\<in> span S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> span S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lindep_same:\n  assumes S_kernel: \"S \\<subseteq> mat_kernel A\"\n  shows \"Ker.lin_dep S = NC.lin_dep S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_dep S = NC.lin_dep S", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lin_dep S \\<Longrightarrow> NC.lin_dep S\n 2. NC.lin_dep S \\<Longrightarrow> lin_dep S", "note [simp] = module_vec_simps class_ring_simps"], ["proof (state)\nthis:\n  (\\<oplus>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (+)\n  \\<zero>\\<^bsub>module_vec ?ty ?n\\<^esub> = 0\\<^sub>v ?n\n  carrier (module_vec ?ty ?n) = carrier_vec ?n\n  (\\<odot>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (\\<cdot>\\<^sub>v)\n  carrier class_ring = UNIV\n  (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n  (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n  \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n  \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n  ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n  finsum class_ring = sum\n  a_inv class_ring = uminus\n  a_minus class_ring = (-)\n  finprod class_ring = prod\n  inv\\<^bsub>class_ring\\<^esub> ?x =\n  (if ?x = (0::?'a) then div0 else inverse ?x)\n  class_field \\<equiv> class_ring\n\ngoal (2 subgoals):\n 1. lin_dep S \\<Longrightarrow> NC.lin_dep S\n 2. NC.lin_dep S \\<Longrightarrow> lin_dep S", "{"], ["proof (state)\nthis:\n  (\\<oplus>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (+)\n  \\<zero>\\<^bsub>module_vec ?ty ?n\\<^esub> = 0\\<^sub>v ?n\n  carrier (module_vec ?ty ?n) = carrier_vec ?n\n  (\\<odot>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (\\<cdot>\\<^sub>v)\n  carrier class_ring = UNIV\n  (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n  (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n  \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n  \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n  ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n  finsum class_ring = sum\n  a_inv class_ring = uminus\n  a_minus class_ring = (-)\n  finprod class_ring = prod\n  inv\\<^bsub>class_ring\\<^esub> ?x =\n  (if ?x = (0::?'a) then div0 else inverse ?x)\n  class_field \\<equiv> class_ring\n\ngoal (2 subgoals):\n 1. lin_dep S \\<Longrightarrow> NC.lin_dep S\n 2. NC.lin_dep S \\<Longrightarrow> lin_dep S", "assume L: \"Ker.lin_dep S\""], ["proof (state)\nthis:\n  lin_dep S\n\ngoal (2 subgoals):\n 1. lin_dep S \\<Longrightarrow> NC.lin_dep S\n 2. NC.lin_dep S \\<Longrightarrow> lin_dep S", "then"], ["proof (chain)\npicking this:\n  lin_dep S", "obtain v a U\n    where finU: \"finite U\" and US: \"U \\<subseteq> S\"\n      and lc: \"lincomb a U = 0\\<^sub>v nc\"\n      and vU: \"v \\<in> U\"\n      and av0: \"a v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lin_dep S\n\ngoal (1 subgoal):\n 1. (\\<And>U a v.\n        \\<lbrakk>finite U; U \\<subseteq> S; lincomb a U = 0\\<^sub>v nc;\n         v \\<in> U; a v \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ker.lin_dep_def"], ["proof (prove)\nusing this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> S \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     lincomb a A = 0\\<^sub>v nc \\<and> v \\<in> A \\<and> a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U a v.\n        \\<lbrakk>finite U; U \\<subseteq> S; lincomb a U = 0\\<^sub>v nc;\n         v \\<in> U; a v \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite U\n  U \\<subseteq> S\n  lincomb a U = 0\\<^sub>v nc\n  v \\<in> U\n  a v \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. lin_dep S \\<Longrightarrow> NC.lin_dep S\n 2. NC.lin_dep S \\<Longrightarrow> lin_dep S", "have lc': \"NC.lincomb a U = 0\\<^sub>v nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NC.lincomb a U = 0\\<^sub>v nc", "using lc lincomb_same US S_kernel"], ["proof (prove)\nusing this:\n  lincomb a U = 0\\<^sub>v nc\n  ?S \\<subseteq> mat_kernel A \\<Longrightarrow>\n  lincomb ?a ?S = NC.lincomb ?a ?S\n  U \\<subseteq> S\n  S \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. NC.lincomb a U = 0\\<^sub>v nc", "by auto"], ["proof (state)\nthis:\n  NC.lincomb a U = 0\\<^sub>v nc\n\ngoal (2 subgoals):\n 1. lin_dep S \\<Longrightarrow> NC.lin_dep S\n 2. NC.lin_dep S \\<Longrightarrow> lin_dep S", "show \"NC.lin_dep S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NC.lin_dep S", "unfolding NC.lin_dep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A a v.\n       finite A \\<and>\n       A \\<subseteq> S \\<and>\n       True \\<and>\n       NC.lincomb a A = 0\\<^sub>v nc \\<and>\n       v \\<in> A \\<and> a v \\<noteq> (0::'a)", "by (intro exI conjI, insert finU US lc' vU av0, auto)"], ["proof (state)\nthis:\n  NC.lin_dep S\n\ngoal (1 subgoal):\n 1. NC.lin_dep S \\<Longrightarrow> lin_dep S", "}"], ["proof (state)\nthis:\n  lin_dep S \\<Longrightarrow> NC.lin_dep S\n\ngoal (1 subgoal):\n 1. NC.lin_dep S \\<Longrightarrow> lin_dep S", "assume R: \"NC.lin_dep S\""], ["proof (state)\nthis:\n  NC.lin_dep S\n\ngoal (1 subgoal):\n 1. NC.lin_dep S \\<Longrightarrow> lin_dep S", "then"], ["proof (chain)\npicking this:\n  NC.lin_dep S", "obtain v a U\n  where finU: \"finite U\" and US: \"U \\<subseteq> S\"\n    and lc: \"NC.lincomb a U = 0\\<^sub>v nc\"\n    and vU: \"v : U\"\n    and av0: \"a v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  NC.lin_dep S\n\ngoal (1 subgoal):\n 1. (\\<And>U a v.\n        \\<lbrakk>finite U; U \\<subseteq> S; NC.lincomb a U = 0\\<^sub>v nc;\n         v \\<in> U; a v \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding NC.lin_dep_def"], ["proof (prove)\nusing this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> S \\<and>\n     True \\<and>\n     NC.lincomb a A = 0\\<^sub>v nc \\<and>\n     v \\<in> A \\<and> a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U a v.\n        \\<lbrakk>finite U; U \\<subseteq> S; NC.lincomb a U = 0\\<^sub>v nc;\n         v \\<in> U; a v \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite U\n  U \\<subseteq> S\n  NC.lincomb a U = 0\\<^sub>v nc\n  v \\<in> U\n  a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. NC.lin_dep S \\<Longrightarrow> lin_dep S", "have lc': \"lincomb a U = zero VK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a U = \\<zero>\\<^bsub>VK\\<^esub>", "using lc lincomb_same US S_kernel"], ["proof (prove)\nusing this:\n  NC.lincomb a U = 0\\<^sub>v nc\n  ?S \\<subseteq> mat_kernel A \\<Longrightarrow>\n  lincomb ?a ?S = NC.lincomb ?a ?S\n  U \\<subseteq> S\n  S \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. lincomb a U = \\<zero>\\<^bsub>VK\\<^esub>", "by auto"], ["proof (state)\nthis:\n  lincomb a U = \\<zero>\\<^bsub>VK\\<^esub>\n\ngoal (1 subgoal):\n 1. NC.lin_dep S \\<Longrightarrow> lin_dep S", "show \"Ker.lin_dep S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_dep S", "unfolding Ker.lin_dep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A a v.\n       finite A \\<and>\n       A \\<subseteq> S \\<and>\n       a \\<in> A \\<rightarrow> UNIV \\<and>\n       lincomb a A = 0\\<^sub>v nc \\<and>\n       v \\<in> A \\<and> a v \\<noteq> (0::'a)", "by (intro exI conjI,insert finU US lc' vU av0, auto)"], ["proof (state)\nthis:\n  lin_dep S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lincomb_index:\n  assumes i: \"i < nc\"\n    and Xk: \"X \\<subseteq> mat_kernel A\"\n  shows \"lincomb a X $ i = sum (\\<lambda>x. a x * x $ i) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "have X: \"X \\<subseteq> carrier_vec nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> carrier_vec nc", "using Xk mat_kernel_def A"], ["proof (prove)\nusing this:\n  X \\<subseteq> mat_kernel A\n  mat_kernel ?A =\n  {v \\<in> carrier_vec (dim_col ?A).\n   ?A *\\<^sub>v v = 0\\<^sub>v (dim_row ?A)}\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. X \\<subseteq> carrier_vec nc", "by auto"], ["proof (state)\nthis:\n  X \\<subseteq> carrier_vec nc\n\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "using vec_space.lincomb_index[OF i X]"], ["proof (prove)\nusing this:\n  NC.lincomb ?a X $ i = (\\<Sum>x\\<in>X. ?a x * x $ i)\n\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "using lincomb_same[OF Xk]"], ["proof (prove)\nusing this:\n  NC.lincomb ?a X $ i = (\\<Sum>x\\<in>X. ?a x * x $ i)\n  lincomb ?a X = NC.lincomb ?a X\n\ngoal (1 subgoal):\n 1. lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)", "by auto"], ["proof (state)\nthis:\n  lincomb a X $ i = (\\<Sum>x\\<in>X. a x * x $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma find_base_vectors: assumes ref: \"row_echelon_form A\" \n  and A: \"A \\<in> carrier_mat nr nc\" shows\n  \"set (find_base_vectors A) \\<subseteq> mat_kernel A\"\n  \"0\\<^sub>v nc \\<notin> set (find_base_vectors A)\"\n  \"kernel.basis nc A (set (find_base_vectors A))\"\n  \"card (set (find_base_vectors A)) = nc - card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\"\n  \"length (pivot_positions A) = card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\"\n  \"kernel.dim nc A = nc - card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (find_base_vectors A) \\<subseteq> mat_kernel A &&&\n     0\\<^sub>v nc \\<notin> set (find_base_vectors A) &&&\n     vectorspace.basis class_ring\n      (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n      (set (find_base_vectors A))) &&&\n    card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc} &&&\n    length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc} &&&\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "note non_pivot_base = non_pivot_base[OF ref A]"], ["proof (state)\nthis:\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A)\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?qj\n                    \\<in> carrier_vec nc\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A)\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?qj $ ?qj = (1::'a)\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A)\\<rbrakk>\n  \\<Longrightarrow> A *\\<^sub>v non_pivot_base A (pivot_positions A) ?qj =\n                    0\\<^sub>v nr\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A); ?qj' < nc;\n   ?qj' \\<notin> snd ` set (pivot_positions A); ?qj \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?qj $ ?qj' =\n                    (0::'a)\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "let ?B = \"set (find_base_vectors A)\""], ["proof (state)\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "let ?pp = \"set (pivot_positions A)\""], ["proof (state)\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc", "have dim: \"dim_row A = nr\" \"dim_col A = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr &&& dim_col A = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "from ref[unfolded row_echelon_form_def]"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A)", "obtain p \n  where pivot: \"pivot_fun A p nc\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dim"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pivot_fun A p nc\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "note piv = pivot_funD[OF dim(1) pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> p ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < p ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> p ?i < p (Suc ?i) \\<or> p (Suc ?i) = nc\n  \\<lbrakk>?i < nr; p ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, p ?i) = (1::'a)\n  \\<lbrakk>?i < nr; p ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ?i) = (0::'a)\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "{"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> p ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < p ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> p ?i < p (Suc ?i) \\<or> p (Suc ?i) = nc\n  \\<lbrakk>?i < nr; p ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, p ?i) = (1::'a)\n  \\<lbrakk>?i < nr; p ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ?i) = (0::'a)\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "fix v"], ["proof (state)\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "assume \"v \\<in> ?B\""], ["proof (state)\nthis:\n  v \\<in> set (find_base_vectors A)\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "from this[unfolded find_base_vectors_def Let_def dim]"], ["proof (chain)\npicking this:\n  v \\<in> set (map (non_pivot_base A (pivot_positions A))\n                (filter\n                  (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n                  [0..<nc]))", "obtain c where c: \"c < nc\" \"c \\<notin> snd ` ?pp\"\n      and res: \"v = non_pivot_base A (pivot_positions A) c\""], ["proof (prove)\nusing this:\n  v \\<in> set (map (non_pivot_base A (pivot_positions A))\n                (filter\n                  (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n                  [0..<nc]))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < nc; c \\<notin> snd ` set (pivot_positions A);\n         v = non_pivot_base A (pivot_positions A) c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c < nc\n  c \\<notin> snd ` set (pivot_positions A)\n  v = non_pivot_base A (pivot_positions A) c\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "from non_pivot_base[OF c, folded res] c"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec nc\n  v $ c = (1::'a)\n  A *\\<^sub>v v = 0\\<^sub>v nr\n  \\<lbrakk>?qj' < nc; ?qj' \\<notin> snd ` set (pivot_positions A);\n   c \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> v $ ?qj' = (0::'a)\n  c < nc\n  c \\<notin> snd ` set (pivot_positions A)", "have \"v \\<in> mat_kernel A\" \"v \\<noteq> 0\\<^sub>v nc\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  v $ c = (1::'a)\n  A *\\<^sub>v v = 0\\<^sub>v nr\n  \\<lbrakk>?qj' < nc; ?qj' \\<notin> snd ` set (pivot_positions A);\n   c \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> v $ ?qj' = (0::'a)\n  c < nc\n  c \\<notin> snd ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. v \\<in> mat_kernel A &&& v \\<noteq> 0\\<^sub>v nc", "by (intro mat_kernelI[OF A], auto)"], ["proof (state)\nthis:\n  v \\<in> mat_kernel A\n  v \\<noteq> 0\\<^sub>v nc\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set (find_base_vectors A) \\<Longrightarrow>\n  ?v2 \\<in> mat_kernel A\n  ?v2 \\<in> set (find_base_vectors A) \\<Longrightarrow>\n  ?v2 \\<noteq> 0\\<^sub>v nc\n\ngoal (6 subgoals):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A\n 2. 0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n 3. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 4. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 5. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 6. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "thus sub: \"?B \\<subseteq> mat_kernel A\" and\n    \"0\\<^sub>v nc \\<notin> ?B\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> set (find_base_vectors A) \\<Longrightarrow>\n  ?v2 \\<in> mat_kernel A\n  ?v2 \\<in> set (find_base_vectors A) \\<Longrightarrow>\n  ?v2 \\<noteq> 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A &&&\n    0\\<^sub>v nc \\<notin> set (find_base_vectors A)", "by auto"], ["proof (state)\nthis:\n  set (find_base_vectors A) \\<subseteq> mat_kernel A\n  0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "{"], ["proof (state)\nthis:\n  set (find_base_vectors A) \\<subseteq> mat_kernel A\n  0\\<^sub>v nc \\<notin> set (find_base_vectors A)\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "fix j j'"], ["proof (state)\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "assume j: \"j < nc\" \"j \\<notin> snd ` ?pp\" and j': \"j' < nc\" \"j' \\<notin> snd ` ?pp\" and neq: \"j' \\<noteq> j\""], ["proof (state)\nthis:\n  j < nc\n  j \\<notin> snd ` set (pivot_positions A)\n  j' < nc\n  j' \\<notin> snd ` set (pivot_positions A)\n  j' \\<noteq> j\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "from non_pivot_base(2)[OF j] non_pivot_base(4)[OF j' j neq]"], ["proof (chain)\npicking this:\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n  non_pivot_base A (pivot_positions A) j' $ j = (0::'a)", "have \"non_pivot_base A (pivot_positions A) j \\<noteq> non_pivot_base A (pivot_positions A) j'\""], ["proof (prove)\nusing this:\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n  non_pivot_base A (pivot_positions A) j' $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. non_pivot_base A (pivot_positions A) j \\<noteq>\n    non_pivot_base A (pivot_positions A) j'", "by auto"], ["proof (state)\nthis:\n  non_pivot_base A (pivot_positions A) j \\<noteq>\n  non_pivot_base A (pivot_positions A) j'\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < nc; ?j2 \\<notin> snd ` set (pivot_positions A); ?j'2 < nc;\n   ?j'2 \\<notin> snd ` set (pivot_positions A); ?j'2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?j2 \\<noteq>\n                    non_pivot_base A (pivot_positions A) ?j'2\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "hence inj: \"inj_on (non_pivot_base A (pivot_positions A))\n     (set [j\\<leftarrow>[0..<nc] . j \\<notin> snd ` ?pp])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j2 < nc; ?j2 \\<notin> snd ` set (pivot_positions A); ?j'2 < nc;\n   ?j'2 \\<notin> snd ` set (pivot_positions A); ?j'2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?j2 \\<noteq>\n                    non_pivot_base A (pivot_positions A) ?j'2\n\ngoal (1 subgoal):\n 1. inj_on (non_pivot_base A (pivot_positions A))\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc]))", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j2 < nc; ?j2 \\<notin> snd ` set (pivot_positions A); ?j'2 < nc;\n   ?j'2 \\<notin> snd ` set (pivot_positions A); ?j'2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?j2 \\<noteq>\n                    non_pivot_base A (pivot_positions A) ?j'2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (filter\n                         (\\<lambda>j.\n                             j \\<notin> snd ` set (pivot_positions A))\n                         [0..<nc]).\n       \\<forall>y\\<in>set (filter\n                            (\\<lambda>j.\n                                j \\<notin> snd ` set (pivot_positions A))\n                            [0..<nc]).\n          non_pivot_base A (pivot_positions A) x =\n          non_pivot_base A (pivot_positions A) y \\<longrightarrow>\n          x = y", "by auto"], ["proof (state)\nthis:\n  inj_on (non_pivot_base A (pivot_positions A))\n   (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc]))\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "note pp = pivot_positions[OF A pivot]"], ["proof (state)\nthis:\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "have lc: \"length (pivot_positions A) = card (snd ` ?pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) = card (snd ` set (pivot_positions A))", "using distinct_card[OF pp(3)]"], ["proof (prove)\nusing this:\n  card (set (map snd (pivot_positions A))) =\n  length (map snd (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) = card (snd ` set (pivot_positions A))", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) = card (snd ` set (pivot_positions A))\n\ngoal (4 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 3. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n 4. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "show card: \"card ?B = nc - card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\"\n    \"length (pivot_positions A) = card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (find_base_vectors A)) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc} &&&\n    length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "unfolding find_base_vectors_def Let_def dim set_map  card_image[OF inj] pp(4)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc])) =\n    nc - length (pivot_positions A) &&&\n    length (pivot_positions A) = length (pivot_positions A)", "unfolding pp(1) lc"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) &&&\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n 2. card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "have \"nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n      = card {0 ..< nc} - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card {0..<nc} -\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "by auto"], ["proof (state)\nthis:\n  nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n  card {0..<nc} - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n\ngoal (2 subgoals):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n 2. card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "also"], ["proof (state)\nthis:\n  nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n  card {0..<nc} - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n\ngoal (2 subgoals):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n 2. card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "have \"\\<dots> = card ({0 ..< nc} - snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<nc} -\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card ({0..<nc} - snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "by (rule card_Diff_subset[symmetric], insert piv(1), force+)"], ["proof (state)\nthis:\n  card {0..<nc} -\n  card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n  card ({0..<nc} - snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n\ngoal (2 subgoals):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n 2. card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "also"], ["proof (state)\nthis:\n  card {0..<nc} -\n  card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n  card ({0..<nc} - snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n\ngoal (2 subgoals):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n 2. card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "have \"{0 ..< nc} - snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc} = (set [j\\<leftarrow>[0..<nc] . j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<nc} - snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc} =\n    set (filter\n          (\\<lambda>j.\n              j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n          [0..<nc])", "by auto"], ["proof (state)\nthis:\n  {0..<nc} - snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc} =\n  set (filter\n        (\\<lambda>j.\n            j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n        [0..<nc])\n\ngoal (2 subgoals):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n 2. card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "finally"], ["proof (chain)\npicking this:\n  nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n  card\n   (set (filter\n          (\\<lambda>j.\n              j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n          [0..<nc]))", "show \"card (set [j\\<leftarrow>[0..<nc] . j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}]) =\n      nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\""], ["proof (prove)\nusing this:\n  nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n  card\n   (set (filter\n          (\\<lambda>j.\n              j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n          [0..<nc]))\n\ngoal (1 subgoal):\n 1. card\n     (set (filter\n            (\\<lambda>j.\n                j \\<notin> snd `\n                           {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n            [0..<nc])) =\n    nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "by simp"], ["proof (state)\nthis:\n  card\n   (set (filter\n          (\\<lambda>j.\n              j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n          [0..<nc])) =\n  nc - card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n\ngoal (1 subgoal):\n 1. card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}) =\n    card (snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})", "qed auto"], ["proof (state)\nthis:\n  card (set (find_base_vectors A)) =\n  nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     (set (find_base_vectors A))\n 2. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "interpret kernel nr nc A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc A", "by (unfold_locales, rule A)"], ["proof (state)\ngoal (2 subgoals):\n 1. basis (set (find_base_vectors A))\n 2. dim = nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "show basis: \"basis ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis (set (find_base_vectors A))", "unfolding Ker.basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A)) \\<and>\n    span (set (find_base_vectors A)) = mat_kernel A \\<and>\n    set (find_base_vectors A) \\<subseteq> mat_kernel A", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. lin_indpt (set (find_base_vectors A))\n 2. span (set (find_base_vectors A)) = mat_kernel A\n 3. set (find_base_vectors A) \\<subseteq> mat_kernel A", "show \"span ?B = mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (set (find_base_vectors A)) = mat_kernel A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. span (set (find_base_vectors A)) \\<subseteq> mat_kernel A\n 2. mat_kernel A \\<subseteq> span (set (find_base_vectors A))", "show \"span ?B \\<subseteq> mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (set (find_base_vectors A)) \\<subseteq> mat_kernel A", "using sub"], ["proof (prove)\nusing this:\n  set (find_base_vectors A) \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. span (set (find_base_vectors A)) \\<subseteq> mat_kernel A", "by (rule Ker.span_is_subset2)"], ["proof (state)\nthis:\n  span (set (find_base_vectors A)) \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> span (set (find_base_vectors A))", "show \"mat_kernel A \\<subseteq> Ker.span ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> span (set (find_base_vectors A))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "assume \"v \\<in> mat_kernel A\""], ["proof (state)\nthis:\n  v \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "from mat_kernelD[OF A this]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr", "have v: \"v \\<in> carrier_vec nc\" and Av: \"A *\\<^sub>v v = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A *\\<^sub>v v = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "let ?bi = \"non_pivot_base A (pivot_positions A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "let ?ran = \"set [j\\<leftarrow>[0..<nc] . j \\<notin> snd ` ?pp]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "let ?ran' = \"set [j\\<leftarrow>[0..<nc] . j \\<in> snd ` ?pp]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "have dimv: \"dim_vec v = nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec v = nc", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. dim_vec v = nc", "by auto"], ["proof (state)\nthis:\n  dim_vec v = nc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "define I where \"I = (\\<lambda> b. SOME i. i \\<in> ?ran \\<and> ?bi i = b)\""], ["proof (state)\nthis:\n  I =\n  (\\<lambda>b.\n      SOME i.\n         i \\<in> set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]) \\<and>\n         non_pivot_base A (pivot_positions A) i = b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "{"], ["proof (state)\nthis:\n  I =\n  (\\<lambda>b.\n      SOME i.\n         i \\<in> set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]) \\<and>\n         non_pivot_base A (pivot_positions A) i = b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "assume j: \"j \\<in> ?ran\""], ["proof (state)\nthis:\n  j \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "hence \"\\<exists> i. i \\<in> ?ran \\<and> ?bi i = ?bi j\""], ["proof (prove)\nusing this:\n  j \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       i \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<and>\n       non_pivot_base A (pivot_positions A) i =\n       non_pivot_base A (pivot_positions A) j", "unfolding find_base_vectors_def Let_def dim"], ["proof (prove)\nusing this:\n  j \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       i \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<and>\n       non_pivot_base A (pivot_positions A) i =\n       non_pivot_base A (pivot_positions A) j", "by auto"], ["proof (state)\nthis:\n  \\<exists>i.\n     i \\<in> set (filter\n                   (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                   [0..<nc]) \\<and>\n     non_pivot_base A (pivot_positions A) i =\n     non_pivot_base A (pivot_positions A) j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "from someI_ex[OF this]"], ["proof (chain)\npicking this:\n  (SOME x.\n      x \\<in> set (filter\n                    (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                    [0..<nc]) \\<and>\n      non_pivot_base A (pivot_positions A) x =\n      non_pivot_base A (pivot_positions A) j)\n  \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n              [0..<nc]) \\<and>\n  non_pivot_base A (pivot_positions A)\n   (SOME x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<and>\n       non_pivot_base A (pivot_positions A) x =\n       non_pivot_base A (pivot_positions A) j) =\n  non_pivot_base A (pivot_positions A) j", "have I: \"I (?bi j) \\<in> ?ran\" and id: \"?bi (I (?bi j)) = ?bi j\""], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<in> set (filter\n                    (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                    [0..<nc]) \\<and>\n      non_pivot_base A (pivot_positions A) x =\n      non_pivot_base A (pivot_positions A) j)\n  \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n              [0..<nc]) \\<and>\n  non_pivot_base A (pivot_positions A)\n   (SOME x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<and>\n       non_pivot_base A (pivot_positions A) x =\n       non_pivot_base A (pivot_positions A) j) =\n  non_pivot_base A (pivot_positions A) j\n\ngoal (1 subgoal):\n 1. I (non_pivot_base A (pivot_positions A) j)\n    \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc]) &&&\n    non_pivot_base A (pivot_positions A)\n     (I (non_pivot_base A (pivot_positions A) j)) =\n    non_pivot_base A (pivot_positions A) j", "unfolding I_def"], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<in> set (filter\n                    (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                    [0..<nc]) \\<and>\n      non_pivot_base A (pivot_positions A) x =\n      non_pivot_base A (pivot_positions A) j)\n  \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n              [0..<nc]) \\<and>\n  non_pivot_base A (pivot_positions A)\n   (SOME x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<and>\n       non_pivot_base A (pivot_positions A) x =\n       non_pivot_base A (pivot_positions A) j) =\n  non_pivot_base A (pivot_positions A) j\n\ngoal (1 subgoal):\n 1. (SOME i.\n        i \\<in> set (filter\n                      (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                      [0..<nc]) \\<and>\n        non_pivot_base A (pivot_positions A) i =\n        non_pivot_base A (pivot_positions A) j)\n    \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc]) &&&\n    non_pivot_base A (pivot_positions A)\n     (SOME i.\n         i \\<in> set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]) \\<and>\n         non_pivot_base A (pivot_positions A) i =\n         non_pivot_base A (pivot_positions A) j) =\n    non_pivot_base A (pivot_positions A) j", "by blast+"], ["proof (state)\nthis:\n  I (non_pivot_base A (pivot_positions A) j)\n  \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n              [0..<nc])\n  non_pivot_base A (pivot_positions A)\n   (I (non_pivot_base A (pivot_positions A) j)) =\n  non_pivot_base A (pivot_positions A) j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "from inj_onD[OF inj id I j]"], ["proof (chain)\npicking this:\n  I (non_pivot_base A (pivot_positions A) j) = j", "have \"I (?bi j) = j\""], ["proof (prove)\nusing this:\n  I (non_pivot_base A (pivot_positions A) j) = j\n\ngoal (1 subgoal):\n 1. I (non_pivot_base A (pivot_positions A) j) = j", "."], ["proof (state)\nthis:\n  I (non_pivot_base A (pivot_positions A) j) = j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "}"], ["proof (state)\nthis:\n  ?j3\n  \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n              [0..<nc]) \\<Longrightarrow>\n  I (non_pivot_base A (pivot_positions A) ?j3) = ?j3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "note I = this"], ["proof (state)\nthis:\n  ?j3\n  \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n              [0..<nc]) \\<Longrightarrow>\n  I (non_pivot_base A (pivot_positions A) ?j3) = ?j3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "define a where \"a = (\\<lambda> b. v $ (I b))\""], ["proof (state)\nthis:\n  a = (\\<lambda>b. v $ I b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "from Ker.lincomb_closed[OF sub]"], ["proof (chain)\npicking this:\n  ?a \\<in> set (find_base_vectors A) \\<rightarrow> UNIV \\<Longrightarrow>\n  lincomb ?a (set (find_base_vectors A)) \\<in> mat_kernel A", "have diml: \"dim_vec (lincomb a ?B) = nc\""], ["proof (prove)\nusing this:\n  ?a \\<in> set (find_base_vectors A) \\<rightarrow> UNIV \\<Longrightarrow>\n  lincomb ?a (set (find_base_vectors A)) \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. dim_vec (lincomb a (set (find_base_vectors A))) = nc", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  ?a \\<in> set (find_base_vectors A) \\<rightarrow> UNIV \\<Longrightarrow>\n  module.lincomb\n   (NC.vs\n     {v \\<in> carrier_vec (dim_col A).\n      A *\\<^sub>v v = 0\\<^sub>v (dim_row A)})\n   ?a (set (find_base_vectors A))\n  \\<in> {v \\<in> carrier_vec (dim_col A).\n         A *\\<^sub>v v = 0\\<^sub>v (dim_row A)}\n\ngoal (1 subgoal):\n 1. dim_vec\n     (module.lincomb\n       (NC.vs\n         {v \\<in> carrier_vec (dim_col A).\n          A *\\<^sub>v v = 0\\<^sub>v (dim_row A)})\n       a (set (find_base_vectors A))) =\n    nc", "using dim lincomb_same"], ["proof (prove)\nusing this:\n  ?a \\<in> set (find_base_vectors A) \\<rightarrow> UNIV \\<Longrightarrow>\n  module.lincomb\n   (NC.vs\n     {v \\<in> carrier_vec (dim_col A).\n      A *\\<^sub>v v = 0\\<^sub>v (dim_row A)})\n   ?a (set (find_base_vectors A))\n  \\<in> {v \\<in> carrier_vec (dim_col A).\n         A *\\<^sub>v v = 0\\<^sub>v (dim_row A)}\n  dim_row A = nr\n  dim_col A = nc\n  ?S \\<subseteq> mat_kernel A \\<Longrightarrow>\n  lincomb ?a ?S = NC.lincomb ?a ?S\n\ngoal (1 subgoal):\n 1. dim_vec\n     (module.lincomb\n       (NC.vs\n         {v \\<in> carrier_vec (dim_col A).\n          A *\\<^sub>v v = 0\\<^sub>v (dim_row A)})\n       a (set (find_base_vectors A))) =\n    nc", "by auto"], ["proof (state)\nthis:\n  dim_vec (lincomb a (set (find_base_vectors A))) = nc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "have \"v = lincomb a ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = lincomb a (set (find_base_vectors A))", "proof (rule eq_vecI; unfold diml dimv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "assume j: \"j < nc\""], ["proof (state)\nthis:\n  j < nc\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "have \"Ker.lincomb a ?B $ j = (\\<Sum>b\\<in> ?B. a b * b $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a (set (find_base_vectors A)) $ j =\n    (\\<Sum>b\\<in>set (find_base_vectors A). a b * b $ j)", "by (rule lincomb_index[OF j sub])"], ["proof (state)\nthis:\n  lincomb a (set (find_base_vectors A)) $ j =\n  (\\<Sum>b\\<in>set (find_base_vectors A). a b * b $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "also"], ["proof (state)\nthis:\n  lincomb a (set (find_base_vectors A)) $ j =\n  (\\<Sum>b\\<in>set (find_base_vectors A). a b * b $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "have \"\\<dots> = (\\<Sum> i\\<in> ?ran. v $ i * ?bi i $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>set (find_base_vectors A). a b * b $ j) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "proof (subst sum.reindex_cong[OF inj])"], ["proof (state)\ngoal (3 subgoals):\n 1. set (find_base_vectors A) =\n    non_pivot_base A (pivot_positions A) `\n    set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc])\n 2. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       a (non_pivot_base A (pivot_positions A) x) *\n       non_pivot_base A (pivot_positions A) x $ j =\n       ?h x\n 3. sum ?h\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc])) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "show \"?B = ?bi ` ?ran\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors A) =\n    non_pivot_base A (pivot_positions A) `\n    set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc])", "unfolding find_base_vectors_def Let_def dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (non_pivot_base A (pivot_positions A))\n          (filter (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n            [0..<nc])) =\n    non_pivot_base A (pivot_positions A) `\n    set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc])", "by auto"], ["proof (state)\nthis:\n  set (find_base_vectors A) =\n  non_pivot_base A (pivot_positions A) `\n  set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n        [0..<nc])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       a (non_pivot_base A (pivot_positions A) x) *\n       non_pivot_base A (pivot_positions A) x $ j =\n       ?h x\n 2. sum ?h\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc])) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       a (non_pivot_base A (pivot_positions A) x) *\n       non_pivot_base A (pivot_positions A) x $ j =\n       ?h x\n 2. sum ?h\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc])) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "assume \"i \\<in> ?ran\""], ["proof (state)\nthis:\n  i \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       a (non_pivot_base A (pivot_positions A) x) *\n       non_pivot_base A (pivot_positions A) x $ j =\n       ?h x\n 2. sum ?h\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc])) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "hence \"I (?bi i) = i\""], ["proof (prove)\nusing this:\n  i \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (1 subgoal):\n 1. I (non_pivot_base A (pivot_positions A) i) = i", "by (rule I)"], ["proof (state)\nthis:\n  I (non_pivot_base A (pivot_positions A) i) = i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       a (non_pivot_base A (pivot_positions A) x) *\n       non_pivot_base A (pivot_positions A) x $ j =\n       ?h x\n 2. sum ?h\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc])) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "hence \"a (?bi i) = v $ i\""], ["proof (prove)\nusing this:\n  I (non_pivot_base A (pivot_positions A) i) = i\n\ngoal (1 subgoal):\n 1. a (non_pivot_base A (pivot_positions A) i) = v $ i", "unfolding a_def"], ["proof (prove)\nusing this:\n  I (non_pivot_base A (pivot_positions A) i) = i\n\ngoal (1 subgoal):\n 1. v $ I (non_pivot_base A (pivot_positions A) i) = v $ i", "by simp"], ["proof (state)\nthis:\n  a (non_pivot_base A (pivot_positions A) i) = v $ i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       a (non_pivot_base A (pivot_positions A) x) *\n       non_pivot_base A (pivot_positions A) x $ j =\n       ?h x\n 2. sum ?h\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc])) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "thus \"a (?bi i) * ?bi i $ j = v $ i * ?bi i $ j\""], ["proof (prove)\nusing this:\n  a (non_pivot_base A (pivot_positions A) i) = v $ i\n\ngoal (1 subgoal):\n 1. a (non_pivot_base A (pivot_positions A) i) *\n    non_pivot_base A (pivot_positions A) i $ j =\n    v $ i * non_pivot_base A (pivot_positions A) i $ j", "by simp"], ["proof (state)\nthis:\n  a (non_pivot_base A (pivot_positions A) i) *\n  non_pivot_base A (pivot_positions A) i $ j =\n  v $ i * non_pivot_base A (pivot_positions A) i $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ x * non_pivot_base A (pivot_positions A) x $ j) =\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set (find_base_vectors A). a b * b $ j) =\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set (find_base_vectors A). a b * b $ j) =\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "have \"\\<dots> = v $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "proof (cases \"j \\<in> ?ran\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "case True"], ["proof (state)\nthis:\n  j \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "hence nmem: \"j \\<notin> snd ` set (pivot_positions A)\""], ["proof (prove)\nusing this:\n  j \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (1 subgoal):\n 1. j \\<notin> snd ` set (pivot_positions A)", "by auto"], ["proof (state)\nthis:\n  j \\<notin> snd ` set (pivot_positions A)\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "note npb = non_pivot_base[OF j nmem]"], ["proof (state)\nthis:\n  non_pivot_base A (pivot_positions A) j \\<in> carrier_vec nc\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n  A *\\<^sub>v non_pivot_base A (pivot_positions A) j = 0\\<^sub>v nr\n  \\<lbrakk>?qj' < nc; ?qj' \\<notin> snd ` set (pivot_positions A);\n   j \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) j $ ?qj' = (0::'a)\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"(\\<Sum> i\\<in> ?ran. v $ i * (?bi i) $ j) =\n              v $ j * ?bi j $ j + (\\<Sum> i\\<in> ?ran - {j}. v $ i * ?bi i $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j * non_pivot_base A (pivot_positions A) j $ j +\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]) -\n                 {j}.\n       v $ i * non_pivot_base A (pivot_positions A) i $ j)", "by (subst sum.remove[OF _ True], auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  v $ j * non_pivot_base A (pivot_positions A) j $ j +\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {j}.\n     v $ i * non_pivot_base A (pivot_positions A) i $ j)\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  v $ j * non_pivot_base A (pivot_positions A) j $ j +\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {j}.\n     v $ i * non_pivot_base A (pivot_positions A) i $ j)\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"?bi j $ j = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_pivot_base A (pivot_positions A) j $ j = (1::'a)", "using npb"], ["proof (prove)\nusing this:\n  non_pivot_base A (pivot_positions A) j \\<in> carrier_vec nc\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n  A *\\<^sub>v non_pivot_base A (pivot_positions A) j = 0\\<^sub>v nr\n  \\<lbrakk>?qj' < nc; ?qj' \\<notin> snd ` set (pivot_positions A);\n   j \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) j $ ?qj' = (0::'a)\n\ngoal (1 subgoal):\n 1. non_pivot_base A (pivot_positions A) j $ j = (1::'a)", "by simp"], ["proof (state)\nthis:\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"(\\<Sum> i \\<in> ?ran - {j}. v $ i * ?bi i $ j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]) -\n                 {j}.\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    (0::'a)", "using insert non_pivot_base(4)[OF _ _ j nmem]"], ["proof (prove)\nusing this:\n  ListMem ?x ?xs \\<Longrightarrow> ListMem ?x (?y # ?xs)\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A);\n   ?qj \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?qj $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]) -\n                 {j}.\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    (0::'a)", "by (intro sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {j}.\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. j \\<in> set (filter\n                  (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                  [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j\n 2. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  v $ j * (1::'a) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  v $ j * (1::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  v $ j\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "case False"], ["proof (state)\nthis:\n  j \\<notin> set (filter\n                   (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                   [0..<nc])\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "with j"], ["proof (chain)\npicking this:\n  j < nc\n  j \\<notin> set (filter\n                   (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                   [0..<nc])", "have jpp: \"j \\<in> snd ` ?pp\""], ["proof (prove)\nusing this:\n  j < nc\n  j \\<notin> set (filter\n                   (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                   [0..<nc])\n\ngoal (1 subgoal):\n 1. j \\<in> snd ` set (pivot_positions A)", "by auto"], ["proof (state)\nthis:\n  j \\<in> snd ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "with j pp"], ["proof (chain)\npicking this:\n  j < nc\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n  j \\<in> snd ` set (pivot_positions A)", "obtain i where i: \"i < nr\" and ji: \"j = p i\" and pi: \"p i < nc\""], ["proof (prove)\nusing this:\n  j < nc\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n  j \\<in> snd ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < nr; j = p i; p i < nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < nr\n  j = p i\n  p i < nc\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "from arg_cong[OF Av, of \"\\<lambda> u. u $ i\"] i A"], ["proof (chain)\npicking this:\n  (A *\\<^sub>v v) $ i = 0\\<^sub>v nr $ i\n  i < nr\n  A \\<in> carrier_mat nr nc", "have \"v $ j = v $ j - row A i \\<bullet> v\""], ["proof (prove)\nusing this:\n  (A *\\<^sub>v v) $ i = 0\\<^sub>v nr $ i\n  i < nr\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. v $ j = v $ j - row A i \\<bullet> v", "by auto"], ["proof (state)\nthis:\n  v $ j = v $ j - row A i \\<bullet> v\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  v $ j = v $ j - row A i \\<bullet> v\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"row A i \\<bullet> v = (\\<Sum> j = 0 ..< nc. A $$ (i,j) * v $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> v = (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j)", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec v. row A i $ ia * v $ ia) =\n    (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j)", "using v A i"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  A \\<in> carrier_mat nr nc\n  i < nr\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec v. row A i $ ia * v $ ia) =\n    (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j)", "by auto"], ["proof (state)\nthis:\n  row A i \\<bullet> v = (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  row A i \\<bullet> v = (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"\\<dots> = (\\<Sum> j \\<in> ?ran. A $$ (i,j) * v $ j) +  (\\<Sum> j \\<in> ?ran'. A $$ (i,j) * v $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j) =\n    (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       A $$ (i, j) * v $ j) +\n    (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       A $$ (i, j) * v $ j)", "by (subst sum.union_disjoint[symmetric], auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j) =\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     A $$ (i, j) * v $ j) +\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     A $$ (i, j) * v $ j)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nc. A $$ (i, j) * v $ j) =\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     A $$ (i, j) * v $ j) +\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     A $$ (i, j) * v $ j)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"(\\<Sum> j \\<in> ?ran'. A $$ (i,j) * v $ j) =\n              A $$ (i,p i) * v $ j + (\\<Sum> j \\<in> ?ran' - {p i}. A $$ (i,j) * v $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       A $$ (i, j) * v $ j) =\n    A $$ (i, p i) * v $ j +\n    (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                       [0..<nc]) -\n                 {p i}.\n       A $$ (i, j) * v $ j)", "using jpp"], ["proof (prove)\nusing this:\n  j \\<in> snd ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       A $$ (i, j) * v $ j) =\n    A $$ (i, p i) * v $ j +\n    (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                       [0..<nc]) -\n                 {p i}.\n       A $$ (i, j) * v $ j)", "by (subst sum.remove, auto simp: ji i pi)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     A $$ (i, j) * v $ j) =\n  A $$ (i, p i) * v $ j +\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i}.\n     A $$ (i, j) * v $ j)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     A $$ (i, j) * v $ j) =\n  A $$ (i, p i) * v $ j +\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i}.\n     A $$ (i, j) * v $ j)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"A $$ (i, p i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, p i) = (1::'a)", "using piv(4)[OF i] pi ji"], ["proof (prove)\nusing this:\n  p i < nc \\<Longrightarrow> A $$ (i, p i) = (1::'a)\n  p i < nc\n  j = p i\n\ngoal (1 subgoal):\n 1. A $$ (i, p i) = (1::'a)", "by auto"], ["proof (state)\nthis:\n  A $$ (i, p i) = (1::'a)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  A $$ (i, p i) = (1::'a)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"(\\<Sum> j \\<in> ?ran' - {p i}. A $$ (i,j) * v $ j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                       [0..<nc]) -\n                 {p i}.\n       A $$ (i, j) * v $ j) =\n    (0::'a)", "proof (rule sum.neutral, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i} \\<Longrightarrow>\n       A $$ (i, x) * v $ x = (0::'a)", "fix j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i} \\<Longrightarrow>\n       A $$ (i, x) * v $ x = (0::'a)", "assume \"j' \\<in> ?ran' - {p i}\""], ["proof (state)\nthis:\n  j' \\<in> set (filter (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                 [0..<nc]) -\n           {p i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i} \\<Longrightarrow>\n       A $$ (i, x) * v $ x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  j' \\<in> set (filter (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                 [0..<nc]) -\n           {p i}", "obtain i' where i': \"i' < nr\" and j': \"j' = p i'\" and pi': \"p i' \\<noteq> nc\" and neq: \"p i' \\<noteq> p i\""], ["proof (prove)\nusing this:\n  j' \\<in> set (filter (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                 [0..<nc]) -\n           {p i}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i' < nr; j' = p i'; p i' \\<noteq> nc;\n         p i' \\<noteq> p i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding pp"], ["proof (prove)\nusing this:\n  j' \\<in> set (filter\n                 (\\<lambda>j.\n                     j \\<in> snd `\n                             {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n                 [0..<nc]) -\n           {p i}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i' < nr; j' = p i'; p i' \\<noteq> nc;\n         p i' \\<noteq> p i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' < nr\n  j' = p i'\n  p i' \\<noteq> nc\n  p i' \\<noteq> p i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i} \\<Longrightarrow>\n       A $$ (i, x) * v $ x = (0::'a)", "from pi' piv[OF i']"], ["proof (chain)\npicking this:\n  p i' \\<noteq> nc\n  p i' \\<le> nc\n  ?j < p i' \\<Longrightarrow> A $$ (i', ?j) = (0::'a)\n  Suc i' < nr \\<Longrightarrow> p i' < p (Suc i') \\<or> p (Suc i') = nc\n  p i' < nc \\<Longrightarrow> A $$ (i', p i') = (1::'a)\n  \\<lbrakk>p i' < nc; ?i' < nr; ?i' \\<noteq> i'\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p i') = (0::'a)", "have pi': \"p i' < nc\""], ["proof (prove)\nusing this:\n  p i' \\<noteq> nc\n  p i' \\<le> nc\n  ?j < p i' \\<Longrightarrow> A $$ (i', ?j) = (0::'a)\n  Suc i' < nr \\<Longrightarrow> p i' < p (Suc i') \\<or> p (Suc i') = nc\n  p i' < nc \\<Longrightarrow> A $$ (i', p i') = (1::'a)\n  \\<lbrakk>p i' < nc; ?i' < nr; ?i' \\<noteq> i'\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p i') = (0::'a)\n\ngoal (1 subgoal):\n 1. p i' < nc", "by auto"], ["proof (state)\nthis:\n  p i' < nc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i} \\<Longrightarrow>\n       A $$ (i, x) * v $ x = (0::'a)", "from pp pi' neq j i' i"], ["proof (chain)\npicking this:\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n  p i' < nc\n  p i' \\<noteq> p i\n  j < nc\n  i' < nr\n  i < nr", "have \"i \\<noteq> i'\""], ["proof (prove)\nusing this:\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n  p i' < nc\n  p i' \\<noteq> p i\n  j < nc\n  i' < nr\n  i < nr\n\ngoal (1 subgoal):\n 1. i \\<noteq> i'", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> i'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i} \\<Longrightarrow>\n       A $$ (i, x) * v $ x = (0::'a)", "from piv(5)[OF i' pi' i this]"], ["proof (chain)\npicking this:\n  A $$ (i, p i') = (0::'a)", "show \"A $$ (i,j') * v $ j' = 0\""], ["proof (prove)\nusing this:\n  A $$ (i, p i') = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j') * v $ j' = (0::'a)", "unfolding j'"], ["proof (prove)\nusing this:\n  A $$ (i, p i') = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, p i') * v $ p i' = (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $$ (i, j') * v $ j' = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i}.\n     A $$ (i, j) * v $ j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<in> snd ` set (pivot_positions A))\n                     [0..<nc]) -\n               {p i}.\n     A $$ (i, j) * v $ j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "have \"(\\<Sum> j \\<in> ?ran. A $$ (i,j) * v $ j) = - (\\<Sum> j \\<in> ?ran. v $ j * - A $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       A $$ (i, j) * v $ j) =\n    - (\\<Sum>j\\<in>set (filter\n                         (\\<lambda>j.\n                             j \\<notin> snd ` set (pivot_positions A))\n                         [0..<nc]).\n         v $ j * - A $$ (i, j))", "unfolding sum_negf[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       A $$ (i, j) * v $ j) =\n    (\\<Sum>x\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       - (v $ x * - A $$ (i, x)))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     A $$ (i, j) * v $ j) =\n  - (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ j * - A $$ (i, j))\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "finally"], ["proof (chain)\npicking this:\n  v $ j =\n  v $ j -\n  (- (\\<Sum>j\\<in>set (filter\n                        (\\<lambda>j.\n                            j \\<notin> snd ` set (pivot_positions A))\n                        [0..<nc]).\n        v $ j * - A $$ (i, j)) +\n   ((1::'a) * v $ j + (0::'a)))", "have vj: \"v $ j = (\\<Sum> j \\<in> ?ran. v $ j * - A $$ (i,j))\""], ["proof (prove)\nusing this:\n  v $ j =\n  v $ j -\n  (- (\\<Sum>j\\<in>set (filter\n                        (\\<lambda>j.\n                            j \\<notin> snd ` set (pivot_positions A))\n                        [0..<nc]).\n        v $ j * - A $$ (i, j)) +\n   ((1::'a) * v $ j + (0::'a)))\n\ngoal (1 subgoal):\n 1. v $ j =\n    (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ j * - A $$ (i, j))", "by simp"], ["proof (state)\nthis:\n  v $ j =\n  (\\<Sum>j\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ j * - A $$ (i, j))\n\ngoal (1 subgoal):\n 1. j \\<notin> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n    (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    v $ j", "unfolding vj j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n    (\\<Sum>j\\<in>set (filter\n                       (\\<lambda>j.\n                           j \\<notin> snd ` set (pivot_positions A))\n                       [0..<nc]).\n       v $ j * - A $$ (i, j))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "fix j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "assume j': \"j' \\<in> ?ran\""], ["proof (state)\nthis:\n  j' \\<in> set (filter\n                 (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                 [0..<nc])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "from jpp j'"], ["proof (chain)\npicking this:\n  j \\<in> snd ` set (pivot_positions A)\n  j' \\<in> set (filter\n                 (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                 [0..<nc])", "have jj': \"j \\<noteq> j'\""], ["proof (prove)\nusing this:\n  j \\<in> snd ` set (pivot_positions A)\n  j' \\<in> set (filter\n                 (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                 [0..<nc])\n\ngoal (1 subgoal):\n 1. j \\<noteq> j'", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> j'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "let ?map = \"map prod.swap (pivot_positions A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "from ji i j"], ["proof (chain)\npicking this:\n  j = p i\n  i < nr\n  j < nc", "have \"(i,j) \\<in> set (pivot_positions A)\""], ["proof (prove)\nusing this:\n  j = p i\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> set (pivot_positions A)", "unfolding pp"], ["proof (prove)\nusing this:\n  j = p i\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}", "by auto"], ["proof (state)\nthis:\n  (i, j) \\<in> set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "hence mem: \"(j,i) \\<in> set ?map\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. (j, i) \\<in> set (map prod.swap (pivot_positions A))", "by auto"], ["proof (state)\nthis:\n  (j, i) \\<in> set (map prod.swap (pivot_positions A))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "from pp"], ["proof (chain)\npicking this:\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "have \"distinct (map fst ?map)\""], ["proof (prove)\nusing this:\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. distinct (map fst (map prod.swap (pivot_positions A)))", "unfolding map_map o_def prod.swap_def fst_conv"], ["proof (prove)\nusing this:\n  set (pivot_positions A) = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. distinct (map snd (pivot_positions A))", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (map prod.swap (pivot_positions A)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "from map_of_is_SomeI[OF this mem]"], ["proof (chain)\npicking this:\n  map_of (map prod.swap (pivot_positions A)) j = Some i", "have \"map_of ?map j = Some i\""], ["proof (prove)\nusing this:\n  map_of (map prod.swap (pivot_positions A)) j = Some i\n\ngoal (1 subgoal):\n 1. map_of (map prod.swap (pivot_positions A)) j = Some i", "by auto"], ["proof (state)\nthis:\n  map_of (map prod.swap (pivot_positions A)) j = Some i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "hence \"?bi j' $ j = - A $$ (i, j')\""], ["proof (prove)\nusing this:\n  map_of (map prod.swap (pivot_positions A)) j = Some i\n\ngoal (1 subgoal):\n 1. non_pivot_base A (pivot_positions A) j' $ j = - A $$ (i, j')", "unfolding non_pivot_base_def Let_def dim"], ["proof (prove)\nusing this:\n  map_of (map prod.swap (pivot_positions A)) j = Some i\n\ngoal (1 subgoal):\n 1. vec nc\n     (\\<lambda>i.\n         if i = j' then 1::'a\n         else case map_of (map prod.swap (pivot_positions A)) i of\n              None \\<Rightarrow> 0::'a\n              | Some j \\<Rightarrow> - A $$ (j, j')) $\n    j =\n    - A $$ (i, j')", "using j jj'"], ["proof (prove)\nusing this:\n  map_of (map prod.swap (pivot_positions A)) j = Some i\n  j < nc\n  j \\<noteq> j'\n\ngoal (1 subgoal):\n 1. vec nc\n     (\\<lambda>i.\n         if i = j' then 1::'a\n         else case map_of (map prod.swap (pivot_positions A)) i of\n              None \\<Rightarrow> 0::'a\n              | Some j \\<Rightarrow> - A $$ (j, j')) $\n    j =\n    - A $$ (i, j')", "by auto"], ["proof (state)\nthis:\n  non_pivot_base A (pivot_positions A) j' $ j = - A $$ (i, j')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]) \\<Longrightarrow>\n       v $ x * non_pivot_base A (pivot_positions A) x $ j =\n       v $ x * - A $$ (i, x)", "thus \"v $ j' * ?bi j' $ j = v $ j' * - A $$ (i,j')\""], ["proof (prove)\nusing this:\n  non_pivot_base A (pivot_positions A) j' $ j = - A $$ (i, j')\n\ngoal (1 subgoal):\n 1. v $ j' * non_pivot_base A (pivot_positions A) j' $ j =\n    v $ j' * - A $$ (i, j')", "by simp"], ["proof (state)\nthis:\n  v $ j' * non_pivot_base A (pivot_positions A) j' $ j =\n  v $ j' * - A $$ (i, j')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  v $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set (filter\n                     (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                     [0..<nc]).\n     v $ i * non_pivot_base A (pivot_positions A) i $ j) =\n  v $ j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       v $ i = lincomb a (set (find_base_vectors A)) $ i\n 2. nc = nc", "finally"], ["proof (chain)\npicking this:\n  lincomb a (set (find_base_vectors A)) $ j = v $ j", "show \"v $ j = lincomb a ?B $ j\""], ["proof (prove)\nusing this:\n  lincomb a (set (find_base_vectors A)) $ j = v $ j\n\ngoal (1 subgoal):\n 1. v $ j = lincomb a (set (find_base_vectors A)) $ j", ".."], ["proof (state)\nthis:\n  v $ j = lincomb a (set (find_base_vectors A)) $ j\n\ngoal (1 subgoal):\n 1. nc = nc", "qed auto"], ["proof (state)\nthis:\n  v = lincomb a (set (find_base_vectors A))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> span (set (find_base_vectors A))", "thus \"v \\<in> span ?B\""], ["proof (prove)\nusing this:\n  v = lincomb a (set (find_base_vectors A))\n\ngoal (1 subgoal):\n 1. v \\<in> span (set (find_base_vectors A))", "unfolding Ker.span_def"], ["proof (prove)\nusing this:\n  v = lincomb a (set (find_base_vectors A))\n\ngoal (1 subgoal):\n 1. v \\<in> {lincomb a Aa |a Aa.\n             finite Aa \\<and>\n             Aa \\<subseteq> set (find_base_vectors A) \\<and>\n             a \\<in> Aa \\<rightarrow> UNIV}", "by auto"], ["proof (state)\nthis:\n  v \\<in> span (set (find_base_vectors A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_kernel A \\<subseteq> span (set (find_base_vectors A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  span (set (find_base_vectors A)) = mat_kernel A\n\ngoal (2 subgoals):\n 1. lin_indpt (set (find_base_vectors A))\n 2. set (find_base_vectors A) \\<subseteq> mat_kernel A", "show \"?B \\<subseteq> mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors A) \\<subseteq> mat_kernel A", "by (rule sub)"], ["proof (state)\nthis:\n  set (find_base_vectors A) \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "{"], ["proof (state)\nthis:\n  set (find_base_vectors A) \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "fix a v"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "assume lc: \"lincomb a ?B = 0\\<^sub>v nc\" and vB: \"v \\<in> ?B\""], ["proof (state)\nthis:\n  lincomb a (set (find_base_vectors A)) = 0\\<^sub>v nc\n  v \\<in> set (find_base_vectors A)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "from vB[unfolded find_base_vectors_def Let_def dim]"], ["proof (chain)\npicking this:\n  v \\<in> set (map (non_pivot_base A (pivot_positions A))\n                (filter\n                  (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n                  [0..<nc]))", "obtain j where j: \"j < nc\" \"j \\<notin> snd ` ?pp\" and v: \"v = non_pivot_base A (pivot_positions A) j\""], ["proof (prove)\nusing this:\n  v \\<in> set (map (non_pivot_base A (pivot_positions A))\n                (filter\n                  (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n                  [0..<nc]))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < nc; j \\<notin> snd ` set (pivot_positions A);\n         v = non_pivot_base A (pivot_positions A) j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < nc\n  j \\<notin> snd ` set (pivot_positions A)\n  v = non_pivot_base A (pivot_positions A) j\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "from arg_cong[OF lc, of \"\\<lambda> v. v $ j\"] j"], ["proof (chain)\npicking this:\n  lincomb a (set (find_base_vectors A)) $ j = 0\\<^sub>v nc $ j\n  j < nc\n  j \\<notin> snd ` set (pivot_positions A)", "have \"0 = lincomb a ?B $ j\""], ["proof (prove)\nusing this:\n  lincomb a (set (find_base_vectors A)) $ j = 0\\<^sub>v nc $ j\n  j < nc\n  j \\<notin> snd ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. (0::'a) = lincomb a (set (find_base_vectors A)) $ j", "by auto"], ["proof (state)\nthis:\n  (0::'a) = lincomb a (set (find_base_vectors A)) $ j\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "also"], ["proof (state)\nthis:\n  (0::'a) = lincomb a (set (find_base_vectors A)) $ j\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "have \"\\<dots> = (\\<Sum>v\\<in>?B. a v * v $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a (set (find_base_vectors A)) $ j =\n    (\\<Sum>v\\<in>set (find_base_vectors A). a v * v $ j)", "by (subst lincomb_index[OF j(1) sub], simp)"], ["proof (state)\nthis:\n  lincomb a (set (find_base_vectors A)) $ j =\n  (\\<Sum>v\\<in>set (find_base_vectors A). a v * v $ j)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "also"], ["proof (state)\nthis:\n  lincomb a (set (find_base_vectors A)) $ j =\n  (\\<Sum>v\\<in>set (find_base_vectors A). a v * v $ j)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "have \"\\<dots> = a v * v $ j + (\\<Sum>w\\<in>?B - {v}. a w * w $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>set (find_base_vectors A). a v * v $ j) =\n    a v * v $ j + (\\<Sum>w\\<in>set (find_base_vectors A) - {v}. a w * w $ j)", "by (subst sum.remove[OF _ vB], auto)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>set (find_base_vectors A). a v * v $ j) =\n  a v * v $ j + (\\<Sum>w\\<in>set (find_base_vectors A) - {v}. a w * w $ j)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>set (find_base_vectors A). a v * v $ j) =\n  a v * v $ j + (\\<Sum>w\\<in>set (find_base_vectors A) - {v}. a w * w $ j)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "have \"a v * v $ j = a v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a v * v $ j = a v", "using non_pivot_base[OF j, folded v]"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  v $ j = (1::'a)\n  A *\\<^sub>v v = 0\\<^sub>v nr\n  \\<lbrakk>?qj' < nc; ?qj' \\<notin> snd ` set (pivot_positions A);\n   j \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> v $ ?qj' = (0::'a)\n\ngoal (1 subgoal):\n 1. a v * v $ j = a v", "by simp"], ["proof (state)\nthis:\n  a v * v $ j = a v\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "also"], ["proof (state)\nthis:\n  a v * v $ j = a v\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "have \"(\\<Sum>w\\<in>?B - {v}. a w * w $ j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>set (find_base_vectors A) - {v}. a w * w $ j) = (0::'a)", "proof (rule sum.neutral, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (find_base_vectors A) - {v} \\<Longrightarrow>\n       a x * x $ j = (0::'a)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (find_base_vectors A) - {v} \\<Longrightarrow>\n       a x * x $ j = (0::'a)", "assume wB: \"w \\<in> ?B - {v}\""], ["proof (state)\nthis:\n  w \\<in> set (find_base_vectors A) - {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (find_base_vectors A) - {v} \\<Longrightarrow>\n       a x * x $ j = (0::'a)", "from this[unfolded find_base_vectors_def Let_def dim]"], ["proof (chain)\npicking this:\n  w \\<in> set (map (non_pivot_base A (pivot_positions A))\n                (filter\n                  (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n                  [0..<nc])) -\n          {v}", "obtain j' where j': \"j' < nc\" \"j' \\<notin> snd ` ?pp\" and w: \"w = non_pivot_base A (pivot_positions A) j'\""], ["proof (prove)\nusing this:\n  w \\<in> set (map (non_pivot_base A (pivot_positions A))\n                (filter\n                  (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n                  [0..<nc])) -\n          {v}\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j' < nc; j' \\<notin> snd ` set (pivot_positions A);\n         w = non_pivot_base A (pivot_positions A) j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j' < nc\n  j' \\<notin> snd ` set (pivot_positions A)\n  w = non_pivot_base A (pivot_positions A) j'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (find_base_vectors A) - {v} \\<Longrightarrow>\n       a x * x $ j = (0::'a)", "with wB v"], ["proof (chain)\npicking this:\n  w \\<in> set (find_base_vectors A) - {v}\n  v = non_pivot_base A (pivot_positions A) j\n  j' < nc\n  j' \\<notin> snd ` set (pivot_positions A)\n  w = non_pivot_base A (pivot_positions A) j'", "have \"j' \\<noteq> j\""], ["proof (prove)\nusing this:\n  w \\<in> set (find_base_vectors A) - {v}\n  v = non_pivot_base A (pivot_positions A) j\n  j' < nc\n  j' \\<notin> snd ` set (pivot_positions A)\n  w = non_pivot_base A (pivot_positions A) j'\n\ngoal (1 subgoal):\n 1. j' \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  j' \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (find_base_vectors A) - {v} \\<Longrightarrow>\n       a x * x $ j = (0::'a)", "from non_pivot_base(4)[OF j' j this]"], ["proof (chain)\npicking this:\n  non_pivot_base A (pivot_positions A) j' $ j = (0::'a)", "show \"a w * w $ j = 0\""], ["proof (prove)\nusing this:\n  non_pivot_base A (pivot_positions A) j' $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. a w * w $ j = (0::'a)", "unfolding w"], ["proof (prove)\nusing this:\n  non_pivot_base A (pivot_positions A) j' $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. a (non_pivot_base A (pivot_positions A) j') *\n    non_pivot_base A (pivot_positions A) j' $ j =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  a w * w $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>w\\<in>set (find_base_vectors A) - {v}. a w * w $ j) = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "finally"], ["proof (chain)\npicking this:\n  (0::'a) = a v + (0::'a)", "have \"a v = 0\""], ["proof (prove)\nusing this:\n  (0::'a) = a v + (0::'a)\n\ngoal (1 subgoal):\n 1. a v = (0::'a)", "by simp"], ["proof (state)\nthis:\n  a v = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lincomb ?a3 (set (find_base_vectors A)) = 0\\<^sub>v nc;\n   ?v3 \\<in> set (find_base_vectors A)\\<rbrakk>\n  \\<Longrightarrow> ?a3 ?v3 = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "thus \"\\<not> lin_dep ?B\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lincomb ?a3 (set (find_base_vectors A)) = 0\\<^sub>v nc;\n   ?v3 \\<in> set (find_base_vectors A)\\<rbrakk>\n  \\<Longrightarrow> ?a3 ?v3 = (0::'a)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (find_base_vectors A))", "by (intro Ker.finite_lin_indpt2[OF finite_set sub], auto simp: class_field_def)"], ["proof (state)\nthis:\n  lin_indpt (set (find_base_vectors A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  basis (set (find_base_vectors A))\n\ngoal (1 subgoal):\n 1. dim = nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "show \"dim = nc - card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim = nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "using Ker.dim_basis[OF finite_set basis] card"], ["proof (prove)\nusing this:\n  dim = card (set (find_base_vectors A))\n  card (set (find_base_vectors A)) =\n  nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. dim = nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "by simp"], ["proof (state)\nthis:\n  dim = nc - card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition kernel_dim :: \"'a :: field mat \\<Rightarrow> nat\" where\n  [code del]: \"kernel_dim A = kernel.dim (dim_col A) A\""], ["", "lemma (in kernel) kernel_dim [simp]: \"kernel_dim A = dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim A = dim", "unfolding kernel_dim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (dim_col A)\n      \\<lparr>carrier := mat_kernel A\\<rparr>) =\n    dim", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (dim_col A)\n      \\<lparr>carrier := mat_kernel A\\<rparr>) =\n    dim", "by simp"], ["", "lemma kernel_dim_code[code]: \n  \"kernel_dim A = dim_col A - length (pivot_positions (gauss_jordan_single A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "define nr where \"nr = dim_row A\""], ["proof (state)\nthis:\n  nr = dim_row A\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "define nc where \"nc = dim_col A\""], ["proof (state)\nthis:\n  nc = dim_col A\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "let ?B = \"gauss_jordan_single A\""], ["proof (state)\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "have A: \"A \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat nr nc", "unfolding nr_def nc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_row A) (dim_col A)", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "from gauss_jordan_single[OF A refl]"], ["proof (chain)\npicking this:\n  ?x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v ?x = 0\\<^sub>v nr) =\n  (gauss_jordan_single A *\\<^sub>v ?x = 0\\<^sub>v nr)\n  gauss_jordan_single A \\<in> carrier_mat nr nc\n  row_echelon_form (gauss_jordan_single A)\n  \\<exists>P Q.\n     gauss_jordan_single A = P * A \\<and>\n     P \\<in> carrier_mat nr nr \\<and>\n     Q \\<in> carrier_mat nr nr \\<and>\n     P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr", "obtain P Q where AB: \"?B = P * A\" and QP: \"Q * P = 1\\<^sub>m nr\" and\n    P: \"P \\<in> carrier_mat nr nr\" and Q: \"Q \\<in> carrier_mat nr nr\" and B: \"?B \\<in> carrier_mat nr nc\" \n    and row: \"row_echelon_form ?B\""], ["proof (prove)\nusing this:\n  ?x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v ?x = 0\\<^sub>v nr) =\n  (gauss_jordan_single A *\\<^sub>v ?x = 0\\<^sub>v nr)\n  gauss_jordan_single A \\<in> carrier_mat nr nc\n  row_echelon_form (gauss_jordan_single A)\n  \\<exists>P Q.\n     gauss_jordan_single A = P * A \\<and>\n     P \\<in> carrier_mat nr nr \\<and>\n     Q \\<in> carrier_mat nr nr \\<and>\n     P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>gauss_jordan_single A = P * A; Q * P = 1\\<^sub>m nr;\n         P \\<in> carrier_mat nr nr; Q \\<in> carrier_mat nr nr;\n         gauss_jordan_single A \\<in> carrier_mat nr nc;\n         row_echelon_form (gauss_jordan_single A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gauss_jordan_single A = P * A\n  Q * P = 1\\<^sub>m nr\n  P \\<in> carrier_mat nr nr\n  Q \\<in> carrier_mat nr nr\n  gauss_jordan_single A \\<in> carrier_mat nr nc\n  row_echelon_form (gauss_jordan_single A)\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "interpret K: kernel nr nc ?B"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc (gauss_jordan_single A)", "by (unfold_locales, rule B)"], ["proof (state)\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "from mat_kernel_mult_eq[OF A P Q QP, folded AB]"], ["proof (chain)\npicking this:\n  mat_kernel (gauss_jordan_single A) = mat_kernel A", "have \"kernel_dim A = K.dim\""], ["proof (prove)\nusing this:\n  mat_kernel (gauss_jordan_single A) = mat_kernel A\n\ngoal (1 subgoal):\n 1. kernel_dim A = K.dim", "unfolding kernel_dim_def"], ["proof (prove)\nusing this:\n  mat_kernel (gauss_jordan_single A) = mat_kernel A\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (dim_col A)\n      \\<lparr>carrier := mat_kernel A\\<rparr>) =\n    K.dim", "using A"], ["proof (prove)\nusing this:\n  mat_kernel (gauss_jordan_single A) = mat_kernel A\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (dim_col A)\n      \\<lparr>carrier := mat_kernel A\\<rparr>) =\n    K.dim", "by simp"], ["proof (state)\nthis:\n  kernel_dim A = K.dim\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "also"], ["proof (state)\nthis:\n  kernel_dim A = K.dim\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "have \"\\<dots> = nc - length (pivot_positions ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K.dim = nc - length (pivot_positions (gauss_jordan_single A))", "using find_base_vectors[OF row B]"], ["proof (prove)\nusing this:\n  set (find_base_vectors (gauss_jordan_single A))\n  \\<subseteq> mat_kernel (gauss_jordan_single A)\n  0\\<^sub>v nc \\<notin> set (find_base_vectors (gauss_jordan_single A))\n  K.basis (set (find_base_vectors (gauss_jordan_single A)))\n  card (set (find_base_vectors (gauss_jordan_single A))) =\n  nc -\n  card\n   {i. i < nr \\<and> row (gauss_jordan_single A) i \\<noteq> 0\\<^sub>v nc}\n  length (pivot_positions (gauss_jordan_single A)) =\n  card\n   {i. i < nr \\<and> row (gauss_jordan_single A) i \\<noteq> 0\\<^sub>v nc}\n  K.dim =\n  nc -\n  card\n   {i. i < nr \\<and> row (gauss_jordan_single A) i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. K.dim = nc - length (pivot_positions (gauss_jordan_single A))", "by auto"], ["proof (state)\nthis:\n  K.dim = nc - length (pivot_positions (gauss_jordan_single A))\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "also"], ["proof (state)\nthis:\n  K.dim = nc - length (pivot_positions (gauss_jordan_single A))\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "have \"\\<dots> = dim_col A - length (pivot_positions ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nc - length (pivot_positions (gauss_jordan_single A)) =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "unfolding nc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A - length (pivot_positions (gauss_jordan_single A)) =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "by simp"], ["proof (state)\nthis:\n  nc - length (pivot_positions (gauss_jordan_single A)) =\n  dim_col A - length (pivot_positions (gauss_jordan_single A))\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "finally"], ["proof (chain)\npicking this:\n  kernel_dim A =\n  dim_col A - length (pivot_positions (gauss_jordan_single A))", "show ?thesis"], ["proof (prove)\nusing this:\n  kernel_dim A =\n  dim_col A - length (pivot_positions (gauss_jordan_single A))\n\ngoal (1 subgoal):\n 1. kernel_dim A =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "."], ["proof (state)\nthis:\n  kernel_dim A =\n  dim_col A - length (pivot_positions (gauss_jordan_single A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kernel_one_mat: fixes A :: \"'a :: field mat\" and n :: nat\n  defines A: \"A \\<equiv> 1\\<^sub>m n\"\n  shows \n    \"kernel.dim n A = 0\"\n    \"kernel.basis n A {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0 &&&\n    vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "have Ac: \"A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "have \"pivot_fun A id n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun A id n", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (1\\<^sub>m n) id n", "by (rule pivot_funI, auto)"], ["proof (state)\nthis:\n  pivot_fun A id n\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "hence row: \"row_echelon_form A\""], ["proof (prove)\nusing this:\n  pivot_fun A id n\n\ngoal (1 subgoal):\n 1. row_echelon_form A", "unfolding row_echelon_form_def A"], ["proof (prove)\nusing this:\n  pivot_fun (1\\<^sub>m n) id n\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun (1\\<^sub>m n) f (dim_col (1\\<^sub>m n))", "by auto"], ["proof (state)\nthis:\n  row_echelon_form A\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "have \"{i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n} = {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n} = {0..<n}", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < n \\<and> row (1\\<^sub>m n) i \\<noteq> 0\\<^sub>v n} = {0..<n}", "by auto"], ["proof (state)\nthis:\n  {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n} = {0..<n}\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "hence id: \"card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n} = n\""], ["proof (prove)\nusing this:\n  {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n} = {0..<n}\n\ngoal (1 subgoal):\n 1. card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n} = n", "by auto"], ["proof (state)\nthis:\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n} = n\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "interpret kernel n n A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel n n A", "by (unfold_locales, rule Ac)"], ["proof (state)\ngoal (2 subgoals):\n 1. dim = 0\n 2. basis {}", "from find_base_vectors[OF row Ac, unfolded id]"], ["proof (chain)\npicking this:\n  set (find_base_vectors A) \\<subseteq> mat_kernel A\n  0\\<^sub>v n \\<notin> set (find_base_vectors A)\n  basis (set (find_base_vectors A))\n  card (set (find_base_vectors A)) = n - n\n  length (pivot_positions A) = n\n  dim = n - n", "show \"dim = 0\" \"basis {}\""], ["proof (prove)\nusing this:\n  set (find_base_vectors A) \\<subseteq> mat_kernel A\n  0\\<^sub>v n \\<notin> set (find_base_vectors A)\n  basis (set (find_base_vectors A))\n  card (set (find_base_vectors A)) = n - n\n  length (pivot_positions A) = n\n  dim = n - n\n\ngoal (1 subgoal):\n 1. dim = 0 &&& basis {}", "by auto"], ["proof (state)\nthis:\n  dim = 0\n  basis {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kernel_upper_triangular: assumes A: \"A \\<in> carrier_mat n n\"\n  and ut: \"upper_triangular A\" and 0: \"0 \\<notin> set (diag_mat A)\"\n  shows \"kernel.dim n A = 0\" \"kernel.basis n A {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0 &&&\n    vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "define ma where \"ma = diag_mat A\""], ["proof (state)\nthis:\n  ma = diag_mat A\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "from det_upper_triangular[OF ut A]"], ["proof (chain)\npicking this:\n  det A = prod_list (diag_mat A)", "have \"det A = prod_list (diag_mat A)\""], ["proof (prove)\nusing this:\n  det A = prod_list (diag_mat A)\n\ngoal (1 subgoal):\n 1. det A = prod_list (diag_mat A)", "."], ["proof (state)\nthis:\n  det A = prod_list (diag_mat A)\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "also"], ["proof (state)\nthis:\n  det A = prod_list (diag_mat A)\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat A) \\<noteq> (0::'a)", "using 0"], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> set (diag_mat A)\n\ngoal (1 subgoal):\n 1. prod_list (diag_mat A) \\<noteq> (0::'a)", "unfolding ma_def[symmetric]"], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> set ma\n\ngoal (1 subgoal):\n 1. prod_list ma \\<noteq> (0::'a)", "by (induct ma, auto)"], ["proof (state)\nthis:\n  prod_list (diag_mat A) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "finally"], ["proof (chain)\npicking this:\n  det A \\<noteq> (0::'a)", "have \"det A \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  det A \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "from det_non_zero_imp_unit[OF A this, unfolded Units_def, of \"()\"]"], ["proof (chain)\npicking this:\n  A \\<in> {y \\<in> carrier (ring_mat TYPE('a) n ()).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n ()).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub>}", "obtain B where B: \"B \\<in> carrier_mat n n\" and BA: \"B * A = 1\\<^sub>m n\" and AB: \"A * B = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  A \\<in> {y \\<in> carrier (ring_mat TYPE('a) n ()).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n ()).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n ()\\<^esub>}\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<in> carrier_mat n n; B * A = 1\\<^sub>m n;\n         A * B = 1\\<^sub>m n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ring_mat_def)"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n  B * A = 1\\<^sub>m n\n  A * B = 1\\<^sub>m n\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "from mat_kernel_mult_eq[OF A B A AB, unfolded BA]"], ["proof (chain)\npicking this:\n  mat_kernel (1\\<^sub>m n) = mat_kernel A", "have id: \"mat_kernel A = mat_kernel (1\\<^sub>m n)\""], ["proof (prove)\nusing this:\n  mat_kernel (1\\<^sub>m n) = mat_kernel A\n\ngoal (1 subgoal):\n 1. mat_kernel A = mat_kernel (1\\<^sub>m n)", ".."], ["proof (state)\nthis:\n  mat_kernel A = mat_kernel (1\\<^sub>m n)\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0\n 2. vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "show \"kernel.dim n A = 0\" \"kernel.basis n A {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    0 &&&\n    vectorspace.basis class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier := mat_kernel (1\\<^sub>m n)\\<rparr>) =\n    0 &&&\n    vectorspace.basis class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier := mat_kernel (1\\<^sub>m n)\\<rparr>)\n     {}", "by (rule kernel_one_mat)+"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n  0\n  vectorspace.basis class_ring\n   (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kernel_basis_exists: assumes A: \"A \\<in> carrier_mat nr nc\"\n  shows \"\\<exists> B. finite B \\<and> kernel.basis nc A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "obtain C where gj: \"gauss_jordan_single A = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        gauss_jordan_single A = C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gauss_jordan_single A = C\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "from gauss_jordan_single[OF A gj]"], ["proof (chain)\npicking this:\n  ?x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v ?x = 0\\<^sub>v nr) = (C *\\<^sub>v ?x = 0\\<^sub>v nr)\n  C \\<in> carrier_mat nr nc\n  row_echelon_form C\n  \\<exists>P Q.\n     C = P * A \\<and>\n     P \\<in> carrier_mat nr nr \\<and>\n     Q \\<in> carrier_mat nr nr \\<and>\n     P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr", "obtain P Q where CPA: \"C = P * A\" and QP: \"Q * P = 1\\<^sub>m nr\"\n    and P: \"P \\<in> carrier_mat nr nr\" and Q: \"Q \\<in> carrier_mat nr nr\"   \n    and C: \"C \\<in> carrier_mat nr nc\" and row: \"row_echelon_form C\""], ["proof (prove)\nusing this:\n  ?x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v ?x = 0\\<^sub>v nr) = (C *\\<^sub>v ?x = 0\\<^sub>v nr)\n  C \\<in> carrier_mat nr nc\n  row_echelon_form C\n  \\<exists>P Q.\n     C = P * A \\<and>\n     P \\<in> carrier_mat nr nr \\<and>\n     Q \\<in> carrier_mat nr nr \\<and>\n     P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>C = P * A; Q * P = 1\\<^sub>m nr; P \\<in> carrier_mat nr nr;\n         Q \\<in> carrier_mat nr nr; C \\<in> carrier_mat nr nc;\n         row_echelon_form C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = P * A\n  Q * P = 1\\<^sub>m nr\n  P \\<in> carrier_mat nr nr\n  Q \\<in> carrier_mat nr nr\n  C \\<in> carrier_mat nr nc\n  row_echelon_form C\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "from find_base_vectors[OF row C]"], ["proof (chain)\npicking this:\n  set (find_base_vectors C) \\<subseteq> mat_kernel C\n  0\\<^sub>v nc \\<notin> set (find_base_vectors C)\n  vectorspace.basis class_ring\n   (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel C\\<rparr>)\n   (set (find_base_vectors C))\n  card (set (find_base_vectors C)) =\n  nc - card {i. i < nr \\<and> row C i \\<noteq> 0\\<^sub>v nc}\n  length (pivot_positions C) =\n  card {i. i < nr \\<and> row C i \\<noteq> 0\\<^sub>v nc}\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel C\\<rparr>) =\n  nc - card {i. i < nr \\<and> row C i \\<noteq> 0\\<^sub>v nc}", "have \"\\<exists> B. finite B \\<and> kernel.basis nc C B\""], ["proof (prove)\nusing this:\n  set (find_base_vectors C) \\<subseteq> mat_kernel C\n  0\\<^sub>v nc \\<notin> set (find_base_vectors C)\n  vectorspace.basis class_ring\n   (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel C\\<rparr>)\n   (set (find_base_vectors C))\n  card (set (find_base_vectors C)) =\n  nc - card {i. i < nr \\<and> row C i \\<noteq> 0\\<^sub>v nc}\n  length (pivot_positions C) =\n  card {i. i < nr \\<and> row C i \\<noteq> 0\\<^sub>v nc}\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel C\\<rparr>) =\n  nc - card {i. i < nr \\<and> row C i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel C\\<rparr>) B", "by blast"], ["proof (state)\nthis:\n  \\<exists>B.\n     finite B \\<and>\n     vectorspace.basis class_ring\n      (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel C\\<rparr>) B\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "also"], ["proof (state)\nthis:\n  \\<exists>B.\n     finite B \\<and>\n     vectorspace.basis class_ring\n      (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel C\\<rparr>) B\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "have \"mat_kernel C = mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel C = mat_kernel A", "unfolding CPA"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel (P * A) = mat_kernel A", "by (rule mat_kernel_mult_eq[OF A P Q QP])"], ["proof (state)\nthis:\n  mat_kernel C = mat_kernel A\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "finally"], ["proof (chain)\npicking this:\n  \\<exists>B.\n     finite B \\<and>\n     vectorspace.basis class_ring\n      (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>B.\n     finite B \\<and>\n     vectorspace.basis class_ring\n      (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       finite B \\<and>\n       vectorspace.basis class_ring\n        (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B", "."], ["proof (state)\nthis:\n  \\<exists>B.\n     finite B \\<and>\n     vectorspace.basis class_ring\n      (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_kernel_mult_right_gen_set: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nc nc\"\n  and C: \"C \\<in> carrier_mat nc nc\"\n  and inv: \"B * C = 1\\<^sub>m nc\"\n  and gen_set: \"kernel.gen_set nc (A * B) gen\" and gen: \"gen \\<subseteq> mat_kernel (A * B)\"\n  shows \"kernel.gen_set nc A (((*\\<^sub>v) B) ` gen)\" \"(*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\" \"card (((*\\<^sub>v) B) ` gen) = card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LinearCombinations.module.span class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) =\n    carrier\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>) &&&\n    (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A &&&\n    card ((*\\<^sub>v) B ` gen) = card gen", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. LinearCombinations.module.span class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) =\n    carrier (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "let ?AB = \"A * B\""], ["proof (state)\ngoal (3 subgoals):\n 1. LinearCombinations.module.span class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) =\n    carrier (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "let ?gen = \"((*\\<^sub>v) B) ` gen\""], ["proof (state)\ngoal (3 subgoals):\n 1. LinearCombinations.module.span class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) =\n    carrier (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc", "have AB: \"A * B \\<in> carrier_mat nr nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. A * B \\<in> carrier_mat nr nc", "by auto"], ["proof (state)\nthis:\n  A * B \\<in> carrier_mat nr nc\n\ngoal (3 subgoals):\n 1. LinearCombinations.module.span class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) =\n    carrier (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "from B"], ["proof (chain)\npicking this:\n  B \\<in> carrier_mat nc nc", "have dimB: \"dim_row B = nc\""], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. dim_row B = nc", "by auto"], ["proof (state)\nthis:\n  dim_row B = nc\n\ngoal (3 subgoals):\n 1. LinearCombinations.module.span class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) =\n    carrier (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "from inv B C"], ["proof (chain)\npicking this:\n  B * C = 1\\<^sub>m nc\n  B \\<in> carrier_mat nc nc\n  C \\<in> carrier_mat nc nc", "have CB: \"C * B = 1\\<^sub>m nc\""], ["proof (prove)\nusing this:\n  B * C = 1\\<^sub>m nc\n  B \\<in> carrier_mat nc nc\n  C \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. C * B = 1\\<^sub>m nc", "by (metis mat_mult_left_right_inverse)"], ["proof (state)\nthis:\n  C * B = 1\\<^sub>m nc\n\ngoal (3 subgoals):\n 1. LinearCombinations.module.span class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) =\n    carrier (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "interpret AB: kernel nr nc ?AB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc (A * B)", "by (unfold_locales, rule AB)"], ["proof (state)\ngoal (3 subgoals):\n 1. LinearCombinations.module.span class_ring (AB.NC.vs (mat_kernel A))\n     ((*\\<^sub>v) B ` gen) =\n    carrier (AB.NC.vs (mat_kernel A))\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "interpret A: kernel nr nc A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc A", "by (unfold_locales, rule A)"], ["proof (state)\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "fix w"], ["proof (state)\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "assume \"w \\<in> ?gen\""], ["proof (state)\nthis:\n  w \\<in> (*\\<^sub>v) B ` gen\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "then"], ["proof (chain)\npicking this:\n  w \\<in> (*\\<^sub>v) B ` gen", "obtain v where w: \"w = B *\\<^sub>v v\" and v: \"v \\<in> gen\""], ["proof (prove)\nusing this:\n  w \\<in> (*\\<^sub>v) B ` gen\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>w = B *\\<^sub>v v; v \\<in> gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = B *\\<^sub>v v\n  v \\<in> gen\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "from v"], ["proof (chain)\npicking this:\n  v \\<in> gen", "have \"v \\<in> mat_kernel ?AB\""], ["proof (prove)\nusing this:\n  v \\<in> gen\n\ngoal (1 subgoal):\n 1. v \\<in> mat_kernel (A * B)", "using gen"], ["proof (prove)\nusing this:\n  v \\<in> gen\n  gen \\<subseteq> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. v \\<in> mat_kernel (A * B)", "by auto"], ["proof (state)\nthis:\n  v \\<in> mat_kernel (A * B)\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "hence v: \"v \\<in> carrier_vec nc\" and 0: \"?AB *\\<^sub>v v = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  v \\<in> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A * B *\\<^sub>v v = 0\\<^sub>v nr", "unfolding mat_kernel[OF AB]"], ["proof (prove)\nusing this:\n  v \\<in> {v \\<in> carrier_vec nc. A * B *\\<^sub>v v = 0\\<^sub>v nr}\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A * B *\\<^sub>v v = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec nc\n  A * B *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "have \"?AB *\\<^sub>v v = A *\\<^sub>v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v v = A *\\<^sub>v w", "unfolding w"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v v = A *\\<^sub>v (B *\\<^sub>v v)", "using v A B"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v v = A *\\<^sub>v (B *\\<^sub>v v)", "by simp"], ["proof (state)\nthis:\n  A * B *\\<^sub>v v = A *\\<^sub>v w\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "with 0"], ["proof (chain)\npicking this:\n  A * B *\\<^sub>v v = 0\\<^sub>v nr\n  A * B *\\<^sub>v v = A *\\<^sub>v w", "have 0: \"A *\\<^sub>v w = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  A * B *\\<^sub>v v = 0\\<^sub>v nr\n  A * B *\\<^sub>v v = A *\\<^sub>v w\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v w = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v w = 0\\<^sub>v nr\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "from w B v"], ["proof (chain)\npicking this:\n  w = B *\\<^sub>v v\n  B \\<in> carrier_mat nc nc\n  v \\<in> carrier_vec nc", "have w: \"w \\<in> carrier_vec nc\""], ["proof (prove)\nusing this:\n  w = B *\\<^sub>v v\n  B \\<in> carrier_mat nc nc\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec nc", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec nc\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "from 0 w"], ["proof (chain)\npicking this:\n  A *\\<^sub>v w = 0\\<^sub>v nr\n  w \\<in> carrier_vec nc", "have \"w \\<in> mat_kernel A\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v w = 0\\<^sub>v nr\n  w \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. w \\<in> mat_kernel A", "unfolding mat_kernel[OF A]"], ["proof (prove)\nusing this:\n  A *\\<^sub>v w = 0\\<^sub>v nr\n  w \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. w \\<in> {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}", "by auto"], ["proof (state)\nthis:\n  w \\<in> mat_kernel A\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "}"], ["proof (state)\nthis:\n  ?w3 \\<in> (*\\<^sub>v) B ` gen \\<Longrightarrow> ?w3 \\<in> mat_kernel A\n\ngoal (3 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n 3. card ((*\\<^sub>v) B ` gen) = card gen", "thus genn: \"?gen \\<subseteq> mat_kernel A\""], ["proof (prove)\nusing this:\n  ?w3 \\<in> (*\\<^sub>v) B ` gen \\<Longrightarrow> ?w3 \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "hence one_dir: \"A.span ?gen \\<subseteq> mat_kernel A\""], ["proof (prove)\nusing this:\n  (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. A.span ((*\\<^sub>v) B ` gen) \\<subseteq> mat_kernel A", "by fastforce"], ["proof (state)\nthis:\n  A.span ((*\\<^sub>v) B ` gen) \\<subseteq> mat_kernel A\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "{"], ["proof (state)\nthis:\n  A.span ((*\\<^sub>v) B ` gen) \\<subseteq> mat_kernel A\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "fix v v'"], ["proof (state)\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "assume v: \"v \\<in> gen\" and v': \"v' \\<in> gen\" and id: \"B *\\<^sub>v v = B *\\<^sub>v v'\""], ["proof (state)\nthis:\n  v \\<in> gen\n  v' \\<in> gen\n  B *\\<^sub>v v = B *\\<^sub>v v'\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from v v'"], ["proof (chain)\npicking this:\n  v \\<in> gen\n  v' \\<in> gen", "have v: \"v \\<in> carrier_vec nc\" and v': \"v' \\<in> carrier_vec nc\""], ["proof (prove)\nusing this:\n  v \\<in> gen\n  v' \\<in> gen\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& v' \\<in> carrier_vec nc", "using gen"], ["proof (prove)\nusing this:\n  v \\<in> gen\n  v' \\<in> gen\n  gen \\<subseteq> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& v' \\<in> carrier_vec nc", "unfolding mat_kernel[OF AB]"], ["proof (prove)\nusing this:\n  v \\<in> gen\n  v' \\<in> gen\n  gen \\<subseteq> {v \\<in> carrier_vec nc. A * B *\\<^sub>v v = 0\\<^sub>v nr}\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& v' \\<in> carrier_vec nc", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec nc\n  v' \\<in> carrier_vec nc\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from arg_cong[OF id, of \"\\<lambda> v. C *\\<^sub>v v\"]"], ["proof (chain)\npicking this:\n  C *\\<^sub>v (B *\\<^sub>v v) = C *\\<^sub>v (B *\\<^sub>v v')", "have \"v = v'\""], ["proof (prove)\nusing this:\n  C *\\<^sub>v (B *\\<^sub>v v) = C *\\<^sub>v (B *\\<^sub>v v')\n\ngoal (1 subgoal):\n 1. v = v'", "using v v'"], ["proof (prove)\nusing this:\n  C *\\<^sub>v (B *\\<^sub>v v) = C *\\<^sub>v (B *\\<^sub>v v')\n  v \\<in> carrier_vec nc\n  v' \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. v = v'", "unfolding assoc_mult_mat_vec[symmetric, OF C B v] \n        assoc_mult_mat_vec[symmetric, OF C B v'] CB"], ["proof (prove)\nusing this:\n  1\\<^sub>m nc *\\<^sub>v v = 1\\<^sub>m nc *\\<^sub>v v'\n  v \\<in> carrier_vec nc\n  v' \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. v = v'", "by auto"], ["proof (state)\nthis:\n  v = v'\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v3 \\<in> gen; ?v'3 \\<in> gen;\n   B *\\<^sub>v ?v3 = B *\\<^sub>v ?v'3\\<rbrakk>\n  \\<Longrightarrow> ?v3 = ?v'3\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "note inj = this"], ["proof (state)\nthis:\n  \\<lbrakk>?v3 \\<in> gen; ?v'3 \\<in> gen;\n   B *\\<^sub>v ?v3 = B *\\<^sub>v ?v'3\\<rbrakk>\n  \\<Longrightarrow> ?v3 = ?v'3\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "hence inj_gen: \"inj_on ((*\\<^sub>v) B) gen\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?v3 \\<in> gen; ?v'3 \\<in> gen;\n   B *\\<^sub>v ?v3 = B *\\<^sub>v ?v'3\\<rbrakk>\n  \\<Longrightarrow> ?v3 = ?v'3\n\ngoal (1 subgoal):\n 1. inj_on ((*\\<^sub>v) B) gen", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v3 \\<in> gen; ?v'3 \\<in> gen;\n   B *\\<^sub>v ?v3 = B *\\<^sub>v ?v'3\\<rbrakk>\n  \\<Longrightarrow> ?v3 = ?v'3\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>gen.\n       \\<forall>y\\<in>gen.\n          B *\\<^sub>v x = B *\\<^sub>v y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on ((*\\<^sub>v) B) gen\n\ngoal (2 subgoals):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "show \"card ?gen = card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((*\\<^sub>v) B ` gen) = card gen", "using inj_gen"], ["proof (prove)\nusing this:\n  inj_on ((*\\<^sub>v) B) gen\n\ngoal (1 subgoal):\n 1. card ((*\\<^sub>v) B ` gen) = card gen", "by (rule card_image)"], ["proof (state)\nthis:\n  card ((*\\<^sub>v) B ` gen) = card gen\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "{"], ["proof (state)\nthis:\n  card ((*\\<^sub>v) B ` gen) = card gen\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "let ?Cv = \"C *\\<^sub>v v\""], ["proof (state)\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "assume \"v \\<in> mat_kernel A\""], ["proof (state)\nthis:\n  v \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "from mat_kernelD[OF A this]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr", "have v: \"v \\<in> carrier_vec nc\" and 0: \"A *\\<^sub>v v = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc &&& A *\\<^sub>v v = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec nc\n  A *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "have \"?AB *\\<^sub>v ?Cv = (A * (B * C)) *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v (C *\\<^sub>v v) = A * (B * C) *\\<^sub>v v", "using A B C v"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc\n  C \\<in> carrier_mat nc nc\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v (C *\\<^sub>v v) = A * (B * C) *\\<^sub>v v", "by (subst assoc_mult_mat_vec[symmetric, OF AB C v], subst assoc_mult_mat[OF A B C], simp)"], ["proof (state)\nthis:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = A * (B * C) *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "also"], ["proof (state)\nthis:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = A * (B * C) *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "have \"\\<dots> = 0\\<^sub>v nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (B * C) *\\<^sub>v v = 0\\<^sub>v nr", "unfolding inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * 1\\<^sub>m nc *\\<^sub>v v = 0\\<^sub>v nr", "using 0 A v"], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = 0\\<^sub>v nr\n  A \\<in> carrier_mat nr nc\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A * 1\\<^sub>m nc *\\<^sub>v v = 0\\<^sub>v nr", "by simp"], ["proof (state)\nthis:\n  A * (B * C) *\\<^sub>v v = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "finally"], ["proof (chain)\npicking this:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr", "have 0: \"?AB *\\<^sub>v ?Cv = 0\\<^sub>v nr\" and Cv: \"?Cv \\<in> carrier_vec nc\""], ["proof (prove)\nusing this:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr &&&\n    C *\\<^sub>v v \\<in> carrier_vec nc", "using C v"], ["proof (prove)\nusing this:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr\n  C \\<in> carrier_mat nc nc\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr &&&\n    C *\\<^sub>v v \\<in> carrier_vec nc", "by auto"], ["proof (state)\nthis:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr\n  C *\\<^sub>v v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "hence \"?Cv \\<in> mat_kernel ?AB\""], ["proof (prove)\nusing this:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr\n  C *\\<^sub>v v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. C *\\<^sub>v v \\<in> mat_kernel (A * B)", "unfolding mat_kernel[OF AB]"], ["proof (prove)\nusing this:\n  A * B *\\<^sub>v (C *\\<^sub>v v) = 0\\<^sub>v nr\n  C *\\<^sub>v v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. C *\\<^sub>v v\n    \\<in> {v \\<in> carrier_vec nc. A * B *\\<^sub>v v = 0\\<^sub>v nr}", "by auto"], ["proof (state)\nthis:\n  C *\\<^sub>v v \\<in> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "with gen_set"], ["proof (chain)\npicking this:\n  AB.gen_set gen\n  C *\\<^sub>v v \\<in> mat_kernel (A * B)", "have \"?Cv \\<in> AB.span gen\""], ["proof (prove)\nusing this:\n  AB.gen_set gen\n  C *\\<^sub>v v \\<in> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. C *\\<^sub>v v \\<in> AB.span gen", "by auto"], ["proof (state)\nthis:\n  C *\\<^sub>v v \\<in> AB.span gen\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "from this[unfolded AB.Ker.span_def]"], ["proof (chain)\npicking this:\n  C *\\<^sub>v v\n  \\<in> {AB.lincomb a A |a A.\n         finite A \\<and>\n         A \\<subseteq> gen \\<and> a \\<in> A \\<rightarrow> UNIV}", "obtain a gen' where \n      Cv: \"?Cv = AB.lincomb a gen'\" and sub: \"gen' \\<subseteq> gen\" and fin: \"finite gen'\""], ["proof (prove)\nusing this:\n  C *\\<^sub>v v\n  \\<in> {AB.lincomb a A |a A.\n         finite A \\<and>\n         A \\<subseteq> gen \\<and> a \\<in> A \\<rightarrow> UNIV}\n\ngoal (1 subgoal):\n 1. (\\<And>a gen'.\n        \\<lbrakk>C *\\<^sub>v v = AB.lincomb a gen'; gen' \\<subseteq> gen;\n         finite gen'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C *\\<^sub>v v = AB.lincomb a gen'\n  gen' \\<subseteq> gen\n  finite gen'\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "let ?gen' = \"((*\\<^sub>v) B) ` gen'\""], ["proof (state)\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "from sub gen"], ["proof (chain)\npicking this:\n  gen' \\<subseteq> gen\n  gen \\<subseteq> mat_kernel (A * B)", "have gen': \"gen' \\<subseteq> mat_kernel ?AB\""], ["proof (prove)\nusing this:\n  gen' \\<subseteq> gen\n  gen \\<subseteq> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. gen' \\<subseteq> mat_kernel (A * B)", "by auto"], ["proof (state)\nthis:\n  gen' \\<subseteq> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "have lin1: \"AB.lincomb a gen' \\<in> carrier_vec nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AB.lincomb a gen' \\<in> carrier_vec nc", "using AB.Ker.lincomb_closed[OF gen', of a]"], ["proof (prove)\nusing this:\n  a \\<in> gen' \\<rightarrow> UNIV \\<Longrightarrow>\n  AB.lincomb a gen' \\<in> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. AB.lincomb a gen' \\<in> carrier_vec nc", "unfolding mat_kernel[OF AB]"], ["proof (prove)\nusing this:\n  a \\<in> gen' \\<rightarrow> UNIV \\<Longrightarrow>\n  module.lincomb\n   (AB.NC.vs {v \\<in> carrier_vec nc. A * B *\\<^sub>v v = 0\\<^sub>v nr}) a\n   gen'\n  \\<in> {v \\<in> carrier_vec nc. A * B *\\<^sub>v v = 0\\<^sub>v nr}\n\ngoal (1 subgoal):\n 1. module.lincomb\n     (AB.NC.vs {v \\<in> carrier_vec nc. A * B *\\<^sub>v v = 0\\<^sub>v nr}) a\n     gen'\n    \\<in> carrier_vec nc", "by (auto simp: class_field_def)"], ["proof (state)\nthis:\n  AB.lincomb a gen' \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "hence dim1: \"dim_vec (AB.lincomb a gen') = nc\""], ["proof (prove)\nusing this:\n  AB.lincomb a gen' \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. dim_vec (AB.lincomb a gen') = nc", "by auto"], ["proof (state)\nthis:\n  dim_vec (AB.lincomb a gen') = nc\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "hence dim1b: \"dim_vec (B *\\<^sub>v (AB.Ker.lincomb a gen')) = nc\""], ["proof (prove)\nusing this:\n  dim_vec (AB.lincomb a gen') = nc\n\ngoal (1 subgoal):\n 1. dim_vec (B *\\<^sub>v AB.lincomb a gen') = nc", "using B"], ["proof (prove)\nusing this:\n  dim_vec (AB.lincomb a gen') = nc\n  B \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. dim_vec (B *\\<^sub>v AB.lincomb a gen') = nc", "by auto"], ["proof (state)\nthis:\n  dim_vec (B *\\<^sub>v AB.lincomb a gen') = nc\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "from genn sub"], ["proof (chain)\npicking this:\n  (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n  gen' \\<subseteq> gen", "have genn': \"?gen' \\<subseteq> mat_kernel A\""], ["proof (prove)\nusing this:\n  (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n  gen' \\<subseteq> gen\n\ngoal (1 subgoal):\n 1. (*\\<^sub>v) B ` gen' \\<subseteq> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  (*\\<^sub>v) B ` gen' \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "from gen sub"], ["proof (chain)\npicking this:\n  gen \\<subseteq> mat_kernel (A * B)\n  gen' \\<subseteq> gen", "have gen'nc: \"gen' \\<subseteq> carrier_vec nc\""], ["proof (prove)\nusing this:\n  gen \\<subseteq> mat_kernel (A * B)\n  gen' \\<subseteq> gen\n\ngoal (1 subgoal):\n 1. gen' \\<subseteq> carrier_vec nc", "unfolding mat_kernel[OF AB]"], ["proof (prove)\nusing this:\n  gen \\<subseteq> {v \\<in> carrier_vec nc. A * B *\\<^sub>v v = 0\\<^sub>v nr}\n  gen' \\<subseteq> gen\n\ngoal (1 subgoal):\n 1. gen' \\<subseteq> carrier_vec nc", "by auto"], ["proof (state)\nthis:\n  gen' \\<subseteq> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "define a' where \"a' = (\\<lambda> b. a (C *\\<^sub>v b))\""], ["proof (state)\nthis:\n  a' = (\\<lambda>b. a (C *\\<^sub>v b))\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "from A.Ker.lincomb_closed[OF genn']"], ["proof (chain)\npicking this:\n  ?a \\<in> (*\\<^sub>v) B ` gen' \\<rightarrow> UNIV \\<Longrightarrow>\n  A.lincomb ?a ((*\\<^sub>v) B ` gen') \\<in> mat_kernel A", "have lin2: \"A.Ker.lincomb a' ?gen' \\<in> carrier_vec nc\""], ["proof (prove)\nusing this:\n  ?a \\<in> (*\\<^sub>v) B ` gen' \\<rightarrow> UNIV \\<Longrightarrow>\n  A.lincomb ?a ((*\\<^sub>v) B ` gen') \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. A.lincomb a' ((*\\<^sub>v) B ` gen') \\<in> carrier_vec nc", "unfolding mat_kernel[OF A]"], ["proof (prove)\nusing this:\n  ?a \\<in> (*\\<^sub>v) B ` gen' \\<rightarrow> UNIV \\<Longrightarrow>\n  module.lincomb\n   (AB.NC.vs {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}) ?a\n   ((*\\<^sub>v) B ` gen')\n  \\<in> {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}\n\ngoal (1 subgoal):\n 1. module.lincomb\n     (AB.NC.vs {v \\<in> carrier_vec nc. A *\\<^sub>v v = 0\\<^sub>v nr}) a'\n     ((*\\<^sub>v) B ` gen')\n    \\<in> carrier_vec nc", "by (auto simp: class_field_def)"], ["proof (state)\nthis:\n  A.lincomb a' ((*\\<^sub>v) B ` gen') \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "hence dim2: \"dim_vec (A.Ker.lincomb a' ?gen') = nc\""], ["proof (prove)\nusing this:\n  A.lincomb a' ((*\\<^sub>v) B ` gen') \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. dim_vec (A.lincomb a' ((*\\<^sub>v) B ` gen')) = nc", "by auto"], ["proof (state)\nthis:\n  dim_vec (A.lincomb a' ((*\\<^sub>v) B ` gen')) = nc\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "have \"v = B *\\<^sub>v ?Cv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = B *\\<^sub>v (C *\\<^sub>v v)", "by (unfold assoc_mult_mat_vec[symmetric, OF B C v] inv, insert v, simp)"], ["proof (state)\nthis:\n  v = B *\\<^sub>v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "hence \"v = B *\\<^sub>v AB.Ker.lincomb a gen'\""], ["proof (prove)\nusing this:\n  v = B *\\<^sub>v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v = B *\\<^sub>v AB.lincomb a gen'", "unfolding Cv"], ["proof (prove)\nusing this:\n  v = B *\\<^sub>v AB.lincomb a gen'\n\ngoal (1 subgoal):\n 1. v = B *\\<^sub>v AB.lincomb a gen'", "by simp"], ["proof (state)\nthis:\n  v = B *\\<^sub>v AB.lincomb a gen'\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "also"], ["proof (state)\nthis:\n  v = B *\\<^sub>v AB.lincomb a gen'\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "have \"\\<dots> = A.Ker.lincomb a' ?gen'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>v AB.lincomb a gen' = A.lincomb a' ((*\\<^sub>v) B ` gen')", "proof (rule eq_vecI; unfold dim1 dim1b dim2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "assume i: \"i < nc\""], ["proof (state)\nthis:\n  i < nc\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "with dimB"], ["proof (chain)\npicking this:\n  dim_row B = nc\n  i < nc", "have ii: \"i < dim_row B\""], ["proof (prove)\nusing this:\n  dim_row B = nc\n  i < nc\n\ngoal (1 subgoal):\n 1. i < dim_row B", "by auto"], ["proof (state)\nthis:\n  i < dim_row B\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "from sub inj"], ["proof (chain)\npicking this:\n  gen' \\<subseteq> gen\n  \\<lbrakk>?v3 \\<in> gen; ?v'3 \\<in> gen;\n   B *\\<^sub>v ?v3 = B *\\<^sub>v ?v'3\\<rbrakk>\n  \\<Longrightarrow> ?v3 = ?v'3", "have inj: \"inj_on ((*\\<^sub>v) B) gen'\""], ["proof (prove)\nusing this:\n  gen' \\<subseteq> gen\n  \\<lbrakk>?v3 \\<in> gen; ?v'3 \\<in> gen;\n   B *\\<^sub>v ?v3 = B *\\<^sub>v ?v'3\\<rbrakk>\n  \\<Longrightarrow> ?v3 = ?v'3\n\ngoal (1 subgoal):\n 1. inj_on ((*\\<^sub>v) B) gen'", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  gen' \\<subseteq> gen\n  \\<lbrakk>?v3 \\<in> gen; ?v'3 \\<in> gen;\n   B *\\<^sub>v ?v3 = B *\\<^sub>v ?v'3\\<rbrakk>\n  \\<Longrightarrow> ?v3 = ?v'3\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>gen'.\n       \\<forall>y\\<in>gen'.\n          B *\\<^sub>v x = B *\\<^sub>v y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on ((*\\<^sub>v) B) gen'\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "{"], ["proof (state)\nthis:\n  inj_on ((*\\<^sub>v) B) gen'\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "assume \"v \\<in> gen'\""], ["proof (state)\nthis:\n  v \\<in> gen'\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "with gen'nc"], ["proof (chain)\npicking this:\n  gen' \\<subseteq> carrier_vec nc\n  v \\<in> gen'", "have v: \"v \\<in> carrier_vec nc\""], ["proof (prove)\nusing this:\n  gen' \\<subseteq> carrier_vec nc\n  v \\<in> gen'\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec nc", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec nc\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "hence \"a' (B *\\<^sub>v v) = a v\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. a' (B *\\<^sub>v v) = a v", "unfolding a'_def assoc_mult_mat_vec[symmetric, OF C B v] CB"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. a (1\\<^sub>m nc *\\<^sub>v v) = a v", "by auto"], ["proof (state)\nthis:\n  a' (B *\\<^sub>v v) = a v\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "}"], ["proof (state)\nthis:\n  ?va3 \\<in> gen' \\<Longrightarrow> a' (B *\\<^sub>v ?va3) = a ?va3\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "note a' = this"], ["proof (state)\nthis:\n  ?va3 \\<in> gen' \\<Longrightarrow> a' (B *\\<^sub>v ?va3) = a ?va3\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "have \"A.Ker.lincomb a' ?gen' $ i = (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.lincomb a' ((*\\<^sub>v) B ` gen') $ i =\n    (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i)", "unfolding A.lincomb_index[OF i genn']"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(*\\<^sub>v) B ` gen'. a' x * x $ i) =\n    (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i)", "by simp"], ["proof (state)\nthis:\n  A.lincomb a' ((*\\<^sub>v) B ` gen') $ i =\n  (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "also"], ["proof (state)\nthis:\n  A.lincomb a' ((*\\<^sub>v) B ` gen') $ i =\n  (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "have \"\\<dots> = (\\<Sum>v\\<in>gen'. a v * ((B *\\<^sub>v v) $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i) =\n    (\\<Sum>v\\<in>gen'. a v * (B *\\<^sub>v v) $ i)", "by (rule sum.reindex_cong[OF inj refl], auto simp: a')"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i) =\n  (\\<Sum>v\\<in>gen'. a v * (B *\\<^sub>v v) $ i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>(*\\<^sub>v) B ` gen'. a' v * v $ i) =\n  (\\<Sum>v\\<in>gen'. a v * (B *\\<^sub>v v) $ i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "have \"\\<dots> = (\\<Sum>v\\<in>gen'. (\\<Sum>j = 0..< nc. a v * row B i $ j * v $ j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>gen'. a v * (B *\\<^sub>v v) $ i) =\n    (\\<Sum>v\\<in>gen'. \\<Sum>j = 0..<nc. a v * row B i $ j * v $ j)", "unfolding mult_mat_vec_def dimB scalar_prod_def index_vec[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>gen'.\n       a v * (\\<Sum>ia = 0..<dim_vec v. row B i $ ia * v $ ia)) =\n    (\\<Sum>v\\<in>gen'. \\<Sum>j = 0..<nc. a v * row B i $ j * v $ j)", "by (rule sum.cong, insert gen'nc, auto simp: sum_distrib_left ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>gen'. a v * (B *\\<^sub>v v) $ i) =\n  (\\<Sum>v\\<in>gen'. \\<Sum>j = 0..<nc. a v * row B i $ j * v $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>gen'. a v * (B *\\<^sub>v v) $ i) =\n  (\\<Sum>v\\<in>gen'. \\<Sum>j = 0..<nc. a v * row B i $ j * v $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "have \"\\<dots> = (\\<Sum>j = 0 ..< nc. (\\<Sum>v \\<in> gen'. a v * row B i $ j * v $ j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>gen'. \\<Sum>j = 0..<nc. a v * row B i $ j * v $ j) =\n    (\\<Sum>j = 0..<nc. \\<Sum>v\\<in>gen'. a v * row B i $ j * v $ j)", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>gen'. \\<Sum>j = 0..<nc. a v * row B i $ j * v $ j) =\n  (\\<Sum>j = 0..<nc. \\<Sum>v\\<in>gen'. a v * row B i $ j * v $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>gen'. \\<Sum>j = 0..<nc. a v * row B i $ j * v $ j) =\n  (\\<Sum>j = 0..<nc. \\<Sum>v\\<in>gen'. a v * row B i $ j * v $ j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "have \"\\<dots> = (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nc. \\<Sum>v\\<in>gen'. a v * row B i $ j * v $ j) =\n    (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j))", "by (rule sum.cong, auto simp: sum_distrib_left ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nc. \\<Sum>v\\<in>gen'. a v * row B i $ j * v $ j) =\n  (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nc. \\<Sum>v\\<in>gen'. a v * row B i $ j * v $ j) =\n  (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "have \"\\<dots> = (B *\\<^sub>v AB.Ker.lincomb a gen') $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j)) =\n    (B *\\<^sub>v AB.lincomb a gen') $ i", "unfolding index_mult_mat_vec[OF ii]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j)) =\n    row B i \\<bullet> AB.lincomb a gen'", "unfolding scalar_prod_def dim1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j)) =\n    (\\<Sum>ia = 0..<nc. row B i $ ia * AB.lincomb a gen' $ ia)", "by (rule sum.cong[OF refl], subst AB.lincomb_index[OF _ gen'], auto)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nc. row B i $ j * (\\<Sum>v\\<in>gen'. a v * v $ j)) =\n  (B *\\<^sub>v AB.lincomb a gen') $ i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < nc \\<Longrightarrow>\n       (B *\\<^sub>v AB.lincomb a gen') $ i =\n       A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n 2. nc = nc", "finally"], ["proof (chain)\npicking this:\n  A.lincomb a' ((*\\<^sub>v) B ` gen') $ i =\n  (B *\\<^sub>v AB.lincomb a gen') $ i", "show \"(B *\\<^sub>v AB.Ker.lincomb a gen') $ i = A.Ker.lincomb a' ?gen' $ i\""], ["proof (prove)\nusing this:\n  A.lincomb a' ((*\\<^sub>v) B ` gen') $ i =\n  (B *\\<^sub>v AB.lincomb a gen') $ i\n\ngoal (1 subgoal):\n 1. (B *\\<^sub>v AB.lincomb a gen') $ i =\n    A.lincomb a' ((*\\<^sub>v) B ` gen') $ i", ".."], ["proof (state)\nthis:\n  (B *\\<^sub>v AB.lincomb a gen') $ i =\n  A.lincomb a' ((*\\<^sub>v) B ` gen') $ i\n\ngoal (1 subgoal):\n 1. nc = nc", "qed auto"], ["proof (state)\nthis:\n  B *\\<^sub>v AB.lincomb a gen' = A.lincomb a' ((*\\<^sub>v) B ` gen')\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "finally"], ["proof (chain)\npicking this:\n  v = A.lincomb a' ((*\\<^sub>v) B ` gen')", "have \"v \\<in> A.Ker.span ?gen\""], ["proof (prove)\nusing this:\n  v = A.lincomb a' ((*\\<^sub>v) B ` gen')\n\ngoal (1 subgoal):\n 1. v \\<in> A.span ((*\\<^sub>v) B ` gen)", "using sub fin"], ["proof (prove)\nusing this:\n  v = A.lincomb a' ((*\\<^sub>v) B ` gen')\n  gen' \\<subseteq> gen\n  finite gen'\n\ngoal (1 subgoal):\n 1. v \\<in> A.span ((*\\<^sub>v) B ` gen)", "unfolding A.Ker.span_def"], ["proof (prove)\nusing this:\n  v = A.lincomb a' ((*\\<^sub>v) B ` gen')\n  gen' \\<subseteq> gen\n  finite gen'\n\ngoal (1 subgoal):\n 1. v \\<in> {A.lincomb a A |a A.\n             finite A \\<and>\n             A \\<subseteq> (*\\<^sub>v) B ` gen \\<and>\n             a \\<in> A \\<rightarrow> UNIV}", "by (auto simp: class_field_def intro!: exI[of _ a'] exI[of _ ?gen'])"], ["proof (state)\nthis:\n  v \\<in> A.span ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "}"], ["proof (state)\nthis:\n  ?v3 \\<in> mat_kernel A \\<Longrightarrow>\n  ?v3 \\<in> A.span ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "hence other_dir: \"A.Ker.span ?gen \\<supseteq> mat_kernel A\""], ["proof (prove)\nusing this:\n  ?v3 \\<in> mat_kernel A \\<Longrightarrow>\n  ?v3 \\<in> A.span ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> A.span ((*\\<^sub>v) B ` gen)", "by fastforce"], ["proof (state)\nthis:\n  mat_kernel A \\<subseteq> A.span ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "from one_dir other_dir"], ["proof (chain)\npicking this:\n  A.span ((*\\<^sub>v) B ` gen) \\<subseteq> mat_kernel A\n  mat_kernel A \\<subseteq> A.span ((*\\<^sub>v) B ` gen)", "show \"kernel.gen_set nc A (((*\\<^sub>v) B) ` gen)\""], ["proof (prove)\nusing this:\n  A.span ((*\\<^sub>v) B ` gen) \\<subseteq> mat_kernel A\n  mat_kernel A \\<subseteq> A.span ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen)", "by auto"], ["proof (state)\nthis:\n  A.gen_set ((*\\<^sub>v) B ` gen)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_kernel_mult_right_basis: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nc nc\"\n  and C: \"C \\<in> carrier_mat nc nc\"\n  and inv: \"B * C = 1\\<^sub>m nc\"\n  and fin: \"finite gen\"\n  and basis: \"kernel.basis nc (A * B) gen\"\n  shows \"kernel.basis nc A (((*\\<^sub>v) B) ` gen)\" \n  \"card (((*\\<^sub>v) B) ` gen) = card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen) &&&\n    card ((*\\<^sub>v) B ` gen) = card gen", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "let ?AB = \"A * B\""], ["proof (state)\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "let ?gen = \"((*\\<^sub>v) B) ` gen\""], ["proof (state)\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc", "have AB: \"?AB \\<in> carrier_mat nr nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. A * B \\<in> carrier_mat nr nc", "by auto"], ["proof (state)\nthis:\n  A * B \\<in> carrier_mat nr nc\n\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from B"], ["proof (chain)\npicking this:\n  B \\<in> carrier_mat nc nc", "have dimB: \"dim_row B = nc\""], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. dim_row B = nc", "by auto"], ["proof (state)\nthis:\n  dim_row B = nc\n\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from inv B C"], ["proof (chain)\npicking this:\n  B * C = 1\\<^sub>m nc\n  B \\<in> carrier_mat nc nc\n  C \\<in> carrier_mat nc nc", "have CB: \"C * B = 1\\<^sub>m nc\""], ["proof (prove)\nusing this:\n  B * C = 1\\<^sub>m nc\n  B \\<in> carrier_mat nc nc\n  C \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. C * B = 1\\<^sub>m nc", "by (metis mat_mult_left_right_inverse)"], ["proof (state)\nthis:\n  C * B = 1\\<^sub>m nc\n\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)\n     ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "interpret AB: kernel nr nc ?AB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc (A * B)", "by (unfold_locales, rule AB)"], ["proof (state)\ngoal (2 subgoals):\n 1. vectorspace.basis class_ring (AB.NC.vs (mat_kernel A))\n     ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "interpret A: kernel nr nc A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc A", "by (unfold_locales, rule A)"], ["proof (state)\ngoal (2 subgoals):\n 1. A.basis ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from basis[unfolded AB.Ker.basis_def]"], ["proof (chain)\npicking this:\n  AB.lin_indpt gen \\<and>\n  AB.span gen = mat_kernel (A * B) \\<and> gen \\<subseteq> mat_kernel (A * B)", "have gen_set: \"AB.gen_set gen\" and genAB: \"gen \\<subseteq> mat_kernel ?AB\""], ["proof (prove)\nusing this:\n  AB.lin_indpt gen \\<and>\n  AB.span gen = mat_kernel (A * B) \\<and> gen \\<subseteq> mat_kernel (A * B)\n\ngoal (1 subgoal):\n 1. AB.gen_set gen &&& gen \\<subseteq> mat_kernel (A * B)", "by auto"], ["proof (state)\nthis:\n  AB.gen_set gen\n  gen \\<subseteq> mat_kernel (A * B)\n\ngoal (2 subgoals):\n 1. A.basis ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from mat_kernel_mult_right_gen_set[OF A B C inv gen_set genAB]"], ["proof (chain)\npicking this:\n  A.gen_set ((*\\<^sub>v) B ` gen)\n  (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n  card ((*\\<^sub>v) B ` gen) = card gen", "have gen: \"A.gen_set ?gen\" and sub: \"?gen \\<subseteq> mat_kernel A\" and card: \"card ?gen = card gen\""], ["proof (prove)\nusing this:\n  A.gen_set ((*\\<^sub>v) B ` gen)\n  (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n  card ((*\\<^sub>v) B ` gen) = card gen\n\ngoal (1 subgoal):\n 1. A.gen_set ((*\\<^sub>v) B ` gen) &&&\n    (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A &&&\n    card ((*\\<^sub>v) B ` gen) = card gen", "."], ["proof (state)\nthis:\n  A.gen_set ((*\\<^sub>v) B ` gen)\n  (*\\<^sub>v) B ` gen \\<subseteq> mat_kernel A\n  card ((*\\<^sub>v) B ` gen) = card gen\n\ngoal (2 subgoals):\n 1. A.basis ((*\\<^sub>v) B ` gen)\n 2. card ((*\\<^sub>v) B ` gen) = card gen", "from card"], ["proof (chain)\npicking this:\n  card ((*\\<^sub>v) B ` gen) = card gen", "show \"card ?gen = card gen\""], ["proof (prove)\nusing this:\n  card ((*\\<^sub>v) B ` gen) = card gen\n\ngoal (1 subgoal):\n 1. card ((*\\<^sub>v) B ` gen) = card gen", "."], ["proof (state)\nthis:\n  card ((*\\<^sub>v) B ` gen) = card gen\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from fin"], ["proof (chain)\npicking this:\n  finite gen", "have fing: \"finite ?gen\""], ["proof (prove)\nusing this:\n  finite gen\n\ngoal (1 subgoal):\n 1. finite ((*\\<^sub>v) B ` gen)", "by auto"], ["proof (state)\nthis:\n  finite ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from gen"], ["proof (chain)\npicking this:\n  A.gen_set ((*\\<^sub>v) B ` gen)", "have gen: \"A.Ker.span ?gen = mat_kernel A\""], ["proof (prove)\nusing this:\n  A.gen_set ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. A.span ((*\\<^sub>v) B ` gen) = mat_kernel A", "by auto"], ["proof (state)\nthis:\n  A.span ((*\\<^sub>v) B ` gen) = mat_kernel A\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "have ABC: \"A * B * C = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B * C = A", "using A B C inv"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc\n  C \\<in> carrier_mat nc nc\n  B * C = 1\\<^sub>m nc\n\ngoal (1 subgoal):\n 1. A * B * C = A", "by simp"], ["proof (state)\nthis:\n  A * B * C = A\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from kernel_basis_exists[OF A]"], ["proof (chain)\npicking this:\n  \\<exists>B. finite B \\<and> A.basis B", "obtain bas where finb: \"finite bas\" and bas: \"A.basis bas\""], ["proof (prove)\nusing this:\n  \\<exists>B. finite B \\<and> A.basis B\n\ngoal (1 subgoal):\n 1. (\\<And>bas.\n        \\<lbrakk>finite bas; A.basis bas\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite bas\n  A.basis bas\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from bas"], ["proof (chain)\npicking this:\n  A.basis bas", "have bas': \"A.gen_set bas\" \"bas \\<subseteq> mat_kernel A\""], ["proof (prove)\nusing this:\n  A.basis bas\n\ngoal (1 subgoal):\n 1. A.gen_set bas &&& bas \\<subseteq> mat_kernel A", "unfolding A.Ker.basis_def"], ["proof (prove)\nusing this:\n  A.lin_indpt bas \\<and>\n  A.span bas = mat_kernel A \\<and> bas \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. A.gen_set bas &&& bas \\<subseteq> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  A.gen_set bas\n  bas \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "let ?bas = \"(*\\<^sub>v) C ` bas\""], ["proof (state)\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from mat_kernel_mult_right_gen_set[OF AB C B CB, unfolded ABC, OF bas']"], ["proof (chain)\npicking this:\n  AB.gen_set ((*\\<^sub>v) C ` bas)\n  (*\\<^sub>v) C ` bas \\<subseteq> mat_kernel (A * B)\n  card ((*\\<^sub>v) C ` bas) = card bas", "have bas': \"?bas \\<subseteq> mat_kernel ?AB\" \"AB.Ker.span ?bas = mat_kernel ?AB\" \"card ?bas = card bas\""], ["proof (prove)\nusing this:\n  AB.gen_set ((*\\<^sub>v) C ` bas)\n  (*\\<^sub>v) C ` bas \\<subseteq> mat_kernel (A * B)\n  card ((*\\<^sub>v) C ` bas) = card bas\n\ngoal (1 subgoal):\n 1. (*\\<^sub>v) C ` bas \\<subseteq> mat_kernel (A * B) &&&\n    AB.span ((*\\<^sub>v) C ` bas) = mat_kernel (A * B) &&&\n    card ((*\\<^sub>v) C ` bas) = card bas", "by auto"], ["proof (state)\nthis:\n  (*\\<^sub>v) C ` bas \\<subseteq> mat_kernel (A * B)\n  AB.span ((*\\<^sub>v) C ` bas) = mat_kernel (A * B)\n  card ((*\\<^sub>v) C ` bas) = card bas\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from finb bas"], ["proof (chain)\npicking this:\n  finite bas\n  A.basis bas", "have cardb: \"A.dim = card bas\""], ["proof (prove)\nusing this:\n  finite bas\n  A.basis bas\n\ngoal (1 subgoal):\n 1. A.dim = card bas", "by (rule A.Ker.dim_basis)"], ["proof (state)\nthis:\n  A.dim = card bas\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from fin basis"], ["proof (chain)\npicking this:\n  finite gen\n  AB.basis gen", "have cardg: \"AB.dim = card gen\""], ["proof (prove)\nusing this:\n  finite gen\n  AB.basis gen\n\ngoal (1 subgoal):\n 1. AB.dim = card gen", "by (rule AB.Ker.dim_basis)"], ["proof (state)\nthis:\n  AB.dim = card gen\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from AB.Ker.gen_ge_dim[OF _ bas'(1-2)] finb bas'(3) cardb cardg"], ["proof (chain)\npicking this:\n  finite ((*\\<^sub>v) C ` bas) \\<Longrightarrow>\n  AB.dim \\<le> card ((*\\<^sub>v) C ` bas)\n  finite bas\n  card ((*\\<^sub>v) C ` bas) = card bas\n  A.dim = card bas\n  AB.dim = card gen", "have ineq1: \"card gen \\<le> A.dim\""], ["proof (prove)\nusing this:\n  finite ((*\\<^sub>v) C ` bas) \\<Longrightarrow>\n  AB.dim \\<le> card ((*\\<^sub>v) C ` bas)\n  finite bas\n  card ((*\\<^sub>v) C ` bas) = card bas\n  A.dim = card bas\n  AB.dim = card gen\n\ngoal (1 subgoal):\n 1. card gen \\<le> A.dim", "by auto"], ["proof (state)\nthis:\n  card gen \\<le> A.dim\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "from A.Ker.dim_gen_is_basis[OF fing sub gen, unfolded card, OF this]"], ["proof (chain)\npicking this:\n  A.basis ((*\\<^sub>v) B ` gen)", "show \"A.basis ?gen\""], ["proof (prove)\nusing this:\n  A.basis ((*\\<^sub>v) B ` gen)\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` gen)", "."], ["proof (state)\nthis:\n  A.basis ((*\\<^sub>v) B ` gen)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_kernel_dim_mult_eq_right: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nc nc\"\n  and C: \"C \\<in> carrier_mat nc nc\"\n  and BC: \"B * C = 1\\<^sub>m nc\"\n  shows \"kernel.dim nc (A * B) = kernel.dim nc A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel (A * B)\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel (A * B)\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)", "let ?AB = \"A * B\""], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel (A * B)\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc", "have AB: \"?AB \\<in> carrier_mat nr nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nc nc\n\ngoal (1 subgoal):\n 1. A * B \\<in> carrier_mat nr nc", "by auto"], ["proof (state)\nthis:\n  A * B \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel (A * B)\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) nc\\<lparr>carrier := mat_kernel A\\<rparr>)", "interpret AB: kernel nr nc ?AB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc (A * B)", "by (unfold_locales, rule AB)"], ["proof (state)\ngoal (1 subgoal):\n 1. AB.dim = vectorspace.dim class_ring (AB.NC.vs (mat_kernel A))", "interpret A: kernel nr nc A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel nr nc A", "by (unfold_locales, rule A)"], ["proof (state)\ngoal (1 subgoal):\n 1. AB.dim = A.dim", "from kernel_basis_exists[OF AB]"], ["proof (chain)\npicking this:\n  \\<exists>B. finite B \\<and> AB.basis B", "obtain bas where finb: \"finite bas\" and bas: \"AB.basis bas\""], ["proof (prove)\nusing this:\n  \\<exists>B. finite B \\<and> AB.basis B\n\ngoal (1 subgoal):\n 1. (\\<And>bas.\n        \\<lbrakk>finite bas; AB.basis bas\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite bas\n  AB.basis bas\n\ngoal (1 subgoal):\n 1. AB.dim = A.dim", "let ?bas = \"((*\\<^sub>v) B) ` bas\""], ["proof (state)\ngoal (1 subgoal):\n 1. AB.dim = A.dim", "from mat_kernel_mult_right_basis[OF A B C BC finb bas] finb"], ["proof (chain)\npicking this:\n  A.basis ((*\\<^sub>v) B ` bas)\n  card ((*\\<^sub>v) B ` bas) = card bas\n  finite bas", "have bas': \"A.basis ?bas\" and finb': \"finite ?bas\" and card: \"card ?bas = card bas\""], ["proof (prove)\nusing this:\n  A.basis ((*\\<^sub>v) B ` bas)\n  card ((*\\<^sub>v) B ` bas) = card bas\n  finite bas\n\ngoal (1 subgoal):\n 1. A.basis ((*\\<^sub>v) B ` bas) &&&\n    finite ((*\\<^sub>v) B ` bas) &&& card ((*\\<^sub>v) B ` bas) = card bas", "by auto"], ["proof (state)\nthis:\n  A.basis ((*\\<^sub>v) B ` bas)\n  finite ((*\\<^sub>v) B ` bas)\n  card ((*\\<^sub>v) B ` bas) = card bas\n\ngoal (1 subgoal):\n 1. AB.dim = A.dim", "show \"AB.dim = A.dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AB.dim = A.dim", "unfolding A.Ker.dim_basis[OF finb' bas'] AB.Ker.dim_basis[OF finb bas] card"], ["proof (prove)\ngoal (1 subgoal):\n 1. card bas = card bas", ".."], ["proof (state)\nthis:\n  AB.dim = A.dim\n\ngoal:\nNo subgoals!", "qed"], ["", "locale vardim =\n  fixes f_ty :: \"'a :: field itself\"\nbegin"], ["", "abbreviation \"M == \\<lambda>k. module_vec TYPE('a) k\""], ["", "abbreviation \"span == \\<lambda>k. LinearCombinations.module.span class_ring (M k)\""], ["", "abbreviation \"lincomb == \\<lambda>k. module.lincomb (M k)\""], ["", "abbreviation \"lin_dep == \\<lambda>k. module.lin_dep class_ring (M k)\""], ["", "abbreviation \"padr m v == v @\\<^sub>v 0\\<^sub>v m\""], ["", "definition \"unpadr m v == vec (dim_vec v - m) (\\<lambda>i. v $ i)\""], ["", "abbreviation \"padl m v == 0\\<^sub>v m @\\<^sub>v v\""], ["", "definition \"unpadl m v == vec (dim_vec v - m) (\\<lambda>i. v $ (m+i))\""], ["", "lemma unpadr_padr[simp]: \"unpadr m (padr m v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unpadr m (v @\\<^sub>v 0\\<^sub>v m) = v", "unfolding unpadr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_vec (v @\\<^sub>v 0\\<^sub>v m) - m)\n     (($) (v @\\<^sub>v 0\\<^sub>v m)) =\n    v", "by auto"], ["", "lemma unpadl_padl[simp]: \"unpadl m (padl m v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unpadl m (0\\<^sub>v m @\\<^sub>v v) = v", "unfolding unpadl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_vec (0\\<^sub>v m @\\<^sub>v v) - m)\n     (\\<lambda>i. (0\\<^sub>v m @\\<^sub>v v) $ (m + i)) =\n    v", "by auto"], ["", "lemma padr_unpadr[simp]: \"v : padr m ` U \\<Longrightarrow> padr m (unpadr m v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U \\<Longrightarrow>\n    unpadr m v @\\<^sub>v 0\\<^sub>v m = v", "by auto"], ["", "lemma padl_unpadl[simp]: \"v : padl m ` U \\<Longrightarrow> padl m (unpadl m v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U \\<Longrightarrow>\n    0\\<^sub>v m @\\<^sub>v unpadl m v = v", "by auto"], ["", "(* somehow not automatically proven *)"], ["", "lemma padr_image:\n  assumes \"U \\<subseteq> carrier_vec n\" shows \"padr m ` U \\<subseteq> carrier_vec (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U\n    \\<subseteq> carrier_vec (n + m)", "proof(rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "assume \"v : padr m ` U\""], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "then"], ["proof (chain)\npicking this:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U", "obtain u where \"u : U\" and vmu: \"v = padr m u\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> U; v = u @\\<^sub>v 0\\<^sub>v m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> U\n  v = u @\\<^sub>v 0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "hence \"u : carrier_vec n\""], ["proof (prove)\nusing this:\n  u \\<in> U\n  v = u @\\<^sub>v 0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. u \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> U\n  v = u @\\<^sub>v 0\\<^sub>v m\n  U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. u \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "thus \"v : carrier_vec (n + m)\""], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (n + m)", "unfolding vmu"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. u @\\<^sub>v 0\\<^sub>v m \\<in> carrier_vec (n + m)", "using zero_carrier_vec[of m] append_carrier_vec"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  0\\<^sub>v m \\<in> carrier_vec m\n  \\<lbrakk>?v \\<in> carrier_vec ?n1.0; ?w \\<in> carrier_vec ?n2.0\\<rbrakk>\n  \\<Longrightarrow> ?v @\\<^sub>v ?w \\<in> carrier_vec (?n1.0 + ?n2.0)\n\ngoal (1 subgoal):\n 1. u @\\<^sub>v 0\\<^sub>v m \\<in> carrier_vec (n + m)", "by metis"], ["proof (state)\nthis:\n  v \\<in> carrier_vec (n + m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma padl_image:\n  assumes \"U \\<subseteq> carrier_vec n\" shows \"padl m ` U \\<subseteq> carrier_vec (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (@\\<^sub>v) (0\\<^sub>v m) ` U \\<subseteq> carrier_vec (m + n)", "proof(rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (m + n)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (m + n)", "assume \"v : padl m ` U\""], ["proof (state)\nthis:\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (m + n)", "then"], ["proof (chain)\npicking this:\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U", "obtain u where \"u : U\" and vmu: \"v = padl m u\""], ["proof (prove)\nusing this:\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> U; v = 0\\<^sub>v m @\\<^sub>v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> U\n  v = 0\\<^sub>v m @\\<^sub>v u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (m + n)", "hence \"u : carrier_vec n\""], ["proof (prove)\nusing this:\n  u \\<in> U\n  v = 0\\<^sub>v m @\\<^sub>v u\n\ngoal (1 subgoal):\n 1. u \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> U\n  v = 0\\<^sub>v m @\\<^sub>v u\n  U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. u \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v m) ` U \\<Longrightarrow>\n       x \\<in> carrier_vec (m + n)", "thus \"v : carrier_vec (m + n)\""], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (m + n)", "unfolding vmu"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v u \\<in> carrier_vec (m + n)", "using zero_carrier_vec[of m] append_carrier_vec"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  0\\<^sub>v m \\<in> carrier_vec m\n  \\<lbrakk>?v \\<in> carrier_vec ?n1.0; ?w \\<in> carrier_vec ?n2.0\\<rbrakk>\n  \\<Longrightarrow> ?v @\\<^sub>v ?w \\<in> carrier_vec (?n1.0 + ?n2.0)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v u \\<in> carrier_vec (m + n)", "by metis"], ["proof (state)\nthis:\n  v \\<in> carrier_vec (m + n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma padr_inj:\n  shows \"inj_on (padr m) (carrier_vec n :: 'a vec set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) (carrier_vec n)", "apply(intro inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier_vec n; y \\<in> carrier_vec n;\n        x @\\<^sub>v 0\\<^sub>v m = y @\\<^sub>v 0\\<^sub>v m\\<rbrakk>\n       \\<Longrightarrow> x = y", "using append_vec_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v' \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> (?v @\\<^sub>v ?w = ?v' @\\<^sub>v ?w') =\n                    (?v = ?v' \\<and> ?w = ?w')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier_vec n; y \\<in> carrier_vec n;\n        x @\\<^sub>v 0\\<^sub>v m = y @\\<^sub>v 0\\<^sub>v m\\<rbrakk>\n       \\<Longrightarrow> x = y", "by auto"], ["", "lemma padl_inj:\n  shows \"inj_on (padl m) (carrier_vec n :: 'a vec set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((@\\<^sub>v) (0\\<^sub>v m)) (carrier_vec n)", "apply(intro inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier_vec n; y \\<in> carrier_vec n;\n        0\\<^sub>v m @\\<^sub>v x = 0\\<^sub>v m @\\<^sub>v y\\<rbrakk>\n       \\<Longrightarrow> x = y", "using append_vec_eq[OF zero_carrier_vec zero_carrier_vec]"], ["proof (prove)\nusing this:\n  (0\\<^sub>v ?n @\\<^sub>v ?w = 0\\<^sub>v ?n @\\<^sub>v ?w') =\n  (0\\<^sub>v ?n = 0\\<^sub>v ?n \\<and> ?w = ?w')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier_vec n; y \\<in> carrier_vec n;\n        0\\<^sub>v m @\\<^sub>v x = 0\\<^sub>v m @\\<^sub>v y\\<rbrakk>\n       \\<Longrightarrow> x = y", "by auto"], ["", "lemma lincomb_pad:\n  fixes m n a\n  assumes U: \"(U :: 'a vec set) \\<subseteq> carrier_vec n\"\n      and finU: \"finite U\"\n  defines \"goal pad unpad W == pad m (lincomb n a W) = lincomb (n+m) (a o unpad m) (pad m ` W)\"\n  shows \"goal padr unpadr U\" (is ?R) and \"goal padl unpadl U\" (is \"?L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U &&&\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "interpret N: vectorspace class_ring \"M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M n)", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M n)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "interpret NM: vectorspace class_ring \"M (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "."], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "note [simp] = module_vec_simps class_ring_simps"], ["proof (state)\nthis:\n  (\\<oplus>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (+)\n  \\<zero>\\<^bsub>module_vec ?ty ?n\\<^esub> = 0\\<^sub>v ?n\n  carrier (module_vec ?ty ?n) = carrier_vec ?n\n  (\\<odot>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (\\<cdot>\\<^sub>v)\n  carrier class_ring = UNIV\n  (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n  (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n  \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n  \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n  ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n  finsum class_ring = sum\n  a_inv class_ring = uminus\n  a_minus class_ring = (-)\n  finprod class_ring = prod\n  inv\\<^bsub>class_ring\\<^esub> ?x =\n  (if ?x = (0::?'a) then div0 else inverse ?x)\n  class_field \\<equiv> class_ring\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "have \"?R \\<and> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U \\<and>\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "using finU U"], ["proof (prove)\nusing this:\n  finite U\n  U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U \\<and>\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "proof (induct set:finite)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> carrier_vec n \\<Longrightarrow>\n    goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr {} \\<and>\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> carrier_vec n \\<Longrightarrow>\n    goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr {} \\<and>\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr {} \\<and>\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl {}", "unfolding goal_def"], ["proof (prove)\nusing this:\n  {} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. N.lincomb a {} @\\<^sub>v 0\\<^sub>v m =\n    NM.lincomb (a \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` {}) \\<and>\n    0\\<^sub>v m @\\<^sub>v N.lincomb a {} =\n    NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` {})", "unfolding N.lincomb_def NM.lincomb_def"], ["proof (prove)\nusing this:\n  {} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>M n\\<^esub>v\\<in>{}. a v \\<odot>\\<^bsub>M n\\<^esub>\n    v) @\\<^sub>v\n    0\\<^sub>v m =\n    (\\<Oplus>\\<^bsub>M (n + m)\\<^esub>v\\<in>(\\<lambda>v.\n          v @\\<^sub>v 0\\<^sub>v m) `\n      {}. (a \\<circ> unpadr m) v \\<odot>\\<^bsub>M (n + m)\\<^esub> v) \\<and>\n    0\\<^sub>v m @\\<^sub>v\n    (\\<Oplus>\\<^bsub>M n\\<^esub>v\\<in>{}. a v \\<odot>\\<^bsub>M n\\<^esub>\n    v) =\n    (\\<Oplus>\\<^bsub>M (n + m)\\<^esub>v\\<in>(@\\<^sub>v) (0\\<^sub>v m) `\n      {}. (a \\<circ> unpadl m) v \\<odot>\\<^bsub>M (n + m)\\<^esub> v)", "by auto"], ["proof (state)\nthis:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr {} \\<and>\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "case (insert u U)"], ["proof (state)\nthis:\n  finite U\n  u \\<notin> U\n  U \\<subseteq> carrier_vec n \\<Longrightarrow>\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U \\<and>\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n  insert u U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "hence finU: \"finite U\"\n        and U: \"U \\<subseteq> carrier_vec n\"\n        and u[simp]: \"u : carrier_vec n\"\n        and uU: \"u \\<notin> U\"\n        and auU: \"a : insert u U \\<rightarrow> UNIV\"\n        and aU: \"a : U \\<rightarrow> UNIV\"\n        and au: \"a u : UNIV\""], ["proof (prove)\nusing this:\n  finite U\n  u \\<notin> U\n  U \\<subseteq> carrier_vec n \\<Longrightarrow>\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U \\<and>\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n  insert u U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (finite U &&& U \\<subseteq> carrier_vec n &&& u \\<in> carrier_vec n) &&&\n    (u \\<notin> U &&& a \\<in> insert u U \\<rightarrow> UNIV) &&&\n    a \\<in> U \\<rightarrow> UNIV &&& a u \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  finite U\n  U \\<subseteq> carrier_vec n\n  u \\<in> carrier_vec n\n  u \\<notin> U\n  a \\<in> insert u U \\<rightarrow> UNIV\n  a \\<in> U \\<rightarrow> UNIV\n  a u \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "have IHr: \"goal padr unpadr U\" and IHl: \"goal padl unpadl U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U &&&\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "using insert(3) U aU"], ["proof (prove)\nusing this:\n  U \\<subseteq> carrier_vec n \\<Longrightarrow>\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U \\<and>\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n  U \\<subseteq> carrier_vec n\n  a \\<in> U \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U &&&\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "by auto"], ["proof (state)\nthis:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "note N_lci = N.lincomb_insert2[unfolded module_vec_simps]"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S; ?S \\<subseteq> carrier_vec n;\n   ?a \\<in> insert ?v ?S \\<rightarrow> carrier class_ring; ?v \\<notin> ?S;\n   ?v \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> N.lincomb ?a (insert ?v ?S) =\n                    ?a ?v \\<cdot>\\<^sub>v ?v + N.lincomb ?a ?S\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "note NM_lci = NM.lincomb_insert2[unfolded module_vec_simps]"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S; ?S \\<subseteq> carrier_vec (n + m);\n   ?a \\<in> insert ?v ?S \\<rightarrow> carrier class_ring; ?v \\<notin> ?S;\n   ?v \\<in> carrier_vec (n + m)\\<rbrakk>\n  \\<Longrightarrow> NM.lincomb ?a (insert ?v ?S) =\n                    ?a ?v \\<cdot>\\<^sub>v ?v + NM.lincomb ?a ?S\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "have auu[simp]: \"a u \\<cdot>\\<^sub>v u : carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a u \\<cdot>\\<^sub>v u \\<in> carrier_vec n", "using au u"], ["proof (prove)\nusing this:\n  a u \\<in> UNIV\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. a u \\<cdot>\\<^sub>v u \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  a u \\<cdot>\\<^sub>v u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "have laU[simp]: \"lincomb n a U : carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N.lincomb a U \\<in> carrier_vec n", "using N.lincomb_closed[unfolded module_vec_simps class_ring_simps, OF U aU]"], ["proof (prove)\nusing this:\n  N.lincomb a U \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. N.lincomb a U \\<in> carrier_vec n", "."], ["proof (state)\nthis:\n  N.lincomb a U \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "let ?m0 = \"0\\<^sub>v m :: 'a vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "have m0: \"?m0 : carrier_vec m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v m \\<in> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v m \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "have ins: \"lincomb n a (insert u U) = a u \\<cdot>\\<^sub>v u + lincomb n a U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N.lincomb a (insert u U) = a u \\<cdot>\\<^sub>v u + N.lincomb a U", "using N_lci[OF finU U] auU uU u"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> insert ?v U \\<rightarrow> carrier class_ring;\n   ?v \\<notin> U; ?v \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> N.lincomb ?a (insert ?v U) =\n                    ?a ?v \\<cdot>\\<^sub>v ?v + N.lincomb ?a U\n  a \\<in> insert u U \\<rightarrow> UNIV\n  u \\<notin> U\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. N.lincomb a (insert u U) = a u \\<cdot>\\<^sub>v u + N.lincomb a U", "by auto"], ["proof (state)\nthis:\n  N.lincomb a (insert u U) = a u \\<cdot>\\<^sub>v u + N.lincomb a U\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> carrier_vec n \\<Longrightarrow>\n        goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr F \\<and>\n        goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl F;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr\n                          (insert x F) \\<and>\n                         goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl\n                          (insert x F)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U) \\<and>\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"padr m (a u \\<cdot>\\<^sub>v u + lincomb n a U) =\n          (a u \\<cdot>\\<^sub>v u + lincomb n a U) @\\<^sub>v (?m0 + ?m0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v 0\\<^sub>v m =\n    (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n    0\\<^sub>v m + 0\\<^sub>v m", "by auto"], ["proof (state)\nthis:\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v 0\\<^sub>v m =\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n  0\\<^sub>v m + 0\\<^sub>v m\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v 0\\<^sub>v m =\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n  0\\<^sub>v m + 0\\<^sub>v m\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"... = padr m (a u \\<cdot>\\<^sub>v u) + padr m (lincomb n a U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n    0\\<^sub>v m + 0\\<^sub>v m =\n    a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m +\n    (N.lincomb a U @\\<^sub>v 0\\<^sub>v m)", "using append_vec_add[symmetric, OF auu laU]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> carrier_vec ?m; ?w' \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n                    ?w + ?w' =\n                    a u \\<cdot>\\<^sub>v u @\\<^sub>v ?w +\n                    (N.lincomb a U @\\<^sub>v ?w')\n\ngoal (1 subgoal):\n 1. (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n    0\\<^sub>v m + 0\\<^sub>v m =\n    a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m +\n    (N.lincomb a U @\\<^sub>v 0\\<^sub>v m)", "using zero_carrier_vec[of m]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> carrier_vec ?m; ?w' \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n                    ?w + ?w' =\n                    a u \\<cdot>\\<^sub>v u @\\<^sub>v ?w +\n                    (N.lincomb a U @\\<^sub>v ?w')\n  0\\<^sub>v m \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n    0\\<^sub>v m + 0\\<^sub>v m =\n    a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m +\n    (N.lincomb a U @\\<^sub>v 0\\<^sub>v m)", "by metis"], ["proof (state)\nthis:\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n  0\\<^sub>v m + 0\\<^sub>v m =\n  a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m +\n  (N.lincomb a U @\\<^sub>v 0\\<^sub>v m)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v\n  0\\<^sub>v m + 0\\<^sub>v m =\n  a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m +\n  (N.lincomb a U @\\<^sub>v 0\\<^sub>v m)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"padr m (lincomb n a U) = lincomb (n+m) (a o unpadr m) (padr m ` U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N.lincomb a U @\\<^sub>v 0\\<^sub>v m =\n    NM.lincomb (a \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)", "using IHr"], ["proof (prove)\nusing this:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n\ngoal (1 subgoal):\n 1. N.lincomb a U @\\<^sub>v 0\\<^sub>v m =\n    NM.lincomb (a \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)", "unfolding goal_def"], ["proof (prove)\nusing this:\n  N.lincomb a U @\\<^sub>v 0\\<^sub>v m =\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)\n\ngoal (1 subgoal):\n 1. N.lincomb a U @\\<^sub>v 0\\<^sub>v m =\n    NM.lincomb (a \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)", "."], ["proof (state)\nthis:\n  N.lincomb a U @\\<^sub>v 0\\<^sub>v m =\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  N.lincomb a U @\\<^sub>v 0\\<^sub>v m =\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"padr m (a u \\<cdot>\\<^sub>v u) = a u \\<cdot>\\<^sub>v padr m u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m =\n    a u \\<cdot>\\<^sub>v (u @\\<^sub>v 0\\<^sub>v m)", "by auto"], ["proof (state)\nthis:\n  a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m =\n  a u \\<cdot>\\<^sub>v (u @\\<^sub>v 0\\<^sub>v m)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  a u \\<cdot>\\<^sub>v u @\\<^sub>v 0\\<^sub>v m =\n  a u \\<cdot>\\<^sub>v (u @\\<^sub>v 0\\<^sub>v m)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"... = (a o unpadr m) (padr m u) \\<cdot>\\<^sub>v padr m u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a u \\<cdot>\\<^sub>v (u @\\<^sub>v 0\\<^sub>v m) =\n    (a \\<circ> unpadr m) (u @\\<^sub>v 0\\<^sub>v m) \\<cdot>\\<^sub>v\n    (u @\\<^sub>v 0\\<^sub>v m)", "by auto"], ["proof (state)\nthis:\n  a u \\<cdot>\\<^sub>v (u @\\<^sub>v 0\\<^sub>v m) =\n  (a \\<circ> unpadr m) (u @\\<^sub>v 0\\<^sub>v m) \\<cdot>\\<^sub>v\n  (u @\\<^sub>v 0\\<^sub>v m)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  a u \\<cdot>\\<^sub>v (u @\\<^sub>v 0\\<^sub>v m) =\n  (a \\<circ> unpadr m) (u @\\<^sub>v 0\\<^sub>v m) \\<cdot>\\<^sub>v\n  (u @\\<^sub>v 0\\<^sub>v m)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"... + lincomb (n+m) (a o unpadr m) (padr m ` U) =\n          lincomb (n+m) (a o unpadr m) (insert (padr m u) (padr m ` U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<circ> unpadr m) (u @\\<^sub>v 0\\<^sub>v m) \\<cdot>\\<^sub>v\n    (u @\\<^sub>v 0\\<^sub>v m) +\n    NM.lincomb (a \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) =\n    NM.lincomb (a \\<circ> unpadr m)\n     (insert (u @\\<^sub>v 0\\<^sub>v m)\n       ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U))", "apply(subst NM_lci[symmetric])"], ["proof (prove)\ngoal (6 subgoals):\n 1. finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)\n 2. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U\n    \\<subseteq> carrier_vec (n + m)\n 3. a \\<circ> unpadr m\n    \\<in> insert (u @\\<^sub>v 0\\<^sub>v m)\n           ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) \\<rightarrow>\n          carrier class_ring\n 4. u @\\<^sub>v 0\\<^sub>v m\n    \\<notin> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U\n 5. u @\\<^sub>v 0\\<^sub>v m \\<in> carrier_vec (n + m)\n 6. NM.lincomb (a \\<circ> unpadr m)\n     (insert (u @\\<^sub>v 0\\<^sub>v m)\n       ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)) =\n    NM.lincomb (a \\<circ> unpadr m)\n     (insert (u @\\<^sub>v 0\\<^sub>v m)\n       ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U))", "using finU uU U append_vec_eq[OF u]"], ["proof (prove)\nusing this:\n  finite U\n  u \\<notin> U\n  U \\<subseteq> carrier_vec n\n  ?v' \\<in> carrier_vec n \\<Longrightarrow>\n  (u @\\<^sub>v ?w = ?v' @\\<^sub>v ?w') = (u = ?v' \\<and> ?w = ?w')\n\ngoal (6 subgoals):\n 1. finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)\n 2. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U\n    \\<subseteq> carrier_vec (n + m)\n 3. a \\<circ> unpadr m\n    \\<in> insert (u @\\<^sub>v 0\\<^sub>v m)\n           ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) \\<rightarrow>\n          carrier class_ring\n 4. u @\\<^sub>v 0\\<^sub>v m\n    \\<notin> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U\n 5. u @\\<^sub>v 0\\<^sub>v m \\<in> carrier_vec (n + m)\n 6. NM.lincomb (a \\<circ> unpadr m)\n     (insert (u @\\<^sub>v 0\\<^sub>v m)\n       ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)) =\n    NM.lincomb (a \\<circ> unpadr m)\n     (insert (u @\\<^sub>v 0\\<^sub>v m)\n       ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U))", "by auto"], ["proof (state)\nthis:\n  (a \\<circ> unpadr m) (u @\\<^sub>v 0\\<^sub>v m) \\<cdot>\\<^sub>v\n  (u @\\<^sub>v 0\\<^sub>v m) +\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) =\n  NM.lincomb (a \\<circ> unpadr m)\n   (insert (u @\\<^sub>v 0\\<^sub>v m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U))\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  (a \\<circ> unpadr m) (u @\\<^sub>v 0\\<^sub>v m) \\<cdot>\\<^sub>v\n  (u @\\<^sub>v 0\\<^sub>v m) +\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) =\n  NM.lincomb (a \\<circ> unpadr m)\n   (insert (u @\\<^sub>v 0\\<^sub>v m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U))\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"insert (padr m u) (padr m ` U) = padr m ` insert u U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (u @\\<^sub>v 0\\<^sub>v m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) =\n    (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` insert u U", "by auto"], ["proof (state)\nthis:\n  insert (u @\\<^sub>v 0\\<^sub>v m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` insert u U\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "finally"], ["proof (chain)\npicking this:\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v 0\\<^sub>v m =\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` insert u U)", "show \"goal padr unpadr (insert u U)\""], ["proof (prove)\nusing this:\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v 0\\<^sub>v m =\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` insert u U)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)", "unfolding goal_def ins"], ["proof (prove)\nusing this:\n  (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v 0\\<^sub>v m =\n  NM.lincomb (a \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` insert u U)\n\ngoal (1 subgoal):\n 1. (a u \\<cdot>\\<^sub>v u + N.lincomb a U) @\\<^sub>v 0\\<^sub>v m =\n    NM.lincomb (a \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` insert u U)", "."], ["proof (state)\nthis:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have [simp]: \"n+m = m+n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m = m + n", "by auto"], ["proof (state)\nthis:\n  n + m = m + n\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"padl m (a u \\<cdot>\\<^sub>v u + lincomb n a U) =\n          (?m0 + ?m0) @\\<^sub>v (a u \\<cdot>\\<^sub>v u + lincomb n a U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n    (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n    a u \\<cdot>\\<^sub>v u + N.lincomb a U", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n  (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n  a u \\<cdot>\\<^sub>v u + N.lincomb a U\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n  (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n  a u \\<cdot>\\<^sub>v u + N.lincomb a U\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"... = padl m (a u \\<cdot>\\<^sub>v u) + padl m (lincomb n a U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n    a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n    0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u +\n    (0\\<^sub>v m @\\<^sub>v N.lincomb a U)", "using append_vec_add[symmetric, OF _ _ auu laU]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v' \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> (?v + ?v') @\\<^sub>v\n                    a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n                    ?v @\\<^sub>v a u \\<cdot>\\<^sub>v u +\n                    (?v' @\\<^sub>v N.lincomb a U)\n\ngoal (1 subgoal):\n 1. (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n    a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n    0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u +\n    (0\\<^sub>v m @\\<^sub>v N.lincomb a U)", "using zero_carrier_vec[of m]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v' \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> (?v + ?v') @\\<^sub>v\n                    a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n                    ?v @\\<^sub>v a u \\<cdot>\\<^sub>v u +\n                    (?v' @\\<^sub>v N.lincomb a U)\n  0\\<^sub>v m \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n    a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n    0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u +\n    (0\\<^sub>v m @\\<^sub>v N.lincomb a U)", "by metis"], ["proof (state)\nthis:\n  (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n  a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u +\n  (0\\<^sub>v m @\\<^sub>v N.lincomb a U)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  (0\\<^sub>v m + 0\\<^sub>v m) @\\<^sub>v\n  a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u +\n  (0\\<^sub>v m @\\<^sub>v N.lincomb a U)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"padl m (lincomb n a U) = lincomb (n+m) (a o unpadl m) (padl m ` U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v N.lincomb a U =\n    NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U)", "using IHl"], ["proof (prove)\nusing this:\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v N.lincomb a U =\n    NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U)", "unfolding goal_def"], ["proof (prove)\nusing this:\n  0\\<^sub>v m @\\<^sub>v N.lincomb a U =\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v N.lincomb a U =\n    NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U)", "."], ["proof (state)\nthis:\n  0\\<^sub>v m @\\<^sub>v N.lincomb a U =\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  0\\<^sub>v m @\\<^sub>v N.lincomb a U =\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"padl m (a u \\<cdot>\\<^sub>v u) = a u \\<cdot>\\<^sub>v padl m u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u =\n    a u \\<cdot>\\<^sub>v (0\\<^sub>v m @\\<^sub>v u)", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u =\n  a u \\<cdot>\\<^sub>v (0\\<^sub>v m @\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u =\n  a u \\<cdot>\\<^sub>v (0\\<^sub>v m @\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"... = (a o unpadl m) (padl m u) \\<cdot>\\<^sub>v padl m u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a u \\<cdot>\\<^sub>v (0\\<^sub>v m @\\<^sub>v u) =\n    (a \\<circ> unpadl m) (0\\<^sub>v m @\\<^sub>v u) \\<cdot>\\<^sub>v\n    (0\\<^sub>v m @\\<^sub>v u)", "by auto"], ["proof (state)\nthis:\n  a u \\<cdot>\\<^sub>v (0\\<^sub>v m @\\<^sub>v u) =\n  (a \\<circ> unpadl m) (0\\<^sub>v m @\\<^sub>v u) \\<cdot>\\<^sub>v\n  (0\\<^sub>v m @\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  a u \\<cdot>\\<^sub>v (0\\<^sub>v m @\\<^sub>v u) =\n  (a \\<circ> unpadl m) (0\\<^sub>v m @\\<^sub>v u) \\<cdot>\\<^sub>v\n  (0\\<^sub>v m @\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"... + lincomb (n+m) (a o unpadl m) (padl m ` U) =\n          lincomb (n+m) (a o unpadl m) (insert (padl m u) (padl m ` U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<circ> unpadl m) (0\\<^sub>v m @\\<^sub>v u) \\<cdot>\\<^sub>v\n    (0\\<^sub>v m @\\<^sub>v u) +\n    NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U) =\n    NM.lincomb (a \\<circ> unpadl m)\n     (insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U))", "apply(subst NM_lci[symmetric])"], ["proof (prove)\ngoal (6 subgoals):\n 1. finite ((@\\<^sub>v) (0\\<^sub>v m) ` U)\n 2. (@\\<^sub>v) (0\\<^sub>v m) ` U \\<subseteq> carrier_vec (n + m)\n 3. a \\<circ> unpadl m\n    \\<in> insert (0\\<^sub>v m @\\<^sub>v u)\n           ((@\\<^sub>v) (0\\<^sub>v m) ` U) \\<rightarrow>\n          carrier class_ring\n 4. 0\\<^sub>v m @\\<^sub>v u \\<notin> (@\\<^sub>v) (0\\<^sub>v m) ` U\n 5. 0\\<^sub>v m @\\<^sub>v u \\<in> carrier_vec (n + m)\n 6. NM.lincomb (a \\<circ> unpadl m)\n     (insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U)) =\n    NM.lincomb (a \\<circ> unpadl m)\n     (insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U))", "using finU uU U append_vec_eq[OF m0]"], ["proof (prove)\nusing this:\n  finite U\n  u \\<notin> U\n  U \\<subseteq> carrier_vec n\n  ?v' \\<in> carrier_vec m \\<Longrightarrow>\n  (0\\<^sub>v m @\\<^sub>v ?w = ?v' @\\<^sub>v ?w') =\n  (0\\<^sub>v m = ?v' \\<and> ?w = ?w')\n\ngoal (6 subgoals):\n 1. finite ((@\\<^sub>v) (0\\<^sub>v m) ` U)\n 2. (@\\<^sub>v) (0\\<^sub>v m) ` U \\<subseteq> carrier_vec (n + m)\n 3. a \\<circ> unpadl m\n    \\<in> insert (0\\<^sub>v m @\\<^sub>v u)\n           ((@\\<^sub>v) (0\\<^sub>v m) ` U) \\<rightarrow>\n          carrier class_ring\n 4. 0\\<^sub>v m @\\<^sub>v u \\<notin> (@\\<^sub>v) (0\\<^sub>v m) ` U\n 5. 0\\<^sub>v m @\\<^sub>v u \\<in> carrier_vec (n + m)\n 6. NM.lincomb (a \\<circ> unpadl m)\n     (insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U)) =\n    NM.lincomb (a \\<circ> unpadl m)\n     (insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U))", "by auto"], ["proof (state)\nthis:\n  (a \\<circ> unpadl m) (0\\<^sub>v m @\\<^sub>v u) \\<cdot>\\<^sub>v\n  (0\\<^sub>v m @\\<^sub>v u) +\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U) =\n  NM.lincomb (a \\<circ> unpadl m)\n   (insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U))\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "also"], ["proof (state)\nthis:\n  (a \\<circ> unpadl m) (0\\<^sub>v m @\\<^sub>v u) \\<cdot>\\<^sub>v\n  (0\\<^sub>v m @\\<^sub>v u) +\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` U) =\n  NM.lincomb (a \\<circ> unpadl m)\n   (insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U))\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "have \"insert (padl m u) (padl m ` U) = padl m ` insert u U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U) =\n    (@\\<^sub>v) (0\\<^sub>v m) ` insert u U", "by auto"], ["proof (state)\nthis:\n  insert (0\\<^sub>v m @\\<^sub>v u) ((@\\<^sub>v) (0\\<^sub>v m) ` U) =\n  (@\\<^sub>v) (0\\<^sub>v m) ` insert u U\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "finally"], ["proof (chain)\npicking this:\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` insert u U)", "show \"goal padl unpadl (insert u U)\""], ["proof (prove)\nusing this:\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` insert u U)\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)", "unfolding goal_def ins"], ["proof (prove)\nusing this:\n  0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n  NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` insert u U)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v m @\\<^sub>v a u \\<cdot>\\<^sub>v u + N.lincomb a U =\n    NM.lincomb (a \\<circ> unpadl m) ((@\\<^sub>v) (0\\<^sub>v m) ` insert u U)", "."], ["proof (state)\nthis:\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr (insert u U) \\<and>\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl (insert u U)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U \\<and>\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "thus ?R ?L"], ["proof (prove)\nusing this:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U \\<and>\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U &&&\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U", "by auto"], ["proof (state)\nthis:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) unpadr U\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) unpadl U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_pad:\n  assumes U: \"(U::'a vec set) \\<subseteq> carrier_vec n\"\n  defines \"goal pad m == pad m ` span n U = span (n+m) (pad m ` U)\"\n  shows \"goal padr m\" \"goal padl m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m &&&\n    goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "interpret N: vectorspace class_ring \"M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M n)", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M n)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "interpret NM: vectorspace class_ring \"M (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "."], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "fix pad :: \"'a vec \\<Rightarrow> 'a vec\" and unpad :: \"'a vec \\<Rightarrow> 'a vec\""], ["proof (state)\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "assume main: \"\\<And>A a. A \\<subseteq> U \\<Longrightarrow> finite A \\<Longrightarrow>\n      pad (lincomb n a A) = lincomb (n+m) (a o unpad) (pad ` A)\""], ["proof (state)\nthis:\n  \\<lbrakk>?A1 \\<subseteq> U; finite ?A1\\<rbrakk>\n  \\<Longrightarrow> pad (N.lincomb ?a1 ?A1) =\n                    NM.lincomb (?a1 \\<circ> unpad) (pad ` ?A1)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "assume [simp]: \"\\<And>v. unpad (pad v) = v\""], ["proof (state)\nthis:\n  unpad (pad ?v1) = ?v1\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "assume pU: \"pad ` U \\<subseteq> carrier_vec (n+m)\""], ["proof (state)\nthis:\n  pad ` U \\<subseteq> carrier_vec (n + m)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "have \"pad ` (span n U) = span (n+m) (pad ` U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pad ` N.span U = NM.span (pad ` U)", "proof (intro Set.equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> pad ` N.span U \\<Longrightarrow> x \\<in> NM.span (pad ` U)\n 2. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> pad ` N.span U \\<Longrightarrow> x \\<in> NM.span (pad ` U)\n 2. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "assume \"x : pad ` (span n U)\""], ["proof (state)\nthis:\n  x \\<in> pad ` N.span U\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> pad ` N.span U \\<Longrightarrow> x \\<in> NM.span (pad ` U)\n 2. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "then"], ["proof (chain)\npicking this:\n  x \\<in> pad ` N.span U", "obtain v where \"v : span n U\" and xv: \"x = pad v\""], ["proof (prove)\nusing this:\n  x \\<in> pad ` N.span U\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> N.span U; x = pad v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> N.span U\n  x = pad v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> pad ` N.span U \\<Longrightarrow> x \\<in> NM.span (pad ` U)\n 2. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "then"], ["proof (chain)\npicking this:\n  v \\<in> N.span U\n  x = pad v", "obtain a A\n        where AU: \"A \\<subseteq> U\" and finA: \"finite A\" and a: \"a : A \\<rightarrow> UNIV\"\n          and vaA: \"v = lincomb n a A\""], ["proof (prove)\nusing this:\n  v \\<in> N.span U\n  x = pad v\n\ngoal (1 subgoal):\n 1. (\\<And>A a.\n        \\<lbrakk>A \\<subseteq> U; finite A; a \\<in> A \\<rightarrow> UNIV;\n         v = N.lincomb a A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding N.span_def"], ["proof (prove)\nusing this:\n  v \\<in> {N.lincomb a A |a A.\n           finite A \\<and>\n           A \\<subseteq> U \\<and>\n           a \\<in> A \\<rightarrow> carrier class_ring}\n  x = pad v\n\ngoal (1 subgoal):\n 1. (\\<And>A a.\n        \\<lbrakk>A \\<subseteq> U; finite A; a \\<in> A \\<rightarrow> UNIV;\n         v = N.lincomb a A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> U\n  finite A\n  a \\<in> A \\<rightarrow> UNIV\n  v = N.lincomb a A\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> pad ` N.span U \\<Longrightarrow> x \\<in> NM.span (pad ` U)\n 2. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "hence A: \"A \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  A \\<subseteq> U\n  finite A\n  a \\<in> A \\<rightarrow> UNIV\n  v = N.lincomb a A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier_vec n", "using U"], ["proof (prove)\nusing this:\n  A \\<subseteq> U\n  finite A\n  a \\<in> A \\<rightarrow> UNIV\n  v = N.lincomb a A\n  U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> pad ` N.span U \\<Longrightarrow> x \\<in> NM.span (pad ` U)\n 2. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "show \"x : span (n+m) (pad ` U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> NM.span (pad ` U)", "unfolding NM.span_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {NM.lincomb a A |a A.\n             finite A \\<and>\n             A \\<subseteq> pad ` U \\<and>\n             a \\<in> A \\<rightarrow> carrier class_ring}", "proof (intro CollectI exI conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. x = NM.lincomb ?a1 ?A2\n 2. finite ?A2\n 3. ?A2 \\<subseteq> pad ` U\n 4. ?a1 \\<in> ?A2 \\<rightarrow> carrier class_ring", "show \"x = lincomb (n+m) (a o unpad) (pad ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = NM.lincomb (a \\<circ> unpad) (pad ` A)", "using xv vaA main[OF AU finA]"], ["proof (prove)\nusing this:\n  x = pad v\n  v = N.lincomb a A\n  pad (N.lincomb ?a1 A) = NM.lincomb (?a1 \\<circ> unpad) (pad ` A)\n\ngoal (1 subgoal):\n 1. x = NM.lincomb (a \\<circ> unpad) (pad ` A)", "by auto"], ["proof (state)\nthis:\n  x = NM.lincomb (a \\<circ> unpad) (pad ` A)\n\ngoal (3 subgoals):\n 1. finite (pad ` A)\n 2. pad ` A \\<subseteq> pad ` U\n 3. a \\<circ> unpad \\<in> pad ` A \\<rightarrow> carrier class_ring", "show \"pad ` A \\<subseteq> pad ` U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pad ` A \\<subseteq> pad ` U", "using AU"], ["proof (prove)\nusing this:\n  A \\<subseteq> U\n\ngoal (1 subgoal):\n 1. pad ` A \\<subseteq> pad ` U", "by auto"], ["proof (state)\nthis:\n  pad ` A \\<subseteq> pad ` U\n\ngoal (2 subgoals):\n 1. finite (pad ` A)\n 2. a \\<circ> unpad \\<in> pad ` A \\<rightarrow> carrier class_ring", "qed (insert finA, auto simp: class_ring_simps)"], ["proof (state)\nthis:\n  x \\<in> NM.span (pad ` U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "assume \"x : span (n+m) (pad ` U)\""], ["proof (state)\nthis:\n  x \\<in> NM.span (pad ` U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "then"], ["proof (chain)\npicking this:\n  x \\<in> NM.span (pad ` U)", "obtain a' A'\n        where A'U: \"A' \\<subseteq> pad ` U\" and finA': \"finite A'\" and a': \"a' : A' \\<rightarrow> UNIV\"\n          and xa'A': \"x = lincomb (n+m) a' A'\""], ["proof (prove)\nusing this:\n  x \\<in> NM.span (pad ` U)\n\ngoal (1 subgoal):\n 1. (\\<And>A' a'.\n        \\<lbrakk>A' \\<subseteq> pad ` U; finite A';\n         a' \\<in> A' \\<rightarrow> UNIV; x = NM.lincomb a' A'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding NM.span_def"], ["proof (prove)\nusing this:\n  x \\<in> {NM.lincomb a A |a A.\n           finite A \\<and>\n           A \\<subseteq> pad ` U \\<and>\n           a \\<in> A \\<rightarrow> carrier class_ring}\n\ngoal (1 subgoal):\n 1. (\\<And>A' a'.\n        \\<lbrakk>A' \\<subseteq> pad ` U; finite A';\n         a' \\<in> A' \\<rightarrow> UNIV; x = NM.lincomb a' A'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A' \\<subseteq> pad ` U\n  finite A'\n  a' \\<in> A' \\<rightarrow> UNIV\n  x = NM.lincomb a' A'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "then"], ["proof (chain)\npicking this:\n  A' \\<subseteq> pad ` U\n  finite A'\n  a' \\<in> A' \\<rightarrow> UNIV\n  x = NM.lincomb a' A'", "obtain A where finA: \"finite A\" and AU: \"A \\<subseteq> U\" and A'A: \"A' = pad ` A\""], ["proof (prove)\nusing this:\n  A' \\<subseteq> pad ` U\n  finite A'\n  a' \\<in> A' \\<rightarrow> UNIV\n  x = NM.lincomb a' A'\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>finite A; A \\<subseteq> U; A' = pad ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_subset_image[OF finA' A'U]"], ["proof (prove)\nusing this:\n  A' \\<subseteq> pad ` U\n  finite A'\n  a' \\<in> A' \\<rightarrow> UNIV\n  x = NM.lincomb a' A'\n  \\<exists>C\\<subseteq>U. finite C \\<and> A' = pad ` C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>finite A; A \\<subseteq> U; A' = pad ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> U\n  A' = pad ` A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "hence A: \"A \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> U\n  A' = pad ` A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier_vec n", "using U"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> U\n  A' = pad ` A\n  U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "have A': \"A' \\<subseteq> carrier_vec (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<subseteq> carrier_vec (n + m)", "using A'U pU"], ["proof (prove)\nusing this:\n  A' \\<subseteq> pad ` U\n  pad ` U \\<subseteq> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. A' \\<subseteq> carrier_vec (n + m)", "by auto"], ["proof (state)\nthis:\n  A' \\<subseteq> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "define a where \"a = a' o pad\""], ["proof (state)\nthis:\n  a = a' \\<circ> pad\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "define a'' where \"a'' = (a' o pad) o unpad\""], ["proof (state)\nthis:\n  a'' = a' \\<circ> pad \\<circ> unpad\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "have a: \"a : A \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<rightarrow> UNIV", "by auto"], ["proof (state)\nthis:\n  a \\<in> A \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "have restr: \"restrict a' A' = restrict a'' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict a' A' = restrict a'' A'", "proof(rule restrict_ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A' \\<Longrightarrow> a' x = a'' x", "fix u'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A' \\<Longrightarrow> a' x = a'' x", "assume \"u' : A'\""], ["proof (state)\nthis:\n  u' \\<in> A'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A' \\<Longrightarrow> a' x = a'' x", "then"], ["proof (chain)\npicking this:\n  u' \\<in> A'", "obtain u where \"u : A\" and \"u' = pad u\""], ["proof (prove)\nusing this:\n  u' \\<in> A'\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> A; u' = pad u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding A'A"], ["proof (prove)\nusing this:\n  u' \\<in> pad ` A\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> A; u' = pad u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> A\n  u' = pad u\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A' \\<Longrightarrow> a' x = a'' x", "thus \"a' u' = a'' u'\""], ["proof (prove)\nusing this:\n  u \\<in> A\n  u' = pad u\n\ngoal (1 subgoal):\n 1. a' u' = a'' u'", "unfolding a''_def a_def"], ["proof (prove)\nusing this:\n  u \\<in> A\n  u' = pad u\n\ngoal (1 subgoal):\n 1. a' u' = (a' \\<circ> pad \\<circ> unpad) u'", "by auto"], ["proof (state)\nthis:\n  a' u' = a'' u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict a' A' = restrict a'' A'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "have \"x = lincomb (n+m) a' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = NM.lincomb a' A'", "using xa'A'"], ["proof (prove)\nusing this:\n  x = NM.lincomb a' A'\n\ngoal (1 subgoal):\n 1. x = NM.lincomb a' A'", "unfolding A'A"], ["proof (prove)\nusing this:\n  x = NM.lincomb a' (pad ` A)\n\ngoal (1 subgoal):\n 1. x = NM.lincomb a' (pad ` A)", "."], ["proof (state)\nthis:\n  x = NM.lincomb a' A'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "also"], ["proof (state)\nthis:\n  x = NM.lincomb a' A'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "have \"... = lincomb (n+m) a'' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb a' A' = NM.lincomb a'' A'", "apply (subst NM.lincomb_restrict)"], ["proof (prove)\ngoal (4 subgoals):\n 1. A' \\<subseteq> carrier (M (n + m))\n 2. a' \\<in> A' \\<rightarrow> carrier class_ring\n 3. restrict a' A' = restrict ?b A'\n 4. NM.lincomb ?b A' = NM.lincomb a'' A'", "using finA' A' restr"], ["proof (prove)\nusing this:\n  finite A'\n  A' \\<subseteq> carrier_vec (n + m)\n  restrict a' A' = restrict a'' A'\n\ngoal (4 subgoals):\n 1. A' \\<subseteq> carrier (M (n + m))\n 2. a' \\<in> A' \\<rightarrow> carrier class_ring\n 3. restrict a' A' = restrict ?b A'\n 4. NM.lincomb ?b A' = NM.lincomb a'' A'", "by (auto simp: module_vec_simps class_ring_simps)"], ["proof (state)\nthis:\n  NM.lincomb a' A' = NM.lincomb a'' A'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "also"], ["proof (state)\nthis:\n  NM.lincomb a' A' = NM.lincomb a'' A'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "have \"... = lincomb (n+m) a'' (pad ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb a'' A' = NM.lincomb a'' (pad ` A)", "unfolding A'A"], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb a'' (pad ` A) = NM.lincomb a'' (pad ` A)", ".."], ["proof (state)\nthis:\n  NM.lincomb a'' A' = NM.lincomb a'' (pad ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "also"], ["proof (state)\nthis:\n  NM.lincomb a'' A' = NM.lincomb a'' (pad ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "have \"... = pad (lincomb n a A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb a'' (pad ` A) = pad (N.lincomb a A)", "unfolding a''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb (a' \\<circ> pad \\<circ> unpad) (pad ` A) =\n    pad (N.lincomb a A)", "using main[OF AU finA]"], ["proof (prove)\nusing this:\n  pad (N.lincomb ?a1 A) = NM.lincomb (?a1 \\<circ> unpad) (pad ` A)\n\ngoal (1 subgoal):\n 1. NM.lincomb (a' \\<circ> pad \\<circ> unpad) (pad ` A) =\n    pad (N.lincomb a A)", "unfolding a_def"], ["proof (prove)\nusing this:\n  pad (N.lincomb ?a1 A) = NM.lincomb (?a1 \\<circ> unpad) (pad ` A)\n\ngoal (1 subgoal):\n 1. NM.lincomb (a' \\<circ> pad \\<circ> unpad) (pad ` A) =\n    pad (N.lincomb (a' \\<circ> pad) A)", "by auto"], ["proof (state)\nthis:\n  NM.lincomb a'' (pad ` A) = pad (N.lincomb a A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> NM.span (pad ` U) \\<Longrightarrow> x \\<in> pad ` N.span U", "finally"], ["proof (chain)\npicking this:\n  x = pad (N.lincomb a A)", "show \"x : pad ` (span n U)\""], ["proof (prove)\nusing this:\n  x = pad (N.lincomb a A)\n\ngoal (1 subgoal):\n 1. x \\<in> pad ` N.span U", "unfolding N.span_def"], ["proof (prove)\nusing this:\n  x = pad (N.lincomb a A)\n\ngoal (1 subgoal):\n 1. x \\<in> pad `\n            {N.lincomb a A |a A.\n             finite A \\<and>\n             A \\<subseteq> U \\<and>\n             a \\<in> A \\<rightarrow> carrier class_ring}", "apply(rule image_eqI, intro CollectI exI conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x = pad (N.lincomb a A) \\<Longrightarrow>\n    N.lincomb a A = N.lincomb ?a10 ?A11\n 2. x = pad (N.lincomb a A) \\<Longrightarrow> finite ?A11\n 3. x = pad (N.lincomb a A) \\<Longrightarrow> ?A11 \\<subseteq> U\n 4. x = pad (N.lincomb a A) \\<Longrightarrow>\n    ?a10 \\<in> ?A11 \\<rightarrow> carrier class_ring", "using finA AU"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> U\n\ngoal (4 subgoals):\n 1. x = pad (N.lincomb a A) \\<Longrightarrow>\n    N.lincomb a A = N.lincomb ?a10 ?A11\n 2. x = pad (N.lincomb a A) \\<Longrightarrow> finite ?A11\n 3. x = pad (N.lincomb a A) \\<Longrightarrow> ?A11 \\<subseteq> U\n 4. x = pad (N.lincomb a A) \\<Longrightarrow>\n    ?a10 \\<in> ?A11 \\<rightarrow> carrier class_ring", "by (auto simp: class_ring_simps)"], ["proof (state)\nthis:\n  x \\<in> pad ` N.span U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pad ` N.span U = NM.span (pad ` U)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>A a.\n              \\<lbrakk>A \\<subseteq> U; finite A\\<rbrakk>\n              \\<Longrightarrow> ?pad3 (N.lincomb a A) =\n                                NM.lincomb (a \\<circ> ?unpad3) (?pad3 ` A);\n   \\<And>v. ?unpad3 (?pad3 v) = v;\n   ?pad3 ` U \\<subseteq> carrier_vec (n + m)\\<rbrakk>\n  \\<Longrightarrow> ?pad3 ` N.span U = NM.span (?pad3 ` U)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>A a.\n              \\<lbrakk>A \\<subseteq> U; finite A\\<rbrakk>\n              \\<Longrightarrow> ?pad3 (N.lincomb a A) =\n                                NM.lincomb (a \\<circ> ?unpad3) (?pad3 ` A);\n   \\<And>v. ?unpad3 (?pad3 v) = v;\n   ?pad3 ` U \\<subseteq> carrier_vec (n + m)\\<rbrakk>\n  \\<Longrightarrow> ?pad3 ` N.span U = NM.span (?pad3 ` U)\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "have AUC: \"\\<And>A. A \\<subseteq> U \\<Longrightarrow> A \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. A \\<subseteq> U \\<Longrightarrow> A \\<subseteq> carrier_vec n", "using U"], ["proof (prove)\nusing this:\n  U \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>A. A \\<subseteq> U \\<Longrightarrow> A \\<subseteq> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  ?A1 \\<subseteq> U \\<Longrightarrow> ?A1 \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "have [simp]: \"n+m = m+n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m = m + n", "by auto"], ["proof (state)\nthis:\n  n + m = m + n\n\ngoal (2 subgoals):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n 2. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "show \"goal padr m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m", "unfolding goal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` N.span U =\n    NM.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)", "apply (subst main[OF _ _ padr_image[OF U]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> U; finite A\\<rbrakk>\n       \\<Longrightarrow> N.lincomb a A @\\<^sub>v 0\\<^sub>v m =\n                         NM.lincomb (a \\<circ> ?unpad)\n                          ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 2. \\<And>v. ?unpad (v @\\<^sub>v 0\\<^sub>v m) = v\n 3. NM.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) =\n    NM.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)", "using lincomb_pad[OF AUC] unpadr_padr"], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<subseteq> U; finite ?U\\<rbrakk>\n  \\<Longrightarrow> N.lincomb ?a ?U @\\<^sub>v 0\\<^sub>v ?m =\n                    lincomb (n + ?m) (?a \\<circ> unpadr ?m)\n                     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` ?U)\n  \\<lbrakk>?U \\<subseteq> U; finite ?U\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>v ?m @\\<^sub>v N.lincomb ?a ?U =\n                    lincomb (n + ?m) (?a \\<circ> unpadl ?m)\n                     ((@\\<^sub>v) (0\\<^sub>v ?m) ` ?U)\n  unpadr ?m (?v @\\<^sub>v 0\\<^sub>v ?m) = ?v\n\ngoal (3 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> U; finite A\\<rbrakk>\n       \\<Longrightarrow> N.lincomb a A @\\<^sub>v 0\\<^sub>v m =\n                         NM.lincomb (a \\<circ> ?unpad)\n                          ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 2. \\<And>v. ?unpad (v @\\<^sub>v 0\\<^sub>v m) = v\n 3. NM.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U) =\n    NM.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` U)", "by auto"], ["proof (state)\nthis:\n  goal (\\<lambda>m v. v @\\<^sub>v 0\\<^sub>v m) m\n\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "show \"goal padl m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m", "unfolding goal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (@\\<^sub>v) (0\\<^sub>v m) ` N.span U =\n    NM.span ((@\\<^sub>v) (0\\<^sub>v m) ` U)", "apply (subst main)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> U; finite A\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>v m @\\<^sub>v N.lincomb a A =\n                         NM.lincomb (a \\<circ> ?unpad)\n                          ((@\\<^sub>v) (0\\<^sub>v m) ` A)\n 2. \\<And>v. ?unpad (0\\<^sub>v m @\\<^sub>v v) = v\n 3. (@\\<^sub>v) (0\\<^sub>v m) ` U \\<subseteq> carrier_vec (n + m)\n 4. NM.span ((@\\<^sub>v) (0\\<^sub>v m) ` U) =\n    NM.span ((@\\<^sub>v) (0\\<^sub>v m) ` U)", "using lincomb_pad[OF AUC] unpadl_padl padl_image[OF U]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<subseteq> U; finite ?U\\<rbrakk>\n  \\<Longrightarrow> N.lincomb ?a ?U @\\<^sub>v 0\\<^sub>v ?m =\n                    lincomb (n + ?m) (?a \\<circ> unpadr ?m)\n                     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` ?U)\n  \\<lbrakk>?U \\<subseteq> U; finite ?U\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>v ?m @\\<^sub>v N.lincomb ?a ?U =\n                    lincomb (n + ?m) (?a \\<circ> unpadl ?m)\n                     ((@\\<^sub>v) (0\\<^sub>v ?m) ` ?U)\n  unpadl ?m (0\\<^sub>v ?m @\\<^sub>v ?v) = ?v\n  (@\\<^sub>v) (0\\<^sub>v ?m) ` U \\<subseteq> carrier_vec (?m + n)\n\ngoal (4 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> U; finite A\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>v m @\\<^sub>v N.lincomb a A =\n                         NM.lincomb (a \\<circ> ?unpad)\n                          ((@\\<^sub>v) (0\\<^sub>v m) ` A)\n 2. \\<And>v. ?unpad (0\\<^sub>v m @\\<^sub>v v) = v\n 3. (@\\<^sub>v) (0\\<^sub>v m) ` U \\<subseteq> carrier_vec (n + m)\n 4. NM.span ((@\\<^sub>v) (0\\<^sub>v m) ` U) =\n    NM.span ((@\\<^sub>v) (0\\<^sub>v m) ` U)", "by auto"], ["proof (state)\nthis:\n  goal (\\<lambda>m. (@\\<^sub>v) (0\\<^sub>v m)) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kernel_padr:\n  assumes aA: \"a : mat_kernel (A :: 'a :: field mat)\"\n      and A: \"A : carrier_mat nr1 nc1\"\n      and B: \"B : carrier_mat nr1 nc2\"\n      and D: \"D : carrier_mat nr2 nc2\"\n  shows \"padr nc2 a : mat_kernel (four_block_mat A B (0\\<^sub>m nr2 nc1) D)\" (is \"_ : mat_kernel ?ABCD\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> mat_kernel (four_block_mat A B (0\\<^sub>m nr2 nc1) D)", "unfolding mat_kernel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> {v \\<in> carrier_vec\n                    (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D)).\n           four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v v =\n           0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D))}", "proof (rule, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> carrier_vec (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D))\n 2. four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D))", "have [simp]: \"dim_row A = nr1\" \"dim_row D = nr2\" \"dim_row ?ABCD = nr1 + nr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = nr1 &&&\n    dim_row D = nr2 &&&\n    dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) = nr1 + nr2", "using A D"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr1 nc1\n  D \\<in> carrier_mat nr2 nc2\n\ngoal (1 subgoal):\n 1. dim_row A = nr1 &&&\n    dim_row D = nr2 &&&\n    dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) = nr1 + nr2", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr1\n  dim_row D = nr2\n  dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) = nr1 + nr2\n\ngoal (2 subgoals):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> carrier_vec (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D))\n 2. four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D))", "have a: \"a : carrier_vec nc1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec nc1", "using mat_kernel_carrier[OF A] aA"], ["proof (prove)\nusing this:\n  mat_kernel A \\<subseteq> carrier_vec nc1\n  a \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec nc1", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier_vec nc1\n\ngoal (2 subgoals):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> carrier_vec (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D))\n 2. four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D))", "show \"?ABCD *\\<^sub>v padr nc2 a = 0\\<^sub>v (dim_row ?ABCD)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A B (0\\<^sub>m nr2 nc1)\n                  D))) \\<Longrightarrow>\n       (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n        (a @\\<^sub>v 0\\<^sub>v nc2)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i\n 2. dim_vec\n     (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n      (a @\\<^sub>v 0\\<^sub>v nc2)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A B (0\\<^sub>m nr2 nc1)\n                  D))) \\<Longrightarrow>\n       (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n        (a @\\<^sub>v 0\\<^sub>v nc2)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i\n 2. dim_vec\n     (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n      (a @\\<^sub>v 0\\<^sub>v nc2)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))", "assume i: \"i < dim_vec ?r\""], ["proof (state)\nthis:\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A B (0\\<^sub>m nr2 nc1)\n                  D))) \\<Longrightarrow>\n       (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n        (a @\\<^sub>v 0\\<^sub>v nc2)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i\n 2. dim_vec\n     (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n      (a @\\<^sub>v 0\\<^sub>v nc2)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))", "hence \"?l $ i = row ?ABCD i \\<bullet> padr nc2 a\""], ["proof (prove)\nusing this:\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))\n\ngoal (1 subgoal):\n 1. (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n     (a @\\<^sub>v 0\\<^sub>v nc2)) $\n    i =\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2)", "by auto"], ["proof (state)\nthis:\n  (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n   (a @\\<^sub>v 0\\<^sub>v nc2)) $\n  i =\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A B (0\\<^sub>m nr2 nc1)\n                  D))) \\<Longrightarrow>\n       (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n        (a @\\<^sub>v 0\\<^sub>v nc2)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i\n 2. dim_vec\n     (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n      (a @\\<^sub>v 0\\<^sub>v nc2)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))", "also"], ["proof (state)\nthis:\n  (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n   (a @\\<^sub>v 0\\<^sub>v nc2)) $\n  i =\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A B (0\\<^sub>m nr2 nc1)\n                  D))) \\<Longrightarrow>\n       (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n        (a @\\<^sub>v 0\\<^sub>v nc2)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i\n 2. dim_vec\n     (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n      (a @\\<^sub>v 0\\<^sub>v nc2)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "proof (cases \"i < nr1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  i < nr1\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "hence rows: \"row A i : carrier_vec nc1\" \"row B i : carrier_vec nc2\""], ["proof (prove)\nusing this:\n  i < nr1\n\ngoal (1 subgoal):\n 1. row A i \\<in> carrier_vec nc1 &&& row B i \\<in> carrier_vec nc2", "using A B"], ["proof (prove)\nusing this:\n  i < nr1\n  A \\<in> carrier_mat nr1 nc1\n  B \\<in> carrier_mat nr1 nc2\n\ngoal (1 subgoal):\n 1. row A i \\<in> carrier_vec nc1 &&& row B i \\<in> carrier_vec nc2", "by auto"], ["proof (state)\nthis:\n  row A i \\<in> carrier_vec nc1\n  row B i \\<in> carrier_vec nc2\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"row ?ABCD i = row A i @\\<^sub>v row B i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n    row A i @\\<^sub>v row B i", "using row_four_block_mat(1)[OF A B _ D True]"], ["proof (prove)\nusing this:\n  ?C \\<in> carrier_mat nr2 nc1 \\<Longrightarrow>\n  row (four_block_mat A B ?C D) i = row A i @\\<^sub>v row B i\n\ngoal (1 subgoal):\n 1. row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n    row A i @\\<^sub>v row B i", "by auto"], ["proof (state)\nthis:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n  row A i @\\<^sub>v row B i\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n  row A i @\\<^sub>v row B i\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"... \\<bullet> padr nc2 a = row A i \\<bullet> a + row B i \\<bullet> 0\\<^sub>v nc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row A i @\\<^sub>v row B i) \\<bullet> (a @\\<^sub>v 0\\<^sub>v nc2) =\n    row A i \\<bullet> a + row B i \\<bullet> 0\\<^sub>v nc2", "using scalar_prod_append[OF rows] a"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w1.0 \\<in> carrier_vec nc1; ?w2.0 \\<in> carrier_vec nc2\\<rbrakk>\n  \\<Longrightarrow> (row A i @\\<^sub>v row B i) \\<bullet>\n                    (?w1.0 @\\<^sub>v ?w2.0) =\n                    row A i \\<bullet> ?w1.0 + row B i \\<bullet> ?w2.0\n  a \\<in> carrier_vec nc1\n\ngoal (1 subgoal):\n 1. (row A i @\\<^sub>v row B i) \\<bullet> (a @\\<^sub>v 0\\<^sub>v nc2) =\n    row A i \\<bullet> a + row B i \\<bullet> 0\\<^sub>v nc2", "by auto"], ["proof (state)\nthis:\n  (row A i @\\<^sub>v row B i) \\<bullet> (a @\\<^sub>v 0\\<^sub>v nc2) =\n  row A i \\<bullet> a + row B i \\<bullet> 0\\<^sub>v nc2\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (row A i @\\<^sub>v row B i) \\<bullet> (a @\\<^sub>v 0\\<^sub>v nc2) =\n  row A i \\<bullet> a + row B i \\<bullet> 0\\<^sub>v nc2\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"row A i \\<bullet> a = (A *\\<^sub>v a) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> a = (A *\\<^sub>v a) $ i", "using True A"], ["proof (prove)\nusing this:\n  i < nr1\n  A \\<in> carrier_mat nr1 nc1\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> a = (A *\\<^sub>v a) $ i", "by auto"], ["proof (state)\nthis:\n  row A i \\<bullet> a = (A *\\<^sub>v a) $ i\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row A i \\<bullet> a = (A *\\<^sub>v a) $ i\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v a) $ i = (0::'a)", "using mat_kernelD[OF A aA] True"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec nc1\n  A *\\<^sub>v a = 0\\<^sub>v nr1\n  i < nr1\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v a) $ i = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (A *\\<^sub>v a) $ i = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (A *\\<^sub>v a) $ i = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"row B i \\<bullet> 0\\<^sub>v nc2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row B i \\<bullet> 0\\<^sub>v nc2 = (0::'a)", "using True rows"], ["proof (prove)\nusing this:\n  i < nr1\n  row A i \\<in> carrier_vec nc1\n  row B i \\<in> carrier_vec nc2\n\ngoal (1 subgoal):\n 1. row B i \\<bullet> 0\\<^sub>v nc2 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  row B i \\<bullet> 0\\<^sub>v nc2 = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  (0::'a) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> i < nr1\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "let ?C = \"0\\<^sub>m nr2 nc1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "let ?i = \"i - nr1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have rows:\n            \"row ?C ?i : carrier_vec nc1\" \"row D ?i : carrier_vec nc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (0\\<^sub>m nr2 nc1) (i - nr1) \\<in> carrier_vec nc1 &&&\n    row D (i - nr1) \\<in> carrier_vec nc2", "using D i False A"], ["proof (prove)\nusing this:\n  D \\<in> carrier_mat nr2 nc2\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))\n  \\<not> i < nr1\n  A \\<in> carrier_mat nr1 nc1\n\ngoal (1 subgoal):\n 1. row (0\\<^sub>m nr2 nc1) (i - nr1) \\<in> carrier_vec nc1 &&&\n    row D (i - nr1) \\<in> carrier_vec nc2", "by auto"], ["proof (state)\nthis:\n  row (0\\<^sub>m nr2 nc1) (i - nr1) \\<in> carrier_vec nc1\n  row D (i - nr1) \\<in> carrier_vec nc2\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"row ?ABCD i = row ?C ?i @\\<^sub>v row D ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n    row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)", "using row_four_block_mat(2)[OF A B _ D False] i A D"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<in> carrier_mat nr2 nc1; i < nr1 + nr2\\<rbrakk>\n  \\<Longrightarrow> row (four_block_mat A B ?C D) i =\n                    row ?C (i - nr1) @\\<^sub>v row D (i - nr1)\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))\n  A \\<in> carrier_mat nr1 nc1\n  D \\<in> carrier_mat nr2 nc2\n\ngoal (1 subgoal):\n 1. row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n    row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)", "by auto"], ["proof (state)\nthis:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n  row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i =\n  row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"... \\<bullet> padr nc2 a = row ?C ?i \\<bullet> a + row D ?i \\<bullet> 0\\<^sub>v nc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a +\n    row D (i - nr1) \\<bullet> 0\\<^sub>v nc2", "using scalar_prod_append[OF rows] a"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w1.0 \\<in> carrier_vec nc1; ?w2.0 \\<in> carrier_vec nc2\\<rbrakk>\n  \\<Longrightarrow> (row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v\n                     row D (i - nr1)) \\<bullet>\n                    (?w1.0 @\\<^sub>v ?w2.0) =\n                    row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> ?w1.0 +\n                    row D (i - nr1) \\<bullet> ?w2.0\n  a \\<in> carrier_vec nc1\n\ngoal (1 subgoal):\n 1. (row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a +\n    row D (i - nr1) \\<bullet> 0\\<^sub>v nc2", "by auto"], ["proof (state)\nthis:\n  (row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a +\n  row D (i - nr1) \\<bullet> 0\\<^sub>v nc2\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (row (0\\<^sub>m nr2 nc1) (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a +\n  row D (i - nr1) \\<bullet> 0\\<^sub>v nc2\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"row ?C ?i \\<bullet> a = 0\\<^sub>v nc1 \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a =\n    0\\<^sub>v nc1 \\<bullet> a", "using False A i"], ["proof (prove)\nusing this:\n  \\<not> i < nr1\n  A \\<in> carrier_mat nr1 nc1\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))\n\ngoal (1 subgoal):\n 1. row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a =\n    0\\<^sub>v nc1 \\<bullet> a", "by auto"], ["proof (state)\nthis:\n  row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a = 0\\<^sub>v nc1 \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row (0\\<^sub>m nr2 nc1) (i - nr1) \\<bullet> a = 0\\<^sub>v nc1 \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v nc1 \\<bullet> a = (0::'a)", "using a"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec nc1\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v nc1 \\<bullet> a = (0::'a)", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v nc1 \\<bullet> a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  0\\<^sub>v nc1 \\<bullet> a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "have \"row D ?i \\<bullet> 0\\<^sub>v nc2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row D (i - nr1) \\<bullet> 0\\<^sub>v nc2 = (0::'a)", "using False rows"], ["proof (prove)\nusing this:\n  \\<not> i < nr1\n  row (0\\<^sub>m nr2 nc1) (i - nr1) \\<in> carrier_vec nc1\n  row D (i - nr1) \\<in> carrier_vec nc2\n\ngoal (1 subgoal):\n 1. row D (i - nr1) \\<bullet> 0\\<^sub>v nc2 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  row D (i - nr1) \\<bullet> 0\\<^sub>v nc2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  (0::'a) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n    (a @\\<^sub>v 0\\<^sub>v nc2) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (four_block_mat A B (0\\<^sub>m nr2 nc1) D) i \\<bullet>\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A B (0\\<^sub>m nr2 nc1)\n                  D))) \\<Longrightarrow>\n       (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n        (a @\\<^sub>v 0\\<^sub>v nc2)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i\n 2. dim_vec\n     (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n      (a @\\<^sub>v 0\\<^sub>v nc2)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))", "finally"], ["proof (chain)\npicking this:\n  (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n   (a @\\<^sub>v 0\\<^sub>v nc2)) $\n  i =\n  (0::'a)", "show \"?l $ i = ?r $ i\""], ["proof (prove)\nusing this:\n  (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n   (a @\\<^sub>v 0\\<^sub>v nc2)) $\n  i =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n     (a @\\<^sub>v 0\\<^sub>v nc2)) $\n    i =\n    0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i", "using i"], ["proof (prove)\nusing this:\n  (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n   (a @\\<^sub>v 0\\<^sub>v nc2)) $\n  i =\n  (0::'a)\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))\n\ngoal (1 subgoal):\n 1. (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n     (a @\\<^sub>v 0\\<^sub>v nc2)) $\n    i =\n    0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i", "by auto"], ["proof (state)\nthis:\n  (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n   (a @\\<^sub>v 0\\<^sub>v nc2)) $\n  i =\n  0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)) $ i\n\ngoal (1 subgoal):\n 1. dim_vec\n     (four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n      (a @\\<^sub>v 0\\<^sub>v nc2)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D)))", "qed auto"], ["proof (state)\nthis:\n  four_block_mat A B (0\\<^sub>m nr2 nc1) D *\\<^sub>v\n  (a @\\<^sub>v 0\\<^sub>v nc2) =\n  0\\<^sub>v (dim_row (four_block_mat A B (0\\<^sub>m nr2 nc1) D))\n\ngoal (1 subgoal):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> carrier_vec (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D))", "show \"padr nc2 a : carrier_vec (dim_col ?ABCD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> carrier_vec (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D))", "using a A D"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec nc1\n  A \\<in> carrier_mat nr1 nc1\n  D \\<in> carrier_mat nr2 nc2\n\ngoal (1 subgoal):\n 1. a @\\<^sub>v 0\\<^sub>v nc2\n    \\<in> carrier_vec (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D))", "by auto"], ["proof (state)\nthis:\n  a @\\<^sub>v 0\\<^sub>v nc2\n  \\<in> carrier_vec (dim_col (four_block_mat A B (0\\<^sub>m nr2 nc1) D))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kernel_padl:\n  assumes dD: \"d \\<in> mat_kernel (D :: 'a :: field mat)\"\n      and A: \"A \\<in> carrier_mat nr1 nc1\"\n      and C: \"C \\<in> carrier_mat nr2 nc1\"\n      and D: \"D \\<in> carrier_mat nr2 nc2\"\n  shows \"padl nc1 d \\<in> mat_kernel (four_block_mat A (0\\<^sub>m nr1 nc2) C D)\" (is \"_ \\<in> mat_kernel ?ABCD\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> mat_kernel (four_block_mat A (0\\<^sub>m nr1 nc2) C D)", "unfolding mat_kernel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> {v \\<in> carrier_vec\n                    (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D)).\n           four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v v =\n           0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D))}", "proof (rule, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> carrier_vec (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D))\n 2. four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D))", "have [simp]: \"dim_row A = nr1\" \"dim_row D = nr2\" \"dim_row ?ABCD = nr1 + nr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = nr1 &&&\n    dim_row D = nr2 &&&\n    dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) = nr1 + nr2", "using A D"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr1 nc1\n  D \\<in> carrier_mat nr2 nc2\n\ngoal (1 subgoal):\n 1. dim_row A = nr1 &&&\n    dim_row D = nr2 &&&\n    dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) = nr1 + nr2", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr1\n  dim_row D = nr2\n  dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) = nr1 + nr2\n\ngoal (2 subgoals):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> carrier_vec (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D))\n 2. four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D))", "have d: \"d : carrier_vec nc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in> carrier_vec nc2", "using mat_kernel_carrier[OF D] dD"], ["proof (prove)\nusing this:\n  mat_kernel D \\<subseteq> carrier_vec nc2\n  d \\<in> mat_kernel D\n\ngoal (1 subgoal):\n 1. d \\<in> carrier_vec nc2", "by auto"], ["proof (state)\nthis:\n  d \\<in> carrier_vec nc2\n\ngoal (2 subgoals):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> carrier_vec (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D))\n 2. four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D))", "show \"?ABCD *\\<^sub>v padl nc1 d = 0\\<^sub>v (dim_row ?ABCD)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A (0\\<^sub>m nr1 nc2) C\n                  D))) \\<Longrightarrow>\n       (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n        (0\\<^sub>v nc1 @\\<^sub>v d)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i\n 2. dim_vec\n     (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n      (0\\<^sub>v nc1 @\\<^sub>v d)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A (0\\<^sub>m nr1 nc2) C\n                  D))) \\<Longrightarrow>\n       (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n        (0\\<^sub>v nc1 @\\<^sub>v d)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i\n 2. dim_vec\n     (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n      (0\\<^sub>v nc1 @\\<^sub>v d)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))", "assume i: \"i < dim_vec ?r\""], ["proof (state)\nthis:\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A (0\\<^sub>m nr1 nc2) C\n                  D))) \\<Longrightarrow>\n       (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n        (0\\<^sub>v nc1 @\\<^sub>v d)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i\n 2. dim_vec\n     (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n      (0\\<^sub>v nc1 @\\<^sub>v d)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))", "hence \"?l $ i = row ?ABCD i \\<bullet> padl nc1 d\""], ["proof (prove)\nusing this:\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n\ngoal (1 subgoal):\n 1. (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n     (0\\<^sub>v nc1 @\\<^sub>v d)) $\n    i =\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d)", "by auto"], ["proof (state)\nthis:\n  (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n   (0\\<^sub>v nc1 @\\<^sub>v d)) $\n  i =\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A (0\\<^sub>m nr1 nc2) C\n                  D))) \\<Longrightarrow>\n       (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n        (0\\<^sub>v nc1 @\\<^sub>v d)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i\n 2. dim_vec\n     (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n      (0\\<^sub>v nc1 @\\<^sub>v d)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))", "also"], ["proof (state)\nthis:\n  (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n   (0\\<^sub>v nc1 @\\<^sub>v d)) $\n  i =\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A (0\\<^sub>m nr1 nc2) C\n                  D))) \\<Longrightarrow>\n       (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n        (0\\<^sub>v nc1 @\\<^sub>v d)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i\n 2. dim_vec\n     (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n      (0\\<^sub>v nc1 @\\<^sub>v d)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "proof (cases \"i < nr1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  i < nr1\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "let ?B = \"0\\<^sub>m nr1 nc2\""], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have rows: \"row A i : carrier_vec nc1\" \"row ?B i : carrier_vec nc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<in> carrier_vec nc1 &&&\n    row (0\\<^sub>m nr1 nc2) i \\<in> carrier_vec nc2", "using A True"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr1 nc1\n  i < nr1\n\ngoal (1 subgoal):\n 1. row A i \\<in> carrier_vec nc1 &&&\n    row (0\\<^sub>m nr1 nc2) i \\<in> carrier_vec nc2", "by auto"], ["proof (state)\nthis:\n  row A i \\<in> carrier_vec nc1\n  row (0\\<^sub>m nr1 nc2) i \\<in> carrier_vec nc2\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"row ?ABCD i = row A i @\\<^sub>v row ?B i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n    row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i", "using row_four_block_mat(1)[OF A _ C D True]"], ["proof (prove)\nusing this:\n  ?B \\<in> carrier_mat nr1 nc2 \\<Longrightarrow>\n  row (four_block_mat A ?B C D) i = row A i @\\<^sub>v row ?B i\n\ngoal (1 subgoal):\n 1. row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n    row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i", "by auto"], ["proof (state)\nthis:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n  row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n  row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"... \\<bullet> padl nc1 d = row A i \\<bullet> 0\\<^sub>v nc1 + row ?B i \\<bullet> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i) \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    row A i \\<bullet> 0\\<^sub>v nc1 + row (0\\<^sub>m nr1 nc2) i \\<bullet> d", "using scalar_prod_append[OF rows] d"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w1.0 \\<in> carrier_vec nc1; ?w2.0 \\<in> carrier_vec nc2\\<rbrakk>\n  \\<Longrightarrow> (row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i) \\<bullet>\n                    (?w1.0 @\\<^sub>v ?w2.0) =\n                    row A i \\<bullet> ?w1.0 +\n                    row (0\\<^sub>m nr1 nc2) i \\<bullet> ?w2.0\n  d \\<in> carrier_vec nc2\n\ngoal (1 subgoal):\n 1. (row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i) \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    row A i \\<bullet> 0\\<^sub>v nc1 + row (0\\<^sub>m nr1 nc2) i \\<bullet> d", "by auto"], ["proof (state)\nthis:\n  (row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i) \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  row A i \\<bullet> 0\\<^sub>v nc1 + row (0\\<^sub>m nr1 nc2) i \\<bullet> d\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (row A i @\\<^sub>v row (0\\<^sub>m nr1 nc2) i) \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  row A i \\<bullet> 0\\<^sub>v nc1 + row (0\\<^sub>m nr1 nc2) i \\<bullet> d\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"row A i \\<bullet> 0\\<^sub>v nc1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> 0\\<^sub>v nc1 = (0::'a)", "using A True"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr1 nc1\n  i < nr1\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> 0\\<^sub>v nc1 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  row A i \\<bullet> 0\\<^sub>v nc1 = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row A i \\<bullet> 0\\<^sub>v nc1 = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"row ?B i \\<bullet> d = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (0\\<^sub>m nr1 nc2) i \\<bullet> d = (0::'a)", "using True d"], ["proof (prove)\nusing this:\n  i < nr1\n  d \\<in> carrier_vec nc2\n\ngoal (1 subgoal):\n 1. row (0\\<^sub>m nr1 nc2) i \\<bullet> d = (0::'a)", "by auto"], ["proof (state)\nthis:\n  row (0\\<^sub>m nr1 nc2) i \\<bullet> d = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)\n 2. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  (0::'a) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> i < nr1\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "let ?i = \"i - nr1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have rows:\n            \"row C ?i : carrier_vec nc1\" \"row D ?i : carrier_vec nc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row C (i - nr1) \\<in> carrier_vec nc1 &&&\n    row D (i - nr1) \\<in> carrier_vec nc2", "using C D i False A"], ["proof (prove)\nusing this:\n  C \\<in> carrier_mat nr2 nc1\n  D \\<in> carrier_mat nr2 nc2\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n  \\<not> i < nr1\n  A \\<in> carrier_mat nr1 nc1\n\ngoal (1 subgoal):\n 1. row C (i - nr1) \\<in> carrier_vec nc1 &&&\n    row D (i - nr1) \\<in> carrier_vec nc2", "by auto"], ["proof (state)\nthis:\n  row C (i - nr1) \\<in> carrier_vec nc1\n  row D (i - nr1) \\<in> carrier_vec nc2\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"row ?ABCD i = row C ?i @\\<^sub>v row D ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n    row C (i - nr1) @\\<^sub>v row D (i - nr1)", "using row_four_block_mat(2)[OF A _ C D False] i A D"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B \\<in> carrier_mat nr1 nc2; i < nr1 + nr2\\<rbrakk>\n  \\<Longrightarrow> row (four_block_mat A ?B C D) i =\n                    row C (i - nr1) @\\<^sub>v row D (i - nr1)\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n  A \\<in> carrier_mat nr1 nc1\n  D \\<in> carrier_mat nr2 nc2\n\ngoal (1 subgoal):\n 1. row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n    row C (i - nr1) @\\<^sub>v row D (i - nr1)", "by auto"], ["proof (state)\nthis:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n  row C (i - nr1) @\\<^sub>v row D (i - nr1)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i =\n  row C (i - nr1) @\\<^sub>v row D (i - nr1)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"... \\<bullet> padl nc1 d = row C ?i \\<bullet> 0\\<^sub>v nc1 + row D ?i \\<bullet> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row C (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 + row D (i - nr1) \\<bullet> d", "using scalar_prod_append[OF rows] d"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w1.0 \\<in> carrier_vec nc1; ?w2.0 \\<in> carrier_vec nc2\\<rbrakk>\n  \\<Longrightarrow> (row C (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n                    (?w1.0 @\\<^sub>v ?w2.0) =\n                    row C (i - nr1) \\<bullet> ?w1.0 +\n                    row D (i - nr1) \\<bullet> ?w2.0\n  d \\<in> carrier_vec nc2\n\ngoal (1 subgoal):\n 1. (row C (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 + row D (i - nr1) \\<bullet> d", "by auto"], ["proof (state)\nthis:\n  (row C (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 + row D (i - nr1) \\<bullet> d\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (row C (i - nr1) @\\<^sub>v row D (i - nr1)) \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 + row D (i - nr1) \\<bullet> d\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"row C ?i \\<bullet> 0\\<^sub>v nc1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 = (0::'a)", "using False A C i"], ["proof (prove)\nusing this:\n  \\<not> i < nr1\n  A \\<in> carrier_mat nr1 nc1\n  C \\<in> carrier_mat nr2 nc1\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n\ngoal (1 subgoal):\n 1. row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row C (i - nr1) \\<bullet> 0\\<^sub>v nc1 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"row D ?i \\<bullet> d = (D *\\<^sub>v d) $ ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row D (i - nr1) \\<bullet> d = (D *\\<^sub>v d) $ (i - nr1)", "using D d False i"], ["proof (prove)\nusing this:\n  D \\<in> carrier_mat nr2 nc2\n  d \\<in> carrier_vec nc2\n  \\<not> i < nr1\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n\ngoal (1 subgoal):\n 1. row D (i - nr1) \\<bullet> d = (D *\\<^sub>v d) $ (i - nr1)", "by auto"], ["proof (state)\nthis:\n  row D (i - nr1) \\<bullet> d = (D *\\<^sub>v d) $ (i - nr1)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  row D (i - nr1) \\<bullet> d = (D *\\<^sub>v d) $ (i - nr1)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D *\\<^sub>v d) $ (i - nr1) = (0::'a)", "using mat_kernelD[OF D dD]"], ["proof (prove)\nusing this:\n  d \\<in> carrier_vec nc2\n  D *\\<^sub>v d = 0\\<^sub>v nr2\n\ngoal (1 subgoal):\n 1. (D *\\<^sub>v d) $ (i - nr1) = (0::'a)", "using False i"], ["proof (prove)\nusing this:\n  d \\<in> carrier_vec nc2\n  D *\\<^sub>v d = 0\\<^sub>v nr2\n  \\<not> i < nr1\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n\ngoal (1 subgoal):\n 1. (D *\\<^sub>v d) $ (i - nr1) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (D *\\<^sub>v d) $ (i - nr1) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < nr1 \\<Longrightarrow>\n    row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  (0::'a) + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n    (0\\<^sub>v nc1 @\\<^sub>v d) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (four_block_mat A (0\\<^sub>m nr1 nc2) C D) i \\<bullet>\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (0\\<^sub>v\n              (dim_row\n                (four_block_mat A (0\\<^sub>m nr1 nc2) C\n                  D))) \\<Longrightarrow>\n       (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n        (0\\<^sub>v nc1 @\\<^sub>v d)) $\n       i =\n       0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i\n 2. dim_vec\n     (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n      (0\\<^sub>v nc1 @\\<^sub>v d)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))", "finally"], ["proof (chain)\npicking this:\n  (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n   (0\\<^sub>v nc1 @\\<^sub>v d)) $\n  i =\n  (0::'a)", "show \"?l $ i = ?r $ i\""], ["proof (prove)\nusing this:\n  (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n   (0\\<^sub>v nc1 @\\<^sub>v d)) $\n  i =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n     (0\\<^sub>v nc1 @\\<^sub>v d)) $\n    i =\n    0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i", "using i"], ["proof (prove)\nusing this:\n  (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n   (0\\<^sub>v nc1 @\\<^sub>v d)) $\n  i =\n  (0::'a)\n  i < dim_vec\n       (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))\n\ngoal (1 subgoal):\n 1. (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n     (0\\<^sub>v nc1 @\\<^sub>v d)) $\n    i =\n    0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i", "by auto"], ["proof (state)\nthis:\n  (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n   (0\\<^sub>v nc1 @\\<^sub>v d)) $\n  i =\n  0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)) $ i\n\ngoal (1 subgoal):\n 1. dim_vec\n     (four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n      (0\\<^sub>v nc1 @\\<^sub>v d)) =\n    dim_vec (0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D)))", "qed auto"], ["proof (state)\nthis:\n  four_block_mat A (0\\<^sub>m nr1 nc2) C D *\\<^sub>v\n  (0\\<^sub>v nc1 @\\<^sub>v d) =\n  0\\<^sub>v (dim_row (four_block_mat A (0\\<^sub>m nr1 nc2) C D))\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> carrier_vec (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D))", "show \"padl nc1 d : carrier_vec (dim_col ?ABCD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> carrier_vec (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D))", "using d A D"], ["proof (prove)\nusing this:\n  d \\<in> carrier_vec nc2\n  A \\<in> carrier_mat nr1 nc1\n  D \\<in> carrier_mat nr2 nc2\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v nc1 @\\<^sub>v d\n    \\<in> carrier_vec (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D))", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v nc1 @\\<^sub>v d\n  \\<in> carrier_vec (dim_col (four_block_mat A (0\\<^sub>m nr1 nc2) C D))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_kernel_split:\n  assumes A: \"A \\<in> carrier_mat n n\"\n      and D: \"D \\<in> carrier_mat m m\"\n      and kAD: \"k \\<in> mat_kernel (four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D)\"\n           (is \"_ \\<in> mat_kernel ?A00D\")\n  shows \"vec_first k n \\<in> mat_kernel A\" (is \"?a \\<in> _\")\n    and \"vec_last k m \\<in> mat_kernel D\" (is \"?d \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first k n \\<in> mat_kernel A &&& vec_last k m \\<in> mat_kernel D", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "have \"0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n + m)", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n + m)\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "also"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n + m)\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "have A00D: \"?A00D : carrier_mat (n+m) (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D\n    \\<in> carrier_mat (n + m) (n + m)", "using four_block_carrier_mat[OF A D]"], ["proof (prove)\nusing this:\n  four_block_mat A ?B ?C D \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D\n    \\<in> carrier_mat (n + m) (n + m)", "."], ["proof (state)\nthis:\n  four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D\n  \\<in> carrier_mat (n + m) (n + m)\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "hence k: \"k : carrier_vec (n+m)\""], ["proof (prove)\nusing this:\n  four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D\n  \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. k \\<in> carrier_vec (n + m)", "using kAD mat_kernel_carrier"], ["proof (prove)\nusing this:\n  four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D\n  \\<in> carrier_mat (n + m) (n + m)\n  k \\<in> mat_kernel (four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D)\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow>\n  mat_kernel ?A \\<subseteq> carrier_vec ?nc\n\ngoal (1 subgoal):\n 1. k \\<in> carrier_vec (n + m)", "by auto"], ["proof (state)\nthis:\n  k \\<in> carrier_vec (n + m)\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "hence \"?a @\\<^sub>v ?d = k\""], ["proof (prove)\nusing this:\n  k \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. vec_first k n @\\<^sub>v vec_last k m = k", "by simp"], ["proof (state)\nthis:\n  vec_first k n @\\<^sub>v vec_last k m = k\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "hence \"0\\<^sub>v (n+m) = ?A00D *\\<^sub>v (?a @\\<^sub>v ?d)\""], ["proof (prove)\nusing this:\n  vec_first k n @\\<^sub>v vec_last k m = k\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (n + m) =\n    four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v\n    (vec_first k n @\\<^sub>v vec_last k m)", "using mat_kernelD[OF A00D] kAD"], ["proof (prove)\nusing this:\n  vec_first k n @\\<^sub>v vec_last k m = k\n  ?v \\<in> mat_kernel\n            (four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n)\n              D) \\<Longrightarrow>\n  ?v \\<in> carrier_vec (n + m)\n  ?v \\<in> mat_kernel\n            (four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n)\n              D) \\<Longrightarrow>\n  four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v ?v =\n  0\\<^sub>v (n + m)\n  k \\<in> mat_kernel (four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (n + m) =\n    four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v\n    (vec_first k n @\\<^sub>v vec_last k m)", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v (n + m) =\n  four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v\n  (vec_first k n @\\<^sub>v vec_last k m)\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "also"], ["proof (state)\nthis:\n  0\\<^sub>v (n + m) =\n  four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v\n  (vec_first k n @\\<^sub>v vec_last k m)\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "have \"... = A *\\<^sub>v ?a @\\<^sub>v D *\\<^sub>v ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v\n    (vec_first k n @\\<^sub>v vec_last k m) =\n    A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m", "using mult_mat_vec_split[OF A D]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier_vec n; ?d \\<in> carrier_vec m\\<rbrakk>\n  \\<Longrightarrow> four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n)\n                     D *\\<^sub>v\n                    (?a @\\<^sub>v ?d) =\n                    A *\\<^sub>v ?a @\\<^sub>v D *\\<^sub>v ?d\n\ngoal (1 subgoal):\n 1. four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v\n    (vec_first k n @\\<^sub>v vec_last k m) =\n    A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m", "by auto"], ["proof (state)\nthis:\n  four_block_mat A (0\\<^sub>m n m) (0\\<^sub>m m n) D *\\<^sub>v\n  (vec_first k n @\\<^sub>v vec_last k m) =\n  A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "finally"], ["proof (chain)\npicking this:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m", "have \"0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = A *\\<^sub>v ?a @\\<^sub>v D *\\<^sub>v ?d\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m", "."], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "hence \"0\\<^sub>v n = A *\\<^sub>v ?a \\<and> 0\\<^sub>v m = D *\\<^sub>v ?d\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n = A *\\<^sub>v vec_first k n \\<and>\n    0\\<^sub>v m = D *\\<^sub>v vec_last k m", "apply(subst append_vec_eq[of _ n, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v\n    D *\\<^sub>v vec_last k m \\<Longrightarrow>\n    0\\<^sub>v n \\<in> carrier_vec n\n 2. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v\n    D *\\<^sub>v vec_last k m \\<Longrightarrow>\n    A *\\<^sub>v vec_first k n \\<in> carrier_vec n\n 3. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v\n    D *\\<^sub>v vec_last k m \\<Longrightarrow>\n    0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m", "using A D"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  D \\<in> carrier_mat m m\n\ngoal (3 subgoals):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v\n    D *\\<^sub>v vec_last k m \\<Longrightarrow>\n    0\\<^sub>v n \\<in> carrier_vec n\n 2. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v\n    D *\\<^sub>v vec_last k m \\<Longrightarrow>\n    A *\\<^sub>v vec_first k n \\<in> carrier_vec n\n 3. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v\n    D *\\<^sub>v vec_last k m \\<Longrightarrow>\n    0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    A *\\<^sub>v vec_first k n @\\<^sub>v D *\\<^sub>v vec_last k m", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n = A *\\<^sub>v vec_first k n \\<and>\n  0\\<^sub>v m = D *\\<^sub>v vec_last k m\n\ngoal (2 subgoals):\n 1. vec_first k n \\<in> mat_kernel A\n 2. vec_last k m \\<in> mat_kernel D", "thus \"?a : mat_kernel A\" \"?d : mat_kernel D\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n = A *\\<^sub>v vec_first k n \\<and>\n  0\\<^sub>v m = D *\\<^sub>v vec_last k m\n\ngoal (1 subgoal):\n 1. vec_first k n \\<in> mat_kernel A &&& vec_last k m \\<in> mat_kernel D", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  0\\<^sub>v n = A *\\<^sub>v vec_first k n \\<and>\n  0\\<^sub>v m = D *\\<^sub>v vec_last k m\n\ngoal (1 subgoal):\n 1. vec_first k n\n    \\<in> {v \\<in> carrier_vec (dim_col A).\n           A *\\<^sub>v v = 0\\<^sub>v (dim_row A)} &&&\n    vec_last k m\n    \\<in> {v \\<in> carrier_vec (dim_col D).\n           D *\\<^sub>v v = 0\\<^sub>v (dim_row D)}", "using A D"], ["proof (prove)\nusing this:\n  0\\<^sub>v n = A *\\<^sub>v vec_first k n \\<and>\n  0\\<^sub>v m = D *\\<^sub>v vec_last k m\n  A \\<in> carrier_mat n n\n  D \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. vec_first k n\n    \\<in> {v \\<in> carrier_vec (dim_col A).\n           A *\\<^sub>v v = 0\\<^sub>v (dim_row A)} &&&\n    vec_last k m\n    \\<in> {v \\<in> carrier_vec (dim_col D).\n           D *\\<^sub>v v = 0\\<^sub>v (dim_row D)}", "by auto"], ["proof (state)\nthis:\n  vec_first k n \\<in> mat_kernel A\n  vec_last k m \\<in> mat_kernel D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma padr_padl_eq:\n  assumes v: \"v : carrier_vec n\"\n  shows \"padr m v = padl n u \\<longleftrightarrow> v = 0\\<^sub>v n \\<and> u = 0\\<^sub>v m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v n @\\<^sub>v u) =\n    (v = 0\\<^sub>v n \\<and> u = 0\\<^sub>v m)", "apply (subst append_vec_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. v \\<in> carrier_vec ?n\n 2. 0\\<^sub>v n \\<in> carrier_vec ?n\n 3. (v = 0\\<^sub>v n \\<and> 0\\<^sub>v m = u) =\n    (v = 0\\<^sub>v n \\<and> u = 0\\<^sub>v m)", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. v \\<in> carrier_vec ?n\n 2. 0\\<^sub>v n \\<in> carrier_vec ?n\n 3. (v = 0\\<^sub>v n \\<and> 0\\<^sub>v m = u) =\n    (v = 0\\<^sub>v n \\<and> u = 0\\<^sub>v m)", "by auto"], ["", "lemma pad_disjoint:\n  assumes A: \"A \\<subseteq> carrier_vec n\" and A0: \"0\\<^sub>v n \\<notin> A\" and B: \"B \\<subseteq> carrier_vec m\"\n  shows \"padr m ` A \\<inter> padl n ` B = {}\" (is \"?A \\<inter> ?B = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n    (@\\<^sub>v) (0\\<^sub>v n) ` B =\n    {}", "proof (intro equals0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n               (@\\<^sub>v) (0\\<^sub>v n) ` B \\<Longrightarrow>\n       False", "fix ab"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n               (@\\<^sub>v) (0\\<^sub>v n) ` B \\<Longrightarrow>\n       False", "assume \"ab : ?A \\<inter> ?B\""], ["proof (state)\nthis:\n  ab \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n           (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n               (@\\<^sub>v) (0\\<^sub>v n) ` B \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  ab \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n           (@\\<^sub>v) (0\\<^sub>v n) ` B", "obtain a b\n    where \"ab = padr m a\" \"ab = padl n b\" and dim: \"a : A\" \"b : B\""], ["proof (prove)\nusing this:\n  ab \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n           (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>ab = a @\\<^sub>v 0\\<^sub>v m; ab = 0\\<^sub>v n @\\<^sub>v b;\n         a \\<in> A; b \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ab = a @\\<^sub>v 0\\<^sub>v m\n  ab = 0\\<^sub>v n @\\<^sub>v b\n  a \\<in> A\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n               (@\\<^sub>v) (0\\<^sub>v n) ` B \\<Longrightarrow>\n       False", "hence \"padr m a = padl n b\""], ["proof (prove)\nusing this:\n  ab = a @\\<^sub>v 0\\<^sub>v m\n  ab = 0\\<^sub>v n @\\<^sub>v b\n  a \\<in> A\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. a @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v n @\\<^sub>v b", "by auto"], ["proof (state)\nthis:\n  a @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v n @\\<^sub>v b\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n               (@\\<^sub>v) (0\\<^sub>v n) ` B \\<Longrightarrow>\n       False", "hence \"a = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  a @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v n @\\<^sub>v b\n\ngoal (1 subgoal):\n 1. a = 0\\<^sub>v n", "using dim A B"], ["proof (prove)\nusing this:\n  a @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v n @\\<^sub>v b\n  a \\<in> A\n  b \\<in> B\n  A \\<subseteq> carrier_vec n\n  B \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. a = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  a = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n               (@\\<^sub>v) (0\\<^sub>v n) ` B \\<Longrightarrow>\n       False", "thus \"False\""], ["proof (prove)\nusing this:\n  a = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "using dim A0"], ["proof (prove)\nusing this:\n  a = 0\\<^sub>v n\n  a \\<in> A\n  b \\<in> B\n  0\\<^sub>v n \\<notin> A\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma padr_padl_lindep:\n  assumes A: \"A \\<subseteq> carrier_vec n\" and liA: \"~ lin_dep n A\"\n      and B: \"B \\<subseteq> carrier_vec m\" and liB: \"~ lin_dep m B\"\n  shows \"~ lin_dep (n+m) (padr m ` A \\<union> padl n ` B)\" (is \"~ lin_dep _ (?A \\<union> ?B)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep class_ring (M (n + m))\n            ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n             (@\\<^sub>v) (0\\<^sub>v n) ` B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep class_ring (M (n + m))\n            ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n             (@\\<^sub>v) (0\\<^sub>v n) ` B)", "interpret N: vectorspace class_ring \"M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M n)", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M n)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep class_ring (M (n + m))\n            ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n             (@\\<^sub>v) (0\\<^sub>v n) ` B)", "interpret M: vectorspace class_ring \"M m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M m)", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M m)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep class_ring (M (n + m))\n            ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n             (@\\<^sub>v) (0\\<^sub>v n) ` B)", "interpret NM: vectorspace class_ring \"M (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. NM.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` B)", "note [simp] = module_vec_simps class_ring_simps"], ["proof (state)\nthis:\n  (\\<oplus>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (+)\n  \\<zero>\\<^bsub>module_vec ?ty ?n\\<^esub> = 0\\<^sub>v ?n\n  carrier (module_vec ?ty ?n) = carrier_vec ?n\n  (\\<odot>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (\\<cdot>\\<^sub>v)\n  carrier class_ring = UNIV\n  (\\<otimes>\\<^bsub>class_ring\\<^esub>) = (*)\n  (\\<oplus>\\<^bsub>class_ring\\<^esub>) = (+)\n  \\<one>\\<^bsub>class_ring\\<^esub> = (1::?'e)\n  \\<zero>\\<^bsub>class_ring\\<^esub> = (0::?'f)\n  ([^]\\<^bsub>class_ring\\<^esub>) = (^)\n  finsum class_ring = sum\n  a_inv class_ring = uminus\n  a_minus class_ring = (-)\n  finprod class_ring = prod\n  inv\\<^bsub>class_ring\\<^esub> ?x =\n  (if ?x = (0::?'a) then div0 else inverse ?x)\n  class_field \\<equiv> class_ring\n\ngoal (1 subgoal):\n 1. NM.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` B)", "have AB: \"?A \\<union> ?B \\<subseteq> carrier_vec (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` B\n    \\<subseteq> carrier_vec (n + m)", "using padr_image[OF A] padl_image[OF B]"], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` A\n  \\<subseteq> carrier_vec (n + ?m)\n  (@\\<^sub>v) (0\\<^sub>v ?m) ` B \\<subseteq> carrier_vec (?m + m)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` B\n    \\<subseteq> carrier_vec (n + m)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` B\n  \\<subseteq> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. NM.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` B)", "unfolding NM.lin_dep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Aa a v.\n       finite Aa \\<and>\n       Aa \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B \\<and>\n       a \\<in> Aa \\<rightarrow> carrier class_ring \\<and>\n       NM.lincomb a Aa = \\<zero>\\<^bsub>M (n + m)\\<^esub> \\<and>\n       v \\<in> Aa \\<and> a v \\<noteq> \\<zero>\\<^bsub>class_ring\\<^esub>", "unfolding not_ex not_imp[symmetric] not_not"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa xb.\n       finite x \\<longrightarrow>\n       x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                     (@\\<^sub>v) (0\\<^sub>v n) ` B \\<longrightarrow>\n       xa \\<in> x \\<rightarrow> carrier class_ring \\<longrightarrow>\n       NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub> \\<longrightarrow>\n       xb \\<in> x \\<longrightarrow>\n       xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "proof(intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "fix U f u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "assume finU: \"finite U\"\n       and UAB: \"U \\<subseteq> ?A \\<union> ?B\"\n       and f: \"f : U \\<rightarrow> carrier class_ring\"\n       and 0: \"lincomb (n+m) f U = \\<zero>\\<^bsub>M (n+m)\\<^esub>\"\n       and uU: \"u : U\""], ["proof (state)\nthis:\n  finite U\n  U \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                (@\\<^sub>v) (0\\<^sub>v n) ` B\n  f \\<in> U \\<rightarrow> carrier class_ring\n  NM.lincomb f U = \\<zero>\\<^bsub>M (n + m)\\<^esub>\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "let ?UA = \"U \\<inter> ?A\" and ?UB = \"U \\<inter> ?B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"?UA \\<subseteq> ?A\" \"?UB \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n    \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A &&&\n    U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B\n    \\<subseteq> (@\\<^sub>v) (0\\<^sub>v n) ` B", "by auto"], ["proof (state)\nthis:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n  \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B\n  \\<subseteq> (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "then"], ["proof (chain)\npicking this:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n  \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B\n  \\<subseteq> (@\\<^sub>v) (0\\<^sub>v n) ` B", "obtain A' B'\n      where A'A: \"A' \\<subseteq> A\" and B'B: \"B' \\<subseteq> B\"\n        and UAA': \"?UA = padr m ` A'\" and UBB': \"?UB = padl n ` B'\""], ["proof (prove)\nusing this:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n  \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B\n  \\<subseteq> (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        \\<lbrakk>A' \\<subseteq> A; B' \\<subseteq> B;\n         U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n         (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A';\n         U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B =\n         (@\\<^sub>v) (0\\<^sub>v n) ` B'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subset_image_iff"], ["proof (prove)\nusing this:\n  \\<exists>AA\\<subseteq>A.\n     U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n     (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` AA\n  \\<exists>AA\\<subseteq>B.\n     U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B =\n     (@\\<^sub>v) (0\\<^sub>v n) ` AA\n\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        \\<lbrakk>A' \\<subseteq> A; B' \\<subseteq> B;\n         U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n         (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A';\n         U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B =\n         (@\\<^sub>v) (0\\<^sub>v n) ` B'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A' \\<subseteq> A\n  B' \\<subseteq> B\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B = (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence A': \"A' \\<subseteq> carrier_vec n\" and B': \"B' \\<subseteq> carrier_vec m\""], ["proof (prove)\nusing this:\n  A' \\<subseteq> A\n  B' \\<subseteq> B\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B = (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. A' \\<subseteq> carrier_vec n &&& B' \\<subseteq> carrier_vec m", "using A B"], ["proof (prove)\nusing this:\n  A' \\<subseteq> A\n  B' \\<subseteq> B\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B = (@\\<^sub>v) (0\\<^sub>v n) ` B'\n  A \\<subseteq> carrier_vec n\n  B \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. A' \\<subseteq> carrier_vec n &&& B' \\<subseteq> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  A' \\<subseteq> carrier_vec n\n  B' \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "have finA': \"finite A'\" and finB': \"finite B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A' &&& finite B'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A'\n 2. finite B'", "have \"padr m ` A' \\<subseteq> U\" \"padl n ` B' \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<subseteq> U &&&\n    (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<subseteq> U", "using UAA' UBB'"], ["proof (prove)\nusing this:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B = (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<subseteq> U &&&\n    (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<subseteq> U", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<subseteq> U\n  (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<subseteq> U\n\ngoal (2 subgoals):\n 1. finite A'\n 2. finite B'", "hence pre: \"finite (padr m ` A')\" \"finite (padl n ` B')\""], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<subseteq> U\n  (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<subseteq> U\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A') &&&\n    finite ((@\\<^sub>v) (0\\<^sub>v n) ` B')", "using finite_subset[OF _ finU]"], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<subseteq> U\n  (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<subseteq> U\n  ?A \\<subseteq> U \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A') &&&\n    finite ((@\\<^sub>v) (0\\<^sub>v n) ` B')", "by auto"], ["proof (state)\nthis:\n  finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A')\n  finite ((@\\<^sub>v) (0\\<^sub>v n) ` B')\n\ngoal (2 subgoals):\n 1. finite A'\n 2. finite B'", "show \"finite A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A'", "apply (rule finite_imageD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (?f ` A')\n 2. inj_on ?f A'", "using subset_inj_on[OF padr_inj A'] pre"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m1) A'\n  finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A')\n  finite ((@\\<^sub>v) (0\\<^sub>v n) ` B')\n\ngoal (2 subgoals):\n 1. finite (?f ` A')\n 2. inj_on ?f A'", "by auto"], ["proof (state)\nthis:\n  finite A'\n\ngoal (1 subgoal):\n 1. finite B'", "show \"finite B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B'", "apply (rule finite_imageD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (?f ` B')\n 2. inj_on ?f B'", "using subset_inj_on[OF padl_inj B'] pre"], ["proof (prove)\nusing this:\n  inj_on ((@\\<^sub>v) (0\\<^sub>v ?m1)) B'\n  finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A')\n  finite ((@\\<^sub>v) (0\\<^sub>v n) ` B')\n\ngoal (2 subgoals):\n 1. finite (?f ` B')\n 2. inj_on ?f B'", "by auto"], ["proof (state)\nthis:\n  finite B'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite A'\n  finite B'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"0\\<^sub>v n \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> A", "using N.zero_nin_lin_indpt[OF _ liA] A class_semiring.one_zeroI"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<subseteq> carrier (M n);\n   carrier class_ring \\<noteq> {\\<zero>\\<^bsub>class_ring\\<^esub>}\\<rbrakk>\n  \\<Longrightarrow> \\<zero>\\<^bsub>M n\\<^esub> \\<notin> A\n  A \\<subseteq> carrier_vec n\n  UNIV = {0::?'a} \\<Longrightarrow> (1::?'a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> A", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence \"?A \\<inter> ?B = {}\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n \\<notin> A\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n    (@\\<^sub>v) (0\\<^sub>v n) ` B =\n    {}", "using pad_disjoint A B"], ["proof (prove)\nusing this:\n  0\\<^sub>v n \\<notin> A\n  \\<lbrakk>?A \\<subseteq> carrier_vec ?n; 0\\<^sub>v ?n \\<notin> ?A;\n   ?B \\<subseteq> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` ?A \\<inter>\n                    (@\\<^sub>v) (0\\<^sub>v ?n) ` ?B =\n                    {}\n  A \\<subseteq> carrier_vec n\n  B \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n    (@\\<^sub>v) (0\\<^sub>v n) ` B =\n    {}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n  (@\\<^sub>v) (0\\<^sub>v n) ` B =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence disj: \"?UA \\<inter> ?UB = {}\""], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n  (@\\<^sub>v) (0\\<^sub>v n) ` B =\n  {}\n\ngoal (1 subgoal):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n    (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    {}", "by auto"], ["proof (state)\nthis:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n  (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "have split: \"U = padr m ` A' \\<union> padl n ` B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U =\n    (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` B'", "unfolding UAA'[symmetric] UBB'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. U =\n    U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B", "using UAB"], ["proof (prove)\nusing this:\n  U \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. U =\n    U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B", "by auto"], ["proof (state)\nthis:\n  U =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>finite x;\n        x \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                      (@\\<^sub>v) (0\\<^sub>v n) ` B;\n        xa \\<in> x \\<rightarrow> carrier class_ring;\n        NM.lincomb xa x = \\<zero>\\<^bsub>M (n + m)\\<^esub>;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa xb = \\<zero>\\<^bsub>class_ring\\<^esub>", "show \"f u = \\<zero>\\<^bsub>(class_ring::'a ring)\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "let ?a = \"f \\<circ> padr m\""], ["proof (state)\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "let ?b = \"f \\<circ> padl n\""], ["proof (state)\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have lcA': \"lincomb n ?a A' : carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n    \\<in> carrier_vec n", "using N.lincomb_closed A'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> carrier (M n);\n   ?a \\<in> ?S \\<rightarrow> carrier class_ring\\<rbrakk>\n  \\<Longrightarrow> N.lincomb ?a ?S \\<in> carrier (M n)\n  A' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n    \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have lcB': \"lincomb m ?b B' : carrier_vec m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec m", "using M.lincomb_closed B'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> carrier (M m);\n   ?a \\<in> ?S \\<rightarrow> carrier class_ring\\<rbrakk>\n  \\<Longrightarrow> M.lincomb ?a ?S \\<in> carrier (M m)\n  B' \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n + m)", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n + m)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (n + m)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"... = lincomb (n+m) f U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v (n + m) = NM.lincomb f U", "using 0"], ["proof (prove)\nusing this:\n  NM.lincomb f U = \\<zero>\\<^bsub>M (n + m)\\<^esub>\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (n + m) = NM.lincomb f U", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v (n + m) = NM.lincomb f U\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  0\\<^sub>v (n + m) = NM.lincomb f U\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"U = ?UA \\<union> ?UB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U =\n    U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B", "using UAB"], ["proof (prove)\nusing this:\n  U \\<subseteq> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n                (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. U =\n    U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B", "by auto"], ["proof (state)\nthis:\n  U =\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  U =\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"lincomb (n+m) f ... = lincomb (n+m) f ?UA + lincomb (n+m) f ?UB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb f\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n      U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) +\n    NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "apply(subst NM.lincomb_union)"], ["proof (prove)\ngoal (7 subgoals):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n    \\<subseteq> carrier (M (n + m))\n 2. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<subseteq> carrier (M (n + m))\n 3. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n    (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    {}\n 4. finite (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 5. finite (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n 6. f \\<in> U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n            U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<rightarrow>\n            carrier class_ring\n 7. NM.lincomb f\n     (U \\<inter>\n      (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n      A) \\<oplus>\\<^bsub>M (n + m)\\<^esub>\n    NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) +\n    NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "using A B finU disj"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier_vec n\n  B \\<subseteq> carrier_vec m\n  finite U\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n  (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  {}\n\ngoal (7 subgoals):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n    \\<subseteq> carrier (M (n + m))\n 2. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<subseteq> carrier (M (n + m))\n 3. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<inter>\n    (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    {}\n 4. finite (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 5. finite (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n 6. f \\<in> U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n            U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<rightarrow>\n            carrier class_ring\n 7. NM.lincomb f\n     (U \\<inter>\n      (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n      A) \\<oplus>\\<^bsub>M (n + m)\\<^esub>\n    NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) +\n    NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "by auto"], ["proof (state)\nthis:\n  NM.lincomb f\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) +\n  NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  NM.lincomb f\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) +\n  NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"lincomb (n+m) f ?UA = lincomb (n+m) (restrict f ?UA) ?UA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    NM.lincomb\n     (restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)", "apply (subst NM.lincomb_restrict)"], ["proof (prove)\ngoal (4 subgoals):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n    \\<subseteq> carrier (M (n + m))\n 2. f \\<in> U \\<inter>\n            (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<rightarrow>\n            carrier class_ring\n 3. restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    restrict ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 4. NM.lincomb ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    NM.lincomb\n     (restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)", "using A finU"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier_vec n\n  finite U\n\ngoal (4 subgoals):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n    \\<subseteq> carrier (M (n + m))\n 2. f \\<in> U \\<inter>\n            (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<rightarrow>\n            carrier class_ring\n 3. restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    restrict ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 4. NM.lincomb ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    NM.lincomb\n     (restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)", "by auto"], ["proof (state)\nthis:\n  NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n  NM.lincomb\n   (restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  NM.lincomb f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n  NM.lincomb\n   (restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"restrict f ?UA = restrict (?a \\<circ> unpadr m) ?UA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    restrict\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)", "apply(rule restrict_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<inter>\n               (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<Longrightarrow>\n       f x =\n       (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m) x", "by auto"], ["proof (state)\nthis:\n  restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n  restrict\n   (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  restrict f (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n  restrict\n   (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"lincomb (n+m) ... ?UA = lincomb (n+m) (?a \\<circ> unpadr m) ?UA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb\n     (restrict\n       (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n       (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    NM.lincomb\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)", "apply(subst NM.lincomb_restrict)"], ["proof (prove)\ngoal (4 subgoals):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n    \\<subseteq> carrier (M (n + m))\n 2. restrict\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n    \\<in> U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<rightarrow>\n          carrier class_ring\n 3. restrict\n     (restrict\n       (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n       (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    restrict ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 4. NM.lincomb ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    NM.lincomb\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)", "using A finU"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier_vec n\n  finite U\n\ngoal (4 subgoals):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A\n    \\<subseteq> carrier (M (n + m))\n 2. restrict\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n    \\<in> U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<rightarrow>\n          carrier class_ring\n 3. restrict\n     (restrict\n       (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n       (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    restrict ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n 4. NM.lincomb ?b (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n    NM.lincomb\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)", "by auto"], ["proof (state)\nthis:\n  NM.lincomb\n   (restrict\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n  NM.lincomb\n   (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  NM.lincomb\n   (restrict\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A))\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A) =\n  NM.lincomb\n   (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n   (U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"?UA = padr m ` A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n    (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'", "using UAA'"], ["proof (prove)\nusing this:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'\n\ngoal (1 subgoal):\n 1. U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n    (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'", "."], ["proof (state)\nthis:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  U \\<inter> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"lincomb (n+m) (?a \\<circ> unpadr m) ... =\n        padr m (lincomb n ?a A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A') =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    0\\<^sub>v m", "using lincomb_pad(1)[OF A' finA',symmetric]"], ["proof (prove)\nusing this:\n  lincomb (n + ?m) (?a \\<circ> unpadr ?m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` A') =\n  N.lincomb ?a A' @\\<^sub>v 0\\<^sub>v ?m\n\ngoal (1 subgoal):\n 1. NM.lincomb\n     (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A') =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    0\\<^sub>v m", "."], ["proof (state)\nthis:\n  NM.lincomb\n   (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A') =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  NM.lincomb\n   (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) \\<circ> unpadr m)\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A') =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"lincomb (n+m) f ?UB = lincomb (n+m) (restrict f ?UB) ?UB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb (restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "apply (subst NM.lincomb_restrict)"], ["proof (prove)\ngoal (4 subgoals):\n 1. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<subseteq> carrier (M (n + m))\n 2. f \\<in> U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<rightarrow>\n            carrier class_ring\n 3. restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    restrict ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n 4. NM.lincomb ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb (restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "using B finU"], ["proof (prove)\nusing this:\n  B \\<subseteq> carrier_vec m\n  finite U\n\ngoal (4 subgoals):\n 1. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<subseteq> carrier (M (n + m))\n 2. f \\<in> U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<rightarrow>\n            carrier class_ring\n 3. restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    restrict ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n 4. NM.lincomb ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb (restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "by auto"], ["proof (state)\nthis:\n  NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  NM.lincomb (restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  NM.lincomb f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  NM.lincomb (restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"restrict f ?UB = restrict (?b \\<circ> unpadl n) ?UB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "apply(rule restrict_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<Longrightarrow>\n       f x = (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n) x", "by auto"], ["proof (state)\nthis:\n  restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  restrict f (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"lincomb (n+m) ... ?UB = lincomb (n+m) (?b \\<circ> unpadl n) ?UB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NM.lincomb\n     (restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n       (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "apply(subst NM.lincomb_restrict)"], ["proof (prove)\ngoal (4 subgoals):\n 1. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<subseteq> carrier (M (n + m))\n 2. restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n    \\<in> U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<rightarrow>\n          carrier class_ring\n 3. restrict\n     (restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n       (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    restrict ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n 4. NM.lincomb ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "using B finU"], ["proof (prove)\nusing this:\n  B \\<subseteq> carrier_vec m\n  finite U\n\ngoal (4 subgoals):\n 1. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<subseteq> carrier (M (n + m))\n 2. restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n    \\<in> U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B \\<rightarrow>\n          carrier class_ring\n 3. restrict\n     (restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n       (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    restrict ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n 4. NM.lincomb ?b (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n    NM.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)", "by auto"], ["proof (state)\nthis:\n  NM.lincomb\n   (restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  NM.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  NM.lincomb\n   (restrict (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B))\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B) =\n  NM.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n   (U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"n+m = m+n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m = m + n", "by auto"], ["proof (state)\nthis:\n  n + m = m + n\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  n + m = m + n\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"?UB = padl n ` B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B =\n    (@\\<^sub>v) (0\\<^sub>v n) ` B'", "using UBB'"], ["proof (prove)\nusing this:\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B = (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B =\n    (@\\<^sub>v) (0\\<^sub>v n) ` B'", "."], ["proof (state)\nthis:\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B = (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  U \\<inter> (@\\<^sub>v) (0\\<^sub>v n) ` B = (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"lincomb (m+n) (?b \\<circ> unpadl n) ... =\n        padl n (lincomb m ?b B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (m + n) (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     ((@\\<^sub>v) (0\\<^sub>v n) ` B') =\n    0\\<^sub>v n @\\<^sub>v M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "using lincomb_pad(2)[OF B' finB',symmetric]"], ["proof (prove)\nusing this:\n  lincomb (m + ?m) (?a \\<circ> unpadl ?m)\n   ((@\\<^sub>v) (0\\<^sub>v ?m) ` B') =\n  0\\<^sub>v ?m @\\<^sub>v M.lincomb ?a B'\n\ngoal (1 subgoal):\n 1. lincomb (m + n) (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n     ((@\\<^sub>v) (0\\<^sub>v n) ` B') =\n    0\\<^sub>v n @\\<^sub>v M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "."], ["proof (state)\nthis:\n  lincomb (m + n) (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n   ((@\\<^sub>v) (0\\<^sub>v n) ` B') =\n  0\\<^sub>v n @\\<^sub>v M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  lincomb (m + n) (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<circ> unpadl n)\n   ((@\\<^sub>v) (0\\<^sub>v n) ` B') =\n  0\\<^sub>v n @\\<^sub>v M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"padr m (lincomb n ?a A') + ... =\n          (lincomb n ?a A' + 0\\<^sub>v n) @\\<^sub>v (0\\<^sub>v m + lincomb m ?b B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    0\\<^sub>v m +\n    (0\\<^sub>v n @\\<^sub>v\n     M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B') =\n    (N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' +\n     0\\<^sub>v n) @\\<^sub>v\n    0\\<^sub>v m + M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "apply (rule append_vec_add)"], ["proof (prove)\ngoal (4 subgoals):\n 1. N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n    \\<in> carrier_vec ?n\n 2. 0\\<^sub>v n \\<in> carrier_vec ?n\n 3. 0\\<^sub>v m \\<in> carrier_vec ?m\n 4. M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec ?m", "using lcA' lcB'"], ["proof (prove)\nusing this:\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  \\<in> carrier_vec n\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec m\n\ngoal (4 subgoals):\n 1. N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n    \\<in> carrier_vec ?n\n 2. 0\\<^sub>v n \\<in> carrier_vec ?n\n 3. 0\\<^sub>v m \\<in> carrier_vec ?m\n 4. M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec ?m", "by auto"], ["proof (state)\nthis:\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  0\\<^sub>v m +\n  (0\\<^sub>v n @\\<^sub>v\n   M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B') =\n  (N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' +\n   0\\<^sub>v n) @\\<^sub>v\n  0\\<^sub>v m + M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "also"], ["proof (state)\nthis:\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  0\\<^sub>v m +\n  (0\\<^sub>v n @\\<^sub>v\n   M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B') =\n  (N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' +\n   0\\<^sub>v n) @\\<^sub>v\n  0\\<^sub>v m + M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "have \"... = lincomb n ?a A' @\\<^sub>v lincomb m ?b B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' +\n     0\\<^sub>v n) @\\<^sub>v\n    0\\<^sub>v m + M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "using lcA' lcB'"], ["proof (prove)\nusing this:\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  \\<in> carrier_vec n\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. (N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' +\n     0\\<^sub>v n) @\\<^sub>v\n    0\\<^sub>v m + M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "by auto"], ["proof (state)\nthis:\n  (N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' +\n   0\\<^sub>v n) @\\<^sub>v\n  0\\<^sub>v m + M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "have \"0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m = lincomb n ?a A' @\\<^sub>v lincomb m ?b B'\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "."], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence \"0\\<^sub>v n = lincomb n ?a A' \\<and> 0\\<^sub>v m = lincomb m ?b B'\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' \\<and>\n    0\\<^sub>v m = M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "apply(subst append_vec_eq[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<Longrightarrow>\n    0\\<^sub>v n \\<in> carrier_vec ?n1\n 2. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<Longrightarrow>\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n    \\<in> carrier_vec ?n1\n 3. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<Longrightarrow>\n    0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "using lcA' lcB'"], ["proof (prove)\nusing this:\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  \\<in> carrier_vec n\n  M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<in> carrier_vec m\n\ngoal (3 subgoals):\n 1. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<Longrightarrow>\n    0\\<^sub>v n \\<in> carrier_vec ?n1\n 2. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<Longrightarrow>\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n    \\<in> carrier_vec ?n1\n 3. 0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B' \\<Longrightarrow>\n    0\\<^sub>v n @\\<^sub>v 0\\<^sub>v m =\n    N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' @\\<^sub>v\n    M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A' \\<and>\n  0\\<^sub>v m = M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "from conjunct1[OF this] conjunct2[OF this]"], ["proof (chain)\npicking this:\n  0\\<^sub>v n =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  0\\<^sub>v m = M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'", "have \"?a : A' \\<rightarrow> {0}\" \"?b : B' \\<rightarrow> {0}\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  0\\<^sub>v m = M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n\ngoal (1 subgoal):\n 1. f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)\n    \\<in> A' \\<rightarrow> {0::'a} &&&\n    f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<in> B' \\<rightarrow> {0::'a}", "using N.not_lindepD[OF liA finA' A'A]"], ["proof (prove)\nusing this:\n  0\\<^sub>v n =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  0\\<^sub>v m = M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n  \\<lbrakk>?f \\<in> A' \\<rightarrow> carrier class_ring;\n   N.lincomb ?f A' = \\<zero>\\<^bsub>M n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> A' \\<rightarrow>\n                             {\\<zero>\\<^bsub>class_ring\\<^esub>}\n\ngoal (1 subgoal):\n 1. f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)\n    \\<in> A' \\<rightarrow> {0::'a} &&&\n    f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<in> B' \\<rightarrow> {0::'a}", "using M.not_lindepD[OF liB finB' B'B]"], ["proof (prove)\nusing this:\n  0\\<^sub>v n =\n  N.lincomb (f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)) A'\n  0\\<^sub>v m = M.lincomb (f \\<circ> (@\\<^sub>v) (0\\<^sub>v n)) B'\n  \\<lbrakk>?f \\<in> A' \\<rightarrow> carrier class_ring;\n   N.lincomb ?f A' = \\<zero>\\<^bsub>M n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> A' \\<rightarrow>\n                             {\\<zero>\\<^bsub>class_ring\\<^esub>}\n  \\<lbrakk>?f \\<in> B' \\<rightarrow> carrier class_ring;\n   M.lincomb ?f B' = \\<zero>\\<^bsub>M m\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> B' \\<rightarrow>\n                             {\\<zero>\\<^bsub>class_ring\\<^esub>}\n\ngoal (1 subgoal):\n 1. f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)\n    \\<in> A' \\<rightarrow> {0::'a} &&&\n    f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<in> B' \\<rightarrow> {0::'a}", "by auto"], ["proof (state)\nthis:\n  f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)\n  \\<in> A' \\<rightarrow> {0::'a}\n  f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<in> B' \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence \"f : padr m ` A' \\<rightarrow> {0}\" \"f : padl n ` B' \\<rightarrow> {0}\""], ["proof (prove)\nusing this:\n  f \\<circ> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m)\n  \\<in> A' \\<rightarrow> {0::'a}\n  f \\<circ> (@\\<^sub>v) (0\\<^sub>v n) \\<in> B' \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. f \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<rightarrow>\n            {0::'a} &&&\n    f \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<rightarrow> {0::'a}", "by auto"], ["proof (state)\nthis:\n  f \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<rightarrow> {0::'a}\n  f \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence \"f : padr m ` A' \\<union> padl n ` B' \\<rightarrow> {0}\""], ["proof (prove)\nusing this:\n  f \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<rightarrow> {0::'a}\n  f \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. f \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<union>\n            (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<rightarrow>\n            {0::'a}", "by auto"], ["proof (state)\nthis:\n  f \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<rightarrow>\n          {0::'a}\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence \"f : U \\<rightarrow> {0}\""], ["proof (prove)\nusing this:\n  f \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<rightarrow>\n          {0::'a}\n\ngoal (1 subgoal):\n 1. f \\<in> U \\<rightarrow> {0::'a}", "using split"], ["proof (prove)\nusing this:\n  f \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` B' \\<rightarrow>\n          {0::'a}\n  U =\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A' \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` B'\n\ngoal (1 subgoal):\n 1. f \\<in> U \\<rightarrow> {0::'a}", "by auto"], ["proof (state)\nthis:\n  f \\<in> U \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "hence \"f u = 0\""], ["proof (prove)\nusing this:\n  f \\<in> U \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. f u = (0::'a)", "using uU"], ["proof (prove)\nusing this:\n  f \\<in> U \\<rightarrow> {0::'a}\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. f u = (0::'a)", "by auto"], ["proof (state)\nthis:\n  f u = (0::'a)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "thus ?thesis"], ["proof (prove)\nusing this:\n  f u = (0::'a)\n\ngoal (1 subgoal):\n 1. f u = \\<zero>\\<^bsub>class_ring\\<^esub>", "by simp"], ["proof (state)\nthis:\n  f u = \\<zero>\\<^bsub>class_ring\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f u = \\<zero>\\<^bsub>class_ring\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NM.lin_indpt\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` A \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` B)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma kernel_four_block_0_mat:\n  assumes Adef: \"(A :: 'a::field mat) = four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and D: \"D \\<in> carrier_mat m m\"\n  shows \"kernel.dim (n + m) A = kernel.dim n B + kernel.dim m D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (n + m)\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>) +\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) m\\<lparr>carrier := mat_kernel D\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (n + m)\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>) +\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) m\\<lparr>carrier := mat_kernel D\\<rparr>)", "have [simp]: \"n + m = m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m = m + n", "by auto"], ["proof (state)\nthis:\n  n + m = m + n\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (n + m)\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>) +\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) m\\<lparr>carrier := mat_kernel D\\<rparr>)", "have A: \"A \\<in> carrier_mat (n+m) (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (n + m) (n + m)", "using Adef four_block_carrier_mat[OF B D]"], ["proof (prove)\nusing this:\n  A = four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D\n  four_block_mat B ?B ?C D \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (n + m) (n + m)", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (n + m)\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>) +\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) m\\<lparr>carrier := mat_kernel D\\<rparr>)", "interpret vardim \"TYPE('a)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (M (n + m)\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (M n\\<lparr>carrier := mat_kernel B\\<rparr>) +\n    vectorspace.dim class_ring (M m\\<lparr>carrier := mat_kernel D\\<rparr>)", "interpret MN: vectorspace class_ring \"M (n+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "using vec_vs"], ["proof (prove)\nusing this:\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n\ngoal (1 subgoal):\n 1. vectorspace class_ring (M (n + m))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring (MN.vs (mat_kernel A)) =\n    vectorspace.dim class_ring\n     (M n\\<lparr>carrier := mat_kernel B\\<rparr>) +\n    vectorspace.dim class_ring (M m\\<lparr>carrier := mat_kernel D\\<rparr>)", "interpret KA: kernel \"n+m\" \"n+m\" A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel (n + m) (n + m) A", "by (unfold_locales, rule A)"], ["proof (state)\ngoal (1 subgoal):\n 1. KA.dim =\n    vectorspace.dim class_ring\n     (M n\\<lparr>carrier := mat_kernel B\\<rparr>) +\n    vectorspace.dim class_ring (M m\\<lparr>carrier := mat_kernel D\\<rparr>)", "interpret KB: kernel n n B"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel n n B", "by (unfold_locales, rule B)"], ["proof (state)\ngoal (1 subgoal):\n 1. KA.dim =\n    KB.dim +\n    vectorspace.dim class_ring (M m\\<lparr>carrier := mat_kernel D\\<rparr>)", "interpret KD: kernel m m D"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel m m D", "by (unfold_locales, rule D)"], ["proof (state)\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "note [simp] = module_vec_simps"], ["proof (state)\nthis:\n  (\\<oplus>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (+)\n  \\<zero>\\<^bsub>module_vec ?ty ?n\\<^esub> = 0\\<^sub>v ?n\n  carrier (module_vec ?ty ?n) = carrier_vec ?n\n  (\\<odot>\\<^bsub>module_vec ?ty ?n\\<^esub>) = (\\<cdot>\\<^sub>v)\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "from kernel_basis_exists[OF B]"], ["proof (chain)\npicking this:\n  \\<exists>B. finite B \\<and> KB.basis B", "obtain baseB where fin_bB: \"finite baseB\" and bB: \"KB.basis baseB\""], ["proof (prove)\nusing this:\n  \\<exists>B. finite B \\<and> KB.basis B\n\ngoal (1 subgoal):\n 1. (\\<And>baseB.\n        \\<lbrakk>finite baseB; KB.basis baseB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite baseB\n  KB.basis baseB\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "hence bBkB: \"baseB \\<subseteq> mat_kernel B\""], ["proof (prove)\nusing this:\n  finite baseB\n  KB.basis baseB\n\ngoal (1 subgoal):\n 1. baseB \\<subseteq> mat_kernel B", "unfolding KB.Ker.basis_def"], ["proof (prove)\nusing this:\n  finite baseB\n  KB.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. baseB \\<subseteq> mat_kernel B", "by auto"], ["proof (state)\nthis:\n  baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "hence bBc: \"baseB \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. baseB \\<subseteq> carrier_vec n", "using mat_kernel_carrier[OF B]"], ["proof (prove)\nusing this:\n  baseB \\<subseteq> mat_kernel B\n  mat_kernel B \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. baseB \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  baseB \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have bB0: \"0\\<^sub>v n \\<notin> baseB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> baseB", "using bB"], ["proof (prove)\nusing this:\n  KB.basis baseB\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> baseB", "unfolding KB.Ker.basis_def"], ["proof (prove)\nusing this:\n  KB.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> baseB", "using KB.Ker.vs_zero_lin_dep[OF bBkB]"], ["proof (prove)\nusing this:\n  KB.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n  KB.lin_indpt baseB \\<Longrightarrow> 0\\<^sub>v n \\<notin> baseB\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> baseB", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n \\<notin> baseB\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have bBkA: \"padr m ` baseB \\<subseteq> mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<subseteq> mat_kernel A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n               baseB \\<Longrightarrow>\n       x \\<in> mat_kernel A", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n               baseB \\<Longrightarrow>\n       x \\<in> mat_kernel A", "assume \"a : padr m ` baseB\""], ["proof (state)\nthis:\n  a \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n               baseB \\<Longrightarrow>\n       x \\<in> mat_kernel A", "then"], ["proof (chain)\npicking this:\n  a \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB", "obtain b where ab: \"a = padr m b\" and \"b : baseB\""], ["proof (prove)\nusing this:\n  a \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a = b @\\<^sub>v 0\\<^sub>v m; b \\<in> baseB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = b @\\<^sub>v 0\\<^sub>v m\n  b \\<in> baseB\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n               baseB \\<Longrightarrow>\n       x \\<in> mat_kernel A", "hence \"b : mat_kernel B\""], ["proof (prove)\nusing this:\n  a = b @\\<^sub>v 0\\<^sub>v m\n  b \\<in> baseB\n\ngoal (1 subgoal):\n 1. b \\<in> mat_kernel B", "using bB"], ["proof (prove)\nusing this:\n  a = b @\\<^sub>v 0\\<^sub>v m\n  b \\<in> baseB\n  KB.basis baseB\n\ngoal (1 subgoal):\n 1. b \\<in> mat_kernel B", "unfolding KB.Ker.basis_def"], ["proof (prove)\nusing this:\n  a = b @\\<^sub>v 0\\<^sub>v m\n  b \\<in> baseB\n  KB.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. b \\<in> mat_kernel B", "by auto"], ["proof (state)\nthis:\n  b \\<in> mat_kernel B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n               baseB \\<Longrightarrow>\n       x \\<in> mat_kernel A", "hence \"padr m b : mat_kernel A\""], ["proof (prove)\nusing this:\n  b \\<in> mat_kernel B\n\ngoal (1 subgoal):\n 1. b @\\<^sub>v 0\\<^sub>v m \\<in> mat_kernel A", "unfolding Adef"], ["proof (prove)\nusing this:\n  b \\<in> mat_kernel B\n\ngoal (1 subgoal):\n 1. b @\\<^sub>v 0\\<^sub>v m\n    \\<in> mat_kernel (four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D)", "using kernel_padr[OF _ B _ D]"], ["proof (prove)\nusing this:\n  b \\<in> mat_kernel B\n  \\<lbrakk>?a \\<in> mat_kernel B; ?B \\<in> carrier_mat n m\\<rbrakk>\n  \\<Longrightarrow> ?a @\\<^sub>v 0\\<^sub>v m\n                    \\<in> mat_kernel (four_block_mat B ?B (0\\<^sub>m m n) D)\n\ngoal (1 subgoal):\n 1. b @\\<^sub>v 0\\<^sub>v m\n    \\<in> mat_kernel (four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D)", "by auto"], ["proof (state)\nthis:\n  b @\\<^sub>v 0\\<^sub>v m \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) `\n               baseB \\<Longrightarrow>\n       x \\<in> mat_kernel A", "thus \"a : mat_kernel A\""], ["proof (prove)\nusing this:\n  b @\\<^sub>v 0\\<^sub>v m \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. a \\<in> mat_kernel A", "using ab"], ["proof (prove)\nusing this:\n  b @\\<^sub>v 0\\<^sub>v m \\<in> mat_kernel A\n  a = b @\\<^sub>v 0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. a \\<in> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  a \\<in> mat_kernel A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "from kernel_basis_exists[OF D]"], ["proof (chain)\npicking this:\n  \\<exists>B. finite B \\<and> KD.basis B", "obtain baseD where fin_bD: \"finite baseD\" and bD: \"KD.basis baseD\""], ["proof (prove)\nusing this:\n  \\<exists>B. finite B \\<and> KD.basis B\n\ngoal (1 subgoal):\n 1. (\\<And>baseD.\n        \\<lbrakk>finite baseD; KD.basis baseD\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite baseD\n  KD.basis baseD\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "hence bDkD: \"baseD \\<subseteq> mat_kernel D\""], ["proof (prove)\nusing this:\n  finite baseD\n  KD.basis baseD\n\ngoal (1 subgoal):\n 1. baseD \\<subseteq> mat_kernel D", "unfolding KD.Ker.basis_def"], ["proof (prove)\nusing this:\n  finite baseD\n  KD.lin_indpt baseD \\<and>\n  KD.span baseD = mat_kernel D \\<and> baseD \\<subseteq> mat_kernel D\n\ngoal (1 subgoal):\n 1. baseD \\<subseteq> mat_kernel D", "by auto"], ["proof (state)\nthis:\n  baseD \\<subseteq> mat_kernel D\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "hence bDc: \"baseD \\<subseteq> carrier_vec m\""], ["proof (prove)\nusing this:\n  baseD \\<subseteq> mat_kernel D\n\ngoal (1 subgoal):\n 1. baseD \\<subseteq> carrier_vec m", "using mat_kernel_carrier[OF D]"], ["proof (prove)\nusing this:\n  baseD \\<subseteq> mat_kernel D\n  mat_kernel D \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. baseD \\<subseteq> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  baseD \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have bDkA: \"padl n ` baseD \\<subseteq> mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<subseteq> mat_kernel A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> mat_kernel A", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> mat_kernel A", "assume \"a : padl n ` baseD\""], ["proof (state)\nthis:\n  a \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> mat_kernel A", "then"], ["proof (chain)\npicking this:\n  a \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD", "obtain d where ad: \"a = padl n d\" and \"d : baseD\""], ["proof (prove)\nusing this:\n  a \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>a = 0\\<^sub>v n @\\<^sub>v d; d \\<in> baseD\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = 0\\<^sub>v n @\\<^sub>v d\n  d \\<in> baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> mat_kernel A", "hence \"d : mat_kernel D\""], ["proof (prove)\nusing this:\n  a = 0\\<^sub>v n @\\<^sub>v d\n  d \\<in> baseD\n\ngoal (1 subgoal):\n 1. d \\<in> mat_kernel D", "using bD"], ["proof (prove)\nusing this:\n  a = 0\\<^sub>v n @\\<^sub>v d\n  d \\<in> baseD\n  KD.basis baseD\n\ngoal (1 subgoal):\n 1. d \\<in> mat_kernel D", "unfolding KD.Ker.basis_def"], ["proof (prove)\nusing this:\n  a = 0\\<^sub>v n @\\<^sub>v d\n  d \\<in> baseD\n  KD.lin_indpt baseD \\<and>\n  KD.span baseD = mat_kernel D \\<and> baseD \\<subseteq> mat_kernel D\n\ngoal (1 subgoal):\n 1. d \\<in> mat_kernel D", "by auto"], ["proof (state)\nthis:\n  d \\<in> mat_kernel D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> mat_kernel A", "hence \"padl n d : mat_kernel A\""], ["proof (prove)\nusing this:\n  d \\<in> mat_kernel D\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v d \\<in> mat_kernel A", "unfolding Adef"], ["proof (prove)\nusing this:\n  d \\<in> mat_kernel D\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v d\n    \\<in> mat_kernel (four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D)", "using kernel_padl[OF _ B _ D]"], ["proof (prove)\nusing this:\n  d \\<in> mat_kernel D\n  \\<lbrakk>?d \\<in> mat_kernel D; ?C \\<in> carrier_mat m n\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>v n @\\<^sub>v ?d\n                    \\<in> mat_kernel (four_block_mat B (0\\<^sub>m n m) ?C D)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v d\n    \\<in> mat_kernel (four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D)", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v d \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> mat_kernel A", "thus \"a : mat_kernel A\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n @\\<^sub>v d \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. a \\<in> mat_kernel A", "using ad"], ["proof (prove)\nusing this:\n  0\\<^sub>v n @\\<^sub>v d \\<in> mat_kernel A\n  a = 0\\<^sub>v n @\\<^sub>v d\n\ngoal (1 subgoal):\n 1. a \\<in> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  a \\<in> mat_kernel A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "let ?BD = \"(padr m ` baseB \\<union> padl n ` baseD)\""], ["proof (state)\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have finBD: \"finite ?BD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "using fin_bB fin_bD"], ["proof (prove)\nusing this:\n  finite baseB\n  finite baseD\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "by auto"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have \"KA.basis  ?BD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KA.basis\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "unfolding KA.Ker.basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD) \\<and>\n    KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n    mat_kernel A \\<and>\n    (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n    \\<subseteq> mat_kernel A", "proof (intro conjI Set.equalityI)"], ["proof (state)\ngoal (4 subgoals):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 2. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A\n 3. mat_kernel A\n    \\<subseteq> KA.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 4. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n    \\<subseteq> mat_kernel A", "show BDk: \"?BD \\<subseteq> mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n    \\<subseteq> mat_kernel A", "using bBkA bDkA"], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<subseteq> mat_kernel A\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n    \\<subseteq> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> mat_kernel A\n\ngoal (3 subgoals):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 2. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A\n 3. mat_kernel A\n    \\<subseteq> KA.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "also"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> mat_kernel A\n\ngoal (3 subgoals):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 2. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A\n 3. mat_kernel A\n    \\<subseteq> KA.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"mat_kernel A \\<subseteq> carrier_vec (m+n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> carrier_vec (m + n)", "using mat_kernel_carrier A"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow>\n  mat_kernel ?A \\<subseteq> carrier_vec ?nc\n  A \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. mat_kernel A \\<subseteq> carrier_vec (m + n)", "by auto"], ["proof (state)\nthis:\n  mat_kernel A \\<subseteq> carrier_vec (m + n)\n\ngoal (3 subgoals):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 2. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A\n 3. mat_kernel A\n    \\<subseteq> KA.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> carrier_vec (m + n)", "have BD: \"?BD \\<subseteq> carrier (M (n + m))\""], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> carrier_vec (m + n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n    \\<subseteq> carrier KA.NC.V", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> carrier KA.NC.V\n\ngoal (3 subgoals):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 2. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A\n 3. mat_kernel A\n    \\<subseteq> KA.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "show \"mat_kernel A \\<subseteq> KA.Ker.span ?BD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A\n    \\<subseteq> KA.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "unfolding KA.span_same[OF BDk]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel A\n    \\<subseteq> MN.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have BD: \"?BD \\<subseteq> carrier_vec (n+m)\" (is \"_ \\<subseteq> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n    \\<subseteq> carrier_vec (n + m)", "proof(rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "assume \"v : ?BD\""], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "moreover"], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "{"], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "assume \"v : padr m ` baseB\""], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "then"], ["proof (chain)\npicking this:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB", "obtain b where \"b : baseB\" and vb: \"v = padr m b\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> baseB; v = b @\\<^sub>v 0\\<^sub>v m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<in> baseB\n  v = b @\\<^sub>v 0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "hence \"b : carrier_vec n\""], ["proof (prove)\nusing this:\n  b \\<in> baseB\n  v = b @\\<^sub>v 0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. b \\<in> carrier_vec n", "using bBc"], ["proof (prove)\nusing this:\n  b \\<in> baseB\n  v = b @\\<^sub>v 0\\<^sub>v m\n  baseB \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. b \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  b \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "hence \"v : ?R\""], ["proof (prove)\nusing this:\n  b \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (n + m)", "unfolding vb"], ["proof (prove)\nusing this:\n  b \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. b @\\<^sub>v 0\\<^sub>v m \\<in> carrier_vec (n + m)", "apply(subst append_carrier_vec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. b \\<in> carrier_vec n \\<Longrightarrow> b \\<in> carrier_vec n\n 2. b \\<in> carrier_vec n \\<Longrightarrow> 0\\<^sub>v m \\<in> carrier_vec m\n 3. b \\<in> carrier_vec n \\<Longrightarrow> True", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "}"], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "moreover"], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "{"], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "assume \"v : padl n ` baseD\""], ["proof (state)\nthis:\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "then"], ["proof (chain)\npicking this:\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD", "obtain d where \"d : baseD\" and vd: \"v = padl n d\""], ["proof (prove)\nusing this:\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> baseD; v = 0\\<^sub>v n @\\<^sub>v d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<in> baseD\n  v = 0\\<^sub>v n @\\<^sub>v d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "hence \"d : carrier_vec m\""], ["proof (prove)\nusing this:\n  d \\<in> baseD\n  v = 0\\<^sub>v n @\\<^sub>v d\n\ngoal (1 subgoal):\n 1. d \\<in> carrier_vec m", "using bDc"], ["proof (prove)\nusing this:\n  d \\<in> baseD\n  v = 0\\<^sub>v n @\\<^sub>v d\n  baseD \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. d \\<in> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  d \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "hence \"v : ?R\""], ["proof (prove)\nusing this:\n  d \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (n + m)", "unfolding vd"], ["proof (prove)\nusing this:\n  d \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v d \\<in> carrier_vec (n + m)", "apply(subst append_carrier_vec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. d \\<in> carrier_vec m \\<Longrightarrow> 0\\<^sub>v n \\<in> carrier_vec n\n 2. d \\<in> carrier_vec m \\<Longrightarrow> d \\<in> carrier_vec m\n 3. d \\<in> carrier_vec m \\<Longrightarrow> True", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "}"], ["proof (state)\nthis:\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n               (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n       x \\<in> carrier_vec (n + m)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)", "show \"v: ?R\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  v \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)\n  v \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` baseD \\<Longrightarrow>\n  v \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (n + m)", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec (n + m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "assume a: \"a : mat_kernel A\""], ["proof (state)\nthis:\n  a \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "hence \"a : carrier_vec (n+m)\""], ["proof (prove)\nusing this:\n  a \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec (n + m)", "using a mat_kernel_carrier[OF A]"], ["proof (prove)\nusing this:\n  a \\<in> mat_kernel A\n  a \\<in> mat_kernel A\n  mat_kernel A \\<subseteq> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. a \\<in> carrier_vec (n + m)", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "hence \"a = vec_first a n @\\<^sub>v vec_last a m\" (is \"_ = ?b @\\<^sub>v ?d\")"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. a = vec_first a n @\\<^sub>v vec_last a m", "by simp"], ["proof (state)\nthis:\n  a = vec_first a n @\\<^sub>v vec_last a m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "also"], ["proof (state)\nthis:\n  a = vec_first a n @\\<^sub>v vec_last a m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"... = padr m ?b + padl n ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first a n @\\<^sub>v vec_last a m =\n    vec_first a n @\\<^sub>v 0\\<^sub>v m +\n    (0\\<^sub>v n @\\<^sub>v vec_last a m)", "by auto"], ["proof (state)\nthis:\n  vec_first a n @\\<^sub>v vec_last a m =\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "finally"], ["proof (chain)\npicking this:\n  a =\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)", "have 1: \"a = padr m ?b + padl n ?d\""], ["proof (prove)\nusing this:\n  a =\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)\n\ngoal (1 subgoal):\n 1. a =\n    vec_first a n @\\<^sub>v 0\\<^sub>v m +\n    (0\\<^sub>v n @\\<^sub>v vec_last a m)", "."], ["proof (state)\nthis:\n  a =\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have subkernel: \"?b : mat_kernel B\" \"?d : mat_kernel D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first a n \\<in> mat_kernel B &&& vec_last a m \\<in> mat_kernel D", "using mat_kernel_split[OF B D] a Adef"], ["proof (prove)\nusing this:\n  ?k \\<in> mat_kernel\n            (four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n)\n              D) \\<Longrightarrow>\n  vec_first ?k n \\<in> mat_kernel B\n  ?k \\<in> mat_kernel\n            (four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n)\n              D) \\<Longrightarrow>\n  vec_last ?k m \\<in> mat_kernel D\n  a \\<in> mat_kernel A\n  A = four_block_mat B (0\\<^sub>m n m) (0\\<^sub>m m n) D\n\ngoal (1 subgoal):\n 1. vec_first a n \\<in> mat_kernel B &&& vec_last a m \\<in> mat_kernel D", "by auto"], ["proof (state)\nthis:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "hence \"?b : span n baseB\""], ["proof (prove)\nusing this:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n\ngoal (1 subgoal):\n 1. vec_first a n \\<in> KB.NC.span baseB", "using bB"], ["proof (prove)\nusing this:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n  KB.basis baseB\n\ngoal (1 subgoal):\n 1. vec_first a n \\<in> KB.NC.span baseB", "unfolding KB.Ker.basis_def"], ["proof (prove)\nusing this:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n  KB.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. vec_first a n \\<in> KB.NC.span baseB", "using KB.span_same"], ["proof (prove)\nusing this:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n  KB.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n  ?S \\<subseteq> mat_kernel B \\<Longrightarrow> KB.span ?S = KB.NC.span ?S\n\ngoal (1 subgoal):\n 1. vec_first a n \\<in> KB.NC.span baseB", "by auto"], ["proof (state)\nthis:\n  vec_first a n \\<in> KB.NC.span baseB\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "hence \"padr m ?b : padr m ` span n baseB\""], ["proof (prove)\nusing this:\n  vec_first a n \\<in> KB.NC.span baseB\n\ngoal (1 subgoal):\n 1. vec_first a n @\\<^sub>v 0\\<^sub>v m\n    \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` KB.NC.span baseB", "by auto"], ["proof (state)\nthis:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m\n  \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` KB.NC.span baseB\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "also"], ["proof (state)\nthis:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m\n  \\<in> (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` KB.NC.span baseB\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"padr m ` span n baseB = span (n+m) (padr m ` baseB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` KB.NC.span baseB =\n    MN.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)", "using span_pad[OF bBc]"], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` KB.NC.span baseB =\n  LinearCombinations.module.span class_ring (M (n + ?m))\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` baseB)\n  (@\\<^sub>v) (0\\<^sub>v ?m) ` KB.NC.span baseB =\n  LinearCombinations.module.span class_ring (M (n + ?m))\n   ((@\\<^sub>v) (0\\<^sub>v ?m) ` baseB)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` KB.NC.span baseB =\n    MN.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` KB.NC.span baseB =\n  MN.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "also"], ["proof (state)\nthis:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` KB.NC.span baseB =\n  MN.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"... \\<subseteq> span (n+m) ?BD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MN.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)\n    \\<subseteq> MN.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "using MN.span_is_monotone"], ["proof (prove)\nusing this:\n  ?S \\<subseteq> ?T \\<Longrightarrow> MN.span ?S \\<subseteq> MN.span ?T\n\ngoal (1 subgoal):\n 1. MN.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)\n    \\<subseteq> MN.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "by auto"], ["proof (state)\nthis:\n  MN.span ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)\n  \\<subseteq> MN.span\n               ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "finally"], ["proof (chain)\npicking this:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have 2: \"padr m ?b : span (n+m) ?BD\""], ["proof (prove)\nusing this:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. vec_first a n @\\<^sub>v 0\\<^sub>v m\n    \\<in> MN.span\n           ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n            (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "."], ["proof (state)\nthis:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"?d : span m baseD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_last a m \\<in> KD.NC.span baseD", "using subkernel bD"], ["proof (prove)\nusing this:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n  KD.basis baseD\n\ngoal (1 subgoal):\n 1. vec_last a m \\<in> KD.NC.span baseD", "unfolding KD.Ker.basis_def"], ["proof (prove)\nusing this:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n  KD.lin_indpt baseD \\<and>\n  KD.span baseD = mat_kernel D \\<and> baseD \\<subseteq> mat_kernel D\n\ngoal (1 subgoal):\n 1. vec_last a m \\<in> KD.NC.span baseD", "using KD.span_same"], ["proof (prove)\nusing this:\n  vec_first a n \\<in> mat_kernel B\n  vec_last a m \\<in> mat_kernel D\n  KD.lin_indpt baseD \\<and>\n  KD.span baseD = mat_kernel D \\<and> baseD \\<subseteq> mat_kernel D\n  ?S \\<subseteq> mat_kernel D \\<Longrightarrow> KD.span ?S = KD.NC.span ?S\n\ngoal (1 subgoal):\n 1. vec_last a m \\<in> KD.NC.span baseD", "by auto"], ["proof (state)\nthis:\n  vec_last a m \\<in> KD.NC.span baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "hence \"padl n ?d : padl n ` span m baseD\""], ["proof (prove)\nusing this:\n  vec_last a m \\<in> KD.NC.span baseD\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v vec_last a m\n    \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` KD.NC.span baseD", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v vec_last a m\n  \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` KD.NC.span baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "also"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v vec_last a m\n  \\<in> (@\\<^sub>v) (0\\<^sub>v n) ` KD.NC.span baseD\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"padl n ` span m baseD = span (n+m) (padl n ` baseD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (@\\<^sub>v) (0\\<^sub>v n) ` KD.NC.span baseD =\n    MN.span ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "using span_pad[OF bDc]"], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` KD.NC.span baseD =\n  LinearCombinations.module.span class_ring (M (m + ?m))\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m) ` baseD)\n  (@\\<^sub>v) (0\\<^sub>v ?m) ` KD.NC.span baseD =\n  LinearCombinations.module.span class_ring (M (m + ?m))\n   ((@\\<^sub>v) (0\\<^sub>v ?m) ` baseD)\n\ngoal (1 subgoal):\n 1. (@\\<^sub>v) (0\\<^sub>v n) ` KD.NC.span baseD =\n    MN.span ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "by auto"], ["proof (state)\nthis:\n  (@\\<^sub>v) (0\\<^sub>v n) ` KD.NC.span baseD =\n  MN.span ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "also"], ["proof (state)\nthis:\n  (@\\<^sub>v) (0\\<^sub>v n) ` KD.NC.span baseD =\n  MN.span ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"... \\<subseteq> span (n+m) ?BD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MN.span ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> MN.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "using MN.span_is_monotone"], ["proof (prove)\nusing this:\n  ?S \\<subseteq> ?T \\<Longrightarrow> MN.span ?S \\<subseteq> MN.span ?T\n\ngoal (1 subgoal):\n 1. MN.span ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> MN.span\n                 ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                  (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "by auto"], ["proof (state)\nthis:\n  MN.span ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n  \\<subseteq> MN.span\n               ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "finally"], ["proof (chain)\npicking this:\n  0\\<^sub>v n @\\<^sub>v vec_last a m\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have 3: \"padl n ?d : span (n+m) ?BD\""], ["proof (prove)\nusing this:\n  0\\<^sub>v n @\\<^sub>v vec_last a m\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v vec_last a m\n    \\<in> MN.span\n           ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n            (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "."], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v vec_last a m\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have \"padr m ?b + padl n ?d : span (n+m) ?BD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first a n @\\<^sub>v 0\\<^sub>v m +\n    (0\\<^sub>v n @\\<^sub>v vec_last a m)\n    \\<in> MN.span\n           ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n            (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "using MN.span_add1[OF _ 2 3] BD"], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> carrier KA.NC.V \\<Longrightarrow>\n  vec_first a n @\\<^sub>v 0\\<^sub>v m \\<oplus>\\<^bsub>KA.NC.V\\<^esub>\n  (0\\<^sub>v n @\\<^sub>v vec_last a m)\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD\n  \\<subseteq> carrier_vec (n + m)\n\ngoal (1 subgoal):\n 1. vec_first a n @\\<^sub>v 0\\<^sub>v m +\n    (0\\<^sub>v n @\\<^sub>v vec_last a m)\n    \\<in> MN.span\n           ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n            (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "by auto"], ["proof (state)\nthis:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel A \\<Longrightarrow>\n       x \\<in> MN.span\n                ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                 (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "thus \"a \\<in> span (n+m) ?BD\""], ["proof (prove)\nusing this:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. a \\<in> MN.span\n             ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n              (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "using 1"], ["proof (prove)\nusing this:\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)\n  \\<in> MN.span\n         ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n          (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n  a =\n  vec_first a n @\\<^sub>v 0\\<^sub>v m + (0\\<^sub>v n @\\<^sub>v vec_last a m)\n\ngoal (1 subgoal):\n 1. a \\<in> MN.span\n             ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n              (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "by auto"], ["proof (state)\nthis:\n  a \\<in> MN.span\n           ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n            (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_kernel A\n  \\<subseteq> KA.span\n               ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n                (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (2 subgoals):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 2. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A", "show \"KA.Ker.span ?BD \\<subseteq> mat_kernel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A", "using KA.Ker.span_closed[OF BDk]"], ["proof (prove)\nusing this:\n  ?v \\<in> KA.span\n            ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n             (@\\<^sub>v) (0\\<^sub>v n) ` baseD) \\<Longrightarrow>\n  ?v \\<in> mat_kernel A\n\ngoal (1 subgoal):\n 1. KA.span\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n    \\<subseteq> mat_kernel A", "by auto"], ["proof (state)\nthis:\n  KA.span\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n  \\<subseteq> mat_kernel A\n\ngoal (1 subgoal):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "have li: \"~ lin_dep n baseB\" \"~ lin_dep m baseD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KB.NC.lin_indpt baseB &&& KD.NC.lin_indpt baseD", "using bB[unfolded KB.Ker.basis_def]"], ["proof (prove)\nusing this:\n  KB.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. KB.NC.lin_indpt baseB &&& KD.NC.lin_indpt baseD", "unfolding KB.lindep_same[OF bBkB]"], ["proof (prove)\nusing this:\n  KB.NC.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n\ngoal (1 subgoal):\n 1. KB.NC.lin_indpt baseB &&& KD.NC.lin_indpt baseD", "using bD[unfolded KD.Ker.basis_def]"], ["proof (prove)\nusing this:\n  KB.NC.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n  KD.lin_indpt baseD \\<and>\n  KD.span baseD = mat_kernel D \\<and> baseD \\<subseteq> mat_kernel D\n\ngoal (1 subgoal):\n 1. KB.NC.lin_indpt baseB &&& KD.NC.lin_indpt baseD", "unfolding KD.lindep_same[OF bDkD]"], ["proof (prove)\nusing this:\n  KB.NC.lin_indpt baseB \\<and>\n  KB.span baseB = mat_kernel B \\<and> baseB \\<subseteq> mat_kernel B\n  KD.NC.lin_indpt baseD \\<and>\n  KD.span baseD = mat_kernel D \\<and> baseD \\<subseteq> mat_kernel D\n\ngoal (1 subgoal):\n 1. KB.NC.lin_indpt baseB &&& KD.NC.lin_indpt baseD", "by auto"], ["proof (state)\nthis:\n  KB.NC.lin_indpt baseB\n  KD.NC.lin_indpt baseD\n\ngoal (1 subgoal):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "show \"~ KA.Ker.lin_dep ?BD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KA.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "unfolding KA.lindep_same[OF BDk]"], ["proof (prove)\ngoal (1 subgoal):\n 1. MN.lin_indpt\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "apply(rule padr_padl_lindep)"], ["proof (prove)\ngoal (4 subgoals):\n 1. baseB \\<subseteq> carrier_vec n\n 2. KB.NC.lin_indpt baseB\n 3. baseD \\<subseteq> carrier_vec m\n 4. KD.NC.lin_indpt baseD", "using bBc bDc li"], ["proof (prove)\nusing this:\n  baseB \\<subseteq> carrier_vec n\n  baseD \\<subseteq> carrier_vec m\n  KB.NC.lin_indpt baseB\n  KD.NC.lin_indpt baseD\n\ngoal (4 subgoals):\n 1. baseB \\<subseteq> carrier_vec n\n 2. KB.NC.lin_indpt baseB\n 3. baseD \\<subseteq> carrier_vec m\n 4. KD.NC.lin_indpt baseD", "by auto"], ["proof (state)\nthis:\n  KA.lin_indpt\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  KA.basis\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "hence \"KA.dim = card ?BD\""], ["proof (prove)\nusing this:\n  KA.basis\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim =\n    card\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "using KA.Ker.dim_basis[OF finBD]"], ["proof (prove)\nusing this:\n  KA.basis\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n  KA.basis\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD) \\<Longrightarrow>\n  KA.dim =\n  card\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim =\n    card\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "by auto"], ["proof (state)\nthis:\n  KA.dim =\n  card\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "also"], ["proof (state)\nthis:\n  KA.dim =\n  card\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have \"card ?BD = card (padr m ` baseB) + card (padl n ` baseD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n      (@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n    card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n    card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)", "apply(rule card_Un_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)\n 2. finite ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 3. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<inter>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD =\n    {}", "using pad_disjoint[OF bBc bB0 bDc] fin_bB fin_bD"], ["proof (prove)\nusing this:\n  (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<inter>\n  (@\\<^sub>v) (0\\<^sub>v n) ` baseD =\n  {}\n  finite baseB\n  finite baseD\n\ngoal (3 subgoals):\n 1. finite ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB)\n 2. finite ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n 3. (\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<inter>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD =\n    {}", "by auto"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n  card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n  card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "also"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB \\<union>\n    (@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n  card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n  card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD)\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have \"... = card baseB + card baseD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n    card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n    card baseB + card baseD", "using card_image[OF subset_inj_on[OF padr_inj]]"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> carrier_vec ?n2 \\<Longrightarrow>\n  card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m2) ` ?A) = card ?A\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n    card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n    card baseB + card baseD", "using card_image[OF subset_inj_on[OF padl_inj]] bBc bDc"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> carrier_vec ?n2 \\<Longrightarrow>\n  card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v ?m2) ` ?A) = card ?A\n  ?A \\<subseteq> carrier_vec ?n2 \\<Longrightarrow>\n  card ((@\\<^sub>v) (0\\<^sub>v ?m2) ` ?A) = card ?A\n  baseB \\<subseteq> carrier_vec n\n  baseD \\<subseteq> carrier_vec m\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n    card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n    card baseB + card baseD", "by auto"], ["proof (state)\nthis:\n  card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n  card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n  card baseB + card baseD\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "also"], ["proof (state)\nthis:\n  card ((\\<lambda>v. v @\\<^sub>v 0\\<^sub>v m) ` baseB) +\n  card ((@\\<^sub>v) (0\\<^sub>v n) ` baseD) =\n  card baseB + card baseD\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have \"card baseB = KB.dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card baseB = KB.dim", "using KB.Ker.dim_basis[OF fin_bB] bB"], ["proof (prove)\nusing this:\n  KB.basis baseB \\<Longrightarrow> KB.dim = card baseB\n  KB.basis baseB\n\ngoal (1 subgoal):\n 1. card baseB = KB.dim", "by auto"], ["proof (state)\nthis:\n  card baseB = KB.dim\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "also"], ["proof (state)\nthis:\n  card baseB = KB.dim\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "have \"card baseD = KD.dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card baseD = KD.dim", "using KD.Ker.dim_basis[OF fin_bD] bD"], ["proof (prove)\nusing this:\n  KD.basis baseD \\<Longrightarrow> KD.dim = card baseD\n  KD.basis baseD\n\ngoal (1 subgoal):\n 1. card baseD = KD.dim", "by auto"], ["proof (state)\nthis:\n  card baseD = KD.dim\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "finally"], ["proof (chain)\npicking this:\n  KA.dim = KB.dim + KD.dim", "show ?thesis"], ["proof (prove)\nusing this:\n  KA.dim = KB.dim + KD.dim\n\ngoal (1 subgoal):\n 1. KA.dim = KB.dim + KD.dim", "."], ["proof (state)\nthis:\n  KA.dim = KB.dim + KD.dim\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma similar_mat_wit_kernel_dim: assumes A: \"A \\<in> carrier_mat n n\"\n  and wit: \"similar_mat_wit A B P Q\"\n  shows \"kernel.dim n A = kernel.dim n B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>)", "from similar_mat_witD2[OF A wit]"], ["proof (chain)\npicking this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n", "have QP: \"Q * P = 1\\<^sub>m n\" and AB: \"A = P * B * Q\" and \n    A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\" and P: \"P \\<in> carrier_mat n n\" and Q: \"Q \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (Q * P = 1\\<^sub>m n &&& A = P * B * Q &&& A \\<in> carrier_mat n n) &&&\n    B \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>)", "from P B"], ["proof (chain)\npicking this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n", "have PB: \"P * B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P * B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>)", "unfolding AB mat_kernel_dim_mult_eq_right[OF PB Q P QP] mat_kernel_mult_eq[OF B P Q QP]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel A\\<rparr>) =\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\\<lparr>carrier := mat_kernel B\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}