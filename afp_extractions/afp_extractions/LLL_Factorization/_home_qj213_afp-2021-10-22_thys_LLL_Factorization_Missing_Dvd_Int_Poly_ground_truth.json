{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Factorization/Missing_Dvd_Int_Poly.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Factorization", "problem_names": ["lemma degree_div_mod_smult:\n  fixes g::\"int poly\"\n  assumes g: \"degree g < j\"\n  and r: \"degree r < d\"\n  and u: \"degree u = d\"\n  and g1: \"g = q * u + smult m r\" \n  and q: \"q \\<noteq> 0\" and m_not0: \"m \\<noteq> 0\"\nshows \"degree q < j - d\"", "lemma uniqueness_algorithm_division_poly:\n  fixes f::\"'a::{comm_ring,semiring_1_no_zero_divisors} poly\"\n  assumes f1: \"f = g * q1 + r1\"\n      and f2: \"f = g * q2 + r2\"\n      and g: \"g \\<noteq> 0\"\n      and r1: \"r1 = 0 \\<or> degree r1 < degree g\"\n      and r2: \"r2 = 0 \\<or> degree r2 < degree g\"\n    shows \"q1 = q2 \\<and> r1 = r2\"", "lemma pdivmod_eq_pdivmod_monic:\n  assumes g: \"monic g\"\n  shows \"pdivmod f g = pdivmod_monic f g\"", "lemma dvdm_iff_pdivmod0:\n  assumes f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\"\n  shows \"g dvdm f = (snd (pdivmod F G) = 0)\"", "lemma of_int_poly_Mp_0[simp]: \"(of_int_poly (Mp a) = (0:: 'a mod_ring poly)) = (Mp a = 0)\"", "lemma uniqueness_algorithm_division_of_int_poly:\n  assumes g0: \"Mp g \\<noteq> 0\"\n  and f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\"\n  and F: \"F = G * Q + R\"\n  and R: \"R = 0 \\<or> degree R < degree G\"\n  and Mp_f: \"Mp f = Mp g * q + r\"\n  and r: \"r = 0 \\<or> degree r < degree (Mp g)\"\nshows \"Q = of_int_poly q \\<and> R = of_int_poly r\"", "lemma uniqueness_algorithm_division_Mp_Rel: \n  assumes monic_Mpg: \"monic (Mp g)\"\n    and f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\"\n  and qr: \"pseudo_divmod (Mp f) (Mp g) = (q,r)\"\n  and QR: \"pseudo_divmod F G = (Q,R)\"\nshows \"MP_Rel q Q \\<and> MP_Rel r R \"", "lemma pdivmod2_rel[transfer_rule]: \n  \"(MP_Rel ===> MP_Rel ===> MP_Rel_Pair) (pdivmod2) (pdivmod)\"", "lemma dvdm_iff_Mp_pdivmod2:\n  shows \"g dvdm f = (Mp (snd (pdivmod2 f g)) = 0)\"", "lemmas (in poly_mod_prime) dvdm_pdivmod = poly_mod_prime_type.dvdm_iff_Mp_pdivmod2\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, \n   unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemma (in poly_mod) dvdm_code:\n   \"g dvdm f = (if prime m then Mp (snd (pdivmod2 f g)) = 0 \n    else Code.abort (STR ''dvdm error: m is not a prime number'') (\\<lambda> _. g dvdm f))\""], "translations": [["", "lemma degree_div_mod_smult:\n  fixes g::\"int poly\"\n  assumes g: \"degree g < j\"\n  and r: \"degree r < d\"\n  and u: \"degree u = d\"\n  and g1: \"g = q * u + smult m r\" \n  and q: \"q \\<noteq> 0\" and m_not0: \"m \\<noteq> 0\"\nshows \"degree q < j - d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q < j - d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree q < j - d", "have u_not0: \"u\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "using u r"], ["proof (prove)\nusing this:\n  degree u = d\n  degree r < d\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree q < j - d", "have d_uq: \"d \\<le> degree (u*q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> degree (u * q)", "using u degree_mult_right_le[OF q]"], ["proof (prove)\nusing this:\n  degree u = d\n  degree ?p \\<le> degree (?p * q)\n\ngoal (1 subgoal):\n 1. d \\<le> degree (u * q)", "by auto"], ["proof (state)\nthis:\n  d \\<le> degree (u * q)\n\ngoal (1 subgoal):\n 1. degree q < j - d", "have j: \"j > degree (q* u + smult m r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (q * u + Polynomial.smult m r) < j", "using g1 g"], ["proof (prove)\nusing this:\n  g = q * u + Polynomial.smult m r\n  degree g < j\n\ngoal (1 subgoal):\n 1. degree (q * u + Polynomial.smult m r) < j", "by auto"], ["proof (state)\nthis:\n  degree (q * u + Polynomial.smult m r) < j\n\ngoal (1 subgoal):\n 1. degree q < j - d", "have \"degree (smult m r) < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult m r) < d", "using degree_smult_eq m_not0 r"], ["proof (prove)\nusing this:\n  degree (Polynomial.smult ?a ?p) = (if ?a = (0::?'a) then 0 else degree ?p)\n  m \\<noteq> 0\n  degree r < d\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult m r) < d", "by auto"], ["proof (state)\nthis:\n  degree (Polynomial.smult m r) < d\n\ngoal (1 subgoal):\n 1. degree q < j - d", "also"], ["proof (state)\nthis:\n  degree (Polynomial.smult m r) < d\n\ngoal (1 subgoal):\n 1. degree q < j - d", "have \"... \\<le> degree (u*q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> degree (u * q)", "using d_uq"], ["proof (prove)\nusing this:\n  d \\<le> degree (u * q)\n\ngoal (1 subgoal):\n 1. d \\<le> degree (u * q)", "by auto"], ["proof (state)\nthis:\n  d \\<le> degree (u * q)\n\ngoal (1 subgoal):\n 1. degree q < j - d", "finally"], ["proof (chain)\npicking this:\n  degree (Polynomial.smult m r) < degree (u * q)", "have deg_mr_uq: \"degree (smult m r) < degree (q*u)\""], ["proof (prove)\nusing this:\n  degree (Polynomial.smult m r) < degree (u * q)\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult m r) < degree (q * u)", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  degree (Polynomial.smult m r) < degree (q * u)\n\ngoal (1 subgoal):\n 1. degree q < j - d", "have j2: \"degree (q* u + smult m r) = degree (q*u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (q * u + Polynomial.smult m r) = degree (q * u)", "by (rule degree_add_eq_left[OF deg_mr_uq])"], ["proof (state)\nthis:\n  degree (q * u + Polynomial.smult m r) = degree (q * u)\n\ngoal (1 subgoal):\n 1. degree q < j - d", "also"], ["proof (state)\nthis:\n  degree (q * u + Polynomial.smult m r) = degree (q * u)\n\ngoal (1 subgoal):\n 1. degree q < j - d", "have \"... = degree q + degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (q * u) = degree q + degree u", "by (rule degree_mult_eq[OF q u_not0])"], ["proof (state)\nthis:\n  degree (q * u) = degree q + degree u\n\ngoal (1 subgoal):\n 1. degree q < j - d", "finally"], ["proof (chain)\npicking this:\n  degree (q * u + Polynomial.smult m r) = degree q + degree u", "have \"degree q = degree g - degree u\""], ["proof (prove)\nusing this:\n  degree (q * u + Polynomial.smult m r) = degree q + degree u\n\ngoal (1 subgoal):\n 1. degree q = degree g - degree u", "using g1"], ["proof (prove)\nusing this:\n  degree (q * u + Polynomial.smult m r) = degree q + degree u\n  g = q * u + Polynomial.smult m r\n\ngoal (1 subgoal):\n 1. degree q = degree g - degree u", "by auto"], ["proof (state)\nthis:\n  degree q = degree g - degree u\n\ngoal (1 subgoal):\n 1. degree q < j - d", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree q = degree g - degree u\n\ngoal (1 subgoal):\n 1. degree q < j - d", "using j j2 \\<open>degree (q * u) = degree q + degree u\\<close> u"], ["proof (prove)\nusing this:\n  degree q = degree g - degree u\n  degree (q * u + Polynomial.smult m r) < j\n  degree (q * u + Polynomial.smult m r) = degree (q * u)\n  degree (q * u) = degree q + degree u\n  degree u = d\n\ngoal (1 subgoal):\n 1. degree q < j - d", "by linarith"], ["proof (state)\nthis:\n  degree q < j - d\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Uniqueness of division algorithm for polynomials\\<close>"], ["", "lemma uniqueness_algorithm_division_poly:\n  fixes f::\"'a::{comm_ring,semiring_1_no_zero_divisors} poly\"\n  assumes f1: \"f = g * q1 + r1\"\n      and f2: \"f = g * q2 + r2\"\n      and g: \"g \\<noteq> 0\"\n      and r1: \"r1 = 0 \\<or> degree r1 < degree g\"\n      and r2: \"r2 = 0 \\<or> degree r2 < degree g\"\n    shows \"q1 = q2 \\<and> r1 = r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "have \"0 =  g * q1 + r1 - (g * q2 + r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = g * q1 + r1 - (g * q2 + r2)", "using f1 f2"], ["proof (prove)\nusing this:\n  f = g * q1 + r1\n  f = g * q2 + r2\n\ngoal (1 subgoal):\n 1. 0 = g * q1 + r1 - (g * q2 + r2)", "by auto"], ["proof (state)\nthis:\n  0 = g * q1 + r1 - (g * q2 + r2)\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "also"], ["proof (state)\nthis:\n  0 = g * q1 + r1 - (g * q2 + r2)\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "have \"... = g * (q1 - q2) + r1 - r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g * q1 + r1 - (g * q2 + r2) = g * (q1 - q2) + r1 - r2", "by (simp add: right_diff_distrib)"], ["proof (state)\nthis:\n  g * q1 + r1 - (g * q2 + r2) = g * (q1 - q2) + r1 - r2\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "finally"], ["proof (chain)\npicking this:\n  0 = g * (q1 - q2) + r1 - r2", "have eq: \"g * (q1 - q2) = r2 - r1\""], ["proof (prove)\nusing this:\n  0 = g * (q1 - q2) + r1 - r2\n\ngoal (1 subgoal):\n 1. g * (q1 - q2) = r2 - r1", "by auto"], ["proof (state)\nthis:\n  g * (q1 - q2) = r2 - r1\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "have q_eq: \"q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 = q2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow> False", "assume q1_not_q2: \"q1 \\<noteq> q2\""], ["proof (state)\nthis:\n  q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow> False", "hence nz: \"g * (q1 - q2) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. g * (q1 - q2) \\<noteq> 0", "using g"], ["proof (prove)\nusing this:\n  q1 \\<noteq> q2\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g * (q1 - q2) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g * (q1 - q2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow> False", "hence \"degree (g * (q1 - q2)) \\<ge> degree g\""], ["proof (prove)\nusing this:\n  g * (q1 - q2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree g \\<le> degree (g * (q1 - q2))", "by (simp add: degree_mult_right_le)"], ["proof (state)\nthis:\n  degree g \\<le> degree (g * (q1 - q2))\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree g \\<le> degree (g * (q1 - q2))\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow> False", "have \"degree (r2 - r1) < degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (r2 - r1) < degree g", "using eq nz degree_diff_less r1 r2"], ["proof (prove)\nusing this:\n  g * (q1 - q2) = r2 - r1\n  g * (q1 - q2) \\<noteq> 0\n  \\<lbrakk>degree ?p < ?n; degree ?q < ?n\\<rbrakk>\n  \\<Longrightarrow> degree (?p - ?q) < ?n\n  r1 = 0 \\<or> degree r1 < degree g\n  r2 = 0 \\<or> degree r2 < degree g\n\ngoal (1 subgoal):\n 1. degree (r2 - r1) < degree g", "by auto"], ["proof (state)\nthis:\n  degree (r2 - r1) < degree g\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  degree g \\<le> degree (g * (q1 - q2))\n  degree (r2 - r1) < degree g", "show False"], ["proof (prove)\nusing this:\n  degree g \\<le> degree (g * (q1 - q2))\n  degree (r2 - r1) < degree g\n\ngoal (1 subgoal):\n 1. False", "using eq"], ["proof (prove)\nusing this:\n  degree g \\<le> degree (g * (q1 - q2))\n  degree (r2 - r1) < degree g\n  g * (q1 - q2) = r2 - r1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "moreover"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "have \"r1 = r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 = r2", "using eq q_eq"], ["proof (prove)\nusing this:\n  g * (q1 - q2) = r2 - r1\n  q1 = q2\n\ngoal (1 subgoal):\n 1. r1 = r2", "by auto"], ["proof (state)\nthis:\n  r1 = r2\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "ultimately"], ["proof (chain)\npicking this:\n  q1 = q2\n  r1 = r2", "show ?thesis"], ["proof (prove)\nusing this:\n  q1 = q2\n  r1 = r2\n\ngoal (1 subgoal):\n 1. q1 = q2 \\<and> r1 = r2", "by simp"], ["proof (state)\nthis:\n  q1 = q2 \\<and> r1 = r2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdivmod_eq_pdivmod_monic:\n  assumes g: \"monic g\"\n  shows \"pdivmod f g = pdivmod_monic f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "obtain q r where qr: \"pdivmod f g = (q,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        pdivmod f g = (q, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  pdivmod f g = (q, r)\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "obtain Q R where QR: \"pdivmod_monic f g = (Q,R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q R.\n        pdivmod_monic f g = (Q, R) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  pdivmod_monic f g = (Q, R)\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "have g0: \"g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "using g"], ["proof (prove)\nusing this:\n  monic g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "have f1: \"f = g * q + r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g * q + r", "by (metis Pair_inject mult_div_mod_eq qr)"], ["proof (state)\nthis:\n  f = g * q + r\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "have r: \"r=0 \\<or> degree r < degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree g", "by (metis Pair_inject assms degree_mod_less leading_coeff_0_iff qr zero_neq_one)"], ["proof (state)\nthis:\n  r = 0 \\<or> degree r < degree g\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "have f2: \"f = g * Q + R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g * Q + R", "by (simp add: QR assms pdivmod_monic(1))"], ["proof (state)\nthis:\n  f = g * Q + R\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "have R: \"R=0 \\<or> degree R < degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = 0 \\<or> degree R < degree g", "by (rule pdivmod_monic[OF g QR])"], ["proof (state)\nthis:\n  R = 0 \\<or> degree R < degree g\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "have \"q=Q \\<and> r=R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = Q \\<and> r = R", "by (rule uniqueness_algorithm_division_poly[OF f1 f2 g0 r R])"], ["proof (state)\nthis:\n  q = Q \\<and> r = R\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "thus ?thesis"], ["proof (prove)\nusing this:\n  q = Q \\<and> r = R\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "using qr QR"], ["proof (prove)\nusing this:\n  q = Q \\<and> r = R\n  pdivmod f g = (q, r)\n  pdivmod_monic f g = (Q, R)\n\ngoal (1 subgoal):\n 1. pdivmod f g = pdivmod_monic f g", "by auto"], ["proof (state)\nthis:\n  pdivmod f g = pdivmod_monic f g\n\ngoal:\nNo subgoals!", "qed"], ["", "context poly_mod\nbegin"], ["", "definition \"pdivmod2 f g = (if Mp g = 0 then (0, f)\n else let ilc = inverse_p m ((lead_coeff (Mp g))); \n      h = Polynomial.smult ilc (Mp g); (q, r) = pseudo_divmod (Mp f) (Mp h) \n      in (Polynomial.smult ilc q, r))\""], ["", "end"], ["", "context poly_mod_prime_type\nbegin"], ["", "lemma dvdm_iff_pdivmod0:\n  assumes f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\"\n  shows \"g dvdm f = (snd (pdivmod F G) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g dvdm f) = (snd (pdivmod F G) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g dvdm f) = (snd (pdivmod F G) = 0)", "have [transfer_rule]: \"MP_Rel f F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel f F", "unfolding MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = to_int_poly F", "by (simp add: Mp_f_representative f)"], ["proof (state)\nthis:\n  MP_Rel f F\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (snd (pdivmod F G) = 0)", "have [transfer_rule]: \"MP_Rel g G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel g G", "unfolding MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g = to_int_poly G", "by (simp add: Mp_f_representative g)"], ["proof (state)\nthis:\n  MP_Rel g G\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (snd (pdivmod F G) = 0)", "have \"(snd (pdivmod F G) = 0) = (G dvd F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd (pdivmod F G) = 0) = (G dvd F)", "unfolding dvd_eq_mod_eq_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd (pdivmod F G) = 0) = (F mod G = 0)", "by auto"], ["proof (state)\nthis:\n  (snd (pdivmod F G) = 0) = (G dvd F)\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (snd (pdivmod F G) = 0)", "from this [untransferred]"], ["proof (chain)\npicking this:\n  (snd (pdivmod F G) = 0) = (g dvdm f)", "show ?thesis"], ["proof (prove)\nusing this:\n  (snd (pdivmod F G) = 0) = (g dvdm f)\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (snd (pdivmod F G) = 0)", "by simp"], ["proof (state)\nthis:\n  (g dvdm f) = (snd (pdivmod F G) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_int_poly_Mp_0[simp]: \"(of_int_poly (Mp a) = (0:: 'a mod_ring poly)) = (Mp a = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_poly (Mp a) = 0) = (Mp a = 0)", "by (auto, metis Mp_f_representative map_poly_0 poly_mod.Mp_Mp)"], ["", "lemma uniqueness_algorithm_division_of_int_poly:\n  assumes g0: \"Mp g \\<noteq> 0\"\n  and f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\"\n  and F: \"F = G * Q + R\"\n  and R: \"R = 0 \\<or> degree R < degree G\"\n  and Mp_f: \"Mp f = Mp g * q + r\"\n  and r: \"r = 0 \\<or> degree r < degree (Mp g)\"\nshows \"Q = of_int_poly q \\<and> R = of_int_poly r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = of_int_poly q \\<and> R = of_int_poly r", "proof (rule uniqueness_algorithm_division_poly[OF F _ _ R])"], ["proof (state)\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have f': \"Mp f = to_int_poly F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = to_int_poly F", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = to_int_poly (of_int_poly f)", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  Mp f = to_int_poly F\n\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have g': \"Mp g = to_int_poly G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g = to_int_poly G", "unfolding g"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g = to_int_poly (of_int_poly g)", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  Mp g = to_int_poly G\n\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have f'': \"of_int_poly (Mp f) = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (Mp f) = F", "by (metis (no_types, lifting) Dp_Mp_eq Mp_f_representative \n        Mp_smult_m_0 add_cancel_left_right f map_poly_zero of_int_hom.map_poly_hom_add \n        to_int_mod_ring_hom.hom_zero to_int_mod_ring_hom.injectivity)"], ["proof (state)\nthis:\n  of_int_poly (Mp f) = F\n\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have g'': \"of_int_poly (Mp g) = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (Mp g) = G", "by (metis (no_types, lifting) Dp_Mp_eq Mp_f_representative \n        Mp_smult_m_0 add_cancel_left_right g map_poly_zero of_int_hom.map_poly_hom_add \n        to_int_mod_ring_hom.hom_zero to_int_mod_ring_hom.injectivity)"], ["proof (state)\nthis:\n  of_int_poly (Mp g) = G\n\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have \"F = of_int_poly (Mp g * q + r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = of_int_poly (Mp g * q + r)", "using Mp_f  f''"], ["proof (prove)\nusing this:\n  Mp f = Mp g * q + r\n  of_int_poly (Mp f) = F\n\ngoal (1 subgoal):\n 1. F = of_int_poly (Mp g * q + r)", "by auto"], ["proof (state)\nthis:\n  F = of_int_poly (Mp g * q + r)\n\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "also"], ["proof (state)\nthis:\n  F = of_int_poly (Mp g * q + r)\n\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have \"... = G * of_int_poly q + of_int_poly r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (Mp g * q + r) = G * of_int_poly q + of_int_poly r", "by (simp add: g'' of_int_poly_hom.hom_add of_int_poly_hom.hom_mult)"], ["proof (state)\nthis:\n  of_int_poly (Mp g * q + r) = G * of_int_poly q + of_int_poly r\n\ngoal (3 subgoals):\n 1. F = G * of_int_poly q + of_int_poly r\n 2. G \\<noteq> 0\n 3. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "finally"], ["proof (chain)\npicking this:\n  F = G * of_int_poly q + of_int_poly r", "show \"F = G * of_int_poly q + of_int_poly r\""], ["proof (prove)\nusing this:\n  F = G * of_int_poly q + of_int_poly r\n\ngoal (1 subgoal):\n 1. F = G * of_int_poly q + of_int_poly r", "."], ["proof (state)\nthis:\n  F = G * of_int_poly q + of_int_poly r\n\ngoal (2 subgoals):\n 1. G \\<noteq> 0\n 2. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "show \"of_int_poly r = 0 \\<or> degree (of_int_poly r::'a mod_ring poly) < degree G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "proof (cases \"r = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "case True"], ["proof (state)\nthis:\n  r = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "hence \"of_int_poly r = 0\""], ["proof (prove)\nusing this:\n  r = 0\n\ngoal (1 subgoal):\n 1. of_int_poly r = 0", "by auto"], ["proof (state)\nthis:\n  of_int_poly r = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "then"], ["proof (chain)\npicking this:\n  of_int_poly r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int_poly r = 0\n\ngoal (1 subgoal):\n 1. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "by auto"], ["proof (state)\nthis:\n  of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "case False"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have \"degree (of_int_poly r::'a mod_ring poly) \\<le> degree (r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (of_int_poly r) \\<le> degree r", "by (simp add: degree_map_poly_le)"], ["proof (state)\nthis:\n  degree (of_int_poly r) \\<le> degree r\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "also"], ["proof (state)\nthis:\n  degree (of_int_poly r) \\<le> degree r\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have \"... < degree (Mp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree r < degree_m g", "using r False"], ["proof (prove)\nusing this:\n  r = 0 \\<or> degree r < degree_m g\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree r < degree_m g", "by auto"], ["proof (state)\nthis:\n  degree r < degree_m g\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "also"], ["proof (state)\nthis:\n  degree r < degree_m g\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "have \"... = degree G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m g = degree G", "by (simp add: g')"], ["proof (state)\nthis:\n  degree_m g = degree G\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "finally"], ["proof (chain)\npicking this:\n  degree (of_int_poly r) < degree G", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (of_int_poly r) < degree G\n\ngoal (1 subgoal):\n 1. of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G", "by auto"], ["proof (state)\nthis:\n  of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_int_poly r = 0 \\<or> degree (of_int_poly r) < degree G\n\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "show \"G \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "using g0"], ["proof (prove)\nusing this:\n  Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "unfolding g''[symmetric]"], ["proof (prove)\nusing this:\n  Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly (Mp g) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  G \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary uniqueness_algorithm_division_to_int_poly:\n  assumes g0: \"Mp g \\<noteq> 0\"\n  and f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\"\n  and F: \"F = G * Q + R\"\n  and R: \"R = 0 \\<or> degree R < degree G\"\n  and Mp_f: \"Mp f = Mp g * q + r\"\n  and r: \"r = 0 \\<or> degree r < degree (Mp g)\"\n  shows \"Mp q = to_int_poly Q \\<and> Mp r = to_int_poly R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp q = to_int_poly Q \\<and> Mp r = to_int_poly R", "using uniqueness_algorithm_division_of_int_poly[OF assms]"], ["proof (prove)\nusing this:\n  Q = of_int_poly q \\<and> R = of_int_poly r\n\ngoal (1 subgoal):\n 1. Mp q = to_int_poly Q \\<and> Mp r = to_int_poly R", "by (auto simp add: Mp_f_representative)"], ["", "lemma uniqueness_algorithm_division_Mp_Rel: \n  assumes monic_Mpg: \"monic (Mp g)\"\n    and f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\"\n  and qr: \"pseudo_divmod (Mp f) (Mp g) = (q,r)\"\n  and QR: \"pseudo_divmod F G = (Q,R)\"\nshows \"MP_Rel q Q \\<and> MP_Rel r R \""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel q Q \\<and> MP_Rel r R", "proof (unfold MP_Rel_def, rule uniqueness_algorithm_division_to_int_poly[OF _ f g])"], ["proof (state)\ngoal (5 subgoals):\n 1. Mp g \\<noteq> 0\n 2. F = G * Q + R\n 3. R = 0 \\<or> degree R < degree G\n 4. Mp f = Mp g * q + r\n 5. r = 0 \\<or> degree r < degree_m g", "show f_gq_r: \"Mp f = Mp g * q + r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = Mp g * q + r", "by (rule pdivmod_monic(1)[OF monic_Mpg], simp add: pdivmod_monic_pseudo_divmod qr monic_Mpg)"], ["proof (state)\nthis:\n  Mp f = Mp g * q + r\n\ngoal (4 subgoals):\n 1. Mp g \\<noteq> 0\n 2. F = G * Q + R\n 3. R = 0 \\<or> degree R < degree G\n 4. r = 0 \\<or> degree r < degree_m g", "have monic_G: \"monic G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic G", "using monic_Mpg"], ["proof (prove)\nusing this:\n  monic (Mp g)\n\ngoal (1 subgoal):\n 1. monic G", "using Mp_f_representative g"], ["proof (prove)\nusing this:\n  monic (Mp g)\n  Mp ?f = to_int_poly (of_int_poly ?f)\n  G = of_int_poly g\n\ngoal (1 subgoal):\n 1. monic G", "by auto"], ["proof (state)\nthis:\n  monic G\n\ngoal (4 subgoals):\n 1. Mp g \\<noteq> 0\n 2. F = G * Q + R\n 3. R = 0 \\<or> degree R < degree G\n 4. r = 0 \\<or> degree r < degree_m g", "show \"F = G * Q + R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G * Q + R", "by (rule pdivmod_monic(1)[OF monic_G], simp add: pdivmod_monic_pseudo_divmod QR monic_G)"], ["proof (state)\nthis:\n  F = G * Q + R\n\ngoal (3 subgoals):\n 1. Mp g \\<noteq> 0\n 2. R = 0 \\<or> degree R < degree G\n 3. r = 0 \\<or> degree r < degree_m g", "show \"Mp g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g \\<noteq> 0", "using monic_Mpg"], ["proof (prove)\nusing this:\n  monic (Mp g)\n\ngoal (1 subgoal):\n 1. Mp g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Mp g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. R = 0 \\<or> degree R < degree G\n 2. r = 0 \\<or> degree r < degree_m g", "show \"R = 0 \\<or> degree R < degree G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = 0 \\<or> degree R < degree G", "by (rule pdivmod_monic(2)[OF monic_G], \n        auto simp add: pdivmod_monic_pseudo_divmod monic_G intro: QR)"], ["proof (state)\nthis:\n  R = 0 \\<or> degree R < degree G\n\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree_m g", "show \"r = 0 \\<or> degree r < degree (Mp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree_m g", "by (rule pdivmod_monic(2)[OF monic_Mpg], \n        auto simp add: pdivmod_monic_pseudo_divmod monic_Mpg intro: qr)"], ["proof (state)\nthis:\n  r = 0 \\<or> degree r < degree_m g\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"MP_Rel_Pair A B \\<equiv> (let (a,b) = A; (c,d) = B in MP_Rel a c \\<and> MP_Rel b d)\""], ["", "lemma pdivmod2_rel[transfer_rule]: \n  \"(MP_Rel ===> MP_Rel ===> MP_Rel_Pair) (pdivmod2) (pdivmod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> MP_Rel_Pair) pdivmod2 pdivmod", "proof (auto simp add: rel_fun_def MP_Rel_Pair_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel a (y div ya)\n 2. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel b (y mod ya)", "interpret pm: prime_field m"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field TYPE('a) m", "using m"], ["proof (prove)\nusing this:\n  m = int CARD('a)\n\ngoal (1 subgoal):\n 1. prime_field TYPE('a) m", "unfolding prime_field_def mod_ring_locale_def"], ["proof (prove)\nusing this:\n  m = int CARD('a)\n\ngoal (1 subgoal):\n 1. m = int CARD('a)", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel a (y div ya)\n 2. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel b (y mod ya)", "have p: \"prime_field TYPE('a) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field TYPE('a) m", "using m"], ["proof (prove)\nusing this:\n  m = int CARD('a)\n\ngoal (1 subgoal):\n 1. prime_field TYPE('a) m", "unfolding prime_field_def mod_ring_locale_def"], ["proof (prove)\nusing this:\n  m = int CARD('a)\n\ngoal (1 subgoal):\n 1. m = int CARD('a)", "by auto"], ["proof (state)\nthis:\n  prime_field TYPE('a) m\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel a (y div ya)\n 2. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel b (y mod ya)", "fix f F g G a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel a (y div ya)\n 2. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel b (y mod ya)", "assume 1[transfer_rule]: \"MP_Rel f F\" \n     and 2[transfer_rule]: \"MP_Rel g G\" \n     and 3: \"pdivmod2 f g = (a, b)\""], ["proof (state)\nthis:\n  MP_Rel f F\n  MP_Rel g G\n  pdivmod2 f g = (a, b)\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel a (y div ya)\n 2. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel b (y mod ya)", "have \"MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "proof (cases \"Mp g \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "case True"], ["proof (state)\nthis:\n  Mp g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "note Mp_g = True"], ["proof (state)\nthis:\n  Mp g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have G: \"G \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "using Mp_g 2"], ["proof (prove)\nusing this:\n  Mp g \\<noteq> 0\n  MP_Rel g G\n\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "unfolding MP_Rel_def"], ["proof (prove)\nusing this:\n  Mp g \\<noteq> 0\n  Mp g = to_int_poly G\n\ngoal (1 subgoal):\n 1. G \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  G \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have gG[transfer_rule]: \"pm.mod_ring_rel (lead_coeff (Mp g)) (lead_coeff G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm.mod_ring_rel (lead_coeff (Mp g)) (lead_coeff G)", "using 2"], ["proof (prove)\nusing this:\n  MP_Rel g G\n\ngoal (1 subgoal):\n 1. pm.mod_ring_rel (lead_coeff (Mp g)) (lead_coeff G)", "unfolding pm.mod_ring_rel_def MP_Rel_def"], ["proof (prove)\nusing this:\n  Mp g = to_int_poly G\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp g) = to_int_mod_ring (lead_coeff G)", "by auto"], ["proof (state)\nthis:\n  pm.mod_ring_rel (lead_coeff (Mp g)) (lead_coeff G)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have [transfer_rule]: \"(pm.mod_ring_rel ===> pm.mod_ring_rel) (inverse_p m) inverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pm.mod_ring_rel ===> pm.mod_ring_rel) (inverse_p m) inverse", "by (rule prime_field.mod_ring_inverse[OF p])"], ["proof (state)\nthis:\n  (pm.mod_ring_rel ===> pm.mod_ring_rel) (inverse_p m) inverse\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "hence rel_inverse_p[transfer_rule]: \n      \"pm.mod_ring_rel (inverse_p m ((lead_coeff (Mp g)))) (inverse (lead_coeff G))\""], ["proof (prove)\nusing this:\n  (pm.mod_ring_rel ===> pm.mod_ring_rel) (inverse_p m) inverse\n\ngoal (1 subgoal):\n 1. pm.mod_ring_rel (inverse_p m (lead_coeff (Mp g)))\n     (inverse (lead_coeff G))", "using gG"], ["proof (prove)\nusing this:\n  (pm.mod_ring_rel ===> pm.mod_ring_rel) (inverse_p m) inverse\n  pm.mod_ring_rel (lead_coeff (Mp g)) (lead_coeff G)\n\ngoal (1 subgoal):\n 1. pm.mod_ring_rel (inverse_p m (lead_coeff (Mp g)))\n     (inverse (lead_coeff G))", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     pm.mod_ring_rel x y \\<longrightarrow>\n     pm.mod_ring_rel (inverse_p m x) (inverse y)\n  pm.mod_ring_rel (lead_coeff (Mp g)) (lead_coeff G)\n\ngoal (1 subgoal):\n 1. pm.mod_ring_rel (inverse_p m (lead_coeff (Mp g)))\n     (inverse (lead_coeff G))", "by auto"], ["proof (state)\nthis:\n  pm.mod_ring_rel (inverse_p m (lead_coeff (Mp g))) (inverse (lead_coeff G))\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "let ?h= \"(Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g)\""], ["proof (state)\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "define h where h: \"h = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\""], ["proof (state)\nthis:\n  h = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "define H where H: \"H = Polynomial.smult (inverse (lead_coeff G)) G\""], ["proof (state)\nthis:\n  H = Polynomial.smult (inverse (lead_coeff G)) G\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have hH': \"MP_Rel ?h H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g) H", "unfolding MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g) =\n    to_int_poly H", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g) =\n    to_int_poly (Polynomial.smult (inverse (lead_coeff G)) G)", "by (metis (mono_tags, hide_lams) \"2\" MP_Rel_def M_to_int_mod_ring Mp_f_representative \n         rel_inverse_p functional_relation left_total_MP_Rel of_int_hom.map_poly_hom_smult \n         pm.mod_ring_rel_def right_unique_MP_Rel to_int_mod_ring_hom.injectivity to_int_mod_ring_of_int_M)"], ["proof (state)\nthis:\n  MP_Rel (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g) H\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have \"Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g) \n      = Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g =m\n    Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g =m\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "hence hH: \"MP_Rel h H\""], ["proof (prove)\nusing this:\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g =m\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\n\ngoal (1 subgoal):\n 1. MP_Rel h H", "using hH' h"], ["proof (prove)\nusing this:\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g =m\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\n  MP_Rel (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g) H\n  h = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\n\ngoal (1 subgoal):\n 1. MP_Rel h H", "unfolding MP_Rel_def"], ["proof (prove)\nusing this:\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g =m\n  Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\n  Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) g) = to_int_poly H\n  h = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)\n\ngoal (1 subgoal):\n 1. Mp h = to_int_poly H", "by auto"], ["proof (state)\nthis:\n  MP_Rel h H\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "obtain q x where pseudo_fh: \"pseudo_divmod (Mp f) (Mp h) = (q, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q x.\n        pseudo_divmod (Mp f) (Mp h) = (q, x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  pseudo_divmod (Mp f) (Mp h) = (q, x)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "hence lc_G: \"(lead_coeff G) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pseudo_divmod (Mp f) (Mp h) = (q, x)\n\ngoal (1 subgoal):\n 1. lead_coeff G \\<noteq> 0", "using G"], ["proof (prove)\nusing this:\n  pseudo_divmod (Mp f) (Mp h) = (q, x)\n  G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff G \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff G \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have a: \"a = Polynomial.smult (inverse_p m ((lead_coeff (Mp g)))) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q", "using 3 pseudo_fh Mp_g"], ["proof (prove)\nusing this:\n  pdivmod2 f g = (a, b)\n  pseudo_divmod (Mp f) (Mp h) = (q, x)\n  Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q", "unfolding pdivmod2_def Let_def h"], ["proof (prove)\nusing this:\n  (if Mp g = 0 then (0, f)\n   else case pseudo_divmod (Mp f)\n              (Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g)))\n                    (Mp g))) of\n        (q, x) \\<Rightarrow>\n          (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q, x)) =\n  (a, b)\n  pseudo_divmod (Mp f)\n   (Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g))) =\n  (q, x)\n  Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q", "by auto"], ["proof (state)\nthis:\n  a = Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have b: \"b = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = x", "using 3 pseudo_fh Mp_g"], ["proof (prove)\nusing this:\n  pdivmod2 f g = (a, b)\n  pseudo_divmod (Mp f) (Mp h) = (q, x)\n  Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b = x", "unfolding pdivmod2_def Let_def h"], ["proof (prove)\nusing this:\n  (if Mp g = 0 then (0, f)\n   else case pseudo_divmod (Mp f)\n              (Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g)))\n                    (Mp g))) of\n        (q, x) \\<Rightarrow>\n          (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q, x)) =\n  (a, b)\n  pseudo_divmod (Mp f)\n   (Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g))) =\n  (q, x)\n  Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b = x", "by auto"], ["proof (state)\nthis:\n  b = x\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have Mp_Rel_FH: \"MP_Rel q (F div H) \\<and> MP_Rel x (F mod H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel q (F div H) \\<and> MP_Rel x (F mod H)", "proof (rule uniqueness_algorithm_division_Mp_Rel)"], ["proof (state)\ngoal (5 subgoals):\n 1. monic (Mp ?g)\n 2. ?F = of_int_poly ?f\n 3. ?G = of_int_poly ?g\n 4. pseudo_divmod (Mp ?f) (Mp ?g) = (q, x)\n 5. pseudo_divmod ?F ?G = pdivmod F H", "show \"monic (Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (Mp h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monic (Mp h)", "have aux: \"(inverse_p m (lead_coeff (Mp g))) = to_int_mod_ring (inverse (lead_coeff G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_p m (lead_coeff (Mp g)) =\n    to_int_mod_ring (inverse (lead_coeff G))", "using rel_inverse_p"], ["proof (prove)\nusing this:\n  pm.mod_ring_rel (inverse_p m (lead_coeff (Mp g))) (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. inverse_p m (lead_coeff (Mp g)) =\n    to_int_mod_ring (inverse (lead_coeff G))", "unfolding pm.mod_ring_rel_def"], ["proof (prove)\nusing this:\n  inverse_p m (lead_coeff (Mp g)) = to_int_mod_ring (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. inverse_p m (lead_coeff (Mp g)) =\n    to_int_mod_ring (inverse (lead_coeff G))", "by auto"], ["proof (state)\nthis:\n  inverse_p m (lead_coeff (Mp g)) = to_int_mod_ring (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. monic (Mp h)", "hence \"M (inverse_p m (M (poly.coeff g (degree (Mp g))))) \n          = to_int_mod_ring (inverse (lead_coeff G))\""], ["proof (prove)\nusing this:\n  inverse_p m (lead_coeff (Mp g)) = to_int_mod_ring (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. M (inverse_p m (M (poly.coeff g (degree_m g)))) =\n    to_int_mod_ring (inverse (lead_coeff G))", "by (simp add: M_to_int_mod_ring Mp_coeff)"], ["proof (state)\nthis:\n  M (inverse_p m (M (poly.coeff g (degree_m g)))) =\n  to_int_mod_ring (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. monic (Mp h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  M (inverse_p m (M (poly.coeff g (degree_m g)))) =\n  to_int_mod_ring (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. monic (Mp h)", "unfolding h"], ["proof (prove)\nusing this:\n  M (inverse_p m (M (poly.coeff g (degree_m g)))) =\n  to_int_mod_ring (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. monic (Mp (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) (Mp g)))", "unfolding Mp_coeff"], ["proof (prove)\nusing this:\n  M (inverse_p m (M (poly.coeff g (degree_m g)))) =\n  to_int_mod_ring (inverse (lead_coeff G))\n\ngoal (1 subgoal):\n 1. M (poly.coeff\n        (Polynomial.smult (inverse_p m (M (poly.coeff g (degree_m g))))\n          (Mp g))\n        (degree_m\n          (Polynomial.smult (inverse_p m (M (poly.coeff g (degree_m g))))\n            (Mp g)))) =\n    1", "by auto\n          (metis (no_types, lifting) \"2\" H MP_Rel_def Mp_coeff aux degree_smult_eq gG hH' \n          inverse_zero_imp_zero lc_G left_inverse pm.mod_ring_rel_def to_int_mod_ring_hom.degree_map_poly_hom\n          to_int_mod_ring_hom.hom_one to_int_mod_ring_times)"], ["proof (state)\nthis:\n  monic (Mp h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monic (Mp h)\n\ngoal (4 subgoals):\n 1. ?F = of_int_poly ?f\n 2. ?G = of_int_poly h\n 3. pseudo_divmod (Mp ?f) (Mp h) = (q, x)\n 4. pseudo_divmod ?F ?G = pdivmod F H", "hence monic_H: \"monic H\""], ["proof (prove)\nusing this:\n  monic (Mp h)\n\ngoal (1 subgoal):\n 1. monic H", "using hH H lc_G"], ["proof (prove)\nusing this:\n  monic (Mp h)\n  MP_Rel h H\n  H = Polynomial.smult (inverse (lead_coeff G)) G\n  lead_coeff G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic H", "by auto"], ["proof (state)\nthis:\n  monic H\n\ngoal (4 subgoals):\n 1. ?F = of_int_poly ?f\n 2. ?G = of_int_poly h\n 3. pseudo_divmod (Mp ?f) (Mp h) = (q, x)\n 4. pseudo_divmod ?F ?G = pdivmod F H", "show f: \"F = of_int_poly f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = of_int_poly f", "using 1"], ["proof (prove)\nusing this:\n  MP_Rel f F\n\ngoal (1 subgoal):\n 1. F = of_int_poly f", "unfolding MP_Rel_def"], ["proof (prove)\nusing this:\n  Mp f = to_int_poly F\n\ngoal (1 subgoal):\n 1. F = of_int_poly f", "by (simp add: Mp_f_representative poly_eq_iff)"], ["proof (state)\nthis:\n  F = of_int_poly f\n\ngoal (3 subgoals):\n 1. ?G = of_int_poly h\n 2. pseudo_divmod (Mp f) (Mp h) = (q, x)\n 3. pseudo_divmod F ?G = pdivmod F H", "have \"pdivmod F H = pdivmod_monic F H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdivmod F H = pdivmod_monic F H", "by (rule pdivmod_eq_pdivmod_monic[OF monic_H])"], ["proof (state)\nthis:\n  pdivmod F H = pdivmod_monic F H\n\ngoal (3 subgoals):\n 1. ?G = of_int_poly h\n 2. pseudo_divmod (Mp f) (Mp h) = (q, x)\n 3. pseudo_divmod F ?G = pdivmod F H", "also"], ["proof (state)\nthis:\n  pdivmod F H = pdivmod_monic F H\n\ngoal (3 subgoals):\n 1. ?G = of_int_poly h\n 2. pseudo_divmod (Mp f) (Mp h) = (q, x)\n 3. pseudo_divmod F ?G = pdivmod F H", "have \"... = pseudo_divmod F H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdivmod_monic F H = pseudo_divmod F H", "by (rule pdivmod_monic_pseudo_divmod[OF monic_H])"], ["proof (state)\nthis:\n  pdivmod_monic F H = pseudo_divmod F H\n\ngoal (3 subgoals):\n 1. ?G = of_int_poly h\n 2. pseudo_divmod (Mp f) (Mp h) = (q, x)\n 3. pseudo_divmod F ?G = pdivmod F H", "finally"], ["proof (chain)\npicking this:\n  pdivmod F H = pseudo_divmod F H", "show \"pseudo_divmod F H = (F div H, F mod H)\""], ["proof (prove)\nusing this:\n  pdivmod F H = pseudo_divmod F H\n\ngoal (1 subgoal):\n 1. pseudo_divmod F H = pdivmod F H", "by simp"], ["proof (state)\nthis:\n  pseudo_divmod F H = pdivmod F H\n\ngoal (2 subgoals):\n 1. H = of_int_poly h\n 2. pseudo_divmod (Mp f) (Mp h) = (q, x)", "show \"H = of_int_poly h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = of_int_poly h", "by (meson MP_Rel_def Mp_f_representative hH right_unique_MP_Rel right_unique_def)"], ["proof (state)\nthis:\n  H = of_int_poly h\n\ngoal (1 subgoal):\n 1. pseudo_divmod (Mp f) (Mp h) = (q, x)", "show \"pseudo_divmod (Mp f) (Mp h) = (q, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_divmod (Mp f) (Mp h) = (q, x)", "by (rule pseudo_fh)"], ["proof (state)\nthis:\n  pseudo_divmod (Mp f) (Mp h) = (q, x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MP_Rel q (F div H) \\<and> MP_Rel x (F mod H)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "hence Mp_Rel_F_div_H: \"MP_Rel q (F div H)\" and Mp_Rel_F_mod_H: \"MP_Rel x (F mod H)\""], ["proof (prove)\nusing this:\n  MP_Rel q (F div H) \\<and> MP_Rel x (F mod H)\n\ngoal (1 subgoal):\n 1. MP_Rel q (F div H) &&& MP_Rel x (F mod H)", "by auto"], ["proof (state)\nthis:\n  MP_Rel q (F div H)\n  MP_Rel x (F mod H)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have \"F div H = Polynomial.smult (lead_coeff G) (F div G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F div H = Polynomial.smult (lead_coeff G) (F div G)", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. F div Polynomial.smult (inverse (lead_coeff G)) G =\n    Polynomial.smult (lead_coeff G) (F div G)", "using div_smult_right[OF lc_G] inverse_inverse_eq"], ["proof (prove)\nusing this:\n  ?x div Polynomial.smult (lead_coeff G) ?y =\n  Polynomial.smult (inverse (lead_coeff G)) (?x div ?y)\n  inverse (inverse ?a) = ?a\n\ngoal (1 subgoal):\n 1. F div Polynomial.smult (inverse (lead_coeff G)) G =\n    Polynomial.smult (lead_coeff G) (F div G)", "by (metis div_smult_right inverse_zero)"], ["proof (state)\nthis:\n  F div H = Polynomial.smult (lead_coeff G) (F div G)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "hence F_div_G: \"(F div G) = Polynomial.smult (inverse (lead_coeff G)) (F div H)\""], ["proof (prove)\nusing this:\n  F div H = Polynomial.smult (lead_coeff G) (F div G)\n\ngoal (1 subgoal):\n 1. F div G = Polynomial.smult (inverse (lead_coeff G)) (F div H)", "using lc_G"], ["proof (prove)\nusing this:\n  F div H = Polynomial.smult (lead_coeff G) (F div G)\n  lead_coeff G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. F div G = Polynomial.smult (inverse (lead_coeff G)) (F div H)", "by auto"], ["proof (state)\nthis:\n  F div G = Polynomial.smult (inverse (lead_coeff G)) (F div H)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have \"MP_Rel a (F div G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel a (F div G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MP_Rel a (F div G)", "have \"of_int_poly (Polynomial.smult (inverse_p m ((lead_coeff (Mp g)))) q) \n        = smult (inverse (lead_coeff G)) (F div H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q) =\n    Polynomial.smult (inverse (lead_coeff G)) (F div H)", "by (metis (mono_tags) MP_Rel_def M_to_int_mod_ring Mp_Rel_F_div_H Mp_f_representative \n            of_int_hom.map_poly_hom_smult pm.mod_ring_rel_def rel_inverse_p right_unique_MP_Rel \n            right_unique_def to_int_mod_ring_hom.injectivity to_int_mod_ring_of_int_M)"], ["proof (state)\nthis:\n  of_int_poly (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q) =\n  Polynomial.smult (inverse (lead_coeff G)) (F div H)\n\ngoal (1 subgoal):\n 1. MP_Rel a (F div G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  of_int_poly (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q) =\n  Polynomial.smult (inverse (lead_coeff G)) (F div H)\n\ngoal (1 subgoal):\n 1. MP_Rel a (F div G)", "using Mp_Rel_F_div_H"], ["proof (prove)\nusing this:\n  of_int_poly (Polynomial.smult (inverse_p m (lead_coeff (Mp g))) q) =\n  Polynomial.smult (inverse (lead_coeff G)) (F div H)\n  MP_Rel q (F div H)\n\ngoal (1 subgoal):\n 1. MP_Rel a (F div G)", "unfolding MP_Rel_def a F_div_G Mp_f_representative"], ["proof (prove)\nusing this:\n  of_int_poly\n   (Polynomial.smult\n     (inverse_p m (lead_coeff (to_int_poly (of_int_poly g)))) q) =\n  Polynomial.smult (inverse (lead_coeff G)) (F div H)\n  to_int_poly (of_int_poly q) = to_int_poly (F div H)\n\ngoal (1 subgoal):\n 1. to_int_poly\n     (of_int_poly\n       (Polynomial.smult\n         (inverse_p m (lead_coeff (to_int_poly (of_int_poly g)))) q)) =\n    to_int_poly (Polynomial.smult (inverse (lead_coeff G)) (F div H))", "by auto"], ["proof (state)\nthis:\n  MP_Rel a (F div G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MP_Rel a (F div G)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "moreover"], ["proof (state)\nthis:\n  MP_Rel a (F div G)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have \"MP_Rel b (F mod G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel b (F mod G)", "using Mp_Rel_F_mod_H b H inverse_zero_imp_zero lc_G"], ["proof (prove)\nusing this:\n  MP_Rel x (F mod H)\n  b = x\n  H = Polynomial.smult (inverse (lead_coeff G)) G\n  inverse ?a = (0::?'a) \\<Longrightarrow> ?a = (0::?'a)\n  lead_coeff G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MP_Rel b (F mod G)", "by (metis mod_smult_right)"], ["proof (state)\nthis:\n  MP_Rel b (F mod G)\n\ngoal (2 subgoals):\n 1. Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n 2. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "ultimately"], ["proof (chain)\npicking this:\n  MP_Rel a (F div G)\n  MP_Rel b (F mod G)", "show ?thesis"], ["proof (prove)\nusing this:\n  MP_Rel a (F div G)\n  MP_Rel b (F mod G)\n\ngoal (1 subgoal):\n 1. MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "by auto"], ["proof (state)\nthis:\n  MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "assume Mp_g_0: \"\\<not> Mp g \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "hence \"pdivmod2 f g = (0, f)\""], ["proof (prove)\nusing this:\n  \\<not> Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pdivmod2 f g = (0, f)", "unfolding pdivmod2_def"], ["proof (prove)\nusing this:\n  \\<not> Mp g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if Mp g = 0 then (0, f)\n     else let ilc = inverse_p m (lead_coeff (Mp g));\n              h = Polynomial.smult ilc (Mp g);\n              (q, y) = pseudo_divmod (Mp f) (Mp h)\n          in (Polynomial.smult ilc q, y)) =\n    (0, f)", "by auto"], ["proof (state)\nthis:\n  pdivmod2 f g = (0, f)\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "hence a: \"a = 0\" and b: \"b = f\""], ["proof (prove)\nusing this:\n  pdivmod2 f g = (0, f)\n\ngoal (1 subgoal):\n 1. a = 0 &&& b = f", "using 3"], ["proof (prove)\nusing this:\n  pdivmod2 f g = (0, f)\n  pdivmod2 f g = (a, b)\n\ngoal (1 subgoal):\n 1. a = 0 &&& b = f", "by auto"], ["proof (state)\nthis:\n  a = 0\n  b = f\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have G0: \"G = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G = 0", "using Mp_g_0 2"], ["proof (prove)\nusing this:\n  \\<not> Mp g \\<noteq> 0\n  MP_Rel g G\n\ngoal (1 subgoal):\n 1. G = 0", "unfolding MP_Rel_def"], ["proof (prove)\nusing this:\n  \\<not> Mp g \\<noteq> 0\n  Mp g = to_int_poly G\n\ngoal (1 subgoal):\n 1. G = 0", "by auto"], ["proof (state)\nthis:\n  G = 0\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have \"MP_Rel a (F div G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel a (F div G)", "unfolding MP_Rel_def G0 a"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp 0 = to_int_poly (F div 0)", "by auto"], ["proof (state)\nthis:\n  MP_Rel a (F div G)\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "moreover"], ["proof (state)\nthis:\n  MP_Rel a (F div G)\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "have \"MP_Rel b (F mod G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel b (F mod G)", "using 1"], ["proof (prove)\nusing this:\n  MP_Rel f F\n\ngoal (1 subgoal):\n 1. MP_Rel b (F mod G)", "unfolding MP_Rel_def G0 a b"], ["proof (prove)\nusing this:\n  Mp f = to_int_poly F\n\ngoal (1 subgoal):\n 1. Mp f = to_int_poly (F mod 0)", "by auto"], ["proof (state)\nthis:\n  MP_Rel b (F mod G)\n\ngoal (1 subgoal):\n 1. \\<not> Mp g \\<noteq> 0 \\<Longrightarrow>\n    MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "ultimately"], ["proof (chain)\npicking this:\n  MP_Rel a (F div G)\n  MP_Rel b (F mod G)", "show ?thesis"], ["proof (prove)\nusing this:\n  MP_Rel a (F div G)\n  MP_Rel b (F mod G)\n\ngoal (1 subgoal):\n 1. MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)", "by simp"], ["proof (state)\nthis:\n  MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel a (y div ya)\n 2. \\<And>x y xa ya a b.\n       \\<lbrakk>MP_Rel x y; MP_Rel xa ya; pdivmod2 x xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel b (y mod ya)", "thus \"MP_Rel a (F div G)\" and \"MP_Rel b (F mod G)\""], ["proof (prove)\nusing this:\n  MP_Rel a (F div G) \\<and> MP_Rel b (F mod G)\n\ngoal (1 subgoal):\n 1. MP_Rel a (F div G) &&& MP_Rel b (F mod G)", "by auto"], ["proof (state)\nthis:\n  MP_Rel a (F div G)\n  MP_Rel b (F mod G)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Executable division operation modulo $m$ for polynomials\\<close>"], ["", "lemma dvdm_iff_Mp_pdivmod2:\n  shows \"g dvdm f = (Mp (snd (pdivmod2 f g)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "let ?F=\"(of_int_poly f)::'a mod_ring poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "let ?G=\"(of_int_poly g)::'a mod_ring poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "have a[transfer_rule]: \"MP_Rel f ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel f (of_int_poly f)", "by (simp add: MP_Rel_def Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel f (of_int_poly f)\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "have b[transfer_rule]: \"MP_Rel g ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel g (of_int_poly g)", "by (simp add: MP_Rel_def Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel g (of_int_poly g)\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "have \"MP_Rel_Pair (pdivmod2 f g) (pdivmod ?F ?G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel_Pair (pdivmod2 f g) (pdivmod (of_int_poly f) (of_int_poly g))", "using pdivmod2_rel"], ["proof (prove)\nusing this:\n  (MP_Rel ===> MP_Rel ===> MP_Rel_Pair) pdivmod2 pdivmod\n\ngoal (1 subgoal):\n 1. MP_Rel_Pair (pdivmod2 f g) (pdivmod (of_int_poly f) (of_int_poly g))", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     MP_Rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         MP_Rel xa ya \\<longrightarrow>\n         MP_Rel_Pair (pdivmod2 x xa) (pdivmod y ya))\n\ngoal (1 subgoal):\n 1. MP_Rel_Pair (pdivmod2 f g) (pdivmod (of_int_poly f) (of_int_poly g))", "using a b"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     MP_Rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         MP_Rel xa ya \\<longrightarrow>\n         MP_Rel_Pair (pdivmod2 x xa) (pdivmod y ya))\n  MP_Rel f (of_int_poly f)\n  MP_Rel g (of_int_poly g)\n\ngoal (1 subgoal):\n 1. MP_Rel_Pair (pdivmod2 f g) (pdivmod (of_int_poly f) (of_int_poly g))", "by auto"], ["proof (state)\nthis:\n  MP_Rel_Pair (pdivmod2 f g) (pdivmod (of_int_poly f) (of_int_poly g))\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "hence \"MP_Rel (snd (pdivmod2 f g)) (snd (pdivmod ?F ?G))\""], ["proof (prove)\nusing this:\n  MP_Rel_Pair (pdivmod2 f g) (pdivmod (of_int_poly f) (of_int_poly g))\n\ngoal (1 subgoal):\n 1. MP_Rel (snd (pdivmod2 f g))\n     (snd (pdivmod (of_int_poly f) (of_int_poly g)))", "unfolding MP_Rel_Pair_def"], ["proof (prove)\nusing this:\n  let (a, b) = pdivmod2 f g;\n      (c, d) = pdivmod (of_int_poly f) (of_int_poly g)\n  in MP_Rel a c \\<and> MP_Rel b d\n\ngoal (1 subgoal):\n 1. MP_Rel (snd (pdivmod2 f g))\n     (snd (pdivmod (of_int_poly f) (of_int_poly g)))", "by auto"], ["proof (state)\nthis:\n  MP_Rel (snd (pdivmod2 f g))\n   (snd (pdivmod (of_int_poly f) (of_int_poly g)))\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "hence \"(Mp (snd (pdivmod2 f g)) = 0) = (snd (pdivmod ?F ?G) = 0)\""], ["proof (prove)\nusing this:\n  MP_Rel (snd (pdivmod2 f g))\n   (snd (pdivmod (of_int_poly f) (of_int_poly g)))\n\ngoal (1 subgoal):\n 1. (Mp (snd (pdivmod2 f g)) = 0) =\n    (snd (pdivmod (of_int_poly f) (of_int_poly g)) = 0)", "unfolding MP_Rel_def"], ["proof (prove)\nusing this:\n  Mp (snd (pdivmod2 f g)) =\n  to_int_poly (snd (pdivmod (of_int_poly f) (of_int_poly g)))\n\ngoal (1 subgoal):\n 1. (Mp (snd (pdivmod2 f g)) = 0) =\n    (snd (pdivmod (of_int_poly f) (of_int_poly g)) = 0)", "by auto"], ["proof (state)\nthis:\n  (Mp (snd (pdivmod2 f g)) = 0) =\n  (snd (pdivmod (of_int_poly f) (of_int_poly g)) = 0)\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (Mp (snd (pdivmod2 f g)) = 0) =\n  (snd (pdivmod (of_int_poly f) (of_int_poly g)) = 0)\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "using dvdm_iff_pdivmod0"], ["proof (prove)\nusing this:\n  (Mp (snd (pdivmod2 f g)) = 0) =\n  (snd (pdivmod (of_int_poly f) (of_int_poly g)) = 0)\n  \\<lbrakk>?F = of_int_poly ?f; ?G = of_int_poly ?g\\<rbrakk>\n  \\<Longrightarrow> (?g dvdm ?f) = (snd (pdivmod ?F ?G) = 0)\n\ngoal (1 subgoal):\n 1. (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)", "by auto"], ["proof (state)\nthis:\n  (g dvdm f) = (Mp (snd (pdivmod2 f g)) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas (in poly_mod_prime) dvdm_pdivmod = poly_mod_prime_type.dvdm_iff_Mp_pdivmod2\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, \n   unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemma (in poly_mod) dvdm_code:\n   \"g dvdm f = (if prime m then Mp (snd (pdivmod2 f g)) = 0 \n    else Code.abort (STR ''dvdm error: m is not a prime number'') (\\<lambda> _. g dvdm f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g dvdm f) =\n    (if prime m then Mp (snd (pdivmod2 f g)) = 0\n     else Code.abort STR ''dvdm error: m is not a prime number''\n           (\\<lambda>_. g dvdm f))", "using poly_mod_prime.dvdm_pdivmod[unfolded poly_mod_prime_def]"], ["proof (prove)\nusing this:\n  prime ?p \\<Longrightarrow>\n  poly_mod.dvdm ?p ?g ?f =\n  (poly_mod.Mp ?p (snd (poly_mod.pdivmod2 ?p ?f ?g)) = 0)\n\ngoal (1 subgoal):\n 1. (g dvdm f) =\n    (if prime m then Mp (snd (pdivmod2 f g)) = 0\n     else Code.abort STR ''dvdm error: m is not a prime number''\n           (\\<lambda>_. g dvdm f))", "by auto"], ["", "declare poly_mod.pdivmod2_def[code]"], ["", "declare poly_mod.dvdm_code[code]"], ["", "end"]]}