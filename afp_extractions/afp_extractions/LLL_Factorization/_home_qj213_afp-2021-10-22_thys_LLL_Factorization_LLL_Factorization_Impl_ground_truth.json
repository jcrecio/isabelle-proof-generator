{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Factorization/LLL_Factorization_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Factorization", "problem_names": ["lemma factorization_lattice_code[code]: \"factorization_lattice u k m = (\n  let n = degree u in\n map \n  (\\<lambda>i. vec_of_poly_n (monom_mult i u) (n+k)) [k>..0] \n  @ map (\\<lambda>i. vec_of_poly_n (monom m i) (n+k)) [n>..0]\n)\""], "translations": [["", "lemma factorization_lattice_code[code]: \"factorization_lattice u k m = (\n  let n = degree u in\n map \n  (\\<lambda>i. vec_of_poly_n (monom_mult i u) (n+k)) [k>..0] \n  @ map (\\<lambda>i. vec_of_poly_n (monom m i) (n+k)) [n>..0]\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_lattice u k m =\n    (let n = degree u\n     in map (\\<lambda>i. vec_of_poly_n (monom_mult i u) (n + k)) [k>..0] @\n        map (\\<lambda>i. vec_of_poly_n (monom m i) (n + k)) [n>..0])", "unfolding factorization_lattice_def monom_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. vec_of_poly_n (u * monom (1::'a) i) (degree u + k))\n     [k>..0] @\n    map (\\<lambda>i. vec_of_poly_n (monom m i) (degree u + k))\n     [degree u>..0] =\n    (let n = degree u\n     in map (\\<lambda>i. vec_of_poly_n (monom (1::'a) i * u) (n + k))\n         [k>..0] @\n        map (\\<lambda>i. vec_of_poly_n (monom m i) (n + k)) [n>..0])", "by (auto simp: ac_simps Let_def)"], ["", "text \\<open>Optimization: directly try to minimize coefficients of polynomial $u$.\\<close>"], ["", "definition LLL_short_polynomial where\n  \"LLL_short_polynomial pl n u = poly_of_vec (short_vector_hybrid 2 (factorization_lattice \n     (poly_mod.inv_Mp pl (poly_mod.Mp pl u)) (n - degree u) pl))\""], ["", "locale LLL_implementation =\n  fixes p pl :: int\nbegin"], ["", "function LLL_many_reconstruction where \n  \"LLL_many_reconstruction f us = (let \n     d = degree f;\n     d2 = d div 2;\n     f2_opt = find_map_filter \n        (\\<lambda> u. gcd f (LLL_short_polynomial pl (Suc d2) u)) \n        (\\<lambda> f2. let deg = degree f2 in deg > 0 \\<and> deg < d)\n        (filter (\\<lambda> u. degree u \\<le> d2) us)\n    in case f2_opt of None \\<Rightarrow> [f] \n    | Some f2 \\<Rightarrow> let f1 = f div f2;\n       (us1, us2) = List.partition (\\<lambda> gi. poly_mod.dvdm p gi f1) us\n       in LLL_many_reconstruction f1 us1 @ LLL_many_reconstruction f2 us2)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>f us. x = (f, us) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>f us fa usa.\n       (f, us) = (fa, usa) \\<Longrightarrow>\n       (let d = degree f; d2 = d div 2\n        in Let (find_map_filter\n                 (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc d2) u))\n                 (\\<lambda>f2.\n                     let deg = degree f2 in 0 < deg \\<and> deg < d)\n                 (filter (\\<lambda>u. degree u \\<le> d2) us))\n            (case_option [f]\n              (\\<lambda>f2.\n                  let f1 = f div f2;\n                      (us1, us2) =\n                        List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1)\n                         us\n                  in LLL_many_reconstruction_sumC (f1, us1) @\n                     LLL_many_reconstruction_sumC (f2, us2)))) =\n       (let d = degree fa; d2 = d div 2\n        in Let (find_map_filter\n                 (\\<lambda>u. gcd fa (LLL_short_polynomial pl (Suc d2) u))\n                 (\\<lambda>f2.\n                     let deg = degree f2 in 0 < deg \\<and> deg < d)\n                 (filter (\\<lambda>u. degree u \\<le> d2) usa))\n            (case_option [fa]\n              (\\<lambda>f2.\n                  let f1 = fa div f2;\n                      (us1, us2) =\n                        List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1)\n                         usa\n                  in LLL_many_reconstruction_sumC (f1, us1) @\n                     LLL_many_reconstruction_sumC (f2, us2))))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All LLL_many_reconstruction_dom", "proof (relation \"measure (\\<lambda> (f,us). degree f)\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)\n 3. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((x2, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "case (3 f us d d2 f2_opt f2 f1 pair us1 us2)"], ["proof (state)\nthis:\n  d = degree f\n  d2 = d div 2\n  f2_opt =\n  find_map_filter (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc d2) u))\n   (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < d)\n   (filter (\\<lambda>u. degree u \\<le> d2) us)\n  f2_opt = Some f2\n  f1 = f div f2\n  pair = List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1) us\n  (us1, us2) = pair\n\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)\n 3. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((x2, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "from find_map_filter_Some[OF 3(4)[unfolded 3(3) Let_def]] 3(1,5)"], ["proof (chain)\npicking this:\n  (0 < degree f2 \\<and> degree f2 < d) \\<and>\n  f2 \\<in> (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc d2) u)) `\n           set (filter (\\<lambda>u. degree u \\<le> d2) us)\n  d = degree f\n  f1 = f div f2", "show ?case"], ["proof (prove)\nusing this:\n  (0 < degree f2 \\<and> degree f2 < d) \\<and>\n  f2 \\<in> (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc d2) u)) `\n           set (filter (\\<lambda>u. degree u \\<le> d2) us)\n  d = degree f\n  f1 = f div f2\n\ngoal (1 subgoal):\n 1. ((f2, us2), f, us) \\<in> measure (\\<lambda>(f, us). degree f)", "by auto"], ["proof (state)\nthis:\n  ((f2, us2), f, us) \\<in> measure (\\<lambda>(f, us). degree f)\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "case (2 f us d d2 f2_opt f2 f1 pair us1 us2)"], ["proof (state)\nthis:\n  d = degree f\n  d2 = d div 2\n  f2_opt =\n  find_map_filter (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc d2) u))\n   (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < d)\n   (filter (\\<lambda>u. degree u \\<le> d2) us)\n  f2_opt = Some f2\n  f1 = f div f2\n  pair = List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1) us\n  (us1, us2) = pair\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "from find_map_filter_Some[OF 2(4)[unfolded 2(3) Let_def]] 2(1,5)"], ["proof (chain)\npicking this:\n  (0 < degree f2 \\<and> degree f2 < d) \\<and>\n  f2 \\<in> (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc d2) u)) `\n           set (filter (\\<lambda>u. degree u \\<le> d2) us)\n  d = degree f\n  f1 = f div f2", "have f: \"f = f1 * f2\" and f0: \"f \\<noteq> 0\" \n    and deg: \"degree f2 > 0\" \"degree f2 < degree f\""], ["proof (prove)\nusing this:\n  (0 < degree f2 \\<and> degree f2 < d) \\<and>\n  f2 \\<in> (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc d2) u)) `\n           set (filter (\\<lambda>u. degree u \\<le> d2) us)\n  d = degree f\n  f1 = f div f2\n\ngoal (1 subgoal):\n 1. f = f1 * f2 &&& f \\<noteq> 0 &&& 0 < degree f2 &&& degree f2 < degree f", "by auto"], ["proof (state)\nthis:\n  f = f1 * f2\n  f \\<noteq> 0\n  0 < degree f2\n  degree f2 < degree f\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "have \"degree f = degree f1 + degree f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = degree f1 + degree f2", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f = degree f1 + degree f2", "unfolding f"], ["proof (prove)\nusing this:\n  f1 * f2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (f1 * f2) = degree f1 + degree f2", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree f = degree f1 + degree f2\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb x2 xc xd xe y.\n       \\<lbrakk>x = degree f; xa = x div 2;\n        xb =\n        find_map_filter\n         (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n         (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n         (filter (\\<lambda>u. degree u \\<le> xa) us);\n        xb = Some x2; xc = f div x2;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "with deg"], ["proof (chain)\npicking this:\n  0 < degree f2\n  degree f2 < degree f\n  degree f = degree f1 + degree f2", "show ?case"], ["proof (prove)\nusing this:\n  0 < degree f2\n  degree f2 < degree f\n  degree f = degree f1 + degree f2\n\ngoal (1 subgoal):\n 1. ((f1, us1), f, us) \\<in> measure (\\<lambda>(f, us). degree f)", "by auto"], ["proof (state)\nthis:\n  ((f1, us1), f, us) \\<in> measure (\\<lambda>(f, us). degree f)\n\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(f, us). degree f))", "qed auto"], ["", "function LLL_reconstruction where \n  \"LLL_reconstruction f us = (let \n     d = degree f;\n     u = choose_u us;\n     g = LLL_short_polynomial pl d u;\n     f2 = gcd f g;\n     deg = degree f2\n    in if deg = 0 \\<or> deg \\<ge> d then [f] \n      else let f1 = f div f2;\n       (us1, us2) = List.partition (\\<lambda> gi. poly_mod.dvdm p gi f1) us\n       in LLL_reconstruction f1 us1 @ LLL_reconstruction f2 us2)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>f us. x = (f, us) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>f us fa usa.\n       (f, us) = (fa, usa) \\<Longrightarrow>\n       (let d = degree f; u = choose_u us; g = LLL_short_polynomial pl d u;\n            f2 = gcd f g; deg = degree f2\n        in if deg = 0 \\<or> d \\<le> deg then [f]\n           else let f1 = f div f2;\n                    (us1, us2) =\n                      List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1) us\n                in LLL_reconstruction_sumC (f1, us1) @\n                   LLL_reconstruction_sumC (f2, us2)) =\n       (let d = degree fa; u = choose_u usa;\n            g = LLL_short_polynomial pl d u; f2 = gcd fa g; deg = degree f2\n        in if deg = 0 \\<or> d \\<le> deg then [fa]\n           else let f1 = fa div f2;\n                    (us1, us2) =\n                      List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1)\n                       usa\n                in LLL_reconstruction_sumC (f1, us1) @\n                   LLL_reconstruction_sumC (f2, us2))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All LLL_reconstruction_dom", "proof (relation \"measure (\\<lambda> (f,us). degree f)\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)\n 3. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xaa, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "case (2 f us d u g f2 deg f1 pair us1 us2)"], ["proof (state)\nthis:\n  d = degree f\n  u = choose_u us\n  g = LLL_short_polynomial pl d u\n  f2 = gcd f g\n  deg = degree f2\n  \\<not> (deg = 0 \\<or> d \\<le> deg)\n  f1 = f div f2\n  pair = List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1) us\n  (us1, us2) = pair\n\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)\n 3. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xaa, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "hence f: \"f = f1 * f2\" and f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  d = degree f\n  u = choose_u us\n  g = LLL_short_polynomial pl d u\n  f2 = gcd f g\n  deg = degree f2\n  \\<not> (deg = 0 \\<or> d \\<le> deg)\n  f1 = f div f2\n  pair = List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1) us\n  (us1, us2) = pair\n\ngoal (1 subgoal):\n 1. f = f1 * f2 &&& f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f = f1 * f2\n  f \\<noteq> 0\n\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)\n 3. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xaa, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "have deg: \"degree f = degree f1 + degree f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = degree f1 + degree f2", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f = degree f1 + degree f2", "unfolding f"], ["proof (prove)\nusing this:\n  f1 * f2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (f1 * f2) = degree f1 + degree f2", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree f = degree f1 + degree f2\n\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)\n 3. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xaa, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "from 2"], ["proof (chain)\npicking this:\n  d = degree f\n  u = choose_u us\n  g = LLL_short_polynomial pl d u\n  f2 = gcd f g\n  deg = degree f2\n  \\<not> (deg = 0 \\<or> d \\<le> deg)\n  f1 = f div f2\n  pair = List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1) us\n  (us1, us2) = pair", "have \"degree f2 > 0\" \"degree f2 < degree f\""], ["proof (prove)\nusing this:\n  d = degree f\n  u = choose_u us\n  g = LLL_short_polynomial pl d u\n  f2 = gcd f g\n  deg = degree f2\n  \\<not> (deg = 0 \\<or> d \\<le> deg)\n  f1 = f div f2\n  pair = List.partition (\\<lambda>gi. poly_mod.dvdm p gi f1) us\n  (us1, us2) = pair\n\ngoal (1 subgoal):\n 1. 0 < degree f2 &&& degree f2 < degree f", "by auto"], ["proof (state)\nthis:\n  0 < degree f2\n  degree f2 < degree f\n\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xc, xe), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)\n 3. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xaa, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "thus ?case"], ["proof (prove)\nusing this:\n  0 < degree f2\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. ((f1, us1), f, us) \\<in> measure (\\<lambda>(f, us). degree f)", "using deg"], ["proof (prove)\nusing this:\n  0 < degree f2\n  degree f2 < degree f\n  degree f = degree f1 + degree f2\n\ngoal (1 subgoal):\n 1. ((f1, us1), f, us) \\<in> measure (\\<lambda>(f, us). degree f)", "by auto"], ["proof (state)\nthis:\n  ((f1, us1), f, us) \\<in> measure (\\<lambda>(f, us). degree f)\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(f, us). degree f))\n 2. \\<And>f us x xa xb xaa xab xc xd xe y.\n       \\<lbrakk>x = degree f; xa = choose_u us;\n        xb = LLL_short_polynomial pl x xa; xaa = gcd f xb; xab = degree xaa;\n        \\<not> (xab = 0 \\<or> x \\<le> xab); xc = f div xaa;\n        xd = List.partition (\\<lambda>gi. poly_mod.dvdm p gi xc) us;\n        (xe, y) = xd\\<rbrakk>\n       \\<Longrightarrow> ((xaa, y), f, us)\n                         \\<in> measure (\\<lambda>(f, us). degree f)", "qed auto"], ["", "end"], ["", "declare LLL_implementation.LLL_reconstruction.simps[code]"], ["", "declare LLL_implementation.LLL_many_reconstruction.simps[code]"], ["", "definition LLL_factorization :: \"int poly \\<Rightarrow> int poly list\" where\n  \"LLL_factorization f = (let \n     \\<comment> \\<open>find suitable prime\\<close>\n     p = suitable_prime_bz f;\n     \\<comment> \\<open>compute finite field factorization\\<close>\n     (_, fs) = finite_field_factorization_int p f;\n     \\<comment> \\<open>determine exponent l and B\\<close>\n     n = degree f;\n     no = \\<parallel>f\\<parallel>\\<^sup>2;\n     B = sqrt_int_ceiling (2^(5 * (n - 1) * (n - 1)) * no^(2 * (n - 1)));\n     l = find_exponent p B;\n     \\<comment> \\<open>perform hensel lifting to lift factorization to mod $p^l$\\<close>\n     us = hensel_lifting p l f fs;\n     \\<comment> \\<open>reconstruct integer factors via LLL algorithm\\<close>\n     pl = p^l\n   in LLL_implementation.LLL_reconstruction p pl f us)\""], ["", "definition LLL_many_factorization :: \"int poly \\<Rightarrow> int poly list\" where\n  \"LLL_many_factorization f = (let \n     \\<comment> \\<open>find suitable prime\\<close>\n     p = suitable_prime_bz f;\n     \\<comment> \\<open>compute finite field factorization\\<close>\n     (_, fs) = finite_field_factorization_int p f;\n     \\<comment> \\<open>determine exponent l and B\\<close>\n     n = degree f;\n     no = \\<parallel>f\\<parallel>\\<^sup>2;\n     B = sqrt_int_ceiling (2^(5 * (n div 2) * (n div 2)) * no^(2 * (n div 2)));\n     l = find_exponent p B;\n     \\<comment> \\<open>perform hensel lifting to lift factorization to mod $p^l$\\<close>\n     us = hensel_lifting p l f fs;\n     \\<comment> \\<open>reconstruct integer factors via LLL algorithm\\<close>\n     pl = p^l\n   in LLL_implementation.LLL_many_reconstruction p pl f us)\""], ["", "end"]]}