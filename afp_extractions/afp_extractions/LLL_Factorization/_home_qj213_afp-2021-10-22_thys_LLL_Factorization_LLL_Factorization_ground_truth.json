{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Factorization/LLL_Factorization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Factorization", "problem_names": ["lemma nth_factorization_lattice:\n  fixes u and d\n  defines \"n \\<equiv> degree u\"\n  assumes \"i < n + d\"\n  shows \"factorization_lattice u d m ! i =\n    vec_of_poly_n (if i < d then u * monom 1 (d - Suc i) else monom m (n+d-Suc i)) (n+d)\"", "lemma length_factorization_lattice[simp]: \n  shows \"length (factorization_lattice u d m) = degree u + d\"", "lemma dim_factorization_lattice:\n  assumes \"x < degree u + d\" \n  shows \"dim_vec (factorization_lattice u d m ! x) = degree u + d\"", "lemma dim_factorization_lattice_element: \n  assumes \"x \\<in> set (factorization_lattice u d m)\" shows \"dim_vec x = degree u + d\"", "lemma set_factorization_lattice_in_carrier[simp]: \"set (factorization_lattice u d m) \\<subseteq> carrier_vec (degree u + d)\"", "lemma choose_u_Cons: \"choose_u (x#xs) = \n  (if xs = [] then x else min_degree_poly x (choose_u xs))\"", "lemma choose_u_member: \"xs \\<noteq> [] \\<Longrightarrow> choose_u xs \\<in> set xs\"", "lemma (in LLL) lattice_is_span [simp]: \"lattice_of xs = span_list xs\"", "lemma sq_norm_row_sylvester_mat1:\n  fixes f g :: \"'a :: conjugatable_ring poly\"\n  assumes i: \"i < degree g\"\n  shows \"\\<parallel>(row (sylvester_mat f g) i)\\<parallel>\\<^sup>2 = \\<parallel>f\\<parallel>\\<^sup>2\"", "lemma sq_norm_row_sylvester_mat2:\n  fixes f g :: \"'a :: conjugatable_ring poly\"\n  assumes i1: \"degree g \\<le> i\" and i2: \"i < degree f + degree g\"\n  shows \"\\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 = \\<parallel>g\\<parallel>\\<^sup>2\"", "lemma Hadamard's_inequality_int:\n  fixes A::\"int mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows \"\\<bar>det A\\<bar> \\<le> sqrt (of_int (prod_list (map sq_norm (rows A))))\"", "lemma resultant_le_prod_sq_norm:\n  fixes f g::\"int poly\"\n  defines \"n \\<equiv> degree f\" and \"k \\<equiv> degree g\"\n  shows \"\\<bar>resultant f g\\<bar> \\<le> sqrt (of_int (\\<parallel>f\\<parallel>\\<^sup>2^k * \\<parallel>g\\<parallel>\\<^sup>2^n))\"", "lemma common_factor_via_short:\n  fixes f g u :: \"int poly\"\n  defines \"n \\<equiv> degree f\" and \"k \\<equiv> degree g\"\n  assumes n0: \"n > 0\" and k0: \"k > 0\"\n      and monic: \"monic u\" and deg_u: \"degree u > 0\"\n      and uf: \"poly_mod.dvdm m u f\" and ug: \"poly_mod.dvdm m u g\"\n      and short: \"\\<parallel>f\\<parallel>\\<^sup>2^k * \\<parallel>g\\<parallel>\\<^sup>2^n < m\\<^sup>2\" \n      and m: \"m \\<ge> 0\"\n    shows \"degree (gcd f g) > 0\"", "lemma factorization_lattice_as_sylvester:\n  fixes p :: \"'a :: semidom poly\"\n  assumes dj: \"d \\<le> j\" and d: \"degree p = d\"   \n  shows \"mat_of_rows j (factorization_lattice p (j-d) m) = sylvester_mat_sub d (j-d) p [:m:]\"", "lemma map_poly_hom_mult_monom [hom_distribs]:\n  \"map_poly hom (p * monom a n) = map_poly hom p * monom (hom a) n\"", "lemma hom_vec_of_poly_n [hom_distribs]:\n  \"map_vec hom (vec_of_poly_n p n) = vec_of_poly_n (map_poly hom p) n\"", "lemma hom_factorization_lattice [hom_distribs]:\n  shows \"map (map_vec hom) (factorization_lattice u k m) = factorization_lattice (map_poly hom u) k (hom m)\"", "lemma upper_triangular_factorization_lattice:\n  fixes u :: \"'a :: semidom poly\" and d :: nat\n  assumes d: \"d \\<le> n\" and du: \"d = degree u\"\n  shows \"upper_triangular (mat_of_rows n (factorization_lattice u (n-d) k))\"\n    (is \"upper_triangular ?M\")", "lemma factorization_lattice_diag_nonzero:\n  fixes u :: \"'a :: semidom poly\" and d\n  assumes d: \"d=degree u\" \n    and dn: \"d\\<le>n\"\n    and u: \"u\\<noteq>0\" \n    and m0: \"k\\<noteq>0\"\n    and i: \"i<n\"\n  shows \"(factorization_lattice u (n-d) k) ! i $ i \\<noteq> 0\"", "lemma lin_indpt_list_factorization_lattice: fixes d\n  assumes d: \"d = degree u\" and dn: \"d \\<le> n\" and u: \"u \\<noteq> 0\" and k: \"k \\<noteq> 0\"\n  shows \"gs.lin_indpt_list (RAT (factorization_lattice u (n-d) k))\" (is \"gs.lin_indpt_list (RAT ?vs)\")", "lemma (in semiring_hom) hom_poly_of_vec: \"map_poly hom (poly_of_vec v) = poly_of_vec (map_vec hom v)\"", "lemma lincomb_to_dvd_modulo:\n  fixes u d\n  defines \"d \\<equiv> degree u\"\n  assumes d: \"d \\<le> n\"\n      and lincomb: \"lincomb_list c (factorization_lattice u (n-d) k) = g\" (is \"?l = ?r\")\n  shows \"poly_mod.dvdm k u (poly_of_vec g)\"", "lemma dvd_modulo_to_lincomb:\n  fixes u :: \"int poly\" and d\n  defines \"d \\<equiv> degree u\"\n  assumes d: \"d < n\"\n      and dvd: \"poly_mod.dvdm k u (poly_of_vec g)\"\n      and k_not0: \"k\\<noteq>0\"\n      and monic_u: \"monic u\"\n      and dim_g: \"dim_vec g = n\"\n      and deg_u: \"degree u > 0\"      \n  shows \"\\<exists>c. lincomb_list c (factorization_lattice u (n-d) k) = g\"", "lemma factorization_lattice: fixes M assumes  \n  deg_u: \"degree u \\<noteq> 0\"  and M: \"M \\<noteq> 0\" \nshows \"degree u \\<le> n \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> f \\<in> poly_of_vec ` lattice_of (factorization_lattice u (n - degree u) M) \\<Longrightarrow> \n  degree f < n \\<and> poly_mod.dvdm M u f\" \n  \"monic u \\<Longrightarrow> degree u < n \\<Longrightarrow> \n  degree f < n \\<Longrightarrow> poly_mod.dvdm M u f \\<Longrightarrow> f \\<in> poly_of_vec ` lattice_of (factorization_lattice u (n - degree u) M)\"", "lemma LLL_short_polynomial: assumes deg_u_0: \"degree u \\<noteq> 0\" and deg_le: \"degree u \\<le> n\" \n  and pl1: \"pl > 1\" \n  and monic: \"monic u\" \nshows \"degree (LLL_short_polynomial pl n u) < n\" \n  and \"LLL_short_polynomial pl n u \\<noteq> 0\"\n  and \"poly_mod.dvdm pl u (LLL_short_polynomial pl n u)\" \n  and \"degree u < n \\<Longrightarrow> f \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.dvdm pl u f \\<Longrightarrow> degree f < n \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2 \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2\"", "lemma LLL_reconstruction: assumes \"LLL_reconstruction f us = fs\"\n  and \"degree f \\<noteq> 0\"\n  and \"poly_mod.unique_factorization_m pl f (lead_coeff f, mset us)\"\n  and \"f dvd F\" \n  and \"\\<And> ui. ui \\<in> set us \\<Longrightarrow> poly_mod.Mp pl ui = ui\" \n  and F0: \"F \\<noteq> 0\" \n  and cop: \"coprime (lead_coeff F) p\" \n  and sf: \"poly_mod.square_free_m p F\" \n  and pl1: \"pl > 1\" \n  and plp: \"pl = p^l\" \n  and p: \"prime p\" \n  and large: \"2^(5 * (degree F - 1) * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2^(2 * (degree F - 1)) < pl\\<^sup>2\"\nshows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\"", "lemma LLL_many_reconstruction: assumes \"LLL_many_reconstruction f us = fs\"\n  and \"degree f \\<noteq> 0\"\n  and \"poly_mod.unique_factorization_m pl f (lead_coeff f, mset us)\"\n  and \"f dvd F\" \n  and \"\\<And> ui. ui \\<in> set us \\<Longrightarrow> poly_mod.Mp pl ui = ui\" \n  and F0: \"F \\<noteq> 0\" \n  and cop: \"coprime (lead_coeff F) p\" \n  and sf: \"poly_mod.square_free_m p F\" \n  and pl1: \"pl > 1\" \n  and plp: \"pl = p^l\" \n  and p: \"prime p\" \n  and large: \"2^(5 * (degree F div 2) * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2^(2 * (degree F div 2)) < pl\\<^sup>2\"\nshows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\"", "lemma LLL_factorization:\n  assumes res: \"LLL_factorization f = gs\"\n  and sff: \"square_free f\"\n  and deg: \"degree f \\<noteq> 0\" \n  shows \"f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)\"", "lemma LLL_many_factorization:\n  assumes res: \"LLL_many_factorization f = gs\"\n  and sff: \"square_free f\"\n  and deg: \"degree f \\<noteq> 0\" \n  shows \"f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)\"", "lemma LLL_factorization_primitive: assumes \"LLL_factorization f = fs\"\n  \"square_free f\" \n  \"0 < degree f\" \n  \"primitive f\" \nshows \"f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible fi \\<and> 0 < degree fi \\<and> primitive fi)\""], "translations": [["", "lemma nth_factorization_lattice:\n  fixes u and d\n  defines \"n \\<equiv> degree u\"\n  assumes \"i < n + d\"\n  shows \"factorization_lattice u d m ! i =\n    vec_of_poly_n (if i < d then u * monom 1 (d - Suc i) else monom m (n+d-Suc i)) (n+d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_lattice u d m ! i =\n    vec_of_poly_n\n     (if i < d then u * monom (1::'a) (d - Suc i)\n      else monom m (n + d - Suc i))\n     (n + d)", "using assms"], ["proof (prove)\nusing this:\n  n \\<equiv> degree u\n  i < n + d\n\ngoal (1 subgoal):\n 1. factorization_lattice u d m ! i =\n    vec_of_poly_n\n     (if i < d then u * monom (1::'a) (d - Suc i)\n      else monom m (n + d - Suc i))\n     (n + d)", "by (unfold factorization_lattice_def, auto simp: nth_append smult_monom Let_def not_less)"], ["", "lemma length_factorization_lattice[simp]: \n  shows \"length (factorization_lattice u d m) = degree u + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (factorization_lattice u d m) = degree u + d", "by (auto simp: factorization_lattice_def Let_def)"], ["", "lemma dim_factorization_lattice:\n  assumes \"x < degree u + d\" \n  shows \"dim_vec (factorization_lattice u d m ! x) = degree u + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (factorization_lattice u d m ! x) = degree u + d", "unfolding factorization_lattice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     ((map (\\<lambda>i. vec_of_poly_n (u * monom (1::'a) i) (degree u + d))\n        [d>..0] @\n       map (\\<lambda>i. vec_of_poly_n (monom m i) (degree u + d))\n        [degree u>..0]) !\n      x) =\n    degree u + d", "using assms nth_append"], ["proof (prove)\nusing this:\n  x < degree u + d\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n\ngoal (1 subgoal):\n 1. dim_vec\n     ((map (\\<lambda>i. vec_of_poly_n (u * monom (1::'a) i) (degree u + d))\n        [d>..0] @\n       map (\\<lambda>i. vec_of_poly_n (monom m i) (degree u + d))\n        [degree u>..0]) !\n      x) =\n    degree u + d", "by (simp add: nth_append Let_def)"], ["", "lemma dim_factorization_lattice_element: \n  assumes \"x \\<in> set (factorization_lattice u d m)\" shows \"dim_vec x = degree u + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = degree u + d", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set (factorization_lattice u d m)\n\ngoal (1 subgoal):\n 1. dim_vec x = degree u + d", "by (auto simp: factorization_lattice_def Let_def)"], ["", "lemma set_factorization_lattice_in_carrier[simp]: \"set (factorization_lattice u d m) \\<subseteq> carrier_vec (degree u + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (factorization_lattice u d m) \\<subseteq> carrier_vec (degree u + d)", "using dim_factorization_lattice"], ["proof (prove)\nusing this:\n  ?x < degree ?u + ?d \\<Longrightarrow>\n  dim_vec (factorization_lattice ?u ?d ?m ! ?x) = degree ?u + ?d\n\ngoal (1 subgoal):\n 1. set (factorization_lattice u d m) \\<subseteq> carrier_vec (degree u + d)", "by (auto simp: factorization_lattice_def Let_def)"], ["", "lemma choose_u_Cons: \"choose_u (x#xs) = \n  (if xs = [] then x else min_degree_poly x (choose_u xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_u (x # xs) =\n    (if xs = [] then x else min_degree_poly x (choose_u xs))", "by (cases xs, auto)"], ["", "lemma choose_u_member: \"xs \\<noteq> [] \\<Longrightarrow> choose_u xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> choose_u xs \\<in> set xs", "by (induct xs, auto simp: choose_u_Cons)"], ["", "declare choose_u.simps[simp del]"], ["", "subsection \\<open>Facts about Sylvester matrices and norms\\<close>"], ["", "lemma (in LLL) lattice_is_span [simp]: \"lattice_of xs = span_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of xs = span_list xs", "by (unfold lattice_of_def span_list_def lincomb_list_def image_def, auto)"], ["", "lemma sq_norm_row_sylvester_mat1:\n  fixes f g :: \"'a :: conjugatable_ring poly\"\n  assumes i: \"i < degree g\"\n  shows \"\\<parallel>(row (sylvester_mat f g) i)\\<parallel>\\<^sup>2 = \\<parallel>f\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "by (auto simp add: sylvester_mat_def row_def sq_norm_vec_def o_def\n        interv_sum_list_conv_sum_set_nat i intro!: sum_list_zero)"], ["proof (state)\nthis:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "note f = False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "let ?f = \"\\<lambda>j. if i \\<le> j \\<and> j - i \\<le> degree f then coeff f (degree f + i - j) else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "let ?h = \"\\<lambda>j. j + i\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "let ?row = \"vec (degree f + degree g) ?f \""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "let ?g = \"\\<lambda>j. degree f - j\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have image_g: \"?g ` {0..<Suc (degree f)} = {0..<Suc (degree f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (-) (degree f) ` {0..<Suc (degree f)} = {0..<Suc (degree f)}", "by (auto simp add: image_def) \n       (metis (no_types, hide_lams) Nat.add_diff_assoc add.commute add_diff_cancel_left' \n        atLeastLessThan_iff diff_Suc_Suc diff_Suc_less less_Suc_eq_le zero_le)"], ["proof (state)\nthis:\n  (-) (degree f) ` {0..<Suc (degree f)} = {0..<Suc (degree f)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have bij_h: \"bij_betw ?h {0..<Suc (degree f)} {i..< Suc (degree f + i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>j. j + i) {0..<Suc (degree f)}\n     {i..<Suc (degree f + i)}", "unfolding bij_betw_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>j. j + i) {0..<Suc (degree f)} \\<and>\n    {y. \\<exists>x\\<in>{0..<Suc (degree f)}. y = x + i} =\n    {i..<Suc (degree f + i)}", "by (auto, metis atLeastLessThan_iff le_add_diff_inverse2 \n        less_diff_conv linorder_not_less not_less_eq zero_order(3))"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>j. j + i) {0..<Suc (degree f)} {i..<Suc (degree f + i)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"\\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 = \\<parallel>?row\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>vec (degree f + degree g)\n                (\\<lambda>j.\n                    if i \\<le> j \\<and> j - i \\<le> degree f\n                    then coeff f (degree f + i - j)\n                    else (0::'a))\\<parallel>\\<^sup>2", "by (rule arg_cong[of _ _ \"sq_norm_vec\"], insert i, \n        auto simp add: row_def sylvester_mat_def sylvester_mat_sub_def)"], ["proof (state)\nthis:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i \\<le> j \\<and> j - i \\<le> degree f\n                  then coeff f (degree f + i - j)\n                  else (0::'a))\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i \\<le> j \\<and> j - i \\<le> degree f\n                  then coeff f (degree f + i - j)\n                  else (0::'a))\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum_list (map (sq_norm \\<circ> ?f) [0..<degree f + degree g])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>vec (degree f + degree g)\n                (\\<lambda>j.\n                    if i \\<le> j \\<and> j - i \\<le> degree f\n                    then coeff f (degree f + i - j)\n                    else (0::'a))\\<parallel>\\<^sup>2 =\n    sum_list\n     (map (sq_norm \\<circ>\n           (\\<lambda>j.\n               if i \\<le> j \\<and> j - i \\<le> degree f\n               then coeff f (degree f + i - j) else (0::'a)))\n       [0..<degree f + degree g])", "unfolding sq_norm_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map sq_norm\n       (list_of_vec\n         (vec (degree f + degree g)\n           (\\<lambda>j.\n               if i \\<le> j \\<and> j - i \\<le> degree f\n               then coeff f (degree f + i - j) else (0::'a))))) =\n    sum_list\n     (map (sq_norm \\<circ>\n           (\\<lambda>j.\n               if i \\<le> j \\<and> j - i \\<le> degree f\n               then coeff f (degree f + i - j) else (0::'a)))\n       [0..<degree f + degree g])", "by auto"], ["proof (state)\nthis:\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i \\<le> j \\<and> j - i \\<le> degree f\n                  then coeff f (degree f + i - j)\n                  else (0::'a))\\<parallel>\\<^sup>2 =\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     [0..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i \\<le> j \\<and> j - i \\<le> degree f\n                  then coeff f (degree f + i - j)\n                  else (0::'a))\\<parallel>\\<^sup>2 =\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     [0..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum (sq_norm \\<circ> ?f) {0..<degree f + degree g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map (sq_norm \\<circ>\n           (\\<lambda>j.\n               if i \\<le> j \\<and> j - i \\<le> degree f\n               then coeff f (degree f + i - j) else (0::'a)))\n       [0..<degree f + degree g]) =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     {0..<degree f + degree g}", "unfolding interv_sum_list_conv_sum_set_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     (set [0..<degree f + degree g]) =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     {0..<degree f + degree g}", "by auto"], ["proof (state)\nthis:\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     [0..<degree f + degree g]) =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {0..<degree f + degree g}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     [0..<degree f + degree g]) =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {0..<degree f + degree g}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum (sq_norm \\<circ> ?f) {i..< Suc (degree f + i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     {0..<degree f + degree g} =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     {i..<Suc (degree f + i)}", "by (rule sum.mono_neutral_right, insert i, auto)"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {0..<degree f + degree g} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {i..<Suc (degree f + i)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {0..<degree f + degree g} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {i..<Suc (degree f + i)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum ((sq_norm \\<circ> ?f) \\<circ> ?h) {0..<Suc (degree f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)))\n     {i..<Suc (degree f + i)} =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)) \\<circ>\n         (\\<lambda>j. j + i))\n     {0..<Suc (degree f)}", "by (unfold o_def, rule sum.reindex_bij_betw[symmetric, OF bij_h])"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {i..<Suc (degree f + i)} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i))\n   {0..<Suc (degree f)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)))\n   {i..<Suc (degree f + i)} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i))\n   {0..<Suc (degree f)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum (\\<lambda>j. sq_norm (coeff f (degree f - j))) {0..<Suc (degree f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i \\<le> j \\<and> j - i \\<le> degree f\n             then coeff f (degree f + i - j) else (0::'a)) \\<circ>\n         (\\<lambda>j. j + i))\n     {0..<Suc (degree f)} =\n    (\\<Sum>j = 0..<Suc (degree f).\n        sq_norm_conjugate (coeff f (degree f - j)))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i))\n   {0..<Suc (degree f)} =\n  (\\<Sum>j = 0..<Suc (degree f). sq_norm_conjugate (coeff f (degree f - j)))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i \\<le> j \\<and> j - i \\<le> degree f\n           then coeff f (degree f + i - j) else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i))\n   {0..<Suc (degree f)} =\n  (\\<Sum>j = 0..<Suc (degree f). sq_norm_conjugate (coeff f (degree f - j)))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum ((\\<lambda>j. sq_norm (coeff f j)) \\<circ> ?g) {0..<Suc (degree f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<Suc (degree f).\n        sq_norm_conjugate (coeff f (degree f - j))) =\n    sum ((\\<lambda>j. sq_norm_conjugate (coeff f j)) \\<circ> (-) (degree f))\n     {0..<Suc (degree f)}", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<Suc (degree f).\n        sq_norm_conjugate (coeff f (degree f - j))) =\n    (\\<Sum>x = 0..<Suc (degree f).\n        sq_norm_conjugate (coeff f (degree f - x)))", ".."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<Suc (degree f).\n      sq_norm_conjugate (coeff f (degree f - j))) =\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff f j)) \\<circ> (-) (degree f))\n   {0..<Suc (degree f)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<Suc (degree f).\n      sq_norm_conjugate (coeff f (degree f - j))) =\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff f j)) \\<circ> (-) (degree f))\n   {0..<Suc (degree f)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum (\\<lambda>j. sq_norm (coeff f j)) (?g ` {0..<Suc (degree f)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j. sq_norm_conjugate (coeff f j)) \\<circ> (-) (degree f))\n     {0..<Suc (degree f)} =\n    (\\<Sum>j\\<in>(-) (degree f) ` {0..<Suc (degree f)}.\n       sq_norm_conjugate (coeff f j))", "by (rule sum.reindex[symmetric], auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff f j)) \\<circ> (-) (degree f))\n   {0..<Suc (degree f)} =\n  (\\<Sum>j\\<in>(-) (degree f) ` {0..<Suc (degree f)}.\n     sq_norm_conjugate (coeff f j))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff f j)) \\<circ> (-) (degree f))\n   {0..<Suc (degree f)} =\n  (\\<Sum>j\\<in>(-) (degree f) ` {0..<Suc (degree f)}.\n     sq_norm_conjugate (coeff f j))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>(-) (degree f) ` {0..<Suc (degree f)}.\n       sq_norm_conjugate (coeff f j)) =\n    sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)}", "unfolding image_g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<Suc (degree f). sq_norm_conjugate (coeff f j)) =\n    sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)}", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>(-) (degree f) ` {0..<Suc (degree f)}.\n     sq_norm_conjugate (coeff f j)) =\n  sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>(-) (degree f) ` {0..<Suc (degree f)}.\n     sq_norm_conjugate (coeff f j)) =\n  sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "have \"... = sum_list (map sq_norm (coeffs f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)} =\n    sum_list (map sq_norm (coeffs f))", "unfolding coeffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)} =\n    sum_list\n     (map sq_norm\n       (if f = 0 then [] else map (coeff f) [0..<Suc (degree f)]))", "using f"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)} =\n    sum_list\n     (map sq_norm\n       (if f = 0 then [] else map (coeff f) [0..<Suc (degree f)]))", "by (simp add: interv_sum_list_conv_sum_set_nat)"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ> coeff f) {0..<Suc (degree f)} =\n  sum_list (map sq_norm (coeffs f))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  sum_list (map sq_norm (coeffs f))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  sum_list (map sq_norm (coeffs f))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>f\\<parallel>\\<^sup>2", "unfolding sq_norm_poly_def"], ["proof (prove)\nusing this:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  sum_list (map sq_norm (coeffs f))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    sum_list (map sq_norm (coeffs f))", "by auto"], ["proof (state)\nthis:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sq_norm_row_sylvester_mat2:\n  fixes f g :: \"'a :: conjugatable_ring poly\"\n  assumes i1: \"degree g \\<le> i\" and i2: \"i < degree f + degree g\"\n  shows \"\\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 = \\<parallel>g\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "let ?f = \"\\<lambda>j. if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j) else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "let ?row = \"vec (degree f + degree g) ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "let ?h = \"\\<lambda>j. j + i - degree g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "let ?g = \"\\<lambda>j. degree g - j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have image_g: \"?g ` {0..<Suc (degree g)} = {0..<Suc (degree g)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (-) (degree g) ` {0..<Suc (degree g)} = {0..<Suc (degree g)}", "by (auto simp add: image_def)\n       (metis atLeastLessThan_iff diff_diff_cancel diff_le_self less_Suc_eq_le zero_le)"], ["proof (state)\nthis:\n  (-) (degree g) ` {0..<Suc (degree g)} = {0..<Suc (degree g)}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have x: \"x - (i - degree g) \\<le> degree g\" if x: \"x < Suc i\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - (i - degree g) \\<le> degree g", "using x"], ["proof (prove)\nusing this:\n  x < Suc i\n\ngoal (1 subgoal):\n 1. x - (i - degree g) \\<le> degree g", "by auto"], ["proof (state)\nthis:\n  ?x < Suc i \\<Longrightarrow> ?x - (i - degree g) \\<le> degree g\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have bij_h: \"bij_betw ?h {0..<Suc (degree g)} {i - degree g..<Suc i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>j. j + i - degree g) {0..<Suc (degree g)}\n     {i - degree g..<Suc i}", "unfolding bij_betw_def inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<Suc (degree g)}.\n        \\<forall>y\\<in>{0..<Suc (degree g)}.\n           x + i - degree g = y + i - degree g \\<longrightarrow>\n           x = y) \\<and>\n    (\\<lambda>j. j + i - degree g) ` {0..<Suc (degree g)} =\n    {i - degree g..<Suc i}", "using i1 i2"], ["proof (prove)\nusing this:\n  degree g \\<le> i\n  i < degree f + degree g\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<Suc (degree g)}.\n        \\<forall>y\\<in>{0..<Suc (degree g)}.\n           x + i - degree g = y + i - degree g \\<longrightarrow>\n           x = y) \\<and>\n    (\\<lambda>j. j + i - degree g) ` {0..<Suc (degree g)} =\n    {i - degree g..<Suc i}", "unfolding image_def"], ["proof (prove)\nusing this:\n  degree g \\<le> i\n  i < degree f + degree g\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<Suc (degree g)}.\n        \\<forall>y\\<in>{0..<Suc (degree g)}.\n           x + i - degree g = y + i - degree g \\<longrightarrow>\n           x = y) \\<and>\n    {y. \\<exists>x\\<in>{0..<Suc (degree g)}. y = x + i - degree g} =\n    {i - degree g..<Suc i}", "by (auto, metis (no_types) Nat.add_diff_assoc atLeastLessThan_iff x less_Suc_eq_le \n        less_eq_nat.simps(1) ordered_cancel_comm_monoid_diff_class.diff_add)"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>j. j + i - degree g) {0..<Suc (degree g)}\n   {i - degree g..<Suc i}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"\\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 = \\<parallel>?row\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>vec (degree f + degree g)\n                (\\<lambda>j.\n                    if i - degree g \\<le> j \\<and> j \\<le> i\n                    then coeff g (i - j) else (0::'a))\\<parallel>\\<^sup>2", "by (rule arg_cong[of _ _ \"sq_norm_vec\"], insert i1 i2, \n        auto simp add: row_def sylvester_mat_def sylvester_mat_sub_def)"], ["proof (state)\nthis:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i - degree g \\<le> j \\<and> j \\<le> i\n                  then coeff g (i - j) else (0::'a))\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i - degree g \\<le> j \\<and> j \\<le> i\n                  then coeff g (i - j) else (0::'a))\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum_list (map (sq_norm \\<circ> ?f) [0..<degree f + degree g])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>vec (degree f + degree g)\n                (\\<lambda>j.\n                    if i - degree g \\<le> j \\<and> j \\<le> i\n                    then coeff g (i - j) else (0::'a))\\<parallel>\\<^sup>2 =\n    sum_list\n     (map (sq_norm \\<circ>\n           (\\<lambda>j.\n               if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n               else (0::'a)))\n       [0..<degree f + degree g])", "unfolding sq_norm_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map sq_norm\n       (list_of_vec\n         (vec (degree f + degree g)\n           (\\<lambda>j.\n               if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n               else (0::'a))))) =\n    sum_list\n     (map (sq_norm \\<circ>\n           (\\<lambda>j.\n               if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n               else (0::'a)))\n       [0..<degree f + degree g])", "by auto"], ["proof (state)\nthis:\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i - degree g \\<le> j \\<and> j \\<le> i\n                  then coeff g (i - j) else (0::'a))\\<parallel>\\<^sup>2 =\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     [0..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>vec (degree f + degree g)\n              (\\<lambda>j.\n                  if i - degree g \\<le> j \\<and> j \\<le> i\n                  then coeff g (i - j) else (0::'a))\\<parallel>\\<^sup>2 =\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     [0..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum (sq_norm \\<circ> ?f) {0..<degree f + degree g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map (sq_norm \\<circ>\n           (\\<lambda>j.\n               if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n               else (0::'a)))\n       [0..<degree f + degree g]) =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     {0..<degree f + degree g}", "unfolding interv_sum_list_conv_sum_set_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     (set [0..<degree f + degree g]) =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     {0..<degree f + degree g}", "by auto"], ["proof (state)\nthis:\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     [0..<degree f + degree g]) =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {0..<degree f + degree g}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum_list\n   (map (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     [0..<degree f + degree g]) =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {0..<degree f + degree g}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum (sq_norm \\<circ> ?f) {i - degree g..< Suc i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     {0..<degree f + degree g} =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     {i - degree g..<Suc i}", "by (rule sum.mono_neutral_right, insert i2, auto)"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {0..<degree f + degree g} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {i - degree g..<Suc i}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {0..<degree f + degree g} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {i - degree g..<Suc i}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum ((sq_norm \\<circ> ?f) \\<circ> ?h) {0..<Suc (degree g)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)))\n     {i - degree g..<Suc i} =\n    sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)) \\<circ>\n         (\\<lambda>j. j + i - degree g))\n     {0..<Suc (degree g)}", "by (unfold o_def, rule sum.reindex_bij_betw[symmetric, OF bij_h])"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {i - degree g..<Suc i} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i - degree g))\n   {0..<Suc (degree g)}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)))\n   {i - degree g..<Suc i} =\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i - degree g))\n   {0..<Suc (degree g)}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum (\\<lambda>j. sq_norm (coeff g (degree g - j))) {0..<Suc (degree g)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ>\n         (\\<lambda>j.\n             if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n             else (0::'a)) \\<circ>\n         (\\<lambda>j. j + i - degree g))\n     {0..<Suc (degree g)} =\n    (\\<Sum>j = 0..<Suc (degree g).\n        sq_norm_conjugate (coeff g (degree g - j)))", "by (rule sum.cong, insert i1, auto)"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i - degree g))\n   {0..<Suc (degree g)} =\n  (\\<Sum>j = 0..<Suc (degree g). sq_norm_conjugate (coeff g (degree g - j)))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ>\n       (\\<lambda>j.\n           if i - degree g \\<le> j \\<and> j \\<le> i then coeff g (i - j)\n           else (0::'a)) \\<circ>\n       (\\<lambda>j. j + i - degree g))\n   {0..<Suc (degree g)} =\n  (\\<Sum>j = 0..<Suc (degree g). sq_norm_conjugate (coeff g (degree g - j)))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum ((\\<lambda>j. sq_norm (coeff g j)) \\<circ> ?g) {0..<Suc (degree g)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<Suc (degree g).\n        sq_norm_conjugate (coeff g (degree g - j))) =\n    sum ((\\<lambda>j. sq_norm_conjugate (coeff g j)) \\<circ> (-) (degree g))\n     {0..<Suc (degree g)}", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<Suc (degree g).\n        sq_norm_conjugate (coeff g (degree g - j))) =\n    (\\<Sum>x = 0..<Suc (degree g).\n        sq_norm_conjugate (coeff g (degree g - x)))", ".."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<Suc (degree g).\n      sq_norm_conjugate (coeff g (degree g - j))) =\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff g j)) \\<circ> (-) (degree g))\n   {0..<Suc (degree g)}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<Suc (degree g).\n      sq_norm_conjugate (coeff g (degree g - j))) =\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff g j)) \\<circ> (-) (degree g))\n   {0..<Suc (degree g)}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum (\\<lambda>j. sq_norm (coeff g j)) (?g ` {0..<Suc (degree g)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j. sq_norm_conjugate (coeff g j)) \\<circ> (-) (degree g))\n     {0..<Suc (degree g)} =\n    (\\<Sum>j\\<in>(-) (degree g) ` {0..<Suc (degree g)}.\n       sq_norm_conjugate (coeff g j))", "by (rule sum.reindex[symmetric], auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff g j)) \\<circ> (-) (degree g))\n   {0..<Suc (degree g)} =\n  (\\<Sum>j\\<in>(-) (degree g) ` {0..<Suc (degree g)}.\n     sq_norm_conjugate (coeff g j))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>j. sq_norm_conjugate (coeff g j)) \\<circ> (-) (degree g))\n   {0..<Suc (degree g)} =\n  (\\<Sum>j\\<in>(-) (degree g) ` {0..<Suc (degree g)}.\n     sq_norm_conjugate (coeff g j))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>(-) (degree g) ` {0..<Suc (degree g)}.\n       sq_norm_conjugate (coeff g j)) =\n    sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)}", "unfolding image_g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<Suc (degree g). sq_norm_conjugate (coeff g j)) =\n    sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)}", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>(-) (degree g) ` {0..<Suc (degree g)}.\n     sq_norm_conjugate (coeff g j)) =\n  sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>(-) (degree g) ` {0..<Suc (degree g)}.\n     sq_norm_conjugate (coeff g j)) =\n  sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)}\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "have \"... = sum_list (map sq_norm (coeffs g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)} =\n    sum_list (map sq_norm (coeffs g))", "unfolding coeffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)} =\n    sum_list\n     (map sq_norm\n       (if g = 0 then [] else map (coeff g) [0..<Suc (degree g)]))", "by (simp add: interv_sum_list_conv_sum_set_nat)"], ["proof (state)\nthis:\n  sum (sq_norm \\<circ> coeff g) {0..<Suc (degree g)} =\n  sum_list (map sq_norm (coeffs g))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  sum_list (map sq_norm (coeffs g))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  sum_list (map sq_norm (coeffs g))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    \\<parallel>g\\<parallel>\\<^sup>2", "unfolding sq_norm_poly_def"], ["proof (prove)\nusing this:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  sum_list (map sq_norm (coeffs g))\n\ngoal (1 subgoal):\n 1. \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n    sum_list (map sq_norm (coeffs g))", "by auto"], ["proof (state)\nthis:\n  \\<parallel>row (sylvester_mat f g) i\\<parallel>\\<^sup>2 =\n  \\<parallel>g\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hadamard's_inequality_int:\n  fixes A::\"int mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows \"\\<bar>det A\\<bar> \\<le> sqrt (of_int (prod_list (map sq_norm (rows A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "let ?A = \"map_mat real_of_int A\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "have \"\\<bar>det A\\<bar> = \\<bar>det ?A\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar> = \\<bar>det (of_int_hom.mat_hom A)\\<bar>", "unfolding of_int_hom.hom_det"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar> = \\<bar>real_of_int (det A)\\<bar>", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>det A\\<bar> = \\<bar>det (of_int_hom.mat_hom A)\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>det A\\<bar> = \\<bar>det (of_int_hom.mat_hom A)\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "have \"\\<dots> \\<le> sqrt (prod_list (map sq_norm (rows ?A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>det (of_int_hom.mat_hom A)\\<bar>\n    \\<le> sqrt (prod_list (map sq_norm (rows (of_int_hom.mat_hom A))))", "by (rule Hadamard's_inequality[of ?A n], insert A, auto)"], ["proof (state)\nthis:\n  \\<bar>det (of_int_hom.mat_hom A)\\<bar>\n  \\<le> sqrt (prod_list (map sq_norm (rows (of_int_hom.mat_hom A))))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "also"], ["proof (state)\nthis:\n  \\<bar>det (of_int_hom.mat_hom A)\\<bar>\n  \\<le> sqrt (prod_list (map sq_norm (rows (of_int_hom.mat_hom A))))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "have \"\\<dots> = sqrt (of_int (prod_list (map sq_norm (rows A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (prod_list (map sq_norm (rows (of_int_hom.mat_hom A)))) =\n    sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "unfolding of_int_hom.hom_prod_list map_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (prod_list (map sq_norm (rows (of_int_hom.mat_hom A)))) =\n    sqrt (prod_list (map (real_of_int \\<circ> sq_norm) (rows A)))", "by (rule arg_cong[of _ _ \"\\<lambda> x. sqrt (prod_list x)\"], rule nth_equalityI, force, \n      auto simp: sq_norm_of_int[symmetric] row_def intro!: arg_cong[of _ _ sq_norm_vec])"], ["proof (state)\nthis:\n  sqrt (prod_list (map sq_norm (rows (of_int_hom.mat_hom A)))) =\n  sqrt (real_of_int (prod_list (map sq_norm (rows A))))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>det A\\<bar>\n  \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>det A\\<bar>\n  \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det A\\<bar>\n    \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))", "."], ["proof (state)\nthis:\n  real_of_int \\<bar>det A\\<bar>\n  \\<le> sqrt (real_of_int (prod_list (map sq_norm (rows A))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resultant_le_prod_sq_norm:\n  fixes f g::\"int poly\"\n  defines \"n \\<equiv> degree f\" and \"k \\<equiv> degree g\"\n  shows \"\\<bar>resultant f g\\<bar> \\<le> sqrt (of_int (\\<parallel>f\\<parallel>\\<^sup>2^k * \\<parallel>g\\<parallel>\\<^sup>2^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "let ?S = \"sylvester_mat f g\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "let ?f = \"sq_norm \\<circ> row ?S\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have map_rw1: \"map ?f [0..<degree g] = replicate k \\<parallel>f\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) =\n    length (replicate k \\<parallel>f\\<parallel>\\<^sup>2)\n 2. \\<And>i.\n       i < length\n            (map (sq_norm \\<circ> row (sylvester_mat f g))\n              [0..<degree g]) \\<Longrightarrow>\n       map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n       replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "let ?M = \"map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]\""], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) =\n    length (replicate k \\<parallel>f\\<parallel>\\<^sup>2)\n 2. \\<And>i.\n       i < length\n            (map (sq_norm \\<circ> row (sylvester_mat f g))\n              [0..<degree g]) \\<Longrightarrow>\n       map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n       replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "show \"length ?M = length (replicate k \\<parallel>f\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) =\n    length (replicate k \\<parallel>f\\<parallel>\\<^sup>2)", "using k_def"], ["proof (prove)\nusing this:\n  k \\<equiv> degree g\n\ngoal (1 subgoal):\n 1. length (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) =\n    length (replicate k \\<parallel>f\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  length (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) =\n  length (replicate k \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (sq_norm \\<circ> row (sylvester_mat f g))\n              [0..<degree g]) \\<Longrightarrow>\n       map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n       replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "show \"?M ! i = replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i\" if i: \"i < length ?M\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "have ik: \"i<k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k", "using i k_def"], ["proof (prove)\nusing this:\n  i < length (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g])\n  k \\<equiv> degree g\n\ngoal (1 subgoal):\n 1. i < k", "by auto"], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "hence i_deg_g: \"i < degree g\""], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i < degree g", "using k_def"], ["proof (prove)\nusing this:\n  i < k\n  k \\<equiv> degree g\n\ngoal (1 subgoal):\n 1. i < degree g", "by auto"], ["proof (state)\nthis:\n  i < degree g\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "have \"replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i = \\<parallel>f\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i =\n    \\<parallel>f\\<parallel>\\<^sup>2", "by (rule nth_replicate[OF ik])"], ["proof (state)\nthis:\n  replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i =\n  \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "also"], ["proof (state)\nthis:\n  replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i =\n  \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "have \"... = (sq_norm \\<circ> row (sylvester_mat f g)) (0 + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f\\<parallel>\\<^sup>2 =\n    (sq_norm \\<circ> row (sylvester_mat f g)) (0 + i)", "using sq_norm_row_sylvester_mat1 ik k_def"], ["proof (prove)\nusing this:\n  ?i < degree ?g \\<Longrightarrow>\n  \\<parallel>row (sylvester_mat ?f ?g) ?i\\<parallel>\\<^sup>2 =\n  \\<parallel>?f\\<parallel>\\<^sup>2\n  i < k\n  k \\<equiv> degree g\n\ngoal (1 subgoal):\n 1. \\<parallel>f\\<parallel>\\<^sup>2 =\n    (sq_norm \\<circ> row (sylvester_mat f g)) (0 + i)", "by force"], ["proof (state)\nthis:\n  \\<parallel>f\\<parallel>\\<^sup>2 =\n  (sq_norm \\<circ> row (sylvester_mat f g)) (0 + i)\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "also"], ["proof (state)\nthis:\n  \\<parallel>f\\<parallel>\\<^sup>2 =\n  (sq_norm \\<circ> row (sylvester_mat f g)) (0 + i)\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "have \"... = ?M ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sq_norm \\<circ> row (sylvester_mat f g)) (0 + i) =\n    map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i", "by (rule nth_map_upt[symmetric], simp add: i_deg_g)"], ["proof (state)\nthis:\n  (sq_norm \\<circ> row (sylvester_mat f g)) (0 + i) =\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", "finally"], ["proof (chain)\npicking this:\n  replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i =\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i", "show \"?M ! i = replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i\""], ["proof (prove)\nusing this:\n  replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i =\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n    replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i", ".."], ["proof (state)\nthis:\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! i =\n  replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length\n        (map (sq_norm \\<circ> row (sylvester_mat f g))\n          [0..<degree g]) \\<Longrightarrow>\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] ! ?i =\n  replicate k \\<parallel>f\\<parallel>\\<^sup>2 ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g] =\n  replicate k \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have map_rw2: \"map ?f [degree g..<degree f + degree g] = replicate n \\<parallel>g\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (map (sq_norm \\<circ> row (sylvester_mat f g))\n       [degree g..<degree f + degree g]) =\n    length (replicate n \\<parallel>g\\<parallel>\\<^sup>2)\n 2. \\<And>i.\n       i < length\n            (map (sq_norm \\<circ> row (sylvester_mat f g))\n              [degree g..<degree f + degree g]) \\<Longrightarrow>\n       map (sq_norm \\<circ> row (sylvester_mat f g))\n        [degree g..<degree f + degree g] !\n       i =\n       replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "let ?M = \"map (sq_norm \\<circ> row (sylvester_mat f g)) [degree g..<degree f + degree g]\""], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (map (sq_norm \\<circ> row (sylvester_mat f g))\n       [degree g..<degree f + degree g]) =\n    length (replicate n \\<parallel>g\\<parallel>\\<^sup>2)\n 2. \\<And>i.\n       i < length\n            (map (sq_norm \\<circ> row (sylvester_mat f g))\n              [degree g..<degree f + degree g]) \\<Longrightarrow>\n       map (sq_norm \\<circ> row (sylvester_mat f g))\n        [degree g..<degree f + degree g] !\n       i =\n       replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "show \"length ?M = length (replicate n \\<parallel>g\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (sq_norm \\<circ> row (sylvester_mat f g))\n       [degree g..<degree f + degree g]) =\n    length (replicate n \\<parallel>g\\<parallel>\\<^sup>2)", "by (simp add: n_def)"], ["proof (state)\nthis:\n  length\n   (map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g]) =\n  length (replicate n \\<parallel>g\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (sq_norm \\<circ> row (sylvester_mat f g))\n              [degree g..<degree f + degree g]) \\<Longrightarrow>\n       map (sq_norm \\<circ> row (sylvester_mat f g))\n        [degree g..<degree f + degree g] !\n       i =\n       replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "show \"?M ! i = replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i\" if \"i<length ?M\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "have i_n: \"i<n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n", "using n_def that"], ["proof (prove)\nusing this:\n  n \\<equiv> degree f\n  i < length\n       (map (sq_norm \\<circ> row (sylvester_mat f g))\n         [degree g..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "hence i_deg_f: \"i < degree f\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. i < degree f", "using n_def"], ["proof (prove)\nusing this:\n  i < n\n  n \\<equiv> degree f\n\ngoal (1 subgoal):\n 1. i < degree f", "by auto"], ["proof (state)\nthis:\n  i < degree f\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "have \"replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i = \\<parallel>g\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i =\n    \\<parallel>g\\<parallel>\\<^sup>2", "by (rule nth_replicate[OF i_n])"], ["proof (state)\nthis:\n  replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i =\n  \\<parallel>g\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "also"], ["proof (state)\nthis:\n  replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i =\n  \\<parallel>g\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "have \"... = (sq_norm \\<circ> row (sylvester_mat f g)) (degree g + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>g\\<parallel>\\<^sup>2 =\n    (sq_norm \\<circ> row (sylvester_mat f g)) (degree g + i)", "using i_n n_def"], ["proof (prove)\nusing this:\n  i < n\n  n \\<equiv> degree f\n\ngoal (1 subgoal):\n 1. \\<parallel>g\\<parallel>\\<^sup>2 =\n    (sq_norm \\<circ> row (sylvester_mat f g)) (degree g + i)", "by (simp add: sq_norm_row_sylvester_mat2)"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2 =\n  (sq_norm \\<circ> row (sylvester_mat f g)) (degree g + i)\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "also"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2 =\n  (sq_norm \\<circ> row (sylvester_mat f g)) (degree g + i)\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "have \"... = ?M ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sq_norm \\<circ> row (sylvester_mat f g)) (degree g + i) =\n    map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i", "by (simp add: i_deg_f)"], ["proof (state)\nthis:\n  (sq_norm \\<circ> row (sylvester_mat f g)) (degree g + i) =\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   [degree g..<degree f + degree g] !\n  i\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", "finally"], ["proof (chain)\npicking this:\n  replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i =\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   [degree g..<degree f + degree g] !\n  i", "show \"?M ! i = replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i\""], ["proof (prove)\nusing this:\n  replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i =\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   [degree g..<degree f + degree g] !\n  i\n\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g] !\n    i =\n    replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i", ".."], ["proof (state)\nthis:\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   [degree g..<degree f + degree g] !\n  i =\n  replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length\n        (map (sq_norm \\<circ> row (sylvester_mat f g))\n          [degree g..<degree f + degree g]) \\<Longrightarrow>\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   [degree g..<degree f + degree g] !\n  ?i =\n  replicate n \\<parallel>g\\<parallel>\\<^sup>2 ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   [degree g..<degree f + degree g] =\n  replicate n \\<parallel>g\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have p1: \"prod_list (map ?f [0..<degree g]) = \\<parallel>f\\<parallel>\\<^sup>2^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) =\n    \\<parallel>f\\<parallel>\\<^sup>2 ^ k", "unfolding map_rw1"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate k \\<parallel>f\\<parallel>\\<^sup>2) =\n    \\<parallel>f\\<parallel>\\<^sup>2 ^ k", "by (rule prod_list_replicate)"], ["proof (state)\nthis:\n  prod_list (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) =\n  \\<parallel>f\\<parallel>\\<^sup>2 ^ k\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have p2: \"prod_list (map ?f [degree g..<degree f + degree g]) = \\<parallel>g\\<parallel>\\<^sup>2^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (map (sq_norm \\<circ> row (sylvester_mat f g))\n       [degree g..<degree f + degree g]) =\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ n", "unfolding map_rw2"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate n \\<parallel>g\\<parallel>\\<^sup>2) =\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ n", "by (rule prod_list_replicate)"], ["proof (state)\nthis:\n  prod_list\n   (map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g]) =\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ n\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have list_rw: \"[0..<degree f + degree g] = [0..<degree g] @ [degree g..<degree f + degree g]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<degree f + degree g] =\n    [0..<degree g] @ [degree g..<degree f + degree g]", "by (metis add.commute upt_add_eq_append zero_le)"], ["proof (state)\nthis:\n  [0..<degree f + degree g] =\n  [0..<degree g] @ [degree g..<degree f + degree g]\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have \"\\<bar>resultant f g\\<bar> = \\<bar>det ?S\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>resultant f g\\<bar> = \\<bar>det (sylvester_mat f g)\\<bar>", "unfolding resultant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>det (sylvester_mat f g)\\<bar> =\n    \\<bar>det (sylvester_mat f g)\\<bar>", ".."], ["proof (state)\nthis:\n  \\<bar>resultant f g\\<bar> = \\<bar>det (sylvester_mat f g)\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "also"], ["proof (state)\nthis:\n  \\<bar>resultant f g\\<bar> = \\<bar>det (sylvester_mat f g)\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have \"... \\<le> sqrt (of_int (prod_list (map sq_norm (rows ?S))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>det (sylvester_mat f g)\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (prod_list (map sq_norm (rows (sylvester_mat f g)))))", "by (rule Hadamard's_inequality_int, auto)"], ["proof (state)\nthis:\n  real_of_int \\<bar>det (sylvester_mat f g)\\<bar>\n  \\<le> sqrt\n         (real_of_int (prod_list (map sq_norm (rows (sylvester_mat f g)))))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>det (sylvester_mat f g)\\<bar>\n  \\<le> sqrt\n         (real_of_int (prod_list (map sq_norm (rows (sylvester_mat f g)))))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have \"map sq_norm (rows ?S) = map ?f [0..<degree f + degree g]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map sq_norm (rows (sylvester_mat f g)) =\n    map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree f + degree g]", "unfolding Matrix.rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map sq_norm\n     (map (row (sylvester_mat f g)) [0..<dim_row (sylvester_mat f g)]) =\n    map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree f + degree g]", "by auto"], ["proof (state)\nthis:\n  map sq_norm (rows (sylvester_mat f g)) =\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree f + degree g]\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "also"], ["proof (state)\nthis:\n  map sq_norm (rows (sylvester_mat f g)) =\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree f + degree g]\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have \"... =  map ?f ([0..<degree g] @ [degree g..<degree f + degree g])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sq_norm \\<circ> row (sylvester_mat f g))\n     [0..<degree f + degree g] =\n    map (sq_norm \\<circ> row (sylvester_mat f g))\n     ([0..<degree g] @ [degree g..<degree f + degree g])", "by (simp add: list_rw)"], ["proof (state)\nthis:\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree f + degree g] =\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   ([0..<degree g] @ [degree g..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "also"], ["proof (state)\nthis:\n  map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree f + degree g] =\n  map (sq_norm \\<circ> row (sylvester_mat f g))\n   ([0..<degree g] @ [degree g..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "have \"prod_list ... = prod_list (map ?f [0..<degree g])\n    * prod_list (map ?f [degree g..<degree f + degree g])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (map (sq_norm \\<circ> row (sylvester_mat f g))\n       ([0..<degree g] @ [degree g..<degree f + degree g])) =\n    prod_list\n     (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) *\n    prod_list\n     (map (sq_norm \\<circ> row (sylvester_mat f g))\n       [degree g..<degree f + degree g])", "by auto"], ["proof (state)\nthis:\n  prod_list\n   (map (sq_norm \\<circ> row (sylvester_mat f g))\n     ([0..<degree g] @ [degree g..<degree f + degree g])) =\n  prod_list (map (sq_norm \\<circ> row (sylvester_mat f g)) [0..<degree g]) *\n  prod_list\n   (map (sq_norm \\<circ> row (sylvester_mat f g))\n     [degree g..<degree f + degree g])\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>resultant f g\\<bar>\n  \\<le> sqrt\n         (real_of_int\n           (prod_list\n             (map (sq_norm \\<circ> row (sylvester_mat f g))\n               [0..<degree g]) *\n            prod_list\n             (map (sq_norm \\<circ> row (sylvester_mat f g))\n               [degree g..<degree f + degree g])))", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>resultant f g\\<bar>\n  \\<le> sqrt\n         (real_of_int\n           (prod_list\n             (map (sq_norm \\<circ> row (sylvester_mat f g))\n               [0..<degree g]) *\n            prod_list\n             (map (sq_norm \\<circ> row (sylvester_mat f g))\n               [degree g..<degree f + degree g])))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "unfolding p1 p2"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>resultant f g\\<bar>\n  \\<le> sqrt\n         (real_of_int\n           (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n            \\<parallel>g\\<parallel>\\<^sup>2 ^ n))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "."], ["proof (state)\nthis:\n  real_of_int \\<bar>resultant f g\\<bar>\n  \\<le> sqrt\n         (real_of_int\n           (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n            \\<parallel>g\\<parallel>\\<^sup>2 ^ n))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of the key lemma 16.20\\<close>"], ["", "(* Lemma 16.20 *)"], ["", "lemma common_factor_via_short:\n  fixes f g u :: \"int poly\"\n  defines \"n \\<equiv> degree f\" and \"k \\<equiv> degree g\"\n  assumes n0: \"n > 0\" and k0: \"k > 0\"\n      and monic: \"monic u\" and deg_u: \"degree u > 0\"\n      and uf: \"poly_mod.dvdm m u f\" and ug: \"poly_mod.dvdm m u g\"\n      and short: \"\\<parallel>f\\<parallel>\\<^sup>2^k * \\<parallel>g\\<parallel>\\<^sup>2^n < m\\<^sup>2\" \n      and m: \"m \\<ge> 0\"\n    shows \"degree (gcd f g) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "interpret poly_mod m"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have f_not0: \"f \\<noteq> 0\" and g_not0: \"g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 &&& g \\<noteq> 0", "using n0 k0 k_def n_def"], ["proof (prove)\nusing this:\n  0 < n\n  0 < k\n  k \\<equiv> degree g\n  n \\<equiv> degree f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 &&& g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have deg_f: \"degree f > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree f", "using n0 n_def"], ["proof (prove)\nusing this:\n  0 < n\n  n \\<equiv> degree f\n\ngoal (1 subgoal):\n 1. 0 < degree f", "by simp"], ["proof (state)\nthis:\n  0 < degree f\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have deg_g: \"degree g > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree g", "using k0 k_def"], ["proof (prove)\nusing this:\n  0 < k\n  k \\<equiv> degree g\n\ngoal (1 subgoal):\n 1. 0 < degree g", "by simp"], ["proof (state)\nthis:\n  0 < degree g\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "obtain s t where deg_s: \"degree s < degree g\" and deg_t: \"degree t < degree f\" \n    and res_eq: \"[:resultant f g:] = s * f + t * g\" and s_not0: \"s \\<noteq> 0\" and t_not0: \"t \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>degree s < degree g; degree t < degree f;\n         [:resultant f g:] = s * f + t * g; s \\<noteq> 0;\n         t \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using resultant_as_nonzero_poly[OF deg_f deg_g]"], ["proof (prove)\nusing this:\n  \\<exists>p' q'.\n     degree p' < degree g \\<and>\n     degree q' < degree f \\<and>\n     [:resultant f g:] = p' * f + q' * g \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>degree s < degree g; degree t < degree f;\n         [:resultant f g:] = s * f + t * g; s \\<noteq> 0;\n         t \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree s < degree g\n  degree t < degree f\n  [:resultant f g:] = s * f + t * g\n  s \\<noteq> 0\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have res_eq_modulo: \"[:resultant f g:] =m s * f + t * g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:resultant f g:] =m s * f + t * g", "using res_eq"], ["proof (prove)\nusing this:\n  [:resultant f g:] = s * f + t * g\n\ngoal (1 subgoal):\n 1. [:resultant f g:] =m s * f + t * g", "by simp"], ["proof (state)\nthis:\n  [:resultant f g:] =m s * f + t * g\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have u_dvdm_res: \"u dvdm [:resultant f g:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u dvdm [:resultant f g:]", "proof (unfold res_eq, rule dvdm_add)"], ["proof (state)\ngoal (2 subgoals):\n 1. u dvdm s * f\n 2. u dvdm t * g", "show \"u dvdm s * f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u dvdm s * f", "using dvdm_factor[OF uf, of s]"], ["proof (prove)\nusing this:\n  u dvdm f * s\n\ngoal (1 subgoal):\n 1. u dvdm s * f", "unfolding mult.commute[of f s]"], ["proof (prove)\nusing this:\n  u dvdm s * f\n\ngoal (1 subgoal):\n 1. u dvdm s * f", "by auto"], ["proof (state)\nthis:\n  u dvdm s * f\n\ngoal (1 subgoal):\n 1. u dvdm t * g", "show \"u dvdm t * g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u dvdm t * g", "using dvdm_factor[OF ug, of t]"], ["proof (prove)\nusing this:\n  u dvdm g * t\n\ngoal (1 subgoal):\n 1. u dvdm t * g", "unfolding mult.commute[of g t]"], ["proof (prove)\nusing this:\n  u dvdm t * g\n\ngoal (1 subgoal):\n 1. u dvdm t * g", "by auto"], ["proof (state)\nthis:\n  u dvdm t * g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u dvdm [:resultant f g:]\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have res_0_mod: \"resultant f g mod m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant f g mod m = 0", "by (rule monic_dvdm_constant[OF u_dvdm_res monic deg_u])"], ["proof (state)\nthis:\n  resultant f g mod m = 0\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have res0: \"resultant f g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant f g = 0", "proof (rule mod_0_abs_less_imp_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. [resultant f g = 0] (mod ?m)\n 2. \\<bar>resultant f g\\<bar> < ?m", "show \"[resultant f g = 0] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [resultant f g = 0] (mod m)", "using res_0_mod"], ["proof (prove)\nusing this:\n  resultant f g mod m = 0\n\ngoal (1 subgoal):\n 1. [resultant f g = 0] (mod m)", "unfolding cong_def"], ["proof (prove)\nusing this:\n  resultant f g mod m = 0\n\ngoal (1 subgoal):\n 1. resultant f g mod m = 0 mod m", "by auto"], ["proof (state)\nthis:\n  [resultant f g = 0] (mod m)\n\ngoal (1 subgoal):\n 1. \\<bar>resultant f g\\<bar> < m", "have \"\\<bar>resultant f g\\<bar> \\<le> sqrt ((sq_norm_poly f)^k * (sq_norm_poly g)^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n))", "unfolding k_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>resultant f g\\<bar>\n    \\<le> sqrt\n           (real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ degree g *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f))", "by (rule resultant_le_prod_sq_norm)"], ["proof (state)\nthis:\n  real_of_int \\<bar>resultant f g\\<bar>\n  \\<le> sqrt\n         (real_of_int\n           (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n            \\<parallel>g\\<parallel>\\<^sup>2 ^ n))\n\ngoal (1 subgoal):\n 1. \\<bar>resultant f g\\<bar> < m", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>resultant f g\\<bar>\n  \\<le> sqrt\n         (real_of_int\n           (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n            \\<parallel>g\\<parallel>\\<^sup>2 ^ n))\n\ngoal (1 subgoal):\n 1. \\<bar>resultant f g\\<bar> < m", "have \"... < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (real_of_int\n       (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n        \\<parallel>g\\<parallel>\\<^sup>2 ^ n))\n    < real_of_int m", "proof (rule real_less_lsqrt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\n 2. 0 \\<le> real_of_int m\n 3. real_of_int\n     (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n      \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\n    < (real_of_int m)\\<^sup>2", "show \"0 \\<le> real_of_int (\\<parallel>f\\<parallel>\\<^sup>2 ^ k * \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int\n             (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n              \\<parallel>g\\<parallel>\\<^sup>2 ^ n)", "by (simp add: sq_norm_poly_ge_0)"], ["proof (state)\nthis:\n  0 \\<le> real_of_int\n           (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n            \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\n\ngoal (2 subgoals):\n 1. 0 \\<le> real_of_int m\n 2. real_of_int\n     (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n      \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\n    < (real_of_int m)\\<^sup>2", "show \"0 \\<le> real_of_int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int m", "using m"], ["proof (prove)\nusing this:\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int m", "by simp"], ["proof (state)\nthis:\n  0 \\<le> real_of_int m\n\ngoal (1 subgoal):\n 1. real_of_int\n     (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n      \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\n    < (real_of_int m)\\<^sup>2", "show \"real_of_int (\\<parallel>f\\<parallel>\\<^sup>2 ^ k * \\<parallel>g\\<parallel>\\<^sup>2 ^ n) < (real_of_int m)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n      \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\n    < (real_of_int m)\\<^sup>2", "by (metis of_int_less_iff of_int_power short)"], ["proof (state)\nthis:\n  real_of_int\n   (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ n)\n  < (real_of_int m)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt\n   (real_of_int\n     (\\<parallel>f\\<parallel>\\<^sup>2 ^ k *\n      \\<parallel>g\\<parallel>\\<^sup>2 ^ n))\n  < real_of_int m\n\ngoal (1 subgoal):\n 1. \\<bar>resultant f g\\<bar> < m", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>resultant f g\\<bar> < real_of_int m", "show \"\\<bar>resultant f g\\<bar> < m\""], ["proof (prove)\nusing this:\n  real_of_int \\<bar>resultant f g\\<bar> < real_of_int m\n\ngoal (1 subgoal):\n 1. \\<bar>resultant f g\\<bar> < m", "using of_int_less_iff"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>resultant f g\\<bar> < real_of_int m\n  (of_int ?w < of_int ?z) = (?w < ?z)\n\ngoal (1 subgoal):\n 1. \\<bar>resultant f g\\<bar> < m", "by blast"], ["proof (state)\nthis:\n  \\<bar>resultant f g\\<bar> < m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  resultant f g = 0\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "have \"\\<not> coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime f g", "by (rule resultant_zero_imp_common_factor, auto simp add: deg_f res0)"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "using res0 resultant_0_gcd"], ["proof (prove)\nusing this:\n  \\<not> comm_monoid_mult_class.coprime f g\n  resultant f g = 0\n  (resultant ?f ?g = (0::?'a)) = (degree (gcd ?f ?g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f g)", "by auto"], ["proof (state)\nthis:\n  0 < degree (gcd f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Properties of the computed lattice and its connection with Sylvester matrices\\<close>"], ["", "lemma factorization_lattice_as_sylvester:\n  fixes p :: \"'a :: semidom poly\"\n  assumes dj: \"d \\<le> j\" and d: \"degree p = d\"   \n  shows \"mat_of_rows j (factorization_lattice p (j-d) m) = sylvester_mat_sub d (j-d) p [:m:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "have deg_p: \"d = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = 0", "using True d"], ["proof (prove)\nusing this:\n  p = 0\n  degree p = d\n\ngoal (1 subgoal):\n 1. d = 0", "by simp"], ["proof (state)\nthis:\n  d = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "by (auto simp add: factorization_lattice_def True deg_p mat_of_rows_def d)"], ["proof (state)\nthis:\n  mat_of_rows j (factorization_lattice p (j - d) m) =\n  sylvester_mat_sub d (j - d) p [:m:]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "case p0: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "note 1 = degree_mult_eq[OF p0, of \"monom _ _\", unfolded monom_eq_0_iff, OF one_neq_zero]"], ["proof (state)\nthis:\n  degree (p * monom (1::'a) ?uua3) = degree p + degree (monom (1::'a) ?uua3)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "from dj"], ["proof (chain)\npicking this:\n  d \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<le> j\n\ngoal (1 subgoal):\n 1. mat_of_rows j (factorization_lattice p (j - d) m) =\n    sylvester_mat_sub d (j - d) p [:m:]", "apply (cases \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d \\<le> j; m = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> mat_of_rows j (factorization_lattice p (j - d) m) =\n                      sylvester_mat_sub d (j - d) p [:m:]\n 2. \\<lbrakk>d \\<le> j; m \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> mat_of_rows j (factorization_lattice p (j - d) m) =\n                      sylvester_mat_sub d (j - d) p [:m:]", "apply (auto simp: mat_eq_iff d[symmetric] 1 coeff_mult_monom\n sylvester_mat_sub_index mat_of_rows_index nth_factorization_lattice vec_index_of_poly_n\n degree_monom_eq coeff_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mat_of_rows j (factorization_lattice p (j - d) m) =\n  sylvester_mat_sub d (j - d) p [:m:]\n\ngoal:\nNo subgoals!", "qed"], ["", "context inj_comm_semiring_hom begin"], ["", "lemma map_poly_hom_mult_monom [hom_distribs]:\n  \"map_poly hom (p * monom a n) = map_poly hom p * monom (hom a) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (p * monom a n) = map_poly hom p * monom (hom a) n", "by (auto intro!: poly_eqI simp:coeff_mult_monom hom_mult)"], ["", "lemma hom_vec_of_poly_n [hom_distribs]:\n  \"map_vec hom (vec_of_poly_n p n) = vec_of_poly_n (map_poly hom p) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec\\<^sub>h (vec_of_poly_n p n) = vec_of_poly_n (map_poly hom p) n", "by (auto simp: vec_index_of_poly_n)"], ["", "lemma hom_factorization_lattice [hom_distribs]:\n  shows \"map (map_vec hom) (factorization_lattice u k m) = factorization_lattice (map_poly hom u) k (hom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map vec\\<^sub>h (factorization_lattice u k m) =\n    factorization_lattice (map_poly hom u) k (hom m)", "by (auto intro!:arg_cong[of _ _ \"\\<lambda>p. vec_of_poly_n p _\"] simp: list_eq_iff_nth_eq nth_factorization_lattice hom_vec_of_poly_n map_poly_hom_mult_monom)"], ["", "end"], ["", "subsection \\<open>Proving that @{const factorization_lattice} returns a basis of the lattice\\<close>"], ["", "context LLL\nbegin"], ["", "sublocale idom_vec n \"TYPE(int)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(*In this context, \"n\" is fixed by the locale and corresponds to \"j\" in the book*)"], ["", "lemma upper_triangular_factorization_lattice:\n  fixes u :: \"'a :: semidom poly\" and d :: nat\n  assumes d: \"d \\<le> n\" and du: \"d = degree u\"\n  shows \"upper_triangular (mat_of_rows n (factorization_lattice u (n-d) k))\"\n    (is \"upper_triangular ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (mat_of_rows n (factorization_lattice u (n - d) k))", "proof (intro upper_triangularI, unfold mat_of_rows_carrier length_factorization_lattice)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; i < degree u + (n - d)\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n\n                          (factorization_lattice u (n - d) k) $$\n                         (i, j) =\n                         (0::'a)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; i < degree u + (n - d)\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n\n                          (factorization_lattice u (n - d) k) $$\n                         (i, j) =\n                         (0::'a)", "assume ji: \"j < i\" and i: \"i < degree u + (n - d)\""], ["proof (state)\nthis:\n  j < i\n  i < degree u + (n - d)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; i < degree u + (n - d)\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n\n                          (factorization_lattice u (n - d) k) $$\n                         (i, j) =\n                         (0::'a)", "with d du"], ["proof (chain)\npicking this:\n  d \\<le> n\n  d = degree u\n  j < i\n  i < degree u + (n - d)", "have jn: \"j < n\""], ["proof (prove)\nusing this:\n  d \\<le> n\n  d = degree u\n  j < i\n  i < degree u + (n - d)\n\ngoal (1 subgoal):\n 1. j < n", "by auto"], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; i < degree u + (n - d)\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n\n                          (factorization_lattice u (n - d) k) $$\n                         (i, j) =\n                         (0::'a)", "show \"?M $$ (i,j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "proof (cases \"u=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = 0 \\<Longrightarrow>\n    mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)\n 2. u \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "case True"], ["proof (state)\nthis:\n  u = 0\n\ngoal (2 subgoals):\n 1. u = 0 \\<Longrightarrow>\n    mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)\n 2. u \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "with ji i"], ["proof (chain)\npicking this:\n  j < i\n  i < degree u + (n - d)\n  u = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  j < i\n  i < degree u + (n - d)\n  u = 0\n\ngoal (1 subgoal):\n 1. mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "by (auto simp: factorization_lattice_def mat_of_rows_def)"], ["proof (state)\nthis:\n  mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "case False"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0 \\<Longrightarrow>\n    mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "then"], ["proof (chain)\npicking this:\n  u \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "using d ji i"], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n  d \\<le> n\n  j < i\n  i < degree u + (n - d)\n\ngoal (1 subgoal):\n 1. mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)", "apply (simp add: du mat_of_rows_index nth_factorization_lattice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> 0; degree u \\<le> n; j < i; i < n\\<rbrakk>\n    \\<Longrightarrow> (i < n - degree u \\<longrightarrow>\n                       vec_of_poly_n\n                        (u * monom (1::'a) (n - Suc (degree u + i))) n $\n                       j =\n                       (0::'a)) \\<and>\n                      (\\<not> i < n - degree u \\<longrightarrow>\n                       vec_of_poly_n (monom k (n - Suc i)) n $ j = (0::'a))", "apply (auto simp: vec_index_of_poly_n[OF jn] degree_mult_eq degree_monom_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_of_rows n (factorization_lattice u (n - d) k) $$ (i, j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorization_lattice_diag_nonzero:\n  fixes u :: \"'a :: semidom poly\" and d\n  assumes d: \"d=degree u\" \n    and dn: \"d\\<le>n\"\n    and u: \"u\\<noteq>0\" \n    and m0: \"k\\<noteq>0\"\n    and i: \"i<n\"\n  shows \"(factorization_lattice u (n-d) k) ! i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)", "have 1: \"monom (1::'a) (n - Suc (degree u + i)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (n - Suc (degree u + i)) \\<noteq> 0", "using m0"], ["proof (prove)\nusing this:\n  k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. monom (1::'a) (n - Suc (degree u + i)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monom (1::'a) (n - Suc (degree u + i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)", "have 2: \"i < degree u + (n - d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < degree u + (n - d)", "using i d"], ["proof (prove)\nusing this:\n  i < n\n  d = degree u\n\ngoal (1 subgoal):\n 1. i < degree u + (n - d)", "by auto"], ["proof (state)\nthis:\n  i < degree u + (n - d)\n\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)", "let ?p = \"u * monom 1 (n - Suc (degree u + i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)", "have 3: \"i < n - degree u \\<Longrightarrow> degree (?p) = n - Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n - degree u \\<Longrightarrow>\n    degree (u * monom (1::'a) (n - Suc (degree u + i))) = n - Suc i", "using assms"], ["proof (prove)\nusing this:\n  d = degree u\n  d \\<le> n\n  u \\<noteq> 0\n  k \\<noteq> (0::'a)\n  i < n\n\ngoal (1 subgoal):\n 1. i < n - degree u \\<Longrightarrow>\n    degree (u * monom (1::'a) (n - Suc (degree u + i))) = n - Suc i", "by (auto simp: degree_mult_eq[OF _ 1] degree_monom_eq)"], ["proof (state)\nthis:\n  i < n - degree u \\<Longrightarrow>\n  degree (u * monom (1::'a) (n - Suc (degree u + i))) = n - Suc i\n\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)", "apply (unfold nth_factorization_lattice[OF 2] vec_index_of_poly_n[OF 2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < degree u + (n - d) -\n            Suc (degree\n                  (if i < n - d then u * monom (1::'a) (n - d - Suc i)\n                   else monom k (degree u + (n - d) - Suc i)))\n     then 0::'a\n     else coeff\n           (if i < n - d then u * monom (1::'a) (n - d - Suc i)\n            else monom k (degree u + (n - d) - Suc i))\n           (degree u + (n - d) - i - 1)) \\<noteq>\n    (0::'a)", "using assms leading_coeff_0_iff[of ?p]"], ["proof (prove)\nusing this:\n  d = degree u\n  d \\<le> n\n  u \\<noteq> 0\n  k \\<noteq> (0::'a)\n  i < n\n  (lead_coeff (u * monom (1::'a) (n - Suc (degree u + i))) = (0::'a)) =\n  (u * monom (1::'a) (n - Suc (degree u + i)) = 0)\n\ngoal (1 subgoal):\n 1. (if i < degree u + (n - d) -\n            Suc (degree\n                  (if i < n - d then u * monom (1::'a) (n - d - Suc i)\n                   else monom k (degree u + (n - d) - Suc i)))\n     then 0::'a\n     else coeff\n           (if i < n - d then u * monom (1::'a) (n - d - Suc i)\n            else monom k (degree u + (n - d) - Suc i))\n           (degree u + (n - d) - i - 1)) \\<noteq>\n    (0::'a)", "apply (cases \"i < n - degree u\", auto simp: d 3 degree_monom_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  factorization_lattice u (n - d) k ! i $ i \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary factorization_lattice_diag_nonzero_RAT: fixes d\n  assumes \"d=degree u\" \n    and \"d\\<le>n\"\n    and \"u\\<noteq>0\" \n    and \"k\\<noteq>0\"\n    and \"i<n\"\n  shows \"RAT (factorization_lattice u (n-d) k) ! i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (factorization_lattice u (n - d) k) ! i $\n    i \\<noteq>\n    0", "using factorization_lattice_diag_nonzero[OF assms] assms"], ["proof (prove)\nusing this:\n  factorization_lattice u (n - d) k ! i $ i \\<noteq> 0\n  d = degree u\n  d \\<le> n\n  u \\<noteq> 0\n  k \\<noteq> 0\n  i < n\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (factorization_lattice u (n - d) k) ! i $\n    i \\<noteq>\n    0", "by (auto simp: nth_factorization_lattice)"], ["", "sublocale gs: vec_space \"TYPE(rat)\" n"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lin_indpt_list_factorization_lattice: fixes d\n  assumes d: \"d = degree u\" and dn: \"d \\<le> n\" and u: \"u \\<noteq> 0\" and k: \"k \\<noteq> 0\"\n  shows \"gs.lin_indpt_list (RAT (factorization_lattice u (n-d) k))\" (is \"gs.lin_indpt_list (RAT ?vs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))", "have 1: \"rows (mat_of_rows n (map (map_vec rat_of_int) ?vs)) = map (map_vec rat_of_int) ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows\n     (mat_of_rows n\n       (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))) =\n    map of_int_hom.vec_hom (factorization_lattice u (n - d) k)", "using dn d"], ["proof (prove)\nusing this:\n  d \\<le> n\n  d = degree u\n\ngoal (1 subgoal):\n 1. rows\n     (mat_of_rows n\n       (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))) =\n    map of_int_hom.vec_hom (factorization_lattice u (n - d) k)", "by (subst rows_mat_of_rows, auto dest!: subsetD[OF set_factorization_lattice_in_carrier])"], ["proof (state)\nthis:\n  rows\n   (mat_of_rows n\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))) =\n  map of_int_hom.vec_hom (factorization_lattice u (n - d) k)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))", "note 2 = factorization_lattice_diag_nonzero_RAT[OF d dn u k]"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow>\n  map of_int_hom.vec_hom (factorization_lattice u (n - d) k) ! ?i $\n  ?i \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))", "apply (intro gs.upper_triangular_imp_lin_indpt_list[of \"mat_of_rows n (RAT ?vs)\", unfolded 1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. mat_of_rows n\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))\n    \\<in> carrier_mat n n\n 2. upper_triangular\n     (mat_of_rows n\n       (map of_int_hom.vec_hom (factorization_lattice u (n - d) k)))\n 3. 0 \\<notin> set (diag_mat\n                     (mat_of_rows n\n                       (map of_int_hom.vec_hom\n                         (factorization_lattice u (n - d) k))))", "using assms 2"], ["proof (prove)\nusing this:\n  d = degree u\n  d \\<le> n\n  u \\<noteq> 0\n  k \\<noteq> 0\n  ?i < n \\<Longrightarrow>\n  map of_int_hom.vec_hom (factorization_lattice u (n - d) k) ! ?i $\n  ?i \\<noteq>\n  0\n\ngoal (3 subgoals):\n 1. mat_of_rows n\n     (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))\n    \\<in> carrier_mat n n\n 2. upper_triangular\n     (mat_of_rows n\n       (map of_int_hom.vec_hom (factorization_lattice u (n - d) k)))\n 3. 0 \\<notin> set (diag_mat\n                     (mat_of_rows n\n                       (map of_int_hom.vec_hom\n                         (factorization_lattice u (n - d) k))))", "by (auto simp: diag_mat_def mat_of_rows_index hom_distribs intro!:upper_triangular_factorization_lattice)"], ["proof (state)\nthis:\n  gs.lin_indpt_list\n   (map of_int_hom.vec_hom (factorization_lattice u (n - d) k))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Being in the lattice is being a multiple modulo\\<close>"], ["", "lemma (in semiring_hom) hom_poly_of_vec: \"map_poly hom (poly_of_vec v) = poly_of_vec (map_vec hom v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (poly_of_vec v) = poly_of_vec (vec\\<^sub>h v)", "by (auto simp add: coeff_poly_of_vec poly_eq_iff)"], ["", "abbreviation \"of_int_vec \\<equiv> map_vec of_int\""], ["", "context LLL\nbegin"], ["", "lemma lincomb_to_dvd_modulo:\n  fixes u d\n  defines \"d \\<equiv> degree u\"\n  assumes d: \"d \\<le> n\"\n      and lincomb: \"lincomb_list c (factorization_lattice u (n-d) k) = g\" (is \"?l = ?r\")\n  shows \"poly_mod.dvdm k u (poly_of_vec g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "let ?S = \"sylvester_mat_sub d (n - d) u [:k:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "define q where \"q \\<equiv> poly_of_vec (vec_first (vec n c) (n - d))\""], ["proof (state)\nthis:\n  q \\<equiv> poly_of_vec (vec_first (vec n c) (n - d))\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "define r where \"r \\<equiv> poly_of_vec (vec_last (vec n c) d)\""], ["proof (state)\nthis:\n  r \\<equiv> poly_of_vec (vec_last (vec n c) d)\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "have \"?l = ?S\\<^sup>T *\\<^sub>v vec n c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list c (factorization_lattice u (n - d) k) =\n    (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c", "apply (subst lincomb_list_as_mat_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>w\\<in>set (factorization_lattice u (n - d) k). dim_vec w = n\n 2. mat_of_cols n (factorization_lattice u (n - d) k) *\\<^sub>v\n    vec (length (factorization_lattice u (n - d) k)) c =\n    (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c", "using d d_def"], ["proof (prove)\nusing this:\n  d \\<le> n\n  d \\<equiv> degree u\n\ngoal (2 subgoals):\n 1. \\<forall>w\\<in>set (factorization_lattice u (n - d) k). dim_vec w = n\n 2. mat_of_cols n (factorization_lattice u (n - d) k) *\\<^sub>v\n    vec (length (factorization_lattice u (n - d) k)) c =\n    (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c", "apply (force simp:factorization_lattice_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n (factorization_lattice u (n - d) k) *\\<^sub>v\n    vec (length (factorization_lattice u (n - d) k)) c =\n    (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c", "apply (fold transpose_mat_of_rows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_rows n (factorization_lattice u (n - d) k))\\<^sup>T *\\<^sub>v\n    vec (length (factorization_lattice u (n - d) k)) c =\n    (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c", "using d d_def"], ["proof (prove)\nusing this:\n  d \\<le> n\n  d \\<equiv> degree u\n\ngoal (1 subgoal):\n 1. (mat_of_rows n (factorization_lattice u (n - d) k))\\<^sup>T *\\<^sub>v\n    vec (length (factorization_lattice u (n - d) k)) c =\n    (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c", "by (simp add: factorization_lattice_as_sylvester)"], ["proof (state)\nthis:\n  lincomb_list c (factorization_lattice u (n - d) k) =\n  (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "also"], ["proof (state)\nthis:\n  lincomb_list c (factorization_lattice u (n - d) k) =\n  (sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "have \"poly_of_vec \\<dots> = q * u + smult k r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     ((sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c) =\n    q * u + smult k r", "apply (subst sylvester_sub_poly)"], ["proof (prove)\ngoal (4 subgoals):\n 1. degree u \\<le> d\n 2. degree [:k:] \\<le> n - d\n 3. vec n c \\<in> carrier_vec (d + (n - d))\n 4. poly_of_vec (vec_first (vec n c) (n - d)) * u +\n    poly_of_vec (vec_last (vec n c) d) * [:k:] =\n    q * u + smult k r", "using d_def d q_def r_def"], ["proof (prove)\nusing this:\n  d \\<equiv> degree u\n  d \\<le> n\n  q \\<equiv> poly_of_vec (vec_first (vec n c) (n - d))\n  r \\<equiv> poly_of_vec (vec_last (vec n c) d)\n\ngoal (4 subgoals):\n 1. degree u \\<le> d\n 2. degree [:k:] \\<le> n - d\n 3. vec n c \\<in> carrier_vec (d + (n - d))\n 4. poly_of_vec (vec_first (vec n c) (n - d)) * u +\n    poly_of_vec (vec_last (vec n c) d) * [:k:] =\n    q * u + smult k r", "by auto"], ["proof (state)\nthis:\n  poly_of_vec\n   ((sylvester_mat_sub d (n - d) u [:k:])\\<^sup>T *\\<^sub>v vec n c) =\n  q * u + smult k r\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "finally"], ["proof (chain)\npicking this:\n  poly_of_vec (lincomb_list c (factorization_lattice u (n - d) k)) =\n  q * u + smult k r", "have \"\\<dots> = poly_of_vec g\""], ["proof (prove)\nusing this:\n  poly_of_vec (lincomb_list c (factorization_lattice u (n - d) k)) =\n  q * u + smult k r\n\ngoal (1 subgoal):\n 1. q * u + smult k r = poly_of_vec g", "unfolding lincomb of_int_hom.hom_poly_of_vec"], ["proof (prove)\nusing this:\n  poly_of_vec g = q * u + smult k r\n\ngoal (1 subgoal):\n 1. q * u + smult k r = poly_of_vec g", "by auto"], ["proof (state)\nthis:\n  q * u + smult k r = poly_of_vec g\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "then"], ["proof (chain)\npicking this:\n  q * u + smult k r = poly_of_vec g", "have \"poly_of_vec g = q * u + Polynomial.smult k r\""], ["proof (prove)\nusing this:\n  q * u + smult k r = poly_of_vec g\n\ngoal (1 subgoal):\n 1. poly_of_vec g = q * u + smult k r", "by auto"], ["proof (state)\nthis:\n  poly_of_vec g = q * u + smult k r\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "then"], ["proof (chain)\npicking this:\n  poly_of_vec g = q * u + smult k r", "have \"poly_mod.Mp k (poly_of_vec g) =  poly_mod.Mp k (q * u + Polynomial.smult k r)\""], ["proof (prove)\nusing this:\n  poly_of_vec g = q * u + smult k r\n\ngoal (1 subgoal):\n 1. poly_mod.Mp k (poly_of_vec g) = poly_mod.Mp k (q * u + smult k r)", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp k (poly_of_vec g) = poly_mod.Mp k (q * u + smult k r)\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "also"], ["proof (state)\nthis:\n  poly_mod.Mp k (poly_of_vec g) = poly_mod.Mp k (q * u + smult k r)\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "have \"... = poly_mod.Mp k (q * u + poly_mod.Mp k (Polynomial.smult k r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp k (q * u + smult k r) =\n    poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r))", "using poly_mod.plus_Mp(2)"], ["proof (prove)\nusing this:\n  poly_mod.Mp ?m (?f + poly_mod.Mp ?m ?g) = poly_mod.Mp ?m (?f + ?g)\n\ngoal (1 subgoal):\n 1. poly_mod.Mp k (q * u + smult k r) =\n    poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r))", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp k (q * u + smult k r) =\n  poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r))\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "also"], ["proof (state)\nthis:\n  poly_mod.Mp k (q * u + smult k r) =\n  poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r))\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "have \"... =  poly_mod.Mp k (q * u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r)) =\n    poly_mod.Mp k (q * u)", "using poly_mod.plus_Mp(2)"], ["proof (prove)\nusing this:\n  poly_mod.Mp ?m (?f + poly_mod.Mp ?m ?g) = poly_mod.Mp ?m (?f + ?g)\n\ngoal (1 subgoal):\n 1. poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r)) =\n    poly_mod.Mp k (q * u)", "unfolding poly_mod.Mp_smult_m_0"], ["proof (prove)\nusing this:\n  poly_mod.Mp ?m (?f + poly_mod.Mp ?m ?g) = poly_mod.Mp ?m (?f + ?g)\n\ngoal (1 subgoal):\n 1. poly_mod.Mp k (q * u + 0) = poly_mod.Mp k (q * u)", "by simp"], ["proof (state)\nthis:\n  poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r)) = poly_mod.Mp k (q * u)\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "also"], ["proof (state)\nthis:\n  poly_mod.Mp k (q * u + poly_mod.Mp k (smult k r)) = poly_mod.Mp k (q * u)\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "have \"... = poly_mod.Mp k (u * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp k (q * u) = poly_mod.Mp k (u * q)", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  poly_mod.Mp k (q * u) = poly_mod.Mp k (u * q)\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "finally"], ["proof (chain)\npicking this:\n  poly_mod.Mp k (poly_of_vec g) = poly_mod.Mp k (u * q)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_mod.Mp k (poly_of_vec g) = poly_mod.Mp k (u * q)\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm k u (poly_of_vec g)", "unfolding poly_mod.dvdm_def"], ["proof (prove)\nusing this:\n  poly_mod.Mp k (poly_of_vec g) = poly_mod.Mp k (u * q)\n\ngoal (1 subgoal):\n 1. \\<exists>h. poly_mod.Mp k (poly_of_vec g) = poly_mod.Mp k (u * h)", "by auto"], ["proof (state)\nthis:\n  poly_mod.dvdm k u (poly_of_vec g)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  There is a typo in the textbook (page 476). The book states q' = q'' * u + r'' and \n  the correct fact is r' = q'' * u+r'' \n*)"], ["", "lemma dvd_modulo_to_lincomb:\n  fixes u :: \"int poly\" and d\n  defines \"d \\<equiv> degree u\"\n  assumes d: \"d < n\"\n      and dvd: \"poly_mod.dvdm k u (poly_of_vec g)\"\n      and k_not0: \"k\\<noteq>0\"\n      and monic_u: \"monic u\"\n      and dim_g: \"dim_vec g = n\"\n      and deg_u: \"degree u > 0\"      \n  shows \"\\<exists>c. lincomb_list c (factorization_lattice u (n-d) k) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "interpret p: poly_mod k"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "have u_not0: \"u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "using monic_u"], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "hence n[simp]: \"0 < n\""], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "using d"], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n  d < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "obtain q' r' where g: \"poly_of_vec g = q' * u + smult k r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q' r'.\n        poly_of_vec g = q' * u + smult k r' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using p.dvdm_imp_div_mod[OF dvd]"], ["proof (prove)\nusing this:\n  \\<exists>q r. poly_of_vec g = q * u + smult k r\n\ngoal (1 subgoal):\n 1. (\\<And>q' r'.\n        poly_of_vec g = q' * u + smult k r' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly_of_vec g = q' * u + smult k r'\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "obtain q'' r'' where r': \"r' = q'' * u + r''\" and deg_r'': \"degree r''<degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'' r''.\n        \\<lbrakk>r' = q'' * u + r''; degree r'' < degree u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using monic_imp_div_mod_int_poly_degree2[OF monic_u deg_u, of r']"], ["proof (prove)\nusing this:\n  \\<exists>q r. r' = q * u + r \\<and> degree r < degree u\n\ngoal (1 subgoal):\n 1. (\\<And>q'' r''.\n        \\<lbrakk>r' = q'' * u + r''; degree r'' < degree u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r' = q'' * u + r''\n  degree r'' < degree u\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "(*The following fact is explained in the paragraph below equation (6) in page 476 of the textbook*)"], ["proof (state)\nthis:\n  r' = q'' * u + r''\n  degree r'' < degree u\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "have g1: \"poly_of_vec g = (q' + smult k q'') * u + smult k r''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec g = (q' + smult k q'') * u + smult k r''", "unfolding g r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' * u + smult k (q'' * u + r'') = (q' + smult k q'') * u + smult k r''", "by (metis (no_types, lifting) combine_common_factor mult_smult_left smult_add_right)"], ["proof (state)\nthis:\n  poly_of_vec g = (q' + smult k q'') * u + smult k r''\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "define q where q: \"q = (q' + smult k q'')\""], ["proof (state)\nthis:\n  q = q' + smult k q''\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "define r where r: \"r = r''\""], ["proof (state)\nthis:\n  r = r''\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "have degree_q: \"q = 0 \\<or> degree (q' + smult k q'') < n - d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = 0 \\<or> degree (q' + smult k q'') < n - d", "proof (cases \"q = 0\",auto, rule degree_div_mod_smult[OF _ _ _ g1])"], ["proof (state)\ngoal (5 subgoals):\n 1. q \\<noteq> 0 \\<Longrightarrow> degree (poly_of_vec g) < n\n 2. q \\<noteq> 0 \\<Longrightarrow> degree r'' < d\n 3. q \\<noteq> 0 \\<Longrightarrow> degree u = d\n 4. q \\<noteq> 0 \\<Longrightarrow> q' + smult k q'' \\<noteq> 0\n 5. q \\<noteq> 0 \\<Longrightarrow> k \\<noteq> 0", "show \"degree (poly_of_vec g) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_vec g) < n", "by (rule degree_poly_of_vec_less, auto simp add: dim_g)"], ["proof (state)\nthis:\n  degree (poly_of_vec g) < n\n\ngoal (4 subgoals):\n 1. q \\<noteq> 0 \\<Longrightarrow> degree r'' < d\n 2. q \\<noteq> 0 \\<Longrightarrow> degree u = d\n 3. q \\<noteq> 0 \\<Longrightarrow> q' + smult k q'' \\<noteq> 0\n 4. q \\<noteq> 0 \\<Longrightarrow> k \\<noteq> 0", "show \"degree r'' < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree r'' < d", "using deg_r''"], ["proof (prove)\nusing this:\n  degree r'' < degree u\n\ngoal (1 subgoal):\n 1. degree r'' < d", "unfolding d_def"], ["proof (prove)\nusing this:\n  degree r'' < degree u\n\ngoal (1 subgoal):\n 1. degree r'' < degree u", "."], ["proof (state)\nthis:\n  degree r'' < d\n\ngoal (3 subgoals):\n 1. q \\<noteq> 0 \\<Longrightarrow> degree u = d\n 2. q \\<noteq> 0 \\<Longrightarrow> q' + smult k q'' \\<noteq> 0\n 3. q \\<noteq> 0 \\<Longrightarrow> k \\<noteq> 0", "assume \"q\\<noteq>0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (3 subgoals):\n 1. q \\<noteq> 0 \\<Longrightarrow> degree u = d\n 2. q \\<noteq> 0 \\<Longrightarrow> q' + smult k q'' \\<noteq> 0\n 3. q \\<noteq> 0 \\<Longrightarrow> k \\<noteq> 0", "thus \"q' + smult k q'' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q' + smult k q'' \\<noteq> 0", "unfolding q"], ["proof (prove)\nusing this:\n  q' + smult k q'' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q' + smult k q'' \\<noteq> 0", "."], ["proof (state)\nthis:\n  q' + smult k q'' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. q \\<noteq> 0 \\<Longrightarrow> degree u = d\n 2. q \\<noteq> 0 \\<Longrightarrow> k \\<noteq> 0", "show \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by fact"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> degree u = d", "show \"degree u = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u = d", "using d_def"], ["proof (prove)\nusing this:\n  d \\<equiv> degree u\n\ngoal (1 subgoal):\n 1. degree u = d", "by auto"], ["proof (state)\nthis:\n  degree u = d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = 0 \\<or> degree (q' + smult k q'') < n - d\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "have g2: \"(vec_of_poly_n (q*u) n) + (vec_of_poly_n (smult k r) n) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "have \"g = vec_of_poly_n (poly_of_vec g) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = vec_of_poly_n (poly_of_vec g) n", "by (rule vec_of_poly_n_poly_of_vec[symmetric], auto simp add: dim_g)"], ["proof (state)\nthis:\n  g = vec_of_poly_n (poly_of_vec g) n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "also"], ["proof (state)\nthis:\n  g = vec_of_poly_n (poly_of_vec g) n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "have \"\\<dots> = vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (poly_of_vec g) n =\n    vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n", "using g1"], ["proof (prove)\nusing this:\n  poly_of_vec g = (q' + smult k q'') * u + smult k r''\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (poly_of_vec g) n =\n    vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n", "by auto"], ["proof (state)\nthis:\n  vec_of_poly_n (poly_of_vec g) n =\n  vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "also"], ["proof (state)\nthis:\n  vec_of_poly_n (poly_of_vec g) n =\n  vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "have \"... = vec_of_poly_n (q * u + smult k r'') n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n =\n    vec_of_poly_n (q * u + smult k r'') n", "unfolding q"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n =\n    vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n", "by auto"], ["proof (state)\nthis:\n  vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n =\n  vec_of_poly_n (q * u + smult k r'') n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "also"], ["proof (state)\nthis:\n  vec_of_poly_n ((q' + smult k q'') * u + smult k r'') n =\n  vec_of_poly_n (q * u + smult k r'') n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "have \"... = vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r'') n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u + smult k r'') n =\n    vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r'') n", "by (rule vec_of_poly_n_add)"], ["proof (state)\nthis:\n  vec_of_poly_n (q * u + smult k r'') n =\n  vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r'') n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "finally"], ["proof (chain)\npicking this:\n  g = vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r'') n", "show ?thesis"], ["proof (prove)\nusing this:\n  g = vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r'') n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "unfolding r"], ["proof (prove)\nusing this:\n  g = vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r'') n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r'') n = g", "by simp"], ["proof (state)\nthis:\n  vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g\n\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "let ?c = \"\\<lambda>i. if i < n - d then coeff q  (n - d - 1 - i) else coeff r (n - Suc i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "let ?c1 = \"\\<lambda>i. ?c i \\<cdot>\\<^sub>v factorization_lattice u (n-d) k ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g", "proof (rule exI[of _ ?c])"], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "let ?part1 = \"map (\\<lambda>i. vec_of_poly_n (u * monom 1 i) n) [n-d>..0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "let ?part2 = \"map (\\<lambda>i. vec_of_poly_n (monom k i) n) [d>..0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have [simp]: \"dim_vec (M.sumlist (map ?c1 [0..<n - d])) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    n", "by (rule dim_sumlist, auto simp add: dim_factorization_lattice d_def)"], ["proof (state)\nthis:\n  dim_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have [simp]: \"dim_vec (M.sumlist (map ?c1 [n-d..<n])) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    n", "by (rule dim_sumlist, insert d, auto simp add: dim_factorization_lattice d_def)"], ["proof (state)\nthis:\n  dim_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have [simp]: \"factorization_lattice u (n-d) k ! x \\<in> carrier_vec n\" if x: \"x < n\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! x \\<in> carrier_vec n", "using x dim_factorization_lattice_element nth_factorization_lattice[of x u \"n-d\"] d"], ["proof (prove)\nusing this:\n  x < n\n  ?x \\<in> set (factorization_lattice ?u ?d ?m) \\<Longrightarrow>\n  dim_vec ?x = degree ?u + ?d\n  x < degree u + (n - d) \\<Longrightarrow>\n  factorization_lattice u (n - d) ?m ! x =\n  vec_of_poly_n\n   (if x < n - d then u * monom 1 (n - d - Suc x)\n    else monom ?m (degree u + (n - d) - Suc x))\n   (degree u + (n - d))\n  d < n\n\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! x \\<in> carrier_vec n", "by (auto simp: d_def)"], ["proof (state)\nthis:\n  ?x1 < n \\<Longrightarrow>\n  factorization_lattice u (n - d) k ! ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have \"[0..<length (factorization_lattice u (n-d) k)] = [0..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<length (factorization_lattice u (n - d) k)] = [0..<n]", "using d"], ["proof (prove)\nusing this:\n  d < n\n\ngoal (1 subgoal):\n 1. [0..<length (factorization_lattice u (n - d) k)] = [0..<n]", "by (simp add: d_def less_imp_le_nat)"], ["proof (state)\nthis:\n  [0..<length (factorization_lattice u (n - d) k)] = [0..<n]\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "also"], ["proof (state)\nthis:\n  [0..<length (factorization_lattice u (n - d) k)] = [0..<n]\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have \"... = [0..<n - d] @ [n-d..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<n] = [0..<n - d] @ [n - d..<n]", "by (rule upt_minus_eq_append, auto)"], ["proof (state)\nthis:\n  [0..<n] = [0..<n - d] @ [n - d..<n]\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "finally"], ["proof (chain)\npicking this:\n  [0..<length (factorization_lattice u (n - d) k)] =\n  [0..<n - d] @ [n - d..<n]", "have list_rw: \"[0..<length (factorization_lattice u (n-d) k)] = [0..<n - d] @ [n-d..<n]\""], ["proof (prove)\nusing this:\n  [0..<length (factorization_lattice u (n - d) k)] =\n  [0..<n - d] @ [n - d..<n]\n\ngoal (1 subgoal):\n 1. [0..<length (factorization_lattice u (n - d) k)] =\n    [0..<n - d] @ [n - d..<n]", "."], ["proof (state)\nthis:\n  [0..<length (factorization_lattice u (n - d) k)] =\n  [0..<n - d] @ [n - d..<n]\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have qu1: \"poly_of_vec (M.sumlist (map ?c1 [0..<n - d])) = q*u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "have \"poly_of_vec (M.sumlist (map ?c1 [0..<n - d])) = poly_of_vec (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<n-d}. ?c1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<n -\n    d}. (if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)", "by (subst sumlist_map_as_finsum, auto)"], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<n -\n  d}. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "also"], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<n -\n  d}. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "have \"... = poly_of_vec (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<n-d]. ?c1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<n -\n    d}. (if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i) =\n    poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set\n[0..<\n n -\n d]. (if i < n - d then coeff q (n - d - 1 - i)\n      else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n     factorization_lattice u (n - d) k ! i)", "by auto"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<n -\n  d}. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n  n -\n  d]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "also"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<n -\n  d}. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n  n -\n  d]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "have \"... = sum (\\<lambda>i. poly_of_vec (?c1 i)) (set [0..<n-d])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set\n[0..<\n n -\n d]. (if i < n - d then coeff q (n - d - 1 - i)\n      else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n     factorization_lattice u (n - d) k ! i) =\n    (\\<Sum>i\\<in>set [0..<n - d].\n       poly_of_vec\n        ((if i < n - d then coeff q (n - d - 1 - i)\n          else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n         factorization_lattice u (n - d) k ! i))", "by (auto simp:poly_of_vec_finsum)"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n  n -\n  d]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  (\\<Sum>i\\<in>set [0..<n - d].\n     poly_of_vec\n      ((if i < n - d then coeff q (n - d - 1 - i)\n        else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n       factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "also"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n  n -\n  d]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  (\\<Sum>i\\<in>set [0..<n - d].\n     poly_of_vec\n      ((if i < n - d then coeff q (n - d - 1 - i)\n        else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n       factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "have \"... = sum (\\<lambda>i. poly_of_vec (?c1 i)) {0..<n-d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>set [0..<n - d].\n       poly_of_vec\n        ((if i < n - d then coeff q (n - d - 1 - i)\n          else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n         factorization_lattice u (n - d) k ! i)) =\n    (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set [0..<n - d].\n     poly_of_vec\n      ((if i < n - d then coeff q (n - d - 1 - i)\n        else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n       factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>set [0..<n - d].\n     poly_of_vec\n      ((if i < n - d then coeff q (n - d - 1 - i)\n        else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n       factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "have \"... = q*u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have deg: \"degree (u * monom 1 (n - Suc (d + i))) < n\" if i: \"i < n - d\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "let ?m=\"monom (1::int) (n - Suc (d + i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "have monom_not0: \"?m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 (n - Suc (d + i)) \\<noteq> 0", "using i"], ["proof (prove)\nusing this:\n  i < n - d\n\ngoal (1 subgoal):\n 1. monom 1 (n - Suc (d + i)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monom 1 (n - Suc (d + i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "have deg_m: \"degree ?m = n - Suc (d + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 (n - Suc (d + i))) = n - Suc (d + i)", "by (rule degree_monom_eq, auto)"], ["proof (state)\nthis:\n  degree (monom 1 (n - Suc (d + i))) = n - Suc (d + i)\n\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "have \"degree (u * ?m) = d + (n - Suc (d + i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) = d + (n - Suc (d + i))", "using degree_mult_eq[OF u_not0 monom_not0] d_def deg_m"], ["proof (prove)\nusing this:\n  degree (u * monom 1 (n - Suc (d + i))) =\n  degree u + degree (monom 1 (n - Suc (d + i)))\n  d \\<equiv> degree u\n  degree (monom 1 (n - Suc (d + i))) = n - Suc (d + i)\n\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) = d + (n - Suc (d + i))", "by auto"], ["proof (state)\nthis:\n  degree (u * monom 1 (n - Suc (d + i))) = d + (n - Suc (d + i))\n\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "also"], ["proof (state)\nthis:\n  degree (u * monom 1 (n - Suc (d + i))) = d + (n - Suc (d + i))\n\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "have \"... < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d + (n - Suc (d + i)) < n", "using i"], ["proof (prove)\nusing this:\n  i < n - d\n\ngoal (1 subgoal):\n 1. d + (n - Suc (d + i)) < n", "by auto"], ["proof (state)\nthis:\n  d + (n - Suc (d + i)) < n\n\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "finally"], ["proof (chain)\npicking this:\n  degree (u * monom 1 (n - Suc (d + i))) < n", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (u * monom 1 (n - Suc (d + i))) < n\n\ngoal (1 subgoal):\n 1. degree (u * monom 1 (n - Suc (d + i))) < n", "."], ["proof (state)\nthis:\n  degree (u * monom 1 (n - Suc (d + i))) < n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i1 < n - d \\<Longrightarrow> degree (u * monom 1 (n - Suc (d + ?i1))) < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have lattice_rw: \"factorization_lattice u (n-d) k ! i = vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n\" \n          if i: \"i< n - d\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i =\n    vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n", "apply (subst nth_factorization_lattice)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < degree u + (n - d)\n 2. vec_of_poly_n\n     (if i < n - d then u * monom 1 (n - d - Suc i)\n      else monom k (degree u + (n - d) - Suc i))\n     (degree u + (n - d)) =\n    vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n", "using i"], ["proof (prove)\nusing this:\n  i < n - d\n\ngoal (2 subgoals):\n 1. i < degree u + (n - d)\n 2. vec_of_poly_n\n     (if i < n - d then u * monom 1 (n - d - Suc i)\n      else monom k (degree u + (n - d) - Suc i))\n     (degree u + (n - d)) =\n    vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n", "by (auto simp:d_def)"], ["proof (state)\nthis:\n  ?i1 < n - d \\<Longrightarrow>\n  factorization_lattice u (n - d) k ! ?i1 =\n  vec_of_poly_n (u * monom 1 (n - Suc (d + ?i1))) n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have q_rw: \"q = (\\<Sum>i = 0..<n - d. (smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q =\n    (\\<Sum>i = 0..<n - d.\n        smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))", "proof (auto simp add: poly_eq_iff coeff_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "let ?m = \"n-d-1-j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "let ?f = \"\\<lambda>x. coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "have set_rw: \"{0..<n-d} = insert ?m ({0..<n-d} - {?m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n - d} = insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j})", "using d"], ["proof (prove)\nusing this:\n  d < n\n\ngoal (1 subgoal):\n 1. {0..<n - d} = insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j})", "by auto"], ["proof (state)\nthis:\n  {0..<n - d} = insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j})\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "have sum0: \"(\\<Sum>x \\<in> {0..<n-d} - {?m}. ?f x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n       coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n    0", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "have \"(\\<Sum>x = 0..<n - d. ?f x) = (\\<Sum>x \\<in> insert ?m ({0..<n-d} - {?m}). ?f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<n - d.\n        coeff q (n - Suc (d + x)) *\n        (if n - Suc (d + x) = j then 1 else 0)) =\n    (\\<Sum>x\\<in>insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j}).\n       coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0))", "using set_rw"], ["proof (prove)\nusing this:\n  {0..<n - d} = insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<n - d.\n        coeff q (n - Suc (d + x)) *\n        (if n - Suc (d + x) = j then 1 else 0)) =\n    (\\<Sum>x\\<in>insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j}).\n       coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0))", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<n - d.\n      coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  (\\<Sum>x\\<in>insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j}).\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<n - d.\n      coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  (\\<Sum>x\\<in>insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j}).\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "have \"... = ?f ?m + (\\<Sum>x \\<in> {0..<n-d} - {?m}. ?f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j}).\n       coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) +\n    (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n       coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0))", "by (rule sum.insert, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j}).\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) +\n  (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>insert (n - d - 1 - j) ({0..<n - d} - {n - d - 1 - j}).\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) +\n  (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "have \"... = ?f ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) +\n    (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n       coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0)", "unfolding sum0"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) +\n    0 =\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) +\n  (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "also"], ["proof (state)\nthis:\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) +\n  (\\<Sum>x\\<in>{0..<n - d} - {n - d - 1 - j}.\n     coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "have \"... = coeff q j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "proof (cases \"j < n - d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j\n 2. \\<not> j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "case True"], ["proof (state)\nthis:\n  j < n - d\n\ngoal (2 subgoals):\n 1. j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j\n 2. \\<not> j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "then"], ["proof (chain)\npicking this:\n  j < n - d", "show ?thesis"], ["proof (prove)\nusing this:\n  j < n - d\n\ngoal (1 subgoal):\n 1. coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "by auto"], ["proof (state)\nthis:\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n  coeff q j\n\ngoal (1 subgoal):\n 1. \\<not> j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "case False"], ["proof (state)\nthis:\n  \\<not> j < n - d\n\ngoal (1 subgoal):\n 1. \\<not> j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "have \"j>degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q < j", "using degree_q q False d"], ["proof (prove)\nusing this:\n  q = 0 \\<or> degree (q' + smult k q'') < n - d\n  q = q' + smult k q''\n  \\<not> j < n - d\n  d < n\n\ngoal (1 subgoal):\n 1. degree q < j", "by auto"], ["proof (state)\nthis:\n  degree q < j\n\ngoal (1 subgoal):\n 1. \\<not> j < n - d \\<Longrightarrow>\n    coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "then"], ["proof (chain)\npicking this:\n  degree q < j", "show ?thesis"], ["proof (prove)\nusing this:\n  degree q < j\n\ngoal (1 subgoal):\n 1. coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "using coeff_eq_0"], ["proof (prove)\nusing this:\n  degree q < j\n  degree ?p < ?n \\<Longrightarrow> coeff ?p ?n = (0::?'a)\n\ngoal (1 subgoal):\n 1. coeff q (n - Suc (d + (n - d - 1 - j))) *\n    (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n    coeff q j", "by auto"], ["proof (state)\nthis:\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n  coeff q j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff q (n - Suc (d + (n - d - 1 - j))) *\n  (if n - Suc (d + (n - d - 1 - j)) = j then 1 else 0) =\n  coeff q j\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff q na =\n       (\\<Sum>i = 0..<n - d.\n           coeff q (n - Suc (d + i)) *\n           (if n - Suc (d + i) = na then 1 else 0))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x = 0..<n - d.\n      coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  coeff q j", "show \"coeff q j = (\\<Sum>i = 0..<n - d. coeff q (n - Suc (d + i)) \n            * (if n - Suc (d + i) = j then 1 else 0))\""], ["proof (prove)\nusing this:\n  (\\<Sum>x = 0..<n - d.\n      coeff q (n - Suc (d + x)) * (if n - Suc (d + x) = j then 1 else 0)) =\n  coeff q j\n\ngoal (1 subgoal):\n 1. coeff q j =\n    (\\<Sum>i = 0..<n - d.\n        coeff q (n - Suc (d + i)) * (if n - Suc (d + i) = j then 1 else 0))", ".."], ["proof (state)\nthis:\n  coeff q j =\n  (\\<Sum>i = 0..<n - d.\n      coeff q (n - Suc (d + i)) * (if n - Suc (d + i) = j then 1 else 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q =\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have \"sum (\\<lambda>i. poly_of_vec (?c1 i)) {0..<n-d} \n        = (\\<Sum>i = 0..<n - d. poly_of_vec (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v factorization_lattice u (n-d) k ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have \"...  = (\\<Sum>i = 0..<n - d. (poly_of_vec (coeff q (n - Suc (d + i)) \n          \\<cdot>\\<^sub>v (vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n          vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n))", "by (rule sum.cong, auto simp add: lattice_rw)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have \"... = (\\<Sum>i = 0..<n - d. smult (coeff q (n - Suc (d + i))) (u * monom 1 (n - Suc (d + i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n          vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n)) =\n    (\\<Sum>i = 0..<n - d.\n        smult (coeff q (n - Suc (d + i))) (u * monom 1 (n - Suc (d + i))))", "by (rule sum.cong, auto simp add: poly_of_vec_scalar_mult[OF deg])"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n)) =\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (u * monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       (coeff q (n - Suc (d + i)) \\<cdot>\\<^sub>v\n        vec_of_poly_n (u * monom 1 (n - Suc (d + i))) n)) =\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (u * monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have \"... = (\\<Sum>i = 0..<n - d. u*(smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        smult (coeff q (n - Suc (d + i))) (u * monom 1 (n - Suc (d + i)))) =\n    (\\<Sum>i = 0..<n - d.\n        u * smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (u * monom 1 (n - Suc (d + i)))) =\n  (\\<Sum>i = 0..<n - d.\n      u * smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (u * monom 1 (n - Suc (d + i)))) =\n  (\\<Sum>i = 0..<n - d.\n      u * smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have \"... = u *(\\<Sum>i = 0..<n - d. (smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        u * smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))) =\n    u *\n    (\\<Sum>i = 0..<n - d.\n        smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))", "by (rule sum_distrib_left[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      u * smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))) =\n  u *\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      u * smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))) =\n  u *\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have \"... = u * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u *\n    (\\<Sum>i = 0..<n - d.\n        smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))) =\n    u * q", "using q_rw"], ["proof (prove)\nusing this:\n  q =\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i))))\n\ngoal (1 subgoal):\n 1. u *\n    (\\<Sum>i = 0..<n - d.\n        smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))) =\n    u * q", "by auto"], ["proof (state)\nthis:\n  u *\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))) =\n  u * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "also"], ["proof (state)\nthis:\n  u *\n  (\\<Sum>i = 0..<n - d.\n      smult (coeff q (n - Suc (d + i))) (monom 1 (n - Suc (d + i)))) =\n  u * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "have \"... = q*u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * q = q * u", "by auto"], ["proof (state)\nthis:\n  u * q = q * u\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  q * u", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  q * u\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - d.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    q * u", "."], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  q * u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - d.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  q * u\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "finally"], ["proof (chain)\npicking this:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  q * u", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  q * u\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])) =\n    q * u", "."], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  q * u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  q * u\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have qu: \"M.sumlist (map ?c1 [0..<n - d]) = vec_of_poly_n (q*u) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) =\n    vec_of_poly_n (q * u) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) =\n    vec_of_poly_n (q * u) n", "have \"vec_of_poly_n (q*u) n = vec_of_poly_n (poly_of_vec (M.sumlist (map ?c1 [0..<n - d]))) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n =\n    vec_of_poly_n\n     (poly_of_vec\n       (M.sumlist\n         (map (\\<lambda>i.\n                  (if i < n - d then coeff q (n - d - 1 - i)\n                   else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                  factorization_lattice u (n - d) k ! i)\n           [0..<n - d])))\n     n", "using qu1"], ["proof (prove)\nusing this:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])) =\n  q * u\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n =\n    vec_of_poly_n\n     (poly_of_vec\n       (M.sumlist\n         (map (\\<lambda>i.\n                  (if i < n - d then coeff q (n - d - 1 - i)\n                   else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                  factorization_lattice u (n - d) k ! i)\n           [0..<n - d])))\n     n", "by auto"], ["proof (state)\nthis:\n  vec_of_poly_n (q * u) n =\n  vec_of_poly_n\n   (poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])))\n   n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) =\n    vec_of_poly_n (q * u) n", "also"], ["proof (state)\nthis:\n  vec_of_poly_n (q * u) n =\n  vec_of_poly_n\n   (poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])))\n   n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) =\n    vec_of_poly_n (q * u) n", "have \"vec_of_poly_n (poly_of_vec (M.sumlist (map ?c1 [0..<n - d]))) n \n        = M.sumlist (map ?c1 [0..<n - d])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n\n     (poly_of_vec\n       (M.sumlist\n         (map (\\<lambda>i.\n                  (if i < n - d then coeff q (n - d - 1 - i)\n                   else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                  factorization_lattice u (n - d) k ! i)\n           [0..<n - d])))\n     n =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d])", "by (rule vec_of_poly_n_poly_of_vec, auto)"], ["proof (state)\nthis:\n  vec_of_poly_n\n   (poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [0..<n - d])))\n   n =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) =\n    vec_of_poly_n (q * u) n", "finally"], ["proof (chain)\npicking this:\n  vec_of_poly_n (q * u) n =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d])", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_of_poly_n (q * u) n =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) =\n    vec_of_poly_n (q * u) n", ".."], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d]) =\n  vec_of_poly_n (q * u) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d]) =\n  vec_of_poly_n (q * u) n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have rm1: \"poly_of_vec (M.sumlist (map ?c1 [n-d..<n])) = smult k r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "have \"poly_of_vec (M.sumlist (map ?c1 [n-d..<n])) = poly_of_vec (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{n-d..<n}. ?c1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{n -\nd..<n}. (if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)", "by (subst sumlist_map_as_finsum, auto)"], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{n -\n                                    d..<n}. (if i < n - d\n       then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "also"], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{n -\n                                    d..<n}. (if i < n - d\n       then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "have \"... = poly_of_vec (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [n-d..<n]. ?c1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{n -\nd..<n}. (if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i) =\n    poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set\n[n - d..<\n n]. (if i < n - d then coeff q (n - d - 1 - i)\n      else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n     factorization_lattice u (n - d) k ! i)", "by auto"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{n -\n                                    d..<n}. (if i < n - d\n       then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [n - d..<\n  n]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "also"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{n -\n                                    d..<n}. (if i < n - d\n       then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [n - d..<\n  n]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i)\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "have \"... = sum (\\<lambda>i. poly_of_vec (?c1 i)) {n-d..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set\n[n - d..<\n n]. (if i < n - d then coeff q (n - d - 1 - i)\n      else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n     factorization_lattice u (n - d) k ! i) =\n    (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i))", "by (auto simp: poly_of_vec_finsum)"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [n - d..<\n  n]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "also"], ["proof (state)\nthis:\n  poly_of_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [n - d..<\n  n]. (if i < n - d then coeff q (n - d - 1 - i)\n       else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n      factorization_lattice u (n - d) k ! i) =\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "have \"... = smult k r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have deg: \"degree (monom k (n - Suc i)) < n\" if i: \"n-d\\<le>i\" and i2: \"i<n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom k (n - Suc i)) < n", "using degree_monom_le i i2"], ["proof (prove)\nusing this:\n  degree (monom ?a ?n) \\<le> ?n\n  n - d \\<le> i\n  i < n\n\ngoal (1 subgoal):\n 1. degree (monom k (n - Suc i)) < n", "by (simp add: degree_monom_eq k_not0)"], ["proof (state)\nthis:\n  \\<lbrakk>n - d \\<le> ?i1; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> degree (monom k (n - Suc ?i1)) < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have lattice_rw: \"factorization_lattice u (n-d) k ! i = vec_of_poly_n (monom k (n - Suc i)) n\" \n          if i: \"n - d \\<le> i\" and i2: \"i<n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i =\n    vec_of_poly_n (monom k (n - Suc i)) n", "using i2 i d d_def"], ["proof (prove)\nusing this:\n  i < n\n  n - d \\<le> i\n  d < n\n  d \\<equiv> degree u\n\ngoal (1 subgoal):\n 1. factorization_lattice u (n - d) k ! i =\n    vec_of_poly_n (monom k (n - Suc i)) n", "by (subst nth_factorization_lattice, auto)"], ["proof (state)\nthis:\n  \\<lbrakk>n - d \\<le> ?i1; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> factorization_lattice u (n - d) k ! ?i1 =\n                    vec_of_poly_n (monom k (n - Suc ?i1)) n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have r_rw: \"r = (\\<Sum>i \\<in> {n-d..<n}. (monom (coeff r (n - Suc i)) (n - Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i))", "proof (auto simp add: poly_eq_iff coeff_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff r na =\n       (\\<Sum>i = n - d..<n.\n           if n - Suc i = na then coeff r (n - Suc i) else 0)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff r na =\n       (\\<Sum>i = n - d..<n.\n           if n - Suc i = na then coeff r (n - Suc i) else 0)", "show \"coeff r j = (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "proof (cases \"j<d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "case True"], ["proof (state)\nthis:\n  j < d\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "have j_eq: \"n - Suc (n - 1 - j) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc (n - 1 - j) = j", "using d True"], ["proof (prove)\nusing this:\n  d < n\n  j < d\n\ngoal (1 subgoal):\n 1. n - Suc (n - 1 - j) = j", "by auto"], ["proof (state)\nthis:\n  n - Suc (n - 1 - j) = j\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "let ?i = \"n-1-j\""], ["proof (state)\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "let ?f =\"\\<lambda>i. if n - Suc i = j then coeff r (n - Suc i) else 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "have sum0: \"sum ?f ({n-d..<n} - {?i}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{n - d..<n} - {n - 1 - j}.\n       if n - Suc i = j then coeff r (n - Suc i) else 0) =\n    0", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{n - d..<n} - {n - 1 - j}.\n     if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  0\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "have \"{n-d..<n} = insert ?i ({n-d..<n} - {?i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n - d..<n} = insert (n - 1 - j) ({n - d..<n} - {n - 1 - j})", "using True"], ["proof (prove)\nusing this:\n  j < d\n\ngoal (1 subgoal):\n 1. {n - d..<n} = insert (n - 1 - j) ({n - d..<n} - {n - 1 - j})", "by auto"], ["proof (state)\nthis:\n  {n - d..<n} = insert (n - 1 - j) ({n - d..<n} - {n - 1 - j})\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "hence \"sum ?f {n - d..<n} = sum ?f (insert ?i ({n-d..<n} - {?i}))\""], ["proof (prove)\nusing this:\n  {n - d..<n} = insert (n - 1 - j) ({n - d..<n} - {n - 1 - j})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        if n - Suc i = j then coeff r (n - Suc i) else 0) =\n    (\\<Sum>i\\<in>insert (n - 1 - j) ({n - d..<n} - {n - 1 - j}).\n       if n - Suc i = j then coeff r (n - Suc i) else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  (\\<Sum>i\\<in>insert (n - 1 - j) ({n - d..<n} - {n - 1 - j}).\n     if n - Suc i = j then coeff r (n - Suc i) else 0)\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  (\\<Sum>i\\<in>insert (n - 1 - j) ({n - d..<n} - {n - 1 - j}).\n     if n - Suc i = j then coeff r (n - Suc i) else 0)\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "have \"... = ?f ?i + sum ?f ({n-d..<n} - {?i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert (n - 1 - j) ({n - d..<n} - {n - 1 - j}).\n       if n - Suc i = j then coeff r (n - Suc i) else 0) =\n    (if n - Suc (n - 1 - j) = j then coeff r (n - Suc (n - 1 - j)) else 0) +\n    (\\<Sum>i\\<in>{n - d..<n} - {n - 1 - j}.\n       if n - Suc i = j then coeff r (n - Suc i) else 0)", "by (rule sum.insert, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert (n - 1 - j) ({n - d..<n} - {n - 1 - j}).\n     if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  (if n - Suc (n - 1 - j) = j then coeff r (n - Suc (n - 1 - j)) else 0) +\n  (\\<Sum>i\\<in>{n - d..<n} - {n - 1 - j}.\n     if n - Suc i = j then coeff r (n - Suc i) else 0)\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert (n - 1 - j) ({n - d..<n} - {n - 1 - j}).\n     if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  (if n - Suc (n - 1 - j) = j then coeff r (n - Suc (n - 1 - j)) else 0) +\n  (\\<Sum>i\\<in>{n - d..<n} - {n - 1 - j}.\n     if n - Suc i = j then coeff r (n - Suc i) else 0)\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "have \"... = coeff r j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n - Suc (n - 1 - j) = j then coeff r (n - Suc (n - 1 - j)) else 0) +\n    (\\<Sum>i\\<in>{n - d..<n} - {n - 1 - j}.\n       if n - Suc i = j then coeff r (n - Suc i) else 0) =\n    coeff r j", "unfolding sum0 j_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = j then coeff r j else 0) + 0 = coeff r j", "by simp"], ["proof (state)\nthis:\n  (if n - Suc (n - 1 - j) = j then coeff r (n - Suc (n - 1 - j)) else 0) +\n  (\\<Sum>i\\<in>{n - d..<n} - {n - 1 - j}.\n     if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  coeff r j\n\ngoal (2 subgoals):\n 1. j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n 2. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  coeff r j", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  coeff r j\n\ngoal (1 subgoal):\n 1. coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", ".."], ["proof (state)\nthis:\n  coeff r j =\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n\ngoal (1 subgoal):\n 1. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> j < d\n\ngoal (1 subgoal):\n 1. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "hence \"(\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) = 0\""], ["proof (prove)\nusing this:\n  \\<not> j < d\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        if n - Suc i = j then coeff r (n - Suc i) else 0) =\n    0", "by (intro sum.neutral ballI, insert False, simp, linarith)"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "have \"... = coeff r j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = coeff r j", "by (rule coeff_eq_0[symmetric], insert False deg_r'' r d_def, auto)"], ["proof (state)\nthis:\n  0 = coeff r j\n\ngoal (1 subgoal):\n 1. \\<not> j < d \\<Longrightarrow>\n    coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  coeff r j", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0) =\n  coeff r j\n\ngoal (1 subgoal):\n 1. coeff r j =\n    (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)", ".."], ["proof (state)\nthis:\n  coeff r j =\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff r j =\n  (\\<Sum>i = n - d..<n. if n - Suc i = j then coeff r (n - Suc i) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r = (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have \"sum (\\<lambda>i. poly_of_vec (?c1 i)) {n-d..<n} \n        = (\\<Sum>i \\<in> {n-d..<n}. poly_of_vec (coeff r (n - Suc i) \\<cdot>\\<^sub>v factorization_lattice u (n-d) k ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have \"...  = (\\<Sum>i \\<in> {n-d..<n}. (poly_of_vec (coeff r (n - Suc i) \n          \\<cdot>\\<^sub>v vec_of_poly_n (monom k (n - Suc i)) n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n          vec_of_poly_n (monom k (n - Suc i)) n))", "by (rule sum.cong, auto simp add: lattice_rw)"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        vec_of_poly_n (monom k (n - Suc i)) n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        vec_of_poly_n (monom k (n - Suc i)) n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have \"... = (\\<Sum>i \\<in> {n-d..<n}. smult (coeff r (n - Suc i)) (monom k (n - Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n          vec_of_poly_n (monom k (n - Suc i)) n)) =\n    (\\<Sum>i = n - d..<n. smult (coeff r (n - Suc i)) (monom k (n - Suc i)))", "by (rule sum.cong, auto simp add: poly_of_vec_scalar_mult[OF deg])"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        vec_of_poly_n (monom k (n - Suc i)) n)) =\n  (\\<Sum>i = n - d..<n. smult (coeff r (n - Suc i)) (monom k (n - Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       (coeff r (n - Suc i) \\<cdot>\\<^sub>v\n        vec_of_poly_n (monom k (n - Suc i)) n)) =\n  (\\<Sum>i = n - d..<n. smult (coeff r (n - Suc i)) (monom k (n - Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have \"... = (\\<Sum>i \\<in> {n-d..<n}. smult k (monom (coeff r (n - Suc i)) (n - Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        smult (coeff r (n - Suc i)) (monom k (n - Suc i))) =\n    (\\<Sum>i = n - d..<n. smult k (monom (coeff r (n - Suc i)) (n - Suc i)))", "by (rule sum.cong, auto simp add: smult_monom smult_sum2)"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. smult (coeff r (n - Suc i)) (monom k (n - Suc i))) =\n  (\\<Sum>i = n - d..<n. smult k (monom (coeff r (n - Suc i)) (n - Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. smult (coeff r (n - Suc i)) (monom k (n - Suc i))) =\n  (\\<Sum>i = n - d..<n. smult k (monom (coeff r (n - Suc i)) (n - Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have \"... = smult k (\\<Sum>i \\<in> {n-d..<n}. (monom (coeff r (n - Suc i)) (n - Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        smult k (monom (coeff r (n - Suc i)) (n - Suc i))) =\n    smult k (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i))", "by (simp add: smult_sum2)"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. smult k (monom (coeff r (n - Suc i)) (n - Suc i))) =\n  smult k (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n. smult k (monom (coeff r (n - Suc i)) (n - Suc i))) =\n  smult k (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "have \"... = smult k r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult k (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i)) =\n    smult k r", "using r_rw"], ["proof (prove)\nusing this:\n  r = (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i))\n\ngoal (1 subgoal):\n 1. smult k (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i)) =\n    smult k r", "by auto"], ["proof (state)\nthis:\n  smult k (\\<Sum>i = n - d..<n. monom (coeff r (n - Suc i)) (n - Suc i)) =\n  smult k r\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  smult k r", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  smult k r\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n - d..<n.\n        poly_of_vec\n         ((if i < n - d then coeff q (n - d - 1 - i)\n           else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n          factorization_lattice u (n - d) k ! i)) =\n    smult k r", "."], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  smult k r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = n - d..<n.\n      poly_of_vec\n       ((if i < n - d then coeff q (n - d - 1 - i)\n         else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n        factorization_lattice u (n - d) k ! i)) =\n  smult k r\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "finally"], ["proof (chain)\npicking this:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  smult k r", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  smult k r\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])) =\n    smult k r", "."], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  smult k r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  smult k r\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have rm: \"(M.sumlist (map ?c1 [n-d..<n])) = vec_of_poly_n (smult k r) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    vec_of_poly_n (smult k r) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    vec_of_poly_n (smult k r) n", "have \"vec_of_poly_n (smult k r) n \n        = vec_of_poly_n (poly_of_vec (M.sumlist (map ?c1 [n-d..<n]))) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (smult k r) n =\n    vec_of_poly_n\n     (poly_of_vec\n       (M.sumlist\n         (map (\\<lambda>i.\n                  (if i < n - d then coeff q (n - d - 1 - i)\n                   else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                  factorization_lattice u (n - d) k ! i)\n           [n - d..<n])))\n     n", "using rm1"], ["proof (prove)\nusing this:\n  poly_of_vec\n   (M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])) =\n  smult k r\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (smult k r) n =\n    vec_of_poly_n\n     (poly_of_vec\n       (M.sumlist\n         (map (\\<lambda>i.\n                  (if i < n - d then coeff q (n - d - 1 - i)\n                   else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                  factorization_lattice u (n - d) k ! i)\n           [n - d..<n])))\n     n", "by auto"], ["proof (state)\nthis:\n  vec_of_poly_n (smult k r) n =\n  vec_of_poly_n\n   (poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])))\n   n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    vec_of_poly_n (smult k r) n", "also"], ["proof (state)\nthis:\n  vec_of_poly_n (smult k r) n =\n  vec_of_poly_n\n   (poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])))\n   n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    vec_of_poly_n (smult k r) n", "have \"vec_of_poly_n (poly_of_vec (M.sumlist (map ?c1 [n-d..<n]))) n \n        = M.sumlist (map ?c1 [n-d..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n\n     (poly_of_vec\n       (M.sumlist\n         (map (\\<lambda>i.\n                  (if i < n - d then coeff q (n - d - 1 - i)\n                   else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                  factorization_lattice u (n - d) k ! i)\n           [n - d..<n])))\n     n =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])", "by (rule vec_of_poly_n_poly_of_vec, auto)"], ["proof (state)\nthis:\n  vec_of_poly_n\n   (poly_of_vec\n     (M.sumlist\n       (map (\\<lambda>i.\n                (if i < n - d then coeff q (n - d - 1 - i)\n                 else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n                factorization_lattice u (n - d) k ! i)\n         [n - d..<n])))\n   n =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    vec_of_poly_n (smult k r) n", "finally"], ["proof (chain)\npicking this:\n  vec_of_poly_n (smult k r) n =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n])", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_of_poly_n (smult k r) n =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    vec_of_poly_n (smult k r) n", ".."], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n]) =\n  vec_of_poly_n (smult k r) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n]) =\n  vec_of_poly_n (smult k r) n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have \"lincomb_list ?c (factorization_lattice u (n-d) k) = M.sumlist (map ?c1 ([0..<n - d] @ [n-d..<n]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       ([0..<n - d] @ [n - d..<n]))", "unfolding lincomb_list_def list_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       ([0..<n - d] @ [n - d..<n])) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       ([0..<n - d] @ [n - d..<n]))", "by auto"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>i.\n       if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n   (factorization_lattice u (n - d) k) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     ([0..<n - d] @ [n - d..<n]))\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "also"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>i.\n       if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n   (factorization_lattice u (n - d) k) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     ([0..<n - d] @ [n - d..<n]))\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have \"... = M.sumlist (map ?c1 [0..<n - d] @ map ?c1 [n-d..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       ([0..<n - d] @ [n - d..<n])) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d] @\n      map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])", "by auto"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     ([0..<n - d] @ [n - d..<n])) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d] @\n    map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n])\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     ([0..<n - d] @ [n - d..<n])) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d] @\n    map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n])\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have \"... = M.sumlist (map ?c1 [0..<n - d]) + M.sumlist (map ?c1 [n-d..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d] @\n      map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) +\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])", "using d"], ["proof (prove)\nusing this:\n  d < n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d] @\n      map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) +\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n])", "by (auto simp add: d_def nth_factorization_lattice intro!: M.sumlist_append)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d] @\n    map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d]) +\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n])\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d] @\n    map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n]) =\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d]) +\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n])\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have \"... = vec_of_poly_n (q*u) n + vec_of_poly_n (smult k r) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [0..<n - d]) +\n    M.sumlist\n     (map (\\<lambda>i.\n              (if i < n - d then coeff q (n - d - 1 - i)\n               else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n              factorization_lattice u (n - d) k ! i)\n       [n - d..<n]) =\n    vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n", "unfolding qu rm"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n =\n    vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n", "by auto"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d]) +\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n]) =\n  vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [0..<n - d]) +\n  M.sumlist\n   (map (\\<lambda>i.\n            (if i < n - d then coeff q (n - d - 1 - i)\n             else coeff r (n - Suc i)) \\<cdot>\\<^sub>v\n            factorization_lattice u (n - d) k ! i)\n     [n - d..<n]) =\n  vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "have \"... = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "using g2"], ["proof (prove)\nusing this:\n  vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g", "by simp"], ["proof (state)\nthis:\n  vec_of_poly_n (q * u) n + vec_of_poly_n (smult k r) n = g\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "finally"], ["proof (chain)\npicking this:\n  lincomb_list\n   (\\<lambda>i.\n       if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n   (factorization_lattice u (n - d) k) =\n  g", "show \"lincomb_list ?c (factorization_lattice u (n-d) k) = g\""], ["proof (prove)\nusing this:\n  lincomb_list\n   (\\<lambda>i.\n       if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n   (factorization_lattice u (n - d) k) =\n  g\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>i.\n         if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n     (factorization_lattice u (n - d) k) =\n    g", "."], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>i.\n       if i < n - d then coeff q (n - d - 1 - i) else coeff r (n - Suc i))\n   (factorization_lattice u (n - d) k) =\n  g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>c. lincomb_list c (factorization_lattice u (n - d) k) = g\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The factorization lattice precisely characterises the polynomials of a certain\n  degree which divide $u$ modulo $M$.\\<close>"], ["", "lemma factorization_lattice: fixes M assumes  \n  deg_u: \"degree u \\<noteq> 0\"  and M: \"M \\<noteq> 0\" \nshows \"degree u \\<le> n \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> f \\<in> poly_of_vec ` lattice_of (factorization_lattice u (n - degree u) M) \\<Longrightarrow> \n  degree f < n \\<and> poly_mod.dvdm M u f\" \n  \"monic u \\<Longrightarrow> degree u < n \\<Longrightarrow> \n  degree f < n \\<Longrightarrow> poly_mod.dvdm M u f \\<Longrightarrow> f \\<in> poly_of_vec ` lattice_of (factorization_lattice u (n - degree u) M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n      f \\<in> poly_of_vec `\n              lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n     \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f) &&&\n    (\\<lbrakk>monic u; degree u < n; degree f < n;\n      poly_mod.dvdm M u f\\<rbrakk>\n     \\<Longrightarrow> f \\<in> poly_of_vec `\n                               lattice_of\n                                (factorization_lattice u (n - degree u) M))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "from deg_u"], ["proof (chain)\npicking this:\n  degree u \\<noteq> 0", "have deg_u: \"degree u > 0\""], ["proof (prove)\nusing this:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree u", "by auto"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "let ?L = \"factorization_lattice u (n - degree u) M\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "assume deg: \"degree f < n\" and dvd: \"poly_mod.dvdm M u f\" and mon: \"monic u\" \n      and deg_u_lt: \"degree u < n\""], ["proof (state)\nthis:\n  degree f < n\n  poly_mod.dvdm M u f\n  monic u\n  degree u < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "define fv where \"fv = vec n (\\<lambda> i. (coeff f (n - Suc i)))\""], ["proof (state)\nthis:\n  fv = vec n (\\<lambda>i. coeff f (n - Suc i))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "have f: \"f = poly_of_vec fv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = poly_of_vec fv", "unfolding fv_def poly_of_vec_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    (\\<Sum>i<dim_vec (vec n (\\<lambda>i. coeff f (n - Suc i))).\n        monom\n         (vec n (\\<lambda>i. coeff f (n - Suc i)) $\n          (dim_vec (vec n (\\<lambda>i. coeff f (n - Suc i))) - Suc i))\n         i)", "using deg"], ["proof (prove)\nusing this:\n  degree f < n\n\ngoal (1 subgoal):\n 1. f =\n    (\\<Sum>i<dim_vec (vec n (\\<lambda>i. coeff f (n - Suc i))).\n        monom\n         (vec n (\\<lambda>i. coeff f (n - Suc i)) $\n          (dim_vec (vec n (\\<lambda>i. coeff f (n - Suc i))) - Suc i))\n         i)", "by (auto intro!: poly_eqI coeff_eq_0 simp: coeff_sum)"], ["proof (state)\nthis:\n  f = poly_of_vec fv\n\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "have dim_fv: \"dim_vec fv = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec fv = n", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec n (\\<lambda>i. coeff f (n - Suc i))) = n", "by simp"], ["proof (state)\nthis:\n  dim_vec fv = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "from dvd_modulo_to_lincomb[OF deg_u_lt _ M mon _ deg_u(1), of fv, folded f, OF dvd dim_fv]"], ["proof (chain)\npicking this:\n  \\<exists>c. lincomb_list c (factorization_lattice u (n - degree u) M) = fv", "obtain c where gv: \"fv = lincomb_list c ?L\""], ["proof (prove)\nusing this:\n  \\<exists>c. lincomb_list c (factorization_lattice u (n - degree u) M) = fv\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        fv =\n        lincomb_list c\n         (factorization_lattice u (n - degree u) M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fv = lincomb_list c (factorization_lattice u (n - degree u) M)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "have \"fv \\<in> lattice_of ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv \\<in> lattice_of (factorization_lattice u (n - degree u) M)", "unfolding gv lattice_is_span"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list c (factorization_lattice u (n - degree u) M)\n    \\<in> span_list (factorization_lattice u (n - degree u) M)", "by (auto simp: in_span_listI)"], ["proof (state)\nthis:\n  fv \\<in> lattice_of (factorization_lattice u (n - degree u) M)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n 2. \\<lbrakk>monic u; degree u < n; degree f < n;\n     poly_mod.dvdm M u f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> poly_of_vec `\n                              lattice_of\n                               (factorization_lattice u (n - degree u) M)", "thus \"f \\<in> poly_of_vec ` lattice_of ?L\""], ["proof (prove)\nusing this:\n  fv \\<in> lattice_of (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. f \\<in> poly_of_vec `\n            lattice_of (factorization_lattice u (n - degree u) M)", "unfolding f"], ["proof (prove)\nusing this:\n  fv \\<in> lattice_of (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. poly_of_vec fv\n    \\<in> poly_of_vec `\n          lattice_of (factorization_lattice u (n - degree u) M)", "by auto"], ["proof (state)\nthis:\n  f \\<in> poly_of_vec `\n          lattice_of (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "}"], ["proof (state)\nthis:\n  \\<lbrakk>degree f < n; poly_mod.dvdm M u f; monic u; degree u < n\\<rbrakk>\n  \\<Longrightarrow> f \\<in> poly_of_vec `\n                            lattice_of\n                             (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>degree f < n; poly_mod.dvdm M u f; monic u; degree u < n\\<rbrakk>\n  \\<Longrightarrow> f \\<in> poly_of_vec `\n                            lattice_of\n                             (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "{"], ["proof (state)\nthis:\n  \\<lbrakk>degree f < n; poly_mod.dvdm M u f; monic u; degree u < n\\<rbrakk>\n  \\<Longrightarrow> f \\<in> poly_of_vec `\n                            lattice_of\n                             (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "assume \"f \\<in> poly_of_vec ` lattice_of ?L\" and deg_u: \"degree u \\<le> n\" and n: \"n \\<noteq> 0\""], ["proof (state)\nthis:\n  f \\<in> poly_of_vec `\n          lattice_of (factorization_lattice u (n - degree u) M)\n  degree u \\<le> n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "then"], ["proof (chain)\npicking this:\n  f \\<in> poly_of_vec `\n          lattice_of (factorization_lattice u (n - degree u) M)\n  degree u \\<le> n\n  n \\<noteq> 0", "obtain fv where f: \"f = poly_of_vec fv\" and fv: \"fv \\<in> lattice_of ?L\""], ["proof (prove)\nusing this:\n  f \\<in> poly_of_vec `\n          lattice_of (factorization_lattice u (n - degree u) M)\n  degree u \\<le> n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>fv.\n        \\<lbrakk>f = poly_of_vec fv;\n         fv \\<in> lattice_of\n                   (factorization_lattice u (n - degree u) M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = poly_of_vec fv\n  fv \\<in> lattice_of (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "from in_span_listE[OF fv[unfolded lattice_is_span]]"], ["proof (chain)\npicking this:\n  (\\<And>c.\n      \\<lbrakk>True;\n       fv =\n       lincomb_list c (factorization_lattice u (n - degree u) M)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where fv: \"fv = lincomb_list c ?L\""], ["proof (prove)\nusing this:\n  (\\<And>c.\n      \\<lbrakk>True;\n       fv =\n       lincomb_list c (factorization_lattice u (n - degree u) M)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        fv =\n        lincomb_list c\n         (factorization_lattice u (n - degree u) M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fv = lincomb_list c (factorization_lattice u (n - degree u) M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "from lincomb_to_dvd_modulo[OF _ fv[symmetric]] deg_u f"], ["proof (chain)\npicking this:\n  degree u \\<le> n \\<Longrightarrow> poly_mod.dvdm M u (poly_of_vec fv)\n  degree u \\<le> n\n  f = poly_of_vec fv", "have dvd: \"poly_mod.dvdm M u f\""], ["proof (prove)\nusing this:\n  degree u \\<le> n \\<Longrightarrow> poly_mod.dvdm M u (poly_of_vec fv)\n  degree u \\<le> n\n  f = poly_of_vec fv\n\ngoal (1 subgoal):\n 1. poly_mod.dvdm M u f", "by auto"], ["proof (state)\nthis:\n  poly_mod.dvdm M u f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "have \"set ?L \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (factorization_lattice u (n - degree u) M) \\<subseteq> carrier_vec n", "unfolding factorization_lattice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 vec_of_poly_n (u * monom 1 i) (degree u + (n - degree u)))\n          [n - degree u>..0] @\n         map (\\<lambda>i.\n                 vec_of_poly_n (monom M i) (degree u + (n - degree u)))\n          [degree u>..0])\n    \\<subseteq> carrier_vec n", "using deg_u"], ["proof (prove)\nusing this:\n  degree u \\<le> n\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 vec_of_poly_n (u * monom 1 i) (degree u + (n - degree u)))\n          [n - degree u>..0] @\n         map (\\<lambda>i.\n                 vec_of_poly_n (monom M i) (degree u + (n - degree u)))\n          [degree u>..0])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (factorization_lattice u (n - degree u) M) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "hence \"fv \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set (factorization_lattice u (n - degree u) M) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. fv \\<in> carrier_vec n", "unfolding fv"], ["proof (prove)\nusing this:\n  set (factorization_lattice u (n - degree u) M) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lincomb_list c (factorization_lattice u (n - degree u) M)\n    \\<in> carrier_vec n", "by (metis lincomb_list_carrier)"], ["proof (state)\nthis:\n  fv \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "hence \"degree f < n\""], ["proof (prove)\nusing this:\n  fv \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. degree f < n", "unfolding f"], ["proof (prove)\nusing this:\n  fv \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec fv) < n", "using degree_poly_of_vec_less[of fv n]"], ["proof (prove)\nusing this:\n  fv \\<in> carrier_vec n\n  \\<lbrakk>0 < dim_vec fv; dim_vec fv \\<le> n\\<rbrakk>\n  \\<Longrightarrow> degree (poly_of_vec fv) < n\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec fv) < n", "using n"], ["proof (prove)\nusing this:\n  fv \\<in> carrier_vec n\n  \\<lbrakk>0 < dim_vec fv; dim_vec fv \\<le> n\\<rbrakk>\n  \\<Longrightarrow> degree (poly_of_vec fv) < n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec fv) < n", "by auto"], ["proof (state)\nthis:\n  degree f < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u \\<le> n; n \\<noteq> 0;\n     f \\<in> poly_of_vec `\n             lattice_of (factorization_lattice u (n - degree u) M)\\<rbrakk>\n    \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f", "with dvd"], ["proof (chain)\npicking this:\n  poly_mod.dvdm M u f\n  degree f < n", "show \"degree f < n \\<and> poly_mod.dvdm M u f\""], ["proof (prove)\nusing this:\n  poly_mod.dvdm M u f\n  degree f < n\n\ngoal (1 subgoal):\n 1. degree f < n \\<and> poly_mod.dvdm M u f", "by auto"], ["proof (state)\nthis:\n  degree f < n \\<and> poly_mod.dvdm M u f\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>f \\<in> poly_of_vec `\n                   lattice_of (factorization_lattice u (n - degree u) M);\n   degree u \\<le> n; n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree f < n \\<and> poly_mod.dvdm M u f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Soundness of the LLL factorization algorithm\\<close>"], ["", "lemma LLL_short_polynomial: assumes deg_u_0: \"degree u \\<noteq> 0\" and deg_le: \"degree u \\<le> n\" \n  and pl1: \"pl > 1\" \n  and monic: \"monic u\" \nshows \"degree (LLL_short_polynomial pl n u) < n\" \n  and \"LLL_short_polynomial pl n u \\<noteq> 0\"\n  and \"poly_mod.dvdm pl u (LLL_short_polynomial pl n u)\" \n  and \"degree u < n \\<Longrightarrow> f \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.dvdm pl u f \\<Longrightarrow> degree f < n \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2 \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degree (LLL_short_polynomial pl n u) < n &&&\n     LLL_short_polynomial pl n u \\<noteq> 0) &&&\n    poly_mod.dvdm pl u (LLL_short_polynomial pl n u) &&&\n    (\\<lbrakk>degree u < n; f \\<noteq> 0; poly_mod.dvdm pl u f;\n      degree f < n\\<rbrakk>\n     \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                   u\\<parallel>\\<^sup>2\n                       \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. poly_mod.dvdm pl u (LLL_short_polynomial pl n u)\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; poly_mod.dvdm pl u f;\n     degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "interpret poly_mod_2 pl"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 pl", "by (unfold_locales, insert pl1, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from pl1"], ["proof (chain)\npicking this:\n  1 < pl", "have pl0: \"pl \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < pl\n\ngoal (1 subgoal):\n 1. pl \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pl \\<noteq> 0\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "let ?d = \"degree u\""], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "let ?u = \"Mp u\""], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "let ?iu = \"inv_Mp ?u\""], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from Mp_inv_Mp_id[of ?u]"], ["proof (chain)\npicking this:\n  inv_Mp (Mp u) =m Mp u", "have \"?iu =m ?u\""], ["proof (prove)\nusing this:\n  inv_Mp (Mp u) =m Mp u\n\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) =m Mp u", "."], ["proof (state)\nthis:\n  inv_Mp (Mp u) =m Mp u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  inv_Mp (Mp u) =m Mp u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have \"\\<dots> =m u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Mp u) =m u", "by simp"], ["proof (state)\nthis:\n  Mp (Mp u) =m u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  Mp (inv_Mp (Mp u)) =m u", "have iu_u: \"?iu =m u\""], ["proof (prove)\nusing this:\n  Mp (inv_Mp (Mp u)) =m u\n\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) =m u", "by simp"], ["proof (state)\nthis:\n  inv_Mp (Mp u) =m u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have degu[simp]: \"degree ?u = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m u = degree u", "using monic"], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. degree_m u = degree u", "by simp"], ["proof (state)\nthis:\n  degree_m u = degree u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have mon: \"monic ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (Mp u)", "using monic"], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. monic (Mp u)", "by (rule monic_Mp)"], ["proof (state)\nthis:\n  monic (Mp u)\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have \"degree ?iu = degree ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (inv_Mp (Mp u)) = degree_m u", "unfolding inv_Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly inv_M (Mp u)) = degree_m u", "by (rule degree_map_poly, unfold mon, insert mon pl1, auto simp: inv_M_def)"], ["proof (state)\nthis:\n  degree (inv_Mp (Mp u)) = degree_m u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "with degu"], ["proof (chain)\npicking this:\n  degree_m u = degree u\n  degree (inv_Mp (Mp u)) = degree_m u", "have deg_iu: \"degree ?iu = degree u\""], ["proof (prove)\nusing this:\n  degree_m u = degree u\n  degree (inv_Mp (Mp u)) = degree_m u\n\ngoal (1 subgoal):\n 1. degree (inv_Mp (Mp u)) = degree u", "by simp"], ["proof (state)\nthis:\n  degree (inv_Mp (Mp u)) = degree u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have mon_iu: \"monic ?iu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (inv_Mp (Mp u))", "unfolding deg_iu"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (inv_Mp (Mp u)) (degree u) = 1", "unfolding inv_Mp_def Mp_def inv_M_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff\n     (map_poly (\\<lambda>x. if x + x \\<le> pl then x else x - pl)\n       (map_poly (\\<lambda>x. x mod pl) u))\n     (degree u) =\n    1", "by (insert pl1, auto simp: coeff_map_poly monic)"], ["proof (state)\nthis:\n  monic (inv_Mp (Mp u))\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "let ?L = \"factorization_lattice ?iu (n - ?d) pl\""], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "let ?sv = \"short_vector_hybrid 2 ?L\""], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from deg_u_0 deg_le"], ["proof (chain)\npicking this:\n  degree u \\<noteq> 0\n  degree u \\<le> n", "have n: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree u \\<noteq> 0\n  degree u \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from deg_u_0"], ["proof (chain)\npicking this:\n  degree u \\<noteq> 0", "have u0: \"u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have id: \"LLL_short_polynomial pl n u = poly_of_vec ?sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_short_polynomial pl n u =\n    poly_of_vec\n     (short_vector_hybrid 2\n       (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl))", "unfolding LLL_short_polynomial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec\n     (short_vector_hybrid 2\n       (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)) =\n    poly_of_vec\n     (short_vector_hybrid 2\n       (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl))", "by blast"], ["proof (state)\nthis:\n  LLL_short_polynomial pl n u =\n  poly_of_vec\n   (short_vector_hybrid 2\n     (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl))\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have id': \"\\<parallel>?sv\\<parallel>\\<^sup>2 = \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>short_vector_hybrid 2\n                (factorization_lattice (inv_Mp (Mp u)) (n - degree u)\n                  pl)\\<parallel>\\<^sup>2 =\n    \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>short_vector_hybrid 2\n                (factorization_lattice (inv_Mp (Mp u)) (n - degree u)\n                  pl)\\<parallel>\\<^sup>2 =\n    \\<parallel>poly_of_vec\n                (short_vector_hybrid 2\n                  (factorization_lattice (inv_Mp (Mp u)) (n - degree u)\n                    pl))\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>short_vector_hybrid 2\n              (factorization_lattice (inv_Mp (Mp u)) (n - degree u)\n                pl)\\<parallel>\\<^sup>2 =\n  \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "interpret vec_module \"TYPE(int)\" n"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "interpret L: LLL n n \"?L\" 2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from deg_le deg_iu"], ["proof (chain)\npicking this:\n  degree u \\<le> n\n  degree (inv_Mp (Mp u)) = degree u", "have deg_iu_le: \"degree ?iu \\<le> n\""], ["proof (prove)\nusing this:\n  degree u \\<le> n\n  degree (inv_Mp (Mp u)) = degree u\n\ngoal (1 subgoal):\n 1. degree (inv_Mp (Mp u)) \\<le> n", "by simp"], ["proof (state)\nthis:\n  degree (inv_Mp (Mp u)) \\<le> n\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have len: \"length ?L = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) = n", "unfolding factorization_lattice_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i.\n              vec_of_poly_n (inv_Mp (Mp u) * monom 1 i)\n               (degree (inv_Mp (Mp u)) + (n - degree u)))\n       [n - degree u>..0] @\n      map (\\<lambda>i.\n              vec_of_poly_n (monom pl i)\n               (degree (inv_Mp (Mp u)) + (n - degree u)))\n       [degree (inv_Mp (Mp u))>..0]) =\n    n", "using deg_le deg_iu"], ["proof (prove)\nusing this:\n  degree u \\<le> n\n  degree (inv_Mp (Mp u)) = degree u\n\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i.\n              vec_of_poly_n (inv_Mp (Mp u) * monom 1 i)\n               (degree (inv_Mp (Mp u)) + (n - degree u)))\n       [n - degree u>..0] @\n      map (\\<lambda>i.\n              vec_of_poly_n (monom pl i)\n               (degree (inv_Mp (Mp u)) + (n - degree u)))\n       [degree (inv_Mp (Mp u))>..0]) =\n    n", "by auto"], ["proof (state)\nthis:\n  length (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) = n\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from deg_u_0 deg_iu"], ["proof (chain)\npicking this:\n  degree u \\<noteq> 0\n  degree (inv_Mp (Mp u)) = degree u", "have deg_iu0: \"degree ?iu \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree u \\<noteq> 0\n  degree (inv_Mp (Mp u)) = degree u\n\ngoal (1 subgoal):\n 1. degree (inv_Mp (Mp u)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree (inv_Mp (Mp u)) \\<noteq> 0\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "hence iu0: \"?iu \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (inv_Mp (Mp u)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  inv_Mp (Mp u) \\<noteq> 0\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from L.lin_indpt_list_factorization_lattice[OF refl deg_iu_le iu0 pl0]"], ["proof (chain)\npicking this:\n  L.gs.lin_indpt_list\n   (map of_int_vec\n     (factorization_lattice (inv_Mp (Mp u)) (n - degree (inv_Mp (Mp u)))\n       pl))", "have *: \"4/3 \\<le> (2 :: rat)\" \"L.gs.lin_indpt_list (L.RAT ?L)\""], ["proof (prove)\nusing this:\n  L.gs.lin_indpt_list\n   (map of_int_vec\n     (factorization_lattice (inv_Mp (Mp u)) (n - degree (inv_Mp (Mp u)))\n       pl))\n\ngoal (1 subgoal):\n 1. 4 / 3 \\<le> 2 &&&\n    L.gs.lin_indpt_list\n     (map of_int_vec\n       (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl))", "by (auto simp: deg_iu)"], ["proof (state)\nthis:\n  4 / 3 \\<le> 2\n  L.gs.lin_indpt_list\n   (map of_int_vec\n     (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl))\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "interpret L: LLL_with_assms n n ?L 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_with_assms n n\n     (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) 2", "by (unfold_locales, insert *, auto simp: deg_iu deg_le)"], ["proof (state)\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "note short = L.short_vector_hybrid[OF refl n, unfolded id' L.L_def]"], ["proof (state)\nthis:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> carrier_vec n\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}\n  ?h \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n           {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from short(2)"], ["proof (chain)\npicking this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}", "have mem: \"LLL_short_polynomial pl n u \\<in> poly_of_vec ` lattice_of ?L\""], ["proof (prove)\nusing this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. LLL_short_polynomial pl n u\n    \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)", "unfolding id"], ["proof (prove)\nusing this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (short_vector_hybrid 2\n       (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl))\n    \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)", "by auto"], ["proof (state)\nthis:\n  LLL_short_polynomial pl n u\n  \\<in> poly_of_vec `\n        lattice_of (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "note fact = L.factorization_lattice(1)[OF deg_iu0 pl0 deg_iu_le n, unfolded deg_iu, OF mem]"], ["proof (state)\nthis:\n  degree (LLL_short_polynomial pl n u) < n \\<and>\n  inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u\n\ngoal (4 subgoals):\n 1. degree (LLL_short_polynomial pl n u) < n\n 2. LLL_short_polynomial pl n u \\<noteq> 0\n 3. u dvdm LLL_short_polynomial pl n u\n 4. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "show \"degree (LLL_short_polynomial pl n u) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (LLL_short_polynomial pl n u) < n", "using fact"], ["proof (prove)\nusing this:\n  degree (LLL_short_polynomial pl n u) < n \\<and>\n  inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u\n\ngoal (1 subgoal):\n 1. degree (LLL_short_polynomial pl n u) < n", "by auto"], ["proof (state)\nthis:\n  degree (LLL_short_polynomial pl n u) < n\n\ngoal (3 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. u dvdm LLL_short_polynomial pl n u\n 3. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from fact"], ["proof (chain)\npicking this:\n  degree (LLL_short_polynomial pl n u) < n \\<and>\n  inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u", "have \"?iu dvdm (LLL_short_polynomial pl n u)\""], ["proof (prove)\nusing this:\n  degree (LLL_short_polynomial pl n u) < n \\<and>\n  inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u\n\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u", "by auto"], ["proof (state)\nthis:\n  inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u\n\ngoal (3 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. u dvdm LLL_short_polynomial pl n u\n 3. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u", "obtain h where \"LLL_short_polynomial pl n u =m ?iu * h\""], ["proof (prove)\nusing this:\n  inv_Mp (Mp u) dvdm LLL_short_polynomial pl n u\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        LLL_short_polynomial pl n u =m inv_Mp (Mp u) * h \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>h. LLL_short_polynomial pl n u =m inv_Mp (Mp u) * h\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        LLL_short_polynomial pl n u =m inv_Mp (Mp u) * h \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_short_polynomial pl n u =m inv_Mp (Mp u) * h\n\ngoal (3 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. u dvdm LLL_short_polynomial pl n u\n 3. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  LLL_short_polynomial pl n u =m inv_Mp (Mp u) * h\n\ngoal (3 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. u dvdm LLL_short_polynomial pl n u\n 3. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have \"?iu * h =m Mp ?iu * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) * h =m Mp (inv_Mp (Mp u)) * h", "unfolding mult_Mp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) * h =m inv_Mp (Mp u) * h", "by simp"], ["proof (state)\nthis:\n  inv_Mp (Mp u) * h =m Mp (inv_Mp (Mp u)) * h\n\ngoal (3 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. u dvdm LLL_short_polynomial pl n u\n 3. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  inv_Mp (Mp u) * h =m Mp (inv_Mp (Mp u)) * h\n\ngoal (3 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. u dvdm LLL_short_polynomial pl n u\n 3. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have \"Mp ?iu * h =m u * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (inv_Mp (Mp u)) * h =m u * h", "unfolding iu_u"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp u * h =m u * h", "unfolding mult_Mp"], ["proof (prove)\ngoal (1 subgoal):\n 1. u * h =m u * h", "by simp"], ["proof (state)\nthis:\n  Mp (inv_Mp (Mp u)) * h =m u * h\n\ngoal (3 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. u dvdm LLL_short_polynomial pl n u\n 3. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  LLL_short_polynomial pl n u =m u * h", "show \"u dvdm (LLL_short_polynomial pl n u)\""], ["proof (prove)\nusing this:\n  LLL_short_polynomial pl n u =m u * h\n\ngoal (1 subgoal):\n 1. u dvdm LLL_short_polynomial pl n u", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  LLL_short_polynomial pl n u =m u * h\n\ngoal (1 subgoal):\n 1. \\<exists>h. LLL_short_polynomial pl n u =m u * h", "by auto"], ["proof (state)\nthis:\n  u dvdm LLL_short_polynomial pl n u\n\ngoal (2 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from short"], ["proof (chain)\npicking this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> carrier_vec n\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}\n  ?h \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n           {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j", "have sv1: \"?sv \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> carrier_vec n\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}\n  ?h \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n           {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j\n\ngoal (1 subgoal):\n 1. short_vector_hybrid 2\n     (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n    \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from short"], ["proof (chain)\npicking this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> carrier_vec n\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}\n  ?h \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n           {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j", "have \"?sv \\<noteq> 0\\<^sub>v j\" for j"], ["proof (prove)\nusing this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> carrier_vec n\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  \\<in> lattice_of\n         (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n        {0\\<^sub>v n}\n  ?h \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n           {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j\n\ngoal (1 subgoal):\n 1. short_vector_hybrid 2\n     (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n    0\\<^sub>v j", "by auto"], ["proof (state)\nthis:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j1\n\ngoal (2 subgoals):\n 1. LLL_short_polynomial pl n u \\<noteq> 0\n 2. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "thus \"LLL_short_polynomial pl n u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j1\n\ngoal (1 subgoal):\n 1. LLL_short_polynomial pl n u \\<noteq> 0", "unfolding id"], ["proof (prove)\nusing this:\n  short_vector_hybrid 2\n   (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) \\<noteq>\n  0\\<^sub>v ?j1\n\ngoal (1 subgoal):\n 1. poly_of_vec\n     (short_vector_hybrid 2\n       (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  LLL_short_polynomial pl n u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "assume degu: \"degree u < n\" and dvd: \"u dvdm f\" \n    and degf: \"degree f < n\" and f0: \"f \\<noteq> 0\""], ["proof (state)\nthis:\n  degree u < n\n  u dvdm f\n  degree f < n\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from dvd"], ["proof (chain)\npicking this:\n  u dvdm f", "obtain h where \"f =m u * h\""], ["proof (prove)\nusing this:\n  u dvdm f\n\ngoal (1 subgoal):\n 1. (\\<And>h. f =m u * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>h. f =m u * h\n\ngoal (1 subgoal):\n 1. (\\<And>h. f =m u * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  f =m u * h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  f =m u * h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have \"u * h =m Mp u * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * h =m Mp u * h", "unfolding mult_Mp"], ["proof (prove)\ngoal (1 subgoal):\n 1. u * h =m u * h", "by simp"], ["proof (state)\nthis:\n  u * h =m Mp u * h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  u * h =m Mp u * h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have \"Mp u * h =m Mp ?iu * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp u * h =m Mp (inv_Mp (Mp u)) * h", "unfolding iu_u"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp u * h =m Mp u * h", "by simp"], ["proof (state)\nthis:\n  Mp u * h =m Mp (inv_Mp (Mp u)) * h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  Mp u * h =m Mp (inv_Mp (Mp u)) * h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have \"Mp ?iu * h =m ?iu * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (inv_Mp (Mp u)) * h =m inv_Mp (Mp u) * h", "unfolding mult_Mp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) * h =m inv_Mp (Mp u) * h", "by simp"], ["proof (state)\nthis:\n  Mp (inv_Mp (Mp u)) * h =m inv_Mp (Mp u) * h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  f =m inv_Mp (Mp u) * h", "have dvd: \"?iu dvdm f\""], ["proof (prove)\nusing this:\n  f =m inv_Mp (Mp u) * h\n\ngoal (1 subgoal):\n 1. inv_Mp (Mp u) dvdm f", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  f =m inv_Mp (Mp u) * h\n\ngoal (1 subgoal):\n 1. \\<exists>h. f =m inv_Mp (Mp u) * h", "by auto"], ["proof (state)\nthis:\n  inv_Mp (Mp u) dvdm f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from degu deg_iu"], ["proof (chain)\npicking this:\n  degree u < n\n  degree (inv_Mp (Mp u)) = degree u", "have deg_iun: \"degree ?iu < n\""], ["proof (prove)\nusing this:\n  degree u < n\n  degree (inv_Mp (Mp u)) = degree u\n\ngoal (1 subgoal):\n 1. degree (inv_Mp (Mp u)) < n", "by auto"], ["proof (state)\nthis:\n  degree (inv_Mp (Mp u)) < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from L.factorization_lattice(2)[OF deg_iu0 pl0 mon_iu deg_iun degf dvd]"], ["proof (chain)\npicking this:\n  f \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u))\n             (n - degree (inv_Mp (Mp u))) pl)", "have \"f \\<in> poly_of_vec ` lattice_of ?L\""], ["proof (prove)\nusing this:\n  f \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u))\n             (n - degree (inv_Mp (Mp u))) pl)\n\ngoal (1 subgoal):\n 1. f \\<in> poly_of_vec `\n            lattice_of\n             (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)", "using deg_iu"], ["proof (prove)\nusing this:\n  f \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u))\n             (n - degree (inv_Mp (Mp u))) pl)\n  degree (inv_Mp (Mp u)) = degree u\n\ngoal (1 subgoal):\n 1. f \\<in> poly_of_vec `\n            lattice_of\n             (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)", "by auto"], ["proof (state)\nthis:\n  f \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  f \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)", "obtain fv where f: \"f = poly_of_vec fv\" and fv: \"fv \\<in> lattice_of ?L\""], ["proof (prove)\nusing this:\n  f \\<in> poly_of_vec `\n          lattice_of\n           (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n\ngoal (1 subgoal):\n 1. (\\<And>fv.\n        \\<lbrakk>f = poly_of_vec fv;\n         fv \\<in> lattice_of\n                   (factorization_lattice (inv_Mp (Mp u)) (n - degree u)\n                     pl)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = poly_of_vec fv\n  fv \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have norm: \"\\<parallel>fv\\<parallel>\\<^sup>2 = \\<parallel>f\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fv\\<parallel>\\<^sup>2 = \\<parallel>f\\<parallel>\\<^sup>2", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fv\\<parallel>\\<^sup>2 =\n    \\<parallel>poly_of_vec fv\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>fv\\<parallel>\\<^sup>2 = \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "have fv0: \"fv \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv \\<noteq> 0\\<^sub>v n", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fv \\<noteq> 0\\<^sub>v n", "unfolding f"], ["proof (prove)\nusing this:\n  poly_of_vec fv \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fv \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  fv \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "with fv"], ["proof (chain)\npicking this:\n  fv \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  fv \\<noteq> 0\\<^sub>v n", "have fvL: \"fv \\<in> lattice_of ?L - {0\\<^sub>v n}\""], ["proof (prove)\nusing this:\n  fv \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl)\n  fv \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. fv \\<in> lattice_of\n              (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n             {0\\<^sub>v n}", "by auto"], ["proof (state)\nthis:\n  fv \\<in> lattice_of\n            (factorization_lattice (inv_Mp (Mp u)) (n - degree u) pl) -\n           {0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "from short(3)[OF this, unfolded norm]"], ["proof (chain)\npicking this:\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * rat_of_int \\<parallel>f\\<parallel>\\<^sup>2", "have \"rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2 \\<le> rat_of_int (2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2)\""], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * rat_of_int \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n    \\<le> rat_of_int (2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> rat_of_int (2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree u < n; f \\<noteq> 0; u dvdm f; degree f < n\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl n\n                                  u\\<parallel>\\<^sup>2\n                      \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "thus \"\\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2 \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2\""], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> rat_of_int (2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n    \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2", "by linarith"], ["proof (state)\nthis:\n  \\<parallel>LLL_short_polynomial pl n u\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (n - 1) * \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "context LLL_implementation\nbegin"], ["", "lemma LLL_reconstruction: assumes \"LLL_reconstruction f us = fs\"\n  and \"degree f \\<noteq> 0\"\n  and \"poly_mod.unique_factorization_m pl f (lead_coeff f, mset us)\"\n  and \"f dvd F\" \n  and \"\\<And> ui. ui \\<in> set us \\<Longrightarrow> poly_mod.Mp pl ui = ui\" \n  and F0: \"F \\<noteq> 0\" \n  and cop: \"coprime (lead_coeff F) p\" \n  and sf: \"poly_mod.square_free_m p F\" \n  and pl1: \"pl > 1\" \n  and plp: \"pl = p^l\" \n  and p: \"prime p\" \n  and large: \"2^(5 * (degree F - 1) * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2^(2 * (degree F - 1)) < pl\\<^sup>2\"\nshows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "interpret p: poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by (standard, rule p)"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "interpret pl: poly_mod_2 \"pl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 pl", "by (standard, rule pl1)"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from pl1 plp"], ["proof (chain)\npicking this:\n  1 < pl\n  pl = p ^ l", "have l0: \"l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < pl\n  pl = p ^ l\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "by (cases l, auto)"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "using assms(1-5)"], ["proof (prove)\nusing this:\n  LLL_reconstruction f us = fs\n  degree f \\<noteq> 0\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n  f dvd F\n  ?ui \\<in> set us \\<Longrightarrow> pl.Mp ?ui = ?ui\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "proof (induct f us arbitrary: fs rule: LLL_reconstruction.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "case (1 f us fs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 = degree f; ?xa1 = choose_u us;\n   ?xb1 = LLL_short_polynomial pl ?x1 ?xa1; ?xaa1 = gcd f ?xb1;\n   ?xab1 = degree ?xaa1; \\<not> (?xab1 = 0 \\<or> ?x1 \\<le> ?xab1);\n   ?xc1 = f div ?xaa1;\n   ?xd1 = List.partition (\\<lambda>gi. p.dvdm gi ?xc1) us;\n   (?xe1, ?y1) = ?xd1; LLL_reconstruction ?xc1 ?xe1 = ?fs1;\n   degree ?xc1 \\<noteq> 0;\n   pl.unique_factorization_m ?xc1 (lead_coeff ?xc1, mset ?xe1); ?xc1 dvd F;\n   \\<And>ui. ui \\<in> set ?xe1 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> ?xc1 = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n  \\<lbrakk>?x1 = degree f; ?xa1 = choose_u us;\n   ?xb1 = LLL_short_polynomial pl ?x1 ?xa1; ?xaa1 = gcd f ?xb1;\n   ?xab1 = degree ?xaa1; \\<not> (?xab1 = 0 \\<or> ?x1 \\<le> ?xab1);\n   ?xc1 = f div ?xaa1;\n   ?xd1 = List.partition (\\<lambda>gi. p.dvdm gi ?xc1) us;\n   (?xe1, ?y1) = ?xd1; LLL_reconstruction ?xaa1 ?y1 = ?fs1;\n   degree ?xaa1 \\<noteq> 0;\n   pl.unique_factorization_m ?xaa1 (lead_coeff ?xaa1, mset ?y1);\n   ?xaa1 dvd F;\n   \\<And>ui. ui \\<in> set ?y1 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> ?xaa1 = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n  LLL_reconstruction f us = fs\n  degree f \\<noteq> 0\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n  f dvd F\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "define u where \"u = choose_u us\""], ["proof (state)\nthis:\n  u = choose_u us\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "define g where \"g = LLL_short_polynomial pl (degree f) u\""], ["proof (state)\nthis:\n  g = LLL_short_polynomial pl (degree f) u\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "define k where \"k = gcd f g\""], ["proof (state)\nthis:\n  k = gcd f g\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note res = 1(3)"], ["proof (state)\nthis:\n  LLL_reconstruction f us = fs\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note degf = 1(4)"], ["proof (state)\nthis:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note uf = 1(5)"], ["proof (state)\nthis:\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note fF = 1(6)"], ["proof (state)\nthis:\n  f dvd F\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note norm = 1(7)"], ["proof (state)\nthis:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note to_fact = pl.unique_factorization_m_imp_factorization"], ["proof (state)\nthis:\n  pl.unique_factorization_m ?f ?cfs \\<Longrightarrow>\n  pl.factorization_m ?f ?cfs\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note fact = to_fact[OF uf]"], ["proof (state)\nthis:\n  pl.factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have mon_gs: \"ui \\<in> set us \\<Longrightarrow> monic ui\" for ui"], ["proof (prove)\ngoal (1 subgoal):\n 1. ui \\<in> set us \\<Longrightarrow> monic ui", "using norm fact"], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  pl.factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. ui \\<in> set us \\<Longrightarrow> monic ui", "unfolding pl.factorization_m_def"], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  case (lead_coeff f, mset us) of\n  (c, fs) \\<Rightarrow>\n    pl.eq_m f (smult c (\\<Prod>\\<^sub># fs)) \\<and>\n    (\\<forall>f\\<in>#fs. pl.irreducible\\<^sub>d_m f \\<and> monic (pl.Mp f))\n\ngoal (1 subgoal):\n 1. ui \\<in> set us \\<Longrightarrow> monic ui", "by auto"], ["proof (state)\nthis:\n  ?ui1 \\<in> set us \\<Longrightarrow> monic ?ui1\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from p.coprime_lead_coeff_factor[OF p.prime] fF cop"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?f) p\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?g) p\n  f dvd F\n  comm_monoid_mult_class.coprime (lead_coeff F) p", "have cop: \"coprime (lead_coeff f) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?f) p\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?g) p\n  f dvd F\n  comm_monoid_mult_class.coprime (lead_coeff F) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?f) p\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?g) p\n  \\<exists>k. F = f * k\n  comm_monoid_mult_class.coprime (lead_coeff F) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "by blast"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have plf0: \"pl.Mp f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.Mp f \\<noteq> 0", "using fact pl.factorization_m_lead_coeff pl.unique_factorization_m_zero uf"], ["proof (prove)\nusing this:\n  pl.factorization_m f (lead_coeff f, mset us)\n  pl.factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  lead_coeff (pl.Mp ?f) = pl.M ?c\n  pl.unique_factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  pl.M ?c \\<noteq> 0\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. pl.Mp f \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  pl.Mp f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"degree f = pl.degree_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = pl.degree_m f", "by (rule sym, rule poly_mod.degree_m_eq[OF _ pl.m1], \n          insert cop p, simp add: l0 p.coprime_exp_mod plp)"], ["proof (state)\nthis:\n  degree f = pl.degree_m f\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "also"], ["proof (state)\nthis:\n  degree f = pl.degree_m f\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"\\<dots> =  sum_mset (image_mset pl.degree_m (mset us))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.degree_m f = \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))", "unfolding pl.factorization_m_degree[OF fact plf0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n    \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))", ".."], ["proof (state)\nthis:\n  pl.degree_m f = \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "also"], ["proof (state)\nthis:\n  pl.degree_m f = \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"\\<dots> = sum_list (map pl.degree_m us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n    sum_list (map pl.degree_m us)", "unfolding sum_mset_sum_list[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n    \\<Sum>\\<^sub># (mset (map pl.degree_m us))", "by auto"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n  sum_list (map pl.degree_m us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n  sum_list (map pl.degree_m us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"\\<dots> = sum_list (map degree us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map pl.degree_m us) = sum_list (map degree us)", "by (rule arg_cong[OF map_cong, OF refl], rule pl.monic_degree_m, insert mon_gs, auto)"], ["proof (state)\nthis:\n  sum_list (map pl.degree_m us) = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "finally"], ["proof (chain)\npicking this:\n  degree f = sum_list (map degree us)", "have degf_gs: \"degree f = sum_list (map degree us)\""], ["proof (prove)\nusing this:\n  degree f = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. degree f = sum_list (map degree us)", "by auto"], ["proof (state)\nthis:\n  degree f = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "hence gs: \"us \\<noteq> []\""], ["proof (prove)\nusing this:\n  degree f = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. us \\<noteq> []", "using degf"], ["proof (prove)\nusing this:\n  degree f = sum_list (map degree us)\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. us \\<noteq> []", "by (cases us, auto)"], ["proof (state)\nthis:\n  us \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from choose_u_member[OF gs]"], ["proof (chain)\npicking this:\n  choose_u us \\<in> set us", "have u_gs: \"u \\<in> set us\""], ["proof (prove)\nusing this:\n  choose_u us \\<in> set us\n\ngoal (1 subgoal):\n 1. u \\<in> set us", "unfolding u_def"], ["proof (prove)\nusing this:\n  choose_u us \\<in> set us\n\ngoal (1 subgoal):\n 1. choose_u us \\<in> set us", "by auto"], ["proof (state)\nthis:\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from fact u_gs"], ["proof (chain)\npicking this:\n  pl.factorization_m f (lead_coeff f, mset us)\n  u \\<in> set us", "have irred: \"pl.irreducible\\<^sub>d_m u\""], ["proof (prove)\nusing this:\n  pl.factorization_m f (lead_coeff f, mset us)\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. pl.irreducible\\<^sub>d_m u", "unfolding pl.factorization_m_def"], ["proof (prove)\nusing this:\n  case (lead_coeff f, mset us) of\n  (c, fs) \\<Rightarrow>\n    pl.eq_m f (smult c (\\<Prod>\\<^sub># fs)) \\<and>\n    (\\<forall>f\\<in>#fs. pl.irreducible\\<^sub>d_m f \\<and> monic (pl.Mp f))\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. pl.irreducible\\<^sub>d_m u", "by auto"], ["proof (state)\nthis:\n  pl.irreducible\\<^sub>d_m u\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "hence deg_u: \"degree u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pl.irreducible\\<^sub>d_m u\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0", "unfolding pl.irreducible\\<^sub>d_m_def norm[OF u_gs]"], ["proof (prove)\nusing this:\n  0 < degree u \\<and>\n  (\\<forall>g h.\n      pl.degree_m g < degree u \\<longrightarrow>\n      pl.degree_m h < degree u \\<longrightarrow> u \\<noteq> pl.Mp (g * h))\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have deg_uf: \"degree u \\<le> degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> degree f", "unfolding degf_gs"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> sum_list (map degree us)", "using split_list[OF u_gs]"], ["proof (prove)\nusing this:\n  \\<exists>ys zs. us = ys @ u # zs\n\ngoal (1 subgoal):\n 1. degree u \\<le> sum_list (map degree us)", "by auto"], ["proof (state)\nthis:\n  degree u \\<le> degree f\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from mon_gs[OF u_gs]"], ["proof (chain)\npicking this:\n  monic u", "have mon_u: \"monic u\" and u0: \"u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. monic u &&& u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monic u\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have f0: \"f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "using degf"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from norm"], ["proof (chain)\npicking this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1", "have norm': \"image_mset pl.Mp (mset us) = mset us\""], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. image_mset pl.Mp (mset us) = mset us", "by (induct us, auto)"], ["proof (state)\nthis:\n  image_mset pl.Mp (mset us) = mset us\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have pl0: \"pl \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl \\<noteq> 0", "using pl1"], ["proof (prove)\nusing this:\n  1 < pl\n\ngoal (1 subgoal):\n 1. pl \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note short_main = LLL_short_polynomial[OF deg_u deg_uf pl1 mon_u]"], ["proof (state)\nthis:\n  degree (LLL_short_polynomial pl (degree f) u) < degree f\n  LLL_short_polynomial pl (degree f) u \\<noteq> 0\n  pl.dvdm u (LLL_short_polynomial pl (degree f) u)\n  \\<lbrakk>degree u < degree f; ?f \\<noteq> 0; pl.dvdm u ?f;\n   degree ?f < degree f\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>LLL_short_polynomial pl (degree f)\n                                u\\<parallel>\\<^sup>2\n                    \\<le> 2 ^ (degree f - 1) *\n                          \\<parallel>?f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from short_main(1-2)[folded g_def]"], ["proof (chain)\npicking this:\n  degree g < degree f\n  g \\<noteq> 0", "have \"degree k < degree f\""], ["proof (prove)\nusing this:\n  degree g < degree f\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree k < degree f", "unfolding k_def"], ["proof (prove)\nusing this:\n  degree g < degree f\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd f g) < degree f", "by (smt Suc_leI Suc_less_eq degree_gcd1 gcd.commute le_imp_less_Suc le_trans)"], ["proof (state)\nthis:\n  degree k < degree f\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "hence deg_fk: \"(degree k = 0 \\<or> degree f \\<le> degree k) = (degree k = 0)\""], ["proof (prove)\nusing this:\n  degree k < degree f\n\ngoal (1 subgoal):\n 1. (degree k = 0 \\<or> degree f \\<le> degree k) = (degree k = 0)", "by auto"], ["proof (state)\nthis:\n  (degree k = 0 \\<or> degree f \\<le> degree k) = (degree k = 0)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note res = res[unfolded LLL_reconstruction.simps[of f us] Let_def, folded u_def, \n        folded g_def, folded k_def, unfolded deg_fk]"], ["proof (state)\nthis:\n  (if degree k = 0 then [f]\n   else case List.partition (\\<lambda>gi. p.dvdm gi (f div k)) us of\n        (us1, us2) \\<Rightarrow>\n          LLL_reconstruction (f div k) us1 @ LLL_reconstruction k us2) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb xaa xab xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = choose_u us;\n                    xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n                    xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n                    xc = f div xaa;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb xaa xab xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = choose_u us;\n            xb = LLL_short_polynomial pl x xa; xaa = gcd f xb;\n            xab = degree xaa; \\<not> (xab = 0 \\<or> x \\<le> xab);\n            xc = f div xaa;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_reconstruction xaa y = fs;\n            degree xaa \\<noteq> 0;\n            pl.unique_factorization_m xaa (lead_coeff xaa, mset y);\n            xaa dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> xaa = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (cases \"degree k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree k = 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case True"], ["proof (state)\nthis:\n  degree k = 0\n\ngoal (2 subgoals):\n 1. degree k = 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with res"], ["proof (chain)\npicking this:\n  (if degree k = 0 then [f]\n   else case List.partition (\\<lambda>gi. p.dvdm gi (f div k)) us of\n        (us1, us2) \\<Rightarrow>\n          LLL_reconstruction (f div k) us1 @ LLL_reconstruction k us2) =\n  fs\n  degree k = 0", "have fs: \"fs = [f]\""], ["proof (prove)\nusing this:\n  (if degree k = 0 then [f]\n   else case List.partition (\\<lambda>gi. p.dvdm gi (f div k)) us of\n        (us1, us2) \\<Rightarrow>\n          LLL_reconstruction (f div k) us1 @ LLL_reconstruction k us2) =\n  fs\n  degree k = 0\n\ngoal (1 subgoal):\n 1. fs = [f]", "by auto"], ["proof (state)\nthis:\n  fs = [f]\n\ngoal (2 subgoals):\n 1. degree k = 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from sf fF"], ["proof (chain)\npicking this:\n  p.square_free_m F\n  f dvd F", "have sf: \"p.square_free_m f\""], ["proof (prove)\nusing this:\n  p.square_free_m F\n  f dvd F\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "using p.square_free_m_factor(1)[of f]"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  f dvd F\n  p.square_free_m (f * ?g) \\<Longrightarrow> p.square_free_m f\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  \\<exists>k. F = f * k\n  p.square_free_m (f * ?g) \\<Longrightarrow> p.square_free_m f\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "by auto"], ["proof (state)\nthis:\n  p.square_free_m f\n\ngoal (2 subgoals):\n 1. degree k = 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have irr: \"irreducible\\<^sub>d f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "assume \"\\<not> irreducible\\<^sub>d f\""], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from reducible\\<^sub>dE[OF this] degf"], ["proof (chain)\npicking this:\n  \\<lbrakk>degree f = 0 \\<Longrightarrow> ?thesis;\n   \\<And>q r.\n      \\<lbrakk>0 < degree q; degree q < degree f; 0 < degree r;\n       degree r < degree f; f = q * r\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  degree f \\<noteq> 0", "obtain f1 f2 where \n          f: \"f = f1 * f2\" and\n          deg12: \"degree f1 \\<noteq> 0\" \"degree f2 \\<noteq> 0\" \"degree f1 < degree f\" \"degree f2 < degree f\""], ["proof (prove)\nusing this:\n  \\<lbrakk>degree f = 0 \\<Longrightarrow> ?thesis;\n   \\<And>q r.\n      \\<lbrakk>0 < degree q; degree q < degree f; 0 < degree r;\n       degree r < degree f; f = q * r\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0; degree f2 \\<noteq> 0;\n         degree f1 < degree f; degree f2 < degree f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp, metis)"], ["proof (state)\nthis:\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from pl.unique_factorization_m_factor[OF p uf[unfolded f], folded f, OF cop sf l0 plp]"], ["proof (chain)\npicking this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     pl.Mf (lead_coeff f, mset us) =\n     pl.Mf (lead_coeff f1 * lead_coeff f2, fs + gs) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs", "obtain us1 us2 where \n          uf12: \"pl.unique_factorization_m f1 (lead_coeff f1, us1)\"\n            \"pl.unique_factorization_m f2 (lead_coeff f2, us2)\"\n          and gs: \"mset us = us1 + us2\"\n          and norm12: \"image_mset pl.Mp us2 = us2\" \"image_mset pl.Mp us1 = us1\""], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     pl.Mf (lead_coeff f, mset us) =\n     pl.Mf (lead_coeff f1 * lead_coeff f2, fs + gs) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>us1 us2.\n        \\<lbrakk>pl.unique_factorization_m f1 (lead_coeff f1, us1);\n         pl.unique_factorization_m f2 (lead_coeff f2, us2);\n         mset us = us1 + us2; image_mset pl.Mp us2 = us2;\n         image_mset pl.Mp us1 = us1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding pl.Mf_def norm' split"], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     (pl.M (lead_coeff f), mset us) =\n     (pl.M (lead_coeff f1 * lead_coeff f2),\n      image_mset pl.Mp (fs + gs)) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>us1 us2.\n        \\<lbrakk>pl.unique_factorization_m f1 (lead_coeff f1, us1);\n         pl.unique_factorization_m f2 (lead_coeff f2, us2);\n         mset us = us1 + us2; image_mset pl.Mp us2 = us2;\n         image_mset pl.Mp us1 = us1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: pl.Mf_def)"], ["proof (state)\nthis:\n  pl.unique_factorization_m f1 (lead_coeff f1, us1)\n  pl.unique_factorization_m f2 (lead_coeff f2, us2)\n  mset us = us1 + us2\n  image_mset pl.Mp us2 = us2\n  image_mset pl.Mp us1 = us1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "note norm_u = norm[OF u_gs]"], ["proof (state)\nthis:\n  pl.Mp u = u\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from u_gs"], ["proof (chain)\npicking this:\n  u \\<in> set us", "have u_gs': \"u \\<in># mset us\""], ["proof (prove)\nusing this:\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. u \\<in># mset us", "by auto"], ["proof (state)\nthis:\n  u \\<in># mset us\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with pl.factorization_m_mem_dvdm[OF fact, of u]"], ["proof (chain)\npicking this:\n  pl.Mp u \\<in># image_mset pl.Mp (mset us) \\<Longrightarrow> pl.dvdm u f\n  u \\<in># mset us", "have u_f: \"pl.dvdm u f\""], ["proof (prove)\nusing this:\n  pl.Mp u \\<in># image_mset pl.Mp (mset us) \\<Longrightarrow> pl.dvdm u f\n  u \\<in># mset us\n\ngoal (1 subgoal):\n 1. pl.dvdm u f", "by auto"], ["proof (state)\nthis:\n  pl.dvdm u f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from u_gs'[unfolded gs]"], ["proof (chain)\npicking this:\n  u \\<in># us1 + us2", "have \"u \\<in># us1 \\<or> u \\<in># us2\""], ["proof (prove)\nusing this:\n  u \\<in># us1 + us2\n\ngoal (1 subgoal):\n 1. u \\<in># us1 \\<or> u \\<in># us2", "by auto"], ["proof (state)\nthis:\n  u \\<in># us1 \\<or> u \\<in># us2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with pl.factorization_m_mem_dvdm[OF to_fact[OF uf12(1)], of u] \n             pl.factorization_m_mem_dvdm[OF to_fact[OF uf12(2)], of u]"], ["proof (chain)\npicking this:\n  pl.Mp u \\<in># image_mset pl.Mp us1 \\<Longrightarrow> pl.dvdm u f1\n  pl.Mp u \\<in># image_mset pl.Mp us2 \\<Longrightarrow> pl.dvdm u f2\n  u \\<in># us1 \\<or> u \\<in># us2", "have \"pl.dvdm u f1 \\<or> pl.dvdm u f2\""], ["proof (prove)\nusing this:\n  pl.Mp u \\<in># image_mset pl.Mp us1 \\<Longrightarrow> pl.dvdm u f1\n  pl.Mp u \\<in># image_mset pl.Mp us2 \\<Longrightarrow> pl.dvdm u f2\n  u \\<in># us1 \\<or> u \\<in># us2\n\ngoal (1 subgoal):\n 1. pl.dvdm u f1 \\<or> pl.dvdm u f2", "unfolding norm12 norm_u"], ["proof (prove)\nusing this:\n  u \\<in># us1 \\<Longrightarrow> pl.dvdm u f1\n  u \\<in># us2 \\<Longrightarrow> pl.dvdm u f2\n  u \\<in># us1 \\<or> u \\<in># us2\n\ngoal (1 subgoal):\n 1. pl.dvdm u f1 \\<or> pl.dvdm u f2", "by auto"], ["proof (state)\nthis:\n  pl.dvdm u f1 \\<or> pl.dvdm u f2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  pl.dvdm u f1 \\<or> pl.dvdm u f2", "have \"\\<exists> f1 f2. f = f1 * f2 \\<and> \n          degree f1 \\<noteq> 0 \\<and> degree f2 \\<noteq> 0 \\<and> degree f1 < degree f \\<and> degree f2 < degree f \\<and> \n          pl.dvdm u f1\""], ["proof (prove)\nusing this:\n  pl.dvdm u f1 \\<or> pl.dvdm u f2\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pl.dvdm u f1 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1\n 2. pl.dvdm u f2 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "assume \"pl.dvdm u f1\""], ["proof (state)\nthis:\n  pl.dvdm u f1\n\ngoal (2 subgoals):\n 1. pl.dvdm u f1 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1\n 2. pl.dvdm u f2 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "thus ?thesis"], ["proof (prove)\nusing this:\n  pl.dvdm u f1\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "using f deg12"], ["proof (prove)\nusing this:\n  pl.dvdm u f1\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "by auto"], ["proof (state)\nthis:\n  \\<exists>f1 f2.\n     f = f1 * f2 \\<and>\n     degree f1 \\<noteq> 0 \\<and>\n     degree f2 \\<noteq> 0 \\<and>\n     degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1\n\ngoal (1 subgoal):\n 1. pl.dvdm u f2 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pl.dvdm u f2 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "from f"], ["proof (chain)\npicking this:\n  f = f1 * f2", "have f: \"f = f2 * f1\""], ["proof (prove)\nusing this:\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. f = f2 * f1", "by auto"], ["proof (state)\nthis:\n  f = f2 * f1\n\ngoal (1 subgoal):\n 1. pl.dvdm u f2 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "assume \"pl.dvdm u f2\""], ["proof (state)\nthis:\n  pl.dvdm u f2\n\ngoal (1 subgoal):\n 1. pl.dvdm u f2 \\<Longrightarrow>\n    \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "thus ?thesis"], ["proof (prove)\nusing this:\n  pl.dvdm u f2\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "using f deg12"], ["proof (prove)\nusing this:\n  pl.dvdm u f2\n  f = f2 * f1\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       f = f1 * f2 \\<and>\n       degree f1 \\<noteq> 0 \\<and>\n       degree f2 \\<noteq> 0 \\<and>\n       degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "by auto"], ["proof (state)\nthis:\n  \\<exists>f1 f2.\n     f = f1 * f2 \\<and>\n     degree f1 \\<noteq> 0 \\<and>\n     degree f2 \\<noteq> 0 \\<and>\n     degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f1 f2.\n     f = f1 * f2 \\<and>\n     degree f1 \\<noteq> 0 \\<and>\n     degree f2 \\<noteq> 0 \\<and>\n     degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>f1 f2.\n     f = f1 * f2 \\<and>\n     degree f1 \\<noteq> 0 \\<and>\n     degree f2 \\<noteq> 0 \\<and>\n     degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1", "obtain f1 f2 where prod: \"f = f1 * f2\" \n          and deg: \"degree f1 \\<noteq> 0\" \"degree f2 \\<noteq> 0\" \"degree f1 < degree f\" \"degree f2 < degree f\" \n          and uf1: \"pl.dvdm u f1\""], ["proof (prove)\nusing this:\n  \\<exists>f1 f2.\n     f = f1 * f2 \\<and>\n     degree f1 \\<noteq> 0 \\<and>\n     degree f2 \\<noteq> 0 \\<and>\n     degree f1 < degree f \\<and> degree f2 < degree f \\<and> pl.dvdm u f1\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0; degree f2 \\<noteq> 0;\n         degree f1 < degree f; degree f2 < degree f; pl.dvdm u f1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n  pl.dvdm u f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from pl.unique_factorization_m_factor[OF p uf[unfolded prod], folded prod, OF cop sf l0 plp]"], ["proof (chain)\npicking this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     pl.Mf (lead_coeff f, mset us) =\n     pl.Mf (lead_coeff f1 * lead_coeff f2, fs + gs) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs", "obtain us1 where fact_f1: \"pl.unique_factorization_m f1 (lead_coeff f1, us1)\""], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     pl.Mf (lead_coeff f, mset us) =\n     pl.Mf (lead_coeff f1 * lead_coeff f2, fs + gs) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>us1.\n        pl.unique_factorization_m f1 (lead_coeff f1, us1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pl.unique_factorization_m f1 (lead_coeff f1, us1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have plf1: \"pl.Mp f1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.Mp f1 \\<noteq> 0", "using to_fact[OF fact_f1] pl.factorization_m_lead_coeff \n            pl.unique_factorization_m_zero fact_f1"], ["proof (prove)\nusing this:\n  pl.factorization_m f1 (lead_coeff f1, us1)\n  pl.factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  lead_coeff (pl.Mp ?f) = pl.M ?c\n  pl.unique_factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  pl.M ?c \\<noteq> 0\n  pl.unique_factorization_m f1 (lead_coeff f1, us1)\n\ngoal (1 subgoal):\n 1. pl.Mp f1 \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  pl.Mp f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"degree u \\<le> degree f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> degree f1", "by (rule pl.dvdm_degree[OF mon_u uf1 plf1])"], ["proof (state)\nthis:\n  degree u \\<le> degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with deg"], ["proof (chain)\npicking this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n  degree u \\<le> degree f1", "have deg_uf: \"degree u < degree f\""], ["proof (prove)\nusing this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n  degree u \\<le> degree f1\n\ngoal (1 subgoal):\n 1. degree u < degree f", "by auto"], ["proof (state)\nthis:\n  degree u < degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have pl0: \"pl \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl \\<noteq> 0", "using pl.m1 plp"], ["proof (prove)\nusing this:\n  1 < pl\n  pl = p ^ l\n\ngoal (1 subgoal):\n 1. pl \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  pl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "let ?n = \"degree f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "let ?n1 = \"degree f1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "let ?d = \"degree u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from prod fF"], ["proof (chain)\npicking this:\n  f = f1 * f2\n  f dvd F", "have f1F: \"f1 dvd F\""], ["proof (prove)\nusing this:\n  f = f1 * f2\n  f dvd F\n\ngoal (1 subgoal):\n 1. f1 dvd F", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  f = f1 * f2\n  \\<exists>k. F = f * k\n\ngoal (1 subgoal):\n 1. \\<exists>k. F = f1 * k", "by auto"], ["proof (state)\nthis:\n  f1 dvd F\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from deg_uf"], ["proof (chain)\npicking this:\n  degree u < degree f", "have deg_uf': \"?d \\<le> ?n\""], ["proof (prove)\nusing this:\n  degree u < degree f\n\ngoal (1 subgoal):\n 1. degree u \\<le> degree f", "by auto"], ["proof (state)\nthis:\n  degree u \\<le> degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from deg"], ["proof (chain)\npicking this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f", "have f1_0: \"f1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. f1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have ug: \"pl.dvdm u g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.dvdm u g", "using short_main(3)"], ["proof (prove)\nusing this:\n  pl.dvdm u (LLL_short_polynomial pl (degree f) u)\n\ngoal (1 subgoal):\n 1. pl.dvdm u g", "unfolding g_def"], ["proof (prove)\nusing this:\n  pl.dvdm u (LLL_short_polynomial pl (degree f) u)\n\ngoal (1 subgoal):\n 1. pl.dvdm u (LLL_short_polynomial pl (degree f) u)", "."], ["proof (state)\nthis:\n  pl.dvdm u g\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have g0: \"g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "using short_main(2)"], ["proof (prove)\nusing this:\n  LLL_short_polynomial pl (degree f) u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  LLL_short_polynomial pl (degree f) u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LLL_short_polynomial pl (degree f) u \\<noteq> 0", "."], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have deg_gf: \"degree g < degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g < degree f", "using short_main(1)"], ["proof (prove)\nusing this:\n  degree (LLL_short_polynomial pl (degree f) u) < degree f\n\ngoal (1 subgoal):\n 1. degree g < degree f", "unfolding g_def"], ["proof (prove)\nusing this:\n  degree (LLL_short_polynomial pl (degree f) u) < degree f\n\ngoal (1 subgoal):\n 1. degree (LLL_short_polynomial pl (degree f) u) < degree f", "."], ["proof (state)\nthis:\n  degree g < degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "let ?N = \"degree F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from fF prod"], ["proof (chain)\npicking this:\n  f dvd F\n  f = f1 * f2", "have f1F: \"f1 dvd F\""], ["proof (prove)\nusing this:\n  f dvd F\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. f1 dvd F", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. F = f * k\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. \\<exists>k. F = f1 * k", "by auto"], ["proof (state)\nthis:\n  f1 dvd F\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<parallel>g\\<parallel>\\<^sup>2 \\<le> 2 ^ (?n - 1) * \\<parallel>f1\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>g\\<parallel>\\<^sup>2\n    \\<le> 2 ^ (degree f - 1) * \\<parallel>f1\\<parallel>\\<^sup>2", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>LLL_short_polynomial pl (degree f) u\\<parallel>\\<^sup>2\n    \\<le> 2 ^ (degree f - 1) * \\<parallel>f1\\<parallel>\\<^sup>2", "by (rule short_main(4)[OF deg_uf _ uf1], insert deg, auto)"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (degree f - 1) * \\<parallel>f1\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (degree f - 1) * \\<parallel>f1\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> \\<le> 2 ^ (?n - 1) * (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (degree f - 1) * \\<parallel>f1\\<parallel>\\<^sup>2\n    \\<le> 2 ^ (degree f - 1) *\n          (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2)", "by (rule mult_left_mono[OF sq_norm_factor_bound[OF f1F F0]], simp)"], ["proof (state)\nthis:\n  2 ^ (degree f - 1) * \\<parallel>f1\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (degree f - 1) *\n        (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ (degree f - 1) * \\<parallel>f1\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (degree f - 1) *\n        (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = 2 ^ ((?n - 1) + 2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (degree f - 1) *\n    (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) =\n    2 ^ (degree f - 1 + 2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2", "unfolding power_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (degree f - 1) *\n    (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) =\n    2 ^ (degree f - 1) * 2 ^ (2 * degree f1) *\n    \\<parallel>F\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  2 ^ (degree f - 1) *\n  (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) =\n  2 ^ (degree f - 1 + 2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ (degree f - 1) *\n  (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) =\n  2 ^ (degree f - 1 + 2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> \\<le> 2 ^ ((?n - 1) + 2 * (?n - 1)) * \\<parallel>F\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (degree f - 1 + 2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2\n    \\<le> 2 ^ (degree f - 1 + 2 * (degree f - 1)) *\n          \\<parallel>F\\<parallel>\\<^sup>2", "by (rule mult_right_mono, insert deg(3), auto)"], ["proof (state)\nthis:\n  2 ^ (degree f - 1 + 2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (degree f - 1 + 2 * (degree f - 1)) *\n        \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ (degree f - 1 + 2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (degree f - 1 + 2 * (degree f - 1)) *\n        \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = 2 ^ (3 * (?n - 1)) * \\<parallel>F\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (degree f - 1 + 2 * (degree f - 1)) *\n    \\<parallel>F\\<parallel>\\<^sup>2 =\n    2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  2 ^ (degree f - 1 + 2 * (degree f - 1)) *\n  \\<parallel>F\\<parallel>\\<^sup>2 =\n  2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>g\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2", "have ineq_g: \"\\<parallel>g\\<parallel>\\<^sup>2 \\<le> 2 ^ (3 * (?n - 1)) * \\<parallel>F\\<parallel>\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<parallel>g\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>g\\<parallel>\\<^sup>2\n    \\<le> 2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2", "."], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2\n  \\<le> 2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from power_mono[OF this, of ?n1]"], ["proof (chain)\npicking this:\n  0 \\<le> \\<parallel>g\\<parallel>\\<^sup>2 \\<Longrightarrow>\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        degree f1", "have ineq1: \"\\<parallel>g\\<parallel>\\<^sup>2 ^ ?n1 \\<le> (2 ^ (3 * (?n - 1)) * \\<parallel>F\\<parallel>\\<^sup>2)^?n1\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<parallel>g\\<parallel>\\<^sup>2 \\<Longrightarrow>\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        degree f1\n\ngoal (1 subgoal):\n 1. \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n    \\<le> (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          degree f1", "by auto"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from F0"], ["proof (chain)\npicking this:\n  F \\<noteq> 0", "have normF: \"\\<parallel>F\\<parallel>\\<^sup>2 \\<ge> 1\""], ["proof (prove)\nusing this:\n  F \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>F\\<parallel>\\<^sup>2", "using sq_norm_poly_pos[of F]"], ["proof (prove)\nusing this:\n  F \\<noteq> 0\n  (0 < \\<parallel>F\\<parallel>\\<^sup>2) = (F \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>F\\<parallel>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from g0"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have normg: \"\\<parallel>g\\<parallel>\\<^sup>2 \\<ge> 1\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>g\\<parallel>\\<^sup>2", "using sq_norm_poly_pos[of g]"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  (0 < \\<parallel>g\\<parallel>\\<^sup>2) = (g \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>g\\<parallel>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>g\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from f0"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have normf: \"\\<parallel>f\\<parallel>\\<^sup>2 \\<ge> 1\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "using sq_norm_poly_pos[of f]"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  (0 < \\<parallel>f\\<parallel>\\<^sup>2) = (f \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from f1_0"], ["proof (chain)\npicking this:\n  f1 \\<noteq> 0", "have normf1: \"\\<parallel>f1\\<parallel>\\<^sup>2 \\<ge> 1\""], ["proof (prove)\nusing this:\n  f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2", "using sq_norm_poly_pos[of f1]"], ["proof (prove)\nusing this:\n  f1 \\<noteq> 0\n  (0 < \\<parallel>f1\\<parallel>\\<^sup>2) = (f1 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from power_mono[OF sq_norm_factor_bound[OF f1F F0], of \"degree g\"]"], ["proof (chain)\npicking this:\n  0 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 \\<Longrightarrow>\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g", "have ineq2: \"\\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g \\<le> (2 ^ (2 * ?n1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 \\<Longrightarrow>\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g\n\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n    \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g", "by auto"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> \\<le> (2 ^ (2 * ?n1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (?n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g\n    \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          (degree f - 1)", "by (rule pow_mono_exp, insert deg_gf normF, auto)"], ["proof (state)\nthis:\n  (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree f - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree f - 1)", "have ineq2: \"\\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g \\<le> (2 ^ (2 * ?n1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (?n - 1)\""], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree f - 1)\n\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n    \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          (degree f - 1)", "."], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree f - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have nN: \"?n \\<le> ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f \\<le> degree F", "using fF F0"], ["proof (prove)\nusing this:\n  f dvd F\n  F \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree F", "by (metis dvd_imp_degree_le)"], ["proof (state)\nthis:\n  degree f \\<le> degree F\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from deg nN"], ["proof (chain)\npicking this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n  degree f \\<le> degree F", "have n1N: \"?n1 \\<le> ?N - 1\""], ["proof (prove)\nusing this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n  degree f \\<le> degree F\n\ngoal (1 subgoal):\n 1. degree f1 \\<le> degree F - 1", "by auto"], ["proof (state)\nthis:\n  degree f1 \\<le> degree F - 1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g * \\<parallel>g\\<parallel>\\<^sup>2 ^ ?n1 \\<le> \n          (2 ^ (2 * ?n1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (?n - 1) * (2 ^ (3 * (?n - 1)) * \\<parallel>F\\<parallel>\\<^sup>2)^?n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n    \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          (degree f - 1) *\n          (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          degree f1", "by (rule mult_mono[OF ineq2 ineq1], force+)"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree f - 1) *\n        (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree f - 1) *\n        (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> \\<le> (2 ^ (2 * (?N - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (?N - 1) *\n          (2 ^ (3 * (?N - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (?N - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n    (degree f - 1) *\n    (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree f1\n    \\<le> (2 ^ (2 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          (degree F - 1) *\n          (2 ^ (3 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          (degree F - 1)", "by (rule mult_mono[OF power_both_mono[OF _ _ mult_mono] \n          power_both_mono], insert normF n1N nN, auto intro: power_both_mono mult_mono)"], ["proof (state)\nthis:\n  (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (degree f - 1) *\n  (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree f1\n  \\<le> (2 ^ (2 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree F - 1) *\n        (2 ^ (3 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree F - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (2 ^ (2 * degree f1) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (degree f - 1) *\n  (2 ^ (3 * (degree f - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^ degree f1\n  \\<le> (2 ^ (2 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree F - 1) *\n        (2 ^ (3 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree F - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = 2 ^ (2 * (?N -1) * (?N - 1) + 3 * (?N - 1) * (?N - 1)) \n            * (\\<parallel>F\\<parallel>\\<^sup>2)^((?N - 1) + (?N - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ (2 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n    (degree F - 1) *\n    (2 ^ (3 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n    (degree F - 1) =\n    2 ^\n    (2 * (degree F - 1) * (degree F - 1) +\n     3 * (degree F - 1) * (degree F - 1)) *\n    \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F - 1 + (degree F - 1))", "unfolding power_mult_distrib power_add power_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2\\<^sup>2 ^ (degree F - 1)) ^ (degree F - 1) *\n    \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F - 1) *\n    (((2 ^ 3) ^ (degree F - 1)) ^ (degree F - 1) *\n     \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F - 1)) =\n    (2\\<^sup>2 ^ (degree F - 1)) ^ (degree F - 1) *\n    ((2 ^ 3) ^ (degree F - 1)) ^ (degree F - 1) *\n    (\\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F - 1) *\n     \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F - 1))", "by simp"], ["proof (state)\nthis:\n  (2 ^ (2 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n  (degree F - 1) *\n  (2 ^ (3 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n  (degree F - 1) =\n  2 ^\n  (2 * (degree F - 1) * (degree F - 1) +\n   3 * (degree F - 1) * (degree F - 1)) *\n  \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F - 1 + (degree F - 1))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (2 ^ (2 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n  (degree F - 1) *\n  (2 ^ (3 * (degree F - 1)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n  (degree F - 1) =\n  2 ^\n  (2 * (degree F - 1) * (degree F - 1) +\n   3 * (degree F - 1) * (degree F - 1)) *\n  \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F - 1 + (degree F - 1))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"2 * (?N - 1) * (?N - 1) + 3 * (?N - 1) * (?N - 1) = 5 * (?N - 1) * (?N - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (degree F - 1) * (degree F - 1) +\n    3 * (degree F - 1) * (degree F - 1) =\n    5 * (degree F - 1) * (degree F - 1)", "by simp"], ["proof (state)\nthis:\n  2 * (degree F - 1) * (degree F - 1) +\n  3 * (degree F - 1) * (degree F - 1) =\n  5 * (degree F - 1) * (degree F - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 * (degree F - 1) * (degree F - 1) +\n  3 * (degree F - 1) * (degree F - 1) =\n  5 * (degree F - 1) * (degree F - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"?N - 1 + (?N - 1) = 2 * (?N - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree F - 1 + (degree F - 1) = 2 * (degree F - 1)", "by simp"], ["proof (state)\nthis:\n  degree F - 1 + (degree F - 1) = 2 * (degree F - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree F - 1 + (degree F - 1) = 2 * (degree F - 1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"2^(5 * (?N - 1) * (?N - 1)) * \\<parallel>F\\<parallel>\\<^sup>2^(2 * (?N - 1)) < pl^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (5 * (degree F - 1) * (degree F - 1)) *\n    \\<parallel>F\\<parallel>\\<^sup>2 ^ (2 * (degree F - 1))\n    < pl\\<^sup>2", "by (rule large)"], ["proof (state)\nthis:\n  2 ^ (5 * (degree F - 1) * (degree F - 1)) *\n  \\<parallel>F\\<parallel>\\<^sup>2 ^ (2 * (degree F - 1))\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2", "have large: \"\\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1 < pl\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n    < pl\\<^sup>2", "."], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have deg_ug: \"degree u \\<le> degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> degree g", "proof (rule pl.dvdm_degree[OF mon_u ug], standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "assume \"pl.Mp g = 0\""], ["proof (state)\nthis:\n  pl.Mp g = 0\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "from arg_cong[OF this, of \"\\<lambda> p. coeff p (degree g)\"]"], ["proof (chain)\npicking this:\n  coeff (pl.Mp g) (degree g) = coeff 0 (degree g)", "have \"pl.M (coeff g (degree g)) = 0\""], ["proof (prove)\nusing this:\n  coeff (pl.Mp g) (degree g) = coeff 0 (degree g)\n\ngoal (1 subgoal):\n 1. pl.M (lead_coeff g) = 0", "by (auto simp: pl.Mp_def coeff_map_poly)"], ["proof (state)\nthis:\n  pl.M (lead_coeff g) = 0\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "from this[unfolded pl.M_def]"], ["proof (chain)\npicking this:\n  lead_coeff g mod pl = 0", "obtain c where lg: \"lead_coeff g = pl * c\""], ["proof (prove)\nusing this:\n  lead_coeff g mod pl = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        lead_coeff g = pl * c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lead_coeff g = pl * c\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "with g0"], ["proof (chain)\npicking this:\n  g \\<noteq> 0\n  lead_coeff g = pl * c", "have c0: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  lead_coeff g = pl * c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "hence \"pl^2 \\<le> (lead_coeff g)^2\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pl\\<^sup>2 \\<le> (lead_coeff g)\\<^sup>2", "unfolding lg abs_le_square_iff[symmetric]"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>pl\\<bar> \\<le> \\<bar>pl * c\\<bar>", "by (rule aux_abs_int)"], ["proof (state)\nthis:\n  pl\\<^sup>2 \\<le> (lead_coeff g)\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  pl\\<^sup>2 \\<le> (lead_coeff g)\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lead_coeff g)\\<^sup>2 \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ 1", "using coeff_le_sq_norm[of g]"], ["proof (prove)\nusing this:\n  \\<bar>coeff g ?i\\<bar>\\<^sup>2 \\<le> \\<parallel>g\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (lead_coeff g)\\<^sup>2 \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ 1", "by auto"], ["proof (state)\nthis:\n  (lead_coeff g)\\<^sup>2 \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ 1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (lead_coeff g)\\<^sup>2 \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ 1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>g\\<parallel>\\<^sup>2 ^ 1\n    \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1", "by (rule pow_mono_exp, insert deg normg, auto)"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ 1\n  \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ 1\n  \\<le> \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "have \"\\<dots> = 1 * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1 =\n    1 * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1", "by simp"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1 =\n  1 * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1 =\n  1 * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n    \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n          \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1", "by (rule mult_right_mono, insert normf1, auto)"], ["proof (state)\nthis:\n  1 * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n        \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  1 * \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n        \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "have \"\\<dots> < pl\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n    < pl\\<^sup>2", "by (rule large)"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp g = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  < \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1", "show False"], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n  \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n  < \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree g *\n    \\<parallel>g\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree u \\<le> degree g\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from deg deg_u deg_ug"], ["proof (chain)\npicking this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n  degree u \\<noteq> 0\n  degree u \\<le> degree g", "have \"degree f1 > 0\" \"degree g > 0\""], ["proof (prove)\nusing this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n  degree u \\<noteq> 0\n  degree u \\<le> degree g\n\ngoal (1 subgoal):\n 1. 0 < degree f1 &&& 0 < degree g", "by auto"], ["proof (state)\nthis:\n  0 < degree f1\n  0 < degree g\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from common_factor_via_short[OF this mon_u _ uf1 ug large] deg_u pl.m1"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < degree u; 0 \\<le> pl\\<rbrakk>\n  \\<Longrightarrow> 0 < degree (gcd f1 g)\n  degree u \\<noteq> 0\n  1 < pl", "have \"0 < degree (gcd f1 g)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < degree u; 0 \\<le> pl\\<rbrakk>\n  \\<Longrightarrow> 0 < degree (gcd f1 g)\n  degree u \\<noteq> 0\n  1 < pl\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd f1 g)", "by auto"], ["proof (state)\nthis:\n  0 < degree (gcd f1 g)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < degree (gcd f1 g)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from True[unfolded k_def]"], ["proof (chain)\npicking this:\n  degree (gcd f g) = 0", "have \"degree (gcd f g) = 0\""], ["proof (prove)\nusing this:\n  degree (gcd f g) = 0\n\ngoal (1 subgoal):\n 1. degree (gcd f g) = 0", "."], ["proof (state)\nthis:\n  degree (gcd f g) = 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree (gcd f g) = 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have dvd: \"gcd f1 g dvd gcd f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f1 g dvd gcd f g", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd f1 g dvd gcd f g", "unfolding prod"], ["proof (prove)\nusing this:\n  f1 * f2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd f1 g dvd gcd (f1 * f2) g", "by simp"], ["proof (state)\nthis:\n  gcd f1 g dvd gcd f g\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 < degree (gcd f1 g)\n  degree (gcd f g) = 0\n  gcd f1 g dvd gcd f g", "show False"], ["proof (prove)\nusing this:\n  0 < degree (gcd f1 g)\n  degree (gcd f g) = 0\n  gcd f1 g dvd gcd f g\n\ngoal (1 subgoal):\n 1. False", "using divides_degree[OF dvd]"], ["proof (prove)\nusing this:\n  0 < degree (gcd f1 g)\n  degree (gcd f g) = 0\n  gcd f1 g dvd gcd f g\n  degree (gcd f1 g) \\<le> degree (gcd f g) \\<or> gcd f g = 0\n\ngoal (1 subgoal):\n 1. False", "using f0"], ["proof (prove)\nusing this:\n  0 < degree (gcd f1 g)\n  degree (gcd f g) = 0\n  gcd f1 g dvd gcd f g\n  degree (gcd f1 g) \\<le> degree (gcd f g) \\<or> gcd f g = 0\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible\\<^sub>d f\n\ngoal (2 subgoals):\n 1. degree k = 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "unfolding fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list [f] \\<and> (\\<forall>a\\<in>set [f]. irreducible\\<^sub>d a)", "using irr"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. f = prod_list [f] \\<and> (\\<forall>a\\<in>set [f]. irreducible\\<^sub>d a)", "by auto"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case False"], ["proof (state)\nthis:\n  degree k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "define f1 where \"f1 = f div k\""], ["proof (state)\nthis:\n  f1 = f div k\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have f: \"f = f1 * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f1 * k", "unfolding f1_def k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f div gcd f g * gcd f g", "by auto"], ["proof (state)\nthis:\n  f = f1 * k\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with arg_cong[OF this, of degree] f0"], ["proof (chain)\npicking this:\n  degree f = degree (f1 * k)\n  f \\<noteq> 0\n  f = f1 * k", "have deg_f1k: \"degree f = degree f1 + degree k\""], ["proof (prove)\nusing this:\n  degree f = degree (f1 * k)\n  f \\<noteq> 0\n  f = f1 * k\n\ngoal (1 subgoal):\n 1. degree f = degree f1 + degree k", "by (auto simp: degree_mult_eq)"], ["proof (state)\nthis:\n  degree f = degree f1 + degree k\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from f fF"], ["proof (chain)\npicking this:\n  f = f1 * k\n  f dvd F", "have dvd: \"f1 dvd F\" \"k dvd F\""], ["proof (prove)\nusing this:\n  f = f1 * k\n  f dvd F\n\ngoal (1 subgoal):\n 1. f1 dvd F &&& k dvd F", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  f = f1 * k\n  \\<exists>k. F = f * k\n\ngoal (1 subgoal):\n 1. \\<exists>k. F = f1 * k &&& \\<exists>ka. F = k * ka", "by auto"], ["proof (state)\nthis:\n  f1 dvd F\n  k dvd F\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain gs1 gs2 where part: \"List.partition (\\<lambda>gi. p.dvdm gi f1) us = (gs1, gs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gs1 gs2.\n        List.partition (\\<lambda>gi. p.dvdm gi f1) us =\n        (gs1, gs2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  List.partition (\\<lambda>gi. p.dvdm gi f1) us = (gs1, gs2)\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note IH = 1(1-2)[OF refl u_def g_def k_def refl, unfolded deg_fk, OF False f1_def part[symmetric] refl]"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_reconstruction f1 gs1 = ?fs1; degree f1 \\<noteq> 0;\n   pl.unique_factorization_m f1 (lead_coeff f1, mset gs1); f1 dvd F;\n   \\<And>ui. ui \\<in> set gs1 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> f1 = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n  \\<lbrakk>LLL_reconstruction k gs2 = ?fs1; degree k \\<noteq> 0;\n   pl.unique_factorization_m k (lead_coeff k, mset gs2); k dvd F;\n   \\<And>ui. ui \\<in> set gs2 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> k = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain fs1 where fs1: \"LLL_reconstruction f1 gs1 = fs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs1.\n        LLL_reconstruction f1 gs1 = fs1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_reconstruction f1 gs1 = fs1\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain fs2 where fs2: \"LLL_reconstruction k gs2 = fs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs2.\n        LLL_reconstruction k gs2 = fs2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_reconstruction k gs2 = fs2\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from False res[folded f1_def, unfolded part split fs1 fs2]"], ["proof (chain)\npicking this:\n  degree k \\<noteq> 0\n  (if degree k = 0 then [f] else fs1 @ fs2) = fs", "have fs: \"fs = fs1 @ fs2\""], ["proof (prove)\nusing this:\n  degree k \\<noteq> 0\n  (if degree k = 0 then [f] else fs1 @ fs2) = fs\n\ngoal (1 subgoal):\n 1. fs = fs1 @ fs2", "by auto"], ["proof (state)\nthis:\n  fs = fs1 @ fs2\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from short_main(1)"], ["proof (chain)\npicking this:\n  degree (LLL_short_polynomial pl (degree f) u) < degree f", "have deg_gf: \"degree g < degree f\""], ["proof (prove)\nusing this:\n  degree (LLL_short_polynomial pl (degree f) u) < degree f\n\ngoal (1 subgoal):\n 1. degree g < degree f", "unfolding g_def"], ["proof (prove)\nusing this:\n  degree (LLL_short_polynomial pl (degree f) u) < degree f\n\ngoal (1 subgoal):\n 1. degree (LLL_short_polynomial pl (degree f) u) < degree f", "by auto"], ["proof (state)\nthis:\n  degree g < degree f\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from short_main(2)"], ["proof (chain)\npicking this:\n  LLL_short_polynomial pl (degree f) u \\<noteq> 0", "have g0: \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  LLL_short_polynomial pl (degree f) u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  LLL_short_polynomial pl (degree f) u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LLL_short_polynomial pl (degree f) u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have deg_kg: \"degree k \\<le> degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree k \\<le> degree g", "unfolding k_def gcd.commute[of f g]"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd g f) \\<le> degree g", "by (rule degree_gcd1[OF g0])"], ["proof (state)\nthis:\n  degree k \\<le> degree g\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from deg_gf deg_kg"], ["proof (chain)\npicking this:\n  degree g < degree f\n  degree k \\<le> degree g", "have deg_kf: \"degree k < degree f\""], ["proof (prove)\nusing this:\n  degree g < degree f\n  degree k \\<le> degree g\n\ngoal (1 subgoal):\n 1. degree k < degree f", "by auto"], ["proof (state)\nthis:\n  degree k < degree f\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with deg_f1k"], ["proof (chain)\npicking this:\n  degree f = degree f1 + degree k\n  degree k < degree f", "have deg_f1: \"degree f1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f = degree f1 + degree k\n  degree k < degree f\n\ngoal (1 subgoal):\n 1. degree f1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have sf_f: \"p.square_free_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.square_free_m f", "using sf fF p.square_free_m_factor"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  f dvd F\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?f\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?g\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  \\<exists>k. F = f * k\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?f\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?g\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "by blast"], ["proof (state)\nthis:\n  p.square_free_m f\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from p.unique_factorization_m_factor_partition[OF l0 uf[unfolded plp] f cop sf_f part]"], ["proof (chain)\npicking this:\n  poly_mod.unique_factorization_m (p ^ l) f1 (lead_coeff f1, mset gs1)\n  poly_mod.unique_factorization_m (p ^ l) k (lead_coeff k, mset gs2)", "have uf: \"pl.unique_factorization_m f1 (lead_coeff f1, mset gs1)\"  \n          \"pl.unique_factorization_m k (lead_coeff k, mset gs2)\""], ["proof (prove)\nusing this:\n  poly_mod.unique_factorization_m (p ^ l) f1 (lead_coeff f1, mset gs1)\n  poly_mod.unique_factorization_m (p ^ l) k (lead_coeff k, mset gs2)\n\ngoal (1 subgoal):\n 1. pl.unique_factorization_m f1 (lead_coeff f1, mset gs1) &&&\n    pl.unique_factorization_m k (lead_coeff k, mset gs2)", "by (auto simp: plp)"], ["proof (state)\nthis:\n  pl.unique_factorization_m f1 (lead_coeff f1, mset gs1)\n  pl.unique_factorization_m k (lead_coeff k, mset gs2)\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"set us = set gs1 \\<union> set gs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set us = set gs1 \\<union> set gs2", "using part"], ["proof (prove)\nusing this:\n  List.partition (\\<lambda>gi. p.dvdm gi f1) us = (gs1, gs2)\n\ngoal (1 subgoal):\n 1. set us = set gs1 \\<union> set gs2", "by auto"], ["proof (state)\nthis:\n  set us = set gs1 \\<union> set gs2\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with norm"], ["proof (chain)\npicking this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  set us = set gs1 \\<union> set gs2", "have norm_12: \"gi \\<in> set gs1 \\<or> gi \\<in> set gs2 \\<Longrightarrow> pl.Mp gi = gi\" for gi"], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  set us = set gs1 \\<union> set gs2\n\ngoal (1 subgoal):\n 1. gi \\<in> set gs1 \\<or> gi \\<in> set gs2 \\<Longrightarrow> pl.Mp gi = gi", "by auto"], ["proof (state)\nthis:\n  ?gi1 \\<in> set gs1 \\<or> ?gi1 \\<in> set gs2 \\<Longrightarrow>\n  pl.Mp ?gi1 = ?gi1\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note IH1 = IH(1)[OF fs1 deg_f1 uf(1) dvd(1) norm_12]"], ["proof (state)\nthis:\n  (\\<And>ui.\n      ui \\<in> set gs1 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  f1 = prod_list fs1 \\<and> (\\<forall>a\\<in>set fs1. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note IH2 = IH(2)[OF fs2 False uf(2) dvd(2) norm_12]"], ["proof (state)\nthis:\n  (\\<And>ui.\n      ui \\<in> set gs2 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  k = prod_list fs2 \\<and> (\\<forall>a\\<in>set fs2. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. degree k \\<noteq> 0 \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "unfolding fs f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f1 * k = prod_list (fs1 @ fs2) \\<and>\n    (\\<forall>a\\<in>set (fs1 @ fs2). irreducible\\<^sub>d a)", "using IH1 IH2"], ["proof (prove)\nusing this:\n  (\\<And>ui.\n      ui \\<in> set gs1 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  f1 = prod_list fs1 \\<and> (\\<forall>a\\<in>set fs1. irreducible\\<^sub>d a)\n  (\\<And>ui.\n      ui \\<in> set gs2 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  k = prod_list fs2 \\<and> (\\<forall>a\\<in>set fs2. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. f1 * k = prod_list (fs1 @ fs2) \\<and>\n    (\\<forall>a\\<in>set (fs1 @ fs2). irreducible\\<^sub>d a)", "by auto"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_many_reconstruction: assumes \"LLL_many_reconstruction f us = fs\"\n  and \"degree f \\<noteq> 0\"\n  and \"poly_mod.unique_factorization_m pl f (lead_coeff f, mset us)\"\n  and \"f dvd F\" \n  and \"\\<And> ui. ui \\<in> set us \\<Longrightarrow> poly_mod.Mp pl ui = ui\" \n  and F0: \"F \\<noteq> 0\" \n  and cop: \"coprime (lead_coeff F) p\" \n  and sf: \"poly_mod.square_free_m p F\" \n  and pl1: \"pl > 1\" \n  and plp: \"pl = p^l\" \n  and p: \"prime p\" \n  and large: \"2^(5 * (degree F div 2) * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2^(2 * (degree F div 2)) < pl\\<^sup>2\"\nshows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "interpret p: poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by (standard, rule p)"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "interpret pl: poly_mod_2 \"pl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 pl", "by (standard, rule pl1)"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from pl1 plp"], ["proof (chain)\npicking this:\n  1 < pl\n  pl = p ^ l", "have l0: \"l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < pl\n  pl = p ^ l\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "by (cases l, auto)"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "using assms(1-5)"], ["proof (prove)\nusing this:\n  LLL_many_reconstruction f us = fs\n  degree f \\<noteq> 0\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n  f dvd F\n  ?ui \\<in> set us \\<Longrightarrow> pl.Mp ?ui = ?ui\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "proof (induct f us arbitrary: fs rule: LLL_many_reconstruction.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "case (1 f us fs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 = degree f; ?xa1 = ?x1 div 2;\n   ?xb1 =\n   find_map_filter\n    (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc ?xa1) u))\n    (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < ?x1)\n    (filter (\\<lambda>u. degree u \\<le> ?xa1) us);\n   ?xb1 = Some ?x2.1; ?xc1 = f div ?x2.1;\n   ?xd1 = List.partition (\\<lambda>gi. p.dvdm gi ?xc1) us;\n   (?xe1, ?y1) = ?xd1; LLL_many_reconstruction ?xc1 ?xe1 = ?fs1;\n   degree ?xc1 \\<noteq> 0;\n   pl.unique_factorization_m ?xc1 (lead_coeff ?xc1, mset ?xe1); ?xc1 dvd F;\n   \\<And>ui. ui \\<in> set ?xe1 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> ?xc1 = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n  \\<lbrakk>?x1 = degree f; ?xa1 = ?x1 div 2;\n   ?xb1 =\n   find_map_filter\n    (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc ?xa1) u))\n    (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < ?x1)\n    (filter (\\<lambda>u. degree u \\<le> ?xa1) us);\n   ?xb1 = Some ?x2.1; ?xc1 = f div ?x2.1;\n   ?xd1 = List.partition (\\<lambda>gi. p.dvdm gi ?xc1) us;\n   (?xe1, ?y1) = ?xd1; LLL_many_reconstruction ?x2.1 ?y1 = ?fs1;\n   degree ?x2.1 \\<noteq> 0;\n   pl.unique_factorization_m ?x2.1 (lead_coeff ?x2.1, mset ?y1);\n   ?x2.1 dvd F;\n   \\<And>ui. ui \\<in> set ?y1 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> ?x2.1 = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n  LLL_many_reconstruction f us = fs\n  degree f \\<noteq> 0\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n  f dvd F\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note res = 1(3)"], ["proof (state)\nthis:\n  LLL_many_reconstruction f us = fs\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note degf = 1(4)"], ["proof (state)\nthis:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note uf = 1(5)"], ["proof (state)\nthis:\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note fF = 1(6)"], ["proof (state)\nthis:\n  f dvd F\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note norm = 1(7)"], ["proof (state)\nthis:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note to_fact = pl.unique_factorization_m_imp_factorization"], ["proof (state)\nthis:\n  pl.unique_factorization_m ?f ?cfs \\<Longrightarrow>\n  pl.factorization_m ?f ?cfs\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note fact = to_fact[OF uf]"], ["proof (state)\nthis:\n  pl.factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have mon_gs: \"ui \\<in> set us \\<Longrightarrow> monic ui\" for ui"], ["proof (prove)\ngoal (1 subgoal):\n 1. ui \\<in> set us \\<Longrightarrow> monic ui", "using norm fact"], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  pl.factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. ui \\<in> set us \\<Longrightarrow> monic ui", "unfolding pl.factorization_m_def"], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  case (lead_coeff f, mset us) of\n  (c, fs) \\<Rightarrow>\n    pl.eq_m f (smult c (\\<Prod>\\<^sub># fs)) \\<and>\n    (\\<forall>f\\<in>#fs. pl.irreducible\\<^sub>d_m f \\<and> monic (pl.Mp f))\n\ngoal (1 subgoal):\n 1. ui \\<in> set us \\<Longrightarrow> monic ui", "by auto"], ["proof (state)\nthis:\n  ?ui1 \\<in> set us \\<Longrightarrow> monic ?ui1\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from p.coprime_lead_coeff_factor[OF p.prime] fF cop"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?f) p\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?g) p\n  f dvd F\n  comm_monoid_mult_class.coprime (lead_coeff F) p", "have cop: \"coprime (lead_coeff f) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?f) p\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?g) p\n  f dvd F\n  comm_monoid_mult_class.coprime (lead_coeff F) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?f) p\n  comm_monoid_mult_class.coprime (lead_coeff (?f * ?g)) p \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (lead_coeff ?g) p\n  \\<exists>k. F = f * k\n  comm_monoid_mult_class.coprime (lead_coeff F) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "by blast"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have plf0: \"pl.Mp f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.Mp f \\<noteq> 0", "using fact pl.factorization_m_lead_coeff pl.unique_factorization_m_zero uf"], ["proof (prove)\nusing this:\n  pl.factorization_m f (lead_coeff f, mset us)\n  pl.factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  lead_coeff (pl.Mp ?f) = pl.M ?c\n  pl.unique_factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  pl.M ?c \\<noteq> 0\n  pl.unique_factorization_m f (lead_coeff f, mset us)\n\ngoal (1 subgoal):\n 1. pl.Mp f \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  pl.Mp f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"degree f = pl.degree_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = pl.degree_m f", "by (rule sym, rule poly_mod.degree_m_eq[OF _ pl.m1], \n          insert cop p, simp add: l0 p.coprime_exp_mod plp)"], ["proof (state)\nthis:\n  degree f = pl.degree_m f\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "also"], ["proof (state)\nthis:\n  degree f = pl.degree_m f\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"\\<dots> =  sum_mset (image_mset pl.degree_m (mset us))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.degree_m f = \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))", "unfolding pl.factorization_m_degree[OF fact plf0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n    \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))", ".."], ["proof (state)\nthis:\n  pl.degree_m f = \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "also"], ["proof (state)\nthis:\n  pl.degree_m f = \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us))\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"\\<dots> = sum_list (map pl.degree_m us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n    sum_list (map pl.degree_m us)", "unfolding sum_mset_sum_list[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n    \\<Sum>\\<^sub># (mset (map pl.degree_m us))", "by auto"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n  sum_list (map pl.degree_m us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset pl.degree_m (mset us)) =\n  sum_list (map pl.degree_m us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have \"\\<dots> = sum_list (map degree us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map pl.degree_m us) = sum_list (map degree us)", "by (rule arg_cong[OF map_cong, OF refl], rule pl.monic_degree_m, insert mon_gs, auto)"], ["proof (state)\nthis:\n  sum_list (map pl.degree_m us) = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "finally"], ["proof (chain)\npicking this:\n  degree f = sum_list (map degree us)", "have degf_gs: \"degree f = sum_list (map degree us)\""], ["proof (prove)\nusing this:\n  degree f = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. degree f = sum_list (map degree us)", "by auto"], ["proof (state)\nthis:\n  degree f = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "hence gs: \"us \\<noteq> []\""], ["proof (prove)\nusing this:\n  degree f = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. us \\<noteq> []", "using degf"], ["proof (prove)\nusing this:\n  degree f = sum_list (map degree us)\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. us \\<noteq> []", "by (cases us, auto)"], ["proof (state)\nthis:\n  us \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from 1(4)"], ["proof (chain)\npicking this:\n  degree f \\<noteq> 0", "have f0: \"f \\<noteq> 0\" and df0: \"degree f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 &&& degree f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from norm"], ["proof (chain)\npicking this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1", "have norm': \"image_mset pl.Mp (mset us) = mset us\""], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. image_mset pl.Mp (mset us) = mset us", "by (induct us, auto)"], ["proof (state)\nthis:\n  image_mset pl.Mp (mset us) = mset us\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "have pl0: \"pl \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl \\<noteq> 0", "using pl1"], ["proof (prove)\nusing this:\n  1 < pl\n\ngoal (1 subgoal):\n 1. pl \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "let ?D2 = \"degree F div 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "let ?d2 = \"degree f div 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "define gg where \"gg = LLL_short_polynomial pl (Suc ?d2)\""], ["proof (state)\nthis:\n  gg = LLL_short_polynomial pl (Suc (degree f div 2))\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "let ?us = \"filter (\\<lambda>u. degree u \\<le> ?d2) us\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note res = res[unfolded LLL_many_reconstruction.simps[of f us], unfolded Let_def,\n        folded gg_def]"], ["proof (state)\nthis:\n  (case find_map_filter (\\<lambda>u. gcd f (gg u))\n         (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n         (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) of\n   None \\<Rightarrow> [f]\n   | Some f2 \\<Rightarrow>\n       case List.partition (\\<lambda>gi. p.dvdm gi (f div f2)) us of\n       (us1, us2) \\<Rightarrow>\n         LLL_many_reconstruction (f div f2) us1 @\n         LLL_many_reconstruction f2 us2) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "let ?f2_opt = \"find_map_filter (\\<lambda>u. gcd f (gg u)) \n      (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f) ?us\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f us fs.\n       \\<lbrakk>\\<And>x xa xb x2 xc xd xe y fs.\n                   \\<lbrakk>x = degree f; xa = x div 2;\n                    xb =\n                    find_map_filter\n                     (\\<lambda>u.\n                         gcd f (LLL_short_polynomial pl (Suc xa) u))\n                     (\\<lambda>f2.\n                         let deg = degree f2 in 0 < deg \\<and> deg < x)\n                     (filter (\\<lambda>u. degree u \\<le> xa) us);\n                    xb = Some x2; xc = f div x2;\n                    xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n                    (xe, y) = xd; LLL_many_reconstruction xc xe = fs;\n                    degree xc \\<noteq> 0;\n                    pl.unique_factorization_m xc (lead_coeff xc, mset xe);\n                    xc dvd F;\n                    \\<And>ui.\n                       ui \\<in> set xe \\<Longrightarrow>\n                       pl.Mp ui = ui\\<rbrakk>\n                   \\<Longrightarrow> xc = prod_list fs \\<and>\n                                     Ball (set fs) irreducible\\<^sub>d;\n        \\<And>x xa xb x2 xc xd xe y fs.\n           \\<lbrakk>x = degree f; xa = x div 2;\n            xb =\n            find_map_filter\n             (\\<lambda>u. gcd f (LLL_short_polynomial pl (Suc xa) u))\n             (\\<lambda>f2. let deg = degree f2 in 0 < deg \\<and> deg < x)\n             (filter (\\<lambda>u. degree u \\<le> xa) us);\n            xb = Some x2; xc = f div x2;\n            xd = List.partition (\\<lambda>gi. p.dvdm gi xc) us;\n            (xe, y) = xd; LLL_many_reconstruction x2 y = fs;\n            degree x2 \\<noteq> 0;\n            pl.unique_factorization_m x2 (lead_coeff x2, mset y); x2 dvd F;\n            \\<And>ui.\n               ui \\<in> set y \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n           \\<Longrightarrow> x2 = prod_list fs \\<and>\n                             Ball (set fs) irreducible\\<^sub>d;\n        LLL_many_reconstruction f us = fs; degree f \\<noteq> 0;\n        pl.unique_factorization_m f (lead_coeff f, mset us); f dvd F;\n        \\<And>ui. ui \\<in> set us \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (cases ?f2_opt)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case (Some f2)"], ["proof (state)\nthis:\n  find_map_filter (\\<lambda>u. gcd f (gg u))\n   (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n   (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n  Some f2\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from find_map_filter_Some[OF this]"], ["proof (chain)\npicking this:\n  (0 < degree f2 \\<and> degree f2 < degree f) \\<and>\n  f2 \\<in> (\\<lambda>u. gcd f (gg u)) `\n           set (filter (\\<lambda>u. degree u \\<le> degree f div 2) us)", "obtain g where deg_f2: \"degree f2 \\<noteq> 0\" \"degree f2 < degree f\"\n        and dvd: \"f2 dvd f\" and gcd: \"f2 = gcd f g\""], ["proof (prove)\nusing this:\n  (0 < degree f2 \\<and> degree f2 < degree f) \\<and>\n  f2 \\<in> (\\<lambda>u. gcd f (gg u)) `\n           set (filter (\\<lambda>u. degree u \\<le> degree f div 2) us)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>degree f2 \\<noteq> 0; degree f2 < degree f; f2 dvd f;\n         f2 = gcd f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree f2 \\<noteq> 0\n  degree f2 < degree f\n  f2 dvd f\n  f2 = gcd f g\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note res = res[unfolded Some option.simps]"], ["proof (state)\nthis:\n  (case List.partition (\\<lambda>gi. p.dvdm gi (f div f2)) us of\n   (us1, us2) \\<Rightarrow>\n     LLL_many_reconstruction (f div f2) us1 @\n     LLL_many_reconstruction f2 us2) =\n  fs\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "define f1 where \"f1 = f div f2\""], ["proof (state)\nthis:\n  f1 = f div f2\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have f: \"f = f1 * f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f1 * f2", "unfolding f1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f div f2 * f2", "using dvd"], ["proof (prove)\nusing this:\n  f2 dvd f\n\ngoal (1 subgoal):\n 1. f = f div f2 * f2", "by auto"], ["proof (state)\nthis:\n  f = f1 * f2\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with arg_cong[OF this, of degree] f0"], ["proof (chain)\npicking this:\n  degree f = degree (f1 * f2)\n  f \\<noteq> 0\n  f = f1 * f2", "have deg_sum: \"degree f = degree f1 + degree f2\""], ["proof (prove)\nusing this:\n  degree f = degree (f1 * f2)\n  f \\<noteq> 0\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. degree f = degree f1 + degree f2", "by (auto simp: degree_mult_eq)"], ["proof (state)\nthis:\n  degree f = degree f1 + degree f2\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with deg_f2"], ["proof (chain)\npicking this:\n  degree f2 \\<noteq> 0\n  degree f2 < degree f\n  degree f = degree f1 + degree f2", "have deg_f1: \"degree f1 \\<noteq> 0\" \"degree f1 < degree f\""], ["proof (prove)\nusing this:\n  degree f2 \\<noteq> 0\n  degree f2 < degree f\n  degree f = degree f1 + degree f2\n\ngoal (1 subgoal):\n 1. degree f1 \\<noteq> 0 &&& degree f1 < degree f", "by auto"], ["proof (state)\nthis:\n  degree f1 \\<noteq> 0\n  degree f1 < degree f\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from f fF"], ["proof (chain)\npicking this:\n  f = f1 * f2\n  f dvd F", "have dvd: \"f1 dvd F\" \"f2 dvd F\""], ["proof (prove)\nusing this:\n  f = f1 * f2\n  f dvd F\n\ngoal (1 subgoal):\n 1. f1 dvd F &&& f2 dvd F", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  f = f1 * f2\n  \\<exists>k. F = f * k\n\ngoal (1 subgoal):\n 1. \\<exists>k. F = f1 * k &&& \\<exists>k. F = f2 * k", "by auto"], ["proof (state)\nthis:\n  f1 dvd F\n  f2 dvd F\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain gs1 gs2 where part: \"List.partition (\\<lambda>gi. p.dvdm gi f1) us = (gs1, gs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gs1 gs2.\n        List.partition (\\<lambda>gi. p.dvdm gi f1) us =\n        (gs1, gs2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  List.partition (\\<lambda>gi. p.dvdm gi f1) us = (gs1, gs2)\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note IH = 1(1-2)[OF refl refl refl, unfolded Let_def, folded gg_def, OF Some f1_def part[symmetric] refl]"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_many_reconstruction f1 gs1 = ?fs1; degree f1 \\<noteq> 0;\n   pl.unique_factorization_m f1 (lead_coeff f1, mset gs1); f1 dvd F;\n   \\<And>ui. ui \\<in> set gs1 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> f1 = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n  \\<lbrakk>LLL_many_reconstruction f2 gs2 = ?fs1; degree f2 \\<noteq> 0;\n   pl.unique_factorization_m f2 (lead_coeff f2, mset gs2); f2 dvd F;\n   \\<And>ui. ui \\<in> set gs2 \\<Longrightarrow> pl.Mp ui = ui\\<rbrakk>\n  \\<Longrightarrow> f2 = prod_list ?fs1 \\<and>\n                    (\\<forall>a\\<in>set ?fs1. irreducible\\<^sub>d a)\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain fs1 where fs1: \"LLL_many_reconstruction f1 gs1 = fs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs1.\n        LLL_many_reconstruction f1 gs1 = fs1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LLL_many_reconstruction f1 gs1 = fs1\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain fs2 where fs2: \"LLL_many_reconstruction f2 gs2 = fs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs2.\n        LLL_many_reconstruction f2 gs2 = fs2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LLL_many_reconstruction f2 gs2 = fs2\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from res[folded f1_def, unfolded part split fs1 fs2]"], ["proof (chain)\npicking this:\n  fs1 @ fs2 = fs", "have fs: \"fs = fs1 @ fs2\""], ["proof (prove)\nusing this:\n  fs1 @ fs2 = fs\n\ngoal (1 subgoal):\n 1. fs = fs1 @ fs2", "by auto"], ["proof (state)\nthis:\n  fs = fs1 @ fs2\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have sf_f: \"p.square_free_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.square_free_m f", "using sf fF p.square_free_m_factor"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  f dvd F\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?f\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?g\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  \\<exists>k. F = f * k\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?f\n  p.square_free_m (?f * ?g) \\<Longrightarrow> p.square_free_m ?g\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "by blast"], ["proof (state)\nthis:\n  p.square_free_m f\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from p.unique_factorization_m_factor_partition[OF l0 uf[unfolded plp] f cop sf_f part]"], ["proof (chain)\npicking this:\n  poly_mod.unique_factorization_m (p ^ l) f1 (lead_coeff f1, mset gs1)\n  poly_mod.unique_factorization_m (p ^ l) f2 (lead_coeff f2, mset gs2)", "have uf: \"pl.unique_factorization_m f1 (lead_coeff f1, mset gs1)\"  \n          \"pl.unique_factorization_m f2 (lead_coeff f2, mset gs2)\""], ["proof (prove)\nusing this:\n  poly_mod.unique_factorization_m (p ^ l) f1 (lead_coeff f1, mset gs1)\n  poly_mod.unique_factorization_m (p ^ l) f2 (lead_coeff f2, mset gs2)\n\ngoal (1 subgoal):\n 1. pl.unique_factorization_m f1 (lead_coeff f1, mset gs1) &&&\n    pl.unique_factorization_m f2 (lead_coeff f2, mset gs2)", "by (auto simp: plp)"], ["proof (state)\nthis:\n  pl.unique_factorization_m f1 (lead_coeff f1, mset gs1)\n  pl.unique_factorization_m f2 (lead_coeff f2, mset gs2)\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"set us = set gs1 \\<union> set gs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set us = set gs1 \\<union> set gs2", "using part"], ["proof (prove)\nusing this:\n  List.partition (\\<lambda>gi. p.dvdm gi f1) us = (gs1, gs2)\n\ngoal (1 subgoal):\n 1. set us = set gs1 \\<union> set gs2", "by auto"], ["proof (state)\nthis:\n  set us = set gs1 \\<union> set gs2\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with norm"], ["proof (chain)\npicking this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  set us = set gs1 \\<union> set gs2", "have norm_12: \"gi \\<in> set gs1 \\<or> gi \\<in> set gs2 \\<Longrightarrow> pl.Mp gi = gi\" for gi"], ["proof (prove)\nusing this:\n  ?ui1 \\<in> set us \\<Longrightarrow> pl.Mp ?ui1 = ?ui1\n  set us = set gs1 \\<union> set gs2\n\ngoal (1 subgoal):\n 1. gi \\<in> set gs1 \\<or> gi \\<in> set gs2 \\<Longrightarrow> pl.Mp gi = gi", "by auto"], ["proof (state)\nthis:\n  ?gi1 \\<in> set gs1 \\<or> ?gi1 \\<in> set gs2 \\<Longrightarrow>\n  pl.Mp ?gi1 = ?gi1\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note IH1 = IH(1)[OF fs1 deg_f1(1) uf(1) dvd(1) norm_12]"], ["proof (state)\nthis:\n  (\\<And>ui.\n      ui \\<in> set gs1 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  f1 = prod_list fs1 \\<and> (\\<forall>a\\<in>set fs1. irreducible\\<^sub>d a)\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note IH2 = IH(2)[OF fs2 deg_f2(1) uf(2) dvd(2) norm_12]"], ["proof (state)\nthis:\n  (\\<And>ui.\n      ui \\<in> set gs2 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  f2 = prod_list fs2 \\<and> (\\<forall>a\\<in>set fs2. irreducible\\<^sub>d a)\n\ngoal (2 subgoals):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a.\n       find_map_filter (\\<lambda>u. gcd f (gg u))\n        (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n        (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n       Some a \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "unfolding fs f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f1 * f2 = prod_list (fs1 @ fs2) \\<and>\n    (\\<forall>a\\<in>set (fs1 @ fs2). irreducible\\<^sub>d a)", "using IH1 IH2"], ["proof (prove)\nusing this:\n  (\\<And>ui.\n      ui \\<in> set gs1 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  f1 = prod_list fs1 \\<and> (\\<forall>a\\<in>set fs1. irreducible\\<^sub>d a)\n  (\\<And>ui.\n      ui \\<in> set gs2 \\<Longrightarrow>\n      ui \\<in> set gs1 \\<or> ui \\<in> set gs2) \\<Longrightarrow>\n  f2 = prod_list fs2 \\<and> (\\<forall>a\\<in>set fs2. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. f1 * f2 = prod_list (fs1 @ fs2) \\<and>\n    (\\<forall>a\\<in>set (fs1 @ fs2). irreducible\\<^sub>d a)", "by auto"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case None"], ["proof (state)\nthis:\n  find_map_filter (\\<lambda>u. gcd f (gg u))\n   (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n   (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n  None\n\ngoal (1 subgoal):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from res[unfolded None option.simps]"], ["proof (chain)\npicking this:\n  [f] = fs", "have fs_f: \"fs = [f]\""], ["proof (prove)\nusing this:\n  [f] = fs\n\ngoal (1 subgoal):\n 1. fs = [f]", "by simp"], ["proof (state)\nthis:\n  fs = [f]\n\ngoal (1 subgoal):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from sf fF"], ["proof (chain)\npicking this:\n  p.square_free_m F\n  f dvd F", "have sf: \"p.square_free_m f\""], ["proof (prove)\nusing this:\n  p.square_free_m F\n  f dvd F\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "using p.square_free_m_factor(1)[of f]"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  f dvd F\n  p.square_free_m (f * ?g) \\<Longrightarrow> p.square_free_m f\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p.square_free_m F\n  \\<exists>k. F = f * k\n  p.square_free_m (f * ?g) \\<Longrightarrow> p.square_free_m f\n\ngoal (1 subgoal):\n 1. p.square_free_m f", "by auto"], ["proof (state)\nthis:\n  p.square_free_m f\n\ngoal (1 subgoal):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"irreducible\\<^sub>d f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "assume \"\\<not> irreducible\\<^sub>d f\""], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from reducible\\<^sub>dE[OF this] degf"], ["proof (chain)\npicking this:\n  \\<lbrakk>degree f = 0 \\<Longrightarrow> ?thesis;\n   \\<And>q r.\n      \\<lbrakk>0 < degree q; degree q < degree f; 0 < degree r;\n       degree r < degree f; f = q * r\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  degree f \\<noteq> 0", "obtain f1 f2 where \n          f: \"f = f1 * f2\" and\n          deg12: \"degree f1 \\<noteq> 0\" \"degree f2 \\<noteq> 0\" \"degree f1 < degree f\" \"degree f2 < degree f\""], ["proof (prove)\nusing this:\n  \\<lbrakk>degree f = 0 \\<Longrightarrow> ?thesis;\n   \\<And>q r.\n      \\<lbrakk>0 < degree q; degree q < degree f; 0 < degree r;\n       degree r < degree f; f = q * r\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0; degree f2 \\<noteq> 0;\n         degree f1 < degree f; degree f2 < degree f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp, metis)"], ["proof (state)\nthis:\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from f0"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have \"degree f = degree f1 + degree f2\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f = degree f1 + degree f2", "unfolding f"], ["proof (prove)\nusing this:\n  f1 * f2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (f1 * f2) = degree f1 + degree f2", "by (auto simp: degree_mult_eq)"], ["proof (state)\nthis:\n  degree f = degree f1 + degree f2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence \"degree f1 \\<le> degree f div 2 \\<or> degree f2 \\<le> degree f div 2\""], ["proof (prove)\nusing this:\n  degree f = degree f1 + degree f2\n\ngoal (1 subgoal):\n 1. degree f1 \\<le> degree f div 2 \\<or> degree f2 \\<le> degree f div 2", "by auto"], ["proof (state)\nthis:\n  degree f1 \\<le> degree f div 2 \\<or> degree f2 \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  degree f1 \\<le> degree f div 2 \\<or> degree f2 \\<le> degree f div 2", "obtain f1 f2 where \n          f: \"f = f1 * f2\" and\n          deg12: \"degree f1 \\<noteq> 0\" \"degree f2 \\<noteq> 0\" \"degree f1 \\<le> degree f div 2\" \"degree f2 < degree f\""], ["proof (prove)\nusing this:\n  degree f1 \\<le> degree f div 2 \\<or> degree f2 \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0; degree f2 \\<noteq> 0;\n         degree f1 \\<le> degree f div 2; degree f2 < degree f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f1 f2.\n                \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0;\n                 degree f2 \\<noteq> 0; degree f1 \\<le> degree f div 2;\n                 degree f2 < degree f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     degree f1 \\<le> degree f div 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>f1 f2.\n                \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0;\n                 degree f2 \\<noteq> 0; degree f1 \\<le> degree f div 2;\n                 degree f2 < degree f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     degree f2 \\<le> degree f div 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  \\<lbrakk>f = ?f1.1 * ?f2.1; degree ?f1.1 \\<noteq> 0;\n   degree ?f2.1 \\<noteq> 0; degree ?f1.1 \\<le> degree f div 2;\n   degree ?f2.1 < degree f\\<rbrakk>\n  \\<Longrightarrow> thesis\n  degree f1 \\<le> degree f div 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f1 f2.\n                \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0;\n                 degree f2 \\<noteq> 0; degree f1 \\<le> degree f div 2;\n                 degree f2 < degree f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     degree f1 \\<le> degree f div 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>f1 f2.\n                \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0;\n                 degree f2 \\<noteq> 0; degree f1 \\<le> degree f div 2;\n                 degree f2 < degree f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     degree f2 \\<le> degree f div 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "from 1(1)[of f1 f2] 1(2) f deg12"], ["proof (chain)\npicking this:\n  \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0; degree f2 \\<noteq> 0;\n   degree f1 \\<le> degree f div 2; degree f2 < degree f\\<rbrakk>\n  \\<Longrightarrow> thesis\n  degree f1 \\<le> degree f div 2\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0; degree f2 \\<noteq> 0;\n   degree f1 \\<le> degree f div 2; degree f2 < degree f\\<rbrakk>\n  \\<Longrightarrow> thesis\n  degree f1 \\<le> degree f div 2\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f1 f2.\n                \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0;\n                 degree f2 \\<noteq> 0; degree f1 \\<le> degree f div 2;\n                 degree f2 < degree f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     degree f2 \\<le> degree f div 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f1 f2.\n                \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0;\n                 degree f2 \\<noteq> 0; degree f1 \\<le> degree f div 2;\n                 degree f2 < degree f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     degree f2 \\<le> degree f div 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 2"], ["proof (state)\nthis:\n  \\<lbrakk>f = ?f1.1 * ?f2.1; degree ?f1.1 \\<noteq> 0;\n   degree ?f2.1 \\<noteq> 0; degree ?f1.1 \\<le> degree f div 2;\n   degree ?f2.1 < degree f\\<rbrakk>\n  \\<Longrightarrow> thesis\n  degree f2 \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f1 f2.\n                \\<lbrakk>f = f1 * f2; degree f1 \\<noteq> 0;\n                 degree f2 \\<noteq> 0; degree f1 \\<le> degree f div 2;\n                 degree f2 < degree f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     degree f2 \\<le> degree f div 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "from 2(1)[of f2 f1] 2(2) f deg12"], ["proof (chain)\npicking this:\n  \\<lbrakk>f = f2 * f1; degree f2 \\<noteq> 0; degree f1 \\<noteq> 0;\n   degree f2 \\<le> degree f div 2; degree f1 < degree f\\<rbrakk>\n  \\<Longrightarrow> thesis\n  degree f2 \\<le> degree f div 2\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>f = f2 * f1; degree f2 \\<noteq> 0; degree f1 \\<noteq> 0;\n   degree f2 \\<le> degree f div 2; degree f1 < degree f\\<rbrakk>\n  \\<Longrightarrow> thesis\n  degree f2 \\<le> degree f div 2\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 < degree f\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = f1 * f2\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 \\<le> degree f div 2\n  degree f2 < degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from f0 f"], ["proof (chain)\npicking this:\n  f \\<noteq> 0\n  f = f1 * f2", "have f10: \"f1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. f1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from sf f"], ["proof (chain)\npicking this:\n  p.square_free_m f\n  f = f1 * f2", "have sf1: \"p.square_free_m f1\""], ["proof (prove)\nusing this:\n  p.square_free_m f\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. p.square_free_m f1", "using p.square_free_m_factor(1)[of f1]"], ["proof (prove)\nusing this:\n  p.square_free_m f\n  f = f1 * f2\n  p.square_free_m (f1 * ?g) \\<Longrightarrow> p.square_free_m f1\n\ngoal (1 subgoal):\n 1. p.square_free_m f1", "by auto"], ["proof (state)\nthis:\n  p.square_free_m f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from p.coprime_lead_coeff_factor[OF p.prime cop[unfolded f]]"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff f1) p\n  comm_monoid_mult_class.coprime (lead_coeff f2) p", "have cop1: \"coprime (lead_coeff f1) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff f1) p\n  comm_monoid_mult_class.coprime (lead_coeff f2) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f1) p", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff f1) p\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have deg_m1: \"pl.degree_m f1 = degree f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.degree_m f1 = degree f1", "by (rule poly_mod.degree_m_eq[OF _ pl.m1], \n            insert cop1 p, simp add: l0 p.coprime_exp_mod plp)"], ["proof (state)\nthis:\n  pl.degree_m f1 = degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from pl.unique_factorization_m_factor[OF p uf[unfolded f], folded f, OF cop sf l0 plp]"], ["proof (chain)\npicking this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     pl.Mf (lead_coeff f, mset us) =\n     pl.Mf (lead_coeff f1 * lead_coeff f2, fs + gs) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs", "obtain us1 us2 where \n          uf12: \"pl.unique_factorization_m f1 (lead_coeff f1, us1)\"\n            \"pl.unique_factorization_m f2 (lead_coeff f2, us2)\"\n          and gs: \"mset us = us1 + us2\"\n          and norm12: \"image_mset pl.Mp us2 = us2\" \"image_mset pl.Mp us1 = us1\""], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     pl.Mf (lead_coeff f, mset us) =\n     pl.Mf (lead_coeff f1 * lead_coeff f2, fs + gs) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>us1 us2.\n        \\<lbrakk>pl.unique_factorization_m f1 (lead_coeff f1, us1);\n         pl.unique_factorization_m f2 (lead_coeff f2, us2);\n         mset us = us1 + us2; image_mset pl.Mp us2 = us2;\n         image_mset pl.Mp us1 = us1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding pl.Mf_def norm' split"], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     pl.unique_factorization_m f1 (lead_coeff f1, fs) \\<and>\n     pl.unique_factorization_m f2 (lead_coeff f2, gs) \\<and>\n     (pl.M (lead_coeff f), mset us) =\n     (pl.M (lead_coeff f1 * lead_coeff f2),\n      image_mset pl.Mp (fs + gs)) \\<and>\n     image_mset pl.Mp fs = fs \\<and> image_mset pl.Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>us1 us2.\n        \\<lbrakk>pl.unique_factorization_m f1 (lead_coeff f1, us1);\n         pl.unique_factorization_m f2 (lead_coeff f2, us2);\n         mset us = us1 + us2; image_mset pl.Mp us2 = us2;\n         image_mset pl.Mp us1 = us1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: pl.Mf_def)"], ["proof (state)\nthis:\n  pl.unique_factorization_m f1 (lead_coeff f1, us1)\n  pl.unique_factorization_m f2 (lead_coeff f2, us2)\n  mset us = us1 + us2\n  image_mset pl.Mp us2 = us2\n  image_mset pl.Mp us1 = us1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from gs"], ["proof (chain)\npicking this:\n  mset us = us1 + us2", "have \"x \\<in># us1 \\<Longrightarrow> x \\<in># mset us\" for x"], ["proof (prove)\nusing this:\n  mset us = us1 + us2\n\ngoal (1 subgoal):\n 1. x \\<in># us1 \\<Longrightarrow> x \\<in># mset us", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in># us1 \\<Longrightarrow> ?x1 \\<in># mset us\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence sub1: \"x \\<in># us1 \\<Longrightarrow> x \\<in> set us\" for x"], ["proof (prove)\nusing this:\n  ?x1 \\<in># us1 \\<Longrightarrow> ?x1 \\<in># mset us\n\ngoal (1 subgoal):\n 1. x \\<in># us1 \\<Longrightarrow> x \\<in> set us", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in># us1 \\<Longrightarrow> ?x1 \\<in> set us\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from to_fact[OF uf12(1)]"], ["proof (chain)\npicking this:\n  pl.factorization_m f1 (lead_coeff f1, us1)", "have fact1: \"pl.factorization_m f1 (lead_coeff f1, us1)\""], ["proof (prove)\nusing this:\n  pl.factorization_m f1 (lead_coeff f1, us1)\n\ngoal (1 subgoal):\n 1. pl.factorization_m f1 (lead_coeff f1, us1)", "."], ["proof (state)\nthis:\n  pl.factorization_m f1 (lead_coeff f1, us1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have plf10: \"pl.Mp f1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.Mp f1 \\<noteq> 0", "using fact1 pl.factorization_m_lead_coeff pl.unique_factorization_m_zero uf12(1)"], ["proof (prove)\nusing this:\n  pl.factorization_m f1 (lead_coeff f1, us1)\n  pl.factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  lead_coeff (pl.Mp ?f) = pl.M ?c\n  pl.unique_factorization_m ?f (?c, ?fs) \\<Longrightarrow>\n  pl.M ?c \\<noteq> 0\n  pl.unique_factorization_m f1 (lead_coeff f1, us1)\n\ngoal (1 subgoal):\n 1. pl.Mp f1 \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  pl.Mp f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"degree f1 = pl.degree_m f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f1 = pl.degree_m f1", "using deg_m1"], ["proof (prove)\nusing this:\n  pl.degree_m f1 = degree f1\n\ngoal (1 subgoal):\n 1. degree f1 = pl.degree_m f1", "by simp"], ["proof (state)\nthis:\n  degree f1 = pl.degree_m f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree f1 = pl.degree_m f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = sum_mset (image_mset pl.degree_m us1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pl.degree_m f1 = \\<Sum>\\<^sub># (image_mset pl.degree_m us1)", "unfolding pl.factorization_m_degree[OF fact1 plf10]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m us1) =\n    \\<Sum>\\<^sub># (image_mset pl.degree_m us1)", ".."], ["proof (state)\nthis:\n  pl.degree_m f1 = \\<Sum>\\<^sub># (image_mset pl.degree_m us1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  pl.degree_m f1 = \\<Sum>\\<^sub># (image_mset pl.degree_m us1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = sum_mset (image_mset degree us1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset pl.degree_m us1) =\n    \\<Sum>\\<^sub># (image_mset degree us1)", "by (rule arg_cong[of _ _ sum_mset], rule image_mset_cong,\n            rule pl.monic_degree_m, rule mon_gs, rule sub1)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset pl.degree_m us1) =\n  \\<Sum>\\<^sub># (image_mset degree us1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree f1 = \\<Sum>\\<^sub># (image_mset degree us1)", "have degf1_sum: \"degree f1 = sum_mset (image_mset degree us1)\""], ["proof (prove)\nusing this:\n  degree f1 = \\<Sum>\\<^sub># (image_mset degree us1)\n\ngoal (1 subgoal):\n 1. degree f1 = \\<Sum>\\<^sub># (image_mset degree us1)", "by auto"], ["proof (state)\nthis:\n  degree f1 = \\<Sum>\\<^sub># (image_mset degree us1)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with deg12"], ["proof (chain)\npicking this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 \\<le> degree f div 2\n  degree f2 < degree f\n  degree f1 = \\<Sum>\\<^sub># (image_mset degree us1)", "have \"us1 \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 \\<le> degree f div 2\n  degree f2 < degree f\n  degree f1 = \\<Sum>\\<^sub># (image_mset degree us1)\n\ngoal (1 subgoal):\n 1. us1 \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  us1 \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  us1 \\<noteq> {#}", "obtain u us11 where us1: \"us1 = {#u#} + us11\""], ["proof (prove)\nusing this:\n  us1 \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>u us11.\n        us1 = {#u#} + us11 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases us1, auto)"], ["proof (state)\nthis:\n  us1 = {#u#} + us11\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence u1: \"u \\<in># us1\""], ["proof (prove)\nusing this:\n  us1 = {#u#} + us11\n\ngoal (1 subgoal):\n 1. u \\<in># us1", "by auto"], ["proof (state)\nthis:\n  u \\<in># us1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence u: \"u \\<in> set us\""], ["proof (prove)\nusing this:\n  u \\<in># us1\n\ngoal (1 subgoal):\n 1. u \\<in> set us", "by (rule sub1)"], ["proof (state)\nthis:\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "let ?g = \"gg u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from pl.factorization_m_mem_dvdm[OF fact1, of u] u1"], ["proof (chain)\npicking this:\n  pl.Mp u \\<in># image_mset pl.Mp us1 \\<Longrightarrow> pl.dvdm u f1\n  u \\<in># us1", "have u_f1: \"pl.dvdm u f1\""], ["proof (prove)\nusing this:\n  pl.Mp u \\<in># image_mset pl.Mp us1 \\<Longrightarrow> pl.dvdm u f1\n  u \\<in># us1\n\ngoal (1 subgoal):\n 1. pl.dvdm u f1", "by auto"], ["proof (state)\nthis:\n  pl.dvdm u f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "note norm_u = norm[OF u]"], ["proof (state)\nthis:\n  pl.Mp u = u\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from fact u"], ["proof (chain)\npicking this:\n  pl.factorization_m f (lead_coeff f, mset us)\n  u \\<in> set us", "have irred: \"pl.irreducible\\<^sub>d_m u\""], ["proof (prove)\nusing this:\n  pl.factorization_m f (lead_coeff f, mset us)\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. pl.irreducible\\<^sub>d_m u", "unfolding pl.factorization_m_def"], ["proof (prove)\nusing this:\n  case (lead_coeff f, mset us) of\n  (c, fs) \\<Rightarrow>\n    pl.eq_m f (smult c (\\<Prod>\\<^sub># fs)) \\<and>\n    (\\<forall>f\\<in>#fs. pl.irreducible\\<^sub>d_m f \\<and> monic (pl.Mp f))\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. pl.irreducible\\<^sub>d_m u", "by auto"], ["proof (state)\nthis:\n  pl.irreducible\\<^sub>d_m u\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence deg_u: \"degree u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pl.irreducible\\<^sub>d_m u\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0", "unfolding pl.irreducible\\<^sub>d_m_def norm[OF u]"], ["proof (prove)\nusing this:\n  0 < degree u \\<and>\n  (\\<forall>g h.\n      pl.degree_m g < degree u \\<longrightarrow>\n      pl.degree_m h < degree u \\<longrightarrow> u \\<noteq> pl.Mp (g * h))\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"degree u \\<le> degree f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> degree f1", "unfolding degf1_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> \\<Sum>\\<^sub># (image_mset degree us1)", "unfolding us1"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> \\<Sum>\\<^sub># (image_mset degree ({#u#} + us11))", "by simp"], ["proof (state)\nthis:\n  degree u \\<le> degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree u \\<le> degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> \\<le> degree f div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f1 \\<le> degree f div 2", "by fact"], ["proof (state)\nthis:\n  degree f1 \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree u \\<le> degree f div 2", "have deg_uf: \"degree u \\<le> degree f div 2\""], ["proof (prove)\nusing this:\n  degree u \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. degree u \\<le> degree f div 2", "."], ["proof (state)\nthis:\n  degree u \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence deg_uf': \"degree u \\<le> Suc (degree f div 2)\" \"degree u < Suc (degree f div 2)\""], ["proof (prove)\nusing this:\n  degree u \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. degree u \\<le> Suc (degree f div 2) &&& degree u < Suc (degree f div 2)", "by auto"], ["proof (state)\nthis:\n  degree u \\<le> Suc (degree f div 2)\n  degree u < Suc (degree f div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from mon_gs[OF u]"], ["proof (chain)\npicking this:\n  monic u", "have mon_u: \"monic u\""], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. monic u", "."], ["proof (state)\nthis:\n  monic u\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "note short = LLL_short_polynomial[OF deg_u deg_uf'(1) pl1 mon_u, folded gg_def]"], ["proof (state)\nthis:\n  degree (gg u) < Suc (degree f div 2)\n  gg u \\<noteq> 0\n  pl.dvdm u (gg u)\n  \\<lbrakk>degree u < Suc (degree f div 2); ?f \\<noteq> 0; pl.dvdm u ?f;\n   degree ?f < Suc (degree f div 2)\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>gg u\\<parallel>\\<^sup>2\n                    \\<le> 2 ^ (Suc (degree f div 2) - 1) *\n                          \\<parallel>?f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "note short = short(1-3) short(4)[OF deg_uf'(2)]"], ["proof (state)\nthis:\n  degree (gg u) < Suc (degree f div 2)\n  gg u \\<noteq> 0\n  pl.dvdm u (gg u)\n  \\<lbrakk>?f \\<noteq> 0; pl.dvdm u ?f;\n   degree ?f < Suc (degree f div 2)\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>gg u\\<parallel>\\<^sup>2\n                    \\<le> 2 ^ (Suc (degree f div 2) - 1) *\n                          \\<parallel>?f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from short(1,2) deg12(1,3) f10"], ["proof (chain)\npicking this:\n  degree (gg u) < Suc (degree f div 2)\n  gg u \\<noteq> 0\n  degree f1 \\<noteq> 0\n  degree f1 \\<le> degree f div 2\n  f1 \\<noteq> 0", "have \"degree (gcd f ?g) \\<le> degree f div 2\""], ["proof (prove)\nusing this:\n  degree (gg u) < Suc (degree f div 2)\n  gg u \\<noteq> 0\n  degree f1 \\<noteq> 0\n  degree f1 \\<le> degree f div 2\n  f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd f (gg u)) \\<le> degree f div 2", "by (metis Suc_leI Suc_le_mono degree_gcd1 gcd.commute le_trans)"], ["proof (state)\nthis:\n  degree (gcd f (gg u)) \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (gcd f (gg u)) \\<le> degree f div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> < degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f div 2 < degree f", "using degf"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f div 2 < degree f", "by simp"], ["proof (state)\nthis:\n  degree f div 2 < degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (gcd f (gg u)) < degree f", "have \"degree (gcd f ?g) < degree f\""], ["proof (prove)\nusing this:\n  degree (gcd f (gg u)) < degree f\n\ngoal (1 subgoal):\n 1. degree (gcd f (gg u)) < degree f", "by simp"], ["proof (state)\nthis:\n  degree (gcd f (gg u)) < degree f\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with find_map_filter_None[OF None, simplified, rule_format, of u] deg_uf u"], ["proof (chain)\npicking this:\n  u \\<in> set us \\<and> degree u \\<le> degree f div 2 \\<Longrightarrow>\n  degree (gcd f (gg u)) = 0 \\<or> \\<not> degree (gcd f (gg u)) < degree f\n  degree u \\<le> degree f div 2\n  u \\<in> set us\n  degree (gcd f (gg u)) < degree f", "have deg_gcd: \"degree (gcd f (?g)) = 0\""], ["proof (prove)\nusing this:\n  u \\<in> set us \\<and> degree u \\<le> degree f div 2 \\<Longrightarrow>\n  degree (gcd f (gg u)) = 0 \\<or> \\<not> degree (gcd f (gg u)) < degree f\n  degree u \\<le> degree f div 2\n  u \\<in> set us\n  degree (gcd f (gg u)) < degree f\n\ngoal (1 subgoal):\n 1. degree (gcd f (gg u)) = 0", "by (auto simp: gcd.commute)"], ["proof (state)\nthis:\n  degree (gcd f (gg u)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"gcd f1 (?g) dvd gcd f (?g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f1 (gg u) dvd gcd f (gg u)", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd f1 (gg u) dvd gcd f (gg u)", "unfolding f"], ["proof (prove)\nusing this:\n  f1 * f2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd f1 (gg u) dvd gcd (f1 * f2) (gg u)", "by simp"], ["proof (state)\nthis:\n  gcd f1 (gg u) dvd gcd f (gg u)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from divides_degree[OF this, unfolded deg_gcd] f0"], ["proof (chain)\npicking this:\n  degree (gcd f1 (gg u)) \\<le> 0 \\<or> gcd f (gg u) = 0\n  f \\<noteq> 0", "have deg_gcd1: \"degree (gcd f1 (?g)) = 0\""], ["proof (prove)\nusing this:\n  degree (gcd f1 (gg u)) \\<le> 0 \\<or> gcd f (gg u) = 0\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd f1 (gg u)) = 0", "by auto"], ["proof (state)\nthis:\n  degree (gcd f1 (gg u)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from F0"], ["proof (chain)\npicking this:\n  F \\<noteq> 0", "have normF: \"\\<parallel>F\\<parallel>\\<^sup>2 \\<ge> 1\""], ["proof (prove)\nusing this:\n  F \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>F\\<parallel>\\<^sup>2", "using sq_norm_poly_pos[of F]"], ["proof (prove)\nusing this:\n  F \\<noteq> 0\n  (0 < \\<parallel>F\\<parallel>\\<^sup>2) = (F \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>F\\<parallel>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>F\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have g0: \"?g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gg u \\<noteq> 0", "using short(2)"], ["proof (prove)\nusing this:\n  gg u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gg u \\<noteq> 0", "."], ["proof (state)\nthis:\n  gg u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from g0"], ["proof (chain)\npicking this:\n  gg u \\<noteq> 0", "have normg: \"\\<parallel>?g\\<parallel>\\<^sup>2 \\<ge> 1\""], ["proof (prove)\nusing this:\n  gg u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2", "using sq_norm_poly_pos[of \"?g\"]"], ["proof (prove)\nusing this:\n  gg u \\<noteq> 0\n  (0 < \\<parallel>gg u\\<parallel>\\<^sup>2) = (gg u \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from f10"], ["proof (chain)\npicking this:\n  f1 \\<noteq> 0", "have normf1: \"\\<parallel>f1\\<parallel>\\<^sup>2 \\<ge> 1\""], ["proof (prove)\nusing this:\n  f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2", "using sq_norm_poly_pos[of f1]"], ["proof (prove)\nusing this:\n  f1 \\<noteq> 0\n  (0 < \\<parallel>f1\\<parallel>\\<^sup>2) = (f1 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from fF f"], ["proof (chain)\npicking this:\n  f dvd F\n  f = f1 * f2", "have f1F: \"f1 dvd F\""], ["proof (prove)\nusing this:\n  f dvd F\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. f1 dvd F", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. F = f * k\n  f = f1 * f2\n\ngoal (1 subgoal):\n 1. \\<exists>k. F = f1 * k", "by auto"], ["proof (state)\nthis:\n  f1 dvd F\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have pl_ge0: \"pl \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> pl", "using pl.poly_mod_2_axioms poly_mod_2_def"], ["proof (prove)\nusing this:\n  poly_mod_2 pl\n  poly_mod_2 ?m \\<equiv> 1 < ?m\n\ngoal (1 subgoal):\n 1. 0 \\<le> pl", "by auto"], ["proof (state)\nthis:\n  0 \\<le> pl\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from fF"], ["proof (chain)\npicking this:\n  f dvd F", "have \"degree f \\<le> degree F\""], ["proof (prove)\nusing this:\n  f dvd F\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree F", "using F0 f0"], ["proof (prove)\nusing this:\n  f dvd F\n  F \\<noteq> 0\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree F", "by (metis dvd_imp_degree_le)"], ["proof (state)\nthis:\n  degree f \\<le> degree F\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence d2D2: \"?d2 \\<le> ?D2\""], ["proof (prove)\nusing this:\n  degree f \\<le> degree F\n\ngoal (1 subgoal):\n 1. degree f div 2 \\<le> degree F div 2", "by simp"], ["proof (state)\nthis:\n  degree f div 2 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with deg12(3)"], ["proof (chain)\npicking this:\n  degree f1 \\<le> degree f div 2\n  degree f div 2 \\<le> degree F div 2", "have df1_D2: \"degree f1 \\<le> ?D2\""], ["proof (prove)\nusing this:\n  degree f1 \\<le> degree f div 2\n  degree f div 2 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. degree f1 \\<le> degree F div 2", "by linarith"], ["proof (state)\nthis:\n  degree f1 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from short(1) d2D2"], ["proof (chain)\npicking this:\n  degree (gg u) < Suc (degree f div 2)\n  degree f div 2 \\<le> degree F div 2", "have dg_D2: \"degree (gg u) \\<le> ?D2\""], ["proof (prove)\nusing this:\n  degree (gg u) < Suc (degree f div 2)\n  degree f div 2 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. degree (gg u) \\<le> degree F div 2", "by linarith"], ["proof (state)\nthis:\n  degree (gg u) \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n          \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ ?D2 * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ ?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n    \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n          \\<parallel>gg u\\<parallel>\\<^sup>2 ^ (degree F div 2)", "by (rule mult_mono[OF pow_mono_exp pow_mono_exp], \n              insert normf1 normg, auto intro: df1_D2 dg_D2)"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n        \\<parallel>gg u\\<parallel>\\<^sup>2 ^ (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n        \\<parallel>gg u\\<parallel>\\<^sup>2 ^ (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = (\\<parallel>f1\\<parallel>\\<^sup>2 * \\<parallel>gg u\\<parallel>\\<^sup>2)^?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ (degree F div 2) =\n    (\\<parallel>f1\\<parallel>\\<^sup>2 *\n     \\<parallel>gg u\\<parallel>\\<^sup>2) ^\n    (degree F div 2)", "by (simp add: power_mult_distrib)"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ (degree F div 2) =\n  (\\<parallel>f1\\<parallel>\\<^sup>2 * \\<parallel>gg u\\<parallel>\\<^sup>2) ^\n  (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ (degree F div 2) =\n  (\\<parallel>f1\\<parallel>\\<^sup>2 * \\<parallel>gg u\\<parallel>\\<^sup>2) ^\n  (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> \\<le> (\\<parallel>f1\\<parallel>\\<^sup>2 * (2^?D2 * \\<parallel>f1\\<parallel>\\<^sup>2))^?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<parallel>f1\\<parallel>\\<^sup>2 *\n     \\<parallel>gg u\\<parallel>\\<^sup>2) ^\n    (degree F div 2)\n    \\<le> (\\<parallel>f1\\<parallel>\\<^sup>2 *\n           (2 ^ (degree F div 2) * \\<parallel>f1\\<parallel>\\<^sup>2)) ^\n          (degree F div 2)", "by (rule power_mono[OF mult_left_mono[OF order.trans[OF short(4)[OF f10 u_f1]]]],\n            insert deg12 d2D2, auto intro!: mult_mono)"], ["proof (state)\nthis:\n  (\\<parallel>f1\\<parallel>\\<^sup>2 * \\<parallel>gg u\\<parallel>\\<^sup>2) ^\n  (degree F div 2)\n  \\<le> (\\<parallel>f1\\<parallel>\\<^sup>2 *\n         (2 ^ (degree F div 2) * \\<parallel>f1\\<parallel>\\<^sup>2)) ^\n        (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<parallel>f1\\<parallel>\\<^sup>2 * \\<parallel>gg u\\<parallel>\\<^sup>2) ^\n  (degree F div 2)\n  \\<le> (\\<parallel>f1\\<parallel>\\<^sup>2 *\n         (2 ^ (degree F div 2) * \\<parallel>f1\\<parallel>\\<^sup>2)) ^\n        (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = \\<parallel>f1\\<parallel>\\<^sup>2 ^ (?D2 + ?D2) * 2^(?D2 * ?D2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<parallel>f1\\<parallel>\\<^sup>2 *\n     (2 ^ (degree F div 2) * \\<parallel>f1\\<parallel>\\<^sup>2)) ^\n    (degree F div 2) =\n    \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2) *\n    2 ^ (degree F div 2 * (degree F div 2))", "unfolding power_add power_mult_distrib power_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n    ((2 ^ (degree F div 2)) ^ (degree F div 2) *\n     \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2)) =\n    \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n    \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n    (2 ^ (degree F div 2)) ^ (degree F div 2)", "by simp"], ["proof (state)\nthis:\n  (\\<parallel>f1\\<parallel>\\<^sup>2 *\n   (2 ^ (degree F div 2) * \\<parallel>f1\\<parallel>\\<^sup>2)) ^\n  (degree F div 2) =\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2) *\n  2 ^ (degree F div 2 * (degree F div 2))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<parallel>f1\\<parallel>\\<^sup>2 *\n   (2 ^ (degree F div 2) * \\<parallel>f1\\<parallel>\\<^sup>2)) ^\n  (degree F div 2) =\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2) *\n  2 ^ (degree F div 2 * (degree F div 2))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> \\<le> (2 ^ (2 * ?D2) * \\<parallel>F\\<parallel>\\<^sup>2) ^ (?D2 + ?D2) * 2^(?D2 * ?D2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2) *\n    2 ^ (degree F div 2 * (degree F div 2))\n    \\<le> (2 ^ (2 * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n          (degree F div 2 + degree F div 2) *\n          2 ^ (degree F div 2 * (degree F div 2))", "by (rule mult_right_mono[OF order.trans[OF power_mono[OF sq_norm_factor_bound[OF f1F F0]]]], \n            auto intro!: power_mono mult_right_mono df1_D2)"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2) *\n  2 ^ (degree F div 2 * (degree F div 2))\n  \\<le> (2 ^ (2 * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree F div 2 + degree F div 2) *\n        2 ^ (degree F div 2 * (degree F div 2))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2) *\n  2 ^ (degree F div 2 * (degree F div 2))\n  \\<le> (2 ^ (2 * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n        (degree F div 2 + degree F div 2) *\n        2 ^ (degree F div 2 * (degree F div 2))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> = 2 ^ (2 * ?D2 * (?D2 + ?D2) + ?D2 * ?D2) * \\<parallel>F\\<parallel>\\<^sup>2 ^ (?D2 + ?D2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ (2 * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n    (degree F div 2 + degree F div 2) *\n    2 ^ (degree F div 2 * (degree F div 2)) =\n    2 ^\n    (2 * (degree F div 2) * (degree F div 2 + degree F div 2) +\n     degree F div 2 * (degree F div 2)) *\n    \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2)", "unfolding power_mult_distrib power_mult power_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2\\<^sup>2 ^ (degree F div 2)) ^ (degree F div 2) *\n    \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n    ((2\\<^sup>2 ^ (degree F div 2)) ^ (degree F div 2) *\n     \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F div 2)) *\n    (2 ^ (degree F div 2)) ^ (degree F div 2) =\n    (2\\<^sup>2 ^ (degree F div 2)) ^ (degree F div 2) *\n    (2\\<^sup>2 ^ (degree F div 2)) ^ (degree F div 2) *\n    (2 ^ (degree F div 2)) ^ (degree F div 2) *\n    (\\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F div 2) *\n     \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F div 2))", "by simp"], ["proof (state)\nthis:\n  (2 ^ (2 * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n  (degree F div 2 + degree F div 2) *\n  2 ^ (degree F div 2 * (degree F div 2)) =\n  2 ^\n  (2 * (degree F div 2) * (degree F div 2 + degree F div 2) +\n   degree F div 2 * (degree F div 2)) *\n  \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (2 ^ (2 * (degree F div 2)) * \\<parallel>F\\<parallel>\\<^sup>2) ^\n  (degree F div 2 + degree F div 2) *\n  2 ^ (degree F div 2 * (degree F div 2)) =\n  2 ^\n  (2 * (degree F div 2) * (degree F div 2 + degree F div 2) +\n   degree F div 2 * (degree F div 2)) *\n  \\<parallel>F\\<parallel>\\<^sup>2 ^ (degree F div 2 + degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"2 * ?D2 * (?D2 + ?D2) + ?D2 * ?D2 = 5 * ?D2 * ?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (degree F div 2) * (degree F div 2 + degree F div 2) +\n    degree F div 2 * (degree F div 2) =\n    5 * (degree F div 2) * (degree F div 2)", "by simp"], ["proof (state)\nthis:\n  2 * (degree F div 2) * (degree F div 2 + degree F div 2) +\n  degree F div 2 * (degree F div 2) =\n  5 * (degree F div 2) * (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 * (degree F div 2) * (degree F div 2 + degree F div 2) +\n  degree F div 2 * (degree F div 2) =\n  5 * (degree F div 2) * (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"?D2 + ?D2 = 2 * ?D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree F div 2 + degree F div 2 = 2 * (degree F div 2)", "by simp"], ["proof (state)\nthis:\n  degree F div 2 + degree F div 2 = 2 * (degree F div 2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> 2 ^ (5 * (degree F div 2) * (degree F div 2)) *\n        \\<parallel>F\\<parallel>\\<^sup>2 ^ (2 * (degree F div 2))", "have large: \n          \"\\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1 < pl^2\""], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> 2 ^ (5 * (degree F div 2) * (degree F div 2)) *\n        \\<parallel>F\\<parallel>\\<^sup>2 ^ (2 * (degree F div 2))\n\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n    < pl\\<^sup>2", "using large"], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> 2 ^ (5 * (degree F div 2) * (degree F div 2)) *\n        \\<parallel>F\\<parallel>\\<^sup>2 ^ (2 * (degree F div 2))\n  2 ^ (5 * (degree F div 2) * (degree F div 2)) *\n  \\<parallel>F\\<parallel>\\<^sup>2 ^ (2 * (degree F div 2))\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n    < pl\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"degree u \\<le> degree (?g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> degree (gg u)", "proof (rule pl.dvdm_degree[OF mon_u short(3)], standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "assume \"pl.Mp (?g) = 0\""], ["proof (state)\nthis:\n  pl.Mp (gg u) = 0\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "from arg_cong[OF this, of \"\\<lambda> p. coeff p (degree ?g)\"]"], ["proof (chain)\npicking this:\n  coeff (pl.Mp (gg u)) (degree (gg u)) = coeff 0 (degree (gg u))", "have \"pl.M (coeff ?g (degree ?g)) = 0\""], ["proof (prove)\nusing this:\n  coeff (pl.Mp (gg u)) (degree (gg u)) = coeff 0 (degree (gg u))\n\ngoal (1 subgoal):\n 1. pl.M (lead_coeff (gg u)) = 0", "by (auto simp: pl.Mp_def coeff_map_poly)"], ["proof (state)\nthis:\n  pl.M (lead_coeff (gg u)) = 0\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "from this[unfolded pl.M_def]"], ["proof (chain)\npicking this:\n  lead_coeff (gg u) mod pl = 0", "obtain c where lg: \"lead_coeff ?g = pl * c\""], ["proof (prove)\nusing this:\n  lead_coeff (gg u) mod pl = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        lead_coeff (gg u) = pl * c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lead_coeff (gg u) = pl * c\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "with g0"], ["proof (chain)\npicking this:\n  gg u \\<noteq> 0\n  lead_coeff (gg u) = pl * c", "have c0: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  gg u \\<noteq> 0\n  lead_coeff (gg u) = pl * c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "hence \"pl^2 \\<le> (lead_coeff ?g)^2\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pl\\<^sup>2 \\<le> (lead_coeff (gg u))\\<^sup>2", "unfolding lg abs_le_square_iff[symmetric]"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>pl\\<bar> \\<le> \\<bar>pl * c\\<bar>", "by (rule aux_abs_int)"], ["proof (state)\nthis:\n  pl\\<^sup>2 \\<le> (lead_coeff (gg u))\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  pl\\<^sup>2 \\<le> (lead_coeff (gg u))\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> \\<parallel>?g\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lead_coeff (gg u))\\<^sup>2 \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2", "using coeff_le_sq_norm[of ?g]"], ["proof (prove)\nusing this:\n  \\<bar>coeff (gg u) ?i\\<bar>\\<^sup>2\n  \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (lead_coeff (gg u))\\<^sup>2 \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (lead_coeff (gg u))\\<^sup>2 \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (lead_coeff (gg u))\\<^sup>2 \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "have \"\\<dots> = \\<parallel>?g\\<parallel>\\<^sup>2 ^ 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gg u\\<parallel>\\<^sup>2 =\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ 1", "by simp"], ["proof (state)\nthis:\n  \\<parallel>gg u\\<parallel>\\<^sup>2 =\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ 1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>gg u\\<parallel>\\<^sup>2 =\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ 1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> \\<parallel>?g\\<parallel>\\<^sup>2 ^ degree f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gg u\\<parallel>\\<^sup>2 ^ 1\n    \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1", "by (rule pow_mono_exp, insert deg12 normg, auto)"], ["proof (state)\nthis:\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ 1\n  \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ 1\n  \\<le> \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "have \"\\<dots> = 1 * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1 =\n    1 * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1", "by simp"], ["proof (state)\nthis:\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1 =\n  1 * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1 =\n  1 * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree ?g * \\<parallel>?g\\<parallel>\\<^sup>2 ^ degree f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n    \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n          \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1", "by (rule mult_right_mono, insert normf1, auto)"], ["proof (state)\nthis:\n  1 * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n        \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  1 * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n        \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "have \"\\<dots> < pl\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n    < pl\\<^sup>2", "by (rule large)"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. pl.Mp (gg u) = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1", "show False"], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree u \\<le> degree (gg u)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with deg_u"], ["proof (chain)\npicking this:\n  degree u \\<noteq> 0\n  degree u \\<le> degree (gg u)", "have deg_g: \"0 < degree (gg u)\""], ["proof (prove)\nusing this:\n  degree u \\<noteq> 0\n  degree u \\<le> degree (gg u)\n\ngoal (1 subgoal):\n 1. 0 < degree (gg u)", "by auto"], ["proof (state)\nthis:\n  0 < degree (gg u)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have pl_ge0: \"pl \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> pl", "using pl.poly_mod_2_axioms poly_mod_2_def"], ["proof (prove)\nusing this:\n  poly_mod_2 pl\n  poly_mod_2 ?m \\<equiv> 1 < ?m\n\ngoal (1 subgoal):\n 1. 0 \\<le> pl", "by auto"], ["proof (state)\nthis:\n  0 \\<le> pl\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from fF"], ["proof (chain)\npicking this:\n  f dvd F", "have \"degree f \\<le> degree F\""], ["proof (prove)\nusing this:\n  f dvd F\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree F", "using F0 f0"], ["proof (prove)\nusing this:\n  f dvd F\n  F \\<noteq> 0\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree F", "by (metis dvd_imp_degree_le)"], ["proof (state)\nthis:\n  degree f \\<le> degree F\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "hence d2D2: \"?d2 \\<le> ?D2\""], ["proof (prove)\nusing this:\n  degree f \\<le> degree F\n\ngoal (1 subgoal):\n 1. degree f div 2 \\<le> degree F div 2", "by simp"], ["proof (state)\nthis:\n  degree f div 2 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "with deg12(3)"], ["proof (chain)\npicking this:\n  degree f1 \\<le> degree f div 2\n  degree f div 2 \\<le> degree F div 2", "have df1_D2: \"degree f1 \\<le> ?D2\""], ["proof (prove)\nusing this:\n  degree f1 \\<le> degree f div 2\n  degree f div 2 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. degree f1 \\<le> degree F div 2", "by linarith"], ["proof (state)\nthis:\n  degree f1 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from short(1) d2D2"], ["proof (chain)\npicking this:\n  degree (gg u) < Suc (degree f div 2)\n  degree f div 2 \\<le> degree F div 2", "have dg_D2: \"degree (gg u) \\<le> ?D2\""], ["proof (prove)\nusing this:\n  degree (gg u) < Suc (degree f div 2)\n  degree f div 2 \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. degree (gg u) \\<le> degree F div 2", "by linarith"], ["proof (state)\nthis:\n  degree (gg u) \\<le> degree F div 2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"0 < degree f1\" \"0 < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree f1 &&& 0 < degree u", "using deg12 deg_u"], ["proof (prove)\nusing this:\n  degree f1 \\<noteq> 0\n  degree f2 \\<noteq> 0\n  degree f1 \\<le> degree f div 2\n  degree f2 < degree f\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree f1 &&& 0 < degree u", "by auto"], ["proof (state)\nthis:\n  0 < degree f1\n  0 < degree u\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "from common_factor_via_short[of f1 \"gg u\", OF this(1) deg_g mon_u this(2) u_f1 short(3) _ pl_ge0] deg_gcd1"], ["proof (chain)\npicking this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2 \\<Longrightarrow>\n  0 < degree (gcd f1 (gg u))\n  degree (gcd f1 (gg u)) = 0", "have \"pl^2 \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) * \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\""], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2 \\<Longrightarrow>\n  0 < degree (gcd f1 (gg u))\n  degree (gcd f1 (gg u)) = 0\n\ngoal (1 subgoal):\n 1. pl\\<^sup>2\n    \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n          \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1", "by linarith"], ["proof (state)\nthis:\n  pl\\<^sup>2\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n        \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  pl\\<^sup>2\n  \\<le> \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n        \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "have \"\\<dots> < pl^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n    < pl\\<^sup>2", "by (rule large)"], ["proof (state)\nthis:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < pl\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d f \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1", "show False"], ["proof (prove)\nusing this:\n  \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n  \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n  < \\<parallel>f1\\<parallel>\\<^sup>2 ^ degree (gg u) *\n    \\<parallel>gg u\\<parallel>\\<^sup>2 ^ degree f1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. find_map_filter (\\<lambda>u. gcd f (gg u))\n     (\\<lambda>f2. 0 < degree f2 \\<and> degree f2 < degree f)\n     (filter (\\<lambda>u. degree u \\<le> degree f div 2) us) =\n    None \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d f\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "using fs_f"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d f\n  fs = [f]\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "by simp"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma LLL_factorization:\n  assumes res: \"LLL_factorization f = gs\"\n  and sff: \"square_free f\"\n  and deg: \"degree f \\<noteq> 0\" \n  shows \"f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "let ?lc = \"lead_coeff f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define p where \"p \\<equiv> suitable_prime_bz f\""], ["proof (state)\nthis:\n  p \\<equiv> suitable_prime_bz f\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "obtain c gs where fff: \"finite_field_factorization_int p f = (c,gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c gs.\n        finite_field_factorization_int p f = (c, gs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  finite_field_factorization_int p f = (c, gs)\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "let ?degs = \"map degree gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res = res[unfolded LLL_factorization_def Let_def, folded p_def,\n    unfolded fff split, folded]"], ["proof (state)\nthis:\n  LLL_implementation.LLL_reconstruction p\n   (p ^\n    find_exponent p\n     (sqrt_int_ceiling\n       (2 ^ (5 * (degree f - 1) * (degree f - 1)) *\n        \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f - 1)))))\n   f (hensel_lifting p\n       (find_exponent p\n         (sqrt_int_ceiling\n           (2 ^ (5 * (degree f - 1) * (degree f - 1)) *\n            \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f - 1)))))\n       f gs) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from suitable_prime_bz[OF sff refl]"], ["proof (chain)\npicking this:\n  prime (suitable_prime_bz f)\n  comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f)\n  poly_mod.square_free_m (suitable_prime_bz f) f", "have prime: \"prime p\" and cop: \"coprime ?lc p\" and sf: \"poly_mod.square_free_m p f\""], ["proof (prove)\nusing this:\n  prime (suitable_prime_bz f)\n  comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f)\n  poly_mod.square_free_m (suitable_prime_bz f) f\n\ngoal (1 subgoal):\n 1. prime p &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) p &&&\n    poly_mod.square_free_m p f", "unfolding p_def"], ["proof (prove)\nusing this:\n  prime (suitable_prime_bz f)\n  comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f)\n  poly_mod.square_free_m (suitable_prime_bz f) f\n\ngoal (1 subgoal):\n 1. prime (suitable_prime_bz f) &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f) &&&\n    poly_mod.square_free_m (suitable_prime_bz f) f", "by auto"], ["proof (state)\nthis:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  poly_mod.square_free_m p f\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res"], ["proof (state)\nthis:\n  LLL_implementation.LLL_reconstruction p\n   (p ^\n    find_exponent p\n     (sqrt_int_ceiling\n       (2 ^ (5 * (degree f - 1) * (degree f - 1)) *\n        \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f - 1)))))\n   f (hensel_lifting p\n       (find_exponent p\n         (sqrt_int_ceiling\n           (2 ^ (5 * (degree f - 1) * (degree f - 1)) *\n            \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f - 1)))))\n       f gs) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from prime"], ["proof (chain)\npicking this:\n  prime p", "interpret p: poly_mod_prime p"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define K where \"K = 2^(5 * (degree f - 1) * (degree f - 1)) * \\<parallel>f\\<parallel>\\<^sup>2^(2 * (degree f - 1))\""], ["proof (state)\nthis:\n  K =\n  2 ^ (5 * (degree f - 1) * (degree f - 1)) *\n  \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f - 1))\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define N where \"N = sqrt_int_ceiling K\""], ["proof (state)\nthis:\n  N = sqrt_int_ceiling K\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "have K0: \"K \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> K", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 ^ (5 * (degree f - 1) * (degree f - 1)) *\n            \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f - 1))", "by fastforce"], ["proof (state)\nthis:\n  0 \\<le> K\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "have N0: \"N \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> N", "unfolding N_def sqrt_int_ceiling"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lceil>sqrt (real_of_int K)\\<rceil>", "using K0"], ["proof (prove)\nusing this:\n  0 \\<le> K\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lceil>sqrt (real_of_int K)\\<rceil>", "by (smt of_int_nonneg real_sqrt_ge_0_iff zero_le_ceiling)"], ["proof (state)\nthis:\n  0 \\<le> N\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define n where \"n = find_exponent p N\""], ["proof (state)\nthis:\n  n = find_exponent p N\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res = res[folded n_def[unfolded N_def K_def]]"], ["proof (state)\nthis:\n  LLL_implementation.LLL_reconstruction p (p ^ n) f\n   (hensel_lifting p n f gs) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note n = find_exponent[OF p.m1, of N, folded n_def]"], ["proof (state)\nthis:\n  N < p ^ n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note bh = p.berlekamp_and_hensel_separated(1)[OF cop sf refl fff n(2)]"], ["proof (state)\nthis:\n  berlekamp_hensel p n f = hensel_lifting p n f gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from deg"], ["proof (chain)\npicking this:\n  degree f \\<noteq> 0", "have f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from n p.m1"], ["proof (chain)\npicking this:\n  N < p ^ n\n  n \\<noteq> 0\n  1 < p", "have pn1: \"p ^ n > 1\""], ["proof (prove)\nusing this:\n  N < p ^ n\n  n \\<noteq> 0\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "by auto"], ["proof (state)\nthis:\n  1 < p ^ n\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res = res[folded bh(1)]"], ["proof (state)\nthis:\n  LLL_implementation.LLL_reconstruction p (p ^ n) f\n   (berlekamp_hensel p n f) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note * = p.berlekamp_hensel_unique[OF cop sf bh n(2)]"], ["proof (state)\nthis:\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note ** = p.berlekamp_hensel_main[OF n(2) bh cop sf fff]"], ["proof (state)\nthis:\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from res * **"], ["proof (chain)\npicking this:\n  LLL_implementation.LLL_reconstruction p (p ^ n) f\n   (berlekamp_hensel p n f) =\n  gs\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g", "have uf: \"poly_mod.unique_factorization_m (p ^ n) f (lead_coeff f, mset (berlekamp_hensel p n f))\" \n    and norm: \"\\<And>ui. ui \\<in> set (berlekamp_hensel p n f) \\<Longrightarrow> poly_mod.Mp (p ^ n) ui = ui\""], ["proof (prove)\nusing this:\n  LLL_implementation.LLL_reconstruction p (p ^ n) f\n   (berlekamp_hensel p n f) =\n  gs\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g\n\ngoal (1 subgoal):\n 1. poly_mod.unique_factorization_m (p ^ n) f\n     (lead_coeff f, mset (berlekamp_hensel p n f)) &&&\n    (\\<And>ui.\n        ui \\<in> set (berlekamp_hensel p n f) \\<Longrightarrow>\n        poly_mod.Mp (p ^ n) ui = ui)", "unfolding berlekamp_hensel_def fff split"], ["proof (prove)\nusing this:\n  LLL_implementation.LLL_reconstruction p (p ^ n) f\n   (hensel_lifting p n f gs) =\n  gs\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g\n\ngoal (1 subgoal):\n 1. poly_mod.unique_factorization_m (p ^ n) f\n     (lead_coeff f, mset (hensel_lifting p n f gs)) &&&\n    (\\<And>ui.\n        ui \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n        poly_mod.Mp (p ^ n) ui = ui)", "by auto"], ["proof (state)\nthis:\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (berlekamp_hensel p n f))\n  ?ui1 \\<in> set (berlekamp_hensel p n f) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "have K: \"K < (p ^ n)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K < (p ^ n)\\<^sup>2", "using n sqrt_int_ceiling_bound[OF K0]"], ["proof (prove)\nusing this:\n  N < p ^ n\n  n \\<noteq> 0\n  K \\<le> (sqrt_int_ceiling K)\\<^sup>2\n\ngoal (1 subgoal):\n 1. K < (p ^ n)\\<^sup>2", "by (smt N0 N_def n(1) power2_le_imp_le)"], ["proof (state)\nthis:\n  K < (p ^ n)\\<^sup>2\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "by (rule LLL_implementation.LLL_reconstruction[OF res deg uf dvd_refl norm f0 cop sf pn1 \n          refl prime K[unfolded K_def]])"], ["proof (state)\nthis:\n  f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_many_factorization:\n  assumes res: \"LLL_many_factorization f = gs\"\n  and sff: \"square_free f\"\n  and deg: \"degree f \\<noteq> 0\" \n  shows \"f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "let ?lc = \"lead_coeff f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define p where \"p \\<equiv> suitable_prime_bz f\""], ["proof (state)\nthis:\n  p \\<equiv> suitable_prime_bz f\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "obtain c gs where fff: \"finite_field_factorization_int p f = (c,gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c gs.\n        finite_field_factorization_int p f = (c, gs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  finite_field_factorization_int p f = (c, gs)\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "let ?degs = \"map degree gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res = res[unfolded LLL_many_factorization_def Let_def, folded p_def,\n    unfolded fff split, folded]"], ["proof (state)\nthis:\n  LLL_implementation.LLL_many_reconstruction p\n   (p ^\n    find_exponent p\n     (sqrt_int_ceiling\n       (2 ^ (5 * (degree f div 2) * (degree f div 2)) *\n        \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f div 2)))))\n   f (hensel_lifting p\n       (find_exponent p\n         (sqrt_int_ceiling\n           (2 ^ (5 * (degree f div 2) * (degree f div 2)) *\n            \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f div 2)))))\n       f gs) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from suitable_prime_bz[OF sff refl]"], ["proof (chain)\npicking this:\n  prime (suitable_prime_bz f)\n  comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f)\n  poly_mod.square_free_m (suitable_prime_bz f) f", "have prime: \"prime p\" and cop: \"coprime ?lc p\" and sf: \"poly_mod.square_free_m p f\""], ["proof (prove)\nusing this:\n  prime (suitable_prime_bz f)\n  comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f)\n  poly_mod.square_free_m (suitable_prime_bz f) f\n\ngoal (1 subgoal):\n 1. prime p &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) p &&&\n    poly_mod.square_free_m p f", "unfolding p_def"], ["proof (prove)\nusing this:\n  prime (suitable_prime_bz f)\n  comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f)\n  poly_mod.square_free_m (suitable_prime_bz f) f\n\ngoal (1 subgoal):\n 1. prime (suitable_prime_bz f) &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) (suitable_prime_bz f) &&&\n    poly_mod.square_free_m (suitable_prime_bz f) f", "by auto"], ["proof (state)\nthis:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  poly_mod.square_free_m p f\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res"], ["proof (state)\nthis:\n  LLL_implementation.LLL_many_reconstruction p\n   (p ^\n    find_exponent p\n     (sqrt_int_ceiling\n       (2 ^ (5 * (degree f div 2) * (degree f div 2)) *\n        \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f div 2)))))\n   f (hensel_lifting p\n       (find_exponent p\n         (sqrt_int_ceiling\n           (2 ^ (5 * (degree f div 2) * (degree f div 2)) *\n            \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f div 2)))))\n       f gs) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from prime"], ["proof (chain)\npicking this:\n  prime p", "interpret p: poly_mod_prime p"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define K where \"K = 2^(5 * (degree f div 2) * (degree f div 2)) * \\<parallel>f\\<parallel>\\<^sup>2^(2 * (degree f div 2))\""], ["proof (state)\nthis:\n  K =\n  2 ^ (5 * (degree f div 2) * (degree f div 2)) *\n  \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f div 2))\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define N where \"N = sqrt_int_ceiling K\""], ["proof (state)\nthis:\n  N = sqrt_int_ceiling K\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "have K0: \"K \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> K", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 ^ (5 * (degree f div 2) * (degree f div 2)) *\n            \\<parallel>f\\<parallel>\\<^sup>2 ^ (2 * (degree f div 2))", "by fastforce"], ["proof (state)\nthis:\n  0 \\<le> K\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "have N0: \"N \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> N", "unfolding N_def sqrt_int_ceiling"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lceil>sqrt (real_of_int K)\\<rceil>", "using K0"], ["proof (prove)\nusing this:\n  0 \\<le> K\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lceil>sqrt (real_of_int K)\\<rceil>", "by (smt of_int_nonneg real_sqrt_ge_0_iff zero_le_ceiling)"], ["proof (state)\nthis:\n  0 \\<le> N\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "define n where \"n = find_exponent p N\""], ["proof (state)\nthis:\n  n = find_exponent p N\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res = res[folded n_def[unfolded N_def K_def]]"], ["proof (state)\nthis:\n  LLL_implementation.LLL_many_reconstruction p (p ^ n) f\n   (hensel_lifting p n f gs) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note n = find_exponent[OF p.m1, of N, folded n_def]"], ["proof (state)\nthis:\n  N < p ^ n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note bh = p.berlekamp_and_hensel_separated(1)[OF cop sf refl fff n(2)]"], ["proof (state)\nthis:\n  berlekamp_hensel p n f = hensel_lifting p n f gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from deg"], ["proof (chain)\npicking this:\n  degree f \\<noteq> 0", "have f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from n p.m1"], ["proof (chain)\npicking this:\n  N < p ^ n\n  n \\<noteq> 0\n  1 < p", "have pn1: \"p ^ n > 1\""], ["proof (prove)\nusing this:\n  N < p ^ n\n  n \\<noteq> 0\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "by auto"], ["proof (state)\nthis:\n  1 < p ^ n\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note res = res[folded bh(1)]"], ["proof (state)\nthis:\n  LLL_implementation.LLL_many_reconstruction p (p ^ n) f\n   (berlekamp_hensel p n f) =\n  gs\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note * = p.berlekamp_hensel_unique[OF cop sf bh n(2)]"], ["proof (state)\nthis:\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "note ** = p.berlekamp_hensel_main[OF n(2) bh cop sf fff]"], ["proof (state)\nthis:\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "from res * **"], ["proof (chain)\npicking this:\n  LLL_implementation.LLL_many_reconstruction p (p ^ n) f\n   (berlekamp_hensel p n f) =\n  gs\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g", "have uf: \"poly_mod.unique_factorization_m (p ^ n) f (lead_coeff f, mset (berlekamp_hensel p n f))\" \n    and norm: \"\\<And>ui. ui \\<in> set (berlekamp_hensel p n f) \\<Longrightarrow> poly_mod.Mp (p ^ n) ui = ui\""], ["proof (prove)\nusing this:\n  LLL_implementation.LLL_many_reconstruction p (p ^ n) f\n   (berlekamp_hensel p n f) =\n  gs\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g\n\ngoal (1 subgoal):\n 1. poly_mod.unique_factorization_m (p ^ n) f\n     (lead_coeff f, mset (berlekamp_hensel p n f)) &&&\n    (\\<And>ui.\n        ui \\<in> set (berlekamp_hensel p n f) \\<Longrightarrow>\n        poly_mod.Mp (p ^ n) ui = ui)", "unfolding berlekamp_hensel_def fff split"], ["proof (prove)\nusing this:\n  LLL_implementation.LLL_many_reconstruction p (p ^ n) f\n   (hensel_lifting p n f gs) =\n  gs\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?g = ?g\n  poly_mod.factorization_m (p ^ n) f\n   (lead_coeff f, mset (hensel_lifting p n f gs))\n  sort (map degree gs) = sort (map degree (hensel_lifting p n f gs))\n  ?g \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n  monic ?g \\<and>\n  poly_mod.Mp (p ^ n) ?g = ?g \\<and>\n  p.irreducible_m ?g \\<and> p.degree_m ?g = degree ?g\n\ngoal (1 subgoal):\n 1. poly_mod.unique_factorization_m (p ^ n) f\n     (lead_coeff f, mset (hensel_lifting p n f gs)) &&&\n    (\\<And>ui.\n        ui \\<in> set (hensel_lifting p n f gs) \\<Longrightarrow>\n        poly_mod.Mp (p ^ n) ui = ui)", "by auto"], ["proof (state)\nthis:\n  poly_mod.unique_factorization_m (p ^ n) f\n   (lead_coeff f, mset (berlekamp_hensel p n f))\n  ?ui1 \\<in> set (berlekamp_hensel p n f) \\<Longrightarrow>\n  poly_mod.Mp (p ^ n) ?ui1 = ?ui1\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "have K: \"K < (p ^ n)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K < (p ^ n)\\<^sup>2", "using n sqrt_int_ceiling_bound[OF K0]"], ["proof (prove)\nusing this:\n  N < p ^ n\n  n \\<noteq> 0\n  K \\<le> (sqrt_int_ceiling K)\\<^sup>2\n\ngoal (1 subgoal):\n 1. K < (p ^ n)\\<^sup>2", "by (smt N0 N_def n(1) power2_le_imp_le)"], ["proof (state)\nthis:\n  K < (p ^ n)\\<^sup>2\n\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)", "by (rule LLL_implementation.LLL_many_reconstruction[OF res deg uf dvd_refl norm f0 cop sf pn1 \n          refl prime K[unfolded K_def]])"], ["proof (state)\nthis:\n  f = prod_list gs \\<and> (\\<forall>g\\<in>set gs. irreducible\\<^sub>d g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition one_lattice_LLL_factorization :: int_poly_factorization_algorithm\n  is LLL_factorization"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>poly list.\n       \\<lbrakk>square_free poly; 0 < degree poly;\n        LLL_factorization poly = list\\<rbrakk>\n       \\<Longrightarrow> poly = prod_list list \\<and>\n                         Ball (set list) irreducible\\<^sub>d", "using LLL_factorization"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_factorization ?f = ?gs; square_free ?f;\n   degree ?f \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?f = prod_list ?gs \\<and>\n                    (\\<forall>g\\<in>set ?gs. irreducible\\<^sub>d g)\n\ngoal (1 subgoal):\n 1. \\<And>poly list.\n       \\<lbrakk>square_free poly; 0 < degree poly;\n        LLL_factorization poly = list\\<rbrakk>\n       \\<Longrightarrow> poly = prod_list list \\<and>\n                         Ball (set list) irreducible\\<^sub>d", "by auto"], ["", "lift_definition many_lattice_LLL_factorization :: int_poly_factorization_algorithm\n  is LLL_many_factorization"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>poly list.\n       \\<lbrakk>square_free poly; 0 < degree poly;\n        LLL_many_factorization poly = list\\<rbrakk>\n       \\<Longrightarrow> poly = prod_list list \\<and>\n                         Ball (set list) irreducible\\<^sub>d", "using LLL_many_factorization"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_many_factorization ?f = ?gs; square_free ?f;\n   degree ?f \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?f = prod_list ?gs \\<and>\n                    (\\<forall>g\\<in>set ?gs. irreducible\\<^sub>d g)\n\ngoal (1 subgoal):\n 1. \\<And>poly list.\n       \\<lbrakk>square_free poly; 0 < degree poly;\n        LLL_many_factorization poly = list\\<rbrakk>\n       \\<Longrightarrow> poly = prod_list list \\<and>\n                         Ball (set list) irreducible\\<^sub>d", "by auto"], ["", "lemma LLL_factorization_primitive: assumes \"LLL_factorization f = fs\"\n  \"square_free f\" \n  \"0 < degree f\" \n  \"primitive f\" \nshows \"f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible fi \\<and> 0 < degree fi \\<and> primitive fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and>\n    (\\<forall>fi\\<in>set fs.\n        irreducible fi \\<and> 0 < degree fi \\<and> primitive fi)", "using assms(1)"], ["proof (prove)\nusing this:\n  LLL_factorization f = fs\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and>\n    (\\<forall>fi\\<in>set fs.\n        irreducible fi \\<and> 0 < degree fi \\<and> primitive fi)", "by (intro int_poly_factorization_algorithm_irreducible[of one_lattice_LLL_factorization, \n      OF _ assms(2-)], transfer, auto)"], ["", "thm factorize_int_poly[of one_lattice_LLL_factorization]"], ["", "thm factorize_int_poly[of many_lattice_LLL_factorization]"], ["", "end"]]}