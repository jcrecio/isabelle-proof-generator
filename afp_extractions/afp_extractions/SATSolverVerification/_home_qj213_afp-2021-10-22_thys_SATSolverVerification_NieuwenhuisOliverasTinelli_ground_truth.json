{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/NieuwenhuisOliverasTinelli.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma applicableDecideCharacterization:\n  fixes stateA::State\n  shows \"applicableDecide stateA decisionVars = \n  (\\<exists> l. \n        (var l) \\<in> decisionVars \\<and> \n        \\<not> l el (elements (getM stateA)) \\<and> \n        \\<not> opposite l el (elements (getM stateA))) \n  \" (is \"?lhs = ?rhs\")", "lemma applicableUnitPropagateCharacterization:\n  fixes stateA::State and F0::Formula\n  shows \"applicableUnitPropagate stateA = \n  (\\<exists> (uc::Clause) (ul::Literal). \n       uc el (getF stateA) \\<and> \n       isUnitClause uc ul (elements (getM stateA)))\n  \" (is \"?lhs = ?rhs\")", "lemma applicableBackjumpCharacterization:\n  fixes stateA::State\n  shows \"applicableBackjump stateA = \n   (\\<exists> bc bl level. \n      isUnitClause bc bl (elements (prefixToLevel level (getM stateA))) \\<and> \n      formulaEntailsClause (getF stateA) bc \\<and> \n      var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and> \n      0 \\<le> level \\<and> level < (currentLevel (getM stateA)))\" (is \"?lhs = ?rhs\")", "lemma applicableLearnCharacterization:\n  fixes stateA::State\n  shows \"applicableLearn stateA = \n    (\\<exists> c. formulaEntailsClause (getF stateA) c \\<and> \n          vars c \\<subseteq> vars (getF stateA) \\<union>  vars (elements (getM stateA)))\" (is \"?lhs = ?rhs\")", "lemma finalStateNonApplicable: \n  fixes state::State\n  shows \"isFinalState state decisionVars = \n          (\\<not> applicableDecide state decisionVars \\<and> \n           \\<not> applicableUnitPropagate state \\<and> \n           \\<not> applicableBackjump state \\<and> \n           \\<not> applicableLearn state)\"", "lemma invariantsHoldInInitialState:\n  fixes state :: State and F0 :: Formula\n  assumes \"isInitialState state F0\" \n  shows \"invariantsHoldInState state F0 decisionVars\"", "lemma transitionsPreserveInvariants: \n  fixes stateA::State and stateB::State\n  assumes \"transition stateA stateB decisionVars\" and \n  \"invariantsHoldInState stateA F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\"", "lemma invariantsHoldInValidRuns: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"(stateA, stateB) \\<in> transitionRelation decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\"", "lemma invariantsHoldInValidRunsFromInitialState:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"isInitialState state0 F0\" \n  and \"(state0, state) \\<in> transitionRelation decisionVars\"\n  shows \"invariantsHoldInState state F0 decisionVars\"", "theorem soundnessForUNSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\"\n\n  \"formulaFalse (getF state) (elements (getM state))\"\n  \"decisions (getM state) = []\"\n\n  shows \"\\<not> satisfiable F0\"", "theorem soundnessForSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\"\n\n  \"\\<not> formulaFalse (getF state) (elements (getM state))\"\n  \"vars (elements (getM state)) \\<supseteq> decisionVars\"  \n  shows \n  \"model (elements (getM state)) F0\"", "lemma trailIsDecreasedByDeciedUnitPropagateAndBackjump:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\"\n  shows \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\"", "theorem stateIsDecreasedByValidTransitions:\n  fixes stateA::State and stateB::State \n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and \"transition stateA stateB decisionVars\"\n  \"appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL\"\n  shows \"(stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\"", "lemma minimalStatesAreFinal:\n  fixes stateA::State\n  assumes *: \"\\<forall> (stateA::State) (stateB::State). appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL\" and\n  \"invariantsHoldInState state F0 decisionVars\" and \"isMinimalState state F0 decisionVars learnL\"\n  shows \"isFinalState state decisionVars\"", "lemma wfLexLessState: \n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\"\n  shows \"wf (lexLessState F0 decisionVars)\"", "lemma wfLearnLessState: \n  assumes \"wf learnL\"\n  shows \"wf (learnLessState learnL)\"", "lemma wfTerminationLess:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"finite decisionVars\" \"wf learnL\"\n  shows \"wf (terminationLess F0 decisionVars learnL)\"", "theorem wfTransitionRelation:\n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\" and\n  *: \"\\<exists> learnL::(Formula \\<times> Formula) set. \n        wf learnL \\<and> \n        (\\<forall> stateA stateB. appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL)\"\n  shows \"wf {(stateB, stateA). \n             (state0, stateA) \\<in> transitionRelation decisionVars \\<and> (transition stateA stateB decisionVars)}\"", "lemma finalNonConflictState: \n  fixes state::State and FO :: Formula\n  assumes \n  \"\\<not> applicableDecide state decisionVars\"\n  shows \"vars (elements (getM state)) \\<supseteq> decisionVars\"", "lemma finalConflictingState: \n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantImpliedLiterals (getF state) (getM state)\"\n  \"\\<not> applicableBackjump state\" and\n  \"formulaFalse (getF state) (elements (getM state))\"  \n  shows\n  \"decisions (getM state) = []\"", "lemma finalStateCharacterizationLemma:\n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantImpliedLiterals (getF state) (getM state)\"\n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableBackjump state\"\n  shows\n  \"(\\<not> formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse (getF state) (elements (getM state)) \\<and> decisions (getM state) = [])\"", "theorem finalStateCharacterization:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \n  \"(\\<not> formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse (getF state) (elements (getM state)) \\<and> decisions (getM state) = [])\"", "theorem completenessForSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"satisfiable F0\" and \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \"\\<not> formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars\"", "theorem completenessForUNSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"\\<not> satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \n  \"formulaFalse (getF state) (elements (getM state)) \\<and> decisions (getM state) = []\"", "theorem partialCorrectness: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and  \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \n  \"satisfiable F0 = (\\<not> formulaFalse (getF state) (elements (getM state)))\""], "translations": [["", "lemma applicableDecideCharacterization:\n  fixes stateA::State\n  shows \"applicableDecide stateA decisionVars = \n  (\\<exists> l. \n        (var l) \\<in> decisionVars \\<and> \n        \\<not> l el (elements (getM stateA)) \\<and> \n        \\<not> opposite l el (elements (getM stateA))) \n  \" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars =\n    (\\<exists>l.\n        var l \\<in> decisionVars \\<and>\n        \\<not> l el elements (getM stateA) \\<and>\n        \\<not> opposite l el elements (getM stateA))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)", "obtain l where \n    *: \"(var l) \\<in> decisionVars\" \"\\<not> l el (elements (getM stateA))\" \"\\<not> opposite l el (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "let ?stateB = \"stateA\\<lparr> getM := (getM stateA) @ [(l, True)] \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "from *"], ["proof (chain)\npicking this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)", "have \"appliedDecide stateA ?stateB decisionVars\""], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. appliedDecide stateA\n     (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>la.\n       var la \\<in> decisionVars \\<and>\n       \\<not> la el elements (getM stateA) \\<and>\n       \\<not> opposite la el elements (getM stateA) \\<and>\n       getF (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) =\n       getF stateA \\<and>\n       getM (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) =\n       getM stateA @ [(la, True)]", "by auto"], ["proof (state)\nthis:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "thus ?lhs"], ["proof (prove)\nusing this:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedDecide stateA state' decisionVars", "by auto"], ["proof (state)\nthis:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "assume ?lhs"], ["proof (state)\nthis:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "then"], ["proof (chain)\npicking this:\n  applicableDecide stateA decisionVars", "obtain stateB l\n    where \"(var l) \\<in> decisionVars\" \"\\<not> l el (elements (getM stateA))\"\n    \"\\<not> opposite l el (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedDecide stateA state' decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>state' l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getF state' = getF stateA \\<and>\n     getM state' = getM stateA @ [(l, True)]\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "thus ?rhs"], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "by auto"], ["proof (state)\nthis:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableUnitPropagateCharacterization:\n  fixes stateA::State and F0::Formula\n  shows \"applicableUnitPropagate stateA = \n  (\\<exists> (uc::Clause) (ul::Literal). \n       uc el (getF stateA) \\<and> \n       isUnitClause uc ul (elements (getM stateA)))\n  \" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA =\n    (\\<exists>uc ul.\n        uc el getF stateA \\<and>\n        isUnitClause uc ul (elements (getM stateA)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el getF stateA \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>uc ul.\n     uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el getF stateA \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA", "then"], ["proof (chain)\npicking this:\n  \\<exists>uc ul.\n     uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))", "obtain ul uc \n    where *: \"uc el (getF stateA)\" \"isUnitClause uc ul (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el getF stateA;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el getF stateA;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  uc el getF stateA\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el getF stateA \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA", "let ?stateB = \"stateA\\<lparr> getM := getM stateA @ [(ul, False)] \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el getF stateA \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA", "from *"], ["proof (chain)\npicking this:\n  uc el getF stateA\n  isUnitClause uc ul (elements (getM stateA))", "have \"appliedUnitPropagate stateA ?stateB\""], ["proof (prove)\nusing this:\n  uc el getF stateA\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. appliedUnitPropagate stateA\n     (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>)", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  uc el getF stateA\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>uc ula.\n       uc el getF stateA \\<and>\n       isUnitClause uc ula (elements (getM stateA)) \\<and>\n       getF (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) =\n       getF stateA \\<and>\n       getM (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) =\n       getM stateA @ [(ula, False)]", "by auto"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>)\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el getF stateA \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA", "thus ?lhs"], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>)\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedUnitPropagate stateA state'", "by auto"], ["proof (state)\nthis:\n  applicableUnitPropagate stateA\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))", "assume ?lhs"], ["proof (state)\nthis:\n  applicableUnitPropagate stateA\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))", "then"], ["proof (chain)\npicking this:\n  applicableUnitPropagate stateA", "obtain stateB uc ul\n    where \"uc el (getF stateA)\" \"isUnitClause uc ul (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableUnitPropagate stateA\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el getF stateA;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedUnitPropagate stateA state'\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el getF stateA;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>state' uc ul.\n     uc el getF stateA \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getF state' = getF stateA \\<and>\n     getM state' = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el getF stateA;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  uc el getF stateA\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))", "thus ?rhs"], ["proof (prove)\nusing this:\n  uc el getF stateA\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>uc ul.\n       uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))", "by auto"], ["proof (state)\nthis:\n  \\<exists>uc ul.\n     uc el getF stateA \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableBackjumpCharacterization:\n  fixes stateA::State\n  shows \"applicableBackjump stateA = \n   (\\<exists> bc bl level. \n      isUnitClause bc bl (elements (prefixToLevel level (getM stateA))) \\<and> \n      formulaEntailsClause (getF stateA) bc \\<and> \n      var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and> \n      0 \\<le> level \\<and> level < (currentLevel (getM stateA)))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableBackjump stateA =\n    (\\<exists>bc bl level.\n        isUnitClause bc bl\n         (elements (prefixToLevel level (getM stateA))) \\<and>\n        formulaEntailsClause (getF stateA) bc \\<and>\n        var bl\n        \\<in> vars (getF stateA) \\<union>\n              vars (elements (getM stateA)) \\<and>\n        0 \\<le> level \\<and> level < currentLevel (getM stateA))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)\n 2. \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and>\n       level < currentLevel (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and> level < currentLevel (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)\n 2. \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and>\n       level < currentLevel (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "then"], ["proof (chain)\npicking this:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and> level < currentLevel (getM stateA)", "obtain bc bl level\n    where *: \"isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\"\n     \"formulaEntailsClause (getF stateA) bc\"\n     \"var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\"\n     \"0 \\<le> level\" \"level < (currentLevel (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and> level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         0 \\<le> level; level < currentLevel (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and> level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         0 \\<le> level; level < currentLevel (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)\n 2. \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and>\n       level < currentLevel (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "let ?stateB = \"stateA\\<lparr> getM := prefixToLevel level (getM stateA) @ [(bl, False)]\\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)\n 2. \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and>\n       level < currentLevel (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "from *"], ["proof (chain)\npicking this:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  0 \\<le> level\n  level < currentLevel (getM stateA)", "have \"appliedBackjump stateA ?stateB\""], ["proof (prove)\nusing this:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. appliedBackjump stateA\n     (stateA\n      \\<lparr>getM :=\n                prefixToLevel level (getM stateA) @ [(bl, False)]\\<rparr>)", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>bc bla levela.\n       isUnitClause bc bla\n        (elements (prefixToLevel levela (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bla\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> levela \\<and>\n       levela < currentLevel (getM stateA) \\<and>\n       getF\n        (stateA\n         \\<lparr>getM :=\n                   prefixToLevel level (getM stateA) @\n                   [(bl, False)]\\<rparr>) =\n       getF stateA \\<and>\n       getM\n        (stateA\n         \\<lparr>getM :=\n                   prefixToLevel level (getM stateA) @\n                   [(bl, False)]\\<rparr>) =\n       prefixToLevel levela (getM stateA) @ [(bla, False)]", "by auto"], ["proof (state)\nthis:\n  appliedBackjump stateA\n   (stateA\n    \\<lparr>getM :=\n              prefixToLevel level (getM stateA) @ [(bl, False)]\\<rparr>)\n\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)\n 2. \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and>\n       level < currentLevel (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  appliedBackjump stateA\n   (stateA\n    \\<lparr>getM :=\n              prefixToLevel level (getM stateA) @ [(bl, False)]\\<rparr>)\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA", "unfolding applicableBackjump_def"], ["proof (prove)\nusing this:\n  appliedBackjump stateA\n   (stateA\n    \\<lparr>getM :=\n              prefixToLevel level (getM stateA) @ [(bl, False)]\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedBackjump stateA state'", "by auto"], ["proof (state)\nthis:\n  applicableBackjump stateA\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)", "assume \"?lhs\""], ["proof (state)\nthis:\n  applicableBackjump stateA\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)", "then"], ["proof (chain)\npicking this:\n  applicableBackjump stateA", "obtain stateB \n    where \"appliedBackjump stateA stateB\""], ["proof (prove)\nusing this:\n  applicableBackjump stateA\n\ngoal (1 subgoal):\n 1. (\\<And>stateB.\n        appliedBackjump stateA stateB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedBackjump stateA state'\n\ngoal (1 subgoal):\n 1. (\\<And>stateB.\n        appliedBackjump stateA stateB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)", "then"], ["proof (chain)\npicking this:\n  appliedBackjump stateA stateB", "obtain bc bl level\n    where \"isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\"\n    \"formulaEntailsClause (getF stateA) bc\"\n    \"var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\"\n    \"getF stateB = getF stateA\" \n    \"getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\"\n     \"0 \\<le> level\" \"level < (currentLevel (getM stateA))\""], ["proof (prove)\nusing this:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)];\n         0 \\<le> level; level < currentLevel (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and>\n     level < currentLevel (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)];\n         0 \\<le> level; level < currentLevel (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)", "thus \"?rhs\""], ["proof (prove)\nusing this:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM stateA))) \\<and>\n       formulaEntailsClause (getF stateA) bc \\<and>\n       var bl\n       \\<in> vars (getF stateA) \\<union>\n             vars (elements (getM stateA)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM stateA)", "by auto"], ["proof (state)\nthis:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and> level < currentLevel (getM stateA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableLearnCharacterization:\n  fixes stateA::State\n  shows \"applicableLearn stateA = \n    (\\<exists> c. formulaEntailsClause (getF stateA) c \\<and> \n          vars c \\<subseteq> vars (getF stateA) \\<union>  vars (elements (getM stateA)))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableLearn stateA =\n    (\\<exists>c.\n        formulaEntailsClause (getF stateA) c \\<and>\n        vars c\n        \\<subseteq> vars (getF stateA) \\<union>\n                    vars (elements (getM stateA)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n 2. \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union>\n                   vars (elements (getM stateA)) \\<Longrightarrow>\n    applicableLearn stateA", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n 2. \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union>\n                   vars (elements (getM stateA)) \\<Longrightarrow>\n    applicableLearn stateA", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))", "obtain c where\n  *: \"formulaEntailsClause (getF stateA) c\" \n     \"vars c \\<subseteq> vars (getF stateA) \\<union>  vars (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF stateA) c;\n         vars c\n         \\<subseteq> vars (getF stateA) \\<union>\n                     vars (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableLearn_def"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF stateA) c;\n         vars c\n         \\<subseteq> vars (getF stateA) \\<union>\n                     vars (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) c\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n 2. \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union>\n                   vars (elements (getM stateA)) \\<Longrightarrow>\n    applicableLearn stateA", "let ?stateB = \"stateA\\<lparr> getF := getF stateA @ [c]\\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n 2. \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union>\n                   vars (elements (getM stateA)) \\<Longrightarrow>\n    applicableLearn stateA", "from *"], ["proof (chain)\npicking this:\n  formulaEntailsClause (getF stateA) c\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))", "have \"appliedLearn stateA ?stateB\""], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF stateA) c\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. appliedLearn stateA (stateA\\<lparr>getF := getF stateA @ [c]\\<rparr>)", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF stateA) c\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>ca.\n       formulaEntailsClause (getF stateA) ca \\<and>\n       vars ca\n       \\<subseteq> vars (getF stateA) \\<union>\n                   vars (elements (getM stateA)) \\<and>\n       getF (stateA\\<lparr>getF := getF stateA @ [c]\\<rparr>) =\n       getF stateA @ [ca] \\<and>\n       getM (stateA\\<lparr>getF := getF stateA @ [c]\\<rparr>) = getM stateA", "by auto"], ["proof (state)\nthis:\n  appliedLearn stateA (stateA\\<lparr>getF := getF stateA @ [c]\\<rparr>)\n\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n 2. \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union>\n                   vars (elements (getM stateA)) \\<Longrightarrow>\n    applicableLearn stateA", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  appliedLearn stateA (stateA\\<lparr>getF := getF stateA @ [c]\\<rparr>)\n\ngoal (1 subgoal):\n 1. applicableLearn stateA", "unfolding applicableLearn_def"], ["proof (prove)\nusing this:\n  appliedLearn stateA (stateA\\<lparr>getF := getF stateA @ [c]\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedLearn stateA state'", "by auto"], ["proof (state)\nthis:\n  applicableLearn stateA\n\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))", "assume \"?lhs\""], ["proof (state)\nthis:\n  applicableLearn stateA\n\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))", "then"], ["proof (chain)\npicking this:\n  applicableLearn stateA", "obtain c stateB\n    where\n    \"formulaEntailsClause (getF stateA) c\"\n    \"vars c \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableLearn stateA\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF stateA) c;\n         vars c\n         \\<subseteq> vars (getF stateA) \\<union>\n                     vars (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableLearn_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedLearn stateA state'\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF stateA) c;\n         vars c\n         \\<subseteq> vars (getF stateA) \\<union>\n                     vars (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  \\<exists>state' c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union>\n                 vars (elements (getM stateA)) \\<and>\n     getF state' = getF stateA @ [c] \\<and> getM state' = getM stateA\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF stateA) c;\n         vars c\n         \\<subseteq> vars (getF stateA) \\<union>\n                     vars (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) c\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))", "thus \"?rhs\""], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF stateA) c\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       formulaEntailsClause (getF stateA) c \\<and>\n       vars c\n       \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))", "by auto"], ["proof (state)\nthis:\n  \\<exists>c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Final states are the ones where no rule is applicable.\\<close>"], ["", "lemma finalStateNonApplicable: \n  fixes state::State\n  shows \"isFinalState state decisionVars = \n          (\\<not> applicableDecide state decisionVars \\<and> \n           \\<not> applicableUnitPropagate state \\<and> \n           \\<not> applicableBackjump state \\<and> \n           \\<not> applicableLearn state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFinalState state decisionVars =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state \\<and>\n     \\<not> applicableBackjump state \\<and> \\<not> applicableLearn state)", "unfolding isFinalState_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'. transition state state' decisionVars) =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state \\<and>\n     \\<not> applicableBackjump state \\<and> \\<not> applicableLearn state)", "unfolding transition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state \\<and>\n     \\<not> applicableBackjump state \\<and> \\<not> applicableLearn state)", "unfolding applicableDecide_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     \\<not> applicableUnitPropagate state \\<and>\n     \\<not> applicableBackjump state \\<and> \\<not> applicableLearn state)", "unfolding applicableUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'. appliedUnitPropagate state state') \\<and>\n     \\<not> applicableBackjump state \\<and> \\<not> applicableLearn state)", "unfolding applicableBackjump_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'. appliedUnitPropagate state state') \\<and>\n     (\\<nexists>state'. appliedBackjump state state') \\<and>\n     \\<not> applicableLearn state)", "unfolding applicableLearn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'. appliedUnitPropagate state state') \\<and>\n     (\\<nexists>state'. appliedBackjump state state') \\<and>\n     (\\<nexists>state'. appliedLearn state state'))", "by auto"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>Invariants that are relevant for the rest of correctness proof.\\<close>"], ["", "definition\ninvariantsHoldInState :: \"State \\<Rightarrow> Formula \\<Rightarrow> Variable set \\<Rightarrow> bool\"\nwhere\n\"invariantsHoldInState state F0 decisionVars == \n    InvariantImpliedLiterals (getF state) (getM state) \\<and>\n    InvariantVarsM (getM state) F0 decisionVars \\<and>\n    InvariantVarsF (getF state) F0 decisionVars \\<and>\n    InvariantConsistent (getM state) \\<and>\n    InvariantUniq (getM state) \\<and> \n    InvariantEquivalent F0 (getF state)\n\""], ["", "text\\<open>Invariants hold in initial states.\\<close>"], ["", "lemma invariantsHoldInInitialState:\n  fixes state :: State and F0 :: Formula\n  assumes \"isInitialState state F0\" \n  shows \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using assms"], ["proof (prove)\nusing this:\n  isInitialState state F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by (auto simp add:\n  isInitialState_def \n  invariantsHoldInState_def \n  InvariantImpliedLiterals_def \n  InvariantVarsM_def\n  InvariantVarsF_def\n  InvariantConsistent_def\n  InvariantUniq_def\n  InvariantEquivalent_def equivalentFormulae_def\n)"], ["", "text\\<open>Valid transitions preserve invariants.\\<close>"], ["", "lemma transitionsPreserveInvariants: \n  fixes stateA::State and stateB::State\n  assumes \"transition stateA stateB decisionVars\" and \n  \"invariantsHoldInState stateA F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars", "have \n      \"InvariantImpliedLiterals (getF stateA) (getM stateA)\" and \n      \"InvariantVarsM (getM stateA) F0 decisionVars\" and\n      \"InvariantVarsF (getF stateA) F0 decisionVars\" and\n      \"InvariantConsistent (getM stateA)\" and\n      \"InvariantUniq (getM stateA)\" and\n      \"InvariantEquivalent F0 (getF stateA)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. (InvariantImpliedLiterals (getF stateA) (getM stateA) &&&\n     InvariantVarsM (getM stateA) F0 decisionVars &&&\n     InvariantVarsF (getF stateA) F0 decisionVars) &&&\n    InvariantConsistent (getM stateA) &&&\n    InvariantUniq (getM stateA) &&& InvariantEquivalent F0 (getF stateA)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateA) (getM stateA) \\<and>\n  InvariantVarsM (getM stateA) F0 decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and>\n  InvariantUniq (getM stateA) \\<and> InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. (InvariantImpliedLiterals (getF stateA) (getM stateA) &&&\n     InvariantVarsM (getM stateA) F0 decisionVars &&&\n     InvariantVarsF (getF stateA) F0 decisionVars) &&&\n    InvariantConsistent (getM stateA) &&&\n    InvariantUniq (getM stateA) &&& InvariantEquivalent F0 (getF stateA)", "by auto"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateA) (getM stateA)\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateA) (getM stateA)\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedDecide stateA stateB decisionVars\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars", "obtain l::Literal where\n      \"(var l) \\<in> decisionVars\"\n      \"\\<not> literalTrue l (elements (getM stateA))\"\n      \"\\<not> literalFalse l (elements (getM stateA))\"\n      \"getM stateB = getM stateA @ [(l, True)]\"\n      \"getF stateB = getF stateA\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> literalTrue l (elements (getM stateA));\n         \\<not> literalFalse l (elements (getM stateA));\n         getM stateB = getM stateA @ [(l, True)];\n         getF stateB = getF stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(l, True)]\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> literalTrue l (elements (getM stateA));\n         \\<not> literalFalse l (elements (getM stateA));\n         getM stateB = getM stateA @ [(l, True)];\n         getF stateB = getF stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n  getM stateB = getM stateA @ [(l, True)]\n  getF stateB = getF stateA\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>\\<not> literalTrue l (elements (getM stateA))\\<close> \\<open>\\<not> literalFalse l (elements (getM stateA))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))", "have *: \"var l \\<notin> vars (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars (elements (getM stateA))", "using variableDefinedImpliesLiteralDefined[of \"l\" \"elements (getM stateA)\"]"], ["proof (prove)\nusing this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n  (var l \\<in> vars (elements (getM stateA))) =\n  (literalTrue l (elements (getM stateA)) \\<or>\n   literalFalse l (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  var l \\<notin> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantImpliedLiterals (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "using \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantImpliedLiterals (getF stateA) (getM stateA)\\<close>\n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantImpliedLiteralsAfterDecide[of \"getF stateA\" \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantImpliedLiterals (getF stateA) (getM stateA)\n  InvariantUniq (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantImpliedLiterals (getF stateA) (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals (getF stateA) (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>var l \\<in> decisionVars\\<close>\n        InvariantVarsMAfterDecide[of \"getM stateA\" \"F0\" \"decisionVars\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantVarsM (getM stateA) F0 decisionVars\n  var l \\<in> decisionVars\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   var l \\<in> decisionVars;\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA\\<close>\n      \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantVarsF (getF stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantConsistentAfterDecide[of \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantConsistent (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantUniqAfterDecide[of \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantUniq (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantUniq (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using \\<open>getF stateB = getF stateA\\<close>\n      \\<open>InvariantEquivalent F0 (getF stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n    InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and> InvariantEquivalent F0 (getF stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedUnitPropagate stateA stateB\""], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedUnitPropagate stateA stateB", "obtain uc::Clause and ul::Literal where \n      \"uc el (getF stateA)\"\n      \"isUnitClause uc ul (elements (getM stateA))\"\n      \"getF stateB = getF stateA\"\n      \"getM stateB = getM stateA @ [(ul, False)]\""], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el getF stateA;\n         isUnitClause uc ul (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el getF stateA \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el getF stateA;\n         isUnitClause uc ul (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  uc el getF stateA\n  isUnitClause uc ul (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>"], ["proof (chain)\npicking this:\n  isUnitClause uc ul (elements (getM stateA))", "have \"ul el uc\""], ["proof (prove)\nusing this:\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. ul el uc", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  ul el uc \\<and>\n  \\<not> literalTrue ul (elements (getM stateA)) \\<and>\n  \\<not> literalFalse ul (elements (getM stateA)) \\<and>\n  (\\<forall>literal.\n      literal el uc \\<and> literal \\<noteq> ul \\<longrightarrow>\n      literalFalse literal (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. ul el uc", "by simp"], ["proof (state)\nthis:\n  ul el uc\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>uc el (getF stateA)\\<close>"], ["proof (chain)\npicking this:\n  uc el getF stateA", "have \"formulaEntailsClause (getF stateA) uc\""], ["proof (prove)\nusing this:\n  uc el getF stateA\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF stateA) uc", "by (simp add: formulaEntailsItsClauses)"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) uc\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantImpliedLiterals (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "using \\<open>getF stateB = getF stateA\\<close> \n        \\<open>InvariantImpliedLiterals (getF stateA) (getM stateA)\\<close> \n        \\<open>formulaEntailsClause (getF stateA) uc\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantImpliedLiteralsAfterUnitPropagate[of \"getF stateA\" \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantImpliedLiterals (getF stateA) (getM stateA)\n  formulaEntailsClause (getF stateA) uc\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantImpliedLiterals (getF stateA) (getM stateA);\n   formulaEntailsClause (getF stateA) uc;\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals (getF stateA) (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>ul el uc\\<close> \\<open>uc el (getF stateA)\\<close>"], ["proof (chain)\npicking this:\n  ul el uc\n  uc el getF stateA", "have \"ul el (getF stateA)\""], ["proof (prove)\nusing this:\n  ul el uc\n  uc el getF stateA\n\ngoal (1 subgoal):\n 1. ul el getF stateA", "by (auto simp add: literalElFormulaCharacterization)"], ["proof (state)\nthis:\n  ul el getF stateA\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "with \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  ul el getF stateA", "have \"var ul \\<in> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  ul el getF stateA\n\ngoal (1 subgoal):\n 1. var ul \\<in> vars F0 \\<union> decisionVars", "using \"formulaContainsItsLiteralsVariable\" [of \"ul\" \"getF stateA\"]"], ["proof (prove)\nusing this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  ul el getF stateA\n  ul el getF stateA \\<Longrightarrow> var ul \\<in> vars (getF stateA)\n\ngoal (1 subgoal):\n 1. var ul \\<in> vars F0 \\<union> decisionVars", "unfolding InvariantVarsF_def"], ["proof (prove)\nusing this:\n  vars (getF stateA) \\<subseteq> vars F0 \\<union> decisionVars\n  ul el getF stateA\n  ul el getF stateA \\<Longrightarrow> var ul \\<in> vars (getF stateA)\n\ngoal (1 subgoal):\n 1. var ul \\<in> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  var ul \\<in> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>var ul \\<in> vars F0 \\<union> decisionVars\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantVarsMAfterUnitPropagate[of \"getM stateA\" \"F0\" \"decisionVars\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  var ul \\<in> vars F0 \\<union> decisionVars\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   var ul \\<in> vars F0 \\<union> decisionVars;\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA\\<close>\n      \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantVarsF (getF stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantConsistentAfterUnitPropagate [of \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantUniqAfterUnitPropagate [of \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantUniq (getM stateA);\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using \\<open>getF stateB = getF stateA\\<close> \n      \\<open>InvariantEquivalent F0 (getF stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n    InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and> InvariantEquivalent F0 (getF stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedLearn stateA stateB\""], ["proof (state)\nthis:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedLearn stateA stateB", "obtain c::Clause where\n      \"formulaEntailsClause (getF stateA) c\"\n      \"vars c \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\"\n      \"getF stateB = getF stateA @ [c]\"\n      \"getM stateB = getM stateA\""], ["proof (prove)\nusing this:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF stateA) c;\n         vars c\n         \\<subseteq> vars (getF stateA) \\<union>\n                     vars (elements (getM stateA));\n         getF stateB = getF stateA @ [c]; getM stateB = getM stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union>\n                 vars (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA @ [c] \\<and> getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF stateA) c;\n         vars c\n         \\<subseteq> vars (getF stateA) \\<union>\n                     vars (elements (getM stateA));\n         getF stateB = getF stateA @ [c]; getM stateB = getM stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) c\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  getF stateB = getF stateA @ [c]\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantImpliedLiterals (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "using \n        \\<open>InvariantImpliedLiterals (getF stateA) (getM stateA)\\<close>\n        \\<open>getF stateB = getF stateA @ [c]\\<close>\n        \\<open>getM stateB = getM stateA\\<close>\n        InvariantImpliedLiteralsAfterLearn[of \"getF stateA\" \"getM stateA\" \"getF stateB\"]"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateA) (getM stateA)\n  getF stateB = getF stateA @ [c]\n  getM stateB = getM stateA\n  \\<lbrakk>InvariantImpliedLiterals (getF stateA) (getM stateA);\n   getF stateB = getF stateA @ [?C]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals (getF stateB) (getM stateA)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \n        \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>vars c \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\\<close>\n      \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars", "have \"vars c \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. vars c \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. vars c \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsF_def"], ["proof (prove)\nusing this:\n  vars c\n  \\<subseteq> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  vars (getF stateA) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. vars c \\<subseteq> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  vars c \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "hence \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\nusing this:\n  vars c \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>\n        \\<open>getF stateB = getF stateA @ [c]\\<close>"], ["proof (prove)\nusing this:\n  vars c \\<subseteq> vars F0 \\<union> decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n  getF stateB = getF stateA @ [c]\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using varsAppendFormulae [of \"getF stateA\" \"[c]\"]"], ["proof (prove)\nusing this:\n  vars c \\<subseteq> vars F0 \\<union> decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n  getF stateB = getF stateA @ [c]\n  vars (getF stateA @ [c]) = vars (getF stateA) \\<union> vars [c]\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "unfolding InvariantVarsF_def"], ["proof (prove)\nusing this:\n  vars c \\<subseteq> vars F0 \\<union> decisionVars\n  vars (getF stateA) \\<subseteq> vars F0 \\<union> decisionVars\n  getF stateB = getF stateA @ [c]\n  vars (getF stateA @ [c]) = vars (getF stateA) \\<union> vars [c]\n\ngoal (1 subgoal):\n 1. vars (getF stateB) \\<subseteq> vars F0 \\<union> decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using\n        \\<open>InvariantEquivalent F0 (getF stateA)\\<close>\n        \\<open>formulaEntailsClause (getF stateA) c\\<close>\n        \\<open>getF stateB = getF stateA @ [c]\\<close>\n        InvariantEquivalentAfterLearn[of \"F0\" \"getF stateA\" \"c\" \"getF stateB\"]"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 (getF stateA)\n  formulaEntailsClause (getF stateA) c\n  getF stateB = getF stateA @ [c]\n  \\<lbrakk>InvariantEquivalent F0 (getF stateA);\n   formulaEntailsClause (getF stateA) c;\n   getF stateB = getF stateA @ [c]\\<rbrakk>\n  \\<Longrightarrow> InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n    InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and> InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedBackjump stateA stateB\""], ["proof (state)\nthis:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedBackjump stateA stateB", "obtain bc::Clause and bl::Literal and level::nat\n      where \n      \"isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\"\n      \"formulaEntailsClause (getF stateA) bc\"\n      \"var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\"\n      \"getF stateB = getF stateA\"\n      \"getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\""], ["proof (prove)\nusing this:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB =\n         prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and>\n     level < currentLevel (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB =\n         prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel level (getM stateA)) (getM stateA)", "by (simp add:isPrefixPrefixToLevel)"], ["proof (state)\nthis:\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantImpliedLiterals (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "using \\<open>InvariantImpliedLiterals (getF stateA) (getM stateA)\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\\<close>\n        \\<open>formulaEntailsClause (getF stateA) bc\\<close>\n        \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<close>\n        InvariantImpliedLiteralsAfterBackjump[of \"getF stateA\" \"getM stateA\" \"prefixToLevel level (getM stateA)\" \"bc\" \"bl\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateA) (getM stateA)\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  \\<lbrakk>InvariantImpliedLiterals (getF stateA) (getM stateA);\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   formulaEntailsClause (getF stateA) bc;\n   isUnitClause bc bl (elements (prefixToLevel level (getM stateA)));\n   getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals (getF stateA) (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>\n      \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n      \\<open>var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\\<close>"], ["proof (chain)\npicking this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  InvariantVarsM (getM stateA) F0 decisionVars\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))", "have \"var bl \\<in> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  InvariantVarsM (getM stateA) F0 decisionVars\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. var bl \\<in> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. var bl \\<in> vars F0 \\<union> decisionVars", "unfolding InvariantVarsF_def"], ["proof (prove)\nusing this:\n  vars (getF stateA) \\<subseteq> vars F0 \\<union> decisionVars\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. var bl \\<in> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  var bl \\<in> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<close>\n        \\<open>var bl \\<in> vars F0 \\<union> decisionVars\\<close>\n        InvariantVarsMAfterBackjump[of \"getM stateA\" \"F0\" \"decisionVars\" \"prefixToLevel level (getM stateA)\" \"bl\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  var bl \\<in> vars F0 \\<union> decisionVars\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   var bl \\<in> vars F0 \\<union> decisionVars;\n   getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA\\<close>\n      \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantVarsF (getF stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<close>\n        InvariantConsistentAfterBackjump[of \"getM stateA\" \"prefixToLevel level (getM stateA)\" \"bc\" \"bl\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   isUnitClause bc bl (elements (prefixToLevel level (getM stateA)));\n   getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<close>\n        InvariantUniqAfterBackjump[of \"getM stateA\" \"prefixToLevel level (getM stateA)\" \"bc\" \"bl\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  \\<lbrakk>InvariantUniq (getM stateA);\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   isUnitClause bc bl (elements (prefixToLevel level (getM stateA)));\n   getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using\n      \\<open>InvariantEquivalent F0 (getF stateA)\\<close>\n      \\<open>getF stateB = getF stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 (getF stateA)\n  getF stateB = getF stateA\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n    InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and> InvariantEquivalent F0 (getF stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using \\<open>transition stateA stateB decisionVars\\<close>"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  transition stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedLearn stateA stateB \\<or> appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The consequence is that invariants hold in all valid runs.\\<close>"], ["", "lemma invariantsHoldInValidRuns: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"(stateA, stateB) \\<in> transitionRelation decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using assms"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using transitionsPreserveInvariants"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using rtrancl_induct[of \"stateA\" \"stateB\" \n  \"{(stateA, stateB). transition stateA stateB decisionVars}\" \"\\<lambda> x. invariantsHoldInState x F0 decisionVars\"]"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n  \\<lbrakk>(stateA, stateB)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*;\n   invariantsHoldInState stateA F0 decisionVars;\n   \\<And>y z.\n      \\<lbrakk>(stateA, y)\n               \\<in> {(stateA, stateB).\n                      transition stateA stateB decisionVars}\\<^sup>*;\n       (y, z)\n       \\<in> {(stateA, stateB). transition stateA stateB decisionVars};\n       invariantsHoldInState y F0 decisionVars\\<rbrakk>\n      \\<Longrightarrow> invariantsHoldInState z F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB)\n  \\<in> {(stateA, stateB). transition stateA stateB decisionVars}\\<^sup>*\n  \\<lbrakk>transition ?stateA ?stateB ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n  \\<lbrakk>(stateA, stateB)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*;\n   invariantsHoldInState stateA F0 decisionVars;\n   \\<And>y z.\n      \\<lbrakk>(stateA, y)\n               \\<in> {(stateA, stateB).\n                      transition stateA stateB decisionVars}\\<^sup>*;\n       (y, z)\n       \\<in> {(stateA, stateB). transition stateA stateB decisionVars};\n       invariantsHoldInState y F0 decisionVars\\<rbrakk>\n      \\<Longrightarrow> invariantsHoldInState z F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["", "lemma invariantsHoldInValidRunsFromInitialState:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"isInitialState state0 F0\" \n  and \"(state0, state) \\<in> transitionRelation decisionVars\"\n  shows \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "from \\<open>isInitialState state0 F0\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0", "have \"invariantsHoldInState state0 F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state0 F0 decisionVars", "by (simp add:invariantsHoldInInitialState)"], ["proof (state)\nthis:\n  invariantsHoldInState state0 F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "with assms"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  invariantsHoldInState state0 F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  invariantsHoldInState state0 F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRuns [of \"state0\"  \"F0\" \"decisionVars\" \"state\"]"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  invariantsHoldInState state0 F0 decisionVars\n  \\<lbrakk>invariantsHoldInState state0 F0 decisionVars;\n   (state0, state) \\<in> transitionRelation decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n In the following text we will show that there are two kinds of states:\n \\begin{enumerate}\n  \\item \\textit{UNSAT} states where @{term \"formulaFalse F0 (elements (getM state))\"}\n  and @{term \"decisions (getM state) = []\"}. \n  \\item \\textit{SAT} states where @{term \"\\<not> formulaFalse F0 (elements (getM state))\"}\n  and @{term \"vars (elements (getM state)) \\<supseteq> decisionVars\"}\n \\end{enumerate}\n  \n The soundness theorems claim that if \\textit{UNSAT} state is reached\n the formula is unsatisfiable and if \\textit{SAT} state is reached,\n the formula is satisfiable.\n\n Completeness theorems claim that every final state is either\n \\textit{UNSAT} or \\textit{SAT}. A consequence of this and soundness\n theorems, is that if formula is unsatisfiable the solver will finish\n in an \\textit{UNSAT} state, and if the formula is satisfiable the\n solver will finish in a \\textit{SAT} state.\\<close>"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Soundness\\<close>"], ["", "(******************************************************************************)\n(*----------------------------------------------------------------------------*)"], ["", "theorem soundnessForUNSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\"\n\n  \"formulaFalse (getF state) (elements (getM state))\"\n  \"decisions (getM state) = []\"\n\n  shows \"\\<not> satisfiable F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "hence \"InvariantImpliedLiterals (getF state) (getM state)\" \"InvariantEquivalent F0 (getF state)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF state) (getM state) &&&\n    InvariantEquivalent F0 (getF state)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF state) (getM state) \\<and>\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantVarsF (getF state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and>\n  InvariantUniq (getM state) \\<and> InvariantEquivalent F0 (getF state)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals (getF state) (getM state) &&&\n    InvariantEquivalent F0 (getF state)", "by auto"], ["proof (state)\nthis:\n  InvariantImpliedLiterals (getF state) (getM state)\n  InvariantEquivalent F0 (getF state)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "with \\<open>formulaFalse (getF state) (elements (getM state))\\<close>\n    \\<open>decisions (getM state) = []\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []\n  InvariantImpliedLiterals (getF state) (getM state)\n  InvariantEquivalent F0 (getF state)", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []\n  InvariantImpliedLiterals (getF state) (getM state)\n  InvariantEquivalent F0 (getF state)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "using unsatReport[of \"getF state\" \"getM state\" \"F0\"]"], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []\n  InvariantImpliedLiterals (getF state) (getM state)\n  InvariantEquivalent F0 (getF state)\n  \\<lbrakk>InvariantImpliedLiterals (getF state) (getM state);\n   InvariantEquivalent F0 (getF state); decisions (getM state) = [];\n   formulaFalse (getF state) (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem soundnessForSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\"\n\n  \"\\<not> formulaFalse (getF state) (elements (getM state))\"\n  \"vars (elements (getM state)) \\<supseteq> decisionVars\"  \n  shows \n  \"model (elements (getM state)) F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "hence \n    \"InvariantConsistent (getM state)\" \n    \"InvariantEquivalent F0 (getF state)\"\n    \"InvariantVarsF (getF state) F0 decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state) &&&\n    InvariantEquivalent F0 (getF state) &&&\n    InvariantVarsF (getF state) F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF state) (getM state) \\<and>\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantVarsF (getF state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and>\n  InvariantUniq (getM state) \\<and> InvariantEquivalent F0 (getF state)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state) &&&\n    InvariantEquivalent F0 (getF state) &&&\n    InvariantVarsF (getF state) F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "with assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "using satReport[of \"F0\" \"decisionVars\" \"getF state\" \"getM state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars;\n   InvariantVarsF (getF state) F0 decisionVars;\n   InvariantConsistent (getM state); InvariantEquivalent F0 (getF state);\n   \\<not> formulaFalse (getF state) (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "by simp"], ["proof (state)\nthis:\n  model (elements (getM state)) F0\n\ngoal:\nNo subgoals!", "qed"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>This system is terminating, but only under assumption that\nthere is no infinite derivation consisting only of applications of \nrule $Learn$. We will formalize this condition by requiring that there\nthere exists an ordering @{term learnL} on the formulae that is\nwell-founded such that the state is decreased with each application\nof the $Learn$ rule. If such ordering exists, the termination\nordering is built as a lexicographic combination of @{term lexLessRestricted} \ntrail ordering and the @{term learnL} ordering. \n\\<close>"], ["", "definition \"lexLessState F0 decisionVars == {((stateA::State), (stateB::State)). \n                       (getM stateA, getM stateB) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\""], ["", "definition \"learnLessState learnL == {((stateA::State), (stateB::State)). \n                        getM stateA = getM stateB \\<and> (getF stateA, getF stateB) \\<in> learnL}\""], ["", "definition \"terminationLess F0 decisionVars learnL == \n  {((stateA::State), (stateB::State)). \n      (stateA,stateB) \\<in> lexLessState F0 decisionVars \\<or> \n      (stateA,stateB) \\<in> learnLessState learnL}\""], ["", "text\\<open>We want to show that every valid transition decreases a state\n  with respect to the constructed termination ordering. Therefore, we\n  show that $Decide$, $UnitPropagate$ and $Backjump$ rule decrease the\n  trail with respect to the restricted trail ordering @{term\n  lexLessRestricted}.  Invariants ensure that trails are indeed uniq,\n  consistent and with finite variable sets. By assumption, $Learn$\n  rule will decrease the formula component of the state with respect\n  to the @{term learnL} ordering.\\<close>"], ["", "lemma trailIsDecreasedByDeciedUnitPropagateAndBackjump:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\"\n  shows \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\\<close>\n    \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars", "have \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using transitionsPreserveInvariants"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>appliedDecide ?stateA ?stateB ?decisionVars \\<or>\n           appliedUnitPropagate ?stateA ?stateB \\<or>\n           appliedLearn ?stateA ?stateB \\<or>\n           appliedBackjump ?stateA ?stateB;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars", "have *: \"uniq (elements (getM stateA))\" \"consistent (elements (getM stateA))\" \"vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateA) (getM stateA) \\<and>\n  InvariantVarsM (getM stateA) F0 decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and>\n  InvariantUniq (getM stateA) \\<and> InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateA) (getM stateA) \\<and>\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and>\n  InvariantUniq (getM stateA) \\<and> InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateA) (getM stateA) \\<and>\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  consistent (elements (getM stateA)) \\<and>\n  InvariantUniq (getM stateA) \\<and> InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateA) (getM stateA) \\<and>\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  consistent (elements (getM stateA)) \\<and>\n  uniq (elements (getM stateA)) \\<and> InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>invariantsHoldInState stateB F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateB F0 decisionVars", "have **: \"uniq (elements (getM stateB))\" \"consistent (elements (getM stateB))\" \"vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n  InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateB) \\<and>\n  InvariantUniq (getM stateB) \\<and> InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateB) \\<and>\n  InvariantUniq (getM stateB) \\<and> InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  consistent (elements (getM stateB)) \\<and>\n  InvariantUniq (getM stateB) \\<and> InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF stateB) (getM stateB) \\<and>\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  consistent (elements (getM stateB)) \\<and>\n  uniq (elements (getM stateB)) \\<and> InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedDecide stateA stateB decisionVars\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(l, True)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (auto simp add:lexLessAppend)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"((getM stateB), (getM stateA)) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedUnitPropagate stateA stateB\""], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el getF stateA \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (auto simp add:lexLessAppend)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "moreover"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedBackjump stateA stateB\""], ["proof (state)\nthis:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "then"], ["proof (chain)\npicking this:\n  appliedBackjump stateA stateB", "obtain bc::Clause and bl::Literal and level::nat\n      where \n      \"isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\"\n      \"formulaEntailsClause (getF stateA) bc\"\n      \"var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\"\n      \"0 \\<le> level\" \"level < currentLevel (getM stateA)\" \n      \"getF stateB = getF stateA\"\n      \"getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\""], ["proof (prove)\nusing this:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         0 \\<le> level; level < currentLevel (getM stateA);\n         getF stateB = getF stateA;\n         getM stateB =\n         prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>bc bl level.\n     isUnitClause bc bl\n      (elements (prefixToLevel level (getM stateA))) \\<and>\n     formulaEntailsClause (getF stateA) bc \\<and>\n     var bl\n     \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA)) \\<and>\n     0 \\<le> level \\<and>\n     level < currentLevel (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>bc bl level.\n        \\<lbrakk>isUnitClause bc bl\n                  (elements (prefixToLevel level (getM stateA)));\n         formulaEntailsClause (getF stateA) bc;\n         var bl\n         \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA));\n         0 \\<le> level; level < currentLevel (getM stateA);\n         getF stateB = getF stateA;\n         getM stateB =\n         prefixToLevel level (getM stateA) @ [(bl, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\\<close>"], ["proof (chain)\npicking this:\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]", "have \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n  isUnitClause bc bl (elements (prefixToLevel level (getM stateA)))\n  formulaEntailsClause (getF stateA) bc\n  var bl \\<in> vars (getF stateA) \\<union> vars (elements (getM stateA))\n  0 \\<le> level\n  level < currentLevel (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(bl, False)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (simp add:lexLessBackjump)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "using assms"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we can show that, under the assumption for $Learn$ rule,\n  every rule application decreases a state with respect to the\n  constructed termination ordering.\\<close>"], ["", "theorem stateIsDecreasedByValidTransitions:\n  fixes stateA::State and stateB::State \n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and \"transition stateA stateB decisionVars\"\n  \"appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL\"\n  shows \"(stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "assume \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "with \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "using trailIsDecreasedByDeciedUnitPropagateAndBackjump"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or> appliedBackjump stateA stateB\n  \\<lbrakk>invariantsHoldInState ?stateA ?F0.0 ?decisionVars;\n   appliedDecide ?stateA ?stateB ?decisionVars \\<or>\n   appliedUnitPropagate ?stateA ?stateB \\<or>\n   appliedBackjump ?stateA ?stateB\\<rbrakk>\n  \\<Longrightarrow> (getM ?stateB, getM ?stateA)\n                    \\<in> lexLessRestricted\n                           (vars ?F0.0 \\<union> ?decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by simp"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "hence \"(stateB, stateA) \\<in> lexLessState F0 decisionVars\""], ["proof (prove)\nusing this:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> lexLessState F0 decisionVars", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (getM stateA, getM stateB)\n           \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "hence \"(stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\""], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n           (stateA, stateB) \\<in> learnLessState learnL}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "assume \"appliedLearn stateA stateB\""], ["proof (state)\nthis:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "with \\<open>appliedLearn stateA stateB \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL\\<close>"], ["proof (chain)\npicking this:\n  appliedLearn stateA stateB \\<longrightarrow>\n  (getF stateB, getF stateA) \\<in> learnL\n  appliedLearn stateA stateB", "have \"(getF stateB, getF stateA) \\<in> learnL\""], ["proof (prove)\nusing this:\n  appliedLearn stateA stateB \\<longrightarrow>\n  (getF stateB, getF stateA) \\<in> learnL\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. (getF stateB, getF stateA) \\<in> learnL", "by simp"], ["proof (state)\nthis:\n  (getF stateB, getF stateA) \\<in> learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "moreover"], ["proof (state)\nthis:\n  (getF stateB, getF stateA) \\<in> learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "from \\<open>appliedLearn stateA stateB\\<close>"], ["proof (chain)\npicking this:\n  appliedLearn stateA stateB", "have \"(getM stateB) = (getM stateA)\""], ["proof (prove)\nusing this:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. getM stateB = getM stateA", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     formulaEntailsClause (getF stateA) c \\<and>\n     vars c\n     \\<subseteq> vars (getF stateA) \\<union>\n                 vars (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA @ [c] \\<and> getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. getM stateB = getM stateA", "by auto"], ["proof (state)\nthis:\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "ultimately"], ["proof (chain)\npicking this:\n  (getF stateB, getF stateA) \\<in> learnL\n  getM stateB = getM stateA", "have \"(stateB, stateA) \\<in> learnLessState learnL\""], ["proof (prove)\nusing this:\n  (getF stateB, getF stateA) \\<in> learnL\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> learnLessState learnL", "unfolding learnLessState_def"], ["proof (prove)\nusing this:\n  (getF stateB, getF stateA) \\<in> learnL\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           getM stateA = getM stateB \\<and>\n           (getF stateA, getF stateB) \\<in> learnL}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "hence \"(stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\""], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n           (stateA, stateB) \\<in> learnLessState learnL}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "}"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "using \\<open>transition stateA stateB decisionVars\\<close>"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n  transition stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB \\<or>\n  appliedLearn stateA stateB \\<or> appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "by auto"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The minimal states with respect to the termination ordering are\n  final i.e., no further transition rules are applicable.\\<close>"], ["", "definition \n\"isMinimalState stateMin F0 decisionVars learnL == (\\<forall> state::State. (state, stateMin) \\<notin> terminationLess F0 decisionVars learnL)\""], ["", "lemma minimalStatesAreFinal:\n  fixes stateA::State\n  assumes *: \"\\<forall> (stateA::State) (stateB::State). appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL\" and\n  \"invariantsHoldInState state F0 decisionVars\" and \"isMinimalState state F0 decisionVars learnL\"\n  shows \"isFinalState state decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> isFinalState state decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<not> isFinalState state decisionVars", "obtain state'::State \n      where \"transition state state' decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> isFinalState state decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition state state' decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isFinalState_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>state'. transition state state' decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition state state' decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transition state state' decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "with \\<open>invariantsHoldInState state F0 decisionVars\\<close> *"], ["proof (chain)\npicking this:\n  invariantsHoldInState state F0 decisionVars\n  \\<forall>stateA stateB.\n     appliedLearn stateA stateB \\<longrightarrow>\n     (getF stateB, getF stateA) \\<in> learnL\n  transition state state' decisionVars", "have \"(state', state) \\<in> terminationLess F0 decisionVars learnL\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  \\<forall>stateA stateB.\n     appliedLearn stateA stateB \\<longrightarrow>\n     (getF stateB, getF stateA) \\<in> learnL\n  transition state state' decisionVars\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars learnL", "using stateIsDecreasedByValidTransitions[of \"state\" \"F0\" \"decisionVars\" \"state'\" \"learnL\"]"], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  \\<forall>stateA stateB.\n     appliedLearn stateA stateB \\<longrightarrow>\n     (getF stateB, getF stateA) \\<in> learnL\n  transition state state' decisionVars\n  \\<lbrakk>invariantsHoldInState state F0 decisionVars;\n   transition state state' decisionVars;\n   appliedLearn state state' \\<longrightarrow>\n   (getF state', getF state) \\<in> learnL\\<rbrakk>\n  \\<Longrightarrow> (state', state)\n                    \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars learnL", "unfolding transition_def"], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  \\<forall>stateA stateB.\n     appliedLearn stateA stateB \\<longrightarrow>\n     (getF stateB, getF stateA) \\<in> learnL\n  appliedDecide state state' decisionVars \\<or>\n  appliedUnitPropagate state state' \\<or>\n  appliedLearn state state' \\<or> appliedBackjump state state'\n  \\<lbrakk>invariantsHoldInState state F0 decisionVars;\n   appliedDecide state state' decisionVars \\<or>\n   appliedUnitPropagate state state' \\<or>\n   appliedLearn state state' \\<or> appliedBackjump state state';\n   appliedLearn state state' \\<longrightarrow>\n   (getF state', getF state) \\<in> learnL\\<rbrakk>\n  \\<Longrightarrow> (state', state)\n                    \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars learnL", "by auto"], ["proof (state)\nthis:\n  (state', state) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "with \\<open>isMinimalState state F0 decisionVars learnL\\<close>"], ["proof (chain)\npicking this:\n  isMinimalState state F0 decisionVars learnL\n  (state', state) \\<in> terminationLess F0 decisionVars learnL", "have False"], ["proof (prove)\nusing this:\n  isMinimalState state F0 decisionVars learnL\n  (state', state) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. False", "unfolding isMinimalState_def"], ["proof (prove)\nusing this:\n  \\<forall>statea.\n     (statea, state) \\<notin> terminationLess F0 decisionVars learnL\n  (state', state) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "}"], ["proof (state)\nthis:\n  \\<not> isFinalState state decisionVars \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> isFinalState state decisionVars \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. isFinalState state decisionVars", "by auto"], ["proof (state)\nthis:\n  isFinalState state decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We now prove that termination ordering is well founded. We\nstart with two auxiliary lemmas.\\<close>"], ["", "lemma wfLexLessState: \n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\"\n  shows \"wf (lexLessState F0 decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (lexLessState F0 decisionVars)", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists>stateMin\\<in>Q. \\<forall>state'. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{M::LiteralTrail. \\<exists> state. state \\<in> Q \\<and> (getM state) = M}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getM state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getM state\n    \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by auto"], ["proof (state)\nthis:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>finite decisionVars\\<close>"], ["proof (chain)\npicking this:\n  finite decisionVars", "have \"finite (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  finite decisionVars\n\ngoal (1 subgoal):\n 1. finite (vars F0 \\<union> decisionVars)", "using finiteVarsFormula[of \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars\n  finite (vars F0)\n\ngoal (1 subgoal):\n 1. finite (vars F0 \\<union> decisionVars)", "by simp"], ["proof (state)\nthis:\n  finite (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "hence \"wf (lexLessRestricted (vars F0 \\<union> decisionVars))\""], ["proof (prove)\nusing this:\n  finite (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "using  wfLexLessRestricted[of \"vars F0 \\<union> decisionVars\"]"], ["proof (prove)\nusing this:\n  finite (vars F0 \\<union> decisionVars)\n  finite (vars F0 \\<union> decisionVars) \\<Longrightarrow>\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "by simp"], ["proof (state)\nthis:\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>getM state \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "obtain Mmin where \"Mmin \\<in> ?Q1\" \"\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars) \\<longrightarrow> M' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> decisionVars) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     \\<forall>x.\n        x \\<in> {M. \\<exists>state.\n                       state \\<in> Q \\<and>\n                       getM state = M} \\<longrightarrow>\n        (\\<exists>z\\<in>{M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}.\n            \\<forall>y.\n               (y, z)\n               \\<in> lexLessRestricted\n                      (vars F0 \\<union> decisionVars) \\<longrightarrow>\n               y \\<notin> {M. \\<exists>state.\n                                 state \\<in> Q \\<and>\n                                 getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getM state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> decisionVars) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     getM state\n     \\<in> {M. \\<exists>state.\n                  state \\<in> Q \\<and> getM state = M} \\<longrightarrow>\n     (\\<exists>z\\<in>{M. \\<exists>state.\n                            state \\<in> Q \\<and> getM state = M}.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            y \\<notin> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>Mmin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "obtain stateMin\n        where \"stateMin \\<in> Q\" \"(getM stateMin) = Mmin\""], ["proof (prove)\nusing this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = Mmin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin)\n       \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> lexLessState F0 decisionVars\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "hence \"(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  (state', stateMin) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  (state', stateMin)\n  \\<in> {(stateA, stateB).\n         (getM stateA, getM stateB)\n         \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by auto"], ["proof (state)\nthis:\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars) \\<longrightarrow> M' \\<notin> ?Q1\\<close>\n            \\<open>(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\\<close> \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  getM stateMin = Mmin", "have \"getM state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. getM state'\n    \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by simp"], ["proof (state)\nthis:\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin)\n          \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfLearnLessState: \n  assumes \"wf learnL\"\n  shows \"wf (learnLessState learnL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (learnLessState learnL)", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> learnLessState learnL \\<longrightarrow>\n              y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> learnLessState learnL \\<longrightarrow>\n              y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists>stateMin\\<in>Q. \\<forall>state'. (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "let ?M = \"(getM state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{f::Formula. \\<exists> state. state \\<in> Q \\<and> (getM state) = ?M \\<and> (getF state) = f}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getF state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getF state\n    \\<in> {f. \\<exists>statea.\n                 statea \\<in> Q \\<and>\n                 getM statea = getM state \\<and> getF statea = f}", "by auto"], ["proof (state)\nthis:\n  getF state\n  \\<in> {f. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getF statea = f}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>wf learnL\\<close>"], ["proof (chain)\npicking this:\n  wf learnL\n  getF state\n  \\<in> {f. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getF statea = f}", "obtain FMin where \"FMin \\<in> ?Q1\" \"\\<forall>F'. (F', FMin) \\<in> learnL \\<longrightarrow> F' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  wf learnL\n  getF state\n  \\<in> {f. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getF statea = f}\n\ngoal (1 subgoal):\n 1. (\\<And>FMin.\n        \\<lbrakk>FMin\n                 \\<in> {f. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getF statea = f};\n         \\<forall>F'.\n            (F', FMin) \\<in> learnL \\<longrightarrow>\n            F' \\<notin> {f. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getF statea = f}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y. (y, z) \\<in> learnL \\<longrightarrow> y \\<notin> Q)\n  getF state\n  \\<in> {f. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getF statea = f}\n\ngoal (1 subgoal):\n 1. (\\<And>FMin.\n        \\<lbrakk>FMin\n                 \\<in> {f. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getF statea = f};\n         \\<forall>F'.\n            (F', FMin) \\<in> learnL \\<longrightarrow>\n            F' \\<notin> {f. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getF statea = f}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>FMin.\n                \\<lbrakk>FMin\n                         \\<in> {f. \\<exists>statea.\nstatea \\<in> Q \\<and> getM statea = getM state \\<and> getF statea = f};\n                 \\<forall>F'.\n                    (F', FMin) \\<in> learnL \\<longrightarrow>\n                    F' \\<notin> {f. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and> getF statea = f}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getF state\n     \\<in> {f. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getF statea = f};\n     \\<forall>x.\n        x \\<in> {f. \\<exists>statea.\n                       statea \\<in> Q \\<and>\n                       getM statea = getM state \\<and>\n                       getF statea = f} \\<longrightarrow>\n        (\\<exists>z\\<in>{f. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getF statea = f}.\n            \\<forall>y.\n               (y, z) \\<in> learnL \\<longrightarrow>\n               y \\<notin> {f. \\<exists>statea.\n                                 statea \\<in> Q \\<and>\n                                 getM statea = getM state \\<and>\n                                 getF statea = f})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getF state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>FMin.\n                \\<lbrakk>FMin\n                         \\<in> {f. \\<exists>statea.\nstatea \\<in> Q \\<and> getM statea = getM state \\<and> getF statea = f};\n                 \\<forall>F'.\n                    (F', FMin) \\<in> learnL \\<longrightarrow>\n                    F' \\<notin> {f. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and> getF statea = f}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getF state\n     \\<in> {f. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getF statea = f};\n     getF state\n     \\<in> {f. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getF statea = f} \\<longrightarrow>\n     (\\<exists>z\\<in>{f. \\<exists>statea.\n                            statea \\<in> Q \\<and>\n                            getM statea = getM state \\<and>\n                            getF statea = f}.\n         \\<forall>y.\n            (y, z) \\<in> learnL \\<longrightarrow>\n            y \\<notin> {f. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getF statea = f})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  FMin\n  \\<in> {f. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getF statea = f}\n  \\<forall>F'.\n     (F', FMin) \\<in> learnL \\<longrightarrow>\n     F' \\<notin> {f. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and> getF statea = f}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>FMin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  FMin\n  \\<in> {f. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getF statea = f}", "obtain stateMin\n        where \"stateMin \\<in> Q\" \"(getM stateMin) = ?M\" \"getF stateMin = FMin\""], ["proof (prove)\nusing this:\n  FMin\n  \\<in> {f. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getF statea = f}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = getM state;\n         getF stateMin = FMin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = getM state\n  getF stateMin = FMin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> learnLessState learnL \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState learnL \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> learnLessState learnL\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState learnL \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = ?M\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = getM state\n  (state', stateMin) \\<in> learnLessState learnL", "have \"getM state' = getM stateMin\" \"(getF state', getF stateMin) \\<in> learnL\""], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  (state', stateMin) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. getM state' = getM stateMin &&&\n    (getF state', getF stateMin) \\<in> learnL", "unfolding learnLessState_def"], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  (state', stateMin)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         (getF stateA, getF stateB) \\<in> learnL}\n\ngoal (1 subgoal):\n 1. getM state' = getM stateMin &&&\n    (getF state', getF stateMin) \\<in> learnL", "by auto"], ["proof (state)\nthis:\n  getM state' = getM stateMin\n  (getF state', getF stateMin) \\<in> learnL\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState learnL \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>F'. (F', FMin) \\<in> learnL \\<longrightarrow> F' \\<notin> ?Q1\\<close> \n            \\<open>(getF state', getF stateMin) \\<in> learnL\\<close> \\<open>getF stateMin = FMin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>F'.\n     (F', FMin) \\<in> learnL \\<longrightarrow>\n     F' \\<notin> {f. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and> getF statea = f}\n  (getF state', getF stateMin) \\<in> learnL\n  getF stateMin = FMin", "have \"getF state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>F'.\n     (F', FMin) \\<in> learnL \\<longrightarrow>\n     F' \\<notin> {f. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and> getF statea = f}\n  (getF state', getF stateMin) \\<in> learnL\n  getF stateMin = FMin\n\ngoal (1 subgoal):\n 1. getF state'\n    \\<notin> {f. \\<exists>statea.\n                    statea \\<in> Q \\<and>\n                    getM statea = getM state \\<and> getF statea = f}", "by simp"], ["proof (state)\nthis:\n  getF state'\n  \\<notin> {f. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getF statea = f}\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState learnL \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM state' = getM stateMin\\<close> \\<open>getM stateMin = ?M\\<close>"], ["proof (chain)\npicking this:\n  getM state' = getM stateMin\n  getM stateMin = getM state\n  getF state'\n  \\<notin> {f. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getF statea = f}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM state' = getM stateMin\n  getM stateMin = getM state\n  getF state'\n  \\<notin> {f. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getF statea = f}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> learnLessState learnL \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> learnLessState learnL \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we can prove the following key lemma which shows that the\ntermination ordering is well founded.\\<close>"], ["", "lemma wfTerminationLess:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"finite decisionVars\" \"wf learnL\"\n  shows \"wf (terminationLess F0 decisionVars learnL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars learnL)", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists> stateMin \\<in> Q. \\<forall>state'. (state', stateMin) \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q::\"State set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "fix state::State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "have \"wf (lexLessState F0 decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (lexLessState F0 decisionVars)", "using wfLexLessState[of \"decisionVars\" \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars \\<Longrightarrow> wf (lexLessState F0 decisionVars)\n\ngoal (1 subgoal):\n 1. wf (lexLessState F0 decisionVars)", "using \\<open>finite decisionVars\\<close>"], ["proof (prove)\nusing this:\n  finite decisionVars \\<Longrightarrow> wf (lexLessState F0 decisionVars)\n  finite decisionVars\n\ngoal (1 subgoal):\n 1. wf (lexLessState F0 decisionVars)", "by simp"], ["proof (state)\nthis:\n  wf (lexLessState F0 decisionVars)\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q\n  wf (lexLessState F0 decisionVars)", "obtain state0\n        where \"state0 \\<in> Q\" \"\\<forall>state'. (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n  wf (lexLessState F0 decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state0.\n        \\<lbrakk>state0 \\<in> Q;\n         \\<forall>state'.\n            (state', state0)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  state \\<in> Q\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>state0.\n        \\<lbrakk>state0 \\<in> Q;\n         \\<forall>state'.\n            (state', state0)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  state0 \\<in> Q\n  \\<forall>state'.\n     (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q0 = \"{state. state \\<in> Q \\<and> (getM state) = (getM state0)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state0 \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state0 \\<in> Q", "have \"state0 \\<in> ?Q0\""], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0 \\<in> {state \\<in> Q. getM state = getM state0}", "by simp"], ["proof (state)\nthis:\n  state0 \\<in> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>wf learnL\\<close>"], ["proof (chain)\npicking this:\n  wf learnL", "have \"wf (learnLessState learnL)\""], ["proof (prove)\nusing this:\n  wf learnL\n\ngoal (1 subgoal):\n 1. wf (learnLessState learnL)", "using wfLearnLessState"], ["proof (prove)\nusing this:\n  wf learnL\n  wf ?learnL \\<Longrightarrow> wf (learnLessState ?learnL)\n\ngoal (1 subgoal):\n 1. wf (learnLessState learnL)", "by simp"], ["proof (state)\nthis:\n  wf (learnLessState learnL)\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>state0 \\<in> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  state0 \\<in> {state \\<in> Q. getM state = getM state0}\n  wf (learnLessState learnL)", "obtain state1\n        where \"state1 \\<in> ?Q0\" \"\\<forall>state'. (state', state1) \\<in> learnLessState learnL \\<longrightarrow> state' \\<notin> ?Q0\""], ["proof (prove)\nusing this:\n  state0 \\<in> {state \\<in> Q. getM state = getM state0}\n  wf (learnLessState learnL)\n\ngoal (1 subgoal):\n 1. (\\<And>state1.\n        \\<lbrakk>state1 \\<in> {state \\<in> Q. getM state = getM state0};\n         \\<forall>state'.\n            (state', state1) \\<in> learnLessState learnL \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q. getM state = getM state0}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  state0 \\<in> {state \\<in> Q. getM state = getM state0}\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> learnLessState learnL \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>state1.\n        \\<lbrakk>state1 \\<in> {state \\<in> Q. getM state = getM state0};\n         \\<forall>state'.\n            (state', state1) \\<in> learnLessState learnL \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q. getM state = getM state0}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q0\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state1.\n                \\<lbrakk>state1\n                         \\<in> {state \\<in> Q. getM state = getM state0};\n                 \\<forall>state'.\n                    (state', state1)\n                    \\<in> learnLessState learnL \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state0 \\<in> {state \\<in> Q. getM state = getM state0};\n     \\<forall>x.\n        x \\<in> {state \\<in> Q. getM state = getM state0} \\<longrightarrow>\n        (\\<exists>z\\<in>{state \\<in> Q. getM state = getM state0}.\n            \\<forall>y.\n               (y, z) \\<in> learnLessState learnL \\<longrightarrow>\n               y \\<notin> {state \\<in> Q.\n                           getM state = getM state0})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"state0\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state1.\n                \\<lbrakk>state1\n                         \\<in> {state \\<in> Q. getM state = getM state0};\n                 \\<forall>state'.\n                    (state', state1)\n                    \\<in> learnLessState learnL \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state0 \\<in> {state \\<in> Q. getM state = getM state0};\n     state0\n     \\<in> {state \\<in> Q. getM state = getM state0} \\<longrightarrow>\n     (\\<exists>z\\<in>{state \\<in> Q. getM state = getM state0}.\n         \\<forall>y.\n            (y, z) \\<in> learnLessState learnL \\<longrightarrow>\n            y \\<notin> {state \\<in> Q. getM state = getM state0})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}\n  \\<forall>state'.\n     (state', state1) \\<in> learnLessState learnL \\<longrightarrow>\n     state' \\<notin> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state1 \\<in> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}", "have \"state1 \\<in> Q\" \"getM state1 = getM state0\""], ["proof (prove)\nusing this:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. state1 \\<in> Q &&& getM state1 = getM state0", "by auto"], ["proof (state)\nthis:\n  state1 \\<in> Q\n  getM state1 = getM state0\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "let ?stateMin = state1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', ?stateMin) \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', state1)\n       \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', state1)\n       \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', state1)\n       \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', ?stateMin) \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> terminationLess F0 decisionVars learnL\""], ["proof (state)\nthis:\n  (state', state1) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "hence \n            \"(state', ?stateMin) \\<in> lexLessState F0 decisionVars \\<or>\n            (state', ?stateMin) \\<in> learnLessState learnL\""], ["proof (prove)\nusing this:\n  (state', state1) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. (state', state1) \\<in> lexLessState F0 decisionVars \\<or>\n    (state', state1) \\<in> learnLessState learnL", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (state', state1)\n  \\<in> {(stateA, stateB).\n         (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n         (stateA, stateB) \\<in> learnLessState learnL}\n\ngoal (1 subgoal):\n 1. (state', state1) \\<in> lexLessState F0 decisionVars \\<or>\n    (state', state1) \\<in> learnLessState learnL", "by auto"], ["proof (state)\nthis:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state1) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state1) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "{"], ["proof (state)\nthis:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state1) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> lexLessState F0 decisionVars\""], ["proof (state)\nthis:\n  (state', state1) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM state1 = getM state0\\<close>"], ["proof (chain)\npicking this:\n  getM state1 = getM state0\n  (state', state1) \\<in> lexLessState F0 decisionVars", "have \"(state', state0) \\<in> lexLessState F0 decisionVars\""], ["proof (prove)\nusing this:\n  getM state1 = getM state0\n  (state', state1) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state0) \\<in> lexLessState F0 decisionVars", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  getM state1 = getM state0\n  (state', state1)\n  \\<in> {(stateA, stateB).\n         (getM stateA, getM stateB)\n         \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\n\ngoal (1 subgoal):\n 1. (state', state0)\n    \\<in> {(stateA, stateB).\n           (getM stateA, getM stateB)\n           \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}", "by simp"], ["proof (state)\nthis:\n  (state', state0) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>\\<forall>state'. (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state'.\n     (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n  (state', state0) \\<in> lexLessState F0 decisionVars", "have \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  \\<forall>state'.\n     (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n  (state', state0) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "}"], ["proof (state)\nthis:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "{"], ["proof (state)\nthis:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> learnLessState learnL\""], ["proof (state)\nthis:\n  (state', state1) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>\\<forall>state'. (state', state1) \\<in> learnLessState learnL \\<longrightarrow> state' \\<notin> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state'.\n     (state', state1) \\<in> learnLessState learnL \\<longrightarrow>\n     state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  (state', state1) \\<in> learnLessState learnL", "have \"state' \\<notin> ?Q0\""], ["proof (prove)\nusing this:\n  \\<forall>state'.\n     (state', state1) \\<in> learnLessState learnL \\<longrightarrow>\n     state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  (state', state1) \\<in> learnLessState learnL\n\ngoal (1 subgoal):\n 1. state' \\<notin> {state \\<in> Q. getM state = getM state0}", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>(state', state1) \\<in> learnLessState learnL\\<close> \\<open>getM state1 = getM state0\\<close>"], ["proof (chain)\npicking this:\n  (state', state1) \\<in> learnLessState learnL\n  getM state1 = getM state0", "have \"getM state' = getM state0\""], ["proof (prove)\nusing this:\n  (state', state1) \\<in> learnLessState learnL\n  getM state1 = getM state0\n\ngoal (1 subgoal):\n 1. getM state' = getM state0", "unfolding learnLessState_def"], ["proof (prove)\nusing this:\n  (state', state1)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         (getF stateA, getF stateB) \\<in> learnL}\n  getM state1 = getM state0\n\ngoal (1 subgoal):\n 1. getM state' = getM state0", "by auto"], ["proof (state)\nthis:\n  getM state' = getM state0\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>state' \\<notin> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  getM state' = getM state0", "have \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  getM state' = getM state0\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "}"], ["proof (state)\nthis:\n  (state', state1) \\<in> learnLessState learnL \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> terminationLess F0 decisionVars learnL \\<Longrightarrow>\n    state' \\<notin> Q", "ultimately"], ["proof (chain)\npicking this:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state1) \\<in> learnLessState learnL\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n  (state', state1) \\<in> learnLessState learnL \\<Longrightarrow>\n  state' \\<notin> Q", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state1) \\<in> learnLessState learnL\n  (state', state1) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n  (state', state1) \\<in> learnLessState learnL \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', state1)\n  \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', state1)\n     \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>?stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state1 \\<in> Q\n  \\<forall>state'.\n     (state', state1)\n     \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n     state' \\<notin> Q", "have \"(\\<exists> stateMin \\<in> Q. \\<forall>state'. (state', stateMin) \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  state1 \\<in> Q\n  \\<forall>state'.\n     (state', state1)\n     \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin)\n          \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n              state' \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> terminationLess F0 decisionVars learnL \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Using the termination ordering we show that the transition\n relation is well founded on states reachable from initial state.  The\n assumption for the $Learn$ rule is neccessary.\\<close>"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem wfTransitionRelation:\n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\" and\n  *: \"\\<exists> learnL::(Formula \\<times> Formula) set. \n        wf learnL \\<and> \n        (\\<forall> stateA stateB. appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL)\"\n  shows \"wf {(stateB, stateA). \n             (state0, stateA) \\<in> transitionRelation decisionVars \\<and> (transition stateA stateB decisionVars)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "from *"], ["proof (chain)\npicking this:\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)", "obtain learnL::\"(Formula \\<times> Formula) set\"\n    where \n    \"wf learnL\" and\n    **: \"\\<forall> stateA stateB. appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL\""], ["proof (prove)\nusing this:\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)\n\ngoal (1 subgoal):\n 1. (\\<And>learnL.\n        \\<lbrakk>wf learnL;\n         \\<forall>stateA stateB.\n            appliedLearn stateA stateB \\<longrightarrow>\n            (getF stateB, getF stateA) \\<in> learnL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wf learnL\n  \\<forall>stateA stateB.\n     appliedLearn stateA stateB \\<longrightarrow>\n     (getF stateB, getF stateA) \\<in> learnL\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "let ?rel = \"{(stateB, stateA). \n                  (state0, stateA) \\<in> transitionRelation decisionVars \\<and> (transition stateA stateB decisionVars)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "let ?rel'= \"terminationLess F0 decisionVars learnL\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "have \"\\<forall>x y. (x, y) \\<in> ?rel \\<longrightarrow> (x, y) \\<in> ?rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "fix stateA::State and stateB::State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "assume \"(stateB, stateA) \\<in> ?rel\""], ["proof (state)\nthis:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "hence \"(stateB, stateA) \\<in> ?rel'\""], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "using \\<open>isInitialState state0 F0\\<close>"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "using invariantsHoldInValidRunsFromInitialState[of \"state0\" \"F0\" \"stateA\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n  isInitialState state0 F0\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, stateA) \\<in> transitionRelation decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "using stateIsDecreasedByValidTransitions[of \"stateA\" \"F0\" \"decisionVars\" \"stateB\"] **"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n  isInitialState state0 F0\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, stateA) \\<in> transitionRelation decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>invariantsHoldInState stateA F0 decisionVars;\n   transition stateA stateB decisionVars;\n   appliedLearn stateA stateB \\<longrightarrow>\n   (getF stateB, getF stateA) \\<in> ?learnL\\<rbrakk>\n  \\<Longrightarrow> (stateB, stateA)\n                    \\<in> terminationLess F0 decisionVars ?learnL\n  \\<forall>stateA stateB.\n     appliedLearn stateA stateB \\<longrightarrow>\n     (getF stateB, getF stateA) \\<in> learnL\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "}"], ["proof (state)\nthis:\n  (?stateB2, ?stateA2)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars} \\<Longrightarrow>\n  (?stateB2, ?stateA2) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?stateB2, ?stateA2)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars} \\<Longrightarrow>\n  (?stateB2, ?stateA2) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n              transition stateA stateB decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars learnL", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars learnL\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars learnL\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "have \"wf ?rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars learnL)", "using \\<open>finite decisionVars\\<close> \\<open>wf learnL\\<close>"], ["proof (prove)\nusing this:\n  finite decisionVars\n  wf learnL\n\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars learnL)", "by (rule wfTerminationLess)"], ["proof (state)\nthis:\n  wf (terminationLess F0 decisionVars learnL)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars learnL\n  wf (terminationLess F0 decisionVars learnL)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars learnL\n  wf (terminationLess F0 decisionVars learnL)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "using wellFoundedEmbed[of \"?rel\" \"?rel'\"]"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars learnL\n  wf (terminationLess F0 decisionVars learnL)\n  \\<lbrakk>\\<forall>x y.\n              (x, y)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation decisionVars \\<and>\n                     transition stateA stateB\n                      decisionVars} \\<longrightarrow>\n              (x, y) \\<in> terminationLess F0 decisionVars learnL;\n   wf (terminationLess F0 decisionVars learnL)\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (state0, stateA)\n                        \\<in> transitionRelation decisionVars \\<and>\n                        transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "by simp"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n      transition stateA stateB decisionVars}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We will now give two corollaries of the previous theorem. First\n  is a weak termination result that shows that there is a terminating\n  run from every intial state to the final one.\\<close>"], ["", "corollary \n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\" and state0 :: \"State\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\" and\n  *: \"\\<exists> learnL::(Formula \\<times> Formula) set. \n        wf learnL \\<and> \n        (\\<forall> stateA stateB. appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL)\"\n  shows \"\\<exists> state. (state0, state) \\<in> transitionRelation decisionVars \\<and> isFinalState state decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation decisionVars \\<and>\n     isFinalState state decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "let ?Q = \"{state. (state0, state) \\<in> transitionRelation decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "let ?rel = \"{(stateB, stateA). (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n                         transition stateA stateB decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "have \"state0 \\<in> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state0\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "hence \"\\<exists> state. state \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state0\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       state\n       \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}", "by auto"], ["proof (state)\nthis:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "from assms"], ["proof (chain)\npicking this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)", "have \"wf ?rel\""], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "using wfTransitionRelation[of \"decisionVars\" \"state0\" \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)\n  \\<lbrakk>finite decisionVars; isInitialState state0 F0;\n   \\<exists>learnL.\n      wf learnL \\<and>\n      (\\<forall>stateA stateB.\n          appliedLearn stateA stateB \\<longrightarrow>\n          (getF stateB, getF stateA) \\<in> learnL)\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (state0, stateA)\n                        \\<in> transitionRelation decisionVars \\<and>\n                        transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "by auto"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n      transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "hence \"\\<forall> Q. (\\<exists> x. x \\<in> Q) \\<longrightarrow> (\\<exists> stateMin \\<in> Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n      transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state.\n              (state, stateMin)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation decisionVars \\<and>\n                     transition stateA stateB\n                      decisionVars} \\<longrightarrow>\n              state \\<notin> Q)", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state.\n              (state, stateMin)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation decisionVars \\<and>\n                     transition stateA stateB\n                      decisionVars} \\<longrightarrow>\n              state \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            state \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "hence \" (\\<exists> x. x \\<in> ?Q) \\<longrightarrow> (\\<exists> stateMin \\<in> ?Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q)\""], ["proof (prove)\nusing this:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            state \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        x \\<in> {state.\n                 (state0, state)\n                 \\<in> transitionRelation decisionVars}) \\<longrightarrow>\n    (\\<exists>stateMin\n              \\<in>{state.\n                    (state0, state) \\<in> transitionRelation decisionVars}.\n        \\<forall>state.\n           (state, stateMin)\n           \\<in> {(stateB, stateA).\n                  (state0, stateA)\n                  \\<in> transitionRelation decisionVars \\<and>\n                  transition stateA stateB decisionVars} \\<longrightarrow>\n           state\n           \\<notin> {state.\n                     (state0, state) \\<in> transitionRelation decisionVars})", "by rule"], ["proof (state)\nthis:\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation decisionVars \\<and>\n                transition stateA stateB decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state) \\<in> transitionRelation decisionVars})\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "with \\<open>\\<exists> state. state \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation decisionVars \\<and>\n                transition stateA stateB decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state) \\<in> transitionRelation decisionVars})", "have \"\\<exists> stateMin \\<in> ?Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation decisionVars \\<and>\n                transition stateA stateB decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state) \\<in> transitionRelation decisionVars})\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\n             \\<in>{state.\n                   (state0, state) \\<in> transitionRelation decisionVars}.\n       \\<forall>state.\n          (state, stateMin)\n          \\<in> {(stateB, stateA).\n                 (state0, stateA)\n                 \\<in> transitionRelation decisionVars \\<and>\n                 transition stateA stateB decisionVars} \\<longrightarrow>\n          state\n          \\<notin> {state.\n                    (state0, state) \\<in> transitionRelation decisionVars}", "by simp"], ["proof (state)\nthis:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n               transition stateA stateB decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n               transition stateA stateB decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation decisionVars}", "obtain stateMin\n      where \"stateMin \\<in> ?Q\" and \"\\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n               transition stateA stateB decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin\n                 \\<in> {state.\n                        (state0, state)\n                        \\<in> transitionRelation decisionVars};\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            state\n            \\<notin> {state.\n                      (state0, state)\n                      \\<in> transitionRelation decisionVars}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "from \\<open>stateMin \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}", "have \"(state0, stateMin) \\<in> transitionRelation decisionVars\""], ["proof (prove)\nusing this:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. (state0, stateMin) \\<in> transitionRelation decisionVars", "by simp"], ["proof (state)\nthis:\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "with \\<open>\\<not> ?thesis\\<close>"], ["proof (chain)\npicking this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation decisionVars \\<and>\n     isFinalState state decisionVars\n  (state0, stateMin) \\<in> transitionRelation decisionVars", "have \"\\<not> isFinalState stateMin decisionVars\""], ["proof (prove)\nusing this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation decisionVars \\<and>\n     isFinalState state decisionVars\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> isFinalState stateMin decisionVars", "by simp"], ["proof (state)\nthis:\n  \\<not> isFinalState stateMin decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<not> isFinalState stateMin decisionVars", "obtain state'::State\n      where \"transition stateMin state' decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> isFinalState stateMin decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition stateMin state' decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isFinalState_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>state'. transition stateMin state' decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition stateMin state' decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "have \"(state', stateMin) \\<in> ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n           transition stateA stateB decisionVars}", "using \\<open>(state0, stateMin) \\<in> transitionRelation decisionVars\\<close>\n            \\<open>transition stateMin state' decisionVars\\<close>"], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n           transition stateA stateB decisionVars}", "by simp"], ["proof (state)\nthis:\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "with \\<open>\\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}", "have \"state' \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}", "by force"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "moreover"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "from \\<open>(state0, stateMin) \\<in> transitionRelation decisionVars\\<close> \\<open>transition stateMin state' decisionVars\\<close>"], ["proof (chain)\npicking this:\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n  transition stateMin state' decisionVars", "have \"state' \\<in> ?Q\""], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB decisionVars}\\<^sup>*\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*}", "using rtrancl_into_rtrancl[of \"state0\" \"stateMin\" \"{(stateA, stateB). transition stateA stateB decisionVars}\" \"state'\"]"], ["proof (prove)\nusing this:\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB decisionVars}\\<^sup>*\n  transition stateMin state' decisionVars\n  \\<lbrakk>(state0, stateMin)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*;\n   (stateMin, state')\n   \\<in> {(stateA, stateB). transition stateA stateB decisionVars}\\<rbrakk>\n  \\<Longrightarrow> (state0, state')\n                    \\<in> {(stateA, stateB).\n                           transition stateA stateB decisionVars}\\<^sup>*\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}", "have False"], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation decisionVars}\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "}"], ["proof (state)\nthis:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation decisionVars \\<and>\n     isFinalState state decisionVars \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation decisionVars \\<and>\n     isFinalState state decisionVars \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation decisionVars \\<and>\n       isFinalState state decisionVars", "by auto"], ["proof (state)\nthis:\n  \\<exists>state.\n     (state0, state) \\<in> transitionRelation decisionVars \\<and>\n     isFinalState state decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we prove the final strong termination result which states\nthat there cannot be infinite chains of transitions. If there is an\ninfinite transition chain that starts from an initial state, its\nelements would for a set that would contain initial state and for\nevery element of that set there would be another element of that set\nthat is directly reachable from it. We show that no such set exists.\\<close>"], ["", "corollary noInfiniteTransitionChains:\n  fixes F0::Formula and decisionVars::\"Variable set\"\n  assumes \"finite decisionVars\" and\n  *: \"\\<exists> learnL::(Formula \\<times> Formula) set. \n        wf learnL \\<and> \n        (\\<forall> stateA stateB. appliedLearn stateA stateB  \\<longrightarrow> (getF stateB, getF stateA) \\<in> learnL)\"\n  shows \"\\<not> (\\<exists> Q::(State set). \\<exists> state0 \\<in> Q. isInitialState state0 F0 \\<and> \n                              (\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' decisionVars))\n            )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' decisionVars))\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' decisionVars))", "obtain Q::\"State set\" and state0::\"State\"\n    where \"isInitialState state0 F0\" \"state0 \\<in> Q\"\n          \"\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' decisionVars)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' decisionVars))\n\ngoal (1 subgoal):\n 1. (\\<And>state0 Q.\n        \\<lbrakk>isInitialState state0 F0; state0 \\<in> Q;\n         \\<forall>state\\<in>Q.\n            \\<exists>state'\\<in>Q.\n               transition state state' decisionVars\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isInitialState state0 F0\n  state0 \\<in> Q\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "let ?rel = \"{(stateB, stateA). (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n                         transition stateA stateB decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "from \\<open>finite decisionVars\\<close> \\<open>isInitialState state0 F0\\<close> *"], ["proof (chain)\npicking this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)", "have \"wf ?rel\""], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "using wfTransitionRelation"], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<exists>learnL.\n     wf learnL \\<and>\n     (\\<forall>stateA stateB.\n         appliedLearn stateA stateB \\<longrightarrow>\n         (getF stateB, getF stateA) \\<in> learnL)\n  \\<lbrakk>finite ?decisionVars; isInitialState ?state0.0 ?F0.0;\n   \\<exists>learnL.\n      wf learnL \\<and>\n      (\\<forall>stateA stateB.\n          appliedLearn stateA stateB \\<longrightarrow>\n          (getF stateB, getF stateA) \\<in> learnL)\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (?state0.0, stateA)\n                        \\<in> transitionRelation ?decisionVars \\<and>\n                        transition stateA stateB ?decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n        transition stateA stateB decisionVars}", "by simp"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n      transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "hence wfmin: \"\\<forall>Q x. x \\<in> Q \\<longrightarrow>\n         (\\<exists>z\\<in>Q. \\<forall>y. (y, z) \\<in> ?rel \\<longrightarrow> y \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n      transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation decisionVars \\<and>\n                     transition stateA stateB\n                      decisionVars} \\<longrightarrow>\n              y \\<notin> Q)", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation decisionVars \\<and>\n                     transition stateA stateB\n                      decisionVars} \\<longrightarrow>\n              y \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "let ?Q = \"{state \\<in> Q. (state0, state) \\<in> transitionRelation decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "from \\<open>state0 \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state0 \\<in> Q", "have \"state0 \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state \\<in> Q.\n           (state0, state) \\<in> transitionRelation decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "with wfmin"], ["proof (chain)\npicking this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}", "obtain stateMin::State\n    where \"stateMin \\<in> ?Q\" and \"\\<forall>y. (y, stateMin) \\<in> ?rel \\<longrightarrow> y \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin\n                 \\<in> {state \\<in> Q.\n                        (state0, state)\n                        \\<in> transitionRelation decisionVars};\n         \\<forall>y.\n            (y, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation decisionVars \\<and>\n                   transition stateA stateB decisionVars} \\<longrightarrow>\n            y \\<notin> {state \\<in> Q.\n                        (state0, state)\n                        \\<in> transitionRelation decisionVars}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>stateMin.\n                \\<lbrakk>stateMin\n                         \\<in> {state \\<in> Q.\n                                (state0, state)\n                                \\<in> transitionRelation decisionVars};\n                 \\<forall>y.\n                    (y, stateMin)\n                    \\<in> {(stateB, stateA).\n                           (state0, stateA)\n                           \\<in> transitionRelation decisionVars \\<and>\n                           transition stateA stateB\n                            decisionVars} \\<longrightarrow>\n                    y \\<notin> {state \\<in> Q.\n                                (state0, state)\n                                \\<in> transitionRelation\n decisionVars}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state0\n     \\<in> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation decisionVars};\n     \\<forall>x.\n        x \\<in> {state \\<in> Q.\n                 (state0, state)\n                 \\<in> transitionRelation decisionVars} \\<longrightarrow>\n        (\\<exists>z\\<in>{state \\<in> Q.\n                         (state0, state)\n                         \\<in> transitionRelation decisionVars}.\n            \\<forall>y.\n               (y, z)\n               \\<in> {(stateB, stateA).\n                      (state0, stateA)\n                      \\<in> transitionRelation decisionVars \\<and>\n                      transition stateA stateB\n                       decisionVars} \\<longrightarrow>\n               y \\<notin> {state \\<in> Q.\n                           (state0, state)\n                           \\<in> transitionRelation decisionVars})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "from \\<open>stateMin \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}", "have \"stateMin \\<in> Q\" \"(state0, stateMin) \\<in> transitionRelation decisionVars\""], ["proof (prove)\nusing this:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. stateMin \\<in> Q &&&\n    (state0, stateMin) \\<in> transitionRelation decisionVars", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "with \\<open>\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' decisionVars)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' decisionVars\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation decisionVars", "obtain state'::State\n    where \"state' \\<in> Q\" \"transition stateMin state' decisionVars\""], ["proof (prove)\nusing this:\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' decisionVars\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        \\<lbrakk>state' \\<in> Q;\n         transition stateMin state' decisionVars\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  state' \\<in> Q\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "with \\<open>(state0, stateMin) \\<in> transitionRelation decisionVars\\<close>"], ["proof (chain)\npicking this:\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n  state' \\<in> Q\n  transition stateMin state' decisionVars", "have \"(state', stateMin) \\<in> ?rel\""], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n  state' \\<in> Q\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n           transition stateA stateB decisionVars}", "by simp"], ["proof (state)\nthis:\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "with \\<open>\\<forall>y. (y, stateMin) \\<in> ?rel \\<longrightarrow> y \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}", "have \"state' \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n            transition stateA stateB decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation decisionVars \\<and>\n         transition stateA stateB decisionVars}\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state \\<in> Q.\n              (state0, state) \\<in> transitionRelation decisionVars}", "by force"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "from \\<open>state' \\<in> Q\\<close> \\<open>(state0, stateMin) \\<in> transitionRelation decisionVars\\<close>\n    \\<open>transition stateMin state' decisionVars\\<close>"], ["proof (chain)\npicking this:\n  state' \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n  transition stateMin state' decisionVars", "have \"state' \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation decisionVars\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state) \\<in> transitionRelation decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB decisionVars}\\<^sup>*\n  transition stateMin state' decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*}", "using rtrancl_into_rtrancl[of \"state0\" \"stateMin\" \"{(stateA, stateB). transition stateA stateB decisionVars}\" \"state'\"]"], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB decisionVars}\\<^sup>*\n  transition stateMin state' decisionVars\n  \\<lbrakk>(state0, stateMin)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*;\n   (stateMin, state')\n   \\<in> {(stateA, stateB). transition stateA stateB decisionVars}\\<rbrakk>\n  \\<Longrightarrow> (state0, state')\n                    \\<in> {(stateA, stateB).\n                           transition stateA stateB decisionVars}\\<^sup>*\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "with \\<open>state' \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation decisionVars}\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}", "have False"], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation decisionVars}\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation decisionVars}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "}"], ["proof (state)\nthis:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state'\n                        decisionVars)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state'\n                        decisionVars)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q. transition state state' decisionVars)", "by force"], ["proof (state)\nthis:\n  \\<nexists>Q.\n     \\<exists>state0\\<in>Q.\n        isInitialState state0 F0 \\<and>\n        (\\<forall>state\\<in>Q.\n            \\<exists>state'\\<in>Q. transition state state' decisionVars)\n\ngoal:\nNo subgoals!", "qed"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Completeness\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>In this section we will first show that each final state is\neither \\textit{SAT} or \\textit{UNSAT} state.\\<close>"], ["", "lemma finalNonConflictState: \n  fixes state::State and FO :: Formula\n  assumes \n  \"\\<not> applicableDecide state decisionVars\"\n  shows \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "fix x :: Variable"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "let ?l = \"Pos x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "assume \"x \\<in> decisionVars\""], ["proof (state)\nthis:\n  x \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "hence \"var ?l = x\" and \"var ?l \\<in> decisionVars\" and \"var (opposite ?l) \\<in> decisionVars\""], ["proof (prove)\nusing this:\n  x \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. var (Pos x) = x &&&\n    var (Pos x) \\<in> decisionVars &&&\n    var (opposite (Pos x)) \\<in> decisionVars", "by auto"], ["proof (state)\nthis:\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "with \\<open>\\<not> applicableDecide state decisionVars\\<close>"], ["proof (chain)\npicking this:\n  \\<not> applicableDecide state decisionVars\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars", "have \"literalTrue ?l (elements (getM state)) \\<or> literalFalse ?l (elements (getM state))\""], ["proof (prove)\nusing this:\n  \\<not> applicableDecide state decisionVars\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. literalTrue (Pos x) (elements (getM state)) \\<or>\n    literalFalse (Pos x) (elements (getM state))", "unfolding applicableDecideCharacterization"], ["proof (prove)\nusing this:\n  \\<nexists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM state) \\<and>\n     \\<not> opposite l el elements (getM state)\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. literalTrue (Pos x) (elements (getM state)) \\<or>\n    literalFalse (Pos x) (elements (getM state))", "by force"], ["proof (state)\nthis:\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "with \\<open>var ?l = x\\<close>"], ["proof (chain)\npicking this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))", "show \"x \\<in> vars (elements (getM state))\""], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"?l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n  Pos x el elements (getM state) \\<Longrightarrow>\n  var (Pos x) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"opposite ?l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n  Pos x el elements (getM state) \\<Longrightarrow>\n  var (Pos x) \\<in> vars (elements (getM state))\n  opposite (Pos x) el elements (getM state) \\<Longrightarrow>\n  var (opposite (Pos x)) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finalConflictingState: \n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantImpliedLiterals (getF state) (getM state)\"\n  \"\\<not> applicableBackjump state\" and\n  \"formulaFalse (getF state) (elements (getM state))\"  \n  shows\n  \"decisions (getM state) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "from \\<open>InvariantUniq (getM state)\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq (getM state)", "have \"uniq (elements (getM state))\""], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM state))", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM state))\n\ngoal (1 subgoal):\n 1. uniq (elements (getM state))", "."], ["proof (state)\nthis:\n  uniq (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "from \\<open>InvariantConsistent (getM state)\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent (getM state)", "have \"consistent (elements (getM state))\""], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n\ngoal (1 subgoal):\n 1. consistent (elements (getM state))", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements (getM state))\n\ngoal (1 subgoal):\n 1. consistent (elements (getM state))", "."], ["proof (state)\nthis:\n  consistent (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "let ?c = \"oppositeLiteralList (decisions (getM state))\""], ["proof (state)\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  decisions (getM state) \\<noteq> []\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "hence \"?c \\<noteq> []\""], ["proof (prove)\nusing this:\n  decisions (getM state) \\<noteq> []\n\ngoal (1 subgoal):\n 1. oppositeLiteralList (decisions (getM state)) \\<noteq> []", "using oppositeLiteralListNonempty[of \"decisions (getM state)\"]"], ["proof (prove)\nusing this:\n  decisions (getM state) \\<noteq> []\n  (decisions (getM state) \\<noteq> []) =\n  (oppositeLiteralList (decisions (getM state)) \\<noteq> [])\n\ngoal (1 subgoal):\n 1. oppositeLiteralList (decisions (getM state)) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "moreover"], ["proof (state)\nthis:\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "have \"clauseFalse ?c (elements (getM state))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "fix l::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "assume \"l el ?c\""], ["proof (state)\nthis:\n  l el oppositeLiteralList (decisions (getM state))\n\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "hence \"opposite l el decisions (getM state)\""], ["proof (prove)\nusing this:\n  l el oppositeLiteralList (decisions (getM state))\n\ngoal (1 subgoal):\n 1. opposite l el decisions (getM state)", "using literalElListIffOppositeLiteralElOppositeLiteralList [of \"l\" \"?c\"]"], ["proof (prove)\nusing this:\n  l el oppositeLiteralList (decisions (getM state))\n  l el oppositeLiteralList (decisions (getM state)) =\n  opposite l el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. opposite l el decisions (getM state)", "by simp"], ["proof (state)\nthis:\n  opposite l el decisions (getM state)\n\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "hence \"literalFalse l (elements (getM state))\""], ["proof (prove)\nusing this:\n  opposite l el decisions (getM state)\n\ngoal (1 subgoal):\n 1. literalFalse l (elements (getM state))", "using markedElementsAreElements[of \"opposite l\" \"getM state\"]"], ["proof (prove)\nusing this:\n  opposite l el decisions (getM state)\n  opposite l \\<in> set (decisions (getM state)) \\<Longrightarrow>\n  opposite l \\<in> set (elements (getM state))\n\ngoal (1 subgoal):\n 1. literalFalse l (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  literalFalse l (elements (getM state))\n\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "}"], ["proof (state)\nthis:\n  ?l2 el oppositeLiteralList (decisions (getM state)) \\<Longrightarrow>\n  literalFalse ?l2 (elements (getM state))\n\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el oppositeLiteralList (decisions (getM state)) \\<Longrightarrow>\n  literalFalse ?l2 (elements (getM state))\n\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "using clauseFalseIffAllLiteralsAreFalse[of \"?c\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  ?l2 el oppositeLiteralList (decisions (getM state)) \\<Longrightarrow>\n  literalFalse ?l2 (elements (getM state))\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state)) =\n  (\\<forall>literal.\n      literal el\n      oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n      literalFalse literal (elements (getM state)))\n\ngoal (1 subgoal):\n 1. clauseFalse (oppositeLiteralList (decisions (getM state)))\n     (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "moreover"], ["proof (state)\nthis:\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "let ?l = \"getLastAssertedLiteral (oppositeLiteralList ?c) (elements (getM state))\""], ["proof (state)\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "have \"isLastAssertedLiteral ?l (oppositeLiteralList ?c) (elements (getM state))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state))", "using \\<open>InvariantUniq (getM state)\\<close>"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state))", "using getLastAssertedLiteralCharacterization[of \"?c\" \"elements (getM state)\"]\n        \\<open>?c \\<noteq> []\\<close> \\<open>clauseFalse ?c (elements (getM state))\\<close>"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  \\<lbrakk>clauseFalse (oppositeLiteralList (decisions (getM state)))\n            (elements (getM state));\n   oppositeLiteralList (decisions (getM state)) \\<noteq> [];\n   uniq (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> isLastAssertedLiteral\n                     (getLastAssertedLiteral\n                       (oppositeLiteralList\n                         (oppositeLiteralList (decisions (getM state))))\n                       (elements (getM state)))\n                     (oppositeLiteralList\n                       (oppositeLiteralList (decisions (getM state))))\n                     (elements (getM state))\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state))", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM state))\n  \\<lbrakk>clauseFalse (oppositeLiteralList (decisions (getM state)))\n            (elements (getM state));\n   oppositeLiteralList (decisions (getM state)) \\<noteq> [];\n   uniq (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> isLastAssertedLiteral\n                     (getLastAssertedLiteral\n                       (oppositeLiteralList\n                         (oppositeLiteralList (decisions (getM state))))\n                       (elements (getM state)))\n                     (oppositeLiteralList\n                       (oppositeLiteralList (decisions (getM state))))\n                     (elements (getM state))\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "moreover"], ["proof (state)\nthis:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "have \"\\<forall> l. l el ?c \\<longrightarrow> (opposite l) el (decisions (getM state))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "fix l::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "assume \"l el ?c\""], ["proof (state)\nthis:\n  l el oppositeLiteralList (decisions (getM state))\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "hence \"(opposite l) el (oppositeLiteralList ?c)\""], ["proof (prove)\nusing this:\n  l el oppositeLiteralList (decisions (getM state))\n\ngoal (1 subgoal):\n 1. opposite l el\n    oppositeLiteralList (oppositeLiteralList (decisions (getM state)))", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"?c\"]"], ["proof (prove)\nusing this:\n  l el oppositeLiteralList (decisions (getM state))\n  l el oppositeLiteralList (decisions (getM state)) =\n  opposite l el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. opposite l el\n    oppositeLiteralList (oppositeLiteralList (decisions (getM state)))", "by simp"], ["proof (state)\nthis:\n  opposite l el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "}"], ["proof (state)\nthis:\n  ?l2 el oppositeLiteralList (decisions (getM state)) \\<Longrightarrow>\n  opposite ?l2 el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el oppositeLiteralList (decisions (getM state)) \\<Longrightarrow>\n  opposite ?l2 el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n       opposite l el decisions (getM state)", "by simp"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n     opposite l el decisions (getM state)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n     opposite l el decisions (getM state)\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "ultimately"], ["proof (chain)\npicking this:\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))\n  \\<forall>l.\n     l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n     opposite l el decisions (getM state)", "have \"\\<exists> level. (isBackjumpLevel level (opposite ?l) ?c (getM state))\""], ["proof (prove)\nusing this:\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))\n  \\<forall>l.\n     l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n     opposite l el decisions (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>level.\n       isBackjumpLevel level\n        (opposite\n          (getLastAssertedLiteral\n            (oppositeLiteralList\n              (oppositeLiteralList (decisions (getM state))))\n            (elements (getM state))))\n        (oppositeLiteralList (decisions (getM state))) (getM state)", "using \\<open>uniq (elements (getM state))\\<close>"], ["proof (prove)\nusing this:\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))\n  \\<forall>l.\n     l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n     opposite l el decisions (getM state)\n  uniq (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>level.\n       isBackjumpLevel level\n        (opposite\n          (getLastAssertedLiteral\n            (oppositeLiteralList\n              (oppositeLiteralList (decisions (getM state))))\n            (elements (getM state))))\n        (oppositeLiteralList (decisions (getM state))) (getM state)", "using allDecisionsThenExistsBackjumpLevel[of \"getM state\" \"?c\" \"opposite ?l\"]"], ["proof (prove)\nusing this:\n  oppositeLiteralList (decisions (getM state)) \\<noteq> []\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))\n  \\<forall>l.\n     l el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n     opposite l el decisions (getM state)\n  uniq (elements (getM state))\n  \\<lbrakk>uniq (elements (getM state));\n   \\<forall>l'.\n      l' el oppositeLiteralList (decisions (getM state)) \\<longrightarrow>\n      opposite l' el decisions (getM state);\n   isLastAssertedLiteral\n    (opposite\n      (opposite\n        (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))))\n    (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n    (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>level.\n                       isBackjumpLevel level\n                        (opposite\n                          (getLastAssertedLiteral\n                            (oppositeLiteralList\n                              (oppositeLiteralList\n                                (decisions (getM state))))\n                            (elements (getM state))))\n                        (oppositeLiteralList (decisions (getM state)))\n                        (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>level.\n       isBackjumpLevel level\n        (opposite\n          (getLastAssertedLiteral\n            (oppositeLiteralList\n              (oppositeLiteralList (decisions (getM state))))\n            (elements (getM state))))\n        (oppositeLiteralList (decisions (getM state))) (getM state)", "by simp"], ["proof (state)\nthis:\n  \\<exists>level.\n     isBackjumpLevel level\n      (opposite\n        (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state))))\n      (oppositeLiteralList (decisions (getM state))) (getM state)\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "then"], ["proof (chain)\npicking this:\n  \\<exists>level.\n     isBackjumpLevel level\n      (opposite\n        (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state))))\n      (oppositeLiteralList (decisions (getM state))) (getM state)", "obtain level::nat\n      where \"isBackjumpLevel level (opposite ?l) ?c (getM state)\""], ["proof (prove)\nusing this:\n  \\<exists>level.\n     isBackjumpLevel level\n      (opposite\n        (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state))))\n      (oppositeLiteralList (decisions (getM state))) (getM state)\n\ngoal (1 subgoal):\n 1. (\\<And>level.\n        isBackjumpLevel level\n         (opposite\n           (getLastAssertedLiteral\n             (oppositeLiteralList\n               (oppositeLiteralList (decisions (getM state))))\n             (elements (getM state))))\n         (oppositeLiteralList (decisions (getM state)))\n         (getM state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (oppositeLiteralList (decisions (getM state))) (getM state)\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "with \\<open>consistent (elements (getM state))\\<close> \\<open>uniq (elements (getM state))\\<close> \\<open>clauseFalse ?c (elements (getM state))\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements (getM state))\n  uniq (elements (getM state))\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (oppositeLiteralList (decisions (getM state))) (getM state)", "have \"isUnitClause ?c (opposite ?l) (elements (prefixToLevel level (getM state)))\""], ["proof (prove)\nusing this:\n  consistent (elements (getM state))\n  uniq (elements (getM state))\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (oppositeLiteralList (decisions (getM state))) (getM state)\n\ngoal (1 subgoal):\n 1. isUnitClause (oppositeLiteralList (decisions (getM state)))\n     (opposite\n       (getLastAssertedLiteral\n         (oppositeLiteralList\n           (oppositeLiteralList (decisions (getM state))))\n         (elements (getM state))))\n     (elements (prefixToLevel level (getM state)))", "using isBackjumpLevelEnsuresIsUnitInPrefix[of \"getM state\" \"?c\" \"level\" \"opposite ?l\"]"], ["proof (prove)\nusing this:\n  consistent (elements (getM state))\n  uniq (elements (getM state))\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (oppositeLiteralList (decisions (getM state))) (getM state)\n  \\<lbrakk>consistent (elements (getM state)); uniq (elements (getM state));\n   clauseFalse (oppositeLiteralList (decisions (getM state)))\n    (elements (getM state));\n   isBackjumpLevel level\n    (opposite\n      (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state))))\n    (oppositeLiteralList (decisions (getM state))) (getM state)\\<rbrakk>\n  \\<Longrightarrow> isUnitClause\n                     (oppositeLiteralList (decisions (getM state)))\n                     (opposite\n                       (getLastAssertedLiteral\n                         (oppositeLiteralList\n                           (oppositeLiteralList (decisions (getM state))))\n                         (elements (getM state))))\n                     (elements (prefixToLevel level (getM state)))\n\ngoal (1 subgoal):\n 1. isUnitClause (oppositeLiteralList (decisions (getM state)))\n     (opposite\n       (getLastAssertedLiteral\n         (oppositeLiteralList\n           (oppositeLiteralList (decisions (getM state))))\n         (elements (getM state))))\n     (elements (prefixToLevel level (getM state)))", "by simp"], ["proof (state)\nthis:\n  isUnitClause (oppositeLiteralList (decisions (getM state)))\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (elements (prefixToLevel level (getM state)))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "moreover"], ["proof (state)\nthis:\n  isUnitClause (oppositeLiteralList (decisions (getM state)))\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (elements (prefixToLevel level (getM state)))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "have \"formulaEntailsClause (getF state) ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF state)\n     (oppositeLiteralList (decisions (getM state)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF state)\n     (oppositeLiteralList (decisions (getM state)))", "from \\<open>clauseFalse ?c (elements (getM state))\\<close> \\<open>consistent (elements (getM state))\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  consistent (elements (getM state))", "have \"\\<not> clauseTautology ?c\""], ["proof (prove)\nusing this:\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  consistent (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology (oppositeLiteralList (decisions (getM state)))", "using tautologyNotFalse[of \"?c\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  clauseFalse (oppositeLiteralList (decisions (getM state)))\n   (elements (getM state))\n  consistent (elements (getM state))\n  \\<lbrakk>clauseTautology (oppositeLiteralList (decisions (getM state)));\n   consistent (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> \\<not> clauseFalse\n                            (oppositeLiteralList (decisions (getM state)))\n                            (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology (oppositeLiteralList (decisions (getM state)))", "by auto"], ["proof (state)\nthis:\n  \\<not> clauseTautology (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF state)\n     (oppositeLiteralList (decisions (getM state)))", "from \\<open>formulaFalse (getF state) (elements (getM state))\\<close> \\<open>InvariantImpliedLiterals (getF state) (getM state)\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse (getF state) (elements (getM state))\n  InvariantImpliedLiterals (getF state) (getM state)", "have \"\\<not> satisfiable ((getF state) @ val2form (decisions (getM state)))\""], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n  InvariantImpliedLiterals (getF state) (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (getF state @ val2form (decisions (getM state)))", "using InvariantImpliedLiteralsAndFormulaFalseThenFormulaAndDecisionsAreNotSatisfiable"], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<lbrakk>InvariantImpliedLiterals ?F ?M;\n   formulaFalse ?F (elements ?M)\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable (?F @ val2form (decisions ?M))\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (getF state @ val2form (decisions (getM state)))", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable (getF state @ val2form (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF state)\n     (oppositeLiteralList (decisions (getM state)))", "hence \"\\<not> satisfiable ((getF state) @ val2form (oppositeLiteralList ?c))\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable (getF state @ val2form (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable\n            (getF state @\n             val2form\n              (oppositeLiteralList\n                (oppositeLiteralList (decisions (getM state)))))", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable\n          (getF state @\n           val2form\n            (oppositeLiteralList\n              (oppositeLiteralList (decisions (getM state)))))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF state)\n     (oppositeLiteralList (decisions (getM state)))", "with \\<open>\\<not> clauseTautology ?c\\<close>"], ["proof (chain)\npicking this:\n  \\<not> clauseTautology (oppositeLiteralList (decisions (getM state)))\n  \\<not> satisfiable\n          (getF state @\n           val2form\n            (oppositeLiteralList\n              (oppositeLiteralList (decisions (getM state)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> clauseTautology (oppositeLiteralList (decisions (getM state)))\n  \\<not> satisfiable\n          (getF state @\n           val2form\n            (oppositeLiteralList\n              (oppositeLiteralList (decisions (getM state)))))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF state)\n     (oppositeLiteralList (decisions (getM state)))", "using unsatisfiableFormulaWithSingleLiteralClauses"], ["proof (prove)\nusing this:\n  \\<not> clauseTautology (oppositeLiteralList (decisions (getM state)))\n  \\<not> satisfiable\n          (getF state @\n           val2form\n            (oppositeLiteralList\n              (oppositeLiteralList (decisions (getM state)))))\n  \\<lbrakk>\\<not> satisfiable (?F @ val2form (oppositeLiteralList ?c));\n   \\<not> clauseTautology ?c\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsClause ?F ?c\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF state)\n     (oppositeLiteralList (decisions (getM state)))", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause (getF state)\n   (oppositeLiteralList (decisions (getM state)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsClause (getF state)\n   (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "moreover"], ["proof (state)\nthis:\n  formulaEntailsClause (getF state)\n   (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "have \"var ?l \\<in> vars (getF state) \\<union> vars (elements (getM state))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (getF state) \\<union> vars (elements (getM state))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (getF state) \\<union> vars (elements (getM state))", "from \\<open>isLastAssertedLiteral ?l (oppositeLiteralList ?c) (elements (getM state))\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))", "have \"?l el (oppositeLiteralList ?c)\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)) el\n    oppositeLiteralList (oppositeLiteralList (decisions (getM state)))", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  getLastAssertedLiteral\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state)) el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state))) \\<and>\n  literalTrue\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (elements (getM state)) \\<and>\n  (\\<forall>literal'.\n      literal' el\n      oppositeLiteralList\n       (oppositeLiteralList (decisions (getM state))) \\<and>\n      literal' \\<noteq>\n      getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)) \\<longrightarrow>\n      \\<not> precedes\n              (getLastAssertedLiteral\n                (oppositeLiteralList\n                  (oppositeLiteralList (decisions (getM state))))\n                (elements (getM state)))\n              literal' (elements (getM state)))\n\ngoal (1 subgoal):\n 1. getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)) el\n    oppositeLiteralList (oppositeLiteralList (decisions (getM state)))", "by simp"], ["proof (state)\nthis:\n  getLastAssertedLiteral\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state)) el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (getF state) \\<union> vars (elements (getM state))", "hence \"literalTrue ?l (elements (getM state))\""], ["proof (prove)\nusing this:\n  getLastAssertedLiteral\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state)) el\n  oppositeLiteralList (oppositeLiteralList (decisions (getM state)))\n\ngoal (1 subgoal):\n 1. literalTrue\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (elements (getM state))", "by (simp add: markedElementsAreElements)"], ["proof (state)\nthis:\n  literalTrue\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (getF state) \\<union> vars (elements (getM state))", "hence \"var ?l \\<in> vars (elements (getM state))\""], ["proof (prove)\nusing this:\n  literalTrue\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"?l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  literalTrue\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (elements (getM state))\n  getLastAssertedLiteral\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state)) el\n  elements (getM state) \\<Longrightarrow>\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (getF state) \\<union> vars (elements (getM state))", "thus ?thesis"], ["proof (prove)\nusing this:\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. var (getLastAssertedLiteral\n          (oppositeLiteralList\n            (oppositeLiteralList (decisions (getM state))))\n          (elements (getM state)))\n    \\<in> vars (getF state) \\<union> vars (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (getF state) \\<union> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (getF state) \\<union> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "moreover"], ["proof (state)\nthis:\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (getF state) \\<union> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "have \"0 \\<le> level\" \"level < (currentLevel (getM state))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> level &&& level < currentLevel (getM state)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> level\n 2. level < currentLevel (getM state)", "from \\<open>isBackjumpLevel level (opposite ?l) ?c (getM state)\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (oppositeLiteralList (decisions (getM state))) (getM state)", "have \"0 \\<le> level\" \"level < (elementLevel ?l (getM state))\""], ["proof (prove)\nusing this:\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (oppositeLiteralList (decisions (getM state))) (getM state)\n\ngoal (1 subgoal):\n 1. 0 \\<le> level &&&\n    level\n    < elementLevel\n       (getLastAssertedLiteral\n         (oppositeLiteralList\n           (oppositeLiteralList (decisions (getM state))))\n         (elements (getM state)))\n       (getM state)", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (opposite\n     (opposite\n       (getLastAssertedLiteral\n         (oppositeLiteralList\n           (oppositeLiteralList (decisions (getM state))))\n         (elements (getM state)))))\n   (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n   (elements (getM state)) \\<and>\n  0 \\<le> level \\<and>\n  level\n  < elementLevel\n     (opposite\n       (opposite\n         (getLastAssertedLiteral\n           (oppositeLiteralList\n             (oppositeLiteralList (decisions (getM state))))\n           (elements (getM state)))))\n     (getM state) \\<and>\n  (\\<forall>l'.\n      l' el oppositeLiteralList (decisions (getM state)) \\<and>\n      l' \\<noteq>\n      opposite\n       (getLastAssertedLiteral\n         (oppositeLiteralList\n           (oppositeLiteralList (decisions (getM state))))\n         (elements (getM state))) \\<longrightarrow>\n      elementLevel (opposite l') (getM state) \\<le> level)\n\ngoal (1 subgoal):\n 1. 0 \\<le> level &&&\n    level\n    < elementLevel\n       (getLastAssertedLiteral\n         (oppositeLiteralList\n           (oppositeLiteralList (decisions (getM state))))\n         (elements (getM state)))\n       (getM state)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> level\n  level\n  < elementLevel\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (getM state)\n\ngoal (2 subgoals):\n 1. 0 \\<le> level\n 2. level < currentLevel (getM state)", "thus \"0 \\<le> level\" \"level < (currentLevel (getM state))\""], ["proof (prove)\nusing this:\n  0 \\<le> level\n  level\n  < elementLevel\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (getM state)\n\ngoal (1 subgoal):\n 1. 0 \\<le> level &&& level < currentLevel (getM state)", "using elementLevelLeqCurrentLevel[of \"?l\" \"getM state\"]"], ["proof (prove)\nusing this:\n  0 \\<le> level\n  level\n  < elementLevel\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state)))\n     (getM state)\n  elementLevel\n   (getLastAssertedLiteral\n     (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n     (elements (getM state)))\n   (getM state)\n  \\<le> currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. 0 \\<le> level &&& level < currentLevel (getM state)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> level\n  level < currentLevel (getM state)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> level\n  level < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "ultimately"], ["proof (chain)\npicking this:\n  isUnitClause (oppositeLiteralList (decisions (getM state)))\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (elements (prefixToLevel level (getM state)))\n  formulaEntailsClause (getF state)\n   (oppositeLiteralList (decisions (getM state)))\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (getF state) \\<union> vars (elements (getM state))\n  0 \\<le> level\n  level < currentLevel (getM state)", "have \"applicableBackjump state\""], ["proof (prove)\nusing this:\n  isUnitClause (oppositeLiteralList (decisions (getM state)))\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (elements (prefixToLevel level (getM state)))\n  formulaEntailsClause (getF state)\n   (oppositeLiteralList (decisions (getM state)))\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (getF state) \\<union> vars (elements (getM state))\n  0 \\<le> level\n  level < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. applicableBackjump state", "unfolding applicableBackjumpCharacterization"], ["proof (prove)\nusing this:\n  isUnitClause (oppositeLiteralList (decisions (getM state)))\n   (opposite\n     (getLastAssertedLiteral\n       (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n       (elements (getM state))))\n   (elements (prefixToLevel level (getM state)))\n  formulaEntailsClause (getF state)\n   (oppositeLiteralList (decisions (getM state)))\n  var (getLastAssertedLiteral\n        (oppositeLiteralList (oppositeLiteralList (decisions (getM state))))\n        (elements (getM state)))\n  \\<in> vars (getF state) \\<union> vars (elements (getM state))\n  0 \\<le> level\n  level < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>bc bl level.\n       isUnitClause bc bl\n        (elements (prefixToLevel level (getM state))) \\<and>\n       formulaEntailsClause (getF state) bc \\<and>\n       var bl\n       \\<in> vars (getF state) \\<union> vars (elements (getM state)) \\<and>\n       0 \\<le> level \\<and> level < currentLevel (getM state)", "by force"], ["proof (state)\nthis:\n  applicableBackjump state\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "with \\<open>\\<not> applicableBackjump state\\<close>"], ["proof (chain)\npicking this:\n  \\<not> applicableBackjump state\n  applicableBackjump state", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> applicableBackjump state\n  applicableBackjump state\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "}"], ["proof (state)\nthis:\n  decisions (getM state) \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  decisions (getM state) \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  decisions (getM state) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finalStateCharacterizationLemma:\n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantImpliedLiterals (getF state) (getM state)\"\n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableBackjump state\"\n  shows\n  \"(\\<not> formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse (getF state) (elements (getM state)) \\<and> decisions (getM state) = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "proof (cases \"formulaFalse (getF state) (elements (getM state))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []\n 2. \\<not> formulaFalse (getF state)\n            (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "case True"], ["proof (state)\nthis:\n  formulaFalse (getF state) (elements (getM state))\n\ngoal (2 subgoals):\n 1. formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []\n 2. \\<not> formulaFalse (getF state)\n            (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "hence \"decisions (getM state) = []\""], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "using assms"], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBackjump state\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "using finalConflictingState"], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBackjump state\n  \\<lbrakk>InvariantUniq (getM ?state); InvariantConsistent (getM ?state);\n   InvariantImpliedLiterals (getF ?state) (getM ?state);\n   \\<not> applicableBackjump ?state;\n   formulaFalse (getF ?state) (elements (getM ?state))\\<rbrakk>\n  \\<Longrightarrow> decisions (getM ?state) = []\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  decisions (getM state) = []\n\ngoal (2 subgoals):\n 1. formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []\n 2. \\<not> formulaFalse (getF state)\n            (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with True"], ["proof (chain)\npicking this:\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by simp"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state)\n            (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state)\n            (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "case False"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state)\n            (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "hence  \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBackjump state\n\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "using finalNonConflictState"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBackjump state\n  \\<not> applicableDecide ?state ?decisionVars \\<Longrightarrow>\n  ?decisionVars \\<subseteq> vars (elements (getM ?state))\n\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state)\n            (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with False"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by simp"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem finalStateCharacterization:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \n  \"(\\<not> formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse (getF state) (elements (getM state)) \\<and> decisions (getM state) = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "hence \n    *: \"InvariantUniq (getM state)\" \n    \"InvariantConsistent (getM state)\"\n    \"InvariantImpliedLiterals (getF state) (getM state)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM state) &&&\n    InvariantConsistent (getM state) &&&\n    InvariantImpliedLiterals (getF state) (getM state)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals (getF state) (getM state) \\<and>\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantVarsF (getF state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and>\n  InvariantUniq (getM state) \\<and> InvariantEquivalent F0 (getF state)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM state) &&&\n    InvariantConsistent (getM state) &&&\n    InvariantImpliedLiterals (getF state) (getM state)", "by auto"], ["proof (state)\nthis:\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "from \\<open>isFinalState state decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isFinalState state decisionVars", "have **: \n    \"\\<not> applicableBackjump state\"\n    \"\\<not> applicableDecide state decisionVars\""], ["proof (prove)\nusing this:\n  isFinalState state decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> applicableBackjump state &&&\n    \\<not> applicableDecide state decisionVars", "unfolding finalStateNonApplicable"], ["proof (prove)\nusing this:\n  \\<not> applicableDecide state decisionVars \\<and>\n  \\<not> applicableUnitPropagate state \\<and>\n  \\<not> applicableBackjump state \\<and> \\<not> applicableLearn state\n\ngoal (1 subgoal):\n 1. \\<not> applicableBackjump state &&&\n    \\<not> applicableDecide state decisionVars", "by auto"], ["proof (state)\nthis:\n  \\<not> applicableBackjump state\n  \\<not> applicableDecide state decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "from * **"], ["proof (chain)\npicking this:\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<not> applicableBackjump state\n  \\<not> applicableDecide state decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<not> applicableBackjump state\n  \\<not> applicableDecide state decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "using finalStateCharacterizationLemma[of \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantImpliedLiterals (getF state) (getM state)\n  \\<not> applicableBackjump state\n  \\<not> applicableDecide state decisionVars\n  \\<lbrakk>InvariantUniq (getM state); InvariantConsistent (getM state);\n   InvariantImpliedLiterals (getF state) (getM state);\n   \\<not> applicableDecide state decisionVars;\n   \\<not> applicableBackjump state\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    formulaFalse (getF state) (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by simp"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Completeness theorems are easy consequences of this characterization and \n soundness.\\<close>"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem completenessForSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"satisfiable F0\" and \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \"\\<not> formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "from assms"], ["proof (chain)\npicking this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars", "have *: \"(\\<not> formulaFalse (getF state) (elements (getM state))  \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n    (formulaFalse (getF state) (elements (getM state)) \\<and> decisions (getM state) = [])\""], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "using finalStateCharacterization[of \"state0\" \"F0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation decisionVars;\n   isFinalState state decisionVars\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    formulaFalse (getF state) (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "{"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "assume \"formulaFalse (getF state) (elements (getM state))\""], ["proof (state)\nthis:\n  formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  formulaFalse (getF state) (elements (getM state))", "have \"formulaFalse (getF state) (elements (getM state))\" \"decisions (getM state) = []\""], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) &&&\n    decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with assms"], ["proof (chain)\npicking this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []", "have \"\\<not> satisfiable F0\""], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "using soundnessForUNSAT"], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  formulaFalse (getF state) (elements (getM state))\n  decisions (getM state) = []\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?decisionVars;\n   formulaFalse (getF ?state) (elements (getM ?state));\n   decisions (getM ?state) = []\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable ?F0.0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with \\<open>satisfiable F0\\<close>"], ["proof (chain)\npicking this:\n  satisfiable F0\n  \\<not> satisfiable F0", "have False"], ["proof (prove)\nusing this:\n  satisfiable F0\n  \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "}"], ["proof (state)\nthis:\n  formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem completenessForUNSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"\\<not> satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \n  \"formulaFalse (getF state) (elements (getM state)) \\<and> decisions (getM state) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "from assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars", "have *: \n  \"(\\<not> formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse (getF state) (elements (getM state))  \\<and> decisions (getM state) = [])\""], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "using finalStateCharacterization[of \"state0\" \"F0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation decisionVars;\n   isFinalState state decisionVars\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    formulaFalse (getF state) (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "{"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "assume \"\\<not> formulaFalse (getF state) (elements (getM state))\""], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  \\<not> formulaFalse (getF state) (elements (getM state))", "have \"\\<not> formulaFalse (getF state) (elements (getM state))\" \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  \\<not> formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) &&&\n    decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))", "have \"satisfiable F0\""], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. satisfiable F0", "using soundnessForSAT[of \"F0\" \"decisionVars\" \"state0\" \"state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation decisionVars;\n   \\<not> formulaFalse (getF state) (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. satisfiable F0", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<nexists>valuation. model valuation F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation decisionVars;\n   \\<not> formulaFalse (getF state) (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation F0", "by auto"], ["proof (state)\nthis:\n  satisfiable F0\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with \\<open>\\<not> satisfiable F0\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable F0\n  satisfiable F0", "have False"], ["proof (prove)\nusing this:\n  \\<not> satisfiable F0\n  satisfiable F0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "}"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisions (getM state) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem partialCorrectness: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and  \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation decisionVars\" and\n  \"isFinalState state decisionVars\"\n  shows \n  \"satisfiable F0 = (\\<not> formulaFalse (getF state) (elements (getM state)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable F0 =\n    (\\<not> formulaFalse (getF state) (elements (getM state)))", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable F0 =\n    (\\<not> formulaFalse (getF state) (elements (getM state)))", "using assms"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n\ngoal (1 subgoal):\n 1. satisfiable F0 =\n    (\\<not> formulaFalse (getF state) (elements (getM state)))", "using completenessForUNSAT[of \"F0\" \"decisionVars\" \"state0\" \"state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; \\<not> satisfiable F0;\n   isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation decisionVars;\n   isFinalState state decisionVars\\<rbrakk>\n  \\<Longrightarrow> formulaFalse (getF state) (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. satisfiable F0 =\n    (\\<not> formulaFalse (getF state) (elements (getM state)))", "using completenessForSAT[of \"F0\" \"state0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation decisionVars\n  isFinalState state decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; \\<not> satisfiable F0;\n   isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation decisionVars;\n   isFinalState state decisionVars\\<rbrakk>\n  \\<Longrightarrow> formulaFalse (getF state) (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n  \\<lbrakk>satisfiable F0; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation decisionVars;\n   isFinalState state decisionVars\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. satisfiable F0 =\n    (\\<not> formulaFalse (getF state) (elements (getM state)))", "by auto"], ["", "end"]]}