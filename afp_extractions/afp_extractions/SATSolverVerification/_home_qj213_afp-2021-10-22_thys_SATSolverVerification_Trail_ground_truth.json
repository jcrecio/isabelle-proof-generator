{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/Trail.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma\n\"elements t = map fst t\"", "lemma eitherMarkedOrNotMarkedElement: \n  shows \"a = (element a, True) \\<or> a = (element a, False)\"", "lemma eitherMarkedOrNotMarked:\n  assumes \"e \\<in> set (elements M)\"\n  shows \"(e, True) \\<in> set M \\<or> (e, False) \\<in> set M\"", "lemma elementMemElements [simp]:\n  assumes \"x \\<in> set M\"\n  shows \"element x \\<in> set (elements M)\"", "lemma elementsAppend [simp]:\n  shows \"elements (a @ b) = elements a @ elements b\"", "lemma elementsEmptyIffTrailEmpty [simp]:\n  shows \"(elements list = []) = (list = [])\"", "lemma elementsButlastTrailIsButlastElementsTrail [simp]:\n  shows \"elements (butlast M) = butlast (elements M)\"", "lemma elementLastTrailIsLastElementsTrail [simp]:\n  assumes \"M \\<noteq> []\"\n  shows \"element (last M) = last (elements M)\"", "lemma isPrefixElements:\n  assumes \"isPrefix a b\"\n  shows \"isPrefix (elements a) (elements b)\"", "lemma prefixElementsAreTrailElements:\n  assumes \n  \"isPrefix p M\" \n  shows \n  \"set (elements p) \\<subseteq> set (elements M)\"", "lemma uniqElementsTrailImpliesUniqElementsPrefix:\n  assumes \n  \"isPrefix p M\" and \"uniq (elements M)\"\n  shows\n  \"uniq (elements p)\"", "lemma [simp]: \n  assumes \"(e, d) \\<in> set M\"\n  shows \"e \\<in> set (elements M)\"", "lemma uniqImpliesExclusiveTrueOrFalse:\n  assumes\n  \"(e, d) \\<in> set M\" and \"uniq (elements M)\"\n  shows\n  \"\\<not> (e, \\<not> d) \\<in> set M\"", "lemma\n\"markedElements t = (elements (filter snd t))\"", "lemma markedElementIsMarkedTrue: \n  shows \"(m \\<in> set (markedElements M)) = ((m, True) \\<in> set M)\"", "lemma markedElementsAppend: \n  shows \"markedElements (M1 @ M2) = markedElements M1 @ markedElements M2\"", "lemma markedElementsAreElements:\n  assumes \"m \\<in> set (markedElements M)\"\n  shows   \"m \\<in> set (elements M)\"", "lemma markedAndMemberImpliesIsMarkedElement:\n  assumes \"marked m\" \"m \\<in> set M\"\n  shows \"(element m) \\<in> set (markedElements M)\"", "lemma markedElementsPrefixAreMarkedElementsTrail:\n  assumes \"isPrefix p M\" \"m \\<in> set (markedElements p)\"\n  shows \"m \\<in> set (markedElements M)\"", "lemma markedElementsTrailMemPrefixAreMarkedElementsPrefix:\n  assumes \n  \"uniq (elements M)\" and\n  \"isPrefix p M\" and\n  \"m \\<in> set (elements p)\" and\n  \"m \\<in> set (markedElements M)\" \n  shows\n  \"m \\<in> set (markedElements p)\"", "lemma \"prefixBeforeElement e t = takeWhile (\\<lambda> e'. element e' \\<noteq> e) t\"", "lemma \"prefixBeforeElement e t = take (firstPos e (elements t)) t\"", "lemma \"prefixToElement e t = take ((firstPos e (elements t)) + 1) t\"", "lemma isPrefixPrefixToElement:\n  shows \"isPrefix (prefixToElement e t) t\"", "lemma isPrefixPrefixBeforeElement:\n  shows \"isPrefix (prefixBeforeElement e t) t\"", "lemma prefixToElementContainsTrailElement:\n  assumes \"e \\<in> set (elements M)\"\n  shows \"e \\<in> set (elements (prefixToElement e M))\"", "lemma prefixBeforeElementDoesNotContainTrailElement:\n  assumes \"e \\<in> set (elements M)\"\n  shows \"e \\<notin> set (elements (prefixBeforeElement e M))\"", "lemma prefixToElementAppend: \n  shows \"prefixToElement e (M1 @ M2) = \n            (if e \\<in> set (elements M1) then \n                prefixToElement e M1\n             else   \n                M1 @ prefixToElement e M2\n             )\"", "lemma prefixToElementToPrefixElement:\n  assumes\n  \"isPrefix p M\" and \"e \\<in> set (elements p)\"\n  shows\n  \"prefixToElement e M = prefixToElement e p\"", "lemma markedElementsToArePrefixOfMarkedElements:\n  shows \"isPrefix (markedElementsTo e M) (markedElements M)\"", "lemma markedElementsToAreMarkedElements: \n  assumes \"m \\<in> set (markedElementsTo e M)\"\n  shows \"m \\<in> set (markedElements M)\"", "lemma markedElementsToNonMemberAreAllMarkedElements:\n  assumes \"e \\<notin> set (elements M)\"\n  shows \"markedElementsTo e M = markedElements M\"", "lemma markedElementsToAppend: \n  shows \"markedElementsTo e (M1 @ M2) = \n          (if e \\<in> set (elements M1) then \n                 markedElementsTo e M1\n           else \n                 markedElements M1 @ markedElementsTo e M2\n          )\"", "lemma markedElementsEmptyImpliesMarkedElementsToEmpty: \n  assumes \"markedElements M = []\"\n  shows \"markedElementsTo e M = []\"", "lemma markedElementIsMemberOfItsMarkedElementsTo: \n  assumes\n  \"uniq (elements M)\" and \"marked e\" and \"e \\<in> set M\"\n  shows \n  \"element e \\<in> set (markedElementsTo (element e) M)\"", "lemma markedElementsToPrefixElement: \n  assumes \"isPrefix p M\" and \"e \\<in> set (elements p)\"\n  shows \"markedElementsTo e M = markedElementsTo e p\"", "lemma lastMarkedIsMarkedElement: \n  assumes \"markedElements M \\<noteq> []\" \n  shows \"lastMarked M \\<in> set (markedElements M)\"", "lemma removeLastMarkedFromMarkedElementsToLastMarkedAreAllMarkedElementsInPrefixLastMarked: \n  assumes\n  \"markedElements M \\<noteq> []\"\n  shows\n  \"removeAll (lastMarked M) (markedElementsTo (lastMarked M) M) = markedElements (prefixBeforeElement (lastMarked M) M)\"", "lemma markedElementsToLastMarkedAreAllMarkedElements:\n  assumes\n  \"uniq (elements M)\" and \"markedElements M \\<noteq> []\"\n  shows\n  \"markedElementsTo (lastMarked M) M = markedElements M\"", "lemma lastTrailElementMarkedImpliesMarkedElementsToLastElementAreAllMarkedElements:\n  assumes\n  \"marked (last M)\" and \"last (elements M) \\<notin> set (butlast (elements M))\"\n  shows\n  \"markedElementsTo (last (elements M)) M = markedElements M\"", "lemma lastMarkedIsMemberOfItsMarkedElementsTo: \n  assumes\n  \"uniq (elements M)\" and \"markedElements M \\<noteq> []\"\n  shows\n  \"lastMarked M \\<in> set (markedElementsTo (lastMarked M) M)\"", "lemma lastTrailElementNotMarkedImpliesMarkedElementsToLAreMarkedElementsToLInButlastTrail: \n  assumes \"\\<not> marked (last M)\"\n  shows \"markedElementsTo e M = markedElementsTo e (butlast M)\"", "lemma elementLevelMarkedGeq1:\n  assumes\n  \"uniq (elements M)\" and \"e \\<in> set (markedElements M)\"\n  shows\n  \"elementLevel e M >= 1\"", "lemma elementLevelAppend:\n  assumes \"a \\<in> set (elements M)\"\n  shows \"elementLevel a M = elementLevel a (M @ M')\"", "lemma elementLevelPrecedesLeq: \n  assumes\n  \"precedes a b (elements M)\" \n  shows\n  \"elementLevel a M \\<le> elementLevel b M\"", "lemma elementLevelPrecedesMarkedElementLt: \n  assumes\n  \"uniq (elements M)\" and\n  \"e \\<noteq> d\" and\n  \"d \\<in> set (markedElements M)\" and\n  \"precedes e d (elements M)\"\n  shows\n  \"elementLevel e M < elementLevel d M\"", "lemma differentMarkedElementsHaveDifferentLevels:\n  assumes\n  \"uniq (elements M)\" and\n  \"a \\<in> set (markedElements M)\" and\n  \"b \\<in> set (markedElements M)\" and\n  \"a \\<noteq> b\" \n  shows \"elementLevel a M \\<noteq> elementLevel b M\"", "lemma currentLevelNonMarked: \n  shows \"currentLevel M = currentLevel (M @ [(l, False)])\"", "lemma currentLevelPrefix:\n  assumes \"isPrefix a b\" \n  shows \"currentLevel a <= currentLevel b\"", "lemma elementLevelLeqCurrentLevel:\n  shows \"elementLevel a M \\<le> currentLevel M\"", "lemma elementOnCurrentLevel:\n  assumes \"a \\<notin> set (elements M)\"\n  shows \"elementLevel a (M @ [(a, d)]) = currentLevel  (M @ [(a, d)])\"", "lemma isPrefixPrefixToLevel_aux:\n  shows \"\\<exists> s. prefixToLevel_aux t l i @ s = t\"", "lemma isPrefixPrefixToLevel:\n  shows \"(isPrefix (prefixToLevel l t) t)\"", "lemma currentLevelPrefixToLevel_aux: \n  assumes \"l \\<ge> i\"\n  shows \"currentLevel (prefixToLevel_aux M l i) <= l - i\"", "lemma currentLevelPrefixToLevel: \n  shows \"currentLevel (prefixToLevel level M) \\<le> level\"", "lemma currentLevelPrefixToLevelEq_aux: \n  assumes \"l \\<ge> i\" \"currentLevel M >= l - i\"\n  shows \"currentLevel (prefixToLevel_aux M l i) = l - i\"", "lemma currentLevelPrefixToLevelEq:\nassumes\n  \"level \\<le> currentLevel M\"\nshows\n  \"currentLevel (prefixToLevel level M) = level\"", "lemma prefixToLevel_auxIncreaseAuxilaryCounter: \n  assumes \"k \\<ge> i\"\n  shows \"prefixToLevel_aux M l i = prefixToLevel_aux M (l + (k - i)) k\"", "lemma isPrefixPrefixToLevel_auxLowerLevel:\n  assumes \"i \\<le> j\"\n  shows \"isPrefix (prefixToLevel_aux M i k) (prefixToLevel_aux M j k)\"", "lemma isPrefixPrefixToLevelLowerLevel:\nassumes \"level < level'\"\nshows \"isPrefix (prefixToLevel level M) (prefixToLevel level' M)\"", "lemma prefixToLevel_auxPrefixToLevel_auxHigherLevel: \n  assumes \"i \\<le> j\"\n  shows \"prefixToLevel_aux a i k = prefixToLevel_aux (prefixToLevel_aux a j k) i k\"", "lemma prefixToLevelPrefixToLevelHigherLevel: \n  assumes \"level \\<le> level'\"\n  shows \"prefixToLevel level M = prefixToLevel level (prefixToLevel level' M)\"", "lemma prefixToLevelAppend_aux1:\n  assumes\n  \"l \\<ge> i\" and \"l - i < currentLevel a\"\n  shows \n  \"prefixToLevel_aux (a @ b) l i = prefixToLevel_aux a l i\"", "lemma prefixToLevelAppend_aux2: \n  assumes \n  \"i \\<le> l\" and \"currentLevel a + i \\<le> l\"\n  shows \"prefixToLevel_aux (a @ b) l i = a @ prefixToLevel_aux b l (i + (currentLevel a))\"", "lemma prefixToLevelAppend:\n  shows \"prefixToLevel level (a @ b) = \n  (if level < currentLevel a then \n      prefixToLevel level a\n  else \n      a @ prefixToLevel_aux b level (currentLevel a)\n  )\"", "lemma isProperPrefixPrefixToLevel:\n  assumes \"level < currentLevel t\" \n  shows \"\\<exists> s. (prefixToLevel level t) @ s = t \\<and> s \\<noteq> [] \\<and> (marked (hd s))\"", "lemma prefixToLevelElementsElementLevel: \n  assumes \n  \"e  \\<in> set (elements (prefixToLevel level M))\"\n  shows\n  \"elementLevel e M \\<le> level\"", "lemma elementLevelLtLevelImpliesMemberPrefixToLevel_aux:\n  assumes\n  \"e  \\<in> set(elements M)\" and\n  \"elementLevel e M + i \\<le> level\" and\n  \"i \\<le> level\"\n  shows \n  \"e  \\<in> set (elements (prefixToLevel_aux M level i))\"", "lemma elementLevelLtLevelImpliesMemberPrefixToLevel:\n  assumes\n  \"e \\<in> set (elements M)\" and\n  \"elementLevel e M \\<le> level\"\n  shows \n  \"e \\<in> set (elements (prefixToLevel level M))\"", "lemma literalNotInEarlierLevelsThanItsLevel: \n  assumes\n  \"level < elementLevel e M\" \n  shows \n  \"e \\<notin> set (elements (prefixToLevel level M))\"", "lemma elementLevelPrefixElement: \n  assumes \"e \\<in> set (elements (prefixToLevel level M))\"\n  shows \"elementLevel e (prefixToLevel level M) = elementLevel e M\"", "lemma currentLevelZeroTrailEqualsItsPrefixToLevelZero:\n  assumes \"currentLevel M = 0\" \n  shows \"M = prefixToLevel 0 M\"", "lemma levelsCounter_aux_startIrellevant: \n  \"\\<forall> y. y \\<noteq> [] \\<longrightarrow> levelsCounter_aux a (x @ y) = (x @ levelsCounter_aux a y)\"", "lemma levelsCounter_auxSuffixContinues: \"\\<forall> l. levelsCounter_aux (a @ b) l = levelsCounter_aux b (levelsCounter_aux a l)\"", "lemma levelsCounter_auxNotEmpty: \"\\<forall> l. l \\<noteq> [] \\<longrightarrow> levelsCounter_aux a l \\<noteq> []\"", "lemma levelsCounter_auxIncreasesFirst: \n\"\\<forall> m n l1 l2. levelsCounter_aux a (m # l1) = n # l2 \\<longrightarrow> m <= n\"", "lemma levelsCounterPrefix:\n  assumes \"(isPrefix p a)\"\n  shows \"? rest. rest \\<noteq> [] \\<and> levelsCounter a = butlast (levelsCounter p) @ rest \\<and> last (levelsCounter p) \\<le> hd rest\"", "lemma levelsCounterPrefixToLevel:\n  assumes \"p = prefixToLevel level a\" \"level \\<ge> 0\" \"level < currentLevel a\" \n  shows \"? rest . rest \\<noteq> [] \\<and> (levelsCounter a) = (levelsCounter p) @ rest\"", "lemma prefixBeforeLastMarkedIsPrefixBeforeLastLevel:\n  assumes \"markedElements M \\<noteq> []\"\n  shows \"prefixBeforeLastMarked M = prefixToLevel ((currentLevel M) - 1) M\"", "lemma isPrefixPrefixBeforeLastMarked:\n  shows \"isPrefix (prefixBeforeLastMarked M) M\"", "lemma lastMarkedNotInPrefixBeforeLastMarked:\n  assumes \"uniq (elements M)\" and \"markedElements M \\<noteq> []\"\n  shows \"\\<not> (lastMarked M) \\<in> set (elements (prefixBeforeLastMarked M))\"", "lemma uniqImpliesPrefixBeforeLastMarkedIsPrefixBeforeLastMarked:\n  assumes \"markedElements M \\<noteq> []\" and \"(lastMarked M) \\<notin> set (elements M)\"\n  shows \"prefixBeforeLastMarked M = prefixBeforeElement (lastMarked M) M\"", "lemma markedElementsAreElementsBeforeLastDecisionAndLastDecision: \n  assumes \"markedElements M \\<noteq> []\"\n  shows \"(markedElements M) = (markedElements (prefixBeforeLastMarked M)) @ [lastMarked M]\""], "translations": [["", "lemma\n\"elements t = map fst t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements t = map element t", "by (induct t) auto"], ["", "lemma eitherMarkedOrNotMarkedElement: \n  shows \"a = (element a, True) \\<or> a = (element a, False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = (element a, True) \\<or> a = (element a, False)", "by (cases a) auto"], ["", "lemma eitherMarkedOrNotMarked:\n  assumes \"e \\<in> set (elements M)\"\n  shows \"(e, True) \\<in> set M \\<or> (e, False) \\<in> set M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, True) \\<in> set M \\<or> (e, False) \\<in> set M", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. (e, True) \\<in> set M \\<or> (e, False) \\<in> set M", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. e \\<in> set (elements []) \\<Longrightarrow>\n    (e, True) \\<in> set [] \\<or> (e, False) \\<in> set []\n 2. \\<And>a M.\n       \\<lbrakk>e \\<in> set (elements M) \\<Longrightarrow>\n                (e, True) \\<in> set M \\<or> (e, False) \\<in> set M;\n        e \\<in> set (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, True) \\<in> set (a # M) \\<or>\n                         (e, False) \\<in> set (a # M)", "case (Cons m M')"], ["proof (state)\nthis:\n  e \\<in> set (elements M') \\<Longrightarrow>\n  (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M'\n  e \\<in> set (elements (m # M'))\n\ngoal (2 subgoals):\n 1. e \\<in> set (elements []) \\<Longrightarrow>\n    (e, True) \\<in> set [] \\<or> (e, False) \\<in> set []\n 2. \\<And>a M.\n       \\<lbrakk>e \\<in> set (elements M) \\<Longrightarrow>\n                (e, True) \\<in> set M \\<or> (e, False) \\<in> set M;\n        e \\<in> set (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, True) \\<in> set (a # M) \\<or>\n                         (e, False) \\<in> set (a # M)", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M') \\<Longrightarrow>\n  (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M'\n  e \\<in> set (elements (m # M'))\n\ngoal (1 subgoal):\n 1. (e, True) \\<in> set (m # M') \\<or> (e, False) \\<in> set (m # M')", "proof (cases \"e = element m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> set (elements M') \\<Longrightarrow>\n             (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M';\n     e \\<in> set (elements (m # M')); e = element m\\<rbrakk>\n    \\<Longrightarrow> (e, True) \\<in> set (m # M') \\<or>\n                      (e, False) \\<in> set (m # M')\n 2. \\<lbrakk>e \\<in> set (elements M') \\<Longrightarrow>\n             (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M';\n     e \\<in> set (elements (m # M')); e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> (e, True) \\<in> set (m # M') \\<or>\n                      (e, False) \\<in> set (m # M')", "case True"], ["proof (state)\nthis:\n  e = element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> set (elements M') \\<Longrightarrow>\n             (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M';\n     e \\<in> set (elements (m # M')); e = element m\\<rbrakk>\n    \\<Longrightarrow> (e, True) \\<in> set (m # M') \\<or>\n                      (e, False) \\<in> set (m # M')\n 2. \\<lbrakk>e \\<in> set (elements M') \\<Longrightarrow>\n             (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M';\n     e \\<in> set (elements (m # M')); e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> (e, True) \\<in> set (m # M') \\<or>\n                      (e, False) \\<in> set (m # M')", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = element m\n\ngoal (1 subgoal):\n 1. (e, True) \\<in> set (m # M') \\<or> (e, False) \\<in> set (m # M')", "using eitherMarkedOrNotMarkedElement [of \"m\"]"], ["proof (prove)\nusing this:\n  e = element m\n  m = (element m, True) \\<or> m = (element m, False)\n\ngoal (1 subgoal):\n 1. (e, True) \\<in> set (m # M') \\<or> (e, False) \\<in> set (m # M')", "by auto"], ["proof (state)\nthis:\n  (e, True) \\<in> set (m # M') \\<or> (e, False) \\<in> set (m # M')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set (elements M') \\<Longrightarrow>\n             (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M';\n     e \\<in> set (elements (m # M')); e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> (e, True) \\<in> set (m # M') \\<or>\n                      (e, False) \\<in> set (m # M')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set (elements M') \\<Longrightarrow>\n             (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M';\n     e \\<in> set (elements (m # M')); e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> (e, True) \\<in> set (m # M') \\<or>\n                      (e, False) \\<in> set (m # M')", "case False"], ["proof (state)\nthis:\n  e \\<noteq> element m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set (elements M') \\<Longrightarrow>\n             (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M';\n     e \\<in> set (elements (m # M')); e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> (e, True) \\<in> set (m # M') \\<or>\n                      (e, False) \\<in> set (m # M')", "with Cons"], ["proof (chain)\npicking this:\n  e \\<in> set (elements M') \\<Longrightarrow>\n  (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M'\n  e \\<in> set (elements (m # M'))\n  e \\<noteq> element m", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M') \\<Longrightarrow>\n  (e, True) \\<in> set M' \\<or> (e, False) \\<in> set M'\n  e \\<in> set (elements (m # M'))\n  e \\<noteq> element m\n\ngoal (1 subgoal):\n 1. (e, True) \\<in> set (m # M') \\<or> (e, False) \\<in> set (m # M')", "by auto"], ["proof (state)\nthis:\n  (e, True) \\<in> set (m # M') \\<or> (e, False) \\<in> set (m # M')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (e, True) \\<in> set (m # M') \\<or> (e, False) \\<in> set (m # M')\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements []) \\<Longrightarrow>\n    (e, True) \\<in> set [] \\<or> (e, False) \\<in> set []", "qed simp"], ["", "lemma elementMemElements [simp]:\n  assumes \"x \\<in> set M\"\n  shows \"element x \\<in> set (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element x \\<in> set (elements M)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set M\n\ngoal (1 subgoal):\n 1. element x \\<in> set (elements M)", "by (induct M) (auto split: if_split_asm)"], ["", "lemma elementsAppend [simp]:\n  shows \"elements (a @ b) = elements a @ elements b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements (a @ b) = elements a @ elements b", "by (induct a) auto"], ["", "lemma elementsEmptyIffTrailEmpty [simp]:\n  shows \"(elements list = []) = (list = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (elements list = []) = (list = [])", "by (induct list) auto"], ["", "lemma elementsButlastTrailIsButlastElementsTrail [simp]:\n  shows \"elements (butlast M) = butlast (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements (butlast M) = butlast (elements M)", "by (induct M) auto"], ["", "lemma elementLastTrailIsLastElementsTrail [simp]:\n  assumes \"M \\<noteq> []\"\n  shows \"element (last M) = last (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element (last M) = last (elements M)", "using assms"], ["proof (prove)\nusing this:\n  M \\<noteq> []\n\ngoal (1 subgoal):\n 1. element (last M) = last (elements M)", "by (induct M) auto"], ["", "lemma isPrefixElements:\n  assumes \"isPrefix a b\"\n  shows \"isPrefix (elements a) (elements b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (elements a) (elements b)", "using assms"], ["proof (prove)\nusing this:\n  isPrefix a b\n\ngoal (1 subgoal):\n 1. isPrefix (elements a) (elements b)", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. a @ s = b\n\ngoal (1 subgoal):\n 1. \\<exists>s. elements a @ s = elements b", "by auto"], ["", "lemma prefixElementsAreTrailElements:\n  assumes \n  \"isPrefix p M\" \n  shows \n  \"set (elements p) \\<subseteq> set (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elements p) \\<subseteq> set (elements M)", "using assms"], ["proof (prove)\nusing this:\n  isPrefix p M\n\ngoal (1 subgoal):\n 1. set (elements p) \\<subseteq> set (elements M)", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. p @ s = M\n\ngoal (1 subgoal):\n 1. set (elements p) \\<subseteq> set (elements M)", "by auto"], ["", "lemma uniqElementsTrailImpliesUniqElementsPrefix:\n  assumes \n  \"isPrefix p M\" and \"uniq (elements M)\"\n  shows\n  \"uniq (elements p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uniq (elements p)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. uniq (elements p)", "from \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M", "obtain s \n    where \"M = p @ s\""], ["proof (prove)\nusing this:\n  isPrefix p M\n\ngoal (1 subgoal):\n 1. (\\<And>s. M = p @ s \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. p @ s = M\n\ngoal (1 subgoal):\n 1. (\\<And>s. M = p @ s \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  M = p @ s\n\ngoal (1 subgoal):\n 1. uniq (elements p)", "with \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  M = p @ s", "show ?thesis"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  M = p @ s\n\ngoal (1 subgoal):\n 1. uniq (elements p)", "using uniqAppend[of \"elements p\" \"elements s\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  M = p @ s\n  uniq (elements p @ elements s) \\<Longrightarrow> uniq (elements p)\n  uniq (elements p @ elements s) \\<Longrightarrow> uniq (elements s)\n\ngoal (1 subgoal):\n 1. uniq (elements p)", "by simp"], ["proof (state)\nthis:\n  uniq (elements p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \n  assumes \"(e, d) \\<in> set M\"\n  shows \"e \\<in> set (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set (elements M)", "using assms"], ["proof (prove)\nusing this:\n  (e, d) \\<in> set M\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements M)", "by (induct M) auto"], ["", "lemma uniqImpliesExclusiveTrueOrFalse:\n  assumes\n  \"(e, d) \\<in> set M\" and \"uniq (elements M)\"\n  shows\n  \"\\<not> (e, \\<not> d) \\<in> set M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set M", "using assms"], ["proof (prove)\nusing this:\n  (e, d) \\<in> set M\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set M", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "case (Cons m M')"], ["proof (state)\nthis:\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set (m # M')\n  uniq (elements (m # M'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set (m # M')\n  uniq (elements (m # M'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "assume \"(e, d) = m\""], ["proof (state)\nthis:\n  (e, d) = m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "hence \"(e, \\<not> d) \\<noteq> m\""], ["proof (prove)\nusing this:\n  (e, d) = m\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  (e, \\<not> d) \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "from \\<open>(e, d) = m\\<close> \\<open>uniq (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  (e, d) = m\n  uniq (elements (m # M'))", "have \"\\<not> (e, d) \\<in> set M'\""], ["proof (prove)\nusing this:\n  (e, d) = m\n  uniq (elements (m # M'))\n\ngoal (1 subgoal):\n 1. (e, d) \\<notin> set M'", "by (auto simp add: uniqAppendIff)"], ["proof (state)\nthis:\n  (e, d) \\<notin> set M'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set (m # M')\n  uniq (elements (m # M'))\n  (e, d) \\<notin> set M'", "have ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set (m # M')\n  uniq (elements (m # M'))\n  (e, d) \\<notin> set M'\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set (m # M')", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "}"], ["proof (state)\nthis:\n  (e, d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "moreover"], ["proof (state)\nthis:\n  (e, d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "{"], ["proof (state)\nthis:\n  (e, d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "assume \"(e, \\<not> d) = m\""], ["proof (state)\nthis:\n  (e, \\<not> d) = m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "hence \"(e, d) \\<noteq> m\""], ["proof (prove)\nusing this:\n  (e, \\<not> d) = m\n\ngoal (1 subgoal):\n 1. (e, d) \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  (e, d) \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "from \\<open>(e, \\<not> d) = m\\<close> \\<open>uniq (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  (e, \\<not> d) = m\n  uniq (elements (m # M'))", "have \"\\<not> (e, \\<not> d) \\<in> set M'\""], ["proof (prove)\nusing this:\n  (e, \\<not> d) = m\n  uniq (elements (m # M'))\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set M'", "by (auto simp add: uniqAppendIff)"], ["proof (state)\nthis:\n  (e, \\<not> d) \\<notin> set M'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set (m # M')\n  uniq (elements (m # M'))\n  (e, \\<not> d) \\<notin> set M'", "have ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set (m # M')\n  uniq (elements (m # M'))\n  (e, \\<not> d) \\<notin> set M'\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set (m # M')", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "}"], ["proof (state)\nthis:\n  (e, \\<not> d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "moreover"], ["proof (state)\nthis:\n  (e, \\<not> d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "{"], ["proof (state)\nthis:\n  (e, \\<not> d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "assume \"(e, d) \\<noteq> m\" \"(e, \\<not> d) \\<noteq> m\""], ["proof (state)\nthis:\n  (e, d) \\<noteq> m\n  (e, \\<not> d) \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "from \\<open>(e, d) \\<noteq> m\\<close> \\<open>(e, d) \\<in> set (m # M')\\<close>"], ["proof (chain)\npicking this:\n  (e, d) \\<noteq> m\n  (e, d) \\<in> set (m # M')", "have \n      \"(e, d) \\<in> set M'\""], ["proof (prove)\nusing this:\n  (e, d) \\<noteq> m\n  (e, d) \\<in> set (m # M')\n\ngoal (1 subgoal):\n 1. (e, d) \\<in> set M'", "by simp"], ["proof (state)\nthis:\n  (e, d) \\<in> set M'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "with \\<open>uniq (elements (m # M'))\\<close> Cons(1)"], ["proof (chain)\npicking this:\n  uniq (elements (m # M'))\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set M'", "have \"\\<not> (e, \\<not> d) \\<in> set M'\""], ["proof (prove)\nusing this:\n  uniq (elements (m # M'))\n  \\<lbrakk>(e, d) \\<in> set M'; uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set M'\n  (e, d) \\<in> set M'\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set M'", "by simp"], ["proof (state)\nthis:\n  (e, \\<not> d) \\<notin> set M'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "with \\<open>(e, \\<not> d) \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  (e, \\<not> d) \\<noteq> m\n  (e, \\<not> d) \\<notin> set M'", "have ?case"], ["proof (prove)\nusing this:\n  (e, \\<not> d) \\<noteq> m\n  (e, \\<not> d) \\<notin> set M'\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set (m # M')", "by simp"], ["proof (state)\nthis:\n  (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(e, d) \\<noteq> m; (e, \\<not> d) \\<noteq> m\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(e, d) \\<noteq> m; (e, \\<not> d) \\<noteq> m\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(e, d) \\<noteq> m; (e, \\<not> d) \\<noteq> m\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "have \"(e, d) = m \\<or> (e, \\<not> d) = m \\<or> (e, d) \\<noteq> m \\<and> (e, \\<not> d) \\<noteq> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, d) = m \\<or>\n    (e, \\<not> d) = m \\<or>\n    (e, d) \\<noteq> m \\<and> (e, \\<not> d) \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  (e, d) = m \\<or>\n  (e, \\<not> d) = m \\<or> (e, d) \\<noteq> m \\<and> (e, \\<not> d) \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "}"], ["proof (state)\nthis:\n  (e, d) = m \\<or>\n  (e, \\<not> d) = m \\<or> (e, d) \\<noteq> m \\<and> (e, \\<not> d) \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>(e, d) \\<in> set M; uniq (elements M)\\<rbrakk>\n                \\<Longrightarrow> (e, \\<not> d) \\<notin> set M;\n        (e, d) \\<in> set (a # M); uniq (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> (e, \\<not> d) \\<notin> set (a # M)", "ultimately"], ["proof (chain)\npicking this:\n  (e, d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n  (e, \\<not> d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n  \\<lbrakk>(e, d) \\<noteq> m; (e, \\<not> d) \\<noteq> m\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n  (e, d) = m \\<or>\n  (e, \\<not> d) = m \\<or> (e, d) \\<noteq> m \\<and> (e, \\<not> d) \\<noteq> m", "show ?case"], ["proof (prove)\nusing this:\n  (e, d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n  (e, \\<not> d) = m \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n  \\<lbrakk>(e, d) \\<noteq> m; (e, \\<not> d) \\<noteq> m\\<rbrakk>\n  \\<Longrightarrow> (e, \\<not> d) \\<notin> set (m # M')\n  (e, d) = m \\<or>\n  (e, \\<not> d) = m \\<or> (e, d) \\<noteq> m \\<and> (e, \\<not> d) \\<noteq> m\n\ngoal (1 subgoal):\n 1. (e, \\<not> d) \\<notin> set (m # M')", "by auto"], ["proof (state)\nthis:\n  (e, \\<not> d) \\<notin> set (m # M')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(e, d) \\<in> set []; uniq (elements [])\\<rbrakk>\n    \\<Longrightarrow> (e, \\<not> d) \\<notin> set []", "qed simp"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Marked trail elements\\<close>"], ["", "primrec\nmarkedElements        :: \"'a Trail \\<Rightarrow> 'a list\"\nwhere\n  \"markedElements [] = []\"\n| \"markedElements (h#t) =  (if (marked h) then (element h) # (markedElements t) else (markedElements t))\""], ["", "lemma\n\"markedElements t = (elements (filter snd t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElements t = elements (filter marked t)", "by (induct t) auto"], ["", "lemma markedElementIsMarkedTrue: \n  shows \"(m \\<in> set (markedElements M)) = ((m, True) \\<in> set M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<in> set (markedElements M)) = ((m, True) \\<in> set M)", "by (induct M) (auto split: if_split_asm)"], ["", "lemma markedElementsAppend: \n  shows \"markedElements (M1 @ M2) = markedElements M1 @ markedElements M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElements (M1 @ M2) = markedElements M1 @ markedElements M2", "by (induct M1) auto"], ["", "lemma markedElementsAreElements:\n  assumes \"m \\<in> set (markedElements M)\"\n  shows   \"m \\<in> set (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> set (elements M)", "using assms markedElementIsMarkedTrue[of \"m\" \"M\"]"], ["proof (prove)\nusing this:\n  m \\<in> set (markedElements M)\n  (m \\<in> set (markedElements M)) = ((m, True) \\<in> set M)\n\ngoal (1 subgoal):\n 1. m \\<in> set (elements M)", "by auto"], ["", "lemma markedAndMemberImpliesIsMarkedElement:\n  assumes \"marked m\" \"m \\<in> set M\"\n  shows \"(element m) \\<in> set (markedElements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element m \\<in> set (markedElements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. element m \\<in> set (markedElements M)", "have \"m = (element m, marked m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = (element m, marked m)", "by auto"], ["proof (state)\nthis:\n  m = (element m, marked m)\n\ngoal (1 subgoal):\n 1. element m \\<in> set (markedElements M)", "with \\<open>marked m\\<close>"], ["proof (chain)\npicking this:\n  marked m\n  m = (element m, marked m)", "have \"m = (element m, True)\""], ["proof (prove)\nusing this:\n  marked m\n  m = (element m, marked m)\n\ngoal (1 subgoal):\n 1. m = (element m, True)", "by simp"], ["proof (state)\nthis:\n  m = (element m, True)\n\ngoal (1 subgoal):\n 1. element m \\<in> set (markedElements M)", "with \\<open>m \\<in> set M\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> set M\n  m = (element m, True)", "have\n    \"(element m, True) \\<in> set M\""], ["proof (prove)\nusing this:\n  m \\<in> set M\n  m = (element m, True)\n\ngoal (1 subgoal):\n 1. (element m, True) \\<in> set M", "by simp"], ["proof (state)\nthis:\n  (element m, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. element m \\<in> set (markedElements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (element m, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. element m \\<in> set (markedElements M)", "using markedElementIsMarkedTrue [of \"element m\" \"M\"]"], ["proof (prove)\nusing this:\n  (element m, True) \\<in> set M\n  (element m \\<in> set (markedElements M)) = ((element m, True) \\<in> set M)\n\ngoal (1 subgoal):\n 1. element m \\<in> set (markedElements M)", "by simp"], ["proof (state)\nthis:\n  element m \\<in> set (markedElements M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma markedElementsPrefixAreMarkedElementsTrail:\n  assumes \"isPrefix p M\" \"m \\<in> set (markedElements p)\"\n  shows \"m \\<in> set (markedElements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "from \\<open>m \\<in> set (markedElements p)\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> set (markedElements p)", "have \"(m, True) \\<in> set p\""], ["proof (prove)\nusing this:\n  m \\<in> set (markedElements p)\n\ngoal (1 subgoal):\n 1. (m, True) \\<in> set p", "by (simp add: markedElementIsMarkedTrue)"], ["proof (state)\nthis:\n  (m, True) \\<in> set p\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "with \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  (m, True) \\<in> set p", "have \"(m, True) \\<in> set M\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  (m, True) \\<in> set p\n\ngoal (1 subgoal):\n 1. (m, True) \\<in> set M", "using prefixIsSubset[of \"p\" \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  (m, True) \\<in> set p\n  isPrefix p M \\<Longrightarrow> set p \\<subseteq> set M\n\ngoal (1 subgoal):\n 1. (m, True) \\<in> set M", "by auto"], ["proof (state)\nthis:\n  (m, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (m, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "by (simp add: markedElementIsMarkedTrue)"], ["proof (state)\nthis:\n  m \\<in> set (markedElements M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma markedElementsTrailMemPrefixAreMarkedElementsPrefix:\n  assumes \n  \"uniq (elements M)\" and\n  \"isPrefix p M\" and\n  \"m \\<in> set (elements p)\" and\n  \"m \\<in> set (markedElements M)\" \n  shows\n  \"m \\<in> set (markedElements p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements p)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements p)", "from \\<open>m \\<in> set (markedElements M)\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> set (markedElements M)", "have \"(m, True) \\<in> set M\""], ["proof (prove)\nusing this:\n  m \\<in> set (markedElements M)\n\ngoal (1 subgoal):\n 1. (m, True) \\<in> set M", "by (simp add: markedElementIsMarkedTrue)"], ["proof (state)\nthis:\n  (m, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements p)", "with \\<open>uniq (elements M)\\<close> \\<open>m \\<in> set (elements p)\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  m \\<in> set (elements p)\n  (m, True) \\<in> set M", "have \"(m, True) \\<in> set p\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  m \\<in> set (elements p)\n  (m, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. (m, True) \\<in> set p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>uniq (elements M); m \\<in> set (elements p);\n     (m, True) \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> (m, True) \\<in> set p", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>uniq (elements M); m \\<in> set (elements p);\n     (m, True) \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> (m, True) \\<in> set p", "assume \"(m, False) \\<in> set p\""], ["proof (state)\nthis:\n  (m, False) \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uniq (elements M); m \\<in> set (elements p);\n     (m, True) \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> (m, True) \\<in> set p", "with \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  (m, False) \\<in> set p", "have \"(m, False) \\<in> set M\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  (m, False) \\<in> set p\n\ngoal (1 subgoal):\n 1. (m, False) \\<in> set M", "using prefixIsSubset[of \"p\" \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  (m, False) \\<in> set p\n  isPrefix p M \\<Longrightarrow> set p \\<subseteq> set M\n\ngoal (1 subgoal):\n 1. (m, False) \\<in> set M", "by auto"], ["proof (state)\nthis:\n  (m, False) \\<in> set M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uniq (elements M); m \\<in> set (elements p);\n     (m, True) \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> (m, True) \\<in> set p", "with \\<open>(m, True) \\<in> set M\\<close> \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  (m, True) \\<in> set M\n  uniq (elements M)\n  (m, False) \\<in> set M", "have False"], ["proof (prove)\nusing this:\n  (m, True) \\<in> set M\n  uniq (elements M)\n  (m, False) \\<in> set M\n\ngoal (1 subgoal):\n 1. False", "using uniqImpliesExclusiveTrueOrFalse[of \"m\" \"True\" \"M\"]"], ["proof (prove)\nusing this:\n  (m, True) \\<in> set M\n  uniq (elements M)\n  (m, False) \\<in> set M\n  \\<lbrakk>(m, True) \\<in> set M; uniq (elements M)\\<rbrakk>\n  \\<Longrightarrow> (m, \\<not> True) \\<notin> set M\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uniq (elements M); m \\<in> set (elements p);\n     (m, True) \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> (m, True) \\<in> set p", "}"], ["proof (state)\nthis:\n  (m, False) \\<in> set p \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uniq (elements M); m \\<in> set (elements p);\n     (m, True) \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> (m, True) \\<in> set p", "with \\<open>m \\<in> set (elements p)\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> set (elements p)\n  (m, False) \\<in> set p \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<in> set (elements p)\n  (m, False) \\<in> set p \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (m, True) \\<in> set p", "using eitherMarkedOrNotMarked[of \"m\" \"p\"]"], ["proof (prove)\nusing this:\n  m \\<in> set (elements p)\n  (m, False) \\<in> set p \\<Longrightarrow> False\n  m \\<in> set (elements p) \\<Longrightarrow>\n  (m, True) \\<in> set p \\<or> (m, False) \\<in> set p\n\ngoal (1 subgoal):\n 1. (m, True) \\<in> set p", "by auto"], ["proof (state)\nthis:\n  (m, True) \\<in> set p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (m, True) \\<in> set p\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (m, True) \\<in> set p\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements p)", "using markedElementIsMarkedTrue[of \"m\" \"p\"]"], ["proof (prove)\nusing this:\n  (m, True) \\<in> set p\n  (m \\<in> set (markedElements p)) = ((m, True) \\<in> set p)\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements p)", "by simp"], ["proof (state)\nthis:\n  m \\<in> set (markedElements p)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Prefix before/upto a trail element\\<close>"], ["", "text\\<open>Elements of the trail before the first occurrence of a given element - not incuding it\\<close>"], ["", "primrec\nprefixBeforeElement  :: \"'a \\<Rightarrow> 'a Trail \\<Rightarrow> 'a Trail\"\nwhere\n  \"prefixBeforeElement e [] = []\"\n| \"prefixBeforeElement e (h#t) = \n (if (element h) = e then\n     []\n  else\n     (h # (prefixBeforeElement e t))\n )\""], ["", "lemma \"prefixBeforeElement e t = takeWhile (\\<lambda> e'. element e' \\<noteq> e) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixBeforeElement e t =\n    takeWhile (\\<lambda>e'. element e' \\<noteq> e) t", "by (induct t) auto"], ["", "lemma \"prefixBeforeElement e t = take (firstPos e (elements t)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixBeforeElement e t = take (firstPos e (elements t)) t", "by (induct t) auto"], ["", "text\\<open>Elements of the trail before the first occurrence of a given element - incuding it\\<close>"], ["", "primrec\nprefixToElement  :: \"'a \\<Rightarrow> 'a Trail \\<Rightarrow> 'a Trail\"\nwhere\n  \"prefixToElement e [] = []\"\n| \"prefixToElement e (h#t) = \n   (if (element h) = e then\n      [h]\n    else\n      (h # (prefixToElement e t))\n   )\""], ["", "lemma \"prefixToElement e t = take ((firstPos e (elements t)) + 1) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToElement e t = take (firstPos e (elements t) + 1) t", "by (induct t) auto"], ["", "lemma isPrefixPrefixToElement:\n  shows \"isPrefix (prefixToElement e t) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToElement e t) t", "unfolding isPrefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. prefixToElement e t @ s = t", "by (induct t) auto"], ["", "lemma isPrefixPrefixBeforeElement:\n  shows \"isPrefix (prefixBeforeElement e t) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixBeforeElement e t) t", "unfolding isPrefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. prefixBeforeElement e t @ s = t", "by (induct t) auto"], ["", "lemma prefixToElementContainsTrailElement:\n  assumes \"e \\<in> set (elements M)\"\n  shows \"e \\<in> set (elements (prefixToElement e M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToElement e M))", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToElement e M))", "by (induct M) auto"], ["", "lemma prefixBeforeElementDoesNotContainTrailElement:\n  assumes \"e \\<in> set (elements M)\"\n  shows \"e \\<notin> set (elements (prefixBeforeElement e M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixBeforeElement e M))", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixBeforeElement e M))", "by (induct M) auto"], ["", "lemma prefixToElementAppend: \n  shows \"prefixToElement e (M1 @ M2) = \n            (if e \\<in> set (elements M1) then \n                prefixToElement e M1\n             else   \n                M1 @ prefixToElement e M2\n             )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToElement e (M1 @ M2) =\n    (if e \\<in> set (elements M1) then prefixToElement e M1\n     else M1 @ prefixToElement e M2)", "by (induct M1) auto"], ["", "lemma prefixToElementToPrefixElement:\n  assumes\n  \"isPrefix p M\" and \"e \\<in> set (elements p)\"\n  shows\n  \"prefixToElement e M = prefixToElement e p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToElement e M = prefixToElement e p", "using assms"], ["proof (prove)\nusing this:\n  isPrefix p M\n  e \\<in> set (elements p)\n\ngoal (1 subgoal):\n 1. prefixToElement e M = prefixToElement e p", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. p @ s = M\n  e \\<in> set (elements p)\n\ngoal (1 subgoal):\n 1. prefixToElement e M = prefixToElement e p", "proof (induct p arbitrary: M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>\\<exists>s. [] @ s = M; e \\<in> set (elements [])\\<rbrakk>\n       \\<Longrightarrow> prefixToElement e M = prefixToElement e []\n 2. \\<And>a p M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<exists>s. p @ s = M;\n                    e \\<in> set (elements p)\\<rbrakk>\n                   \\<Longrightarrow> prefixToElement e M =\n                                     prefixToElement e p;\n        \\<exists>s. (a # p) @ s = M; e \\<in> set (elements (a # p))\\<rbrakk>\n       \\<Longrightarrow> prefixToElement e M = prefixToElement e (a # p)", "case (Cons a p')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>s. p' @ s = ?M; e \\<in> set (elements p')\\<rbrakk>\n  \\<Longrightarrow> prefixToElement e ?M = prefixToElement e p'\n  \\<exists>s. (a # p') @ s = M\n  e \\<in> set (elements (a # p'))\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>\\<exists>s. [] @ s = M; e \\<in> set (elements [])\\<rbrakk>\n       \\<Longrightarrow> prefixToElement e M = prefixToElement e []\n 2. \\<And>a p M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<exists>s. p @ s = M;\n                    e \\<in> set (elements p)\\<rbrakk>\n                   \\<Longrightarrow> prefixToElement e M =\n                                     prefixToElement e p;\n        \\<exists>s. (a # p) @ s = M; e \\<in> set (elements (a # p))\\<rbrakk>\n       \\<Longrightarrow> prefixToElement e M = prefixToElement e (a # p)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<exists>s. p' @ s = ?M; e \\<in> set (elements p')\\<rbrakk>\n  \\<Longrightarrow> prefixToElement e ?M = prefixToElement e p'\n  \\<exists>s. (a # p') @ s = M\n  e \\<in> set (elements (a # p'))", "obtain s \n    where \"(a # p') @ s = M\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>s. p' @ s = ?M; e \\<in> set (elements p')\\<rbrakk>\n  \\<Longrightarrow> prefixToElement e ?M = prefixToElement e p'\n  \\<exists>s. (a # p') @ s = M\n  e \\<in> set (elements (a # p'))\n\ngoal (1 subgoal):\n 1. (\\<And>s. (a # p') @ s = M \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a # p') @ s = M\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>\\<exists>s. [] @ s = M; e \\<in> set (elements [])\\<rbrakk>\n       \\<Longrightarrow> prefixToElement e M = prefixToElement e []\n 2. \\<And>a p M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<exists>s. p @ s = M;\n                    e \\<in> set (elements p)\\<rbrakk>\n                   \\<Longrightarrow> prefixToElement e M =\n                                     prefixToElement e p;\n        \\<exists>s. (a # p) @ s = M; e \\<in> set (elements (a # p))\\<rbrakk>\n       \\<Longrightarrow> prefixToElement e M = prefixToElement e (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToElement e M = prefixToElement e (a # p')", "proof (cases \"(element a) = e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. element a = e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')\n 2. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "case True"], ["proof (state)\nthis:\n  element a = e\n\ngoal (2 subgoals):\n 1. element a = e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')\n 2. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "from True \\<open>(a # p') @ s = M\\<close>"], ["proof (chain)\npicking this:\n  element a = e\n  (a # p') @ s = M", "have \"prefixToElement e M = [a]\""], ["proof (prove)\nusing this:\n  element a = e\n  (a # p') @ s = M\n\ngoal (1 subgoal):\n 1. prefixToElement e M = [a]", "by auto"], ["proof (state)\nthis:\n  prefixToElement e M = [a]\n\ngoal (2 subgoals):\n 1. element a = e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')\n 2. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "moreover"], ["proof (state)\nthis:\n  prefixToElement e M = [a]\n\ngoal (2 subgoals):\n 1. element a = e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')\n 2. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "from True"], ["proof (chain)\npicking this:\n  element a = e", "have \"prefixToElement e (a # p') = [a]\""], ["proof (prove)\nusing this:\n  element a = e\n\ngoal (1 subgoal):\n 1. prefixToElement e (a # p') = [a]", "by auto"], ["proof (state)\nthis:\n  prefixToElement e (a # p') = [a]\n\ngoal (2 subgoals):\n 1. element a = e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')\n 2. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "ultimately"], ["proof (chain)\npicking this:\n  prefixToElement e M = [a]\n  prefixToElement e (a # p') = [a]", "show ?thesis"], ["proof (prove)\nusing this:\n  prefixToElement e M = [a]\n  prefixToElement e (a # p') = [a]\n\ngoal (1 subgoal):\n 1. prefixToElement e M = prefixToElement e (a # p')", "by simp"], ["proof (state)\nthis:\n  prefixToElement e M = prefixToElement e (a # p')\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "case False"], ["proof (state)\nthis:\n  element a \\<noteq> e\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "from False \\<open>(a # p') @ s = M\\<close>"], ["proof (chain)\npicking this:\n  element a \\<noteq> e\n  (a # p') @ s = M", "have \"prefixToElement e M = a # prefixToElement e (p' @ s)\""], ["proof (prove)\nusing this:\n  element a \\<noteq> e\n  (a # p') @ s = M\n\ngoal (1 subgoal):\n 1. prefixToElement e M = a # prefixToElement e (p' @ s)", "by auto"], ["proof (state)\nthis:\n  prefixToElement e M = a # prefixToElement e (p' @ s)\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "moreover"], ["proof (state)\nthis:\n  prefixToElement e M = a # prefixToElement e (p' @ s)\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "from False"], ["proof (chain)\npicking this:\n  element a \\<noteq> e", "have \"prefixToElement e (a # p') = a # prefixToElement e p'\""], ["proof (prove)\nusing this:\n  element a \\<noteq> e\n\ngoal (1 subgoal):\n 1. prefixToElement e (a # p') = a # prefixToElement e p'", "by simp"], ["proof (state)\nthis:\n  prefixToElement e (a # p') = a # prefixToElement e p'\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "moreover"], ["proof (state)\nthis:\n  prefixToElement e (a # p') = a # prefixToElement e p'\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "from False \\<open>e \\<in> set (elements (a # p'))\\<close>"], ["proof (chain)\npicking this:\n  element a \\<noteq> e\n  e \\<in> set (elements (a # p'))", "have \"e \\<in> set (elements p')\""], ["proof (prove)\nusing this:\n  element a \\<noteq> e\n  e \\<in> set (elements (a # p'))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements p')", "by simp"], ["proof (state)\nthis:\n  e \\<in> set (elements p')\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "have \"? s . (p' @ s = p' @ s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. p' @ s = p' @ s", "by simp"], ["proof (state)\nthis:\n  \\<exists>s. p' @ s = p' @ s\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "from \\<open>e \\<in> set (elements p')\\<close>  \\<open>? s. (p' @ s = p' @ s)\\<close>"], ["proof (chain)\npicking this:\n  e \\<in> set (elements p')\n  \\<exists>s. p' @ s = p' @ s", "have \"prefixToElement e (p' @ s) = prefixToElement e p'\""], ["proof (prove)\nusing this:\n  e \\<in> set (elements p')\n  \\<exists>s. p' @ s = p' @ s\n\ngoal (1 subgoal):\n 1. prefixToElement e (p' @ s) = prefixToElement e p'", "using Cons(1) [of \"p' @ s\"]"], ["proof (prove)\nusing this:\n  e \\<in> set (elements p')\n  \\<exists>s. p' @ s = p' @ s\n  \\<lbrakk>\\<exists>sa. p' @ sa = p' @ s; e \\<in> set (elements p')\\<rbrakk>\n  \\<Longrightarrow> prefixToElement e (p' @ s) = prefixToElement e p'\n\ngoal (1 subgoal):\n 1. prefixToElement e (p' @ s) = prefixToElement e p'", "by simp"], ["proof (state)\nthis:\n  prefixToElement e (p' @ s) = prefixToElement e p'\n\ngoal (1 subgoal):\n 1. element a \\<noteq> e \\<Longrightarrow>\n    prefixToElement e M = prefixToElement e (a # p')", "ultimately"], ["proof (chain)\npicking this:\n  prefixToElement e M = a # prefixToElement e (p' @ s)\n  prefixToElement e (a # p') = a # prefixToElement e p'\n  prefixToElement e (p' @ s) = prefixToElement e p'", "show ?thesis"], ["proof (prove)\nusing this:\n  prefixToElement e M = a # prefixToElement e (p' @ s)\n  prefixToElement e (a # p') = a # prefixToElement e p'\n  prefixToElement e (p' @ s) = prefixToElement e p'\n\ngoal (1 subgoal):\n 1. prefixToElement e M = prefixToElement e (a # p')", "by simp"], ["proof (state)\nthis:\n  prefixToElement e M = prefixToElement e (a # p')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixToElement e M = prefixToElement e (a # p')\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>\\<exists>s. [] @ s = M; e \\<in> set (elements [])\\<rbrakk>\n       \\<Longrightarrow> prefixToElement e M = prefixToElement e []", "qed simp"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Marked elements upto a given trail element\\<close>"], ["", "text\\<open>Marked elements of the trail upto the given element (which is also included if it is marked)\\<close>"], ["", "definition\nmarkedElementsTo :: \"'a \\<Rightarrow> 'a Trail \\<Rightarrow> 'a list\"\nwhere\n\"markedElementsTo e t = markedElements (prefixToElement e t)\""], ["", "lemma markedElementsToArePrefixOfMarkedElements:\n  shows \"isPrefix (markedElementsTo e M) (markedElements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (markedElementsTo e M) (markedElements M)", "unfolding isPrefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. markedElementsTo e M @ s = markedElements M", "unfolding markedElementsTo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. markedElements (prefixToElement e M) @ s = markedElements M", "by (induct M) auto"], ["", "lemma markedElementsToAreMarkedElements: \n  assumes \"m \\<in> set (markedElementsTo e M)\"\n  shows \"m \\<in> set (markedElements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "using assms"], ["proof (prove)\nusing this:\n  m \\<in> set (markedElementsTo e M)\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "using markedElementsToArePrefixOfMarkedElements[of \"e\" \"M\"]"], ["proof (prove)\nusing this:\n  m \\<in> set (markedElementsTo e M)\n  isPrefix (markedElementsTo e M) (markedElements M)\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "using prefixIsSubset"], ["proof (prove)\nusing this:\n  m \\<in> set (markedElementsTo e M)\n  isPrefix (markedElementsTo e M) (markedElements M)\n  isPrefix ?p ?l \\<Longrightarrow> set ?p \\<subseteq> set ?l\n\ngoal (1 subgoal):\n 1. m \\<in> set (markedElements M)", "by auto"], ["", "lemma markedElementsToNonMemberAreAllMarkedElements:\n  assumes \"e \\<notin> set (elements M)\"\n  shows \"markedElementsTo e M = markedElements M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElementsTo e M = markedElements M", "using assms"], ["proof (prove)\nusing this:\n  e \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. markedElementsTo e M = markedElements M", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  e \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. markedElements (prefixToElement e M) = markedElements M", "by (induct M) auto"], ["", "lemma markedElementsToAppend: \n  shows \"markedElementsTo e (M1 @ M2) = \n          (if e \\<in> set (elements M1) then \n                 markedElementsTo e M1\n           else \n                 markedElements M1 @ markedElementsTo e M2\n          )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElementsTo e (M1 @ M2) =\n    (if e \\<in> set (elements M1) then markedElementsTo e M1\n     else markedElements M1 @ markedElementsTo e M2)", "unfolding markedElementsTo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElements (prefixToElement e (M1 @ M2)) =\n    (if e \\<in> set (elements M1) then markedElements (prefixToElement e M1)\n     else markedElements M1 @ markedElements (prefixToElement e M2))", "by (auto simp add: prefixToElementAppend markedElementsAppend)"], ["", "lemma markedElementsEmptyImpliesMarkedElementsToEmpty: \n  assumes \"markedElements M = []\"\n  shows \"markedElementsTo e M = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElementsTo e M = []", "using assms"], ["proof (prove)\nusing this:\n  markedElements M = []\n\ngoal (1 subgoal):\n 1. markedElementsTo e M = []", "using markedElementsToArePrefixOfMarkedElements [of \"e\" \"M\"]"], ["proof (prove)\nusing this:\n  markedElements M = []\n  isPrefix (markedElementsTo e M) (markedElements M)\n\ngoal (1 subgoal):\n 1. markedElementsTo e M = []", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  markedElements M = []\n  \\<exists>s. markedElementsTo e M @ s = markedElements M\n\ngoal (1 subgoal):\n 1. markedElementsTo e M = []", "by auto"], ["", "lemma markedElementIsMemberOfItsMarkedElementsTo: \n  assumes\n  \"uniq (elements M)\" and \"marked e\" and \"e \\<in> set M\"\n  shows \n  \"element e \\<in> set (markedElementsTo (element e) M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element e \\<in> set (markedElementsTo (element e) M)", "using assms"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  marked e\n  e \\<in> set M\n\ngoal (1 subgoal):\n 1. element e \\<in> set (markedElementsTo (element e) M)", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  marked e\n  e \\<in> set M\n\ngoal (1 subgoal):\n 1. element e \\<in> set (markedElements (prefixToElement (element e) M))", "by (induct M) (auto split: if_split_asm)"], ["", "lemma markedElementsToPrefixElement: \n  assumes \"isPrefix p M\" and \"e \\<in> set (elements p)\"\n  shows \"markedElementsTo e M = markedElementsTo e p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElementsTo e M = markedElementsTo e p", "unfolding markedElementsTo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElements (prefixToElement e M) =\n    markedElements (prefixToElement e p)", "using assms"], ["proof (prove)\nusing this:\n  isPrefix p M\n  e \\<in> set (elements p)\n\ngoal (1 subgoal):\n 1. markedElements (prefixToElement e M) =\n    markedElements (prefixToElement e p)", "by (simp add: prefixToElementToPrefixElement)"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Last marked element in a trail\\<close>"], ["", "definition\nlastMarked :: \"'a Trail \\<Rightarrow> 'a\"\nwhere\n\"lastMarked t = last (markedElements t)\""], ["", "lemma lastMarkedIsMarkedElement: \n  assumes \"markedElements M \\<noteq> []\" \n  shows \"lastMarked M \\<in> set (markedElements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lastMarked M \\<in> set (markedElements M)", "using assms"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. lastMarked M \\<in> set (markedElements M)", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (markedElements M) \\<in> set (markedElements M)", "by simp"], ["", "lemma removeLastMarkedFromMarkedElementsToLastMarkedAreAllMarkedElementsInPrefixLastMarked: \n  assumes\n  \"markedElements M \\<noteq> []\"\n  shows\n  \"removeAll (lastMarked M) (markedElementsTo (lastMarked M) M) = markedElements (prefixBeforeElement (lastMarked M) M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll (lastMarked M) (markedElementsTo (lastMarked M) M) =\n    markedElements (prefixBeforeElement (lastMarked M) M)", "using assms"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. removeAll (lastMarked M) (markedElementsTo (lastMarked M) M) =\n    markedElements (prefixBeforeElement (lastMarked M) M)", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. removeAll (last (markedElements M))\n     (markedElementsTo (last (markedElements M)) M) =\n    markedElements (prefixBeforeElement (last (markedElements M)) M)", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. removeAll (last (markedElements M))\n     (markedElements (prefixToElement (last (markedElements M)) M)) =\n    markedElements (prefixBeforeElement (last (markedElements M)) M)", "by (induct M) auto"], ["", "lemma markedElementsToLastMarkedAreAllMarkedElements:\n  assumes\n  \"uniq (elements M)\" and \"markedElements M \\<noteq> []\"\n  shows\n  \"markedElementsTo (lastMarked M) M = markedElements M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElementsTo (lastMarked M) M = markedElements M", "using assms"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. markedElementsTo (lastMarked M) M = markedElements M", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. markedElementsTo (last (markedElements M)) M = markedElements M", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. markedElements (prefixToElement (last (markedElements M)) M) =\n    markedElements M", "by (induct M) (auto simp add: markedElementsAreElements)"], ["", "lemma lastTrailElementMarkedImpliesMarkedElementsToLastElementAreAllMarkedElements:\n  assumes\n  \"marked (last M)\" and \"last (elements M) \\<notin> set (butlast (elements M))\"\n  shows\n  \"markedElementsTo (last (elements M)) M = markedElements M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElementsTo (last (elements M)) M = markedElements M", "using assms"], ["proof (prove)\nusing this:\n  marked (last M)\n  last (elements M) \\<notin> set (butlast (elements M))\n\ngoal (1 subgoal):\n 1. markedElementsTo (last (elements M)) M = markedElements M", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  marked (last M)\n  last (elements M) \\<notin> set (butlast (elements M))\n\ngoal (1 subgoal):\n 1. markedElements (prefixToElement (last (elements M)) M) =\n    markedElements M", "by (induct M) auto"], ["", "lemma lastMarkedIsMemberOfItsMarkedElementsTo: \n  assumes\n  \"uniq (elements M)\" and \"markedElements M \\<noteq> []\"\n  shows\n  \"lastMarked M \\<in> set (markedElementsTo (lastMarked M) M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lastMarked M \\<in> set (markedElementsTo (lastMarked M) M)", "using assms"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. lastMarked M \\<in> set (markedElementsTo (lastMarked M) M)", "using markedElementsToLastMarkedAreAllMarkedElements [of \"M\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n  \\<lbrakk>uniq (elements M); markedElements M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> markedElementsTo (lastMarked M) M = markedElements M\n\ngoal (1 subgoal):\n 1. lastMarked M \\<in> set (markedElementsTo (lastMarked M) M)", "using lastMarkedIsMarkedElement [of \"M\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n  \\<lbrakk>uniq (elements M); markedElements M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> markedElementsTo (lastMarked M) M = markedElements M\n  markedElements M \\<noteq> [] \\<Longrightarrow>\n  lastMarked M \\<in> set (markedElements M)\n\ngoal (1 subgoal):\n 1. lastMarked M \\<in> set (markedElementsTo (lastMarked M) M)", "by auto"], ["", "lemma lastTrailElementNotMarkedImpliesMarkedElementsToLAreMarkedElementsToLInButlastTrail: \n  assumes \"\\<not> marked (last M)\"\n  shows \"markedElementsTo e M = markedElementsTo e (butlast M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElementsTo e M = markedElementsTo e (butlast M)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> marked (last M)\n\ngoal (1 subgoal):\n 1. markedElementsTo e M = markedElementsTo e (butlast M)", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  \\<not> marked (last M)\n\ngoal (1 subgoal):\n 1. markedElements (prefixToElement e M) =\n    markedElements (prefixToElement e (butlast M))", "by (induct M) auto"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Level of a trail element\\<close>"], ["", "text\\<open>Level of an element is the number of marked elements that precede it\\<close>"], ["", "definition\nelementLevel :: \"'a \\<Rightarrow> 'a Trail \\<Rightarrow> nat\"\nwhere\n\"elementLevel e t = length (markedElementsTo e t)\""], ["", "lemma elementLevelMarkedGeq1:\n  assumes\n  \"uniq (elements M)\" and \"e \\<in> set (markedElements M)\"\n  shows\n  \"elementLevel e M >= 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel e M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel e M", "from \\<open>e \\<in> set (markedElements M)\\<close>"], ["proof (chain)\npicking this:\n  e \\<in> set (markedElements M)", "have \"(e, True) \\<in> set M\""], ["proof (prove)\nusing this:\n  e \\<in> set (markedElements M)\n\ngoal (1 subgoal):\n 1. (e, True) \\<in> set M", "by (simp add: markedElementIsMarkedTrue)"], ["proof (state)\nthis:\n  (e, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel e M", "with \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  (e, True) \\<in> set M", "have \"e \\<in> set (markedElementsTo e M)\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  (e, True) \\<in> set M\n\ngoal (1 subgoal):\n 1. e \\<in> set (markedElementsTo e M)", "using markedElementIsMemberOfItsMarkedElementsTo[of \"M\" \"(e, True)\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  (e, True) \\<in> set M\n  \\<lbrakk>uniq (elements M); marked (e, True);\n   (e, True) \\<in> set M\\<rbrakk>\n  \\<Longrightarrow> element (e, True)\n                    \\<in> set (markedElementsTo (element (e, True)) M)\n\ngoal (1 subgoal):\n 1. e \\<in> set (markedElementsTo e M)", "by simp"], ["proof (state)\nthis:\n  e \\<in> set (markedElementsTo e M)\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel e M", "hence \"markedElementsTo e M \\<noteq> []\""], ["proof (prove)\nusing this:\n  e \\<in> set (markedElementsTo e M)\n\ngoal (1 subgoal):\n 1. markedElementsTo e M \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  markedElementsTo e M \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel e M", "thus ?thesis"], ["proof (prove)\nusing this:\n  markedElementsTo e M \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel e M", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  markedElementsTo e M \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 \\<le> length (markedElementsTo e M)", "using length_greater_0_conv[of \"markedElementsTo e M\"]"], ["proof (prove)\nusing this:\n  markedElementsTo e M \\<noteq> []\n  (0 < length (markedElementsTo e M)) = (markedElementsTo e M \\<noteq> [])\n\ngoal (1 subgoal):\n 1. 1 \\<le> length (markedElementsTo e M)", "by arith"], ["proof (state)\nthis:\n  1 \\<le> elementLevel e M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elementLevelAppend:\n  assumes \"a \\<in> set (elements M)\"\n  shows \"elementLevel a M = elementLevel a (M @ M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel a M = elementLevel a (M @ M')", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M = elementLevel a (M @ M')", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  a \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. length (markedElementsTo a M) = length (markedElementsTo a (M @ M'))", "by (simp add: markedElementsToAppend)"], ["", "lemma elementLevelPrecedesLeq: \n  assumes\n  \"precedes a b (elements M)\" \n  shows\n  \"elementLevel a M \\<le> elementLevel b M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> elementLevel b M", "using assms"], ["proof (prove)\nusing this:\n  precedes a b (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> elementLevel b M", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "case (Cons m M')"], ["proof (state)\nthis:\n  precedes a b (elements M') \\<Longrightarrow>\n  elementLevel a M' \\<le> elementLevel b M'\n  precedes a b (elements (m # M'))\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "{"], ["proof (state)\nthis:\n  precedes a b (elements M') \\<Longrightarrow>\n  elementLevel a M' \\<le> elementLevel b M'\n  precedes a b (elements (m # M'))\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "assume \"a = element m\""], ["proof (state)\nthis:\n  a = element m\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "hence ?case"], ["proof (prove)\nusing this:\n  a = element m\n\ngoal (1 subgoal):\n 1. elementLevel a (m # M') \\<le> elementLevel b (m # M')", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  a = element m\n\ngoal (1 subgoal):\n 1. length (markedElementsTo a (m # M'))\n    \\<le> length (markedElementsTo b (m # M'))", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  a = element m\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement a (m # M')))\n    \\<le> length (markedElements (prefixToElement b (m # M')))", "by simp"], ["proof (state)\nthis:\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "}"], ["proof (state)\nthis:\n  a = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "moreover"], ["proof (state)\nthis:\n  a = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "{"], ["proof (state)\nthis:\n  a = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "assume \"b = element m\""], ["proof (state)\nthis:\n  b = element m\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "{"], ["proof (state)\nthis:\n  b = element m\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "assume \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "hence \"\\<not> precedes a b (b # (elements M'))\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> precedes a b (b # elements M')", "by (rule noElementsPrecedesFirstElement)"], ["proof (state)\nthis:\n  \\<not> precedes a b (b # elements M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "with \\<open>b = element m\\<close> \\<open>precedes a b (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  b = element m\n  precedes a b (elements (m # M'))\n  \\<not> precedes a b (b # elements M')", "have False"], ["proof (prove)\nusing this:\n  b = element m\n  precedes a b (elements (m # M'))\n  \\<not> precedes a b (b # elements M')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "}"], ["proof (state)\nthis:\n  a \\<noteq> b \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "hence \"a = b\""], ["proof (prove)\nusing this:\n  a \\<noteq> b \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a = b", "by auto"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "hence ?case"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. elementLevel a (m # M') \\<le> elementLevel b (m # M')", "by simp"], ["proof (state)\nthis:\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "}"], ["proof (state)\nthis:\n  b = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "moreover"], ["proof (state)\nthis:\n  b = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "{"], ["proof (state)\nthis:\n  b = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "assume \"a \\<noteq> element m\" \"b \\<noteq> element m\""], ["proof (state)\nthis:\n  a \\<noteq> element m\n  b \\<noteq> element m\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "moreover"], ["proof (state)\nthis:\n  a \\<noteq> element m\n  b \\<noteq> element m\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "from \\<open>precedes a b (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  precedes a b (elements (m # M'))", "have \"a \\<in> set (elements (m # M'))\" \"b \\<in> set (elements (m # M'))\""], ["proof (prove)\nusing this:\n  precedes a b (elements (m # M'))\n\ngoal (1 subgoal):\n 1. a \\<in> set (elements (m # M')) &&& b \\<in> set (elements (m # M'))", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  a \\<in> set (elements (m # M')) \\<and>\n  b \\<in> set (elements (m # M')) \\<and>\n  firstPos a (elements (m # M')) \\<le> firstPos b (elements (m # M'))\n\ngoal (1 subgoal):\n 1. a \\<in> set (elements (m # M')) &&& b \\<in> set (elements (m # M'))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  a \\<in> set (elements (m # M'))\n  b \\<in> set (elements (m # M'))\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "from \\<open>a \\<noteq> element m\\<close> \\<open>a \\<in> set (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> element m\n  a \\<in> set (elements (m # M'))", "have \"a \\<in> set (elements M')\""], ["proof (prove)\nusing this:\n  a \\<noteq> element m\n  a \\<in> set (elements (m # M'))\n\ngoal (1 subgoal):\n 1. a \\<in> set (elements M')", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (elements M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "moreover"], ["proof (state)\nthis:\n  a \\<in> set (elements M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "from \\<open>b \\<noteq> element m\\<close> \\<open>b \\<in> set (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  b \\<noteq> element m\n  b \\<in> set (elements (m # M'))", "have \"b \\<in> set (elements M')\""], ["proof (prove)\nusing this:\n  b \\<noteq> element m\n  b \\<in> set (elements (m # M'))\n\ngoal (1 subgoal):\n 1. b \\<in> set (elements M')", "by simp"], ["proof (state)\nthis:\n  b \\<in> set (elements M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<noteq> element m\n  b \\<noteq> element m\n  a \\<in> set (elements M')\n  b \\<in> set (elements M')", "have \"elementLevel a M' \\<le> elementLevel b M'\""], ["proof (prove)\nusing this:\n  a \\<noteq> element m\n  b \\<noteq> element m\n  a \\<in> set (elements M')\n  b \\<in> set (elements M')\n\ngoal (1 subgoal):\n 1. elementLevel a M' \\<le> elementLevel b M'", "using Cons"], ["proof (prove)\nusing this:\n  a \\<noteq> element m\n  b \\<noteq> element m\n  a \\<in> set (elements M')\n  b \\<in> set (elements M')\n  precedes a b (elements M') \\<Longrightarrow>\n  elementLevel a M' \\<le> elementLevel b M'\n  precedes a b (elements (m # M'))\n\ngoal (1 subgoal):\n 1. elementLevel a M' \\<le> elementLevel b M'", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  a \\<noteq> element m\n  b \\<noteq> element m\n  a \\<in> set (elements M')\n  b \\<in> set (elements M')\n  a \\<in> set (elements M') \\<and>\n  b \\<in> set (elements M') \\<and>\n  firstPos a (elements M') \\<le> firstPos b (elements M') \\<Longrightarrow>\n  elementLevel a M' \\<le> elementLevel b M'\n  a \\<in> set (elements (m # M')) \\<and>\n  b \\<in> set (elements (m # M')) \\<and>\n  firstPos a (elements (m # M')) \\<le> firstPos b (elements (m # M'))\n\ngoal (1 subgoal):\n 1. elementLevel a M' \\<le> elementLevel b M'", "by auto"], ["proof (state)\nthis:\n  elementLevel a M' \\<le> elementLevel b M'\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "hence ?case"], ["proof (prove)\nusing this:\n  elementLevel a M' \\<le> elementLevel b M'\n\ngoal (1 subgoal):\n 1. elementLevel a (m # M') \\<le> elementLevel b (m # M')", "using \\<open>a \\<noteq> element m\\<close> \\<open>b \\<noteq> element m\\<close>"], ["proof (prove)\nusing this:\n  elementLevel a M' \\<le> elementLevel b M'\n  a \\<noteq> element m\n  b \\<noteq> element m\n\ngoal (1 subgoal):\n 1. elementLevel a (m # M') \\<le> elementLevel b (m # M')", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  length (markedElementsTo a M') \\<le> length (markedElementsTo b M')\n  a \\<noteq> element m\n  b \\<noteq> element m\n\ngoal (1 subgoal):\n 1. length (markedElementsTo a (m # M'))\n    \\<le> length (markedElementsTo b (m # M'))", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  length (markedElements (prefixToElement a M'))\n  \\<le> length (markedElements (prefixToElement b M'))\n  a \\<noteq> element m\n  b \\<noteq> element m\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement a (m # M')))\n    \\<le> length (markedElements (prefixToElement b (m # M')))", "by auto"], ["proof (state)\nthis:\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> element m; b \\<noteq> element m\\<rbrakk>\n  \\<Longrightarrow> elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (2 subgoals):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []\n 2. \\<And>aa M.\n       \\<lbrakk>precedes a b (elements M) \\<Longrightarrow>\n                elementLevel a M \\<le> elementLevel b M;\n        precedes a b (elements (aa # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel a (aa # M)\n                         \\<le> elementLevel b (aa # M)", "ultimately"], ["proof (chain)\npicking this:\n  a = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n  b = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n  \\<lbrakk>a \\<noteq> element m; b \\<noteq> element m\\<rbrakk>\n  \\<Longrightarrow> elementLevel a (m # M') \\<le> elementLevel b (m # M')", "show ?case"], ["proof (prove)\nusing this:\n  a = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n  b = element m \\<Longrightarrow>\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n  \\<lbrakk>a \\<noteq> element m; b \\<noteq> element m\\<rbrakk>\n  \\<Longrightarrow> elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (1 subgoal):\n 1. elementLevel a (m # M') \\<le> elementLevel b (m # M')", "by auto"], ["proof (state)\nthis:\n  elementLevel a (m # M') \\<le> elementLevel b (m # M')\n\ngoal (1 subgoal):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []", "case Nil"], ["proof (state)\nthis:\n  precedes a b (elements [])\n\ngoal (1 subgoal):\n 1. precedes a b (elements []) \\<Longrightarrow>\n    elementLevel a [] \\<le> elementLevel b []", "thus ?case"], ["proof (prove)\nusing this:\n  precedes a b (elements [])\n\ngoal (1 subgoal):\n 1. elementLevel a [] \\<le> elementLevel b []", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  a \\<in> set (elements []) \\<and>\n  b \\<in> set (elements []) \\<and>\n  firstPos a (elements []) \\<le> firstPos b (elements [])\n\ngoal (1 subgoal):\n 1. elementLevel a [] \\<le> elementLevel b []", "by simp"], ["proof (state)\nthis:\n  elementLevel a [] \\<le> elementLevel b []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elementLevelPrecedesMarkedElementLt: \n  assumes\n  \"uniq (elements M)\" and\n  \"e \\<noteq> d\" and\n  \"d \\<in> set (markedElements M)\" and\n  \"precedes e d (elements M)\"\n  shows\n  \"elementLevel e M < elementLevel d M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel e M < elementLevel d M", "using assms"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  e \\<noteq> d\n  d \\<in> set (markedElements M)\n  precedes e d (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel e M < elementLevel d M", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "case (Cons m M')"], ["proof (state)\nthis:\n  \\<lbrakk>uniq (elements M'); e \\<noteq> d;\n   d \\<in> set (markedElements M'); precedes e d (elements M')\\<rbrakk>\n  \\<Longrightarrow> elementLevel e M' < elementLevel d M'\n  uniq (elements (m # M'))\n  e \\<noteq> d\n  d \\<in> set (markedElements (m # M'))\n  precedes e d (elements (m # M'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>uniq (elements M'); e \\<noteq> d;\n   d \\<in> set (markedElements M'); precedes e d (elements M')\\<rbrakk>\n  \\<Longrightarrow> elementLevel e M' < elementLevel d M'\n  uniq (elements (m # M'))\n  e \\<noteq> d\n  d \\<in> set (markedElements (m # M'))\n  precedes e d (elements (m # M'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "assume \"e = element m\""], ["proof (state)\nthis:\n  e = element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  e = element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "with \\<open>e \\<noteq> d\\<close>"], ["proof (chain)\npicking this:\n  e \\<noteq> d\n  e = element m", "have \"d \\<noteq> element m\""], ["proof (prove)\nusing this:\n  e \\<noteq> d\n  e = element m\n\ngoal (1 subgoal):\n 1. d \\<noteq> element m", "by simp"], ["proof (state)\nthis:\n  d \\<noteq> element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  d \\<noteq> element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>uniq (elements (m # M'))\\<close> \\<open>d \\<in> set (markedElements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements (m # M'))\n  d \\<in> set (markedElements (m # M'))", "have \"1 \\<le> elementLevel d (m # M')\""], ["proof (prove)\nusing this:\n  uniq (elements (m # M'))\n  d \\<in> set (markedElements (m # M'))\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel d (m # M')", "using elementLevelMarkedGeq1[of \"m # M'\" \"d\"]"], ["proof (prove)\nusing this:\n  uniq (elements (m # M'))\n  d \\<in> set (markedElements (m # M'))\n  \\<lbrakk>uniq (elements (m # M'));\n   d \\<in> set (markedElements (m # M'))\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> elementLevel d (m # M')\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel d (m # M')", "by auto"], ["proof (state)\nthis:\n  1 \\<le> elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  1 \\<le> elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>d \\<noteq> element m\\<close> \\<open>d \\<in> set (markedElements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  d \\<noteq> element m\n  d \\<in> set (markedElements (m # M'))", "have \"d \\<in> set (markedElements M')\""], ["proof (prove)\nusing this:\n  d \\<noteq> element m\n  d \\<in> set (markedElements (m # M'))\n\ngoal (1 subgoal):\n 1. d \\<in> set (markedElements M')", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  d \\<in> set (markedElements M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>uniq (elements (m # M'))\\<close> \\<open>d \\<in> set (markedElements M')\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements (m # M'))\n  d \\<in> set (markedElements M')", "have \"1 \\<le> elementLevel d M'\""], ["proof (prove)\nusing this:\n  uniq (elements (m # M'))\n  d \\<in> set (markedElements M')\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel d M'", "using elementLevelMarkedGeq1[of \"M'\" \"d\"]"], ["proof (prove)\nusing this:\n  uniq (elements (m # M'))\n  d \\<in> set (markedElements M')\n  \\<lbrakk>uniq (elements M'); d \\<in> set (markedElements M')\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> elementLevel d M'\n\ngoal (1 subgoal):\n 1. 1 \\<le> elementLevel d M'", "by auto"], ["proof (state)\nthis:\n  1 \\<le> elementLevel d M'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "ultimately"], ["proof (chain)\npicking this:\n  e = element m\n  d \\<noteq> element m\n  1 \\<le> elementLevel d (m # M')\n  1 \\<le> elementLevel d M'", "have ?case"], ["proof (prove)\nusing this:\n  e = element m\n  d \\<noteq> element m\n  1 \\<le> elementLevel d (m # M')\n  1 \\<le> elementLevel d M'\n\ngoal (1 subgoal):\n 1. elementLevel e (m # M') < elementLevel d (m # M')", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  e = element m\n  d \\<noteq> element m\n  1 \\<le> length (markedElementsTo d (m # M'))\n  1 \\<le> length (markedElementsTo d M')\n\ngoal (1 subgoal):\n 1. length (markedElementsTo e (m # M'))\n    < length (markedElementsTo d (m # M'))", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  e = element m\n  d \\<noteq> element m\n  1 \\<le> length (markedElements (prefixToElement d (m # M')))\n  1 \\<le> length (markedElements (prefixToElement d M'))\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement e (m # M')))\n    < length (markedElements (prefixToElement d (m # M')))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "}"], ["proof (state)\nthis:\n  e = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  e = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "{"], ["proof (state)\nthis:\n  e = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "assume \"d = element m\""], ["proof (state)\nthis:\n  d = element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>e \\<noteq> d\\<close>"], ["proof (chain)\npicking this:\n  e \\<noteq> d", "have \"\\<not> precedes e d (d # (elements M'))\""], ["proof (prove)\nusing this:\n  e \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<not> precedes e d (d # elements M')", "using noElementsPrecedesFirstElement[of \"e\" \"d\" \"elements M'\"]"], ["proof (prove)\nusing this:\n  e \\<noteq> d\n  e \\<noteq> d \\<Longrightarrow> \\<not> precedes e d (d # elements M')\n\ngoal (1 subgoal):\n 1. \\<not> precedes e d (d # elements M')", "by simp"], ["proof (state)\nthis:\n  \\<not> precedes e d (d # elements M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "with \\<open>d = element m\\<close> \\<open>precedes e d (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  d = element m\n  precedes e d (elements (m # M'))\n  \\<not> precedes e d (d # elements M')", "have False"], ["proof (prove)\nusing this:\n  d = element m\n  precedes e d (elements (m # M'))\n  \\<not> precedes e d (d # elements M')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "hence ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. elementLevel e (m # M') < elementLevel d (m # M')", "by simp"], ["proof (state)\nthis:\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "}"], ["proof (state)\nthis:\n  d = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  d = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "{"], ["proof (state)\nthis:\n  d = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "assume \"e \\<noteq> element m\" \"d \\<noteq> element m\""], ["proof (state)\nthis:\n  e \\<noteq> element m\n  d \\<noteq> element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  e \\<noteq> element m\n  d \\<noteq> element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>precedes e d (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  precedes e d (elements (m # M'))", "have \"e \\<in> set (elements (m # M'))\" \"d \\<in> set (elements (m # M'))\""], ["proof (prove)\nusing this:\n  precedes e d (elements (m # M'))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (m # M')) &&& d \\<in> set (elements (m # M'))", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  e \\<in> set (elements (m # M')) \\<and>\n  d \\<in> set (elements (m # M')) \\<and>\n  firstPos e (elements (m # M')) \\<le> firstPos d (elements (m # M'))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (m # M')) &&& d \\<in> set (elements (m # M'))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  e \\<in> set (elements (m # M'))\n  d \\<in> set (elements (m # M'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>e \\<noteq> element m\\<close> \\<open>e \\<in> set (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  e \\<noteq> element m\n  e \\<in> set (elements (m # M'))", "have \"e \\<in> set (elements M')\""], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  e \\<in> set (elements (m # M'))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements M')", "by simp"], ["proof (state)\nthis:\n  e \\<in> set (elements M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  e \\<in> set (elements M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>d \\<noteq> element m\\<close> \\<open>d \\<in> set (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  d \\<noteq> element m\n  d \\<in> set (elements (m # M'))", "have \"d \\<in> set (elements M')\""], ["proof (prove)\nusing this:\n  d \\<noteq> element m\n  d \\<in> set (elements (m # M'))\n\ngoal (1 subgoal):\n 1. d \\<in> set (elements M')", "by simp"], ["proof (state)\nthis:\n  d \\<in> set (elements M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "moreover"], ["proof (state)\nthis:\n  d \\<in> set (elements M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "from \\<open>d \\<noteq> element m\\<close> \\<open>d \\<in> set (markedElements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  d \\<noteq> element m\n  d \\<in> set (markedElements (m # M'))", "have \"d \\<in> set (markedElements M')\""], ["proof (prove)\nusing this:\n  d \\<noteq> element m\n  d \\<in> set (markedElements (m # M'))\n\ngoal (1 subgoal):\n 1. d \\<in> set (markedElements M')", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  d \\<in> set (markedElements M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "ultimately"], ["proof (chain)\npicking this:\n  e \\<noteq> element m\n  d \\<noteq> element m\n  e \\<in> set (elements M')\n  d \\<in> set (elements M')\n  d \\<in> set (markedElements M')", "have \"elementLevel e M' < elementLevel d M'\""], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  d \\<noteq> element m\n  e \\<in> set (elements M')\n  d \\<in> set (elements M')\n  d \\<in> set (markedElements M')\n\ngoal (1 subgoal):\n 1. elementLevel e M' < elementLevel d M'", "using \\<open>uniq (elements (m # M'))\\<close> Cons"], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  d \\<noteq> element m\n  e \\<in> set (elements M')\n  d \\<in> set (elements M')\n  d \\<in> set (markedElements M')\n  uniq (elements (m # M'))\n  \\<lbrakk>uniq (elements M'); e \\<noteq> d;\n   d \\<in> set (markedElements M'); precedes e d (elements M')\\<rbrakk>\n  \\<Longrightarrow> elementLevel e M' < elementLevel d M'\n  uniq (elements (m # M'))\n  e \\<noteq> d\n  d \\<in> set (markedElements (m # M'))\n  precedes e d (elements (m # M'))\n\ngoal (1 subgoal):\n 1. elementLevel e M' < elementLevel d M'", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  d \\<noteq> element m\n  e \\<in> set (elements M')\n  d \\<in> set (elements M')\n  d \\<in> set (markedElements M')\n  uniq (elements (m # M'))\n  \\<lbrakk>uniq (elements M'); e \\<noteq> d;\n   d \\<in> set (markedElements M');\n   e \\<in> set (elements M') \\<and>\n   d \\<in> set (elements M') \\<and>\n   firstPos e (elements M') \\<le> firstPos d (elements M')\\<rbrakk>\n  \\<Longrightarrow> elementLevel e M' < elementLevel d M'\n  uniq (elements (m # M'))\n  e \\<noteq> d\n  d \\<in> set (markedElements (m # M'))\n  e \\<in> set (elements (m # M')) \\<and>\n  d \\<in> set (elements (m # M')) \\<and>\n  firstPos e (elements (m # M')) \\<le> firstPos d (elements (m # M'))\n\ngoal (1 subgoal):\n 1. elementLevel e M' < elementLevel d M'", "by auto"], ["proof (state)\nthis:\n  elementLevel e M' < elementLevel d M'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "hence ?case"], ["proof (prove)\nusing this:\n  elementLevel e M' < elementLevel d M'\n\ngoal (1 subgoal):\n 1. elementLevel e (m # M') < elementLevel d (m # M')", "using \\<open>e \\<noteq> element m\\<close> \\<open>d \\<noteq> element m\\<close>"], ["proof (prove)\nusing this:\n  elementLevel e M' < elementLevel d M'\n  e \\<noteq> element m\n  d \\<noteq> element m\n\ngoal (1 subgoal):\n 1. elementLevel e (m # M') < elementLevel d (m # M')", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  length (markedElementsTo e M') < length (markedElementsTo d M')\n  e \\<noteq> element m\n  d \\<noteq> element m\n\ngoal (1 subgoal):\n 1. length (markedElementsTo e (m # M'))\n    < length (markedElementsTo d (m # M'))", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  length (markedElements (prefixToElement e M'))\n  < length (markedElements (prefixToElement d M'))\n  e \\<noteq> element m\n  d \\<noteq> element m\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement e (m # M')))\n    < length (markedElements (prefixToElement d (m # M')))", "by auto"], ["proof (state)\nthis:\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>e \\<noteq> element m; d \\<noteq> element m\\<rbrakk>\n  \\<Longrightarrow> elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>uniq (elements M); e \\<noteq> d;\n                 d \\<in> set (markedElements M);\n                 precedes e d (elements M)\\<rbrakk>\n                \\<Longrightarrow> elementLevel e M < elementLevel d M;\n        uniq (elements (a # M)); e \\<noteq> d;\n        d \\<in> set (markedElements (a # M));\n        precedes e d (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> elementLevel e (a # M) < elementLevel d (a # M)", "ultimately"], ["proof (chain)\npicking this:\n  e = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n  d = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n  \\<lbrakk>e \\<noteq> element m; d \\<noteq> element m\\<rbrakk>\n  \\<Longrightarrow> elementLevel e (m # M') < elementLevel d (m # M')", "show ?case"], ["proof (prove)\nusing this:\n  e = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n  d = element m \\<Longrightarrow>\n  elementLevel e (m # M') < elementLevel d (m # M')\n  \\<lbrakk>e \\<noteq> element m; d \\<noteq> element m\\<rbrakk>\n  \\<Longrightarrow> elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (1 subgoal):\n 1. elementLevel e (m # M') < elementLevel d (m # M')", "by auto"], ["proof (state)\nthis:\n  elementLevel e (m # M') < elementLevel d (m # M')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uniq (elements []); e \\<noteq> d;\n     d \\<in> set (markedElements []); precedes e d (elements [])\\<rbrakk>\n    \\<Longrightarrow> elementLevel e [] < elementLevel d []", "qed simp"], ["", "lemma differentMarkedElementsHaveDifferentLevels:\n  assumes\n  \"uniq (elements M)\" and\n  \"a \\<in> set (markedElements M)\" and\n  \"b \\<in> set (markedElements M)\" and\n  \"a \\<noteq> b\" \n  shows \"elementLevel a M \\<noteq> elementLevel b M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "from \\<open>a \\<in> set (markedElements M)\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> set (markedElements M)", "have \"a \\<in> set (elements M)\""], ["proof (prove)\nusing this:\n  a \\<in> set (markedElements M)\n\ngoal (1 subgoal):\n 1. a \\<in> set (elements M)", "by (simp add: markedElementsAreElements)"], ["proof (state)\nthis:\n  a \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "moreover"], ["proof (state)\nthis:\n  a \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "from \\<open>b \\<in> set (markedElements M)\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> set (markedElements M)", "have \"b \\<in> set (elements M)\""], ["proof (prove)\nusing this:\n  b \\<in> set (markedElements M)\n\ngoal (1 subgoal):\n 1. b \\<in> set (elements M)", "by (simp add: markedElementsAreElements)"], ["proof (state)\nthis:\n  b \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> set (elements M)\n  b \\<in> set (elements M)", "have \"precedes a b (elements M) \\<or> precedes b a (elements M)\""], ["proof (prove)\nusing this:\n  a \\<in> set (elements M)\n  b \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. precedes a b (elements M) \\<or> precedes b a (elements M)", "using \\<open>a \\<noteq> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> set (elements M)\n  b \\<in> set (elements M)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. precedes a b (elements M) \\<or> precedes b a (elements M)", "using precedesTotalOrder[of \"a\" \"elements M\" \"b\"]"], ["proof (prove)\nusing this:\n  a \\<in> set (elements M)\n  b \\<in> set (elements M)\n  a \\<noteq> b\n  \\<lbrakk>a \\<in> set (elements M); b \\<in> set (elements M)\\<rbrakk>\n  \\<Longrightarrow> a = b \\<or>\n                    precedes a b (elements M) \\<or>\n                    precedes b a (elements M)\n\ngoal (1 subgoal):\n 1. precedes a b (elements M) \\<or> precedes b a (elements M)", "by simp"], ["proof (state)\nthis:\n  precedes a b (elements M) \\<or> precedes b a (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "moreover"], ["proof (state)\nthis:\n  precedes a b (elements M) \\<or> precedes b a (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "{"], ["proof (state)\nthis:\n  precedes a b (elements M) \\<or> precedes b a (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "assume \"precedes a b (elements M)\""], ["proof (state)\nthis:\n  precedes a b (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "with assms"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  a \\<in> set (markedElements M)\n  b \\<in> set (markedElements M)\n  a \\<noteq> b\n  precedes a b (elements M)", "have ?thesis"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  a \\<in> set (markedElements M)\n  b \\<in> set (markedElements M)\n  a \\<noteq> b\n  precedes a b (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "using elementLevelPrecedesMarkedElementLt[of \"M\" \"a\" \"b\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  a \\<in> set (markedElements M)\n  b \\<in> set (markedElements M)\n  a \\<noteq> b\n  precedes a b (elements M)\n  \\<lbrakk>uniq (elements M); a \\<noteq> b; b \\<in> set (markedElements M);\n   precedes a b (elements M)\\<rbrakk>\n  \\<Longrightarrow> elementLevel a M < elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "by auto"], ["proof (state)\nthis:\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "}"], ["proof (state)\nthis:\n  precedes a b (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "moreover"], ["proof (state)\nthis:\n  precedes a b (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "{"], ["proof (state)\nthis:\n  precedes a b (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "assume \"precedes b a (elements M)\""], ["proof (state)\nthis:\n  precedes b a (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "with assms"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  a \\<in> set (markedElements M)\n  b \\<in> set (markedElements M)\n  a \\<noteq> b\n  precedes b a (elements M)", "have ?thesis"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  a \\<in> set (markedElements M)\n  b \\<in> set (markedElements M)\n  a \\<noteq> b\n  precedes b a (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "using elementLevelPrecedesMarkedElementLt[of \"M\" \"b\" \"a\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  a \\<in> set (markedElements M)\n  b \\<in> set (markedElements M)\n  a \\<noteq> b\n  precedes b a (elements M)\n  \\<lbrakk>uniq (elements M); b \\<noteq> a; a \\<in> set (markedElements M);\n   precedes b a (elements M)\\<rbrakk>\n  \\<Longrightarrow> elementLevel b M < elementLevel a M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "by auto"], ["proof (state)\nthis:\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "}"], ["proof (state)\nthis:\n  precedes b a (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "ultimately"], ["proof (chain)\npicking this:\n  precedes a b (elements M) \\<or> precedes b a (elements M)\n  precedes a b (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M\n  precedes b a (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M", "show ?thesis"], ["proof (prove)\nusing this:\n  precedes a b (elements M) \\<or> precedes b a (elements M)\n  precedes a b (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M\n  precedes b a (elements M) \\<Longrightarrow>\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<noteq> elementLevel b M", "by auto"], ["proof (state)\nthis:\n  elementLevel a M \\<noteq> elementLevel b M\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ------------------------------------------------------------------------- *)"], ["", "subsection\\<open>Current trail level\\<close>"], ["", "text\\<open>Current level is the number of marked elements in the trail\\<close>"], ["", "definition\ncurrentLevel :: \"'a Trail \\<Rightarrow> nat\"\nwhere\n\"currentLevel t = length (markedElements t)\""], ["", "lemma currentLevelNonMarked: \n  shows \"currentLevel M = currentLevel (M @ [(l, False)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel M = currentLevel (M @ [(l, False)])", "by (auto simp add:currentLevel_def markedElementsAppend)"], ["", "lemma currentLevelPrefix:\n  assumes \"isPrefix a b\" \n  shows \"currentLevel a <= currentLevel b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel a \\<le> currentLevel b", "using assms"], ["proof (prove)\nusing this:\n  isPrefix a b\n\ngoal (1 subgoal):\n 1. currentLevel a \\<le> currentLevel b", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. a @ s = b\n\ngoal (1 subgoal):\n 1. currentLevel a \\<le> currentLevel b", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  \\<exists>s. a @ s = b\n\ngoal (1 subgoal):\n 1. length (markedElements a) \\<le> length (markedElements b)", "by (auto simp add: markedElementsAppend)"], ["", "lemma elementLevelLeqCurrentLevel:\n  shows \"elementLevel a M \\<le> currentLevel M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "have \"isPrefix (prefixToElement a M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToElement a M) M", "using isPrefixPrefixToElement[of \"a\" \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix (prefixToElement a M) M\n\ngoal (1 subgoal):\n 1. isPrefix (prefixToElement a M) M", "."], ["proof (state)\nthis:\n  isPrefix (prefixToElement a M) M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "then"], ["proof (chain)\npicking this:\n  isPrefix (prefixToElement a M) M", "obtain s\n    where \"prefixToElement a M @ s = M\""], ["proof (prove)\nusing this:\n  isPrefix (prefixToElement a M) M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToElement a M @ s = M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. prefixToElement a M @ s = M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToElement a M @ s = M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prefixToElement a M @ s = M\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "hence \"M = prefixToElement a M @ s\""], ["proof (prove)\nusing this:\n  prefixToElement a M @ s = M\n\ngoal (1 subgoal):\n 1. M = prefixToElement a M @ s", "by (rule sym)"], ["proof (state)\nthis:\n  M = prefixToElement a M @ s\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "hence \"currentLevel M = currentLevel (prefixToElement a M @ s)\""], ["proof (prove)\nusing this:\n  M = prefixToElement a M @ s\n\ngoal (1 subgoal):\n 1. currentLevel M = currentLevel (prefixToElement a M @ s)", "by simp"], ["proof (state)\nthis:\n  currentLevel M = currentLevel (prefixToElement a M @ s)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "hence \"currentLevel M = length (markedElements (prefixToElement a M)) + length (markedElements s)\""], ["proof (prove)\nusing this:\n  currentLevel M = currentLevel (prefixToElement a M @ s)\n\ngoal (1 subgoal):\n 1. currentLevel M =\n    length (markedElements (prefixToElement a M)) +\n    length (markedElements s)", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  length (markedElements M) =\n  length (markedElements (prefixToElement a M @ s))\n\ngoal (1 subgoal):\n 1. length (markedElements M) =\n    length (markedElements (prefixToElement a M)) +\n    length (markedElements s)", "by (simp add: markedElementsAppend)"], ["proof (state)\nthis:\n  currentLevel M =\n  length (markedElements (prefixToElement a M)) + length (markedElements s)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "thus ?thesis"], ["proof (prove)\nusing this:\n  currentLevel M =\n  length (markedElements (prefixToElement a M)) + length (markedElements s)\n\ngoal (1 subgoal):\n 1. elementLevel a M \\<le> currentLevel M", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  currentLevel M =\n  length (markedElements (prefixToElement a M)) + length (markedElements s)\n\ngoal (1 subgoal):\n 1. length (markedElementsTo a M) \\<le> currentLevel M", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  currentLevel M =\n  length (markedElements (prefixToElement a M)) + length (markedElements s)\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement a M)) \\<le> currentLevel M", "by simp"], ["proof (state)\nthis:\n  elementLevel a M \\<le> currentLevel M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elementOnCurrentLevel:\n  assumes \"a \\<notin> set (elements M)\"\n  shows \"elementLevel a (M @ [(a, d)]) = currentLevel  (M @ [(a, d)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel a (M @ [(a, d)]) = currentLevel (M @ [(a, d)])", "using assms"], ["proof (prove)\nusing this:\n  a \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a (M @ [(a, d)]) = currentLevel (M @ [(a, d)])", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  a \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel a (M @ [(a, d)]) = length (markedElements (M @ [(a, d)]))", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  a \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. length (markedElementsTo a (M @ [(a, d)])) =\n    length (markedElements (M @ [(a, d)]))", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  a \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement a (M @ [(a, d)]))) =\n    length (markedElements (M @ [(a, d)]))", "by (auto simp add: prefixToElementAppend)"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Prefix to a given trail level\\<close>"], ["", "text\\<open>Prefix is made or elements of the trail up to a given element level\\<close>"], ["", "primrec\nprefixToLevel_aux :: \"'a Trail \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a Trail\"\nwhere\n  \"(prefixToLevel_aux [] l cl) = []\"\n| \"(prefixToLevel_aux (h#t) l cl) = \n  (if (marked h) then\n    (if (cl >= l) then [] else (h # (prefixToLevel_aux t l (cl+1))))\n  else\n    (h # (prefixToLevel_aux t l cl))\n  )\""], ["", "definition\nprefixToLevel :: \"nat \\<Rightarrow> 'a Trail \\<Rightarrow> 'a Trail\"\nwhere\nprefixToLevel_def: \"(prefixToLevel l t) == (prefixToLevel_aux t l 0)\""], ["", "lemma isPrefixPrefixToLevel_aux:\n  shows \"\\<exists> s. prefixToLevel_aux t l i @ s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. prefixToLevel_aux t l i @ s = t", "by (induct t arbitrary: i) auto"], ["", "lemma isPrefixPrefixToLevel:\n  shows \"(isPrefix (prefixToLevel l t) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel l t) t", "using isPrefixPrefixToLevel_aux[of \"t\" \"l\"]"], ["proof (prove)\nusing this:\n  \\<exists>s. prefixToLevel_aux t l ?i @ s = t\n\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel l t) t", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. prefixToLevel_aux t l ?i @ s = t\n\ngoal (1 subgoal):\n 1. \\<exists>s. prefixToLevel l t @ s = t", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  \\<exists>s. prefixToLevel_aux t l ?i @ s = t\n\ngoal (1 subgoal):\n 1. \\<exists>s. prefixToLevel_aux t l 0 @ s = t", "by simp"], ["", "lemma currentLevelPrefixToLevel_aux: \n  assumes \"l \\<ge> i\"\n  shows \"currentLevel (prefixToLevel_aux M l i) <= l - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M l i) \\<le> l - i", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M l i) \\<le> l - i", "proof (induct M arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "case (Cons m M')"], ["proof (state)\nthis:\n  ?i \\<le> l \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux M' l ?i) \\<le> l - ?i\n  i \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "{"], ["proof (state)\nthis:\n  ?i \\<le> l \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux M' l ?i) \\<le> l - ?i\n  i \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "assume \"marked m\" \"i = l\""], ["proof (state)\nthis:\n  marked m\n  i = l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "hence ?case"], ["proof (prove)\nusing this:\n  marked m\n  i = l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked m\n  i = l\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\<le> l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "assume \"marked m\" \"i < l\""], ["proof (state)\nthis:\n  marked m\n  i < l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "hence ?case"], ["proof (prove)\nusing this:\n  marked m\n  i < l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "using Cons(1) [of \"i+1\"]"], ["proof (prove)\nusing this:\n  marked m\n  i < l\n  i + 1 \\<le> l \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux M' l (i + 1)) \\<le> l - (i + 1)\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked m\n  i < l\n  i + 1 \\<le> l \\<Longrightarrow>\n  length (markedElements (prefixToLevel_aux M' l (i + 1))) \\<le> l - (i + 1)\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\<le> l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "assume \"\\<not> marked m\""], ["proof (state)\nthis:\n  \\<not> marked m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "hence ?case"], ["proof (prove)\nusing this:\n  \\<not> marked m\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> marked m\n  ?i \\<le> l \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux M' l ?i) \\<le> l - ?i\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  \\<not> marked m\n  ?i \\<le> l \\<Longrightarrow>\n  length (markedElements (prefixToLevel_aux M' l ?i)) \\<le> l - ?i\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\<le> l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "}"], ["proof (state)\nthis:\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> l \\<Longrightarrow>\n                   currentLevel (prefixToLevel_aux M l i) \\<le> l - i;\n        i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i)\n                         \\<le> l - i", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "using \\<open>i <= l\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i)\n                    \\<le> l - i\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i", "by auto"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i", "case Nil"], ["proof (state)\nthis:\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> l \\<Longrightarrow>\n       currentLevel (prefixToLevel_aux [] l i) \\<le> l - i", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux [] l i) \\<le> l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux [] l i)) \\<le> l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma currentLevelPrefixToLevel: \n  shows \"currentLevel (prefixToLevel level M) \\<le> level\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level M) \\<le> level", "using currentLevelPrefixToLevel_aux[of \"0\" \"level\" \"M\"]"], ["proof (prove)\nusing this:\n  0 \\<le> level \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux M level 0) \\<le> level - 0\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level M) \\<le> level", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  0 \\<le> level \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux M level 0) \\<le> level - 0\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M level 0) \\<le> level", "by simp"], ["", "lemma currentLevelPrefixToLevelEq_aux: \n  assumes \"l \\<ge> i\" \"currentLevel M >= l - i\"\n  shows \"currentLevel (prefixToLevel_aux M l i) = l - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M l i) = l - i", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> l\n  l - i \\<le> currentLevel M\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M l i) = l - i", "proof (induct M arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "case (Cons m M')"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> l; l - ?i \\<le> currentLevel M'\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) = l - ?i\n  i \\<le> l\n  l - i \\<le> currentLevel (m # M')\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> l; l - ?i \\<le> currentLevel M'\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) = l - ?i\n  i \\<le> l\n  l - i \\<le> currentLevel (m # M')\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "assume \"marked m\" \"i = l\""], ["proof (state)\nthis:\n  marked m\n  i = l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "hence ?case"], ["proof (prove)\nusing this:\n  marked m\n  i = l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked m\n  i = l\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) = l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "assume \"marked m\" \"i < l\""], ["proof (state)\nthis:\n  marked m\n  i < l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "hence ?case"], ["proof (prove)\nusing this:\n  marked m\n  i < l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "using Cons(1) [of \"i+1\"]"], ["proof (prove)\nusing this:\n  marked m\n  i < l\n  \\<lbrakk>i + 1 \\<le> l; l - (i + 1) \\<le> currentLevel M'\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l (i + 1)) =\n                    l - (i + 1)\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "using Cons(3)"], ["proof (prove)\nusing this:\n  marked m\n  i < l\n  \\<lbrakk>i + 1 \\<le> l; l - (i + 1) \\<le> currentLevel M'\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l (i + 1)) =\n                    l - (i + 1)\n  l - i \\<le> currentLevel (m # M')\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked m\n  i < l\n  \\<lbrakk>i + 1 \\<le> l;\n   l - (i + 1) \\<le> length (markedElements M')\\<rbrakk>\n  \\<Longrightarrow> length\n                     (markedElements (prefixToLevel_aux M' l (i + 1))) =\n                    l - (i + 1)\n  l - i \\<le> length (markedElements (m # M'))\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) = l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "assume \"\\<not> marked m\""], ["proof (state)\nthis:\n  \\<not> marked m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "hence ?case"], ["proof (prove)\nusing this:\n  \\<not> marked m\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> marked m\n  \\<lbrakk>?i \\<le> l; l - ?i \\<le> currentLevel M'\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) = l - ?i\n  i \\<le> l\n  l - i \\<le> currentLevel (m # M')\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  \\<not> marked m\n  \\<lbrakk>?i \\<le> l; l - ?i \\<le> length (markedElements M')\\<rbrakk>\n  \\<Longrightarrow> length (markedElements (prefixToLevel_aux M' l ?i)) =\n                    l - ?i\n  i \\<le> l\n  l - i \\<le> length (markedElements (m # M'))\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) = l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "}"], ["proof (state)\nthis:\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel M\\<rbrakk>\n                   \\<Longrightarrow> currentLevel\n(prefixToLevel_aux M l i) =\n                                     l - i;\n        i \\<le> l; l - i \\<le> currentLevel (a # M)\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) =\n                         l - i", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "using \\<open>i <= l\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>marked m; i = l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n  \\<lbrakk>marked m; i < l\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n  \\<not> marked m \\<Longrightarrow>\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) = l - i", "by auto"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux (m # M') l i) = l - i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i", "case Nil"], ["proof (state)\nthis:\n  i \\<le> l\n  l - i \\<le> currentLevel []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i \\<le> currentLevel []\\<rbrakk>\n       \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) = l - i", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> l\n  l - i \\<le> currentLevel []\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux [] l i) = l - i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  i \\<le> l\n  l - i \\<le> length (markedElements [])\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux [] l i)) = l - i", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel_aux [] l i) = l - i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma currentLevelPrefixToLevelEq:\nassumes\n  \"level \\<le> currentLevel M\"\nshows\n  \"currentLevel (prefixToLevel level M) = level\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level M) = level", "using assms"], ["proof (prove)\nusing this:\n  level \\<le> currentLevel M\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level M) = level", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  level \\<le> currentLevel M\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M level 0) = level", "using currentLevelPrefixToLevelEq_aux[of \"0\" \"level\" \"M\"]"], ["proof (prove)\nusing this:\n  level \\<le> currentLevel M\n  \\<lbrakk>0 \\<le> level; level - 0 \\<le> currentLevel M\\<rbrakk>\n  \\<Longrightarrow> currentLevel (prefixToLevel_aux M level 0) = level - 0\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M level 0) = level", "by simp"], ["", "lemma prefixToLevel_auxIncreaseAuxilaryCounter: \n  assumes \"k \\<ge> i\"\n  shows \"prefixToLevel_aux M l i = prefixToLevel_aux M (l + (k - i)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel_aux M l i = prefixToLevel_aux M (l + (k - i)) k", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux M l i = prefixToLevel_aux M (l + (k - i)) k", "proof (induct M arbitrary: i k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "case (Cons m M')"], ["proof (state)\nthis:\n  ?i \\<le> ?k \\<Longrightarrow>\n  prefixToLevel_aux M' l ?i = prefixToLevel_aux M' (l + (?k - ?i)) ?k\n  i \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "{"], ["proof (state)\nthis:\n  ?i \\<le> ?k \\<Longrightarrow>\n  prefixToLevel_aux M' l ?i = prefixToLevel_aux M' (l + (?k - ?i)) ?k\n  i \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "assume \"\\<not> marked m\""], ["proof (state)\nthis:\n  \\<not> marked m\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "hence ?case"], ["proof (prove)\nusing this:\n  \\<not> marked m\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (m # M') l i =\n    prefixToLevel_aux (m # M') (l + (k - i)) k", "using Cons(1)[of \"i\" \"k\"] Cons(2)"], ["proof (prove)\nusing this:\n  \\<not> marked m\n  i \\<le> k \\<Longrightarrow>\n  prefixToLevel_aux M' l i = prefixToLevel_aux M' (l + (k - i)) k\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (m # M') l i =\n    prefixToLevel_aux (m # M') (l + (k - i)) k", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "}"], ["proof (state)\nthis:\n  \\<not> marked m \\<Longrightarrow>\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "moreover"], ["proof (state)\nthis:\n  \\<not> marked m \\<Longrightarrow>\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "{"], ["proof (state)\nthis:\n  \\<not> marked m \\<Longrightarrow>\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "assume \"i \\<ge> l\" \"marked m\""], ["proof (state)\nthis:\n  l \\<le> i\n  marked m\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "hence ?case"], ["proof (prove)\nusing this:\n  l \\<le> i\n  marked m\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (m # M') l i =\n    prefixToLevel_aux (m # M') (l + (k - i)) k", "using \\<open>k \\<ge> i\\<close>"], ["proof (prove)\nusing this:\n  l \\<le> i\n  marked m\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (m # M') l i =\n    prefixToLevel_aux (m # M') (l + (k - i)) k", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "}"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<le> i; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<le> i; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "{"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<le> i; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "assume \"i < l\" \"marked m\""], ["proof (state)\nthis:\n  i < l\n  marked m\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "hence ?case"], ["proof (prove)\nusing this:\n  i < l\n  marked m\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (m # M') l i =\n    prefixToLevel_aux (m # M') (l + (k - i)) k", "using Cons(1)[of \"i+1\" \"k+1\"] Cons(2)"], ["proof (prove)\nusing this:\n  i < l\n  marked m\n  i + 1 \\<le> k + 1 \\<Longrightarrow>\n  prefixToLevel_aux M' l (i + 1) =\n  prefixToLevel_aux M' (l + (k + 1 - (i + 1))) (k + 1)\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (m # M') l i =\n    prefixToLevel_aux (m # M') (l + (k - i)) k", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < l; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (2 subgoals):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k\n 2. \\<And>a M i k.\n       \\<lbrakk>\\<And>i k.\n                   i \\<le> k \\<Longrightarrow>\n                   prefixToLevel_aux M l i =\n                   prefixToLevel_aux M (l + (k - i)) k;\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux (a # M) l i =\n                         prefixToLevel_aux (a # M) (l + (k - i)) k", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> marked m \\<Longrightarrow>\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n  \\<lbrakk>l \\<le> i; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k\n  \\<lbrakk>i < l; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> marked m \\<Longrightarrow>\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n  \\<lbrakk>l \\<le> i; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k\n  \\<lbrakk>i < l; marked m\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (m # M') l i =\n                    prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (m # M') l i =\n    prefixToLevel_aux (m # M') (l + (k - i)) k", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  prefixToLevel_aux (m # M') l i =\n  prefixToLevel_aux (m # M') (l + (k - i)) k\n\ngoal (1 subgoal):\n 1. \\<And>i k.\n       i \\<le> k \\<Longrightarrow>\n       prefixToLevel_aux [] l i = prefixToLevel_aux [] (l + (k - i)) k", "qed simp"], ["", "lemma isPrefixPrefixToLevel_auxLowerLevel:\n  assumes \"i \\<le> j\"\n  shows \"isPrefix (prefixToLevel_aux M i k) (prefixToLevel_aux M j k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel_aux M i k) (prefixToLevel_aux M j k)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel_aux M i k) (prefixToLevel_aux M j k)", "by (induct M arbitrary: k) (auto simp add:isPrefix_def)"], ["", "lemma isPrefixPrefixToLevelLowerLevel:\nassumes \"level < level'\"\nshows \"isPrefix (prefixToLevel level M) (prefixToLevel level' M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel level M) (prefixToLevel level' M)", "using assms"], ["proof (prove)\nusing this:\n  level < level'\n\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel level M) (prefixToLevel level' M)", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  level < level'\n\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel_aux M level 0) (prefixToLevel_aux M level' 0)", "using isPrefixPrefixToLevel_auxLowerLevel[of \"level\" \"level'\" \"M\" \"0\"]"], ["proof (prove)\nusing this:\n  level < level'\n  level \\<le> level' \\<Longrightarrow>\n  isPrefix (prefixToLevel_aux M level 0) (prefixToLevel_aux M level' 0)\n\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel_aux M level 0) (prefixToLevel_aux M level' 0)", "by simp"], ["", "lemma prefixToLevel_auxPrefixToLevel_auxHigherLevel: \n  assumes \"i \\<le> j\"\n  shows \"prefixToLevel_aux a i k = prefixToLevel_aux (prefixToLevel_aux a j k) i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel_aux a i k =\n    prefixToLevel_aux (prefixToLevel_aux a j k) i k", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux a i k =\n    prefixToLevel_aux (prefixToLevel_aux a j k) i k", "by (induct a arbitrary: k) auto"], ["", "lemma prefixToLevelPrefixToLevelHigherLevel: \n  assumes \"level \\<le> level'\"\n  shows \"prefixToLevel level M = prefixToLevel level (prefixToLevel level' M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel level M = prefixToLevel level (prefixToLevel level' M)", "using assms"], ["proof (prove)\nusing this:\n  level \\<le> level'\n\ngoal (1 subgoal):\n 1. prefixToLevel level M = prefixToLevel level (prefixToLevel level' M)", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  level \\<le> level'\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux M level 0 =\n    prefixToLevel_aux (prefixToLevel_aux M level' 0) level 0", "using prefixToLevel_auxPrefixToLevel_auxHigherLevel[of \"level\" \"level'\" \"M\" \"0\"]"], ["proof (prove)\nusing this:\n  level \\<le> level'\n  level \\<le> level' \\<Longrightarrow>\n  prefixToLevel_aux M level 0 =\n  prefixToLevel_aux (prefixToLevel_aux M level' 0) level 0\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux M level 0 =\n    prefixToLevel_aux (prefixToLevel_aux M level' 0) level 0", "by simp"], ["", "lemma prefixToLevelAppend_aux1:\n  assumes\n  \"l \\<ge> i\" and \"l - i < currentLevel a\"\n  shows \n  \"prefixToLevel_aux (a @ b) l i = prefixToLevel_aux a l i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) l i = prefixToLevel_aux a l i", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> l\n  l - i < currentLevel a\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) l i = prefixToLevel_aux a l i", "proof (induct a arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "case (Cons a a')"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> l; l - ?i < currentLevel a'\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l ?i =\n                    prefixToLevel_aux a' l ?i\n  i \\<le> l\n  l - i < currentLevel (a # a')\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> l; l - ?i < currentLevel a'\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l ?i =\n                    prefixToLevel_aux a' l ?i\n  i \\<le> l\n  l - i < currentLevel (a # a')\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "assume \"\\<not> marked a\""], ["proof (state)\nthis:\n  \\<not> marked a\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "hence ?case"], ["proof (prove)\nusing this:\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "using Cons(1)[of \"i\"] \\<open>i \\<le> l\\<close> \\<open>l - i < currentLevel (a # a')\\<close>"], ["proof (prove)\nusing this:\n  \\<not> marked a\n  \\<lbrakk>i \\<le> l; l - i < currentLevel a'\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l i =\n                    prefixToLevel_aux a' l i\n  i \\<le> l\n  l - i < currentLevel (a # a')\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  \\<not> marked a\n  \\<lbrakk>i \\<le> l; l - i < length (markedElements a')\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l i =\n                    prefixToLevel_aux a' l i\n  i \\<le> l\n  l - i < length (markedElements (a # a'))\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "}"], ["proof (state)\nthis:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "moreover"], ["proof (state)\nthis:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "{"], ["proof (state)\nthis:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "assume \"marked a\" \"l = i\""], ["proof (state)\nthis:\n  marked a\n  l = i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "hence ?case"], ["proof (prove)\nusing this:\n  marked a\n  l = i\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "assume \"marked a\" \"l > i\""], ["proof (state)\nthis:\n  marked a\n  i < l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "hence ?case"], ["proof (prove)\nusing this:\n  marked a\n  i < l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "using Cons(1)[of \"i + 1\"] \\<open>i \\<le> l\\<close> \\<open>l - i < currentLevel (a # a')\\<close>"], ["proof (prove)\nusing this:\n  marked a\n  i < l\n  \\<lbrakk>i + 1 \\<le> l; l - (i + 1) < currentLevel a'\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l (i + 1) =\n                    prefixToLevel_aux a' l (i + 1)\n  i \\<le> l\n  l - i < currentLevel (a # a')\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked a\n  i < l\n  \\<lbrakk>i + 1 \\<le> l; l - (i + 1) < length (markedElements a')\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l (i + 1) =\n                    prefixToLevel_aux a' l (i + 1)\n  i \\<le> l\n  l - i < length (markedElements (a # a'))\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; l - i < currentLevel a2\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     prefixToLevel_aux a2 l i;\n        i \\<le> l; l - i < currentLevel (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         prefixToLevel_aux (a1 # a2) l i", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "using \\<open>i \\<le> l\\<close>"], ["proof (prove)\nusing this:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    prefixToLevel_aux (a # a') l i\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i", "by auto"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i = prefixToLevel_aux (a # a') l i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i", "case Nil"], ["proof (state)\nthis:\n  i \\<le> l\n  l - i < currentLevel []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; l - i < currentLevel []\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         prefixToLevel_aux [] l i", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> l\n  l - i < currentLevel []\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ([] @ b) l i = prefixToLevel_aux [] l i", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  i \\<le> l\n  l - i < length (markedElements [])\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ([] @ b) l i = prefixToLevel_aux [] l i", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ([] @ b) l i = prefixToLevel_aux [] l i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefixToLevelAppend_aux2: \n  assumes \n  \"i \\<le> l\" and \"currentLevel a + i \\<le> l\"\n  shows \"prefixToLevel_aux (a @ b) l i = a @ prefixToLevel_aux b l (i + (currentLevel a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) l i =\n    a @ prefixToLevel_aux b l (i + currentLevel a)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> l\n  currentLevel a + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) l i =\n    a @ prefixToLevel_aux b l (i + currentLevel a)", "proof (induct a arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "case (Cons a a')"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> l; currentLevel a' + ?i \\<le> l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l ?i =\n                    a' @ prefixToLevel_aux b l (?i + currentLevel a')\n  i \\<le> l\n  currentLevel (a # a') + i \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> l; currentLevel a' + ?i \\<le> l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l ?i =\n                    a' @ prefixToLevel_aux b l (?i + currentLevel a')\n  i \\<le> l\n  currentLevel (a # a') + i \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "assume \"\\<not> marked a\""], ["proof (state)\nthis:\n  \\<not> marked a\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "hence ?case"], ["proof (prove)\nusing this:\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> marked a\n  \\<lbrakk>?i \\<le> l; currentLevel a' + ?i \\<le> l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l ?i =\n                    a' @ prefixToLevel_aux b l (?i + currentLevel a')\n  i \\<le> l\n  currentLevel (a # a') + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  \\<not> marked a\n  \\<lbrakk>?i \\<le> l; length (markedElements a') + ?i \\<le> l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l ?i =\n                    a' @\n                    prefixToLevel_aux b l (?i + length (markedElements a'))\n  i \\<le> l\n  length (markedElements (a # a')) + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + length (markedElements (a # a')))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "}"], ["proof (state)\nthis:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "moreover"], ["proof (state)\nthis:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "{"], ["proof (state)\nthis:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "assume \"marked a\" \"l = i\""], ["proof (state)\nthis:\n  marked a\n  l = i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "hence ?case"], ["proof (prove)\nusing this:\n  marked a\n  l = i\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "using \\<open>(currentLevel (a # a')) + i \\<le> l\\<close>"], ["proof (prove)\nusing this:\n  marked a\n  l = i\n  currentLevel (a # a') + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked a\n  l = i\n  length (markedElements (a # a')) + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + length (markedElements (a # a')))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "assume \"marked a\" \"l > i\""], ["proof (state)\nthis:\n  marked a\n  i < l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "hence \"prefixToLevel_aux (a' @ b) l (i + 1) = a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')\""], ["proof (prove)\nusing this:\n  marked a\n  i < l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a' @ b) l (i + 1) =\n    a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')", "using Cons(1) [of \"i + 1\"] \\<open>(currentLevel (a # a')) + i \\<le> l\\<close>"], ["proof (prove)\nusing this:\n  marked a\n  i < l\n  \\<lbrakk>i + 1 \\<le> l; currentLevel a' + (i + 1) \\<le> l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l (i + 1) =\n                    a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')\n  currentLevel (a # a') + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a' @ b) l (i + 1) =\n    a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked a\n  i < l\n  \\<lbrakk>i + 1 \\<le> l;\n   length (markedElements a') + (i + 1) \\<le> l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a' @ b) l (i + 1) =\n                    a' @\n                    prefixToLevel_aux b l\n                     (i + 1 + length (markedElements a'))\n  length (markedElements (a # a')) + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a' @ b) l (i + 1) =\n    a' @ prefixToLevel_aux b l (i + 1 + length (markedElements a'))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux (a' @ b) l (i + 1) =\n  a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "moreover"], ["proof (state)\nthis:\n  prefixToLevel_aux (a' @ b) l (i + 1) =\n  a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "have \"i + 1 + length (markedElements a') = i + (1 + length (markedElements a'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 1 + length (markedElements a') =\n    i + (1 + length (markedElements a'))", "by simp"], ["proof (state)\nthis:\n  i + 1 + length (markedElements a') = i + (1 + length (markedElements a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "ultimately"], ["proof (chain)\npicking this:\n  prefixToLevel_aux (a' @ b) l (i + 1) =\n  a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')\n  i + 1 + length (markedElements a') = i + (1 + length (markedElements a'))", "have ?case"], ["proof (prove)\nusing this:\n  prefixToLevel_aux (a' @ b) l (i + 1) =\n  a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')\n  i + 1 + length (markedElements a') = i + (1 + length (markedElements a'))\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "using \\<open>marked a\\<close> \\<open>l > i\\<close>"], ["proof (prove)\nusing this:\n  prefixToLevel_aux (a' @ b) l (i + 1) =\n  a' @ prefixToLevel_aux b l (i + 1 + currentLevel a')\n  i + 1 + length (markedElements a') = i + (1 + length (markedElements a'))\n  marked a\n  i < l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  prefixToLevel_aux (a' @ b) l (i + 1) =\n  a' @ prefixToLevel_aux b l (i + 1 + length (markedElements a'))\n  i + 1 + length (markedElements a') = i + (1 + length (markedElements a'))\n  marked a\n  i < l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + length (markedElements (a # a')))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])\n 2. \\<And>a1 a2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<le> l; currentLevel a2 + i \\<le> l\\<rbrakk>\n                   \\<Longrightarrow> prefixToLevel_aux (a2 @ b) l i =\n                                     a2 @\n                                     prefixToLevel_aux b l\n(i + currentLevel a2);\n        i \\<le> l; currentLevel (a1 # a2) + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ((a1 # a2) @ b) l i =\n                         (a1 # a2) @\n                         prefixToLevel_aux b l (i + currentLevel (a1 # a2))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "using \\<open>l \\<ge> i\\<close>"], ["proof (prove)\nusing this:\n  \\<not> marked a \\<Longrightarrow>\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n  \\<lbrakk>marked a; l = i\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n  \\<lbrakk>marked a; i < l\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux ((a # a') @ b) l i =\n                    (a # a') @\n                    prefixToLevel_aux b l (i + currentLevel (a # a'))\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ((a # a') @ b) l i =\n    (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))", "by auto"], ["proof (state)\nthis:\n  prefixToLevel_aux ((a # a') @ b) l i =\n  (a # a') @ prefixToLevel_aux b l (i + currentLevel (a # a'))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])", "case Nil"], ["proof (state)\nthis:\n  i \\<le> l\n  currentLevel [] + i \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> l; currentLevel [] + i \\<le> l\\<rbrakk>\n       \\<Longrightarrow> prefixToLevel_aux ([] @ b) l i =\n                         [] @ prefixToLevel_aux b l (i + currentLevel [])", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> l\n  currentLevel [] + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ([] @ b) l i =\n    [] @ prefixToLevel_aux b l (i + currentLevel [])", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  i \\<le> l\n  length (markedElements []) + i \\<le> l\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ([] @ b) l i =\n    [] @ prefixToLevel_aux b l (i + length (markedElements []))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ([] @ b) l i =\n  [] @ prefixToLevel_aux b l (i + currentLevel [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefixToLevelAppend:\n  shows \"prefixToLevel level (a @ b) = \n  (if level < currentLevel a then \n      prefixToLevel level a\n  else \n      a @ prefixToLevel_aux b level (currentLevel a)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "proof (cases \"level < currentLevel a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. level < currentLevel a \\<Longrightarrow>\n    prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))\n 2. \\<not> level < currentLevel a \\<Longrightarrow>\n    prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "case True"], ["proof (state)\nthis:\n  level < currentLevel a\n\ngoal (2 subgoals):\n 1. level < currentLevel a \\<Longrightarrow>\n    prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))\n 2. \\<not> level < currentLevel a \\<Longrightarrow>\n    prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  level < currentLevel a\n\ngoal (1 subgoal):\n 1. prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  level < currentLevel a\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) level 0 =\n    (if level < currentLevel a then prefixToLevel_aux a level 0\n     else a @ prefixToLevel_aux b level (currentLevel a))", "using prefixToLevelAppend_aux1[of \"0\" \"level\" \"a\"]"], ["proof (prove)\nusing this:\n  level < currentLevel a\n  \\<lbrakk>0 \\<le> level; level - 0 < currentLevel a\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a @ ?b) level 0 =\n                    prefixToLevel_aux a level 0\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) level 0 =\n    (if level < currentLevel a then prefixToLevel_aux a level 0\n     else a @ prefixToLevel_aux b level (currentLevel a))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel level (a @ b) =\n  (if level < currentLevel a then prefixToLevel level a\n   else a @ prefixToLevel_aux b level (currentLevel a))\n\ngoal (1 subgoal):\n 1. \\<not> level < currentLevel a \\<Longrightarrow>\n    prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> level < currentLevel a \\<Longrightarrow>\n    prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "case False"], ["proof (state)\nthis:\n  \\<not> level < currentLevel a\n\ngoal (1 subgoal):\n 1. \\<not> level < currentLevel a \\<Longrightarrow>\n    prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> level < currentLevel a\n\ngoal (1 subgoal):\n 1. prefixToLevel level (a @ b) =\n    (if level < currentLevel a then prefixToLevel level a\n     else a @ prefixToLevel_aux b level (currentLevel a))", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  \\<not> level < currentLevel a\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) level 0 =\n    (if level < currentLevel a then prefixToLevel_aux a level 0\n     else a @ prefixToLevel_aux b level (currentLevel a))", "using prefixToLevelAppend_aux2[of \"0\" \"level\" \"a\"]"], ["proof (prove)\nusing this:\n  \\<not> level < currentLevel a\n  \\<lbrakk>0 \\<le> level; currentLevel a + 0 \\<le> level\\<rbrakk>\n  \\<Longrightarrow> prefixToLevel_aux (a @ ?b) level 0 =\n                    a @ prefixToLevel_aux ?b level (0 + currentLevel a)\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux (a @ b) level 0 =\n    (if level < currentLevel a then prefixToLevel_aux a level 0\n     else a @ prefixToLevel_aux b level (currentLevel a))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel level (a @ b) =\n  (if level < currentLevel a then prefixToLevel level a\n   else a @ prefixToLevel_aux b level (currentLevel a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isProperPrefixPrefixToLevel:\n  assumes \"level < currentLevel t\" \n  shows \"\\<exists> s. (prefixToLevel level t) @ s = t \\<and> s \\<noteq> [] \\<and> (marked (hd s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "have \"isPrefix (prefixToLevel level t) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel level t) t", "by (simp add:isPrefixPrefixToLevel)"], ["proof (state)\nthis:\n  isPrefix (prefixToLevel level t) t\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "then"], ["proof (chain)\npicking this:\n  isPrefix (prefixToLevel level t) t", "obtain s::\"'a Trail\"\n    where \"(prefixToLevel level t) @ s = t\""], ["proof (prove)\nusing this:\n  isPrefix (prefixToLevel level t) t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToLevel level t @ s = t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. prefixToLevel level t @ s = t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToLevel level t @ s = t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prefixToLevel level t @ s = t\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "moreover"], ["proof (state)\nthis:\n  prefixToLevel level t @ s = t\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "have \"s \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> []", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> []", "assume \"s = []\""], ["proof (state)\nthis:\n  s = []\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "with \\<open>(prefixToLevel level t) @ s = t\\<close>"], ["proof (chain)\npicking this:\n  prefixToLevel level t @ s = t\n  s = []", "have \"prefixToLevel level t = t\""], ["proof (prove)\nusing this:\n  prefixToLevel level t @ s = t\n  s = []\n\ngoal (1 subgoal):\n 1. prefixToLevel level t = t", "by simp"], ["proof (state)\nthis:\n  prefixToLevel level t = t\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "hence \"currentLevel (prefixToLevel level t) \\<le> level\""], ["proof (prove)\nusing this:\n  prefixToLevel level t = t\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level t) \\<le> level", "using currentLevelPrefixToLevel[of \"level\" \"t\"]"], ["proof (prove)\nusing this:\n  prefixToLevel level t = t\n  currentLevel (prefixToLevel level t) \\<le> level\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level t) \\<le> level", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel level t) \\<le> level\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "with \\<open>prefixToLevel level t = t\\<close>"], ["proof (chain)\npicking this:\n  prefixToLevel level t = t\n  currentLevel (prefixToLevel level t) \\<le> level", "have \"currentLevel t \\<le> level\""], ["proof (prove)\nusing this:\n  prefixToLevel level t = t\n  currentLevel (prefixToLevel level t) \\<le> level\n\ngoal (1 subgoal):\n 1. currentLevel t \\<le> level", "by simp"], ["proof (state)\nthis:\n  currentLevel t \\<le> level\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "with \\<open>level < currentLevel t\\<close>"], ["proof (chain)\npicking this:\n  level < currentLevel t\n  currentLevel t \\<le> level", "have False"], ["proof (prove)\nusing this:\n  level < currentLevel t\n  currentLevel t \\<le> level\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "}"], ["proof (state)\nthis:\n  s = [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "moreover"], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "have \"marked (hd s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. marked (hd s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. marked (hd s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. marked (hd s)", "assume \"\\<not> marked (hd s)\""], ["proof (state)\nthis:\n  \\<not> marked (hd s)\n\ngoal (1 subgoal):\n 1. marked (hd s)", "have \"currentLevel (prefixToLevel level t) \\<le> level\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level t) \\<le> level", "by (simp add:currentLevelPrefixToLevel)"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel level t) \\<le> level\n\ngoal (1 subgoal):\n 1. marked (hd s)", "from \\<open>s \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> []", "have \"s = [hd s] @ (tl s)\""], ["proof (prove)\nusing this:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. s = [hd s] @ tl s", "by simp"], ["proof (state)\nthis:\n  s = [hd s] @ tl s\n\ngoal (1 subgoal):\n 1. marked (hd s)", "with \\<open>(prefixToLevel level t) @ s = t\\<close>"], ["proof (chain)\npicking this:\n  prefixToLevel level t @ s = t\n  s = [hd s] @ tl s", "have\n        \"t = (prefixToLevel level t) @ [hd s] @ (tl s)\""], ["proof (prove)\nusing this:\n  prefixToLevel level t @ s = t\n  s = [hd s] @ tl s\n\ngoal (1 subgoal):\n 1. t = prefixToLevel level t @ [hd s] @ tl s", "by simp"], ["proof (state)\nthis:\n  t = prefixToLevel level t @ [hd s] @ tl s\n\ngoal (1 subgoal):\n 1. marked (hd s)", "hence \"(prefixToLevel level t) = (prefixToLevel level ((prefixToLevel level t) @ [hd s] @ (tl s)))\""], ["proof (prove)\nusing this:\n  t = prefixToLevel level t @ [hd s] @ tl s\n\ngoal (1 subgoal):\n 1. prefixToLevel level t =\n    prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s)", "by simp"], ["proof (state)\nthis:\n  prefixToLevel level t =\n  prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s)\n\ngoal (1 subgoal):\n 1. marked (hd s)", "also"], ["proof (state)\nthis:\n  prefixToLevel level t =\n  prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s)\n\ngoal (1 subgoal):\n 1. marked (hd s)", "with \\<open>currentLevel (prefixToLevel level t) \\<le> level\\<close>"], ["proof (chain)\npicking this:\n  currentLevel (prefixToLevel level t) \\<le> level\n  prefixToLevel level t =\n  prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s)", "have \"\\<dots> = ((prefixToLevel level t) @ (prefixToLevel_aux ([hd s] @ (tl s)) level (currentLevel (prefixToLevel level t))))\""], ["proof (prove)\nusing this:\n  currentLevel (prefixToLevel level t) \\<le> level\n  prefixToLevel level t =\n  prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s)\n\ngoal (1 subgoal):\n 1. prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s) =\n    prefixToLevel level t @\n    prefixToLevel_aux ([hd s] @ tl s) level\n     (currentLevel (prefixToLevel level t))", "by (auto simp add: prefixToLevelAppend)"], ["proof (state)\nthis:\n  prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s) =\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. marked (hd s)", "also"], ["proof (state)\nthis:\n  prefixToLevel level (prefixToLevel level t @ [hd s] @ tl s) =\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. marked (hd s)", "have \"\\<dots> = \n        ((prefixToLevel level t) @ (hd s) # prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel level t @\n    prefixToLevel_aux ([hd s] @ tl s) level\n     (currentLevel (prefixToLevel level t)) =\n    prefixToLevel level t @\n    hd s #\n    prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. prefixToLevel level t @\n    prefixToLevel_aux ([hd s] @ tl s) level\n     (currentLevel (prefixToLevel level t)) =\n    prefixToLevel level t @\n    hd s #\n    prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))", "from \\<open>currentLevel (prefixToLevel level t) <= level\\<close> \\<open>\\<not> marked (hd s)\\<close>"], ["proof (chain)\npicking this:\n  currentLevel (prefixToLevel level t) \\<le> level\n  \\<not> marked (hd s)", "have \"prefixToLevel_aux ([hd s] @ (tl s)) level (currentLevel (prefixToLevel level t)) = \n          (hd s) # prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\""], ["proof (prove)\nusing this:\n  currentLevel (prefixToLevel level t) \\<le> level\n  \\<not> marked (hd s)\n\ngoal (1 subgoal):\n 1. prefixToLevel_aux ([hd s] @ tl s) level\n     (currentLevel (prefixToLevel level t)) =\n    hd s #\n    prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t)) =\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. prefixToLevel level t @\n    prefixToLevel_aux ([hd s] @ tl s) level\n     (currentLevel (prefixToLevel level t)) =\n    prefixToLevel level t @\n    hd s #\n    prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t)) =\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. prefixToLevel level t @\n    prefixToLevel_aux ([hd s] @ tl s) level\n     (currentLevel (prefixToLevel level t)) =\n    prefixToLevel level t @\n    hd s #\n    prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t)) =\n  prefixToLevel level t @\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t)) =\n  prefixToLevel level t @\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. marked (hd s)", "ultimately"], ["proof (chain)\npicking this:\n  prefixToLevel level t =\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t))\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t)) =\n  prefixToLevel level t @\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))", "have \"(prefixToLevel level t) = (prefixToLevel level t) @ (hd s) # prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\""], ["proof (prove)\nusing this:\n  prefixToLevel level t =\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t))\n  prefixToLevel level t @\n  prefixToLevel_aux ([hd s] @ tl s) level\n   (currentLevel (prefixToLevel level t)) =\n  prefixToLevel level t @\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. prefixToLevel level t =\n    prefixToLevel level t @\n    hd s #\n    prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel level t =\n  prefixToLevel level t @\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. marked (hd s)", "hence \"False\""], ["proof (prove)\nusing this:\n  prefixToLevel level t =\n  prefixToLevel level t @\n  hd s #\n  prefixToLevel_aux (tl s) level (currentLevel (prefixToLevel level t))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. marked (hd s)", "}"], ["proof (state)\nthis:\n  \\<not> marked (hd s) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. marked (hd s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> marked (hd s) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. marked (hd s)", "by auto"], ["proof (state)\nthis:\n  marked (hd s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  marked (hd s)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "ultimately"], ["proof (chain)\npicking this:\n  prefixToLevel level t @ s = t\n  s \\<noteq> []\n  marked (hd s)", "show ?thesis"], ["proof (prove)\nusing this:\n  prefixToLevel level t @ s = t\n  s \\<noteq> []\n  marked (hd s)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prefixToLevel level t @ s = t \\<and>\n       s \\<noteq> [] \\<and> marked (hd s)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s.\n     prefixToLevel level t @ s = t \\<and> s \\<noteq> [] \\<and> marked (hd s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefixToLevelElementsElementLevel: \n  assumes \n  \"e  \\<in> set (elements (prefixToLevel level M))\"\n  shows\n  \"elementLevel e M \\<le> level\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "have \"elementLevel e (prefixToLevel level M) \\<le> currentLevel (prefixToLevel  level M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M)\n    \\<le> currentLevel (prefixToLevel level M)", "by (simp add: elementLevelLeqCurrentLevel)"], ["proof (state)\nthis:\n  elementLevel e (prefixToLevel level M)\n  \\<le> currentLevel (prefixToLevel level M)\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "moreover"], ["proof (state)\nthis:\n  elementLevel e (prefixToLevel level M)\n  \\<le> currentLevel (prefixToLevel level M)\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "hence \"currentLevel (prefixToLevel level M) \\<le> level\""], ["proof (prove)\nusing this:\n  elementLevel e (prefixToLevel level M)\n  \\<le> currentLevel (prefixToLevel level M)\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level M) \\<le> level", "using currentLevelPrefixToLevel[of \"level\" \"M\"]"], ["proof (prove)\nusing this:\n  elementLevel e (prefixToLevel level M)\n  \\<le> currentLevel (prefixToLevel level M)\n  currentLevel (prefixToLevel level M) \\<le> level\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel level M) \\<le> level", "by simp"], ["proof (state)\nthis:\n  currentLevel (prefixToLevel level M) \\<le> level\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "ultimately"], ["proof (chain)\npicking this:\n  elementLevel e (prefixToLevel level M)\n  \\<le> currentLevel (prefixToLevel level M)\n  currentLevel (prefixToLevel level M) \\<le> level", "have \"elementLevel e (prefixToLevel level M) \\<le> level\""], ["proof (prove)\nusing this:\n  elementLevel e (prefixToLevel level M)\n  \\<le> currentLevel (prefixToLevel level M)\n  currentLevel (prefixToLevel level M) \\<le> level\n\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M) \\<le> level", "by simp"], ["proof (state)\nthis:\n  elementLevel e (prefixToLevel level M) \\<le> level\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "moreover"], ["proof (state)\nthis:\n  elementLevel e (prefixToLevel level M) \\<le> level\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "have \"isPrefix (prefixToLevel level M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel level M) M", "by (simp add:isPrefixPrefixToLevel)"], ["proof (state)\nthis:\n  isPrefix (prefixToLevel level M) M\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "then"], ["proof (chain)\npicking this:\n  isPrefix (prefixToLevel level M) M", "obtain s\n    where \"(prefixToLevel level M) @ s = M\""], ["proof (prove)\nusing this:\n  isPrefix (prefixToLevel level M) M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToLevel level M @ s = M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. prefixToLevel level M @ s = M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToLevel level M @ s = M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prefixToLevel level M @ s = M\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "with \\<open>e  \\<in> set (elements (prefixToLevel level M))\\<close>"], ["proof (chain)\npicking this:\n  e \\<in> set (elements (prefixToLevel level M))\n  prefixToLevel level M @ s = M", "have \"elementLevel e (prefixToLevel level M) = elementLevel e M\""], ["proof (prove)\nusing this:\n  e \\<in> set (elements (prefixToLevel level M))\n  prefixToLevel level M @ s = M\n\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M) = elementLevel e M", "using elementLevelAppend [of \"e\" \"prefixToLevel level M\" \"s\"]"], ["proof (prove)\nusing this:\n  e \\<in> set (elements (prefixToLevel level M))\n  prefixToLevel level M @ s = M\n  e \\<in> set (elements (prefixToLevel level M)) \\<Longrightarrow>\n  elementLevel e (prefixToLevel level M) =\n  elementLevel e (prefixToLevel level M @ s)\n\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M) = elementLevel e M", "by simp"], ["proof (state)\nthis:\n  elementLevel e (prefixToLevel level M) = elementLevel e M\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "ultimately"], ["proof (chain)\npicking this:\n  elementLevel e (prefixToLevel level M) \\<le> level\n  elementLevel e (prefixToLevel level M) = elementLevel e M", "show ?thesis"], ["proof (prove)\nusing this:\n  elementLevel e (prefixToLevel level M) \\<le> level\n  elementLevel e (prefixToLevel level M) = elementLevel e M\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "by simp"], ["proof (state)\nthis:\n  elementLevel e M \\<le> level\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elementLevelLtLevelImpliesMemberPrefixToLevel_aux:\n  assumes\n  \"e  \\<in> set(elements M)\" and\n  \"elementLevel e M + i \\<le> level\" and\n  \"i \\<le> level\"\n  shows \n  \"e  \\<in> set (elements (prefixToLevel_aux M level i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux M level i))", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M)\n  elementLevel e M + i \\<le> level\n  i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux M level i))", "proof (induct M arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>e \\<in> set (elements []);\n        elementLevel e [] + i \\<le> level; i \\<le> level\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (elements\n (prefixToLevel_aux [] level i))\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>e \\<in> set (elements M);\n                    elementLevel e M + i \\<le> level; i \\<le> level\\<rbrakk>\n                   \\<Longrightarrow> e \\<in> set\n        (elements (prefixToLevel_aux M level i));\n        e \\<in> set (elements (a # M));\n        elementLevel e (a # M) + i \\<le> level; i \\<le> level\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (elements\n (prefixToLevel_aux (a # M) level i))", "case (Cons m M')"], ["proof (state)\nthis:\n  \\<lbrakk>e \\<in> set (elements M'); elementLevel e M' + ?i \\<le> level;\n   ?i \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M' level ?i))\n  e \\<in> set (elements (m # M'))\n  elementLevel e (m # M') + i \\<le> level\n  i \\<le> level\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>e \\<in> set (elements []);\n        elementLevel e [] + i \\<le> level; i \\<le> level\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (elements\n (prefixToLevel_aux [] level i))\n 2. \\<And>a M i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>e \\<in> set (elements M);\n                    elementLevel e M + i \\<le> level; i \\<le> level\\<rbrakk>\n                   \\<Longrightarrow> e \\<in> set\n        (elements (prefixToLevel_aux M level i));\n        e \\<in> set (elements (a # M));\n        elementLevel e (a # M) + i \\<le> level; i \\<le> level\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (elements\n (prefixToLevel_aux (a # M) level i))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> set (elements M'); elementLevel e M' + ?i \\<le> level;\n   ?i \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M' level ?i))\n  e \\<in> set (elements (m # M'))\n  elementLevel e (m # M') + i \\<le> level\n  i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "proof (cases \"e = element m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e = element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))\n 2. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))", "case True"], ["proof (state)\nthis:\n  e = element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e = element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))\n 2. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = element m\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "using \\<open>elementLevel e (m # M') + i \\<le> level\\<close>"], ["proof (prove)\nusing this:\n  e = element m\n  elementLevel e (m # M') + i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  e = element m\n  elementLevel e (m # M') + i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  e = element m\n  length (markedElementsTo e (m # M')) + i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  e = element m\n  length (markedElements (prefixToElement e (m # M'))) + i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))", "case False"], ["proof (state)\nthis:\n  e \\<noteq> element m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))", "with \\<open>e \\<in> set (elements (m # M'))\\<close>"], ["proof (chain)\npicking this:\n  e \\<in> set (elements (m # M'))\n  e \\<noteq> element m", "have \"e \\<in> set (elements M')\""], ["proof (prove)\nusing this:\n  e \\<in> set (elements (m # M'))\n  e \\<noteq> element m\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements M')", "by simp"], ["proof (state)\nthis:\n  e \\<in> set (elements M')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>e \\<in> set (elements M');\n                 elementLevel e M' + i \\<le> level; i \\<le> level\\<rbrakk>\n                \\<Longrightarrow> e \\<in> set\n     (elements (prefixToLevel_aux M' level i));\n     e \\<in> set (elements (m # M'));\n     elementLevel e (m # M') + i \\<le> level; i \\<le> level;\n     e \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> e \\<in> set (elements\n                                    (prefixToLevel_aux (m # M') level i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "proof (cases \"marked m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n 2. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "case True"], ["proof (state)\nthis:\n  marked m\n\ngoal (2 subgoals):\n 1. marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n 2. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "with Cons \\<open>e \\<noteq> element m\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>e \\<in> set (elements M'); elementLevel e M' + ?i \\<le> level;\n   ?i \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M' level ?i))\n  e \\<in> set (elements (m # M'))\n  elementLevel e (m # M') + i \\<le> level\n  i \\<le> level\n  e \\<noteq> element m\n  marked m", "have \"(elementLevel e M') + i + 1 \\<le> level\""], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> set (elements M'); elementLevel e M' + ?i \\<le> level;\n   ?i \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M' level ?i))\n  e \\<in> set (elements (m # M'))\n  elementLevel e (m # M') + i \\<le> level\n  i \\<le> level\n  e \\<noteq> element m\n  marked m\n\ngoal (1 subgoal):\n 1. elementLevel e M' + i + 1 \\<le> level", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> set (elements M');\n   length (markedElementsTo e M') + ?i \\<le> level; ?i \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M' level ?i))\n  e \\<in> set (elements (m # M'))\n  length (markedElementsTo e (m # M')) + i \\<le> level\n  i \\<le> level\n  e \\<noteq> element m\n  marked m\n\ngoal (1 subgoal):\n 1. length (markedElementsTo e M') + i + 1 \\<le> level", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<in> set (elements M');\n   length (markedElements (prefixToElement e M')) + ?i \\<le> level;\n   ?i \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M' level ?i))\n  e \\<in> set (elements (m # M'))\n  length (markedElements (prefixToElement e (m # M'))) + i \\<le> level\n  i \\<le> level\n  e \\<noteq> element m\n  marked m\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement e M')) + i + 1 \\<le> level", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  elementLevel e M' + i + 1 \\<le> level\n\ngoal (2 subgoals):\n 1. marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n 2. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "moreover"], ["proof (state)\nthis:\n  elementLevel e M' + i + 1 \\<le> level\n\ngoal (2 subgoals):\n 1. marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n 2. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "have \"elementLevel e M' \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> elementLevel e M'", "by auto"], ["proof (state)\nthis:\n  0 \\<le> elementLevel e M'\n\ngoal (2 subgoals):\n 1. marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n 2. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "ultimately"], ["proof (chain)\npicking this:\n  elementLevel e M' + i + 1 \\<le> level\n  0 \\<le> elementLevel e M'", "have \"i + 1 \\<le> level\""], ["proof (prove)\nusing this:\n  elementLevel e M' + i + 1 \\<le> level\n  0 \\<le> elementLevel e M'\n\ngoal (1 subgoal):\n 1. i + 1 \\<le> level", "by simp"], ["proof (state)\nthis:\n  i + 1 \\<le> level\n\ngoal (2 subgoals):\n 1. marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n 2. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "with \\<open>e \\<in> set (elements M')\\<close> \\<open>(elementLevel e M') + i + 1 \\<le> level\\<close> Cons(1)[of \"i+1\"]"], ["proof (chain)\npicking this:\n  e \\<in> set (elements M')\n  elementLevel e M' + i + 1 \\<le> level\n  \\<lbrakk>e \\<in> set (elements M');\n   elementLevel e M' + (i + 1) \\<le> level; i + 1 \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements\n                                  (prefixToLevel_aux M' level (i + 1)))\n  i + 1 \\<le> level", "have \"e \\<in> set (elements (prefixToLevel_aux M' level (i + 1)))\""], ["proof (prove)\nusing this:\n  e \\<in> set (elements M')\n  elementLevel e M' + i + 1 \\<le> level\n  \\<lbrakk>e \\<in> set (elements M');\n   elementLevel e M' + (i + 1) \\<le> level; i + 1 \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements\n                                  (prefixToLevel_aux M' level (i + 1)))\n  i + 1 \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux M' level (i + 1)))", "by simp"], ["proof (state)\nthis:\n  e \\<in> set (elements (prefixToLevel_aux M' level (i + 1)))\n\ngoal (2 subgoals):\n 1. marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n 2. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "with \\<open>e \\<noteq> element m\\<close> \\<open>i + 1 \\<le> level\\<close> True"], ["proof (chain)\npicking this:\n  e \\<noteq> element m\n  i + 1 \\<le> level\n  marked m\n  e \\<in> set (elements (prefixToLevel_aux M' level (i + 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  i + 1 \\<le> level\n  marked m\n  e \\<in> set (elements (prefixToLevel_aux M' level (i + 1)))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "by simp"], ["proof (state)\nthis:\n  e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n\ngoal (1 subgoal):\n 1. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "case False"], ["proof (state)\nthis:\n  \\<not> marked m\n\ngoal (1 subgoal):\n 1. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "with \\<open>e \\<noteq> element m\\<close> \\<open>elementLevel e (m # M') + i \\<le> level\\<close>"], ["proof (chain)\npicking this:\n  e \\<noteq> element m\n  elementLevel e (m # M') + i \\<le> level\n  \\<not> marked m", "have \"elementLevel e M' + i \\<le> level\""], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  elementLevel e (m # M') + i \\<le> level\n  \\<not> marked m\n\ngoal (1 subgoal):\n 1. elementLevel e M' + i \\<le> level", "unfolding elementLevel_def"], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  length (markedElementsTo e (m # M')) + i \\<le> level\n  \\<not> marked m\n\ngoal (1 subgoal):\n 1. length (markedElementsTo e M') + i \\<le> level", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  length (markedElements (prefixToElement e (m # M'))) + i \\<le> level\n  \\<not> marked m\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToElement e M')) + i \\<le> level", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  elementLevel e M' + i \\<le> level\n\ngoal (1 subgoal):\n 1. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "with \\<open>e \\<in> set (elements M')\\<close>"], ["proof (chain)\npicking this:\n  e \\<in> set (elements M')\n  elementLevel e M' + i \\<le> level", "have \"e \\<in> set (elements (prefixToLevel_aux M' level i))\""], ["proof (prove)\nusing this:\n  e \\<in> set (elements M')\n  elementLevel e M' + i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux M' level i))", "using Cons"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M')\n  elementLevel e M' + i \\<le> level\n  \\<lbrakk>e \\<in> set (elements M'); elementLevel e M' + ?i \\<le> level;\n   ?i \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M' level ?i))\n  e \\<in> set (elements (m # M'))\n  elementLevel e (m # M') + i \\<le> level\n  i \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux M' level i))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  e \\<in> set (elements (prefixToLevel_aux M' level i))\n\ngoal (1 subgoal):\n 1. \\<not> marked m \\<Longrightarrow>\n    e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "with \\<open>e \\<noteq> element m\\<close> False"], ["proof (chain)\npicking this:\n  e \\<noteq> element m\n  \\<not> marked m\n  e \\<in> set (elements (prefixToLevel_aux M' level i))", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> element m\n  \\<not> marked m\n  e \\<in> set (elements (prefixToLevel_aux M' level i))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux (m # M') level i))", "by simp"], ["proof (state)\nthis:\n  e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e \\<in> set (elements (prefixToLevel_aux (m # M') level i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>e \\<in> set (elements []);\n        elementLevel e [] + i \\<le> level; i \\<le> level\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (elements\n (prefixToLevel_aux [] level i))", "qed simp"], ["", "lemma elementLevelLtLevelImpliesMemberPrefixToLevel:\n  assumes\n  \"e \\<in> set (elements M)\" and\n  \"elementLevel e M \\<le> level\"\n  shows \n  \"e \\<in> set (elements (prefixToLevel level M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel level M))", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M)\n  elementLevel e M \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel level M))", "using elementLevelLtLevelImpliesMemberPrefixToLevel_aux[of \"e\" \"M\" \"0\" \"level\"]"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M)\n  elementLevel e M \\<le> level\n  \\<lbrakk>e \\<in> set (elements M); elementLevel e M + 0 \\<le> level;\n   0 \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M level 0))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel level M))", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  e \\<in> set (elements M)\n  elementLevel e M \\<le> level\n  \\<lbrakk>e \\<in> set (elements M); elementLevel e M + 0 \\<le> level;\n   0 \\<le> level\\<rbrakk>\n  \\<Longrightarrow> e \\<in> set (elements (prefixToLevel_aux M level 0))\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel_aux M level 0))", "by simp"], ["", "lemma literalNotInEarlierLevelsThanItsLevel: \n  assumes\n  \"level < elementLevel e M\" \n  shows \n  \"e \\<notin> set (elements (prefixToLevel level M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> e \\<notin> set (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "hence \"level \\<ge> elementLevel e M\""], ["proof (prove)\nusing this:\n  \\<not> e \\<notin> set (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. elementLevel e M \\<le> level", "by (simp add: prefixToLevelElementsElementLevel)"], ["proof (state)\nthis:\n  elementLevel e M \\<le> level\n\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "with \\<open>level < elementLevel e M\\<close>"], ["proof (chain)\npicking this:\n  level < elementLevel e M\n  elementLevel e M \\<le> level", "have False"], ["proof (prove)\nusing this:\n  level < elementLevel e M\n  elementLevel e M \\<le> level\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "}"], ["proof (state)\nthis:\n  \\<not> e \\<notin> set (elements (prefixToLevel level M)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> e \\<notin> set (elements (prefixToLevel level M)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. e \\<notin> set (elements (prefixToLevel level M))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (elements (prefixToLevel level M))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elementLevelPrefixElement: \n  assumes \"e \\<in> set (elements (prefixToLevel level M))\"\n  shows \"elementLevel e (prefixToLevel level M) = elementLevel e M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M) = elementLevel e M", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M) = elementLevel e M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel level M)) \\<Longrightarrow>\n    elementLevel e (prefixToLevel level M) = elementLevel e M", "have \"isPrefix (prefixToLevel level M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel level M) M", "by (simp add: isPrefixPrefixToLevel)"], ["proof (state)\nthis:\n  isPrefix (prefixToLevel level M) M\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel level M)) \\<Longrightarrow>\n    elementLevel e (prefixToLevel level M) = elementLevel e M", "then"], ["proof (chain)\npicking this:\n  isPrefix (prefixToLevel level M) M", "obtain s where \"(prefixToLevel level M) @ s = M\""], ["proof (prove)\nusing this:\n  isPrefix (prefixToLevel level M) M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToLevel level M @ s = M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. prefixToLevel level M @ s = M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        prefixToLevel level M @ s = M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prefixToLevel level M @ s = M\n\ngoal (1 subgoal):\n 1. e \\<in> set (elements (prefixToLevel level M)) \\<Longrightarrow>\n    elementLevel e (prefixToLevel level M) = elementLevel e M", "with assms"], ["proof (chain)\npicking this:\n  e \\<in> set (elements (prefixToLevel level M))\n  prefixToLevel level M @ s = M", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> set (elements (prefixToLevel level M))\n  prefixToLevel level M @ s = M\n\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M) = elementLevel e M", "using elementLevelAppend[of \"e\" \"prefixToLevel level M\" \"s\"]"], ["proof (prove)\nusing this:\n  e \\<in> set (elements (prefixToLevel level M))\n  prefixToLevel level M @ s = M\n  e \\<in> set (elements (prefixToLevel level M)) \\<Longrightarrow>\n  elementLevel e (prefixToLevel level M) =\n  elementLevel e (prefixToLevel level M @ s)\n\ngoal (1 subgoal):\n 1. elementLevel e (prefixToLevel level M) = elementLevel e M", "by auto"], ["proof (state)\nthis:\n  elementLevel e (prefixToLevel level M) = elementLevel e M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma currentLevelZeroTrailEqualsItsPrefixToLevelZero:\n  assumes \"currentLevel M = 0\" \n  shows \"M = prefixToLevel 0 M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = prefixToLevel 0 M", "using assms"], ["proof (prove)\nusing this:\n  currentLevel M = 0\n\ngoal (1 subgoal):\n 1. M = prefixToLevel 0 M", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. currentLevel [] = 0 \\<Longrightarrow> [] = prefixToLevel 0 []\n 2. \\<And>a M.\n       \\<lbrakk>currentLevel M = 0 \\<Longrightarrow> M = prefixToLevel 0 M;\n        currentLevel (a # M) = 0\\<rbrakk>\n       \\<Longrightarrow> a # M = prefixToLevel 0 (a # M)", "case (Cons a M')"], ["proof (state)\nthis:\n  currentLevel M' = 0 \\<Longrightarrow> M' = prefixToLevel 0 M'\n  currentLevel (a # M') = 0\n\ngoal (2 subgoals):\n 1. currentLevel [] = 0 \\<Longrightarrow> [] = prefixToLevel 0 []\n 2. \\<And>a M.\n       \\<lbrakk>currentLevel M = 0 \\<Longrightarrow> M = prefixToLevel 0 M;\n        currentLevel (a # M) = 0\\<rbrakk>\n       \\<Longrightarrow> a # M = prefixToLevel 0 (a # M)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # M' = prefixToLevel 0 (a # M')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a # M' = prefixToLevel 0 (a # M')", "from Cons"], ["proof (chain)\npicking this:\n  currentLevel M' = 0 \\<Longrightarrow> M' = prefixToLevel 0 M'\n  currentLevel (a # M') = 0", "have \"currentLevel M' = 0\" and \"markedElements M' = []\" and \"\\<not> marked a\""], ["proof (prove)\nusing this:\n  currentLevel M' = 0 \\<Longrightarrow> M' = prefixToLevel 0 M'\n  currentLevel (a # M') = 0\n\ngoal (1 subgoal):\n 1. currentLevel M' = 0 &&& markedElements M' = [] &&& \\<not> marked a", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  length (markedElements M') = 0 \\<Longrightarrow> M' = prefixToLevel 0 M'\n  length (markedElements (a # M')) = 0\n\ngoal (1 subgoal):\n 1. length (markedElements M') = 0 &&&\n    markedElements M' = [] &&& \\<not> marked a", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  currentLevel M' = 0\n  markedElements M' = []\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. a # M' = prefixToLevel 0 (a # M')", "thus ?thesis"], ["proof (prove)\nusing this:\n  currentLevel M' = 0\n  markedElements M' = []\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. a # M' = prefixToLevel 0 (a # M')", "using Cons"], ["proof (prove)\nusing this:\n  currentLevel M' = 0\n  markedElements M' = []\n  \\<not> marked a\n  currentLevel M' = 0 \\<Longrightarrow> M' = prefixToLevel 0 M'\n  currentLevel (a # M') = 0\n\ngoal (1 subgoal):\n 1. a # M' = prefixToLevel 0 (a # M')", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  currentLevel M' = 0\n  markedElements M' = []\n  \\<not> marked a\n  currentLevel M' = 0 \\<Longrightarrow> M' = prefixToLevel_aux M' 0 0\n  currentLevel (a # M') = 0\n\ngoal (1 subgoal):\n 1. a # M' = prefixToLevel_aux (a # M') 0 0", "by auto"], ["proof (state)\nthis:\n  a # M' = prefixToLevel 0 (a # M')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # M' = prefixToLevel 0 (a # M')\n\ngoal (1 subgoal):\n 1. currentLevel [] = 0 \\<Longrightarrow> [] = prefixToLevel 0 []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. currentLevel [] = 0 \\<Longrightarrow> [] = prefixToLevel 0 []", "case Nil"], ["proof (state)\nthis:\n  currentLevel [] = 0\n\ngoal (1 subgoal):\n 1. currentLevel [] = 0 \\<Longrightarrow> [] = prefixToLevel 0 []", "thus ?case"], ["proof (prove)\nusing this:\n  currentLevel [] = 0\n\ngoal (1 subgoal):\n 1. [] = prefixToLevel 0 []", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  length (markedElements []) = 0\n\ngoal (1 subgoal):\n 1. [] = prefixToLevel 0 []", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  length (markedElements []) = 0\n\ngoal (1 subgoal):\n 1. [] = prefixToLevel_aux [] 0 0", "by simp"], ["proof (state)\nthis:\n  [] = prefixToLevel 0 []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Number of literals of every trail level\\<close>"], ["", "primrec\nlevelsCounter_aux :: \"'a Trail \\<Rightarrow> nat list \\<Rightarrow> nat list\"\nwhere\n  \"levelsCounter_aux [] l = l\"\n| \"levelsCounter_aux (h # t) l = \n    (if (marked h) then \n        levelsCounter_aux t (l @ [1]) \n     else\n        levelsCounter_aux t (butlast l @ [Suc (last l)])\n    )\""], ["", "definition\nlevelsCounter :: \"'a Trail \\<Rightarrow> nat list\"\nwhere\n\"levelsCounter t = levelsCounter_aux t [0]\""], ["", "lemma levelsCounter_aux_startIrellevant: \n  \"\\<forall> y. y \\<noteq> [] \\<longrightarrow> levelsCounter_aux a (x @ y) = (x @ levelsCounter_aux a y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y \\<noteq> [] \\<longrightarrow>\n       levelsCounter_aux a (x @ y) = x @ levelsCounter_aux a y", "by (induct a) (auto simp add: butlastAppend)"], ["", "lemma levelsCounter_auxSuffixContinues: \"\\<forall> l. levelsCounter_aux (a @ b) l = levelsCounter_aux b (levelsCounter_aux a l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       levelsCounter_aux (a @ b) l =\n       levelsCounter_aux b (levelsCounter_aux a l)", "by (induct a) auto"], ["", "lemma levelsCounter_auxNotEmpty: \"\\<forall> l. l \\<noteq> [] \\<longrightarrow> levelsCounter_aux a l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l \\<noteq> [] \\<longrightarrow> levelsCounter_aux a l \\<noteq> []", "by (induct a) auto"], ["", "lemma levelsCounter_auxIncreasesFirst: \n\"\\<forall> m n l1 l2. levelsCounter_aux a (m # l1) = n # l2 \\<longrightarrow> m <= n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux a (m # l1) = n # l2 \\<longrightarrow> m \\<le> n", "proof (induct \"a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n 2. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n 2. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "{"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n 2. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "fix m::nat and n::nat and l1::\"nat list\" and l2::\"nat list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n 2. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "assume \"levelsCounter_aux [] (m # l1) = n # l2\""], ["proof (state)\nthis:\n  levelsCounter_aux [] (m # l1) = n # l2\n\ngoal (2 subgoals):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n 2. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "hence \"m = n\""], ["proof (prove)\nusing this:\n  levelsCounter_aux [] (m # l1) = n # l2\n\ngoal (1 subgoal):\n 1. m = n", "by simp"], ["proof (state)\nthis:\n  m = n\n\ngoal (2 subgoals):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n 2. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "}"], ["proof (state)\nthis:\n  levelsCounter_aux [] (?m2 # ?l1.2) = ?n2 # ?l2.2 \\<Longrightarrow>\n  ?m2 = ?n2\n\ngoal (2 subgoals):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n 2. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "thus ?case"], ["proof (prove)\nusing this:\n  levelsCounter_aux [] (?m2 # ?l1.2) = ?n2 # ?l2.2 \\<Longrightarrow>\n  ?m2 = ?n2\n\ngoal (1 subgoal):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n", "by simp"], ["proof (state)\nthis:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux [] (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "case (Cons a list)"], ["proof (state)\nthis:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "{"], ["proof (state)\nthis:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "fix m::nat and n::nat and l1::\"nat list\" and l2::\"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "assume \"levelsCounter_aux (a # list) (m # l1) = n # l2\""], ["proof (state)\nthis:\n  levelsCounter_aux (a # list) (m # l1) = n # l2\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "have \"m <= n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "proof (cases \"marked a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. marked a \\<Longrightarrow> m \\<le> n\n 2. \\<not> marked a \\<Longrightarrow> m \\<le> n", "case True"], ["proof (state)\nthis:\n  marked a\n\ngoal (2 subgoals):\n 1. marked a \\<Longrightarrow> m \\<le> n\n 2. \\<not> marked a \\<Longrightarrow> m \\<le> n", "with \\<open>levelsCounter_aux (a # list) (m # l1) = n # l2\\<close>"], ["proof (chain)\npicking this:\n  levelsCounter_aux (a # list) (m # l1) = n # l2\n  marked a", "have \"levelsCounter_aux list (m # l1 @ [Suc 0]) = n # l2\""], ["proof (prove)\nusing this:\n  levelsCounter_aux (a # list) (m # l1) = n # l2\n  marked a\n\ngoal (1 subgoal):\n 1. levelsCounter_aux list (m # l1 @ [Suc 0]) = n # l2", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux list (m # l1 @ [Suc 0]) = n # l2\n\ngoal (2 subgoals):\n 1. marked a \\<Longrightarrow> m \\<le> n\n 2. \\<not> marked a \\<Longrightarrow> m \\<le> n", "with Cons"], ["proof (chain)\npicking this:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n  levelsCounter_aux list (m # l1 @ [Suc 0]) = n # l2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n  levelsCounter_aux list (m # l1 @ [Suc 0]) = n # l2\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by auto"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> marked a \\<Longrightarrow> m \\<le> n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> marked a \\<Longrightarrow> m \\<le> n", "case False"], ["proof (state)\nthis:\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. \\<not> marked a \\<Longrightarrow> m \\<le> n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "proof (cases \"l1 = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l1 = [] \\<Longrightarrow> m \\<le> n\n 2. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "case True"], ["proof (state)\nthis:\n  l1 = []\n\ngoal (2 subgoals):\n 1. l1 = [] \\<Longrightarrow> m \\<le> n\n 2. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "with \\<open>\\<not> marked a\\<close> \\<open>levelsCounter_aux (a # list) (m # l1) = n # l2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> marked a\n  levelsCounter_aux (a # list) (m # l1) = n # l2\n  l1 = []", "have \"levelsCounter_aux list [Suc m] = n # l2\""], ["proof (prove)\nusing this:\n  \\<not> marked a\n  levelsCounter_aux (a # list) (m # l1) = n # l2\n  l1 = []\n\ngoal (1 subgoal):\n 1. levelsCounter_aux list [Suc m] = n # l2", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux list [Suc m] = n # l2\n\ngoal (2 subgoals):\n 1. l1 = [] \\<Longrightarrow> m \\<le> n\n 2. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "with Cons"], ["proof (chain)\npicking this:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n  levelsCounter_aux list [Suc m] = n # l2", "have \"Suc m <= n\""], ["proof (prove)\nusing this:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n  levelsCounter_aux list [Suc m] = n # l2\n\ngoal (1 subgoal):\n 1. Suc m \\<le> n", "by auto"], ["proof (state)\nthis:\n  Suc m \\<le> n\n\ngoal (2 subgoals):\n 1. l1 = [] \\<Longrightarrow> m \\<le> n\n 2. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc m \\<le> n\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by simp"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "case False"], ["proof (state)\nthis:\n  l1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "with \\<open>\\<not> marked a\\<close> \\<open>levelsCounter_aux (a # list) (m # l1) = n # l2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> marked a\n  levelsCounter_aux (a # list) (m # l1) = n # l2\n  l1 \\<noteq> []", "have \"levelsCounter_aux list (m # butlast l1 @ [Suc (last l1)]) = n # l2\""], ["proof (prove)\nusing this:\n  \\<not> marked a\n  levelsCounter_aux (a # list) (m # l1) = n # l2\n  l1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. levelsCounter_aux list (m # butlast l1 @ [Suc (last l1)]) = n # l2", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux list (m # butlast l1 @ [Suc (last l1)]) = n # l2\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> [] \\<Longrightarrow> m \\<le> n", "with Cons"], ["proof (chain)\npicking this:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n  levelsCounter_aux list (m # butlast l1 @ [Suc (last l1)]) = n # l2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux list (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n  levelsCounter_aux list (m # butlast l1 @ [Suc (last l1)]) = n # l2\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by auto"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "}"], ["proof (state)\nthis:\n  levelsCounter_aux (a # list) (?m2 # ?l1.2) = ?n2 # ?l2.2 \\<Longrightarrow>\n  ?m2 \\<le> ?n2\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>m n l1 l2.\n          levelsCounter_aux a2 (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n \\<Longrightarrow>\n       \\<forall>m n l1 l2.\n          levelsCounter_aux (a1 # a2) (m # l1) = n # l2 \\<longrightarrow>\n          m \\<le> n", "thus ?case"], ["proof (prove)\nusing this:\n  levelsCounter_aux (a # list) (?m2 # ?l1.2) = ?n2 # ?l2.2 \\<Longrightarrow>\n  ?m2 \\<le> ?n2\n\ngoal (1 subgoal):\n 1. \\<forall>m n l1 l2.\n       levelsCounter_aux (a # list) (m # l1) = n # l2 \\<longrightarrow>\n       m \\<le> n", "by simp"], ["proof (state)\nthis:\n  \\<forall>m n l1 l2.\n     levelsCounter_aux (a # list) (m # l1) = n # l2 \\<longrightarrow>\n     m \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma levelsCounterPrefix:\n  assumes \"(isPrefix p a)\"\n  shows \"? rest. rest \\<noteq> [] \\<and> levelsCounter a = butlast (levelsCounter p) @ rest \\<and> last (levelsCounter p) \\<le> hd rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "from assms"], ["proof (chain)\npicking this:\n  isPrefix p a", "obtain s :: \"'a Trail\" where \"p @ s = a\""], ["proof (prove)\nusing this:\n  isPrefix p a\n\ngoal (1 subgoal):\n 1. (\\<And>s. p @ s = a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  \\<exists>s. p @ s = a\n\ngoal (1 subgoal):\n 1. (\\<And>s. p @ s = a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p @ s = a\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "from \\<open>p @ s = a\\<close>"], ["proof (chain)\npicking this:\n  p @ s = a", "have \"levelsCounter a = levelsCounter (p @ s)\""], ["proof (prove)\nusing this:\n  p @ s = a\n\ngoal (1 subgoal):\n 1. levelsCounter a = levelsCounter (p @ s)", "by simp"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter (p @ s)\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "proof (cases \"s = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "case True"], ["proof (state)\nthis:\n  s = []\n\ngoal (2 subgoals):\n 1. s = [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"(levelsCounter a) = (butlast (levelsCounter p)) @ [last (levelsCounter p)] \\<and> \n      (last (levelsCounter p)) <= hd [last (levelsCounter p)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter a =\n    butlast (levelsCounter p) @ [last (levelsCounter p)] \\<and>\n    last (levelsCounter p) \\<le> hd [last (levelsCounter p)]", "using \\<open>p @ s = a\\<close> \\<open>s = []\\<close>"], ["proof (prove)\nusing this:\n  p @ s = a\n  s = []\n\ngoal (1 subgoal):\n 1. levelsCounter a =\n    butlast (levelsCounter p) @ [last (levelsCounter p)] \\<and>\n    last (levelsCounter p) \\<le> hd [last (levelsCounter p)]", "unfolding levelsCounter_def"], ["proof (prove)\nusing this:\n  p @ s = a\n  s = []\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    butlast (levelsCounter_aux p [0]) @\n    [last (levelsCounter_aux p [0])] \\<and>\n    last (levelsCounter_aux p [0]) \\<le> hd [last (levelsCounter_aux p [0])]", "using levelsCounter_auxNotEmpty[of \"p\"]"], ["proof (prove)\nusing this:\n  p @ s = a\n  s = []\n  \\<forall>l.\n     l \\<noteq> [] \\<longrightarrow> levelsCounter_aux p l \\<noteq> []\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    butlast (levelsCounter_aux p [0]) @\n    [last (levelsCounter_aux p [0])] \\<and>\n    last (levelsCounter_aux p [0]) \\<le> hd [last (levelsCounter_aux p [0])]", "by auto"], ["proof (state)\nthis:\n  levelsCounter a =\n  butlast (levelsCounter p) @ [last (levelsCounter p)] \\<and>\n  last (levelsCounter p) \\<le> hd [last (levelsCounter p)]\n\ngoal (2 subgoals):\n 1. s = [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "thus ?thesis"], ["proof (prove)\nusing this:\n  levelsCounter a =\n  butlast (levelsCounter p) @ [last (levelsCounter p)] \\<and>\n  last (levelsCounter p) \\<le> hd [last (levelsCounter p)]\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "by auto"], ["proof (state)\nthis:\n  \\<exists>rest.\n     rest \\<noteq> [] \\<and>\n     levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n     last (levelsCounter p) \\<le> hd rest\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "case False"], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "proof (cases \"marked (hd s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "case True"], ["proof (state)\nthis:\n  marked (hd s)\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "from \\<open>p @ s = a\\<close>"], ["proof (chain)\npicking this:\n  p @ s = a", "have \"levelsCounter a = levelsCounter (p @ s)\""], ["proof (prove)\nusing this:\n  p @ s = a\n\ngoal (1 subgoal):\n 1. levelsCounter a = levelsCounter (p @ s)", "by simp"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter (p @ s)\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "also"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter (p @ s)\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"\\<dots> = levelsCounter_aux s (levelsCounter_aux p [0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])", "unfolding levelsCounter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (p @ s) [0] =\n    levelsCounter_aux s (levelsCounter_aux p [0])", "by (simp add: levelsCounter_auxSuffixContinues)"], ["proof (state)\nthis:\n  levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "also"], ["proof (state)\nthis:\n  levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"\\<dots> = levelsCounter_aux (tl s) ((levelsCounter_aux p [0]) @ [1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "from \\<open>s \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> []", "have \"s = hd s # tl s\""], ["proof (prove)\nusing this:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. s = hd s # tl s", "by simp"], ["proof (state)\nthis:\n  s = hd s # tl s\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "then"], ["proof (chain)\npicking this:\n  s = hd s # tl s", "have \"levelsCounter_aux s (levelsCounter_aux p [0]) = levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\""], ["proof (prove)\nusing this:\n  s = hd s # tl s\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "with \\<open>marked (hd s)\\<close>"], ["proof (chain)\npicking this:\n  marked (hd s)\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])", "show ?thesis"], ["proof (prove)\nusing this:\n  marked (hd s)\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "also"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"\\<dots> = levelsCounter_aux p [0] @ (levelsCounter_aux (tl s) [1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1]) =\n    levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]", "by (simp add: levelsCounter_aux_startIrellevant)"], ["proof (state)\nthis:\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1]) =\n  levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "finally"], ["proof (chain)\npicking this:\n  levelsCounter a = levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]", "have \"levelsCounter a = levelsCounter p @ (levelsCounter_aux (tl s) [1])\""], ["proof (prove)\nusing this:\n  levelsCounter a = levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]", "unfolding levelsCounter_def"], ["proof (prove)\nusing this:\n  levelsCounter_aux a [0] =\n  levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]", "by simp"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "hence \"(levelsCounter a) = (butlast (levelsCounter p)) @ ([last (levelsCounter p)] @ (levelsCounter_aux (tl s) [1])) \\<and> \n        (last (levelsCounter p)) <= hd ([last (levelsCounter p)] @ (levelsCounter_aux (tl s) [1]))\""], ["proof (prove)\nusing this:\n  levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. levelsCounter a =\n    butlast (levelsCounter p) @\n    [last (levelsCounter p)] @ levelsCounter_aux (tl s) [1] \\<and>\n    last (levelsCounter p)\n    \\<le> hd ([last (levelsCounter p)] @ levelsCounter_aux (tl s) [1])", "unfolding levelsCounter_def"], ["proof (prove)\nusing this:\n  levelsCounter_aux a [0] =\n  levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    butlast (levelsCounter_aux p [0]) @\n    [last (levelsCounter_aux p [0])] @ levelsCounter_aux (tl s) [1] \\<and>\n    last (levelsCounter_aux p [0])\n    \\<le> hd ([last (levelsCounter_aux p [0])] @\n              levelsCounter_aux (tl s) [1])", "using levelsCounter_auxNotEmpty[of \"p\"]"], ["proof (prove)\nusing this:\n  levelsCounter_aux a [0] =\n  levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n  \\<forall>l.\n     l \\<noteq> [] \\<longrightarrow> levelsCounter_aux p l \\<noteq> []\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    butlast (levelsCounter_aux p [0]) @\n    [last (levelsCounter_aux p [0])] @ levelsCounter_aux (tl s) [1] \\<and>\n    last (levelsCounter_aux p [0])\n    \\<le> hd ([last (levelsCounter_aux p [0])] @\n              levelsCounter_aux (tl s) [1])", "by auto"], ["proof (state)\nthis:\n  levelsCounter a =\n  butlast (levelsCounter p) @\n  [last (levelsCounter p)] @ levelsCounter_aux (tl s) [1] \\<and>\n  last (levelsCounter p)\n  \\<le> hd ([last (levelsCounter p)] @ levelsCounter_aux (tl s) [1])\n\ngoal (2 subgoals):\n 1. marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest\n 2. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "thus ?thesis"], ["proof (prove)\nusing this:\n  levelsCounter a =\n  butlast (levelsCounter p) @\n  [last (levelsCounter p)] @ levelsCounter_aux (tl s) [1] \\<and>\n  last (levelsCounter p)\n  \\<le> hd ([last (levelsCounter p)] @ levelsCounter_aux (tl s) [1])\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "by auto"], ["proof (state)\nthis:\n  \\<exists>rest.\n     rest \\<noteq> [] \\<and>\n     levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n     last (levelsCounter p) \\<le> hd rest\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "case False"], ["proof (state)\nthis:\n  \\<not> marked (hd s)\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "from \\<open>p @ s = a\\<close>"], ["proof (chain)\npicking this:\n  p @ s = a", "have \"levelsCounter a = levelsCounter (p @ s)\""], ["proof (prove)\nusing this:\n  p @ s = a\n\ngoal (1 subgoal):\n 1. levelsCounter a = levelsCounter (p @ s)", "by simp"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter (p @ s)\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "also"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter (p @ s)\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"\\<dots> = levelsCounter_aux s (levelsCounter_aux p [0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])", "unfolding levelsCounter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (p @ s) [0] =\n    levelsCounter_aux s (levelsCounter_aux p [0])", "by (simp add: levelsCounter_auxSuffixContinues)"], ["proof (state)\nthis:\n  levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "also"], ["proof (state)\nthis:\n  levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"\\<dots> = levelsCounter_aux (tl s) ((butlast (levelsCounter_aux p [0])) @ [Suc (last (levelsCounter_aux p [0]))])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s)\n     (butlast (levelsCounter_aux p [0]) @\n      [Suc (last (levelsCounter_aux p [0]))])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s)\n     (butlast (levelsCounter_aux p [0]) @\n      [Suc (last (levelsCounter_aux p [0]))])", "from \\<open>s \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> []", "have \"s = hd s # tl s\""], ["proof (prove)\nusing this:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. s = hd s # tl s", "by simp"], ["proof (state)\nthis:\n  s = hd s # tl s\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s)\n     (butlast (levelsCounter_aux p [0]) @\n      [Suc (last (levelsCounter_aux p [0]))])", "then"], ["proof (chain)\npicking this:\n  s = hd s # tl s", "have \"levelsCounter_aux s (levelsCounter_aux p [0]) = levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\""], ["proof (prove)\nusing this:\n  s = hd s # tl s\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s)\n     (butlast (levelsCounter_aux p [0]) @\n      [Suc (last (levelsCounter_aux p [0]))])", "with \\<open>~marked (hd s)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> marked (hd s)\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> marked (hd s)\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s)\n     (butlast (levelsCounter_aux p [0]) @\n      [Suc (last (levelsCounter_aux p [0]))])", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s)\n   (butlast (levelsCounter_aux p [0]) @\n    [Suc (last (levelsCounter_aux p [0]))])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s)\n   (butlast (levelsCounter_aux p [0]) @\n    [Suc (last (levelsCounter_aux p [0]))])\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "also"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s)\n   (butlast (levelsCounter_aux p [0]) @\n    [Suc (last (levelsCounter_aux p [0]))])\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"\\<dots> = butlast (levelsCounter_aux p [0]) @ (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (tl s)\n     (butlast (levelsCounter_aux p [0]) @\n      [Suc (last (levelsCounter_aux p [0]))]) =\n    butlast (levelsCounter_aux p [0]) @\n    levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]", "by (simp add: levelsCounter_aux_startIrellevant)"], ["proof (state)\nthis:\n  levelsCounter_aux (tl s)\n   (butlast (levelsCounter_aux p [0]) @\n    [Suc (last (levelsCounter_aux p [0]))]) =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "finally"], ["proof (chain)\npicking this:\n  levelsCounter a =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]", "have \"levelsCounter a = butlast (levelsCounter_aux p [0]) @ (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\""], ["proof (prove)\nusing this:\n  levelsCounter a =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n\ngoal (1 subgoal):\n 1. levelsCounter a =\n    butlast (levelsCounter_aux p [0]) @\n    levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]", "unfolding levelsCounter_def"], ["proof (prove)\nusing this:\n  levelsCounter_aux a [0] =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    butlast (levelsCounter_aux p [0]) @\n    levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]", "by simp"], ["proof (state)\nthis:\n  levelsCounter a =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "moreover"], ["proof (state)\nthis:\n  levelsCounter a =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "have \"hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]) >= Suc (last (levelsCounter_aux p [0]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0]))\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0]))\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "have \"(levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<noteq>\n    []", "using levelsCounter_auxNotEmpty[of \"tl s\"]"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l \\<noteq> [] \\<longrightarrow> levelsCounter_aux (tl s) l \\<noteq> []\n\ngoal (1 subgoal):\n 1. levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<noteq>\n    []", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0]))\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "then"], ["proof (chain)\npicking this:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<noteq>\n  []", "obtain h t where \"(levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]) = h # t\""], ["proof (prove)\nusing this:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. (\\<And>h t.\n        levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] =\n        h # t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using neq_Nil_conv[of \"(levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\"]"], ["proof (prove)\nusing this:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<noteq>\n  []\n  (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<noteq>\n   []) =\n  (\\<exists>y ys.\n      levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] =\n      y # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>h t.\n        levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] =\n        h # t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] = h # t\n\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0]))\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "hence \"h \\<ge> Suc (last (levelsCounter_aux p [0]))\""], ["proof (prove)\nusing this:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] = h # t\n\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0])) \\<le> h", "using levelsCounter_auxIncreasesFirst[of \"tl s\"]"], ["proof (prove)\nusing this:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] = h # t\n  \\<forall>m n l1 l2.\n     levelsCounter_aux (tl s) (m # l1) = n # l2 \\<longrightarrow> m \\<le> n\n\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0])) \\<le> h", "by auto"], ["proof (state)\nthis:\n  Suc (last (levelsCounter_aux p [0])) \\<le> h\n\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0]))\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "with \\<open>(levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]) = h # t\\<close>"], ["proof (chain)\npicking this:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] = h # t\n  Suc (last (levelsCounter_aux p [0])) \\<le> h", "show ?thesis"], ["proof (prove)\nusing this:\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] = h # t\n  Suc (last (levelsCounter_aux p [0])) \\<le> h\n\ngoal (1 subgoal):\n 1. Suc (last (levelsCounter_aux p [0]))\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "by simp"], ["proof (state)\nthis:\n  Suc (last (levelsCounter_aux p [0]))\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (last (levelsCounter_aux p [0]))\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "ultimately"], ["proof (chain)\npicking this:\n  levelsCounter a =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n  Suc (last (levelsCounter_aux p [0]))\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])", "have \"levelsCounter a = butlast (levelsCounter p) @ (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]) \\<and> \n        last (levelsCounter p) \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\""], ["proof (prove)\nusing this:\n  levelsCounter a =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n  Suc (last (levelsCounter_aux p [0]))\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\n\ngoal (1 subgoal):\n 1. levelsCounter a =\n    butlast (levelsCounter p) @\n    levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<and>\n    last (levelsCounter p)\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "unfolding levelsCounter_def"], ["proof (prove)\nusing this:\n  levelsCounter_aux a [0] =\n  butlast (levelsCounter_aux p [0]) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))]\n  Suc (last (levelsCounter_aux p [0]))\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    butlast (levelsCounter_aux p [0]) @\n    levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<and>\n    last (levelsCounter_aux p [0])\n    \\<le> hd (levelsCounter_aux (tl s)\n               [Suc (last (levelsCounter_aux p [0]))])", "by simp"], ["proof (state)\nthis:\n  levelsCounter a =\n  butlast (levelsCounter p) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<and>\n  last (levelsCounter p)\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\n\ngoal (1 subgoal):\n 1. \\<not> marked (hd s) \\<Longrightarrow>\n    \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "thus ?thesis"], ["proof (prove)\nusing this:\n  levelsCounter a =\n  butlast (levelsCounter p) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<and>\n  last (levelsCounter p)\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "using levelsCounter_auxNotEmpty[of \"tl s\"]"], ["proof (prove)\nusing this:\n  levelsCounter a =\n  butlast (levelsCounter p) @\n  levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))] \\<and>\n  last (levelsCounter p)\n  \\<le> hd (levelsCounter_aux (tl s) [Suc (last (levelsCounter_aux p [0]))])\n  \\<forall>l.\n     l \\<noteq> [] \\<longrightarrow> levelsCounter_aux (tl s) l \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and>\n       levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n       last (levelsCounter p) \\<le> hd rest", "by auto"], ["proof (state)\nthis:\n  \\<exists>rest.\n     rest \\<noteq> [] \\<and>\n     levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n     last (levelsCounter p) \\<le> hd rest\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>rest.\n     rest \\<noteq> [] \\<and>\n     levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n     last (levelsCounter p) \\<le> hd rest\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>rest.\n     rest \\<noteq> [] \\<and>\n     levelsCounter a = butlast (levelsCounter p) @ rest \\<and>\n     last (levelsCounter p) \\<le> hd rest\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma levelsCounterPrefixToLevel:\n  assumes \"p = prefixToLevel level a\" \"level \\<ge> 0\" \"level < currentLevel a\" \n  shows \"? rest . rest \\<noteq> [] \\<and> (levelsCounter a) = (levelsCounter p) @ rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "from assms"], ["proof (chain)\npicking this:\n  p = prefixToLevel level a\n  0 \\<le> level\n  level < currentLevel a", "obtain s :: \"'a Trail\" where \"p @ s = a\" \"s \\<noteq> []\" \"marked (hd s)\""], ["proof (prove)\nusing this:\n  p = prefixToLevel level a\n  0 \\<le> level\n  level < currentLevel a\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>p @ s = a; s \\<noteq> []; marked (hd s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using isProperPrefixPrefixToLevel[of \"level\" \"a\"]"], ["proof (prove)\nusing this:\n  p = prefixToLevel level a\n  0 \\<le> level\n  level < currentLevel a\n  level < currentLevel a \\<Longrightarrow>\n  \\<exists>s.\n     prefixToLevel level a @ s = a \\<and> s \\<noteq> [] \\<and> marked (hd s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>p @ s = a; s \\<noteq> []; marked (hd s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p @ s = a\n  s \\<noteq> []\n  marked (hd s)\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "from \\<open>p @ s = a\\<close>"], ["proof (chain)\npicking this:\n  p @ s = a", "have \"levelsCounter a = levelsCounter (p @ s)\""], ["proof (prove)\nusing this:\n  p @ s = a\n\ngoal (1 subgoal):\n 1. levelsCounter a = levelsCounter (p @ s)", "by simp"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter (p @ s)\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "also"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter (p @ s)\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "have \"\\<dots> = levelsCounter_aux s (levelsCounter_aux p [0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])", "unfolding levelsCounter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (p @ s) [0] =\n    levelsCounter_aux s (levelsCounter_aux p [0])", "by (simp add: levelsCounter_auxSuffixContinues)"], ["proof (state)\nthis:\n  levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "also"], ["proof (state)\nthis:\n  levelsCounter (p @ s) = levelsCounter_aux s (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "have \"\\<dots> = levelsCounter_aux (tl s) ((levelsCounter_aux p [0]) @ [1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "from \\<open>s \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> []", "have \"s = hd s # tl s\""], ["proof (prove)\nusing this:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. s = hd s # tl s", "by simp"], ["proof (state)\nthis:\n  s = hd s # tl s\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "then"], ["proof (chain)\npicking this:\n  s = hd s # tl s", "have \"levelsCounter_aux s (levelsCounter_aux p [0]) = levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\""], ["proof (prove)\nusing this:\n  s = hd s # tl s\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "with \\<open>marked (hd s)\\<close>"], ["proof (chain)\npicking this:\n  marked (hd s)\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])", "show ?thesis"], ["proof (prove)\nusing this:\n  marked (hd s)\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (hd s # tl s) (levelsCounter_aux p [0])\n\ngoal (1 subgoal):\n 1. levelsCounter_aux s (levelsCounter_aux p [0]) =\n    levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])", "by simp"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "also"], ["proof (state)\nthis:\n  levelsCounter_aux s (levelsCounter_aux p [0]) =\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1])\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "have \"\\<dots> = levelsCounter_aux p [0] @ (levelsCounter_aux (tl s) [1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1]) =\n    levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]", "by (simp add: levelsCounter_aux_startIrellevant)"], ["proof (state)\nthis:\n  levelsCounter_aux (tl s) (levelsCounter_aux p [0] @ [1]) =\n  levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "finally"], ["proof (chain)\npicking this:\n  levelsCounter a = levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]", "have \"levelsCounter a = levelsCounter p @ (levelsCounter_aux (tl s) [1])\""], ["proof (prove)\nusing this:\n  levelsCounter a = levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]", "unfolding levelsCounter_def"], ["proof (prove)\nusing this:\n  levelsCounter_aux a [0] =\n  levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. levelsCounter_aux a [0] =\n    levelsCounter_aux p [0] @ levelsCounter_aux (tl s) [1]", "by simp"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "moreover"], ["proof (state)\nthis:\n  levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "have \"levelsCounter_aux (tl s) [1] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. levelsCounter_aux (tl s) [1] \\<noteq> []", "by (simp add: levelsCounter_auxNotEmpty)"], ["proof (state)\nthis:\n  levelsCounter_aux (tl s) [1] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "ultimately"], ["proof (chain)\npicking this:\n  levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]\n  levelsCounter_aux (tl s) [1] \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  levelsCounter a = levelsCounter p @ levelsCounter_aux (tl s) [1]\n  levelsCounter_aux (tl s) [1] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest", "by simp"], ["proof (state)\nthis:\n  \\<exists>rest.\n     rest \\<noteq> [] \\<and> levelsCounter a = levelsCounter p @ rest\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsection\\<open>Prefix before last marked element\\<close>"], ["", "primrec\nprefixBeforeLastMarked  :: \"'a Trail \\<Rightarrow> 'a Trail\"\nwhere\n  \"prefixBeforeLastMarked [] = []\"\n| \"prefixBeforeLastMarked (h#t) =  (if (marked h) \\<and> (markedElements t) = [] then [] else (h#(prefixBeforeLastMarked t)))\""], ["", "lemma prefixBeforeLastMarkedIsPrefixBeforeLastLevel:\n  assumes \"markedElements M \\<noteq> []\"\n  shows \"prefixBeforeLastMarked M = prefixToLevel ((currentLevel M) - 1) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked M = prefixToLevel (currentLevel M - 1) M", "using assms"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked M = prefixToLevel (currentLevel M - 1) M", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. markedElements [] \\<noteq> [] \\<Longrightarrow>\n    prefixBeforeLastMarked [] = prefixToLevel (currentLevel [] - 1) []\n 2. \\<And>a M.\n       \\<lbrakk>markedElements M \\<noteq> [] \\<Longrightarrow>\n                prefixBeforeLastMarked M =\n                prefixToLevel (currentLevel M - 1) M;\n        markedElements (a # M) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixToLevel (currentLevel (a # M) - 1) (a # M)", "case Nil"], ["proof (state)\nthis:\n  markedElements [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. markedElements [] \\<noteq> [] \\<Longrightarrow>\n    prefixBeforeLastMarked [] = prefixToLevel (currentLevel [] - 1) []\n 2. \\<And>a M.\n       \\<lbrakk>markedElements M \\<noteq> [] \\<Longrightarrow>\n                prefixBeforeLastMarked M =\n                prefixToLevel (currentLevel M - 1) M;\n        markedElements (a # M) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixToLevel (currentLevel (a # M) - 1) (a # M)", "thus ?case"], ["proof (prove)\nusing this:\n  markedElements [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked [] = prefixToLevel (currentLevel [] - 1) []", "by simp"], ["proof (state)\nthis:\n  prefixBeforeLastMarked [] = prefixToLevel (currentLevel [] - 1) []\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>markedElements M \\<noteq> [] \\<Longrightarrow>\n                prefixBeforeLastMarked M =\n                prefixToLevel (currentLevel M - 1) M;\n        markedElements (a # M) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixToLevel (currentLevel (a # M) - 1) (a # M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>markedElements M \\<noteq> [] \\<Longrightarrow>\n                prefixBeforeLastMarked M =\n                prefixToLevel (currentLevel M - 1) M;\n        markedElements (a # M) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixToLevel (currentLevel (a # M) - 1) (a # M)", "case (Cons a M')"], ["proof (state)\nthis:\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel (currentLevel M' - 1) M'\n  markedElements (a # M') \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>markedElements M \\<noteq> [] \\<Longrightarrow>\n                prefixBeforeLastMarked M =\n                prefixToLevel (currentLevel M - 1) M;\n        markedElements (a # M) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixToLevel (currentLevel (a # M) - 1) (a # M)", "thus ?case"], ["proof (prove)\nusing this:\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel (currentLevel M' - 1) M'\n  markedElements (a # M') \\<noteq> []\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel (currentLevel (a # M') - 1) (a # M')", "proof (cases \"marked a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')\n 2. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; \\<not> marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')", "case True"], ["proof (state)\nthis:\n  marked a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')\n 2. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; \\<not> marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')", "hence \"currentLevel (a # M') \\<ge> 1\""], ["proof (prove)\nusing this:\n  marked a\n\ngoal (1 subgoal):\n 1. 1 \\<le> currentLevel (a # M')", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked a\n\ngoal (1 subgoal):\n 1. 1 \\<le> length (markedElements (a # M'))", "by simp"], ["proof (state)\nthis:\n  1 \\<le> currentLevel (a # M')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')\n 2. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; \\<not> marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')", "with True Cons"], ["proof (chain)\npicking this:\n  marked a\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel (currentLevel M' - 1) M'\n  markedElements (a # M') \\<noteq> []\n  1 \\<le> currentLevel (a # M')", "show ?thesis"], ["proof (prove)\nusing this:\n  marked a\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel (currentLevel M' - 1) M'\n  markedElements (a # M') \\<noteq> []\n  1 \\<le> currentLevel (a # M')\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel (currentLevel (a # M') - 1) (a # M')", "using prefixToLevel_auxIncreaseAuxilaryCounter[of \"0\" \"1\" \"M'\" \"currentLevel M' - 1\"]"], ["proof (prove)\nusing this:\n  marked a\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel (currentLevel M' - 1) M'\n  markedElements (a # M') \\<noteq> []\n  1 \\<le> currentLevel (a # M')\n  0 \\<le> 1 \\<Longrightarrow>\n  prefixToLevel_aux M' (currentLevel M' - 1) 0 =\n  prefixToLevel_aux M' (currentLevel M' - 1 + (1 - 0)) 1\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel (currentLevel (a # M') - 1) (a # M')", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  marked a\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel_aux M' (currentLevel M' - 1) 0\n  markedElements (a # M') \\<noteq> []\n  1 \\<le> currentLevel (a # M')\n  0 \\<le> 1 \\<Longrightarrow>\n  prefixToLevel_aux M' (currentLevel M' - 1) 0 =\n  prefixToLevel_aux M' (currentLevel M' - 1 + (1 - 0)) 1\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel_aux (a # M') (currentLevel (a # M') - 1) 0", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  marked a\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' =\n  prefixToLevel_aux M' (length (markedElements M') - 1) 0\n  markedElements (a # M') \\<noteq> []\n  1 \\<le> length (markedElements (a # M'))\n  0 \\<le> 1 \\<Longrightarrow>\n  prefixToLevel_aux M' (length (markedElements M') - 1) 0 =\n  prefixToLevel_aux M' (length (markedElements M') - 1 + (1 - 0)) 1\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel_aux (a # M') (length (markedElements (a # M')) - 1) 0", "by auto"], ["proof (state)\nthis:\n  prefixBeforeLastMarked (a # M') =\n  prefixToLevel (currentLevel (a # M') - 1) (a # M')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; \\<not> marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; \\<not> marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')", "case False"], ["proof (state)\nthis:\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>markedElements M' \\<noteq> [] \\<Longrightarrow>\n             prefixBeforeLastMarked M' =\n             prefixToLevel (currentLevel M' - 1) M';\n     markedElements (a # M') \\<noteq> []; \\<not> marked a\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked (a # M') =\n                      prefixToLevel (currentLevel (a # M') - 1) (a # M')", "with Cons"], ["proof (chain)\npicking this:\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel (currentLevel M' - 1) M'\n  markedElements (a # M') \\<noteq> []\n  \\<not> marked a", "show ?thesis"], ["proof (prove)\nusing this:\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel (currentLevel M' - 1) M'\n  markedElements (a # M') \\<noteq> []\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel (currentLevel (a # M') - 1) (a # M')", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' = prefixToLevel_aux M' (currentLevel M' - 1) 0\n  markedElements (a # M') \\<noteq> []\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel_aux (a # M') (currentLevel (a # M') - 1) 0", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  markedElements M' \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastMarked M' =\n  prefixToLevel_aux M' (length (markedElements M') - 1) 0\n  markedElements (a # M') \\<noteq> []\n  \\<not> marked a\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixToLevel_aux (a # M') (length (markedElements (a # M')) - 1) 0", "by auto"], ["proof (state)\nthis:\n  prefixBeforeLastMarked (a # M') =\n  prefixToLevel (currentLevel (a # M') - 1) (a # M')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixBeforeLastMarked (a # M') =\n  prefixToLevel (currentLevel (a # M') - 1) (a # M')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isPrefixPrefixBeforeLastMarked:\n  shows \"isPrefix (prefixBeforeLastMarked M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixBeforeLastMarked M) M", "unfolding isPrefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. prefixBeforeLastMarked M @ s = M", "by (induct M) auto"], ["", "lemma lastMarkedNotInPrefixBeforeLastMarked:\n  assumes \"uniq (elements M)\" and \"markedElements M \\<noteq> []\"\n  shows \"\\<not> (lastMarked M) \\<in> set (elements (prefixBeforeLastMarked M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lastMarked M \\<notin> set (elements (prefixBeforeLastMarked M))", "using assms"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. lastMarked M \\<notin> set (elements (prefixBeforeLastMarked M))", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (markedElements M)\n    \\<notin> set (elements (prefixBeforeLastMarked M))", "by (induct M) (auto split: if_split_asm simp add: markedElementsAreElements)"], ["", "lemma uniqImpliesPrefixBeforeLastMarkedIsPrefixBeforeLastMarked:\n  assumes \"markedElements M \\<noteq> []\" and \"(lastMarked M) \\<notin> set (elements M)\"\n  shows \"prefixBeforeLastMarked M = prefixBeforeElement (lastMarked M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked M = prefixBeforeElement (lastMarked M) M", "using assms"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n  lastMarked M \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked M = prefixBeforeElement (lastMarked M) M", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n  last (markedElements M) \\<notin> set (elements M)\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked M =\n    prefixBeforeElement (last (markedElements M)) M", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>markedElements [] \\<noteq> [];\n     last (markedElements []) \\<notin> set (elements [])\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked [] =\n                      prefixBeforeElement (last (markedElements [])) []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>markedElements M \\<noteq> [];\n                 last (markedElements M) \\<notin> set (elements M)\\<rbrakk>\n                \\<Longrightarrow> prefixBeforeLastMarked M =\n                                  prefixBeforeElement\n                                   (last (markedElements M)) M;\n        markedElements (a # M) \\<noteq> [];\n        last (markedElements (a # M))\n        \\<notin> set (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixBeforeElement (last (markedElements (a # M)))\n                          (a # M)", "case Nil"], ["proof (state)\nthis:\n  markedElements [] \\<noteq> []\n  last (markedElements []) \\<notin> set (elements [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>markedElements [] \\<noteq> [];\n     last (markedElements []) \\<notin> set (elements [])\\<rbrakk>\n    \\<Longrightarrow> prefixBeforeLastMarked [] =\n                      prefixBeforeElement (last (markedElements [])) []\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>markedElements M \\<noteq> [];\n                 last (markedElements M) \\<notin> set (elements M)\\<rbrakk>\n                \\<Longrightarrow> prefixBeforeLastMarked M =\n                                  prefixBeforeElement\n                                   (last (markedElements M)) M;\n        markedElements (a # M) \\<noteq> [];\n        last (markedElements (a # M))\n        \\<notin> set (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixBeforeElement (last (markedElements (a # M)))\n                          (a # M)", "thus ?case"], ["proof (prove)\nusing this:\n  markedElements [] \\<noteq> []\n  last (markedElements []) \\<notin> set (elements [])\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked [] =\n    prefixBeforeElement (last (markedElements [])) []", "by auto"], ["proof (state)\nthis:\n  prefixBeforeLastMarked [] =\n  prefixBeforeElement (last (markedElements [])) []\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>markedElements M \\<noteq> [];\n                 last (markedElements M) \\<notin> set (elements M)\\<rbrakk>\n                \\<Longrightarrow> prefixBeforeLastMarked M =\n                                  prefixBeforeElement\n                                   (last (markedElements M)) M;\n        markedElements (a # M) \\<noteq> [];\n        last (markedElements (a # M))\n        \\<notin> set (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixBeforeElement (last (markedElements (a # M)))\n                          (a # M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>markedElements M \\<noteq> [];\n                 last (markedElements M) \\<notin> set (elements M)\\<rbrakk>\n                \\<Longrightarrow> prefixBeforeLastMarked M =\n                                  prefixBeforeElement\n                                   (last (markedElements M)) M;\n        markedElements (a # M) \\<noteq> [];\n        last (markedElements (a # M))\n        \\<notin> set (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixBeforeElement (last (markedElements (a # M)))\n                          (a # M)", "case (Cons a M')"], ["proof (state)\nthis:\n  \\<lbrakk>markedElements M' \\<noteq> [];\n   last (markedElements M') \\<notin> set (elements M')\\<rbrakk>\n  \\<Longrightarrow> prefixBeforeLastMarked M' =\n                    prefixBeforeElement (last (markedElements M')) M'\n  markedElements (a # M') \\<noteq> []\n  last (markedElements (a # M')) \\<notin> set (elements (a # M'))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>markedElements M \\<noteq> [];\n                 last (markedElements M) \\<notin> set (elements M)\\<rbrakk>\n                \\<Longrightarrow> prefixBeforeLastMarked M =\n                                  prefixBeforeElement\n                                   (last (markedElements M)) M;\n        markedElements (a # M) \\<noteq> [];\n        last (markedElements (a # M))\n        \\<notin> set (elements (a # M))\\<rbrakk>\n       \\<Longrightarrow> prefixBeforeLastMarked (a # M) =\n                         prefixBeforeElement (last (markedElements (a # M)))\n                          (a # M)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "proof (cases \"marked a \\<and> (markedElements M') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. marked a \\<and> markedElements M' = [] \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')\n 2. \\<not> (marked a \\<and> markedElements M' = []) \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "case True"], ["proof (state)\nthis:\n  marked a \\<and> markedElements M' = []\n\ngoal (2 subgoals):\n 1. marked a \\<and> markedElements M' = [] \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')\n 2. \\<not> (marked a \\<and> markedElements M' = []) \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "thus ?thesis"], ["proof (prove)\nusing this:\n  marked a \\<and> markedElements M' = []\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  marked a \\<and> markedElements M' = []\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "by auto"], ["proof (state)\nthis:\n  prefixBeforeLastMarked (a # M') =\n  prefixBeforeElement (last (markedElements (a # M'))) (a # M')\n\ngoal (1 subgoal):\n 1. \\<not> (marked a \\<and> markedElements M' = []) \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (marked a \\<and> markedElements M' = []) \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "case False"], ["proof (state)\nthis:\n  \\<not> (marked a \\<and> markedElements M' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (marked a \\<and> markedElements M' = []) \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "hence \"last (markedElements (a # M')) = last (markedElements M')\""], ["proof (prove)\nusing this:\n  \\<not> (marked a \\<and> markedElements M' = [])\n\ngoal (1 subgoal):\n 1. last (markedElements (a # M')) = last (markedElements M')", "by auto"], ["proof (state)\nthis:\n  last (markedElements (a # M')) = last (markedElements M')\n\ngoal (1 subgoal):\n 1. \\<not> (marked a \\<and> markedElements M' = []) \\<Longrightarrow>\n    prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "thus ?thesis"], ["proof (prove)\nusing this:\n  last (markedElements (a # M')) = last (markedElements M')\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "using Cons"], ["proof (prove)\nusing this:\n  last (markedElements (a # M')) = last (markedElements M')\n  \\<lbrakk>markedElements M' \\<noteq> [];\n   last (markedElements M') \\<notin> set (elements M')\\<rbrakk>\n  \\<Longrightarrow> prefixBeforeLastMarked M' =\n                    prefixBeforeElement (last (markedElements M')) M'\n  markedElements (a # M') \\<noteq> []\n  last (markedElements (a # M')) \\<notin> set (elements (a # M'))\n\ngoal (1 subgoal):\n 1. prefixBeforeLastMarked (a # M') =\n    prefixBeforeElement (last (markedElements (a # M'))) (a # M')", "by (auto split: if_split_asm simp add: markedElementsAreElements)"], ["proof (state)\nthis:\n  prefixBeforeLastMarked (a # M') =\n  prefixBeforeElement (last (markedElements (a # M'))) (a # M')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixBeforeLastMarked (a # M') =\n  prefixBeforeElement (last (markedElements (a # M'))) (a # M')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma markedElementsAreElementsBeforeLastDecisionAndLastDecision: \n  assumes \"markedElements M \\<noteq> []\"\n  shows \"(markedElements M) = (markedElements (prefixBeforeLastMarked M)) @ [lastMarked M]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. markedElements M =\n    markedElements (prefixBeforeLastMarked M) @ [lastMarked M]", "using assms"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. markedElements M =\n    markedElements (prefixBeforeLastMarked M) @ [lastMarked M]", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  markedElements M \\<noteq> []\n\ngoal (1 subgoal):\n 1. markedElements M =\n    markedElements (prefixBeforeLastMarked M) @ [last (markedElements M)]", "by (induct M) (auto split: if_split_asm)"], ["", "end"]]}