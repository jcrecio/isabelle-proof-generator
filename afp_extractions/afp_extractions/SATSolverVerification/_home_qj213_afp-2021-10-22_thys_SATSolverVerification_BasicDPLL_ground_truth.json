{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/BasicDPLL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma applicableDecideCharacterization:\n  fixes stateA::State\n  shows \"applicableDecide stateA decisionVars = \n  (\\<exists> l. \n        (var l) \\<in> decisionVars \\<and> \n        \\<not> l el (elements (getM stateA)) \\<and> \n        \\<not> opposite l el (elements (getM stateA))) \n  \" (is \"?lhs = ?rhs\")", "lemma applicableUnitPropagateCharacterization:\n  fixes stateA::State and F0::Formula\n  shows \"applicableUnitPropagate stateA F0 = \n  (\\<exists> (uc::Clause) (ul::Literal). \n       uc el F0 \\<and> \n       isUnitClause uc ul (elements (getM stateA)))\n  \" (is \"?lhs = ?rhs\")", "lemma applicableBacktrackCharacterization:\n  fixes stateA::State\n  shows \"applicableBacktrack stateA F0 = \n      (formulaFalse F0 (elements (getM stateA)) \\<and> \n       decisions (getM stateA) \\<noteq> [])\" (is \"?lhs = ?rhs\")", "lemma finalStateNonApplicable: \n  fixes state::State\n  shows \"isFinalState state F0 decisionVars = \n          (\\<not> applicableDecide state decisionVars \\<and> \n           \\<not> applicableUnitPropagate state F0 \\<and> \n           \\<not> applicableBacktrack state F0)\"", "lemma invariantsHoldInInitialState:\n  fixes state :: State and F0 :: Formula\n  assumes \"isInitialState state F0\" \n  shows \"invariantsHoldInState state F0 decisionVars\"", "lemma transitionsPreserveInvariants: \n  fixes stateA::State and stateB::State\n  assumes \"transition stateA stateB F0 decisionVars\" and \n  \"invariantsHoldInState stateA F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\"", "lemma invariantsHoldInValidRuns: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"(stateA, stateB) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\"", "lemma invariantsHoldInValidRunsFromInitialState:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"isInitialState state0 F0\" \n  and \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState state F0 decisionVars\"", "theorem soundnessForUNSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n\n  \"formulaFalse F0 (elements (getM state))\"\n  \"decisions (getM state) = []\"\n  shows \"\\<not> satisfiable F0\"", "theorem soundnessForSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n\n  \"\\<not> formulaFalse F0 (elements (getM state))\"\n  \"vars (elements (getM state)) \\<supseteq> decisionVars\"  \n\n  shows \n  \"model (elements (getM state)) F0\"", "lemma trailIsDecreasedByDeciedUnitPropagateAndBacktrack:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 \\<or> appliedBacktrack stateA stateB F0\"\n  shows \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\"", "lemma stateIsDecreasedByValidTransitions:\n  fixes stateA::State and stateB::State \n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and \"transition stateA stateB F0 decisionVars\"\n  shows \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\"", "lemma minimalStatesAreFinal:\n  fixes stateA::State\n  assumes \"invariantsHoldInState state F0 decisionVars\" and \"isMinimalState state F0 decisionVars\"\n  shows \"isFinalState state F0 decisionVars\"", "lemma wfTerminationLess: \n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\"\n  shows \"wf (terminationLess F0 decisionVars)\"", "theorem wfTransitionRelation:\n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\" and state0 :: \"State\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\"\n  shows \"wf {(stateB, stateA). \n             (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and> (transition stateA stateB F0 decisionVars)}\"", "lemma finalNonConflictState: \n  fixes state::State and FO :: Formula\n  assumes \n  \"\\<not> applicableDecide state decisionVars\"\n  shows \"vars (elements (getM state)) \\<supseteq> decisionVars\"", "lemma finalConflictingState: \n  fixes state :: State\n  assumes \n  \"\\<not> applicableBacktrack state F0\" and\n  \"formulaFalse F0 (elements (getM state))\"  \n  shows\n  \"decisions (getM state) = []\"", "lemma finalStateCharacterizationLemma:\n  fixes state :: State\n  assumes \n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableBacktrack state F0\"\n  shows\n  \"(\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = [])\"", "theorem finalStateCharacterization:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n  shows \n  \"(\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = [])\"", "theorem completenessForSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \"\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars\"", "theorem completenessForUNSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n  \"\\<not> satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\"", "theorem partialCorrectness: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and  \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"satisfiable F0 = (\\<not> formulaFalse F0 (elements (getM state)))\""], "translations": [["", "lemma applicableDecideCharacterization:\n  fixes stateA::State\n  shows \"applicableDecide stateA decisionVars = \n  (\\<exists> l. \n        (var l) \\<in> decisionVars \\<and> \n        \\<not> l el (elements (getM stateA)) \\<and> \n        \\<not> opposite l el (elements (getM stateA))) \n  \" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars =\n    (\\<exists>l.\n        var l \\<in> decisionVars \\<and>\n        \\<not> l el elements (getM stateA) \\<and>\n        \\<not> opposite l el elements (getM stateA))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)", "obtain l where \n    *: \"(var l) \\<in> decisionVars\" \"\\<not> l el (elements (getM stateA))\" \"\\<not> opposite l el (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "let ?stateB = \"stateA\\<lparr> getM := (getM stateA) @ [(l, True)] \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "from *"], ["proof (chain)\npicking this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)", "have \"appliedDecide stateA ?stateB decisionVars\""], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. appliedDecide stateA\n     (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>la.\n       var la \\<in> decisionVars \\<and>\n       \\<not> la el elements (getM stateA) \\<and>\n       \\<not> opposite la el elements (getM stateA) \\<and>\n       getM (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) =\n       getM stateA @ [(la, True)]", "by auto"], ["proof (state)\nthis:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "thus ?lhs"], ["proof (prove)\nusing this:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedDecide stateA state' decisionVars", "by auto"], ["proof (state)\nthis:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "assume ?lhs"], ["proof (state)\nthis:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "then"], ["proof (chain)\npicking this:\n  applicableDecide stateA decisionVars", "obtain stateB l\n    where \"(var l) \\<in> decisionVars\" \"\\<not> l el (elements (getM stateA))\"\n    \"\\<not> opposite l el (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedDecide stateA state' decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>state' l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getM state' = getM stateA @ [(l, True)]\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "thus ?rhs"], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "by auto"], ["proof (state)\nthis:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableUnitPropagateCharacterization:\n  fixes stateA::State and F0::Formula\n  shows \"applicableUnitPropagate stateA F0 = \n  (\\<exists> (uc::Clause) (ul::Literal). \n       uc el F0 \\<and> \n       isUnitClause uc ul (elements (getM stateA)))\n  \" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 =\n    (\\<exists>uc ul.\n        uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>uc ul.\n     uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0", "then"], ["proof (chain)\npicking this:\n  \\<exists>uc ul.\n     uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))", "obtain ul uc \n    where *: \"uc el F0\" \"isUnitClause uc ul (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  uc el F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0", "let ?stateB = \"stateA\\<lparr> getM := getM stateA @ [(ul, False)] \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0", "from *"], ["proof (chain)\npicking this:\n  uc el F0\n  isUnitClause uc ul (elements (getM stateA))", "have \"appliedUnitPropagate stateA ?stateB F0\""], ["proof (prove)\nusing this:\n  uc el F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. appliedUnitPropagate stateA\n     (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  uc el F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>uc ula.\n       uc el F0 \\<and>\n       isUnitClause uc ula (elements (getM stateA)) \\<and>\n       getM (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) =\n       getM stateA @ [(ula, False)]", "by auto"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       uc el F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0", "thus ?lhs"], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedUnitPropagate stateA state' F0", "by auto"], ["proof (state)\nthis:\n  applicableUnitPropagate stateA F0\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))", "assume ?lhs"], ["proof (state)\nthis:\n  applicableUnitPropagate stateA F0\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))", "then"], ["proof (chain)\npicking this:\n  applicableUnitPropagate stateA F0", "obtain stateB uc ul\n    where \"uc el F0\" \"isUnitClause uc ul (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableUnitPropagate stateA F0\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedUnitPropagate stateA state' F0\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>state' uc ul.\n     uc el F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getM state' = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  uc el F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 \\<Longrightarrow>\n    \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))", "thus ?rhs"], ["proof (prove)\nusing this:\n  uc el F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>uc ul.\n       uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))", "by auto"], ["proof (state)\nthis:\n  \\<exists>uc ul.\n     uc el F0 \\<and> isUnitClause uc ul (elements (getM stateA))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableBacktrackCharacterization:\n  fixes stateA::State\n  shows \"applicableBacktrack stateA F0 = \n      (formulaFalse F0 (elements (getM stateA)) \\<and> \n       decisions (getM stateA) \\<noteq> [])\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableBacktrack stateA F0 =\n    (formulaFalse F0 (elements (getM stateA)) \\<and>\n     decisions (getM stateA) \\<noteq> [])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []\n 2. formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> [] \\<Longrightarrow>\n    applicableBacktrack stateA F0", "assume ?rhs"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM stateA)) \\<and>\n  decisions (getM stateA) \\<noteq> []\n\ngoal (2 subgoals):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []\n 2. formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> [] \\<Longrightarrow>\n    applicableBacktrack stateA F0", "hence *: \"formulaFalse F0 (elements (getM stateA))\" \"decisions (getM stateA) \\<noteq> []\""], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA)) \\<and>\n  decisions (getM stateA) \\<noteq> []\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM stateA)) &&&\n    decisions (getM stateA) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n\ngoal (2 subgoals):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []\n 2. formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> [] \\<Longrightarrow>\n    applicableBacktrack stateA F0", "let ?stateB = \"stateA\\<lparr> getM := prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []\n 2. formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> [] \\<Longrightarrow>\n    applicableBacktrack stateA F0", "from *"], ["proof (chain)\npicking this:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []", "have \"appliedBacktrack stateA ?stateB F0\""], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n\ngoal (1 subgoal):\n 1. appliedBacktrack stateA\n     (stateA\n      \\<lparr>getM :=\n                prefixBeforeLastDecision (getM stateA) @\n                [(opposite (lastDecision (getM stateA)), False)]\\<rparr>)\n     F0", "unfolding appliedBacktrack_def"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> [] \\<and>\n    getM\n     (stateA\n      \\<lparr>getM :=\n                prefixBeforeLastDecision (getM stateA) @\n                [(opposite (lastDecision (getM stateA)), False)]\\<rparr>) =\n    prefixBeforeLastDecision (getM stateA) @\n    [(opposite (lastDecision (getM stateA)), False)]", "by auto"], ["proof (state)\nthis:\n  appliedBacktrack stateA\n   (stateA\n    \\<lparr>getM :=\n              prefixBeforeLastDecision (getM stateA) @\n              [(opposite (lastDecision (getM stateA)), False)]\\<rparr>)\n   F0\n\ngoal (2 subgoals):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []\n 2. formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> [] \\<Longrightarrow>\n    applicableBacktrack stateA F0", "thus ?lhs"], ["proof (prove)\nusing this:\n  appliedBacktrack stateA\n   (stateA\n    \\<lparr>getM :=\n              prefixBeforeLastDecision (getM stateA) @\n              [(opposite (lastDecision (getM stateA)), False)]\\<rparr>)\n   F0\n\ngoal (1 subgoal):\n 1. applicableBacktrack stateA F0", "unfolding applicableBacktrack_def"], ["proof (prove)\nusing this:\n  appliedBacktrack stateA\n   (stateA\n    \\<lparr>getM :=\n              prefixBeforeLastDecision (getM stateA) @\n              [(opposite (lastDecision (getM stateA)), False)]\\<rparr>)\n   F0\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedBacktrack stateA state' F0", "by auto"], ["proof (state)\nthis:\n  applicableBacktrack stateA F0\n\ngoal (1 subgoal):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []", "assume \"?lhs\""], ["proof (state)\nthis:\n  applicableBacktrack stateA F0\n\ngoal (1 subgoal):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  applicableBacktrack stateA F0", "obtain stateB \n    where \"appliedBacktrack stateA stateB F0\""], ["proof (prove)\nusing this:\n  applicableBacktrack stateA F0\n\ngoal (1 subgoal):\n 1. (\\<And>stateB.\n        appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableBacktrack_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedBacktrack stateA state' F0\n\ngoal (1 subgoal):\n 1. (\\<And>stateB.\n        appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []", "hence \n    \"formulaFalse F0 (elements (getM stateA))\"\n    \"decisions (getM stateA) \\<noteq> []\"\n    \"getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\""], ["proof (prove)\nusing this:\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM stateA)) &&&\n    decisions (getM stateA) \\<noteq> [] &&&\n    getM stateB =\n    prefixBeforeLastDecision (getM stateA) @\n    [(opposite (lastDecision (getM stateA)), False)]", "unfolding appliedBacktrack_def"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA)) \\<and>\n  decisions (getM stateA) \\<noteq> [] \\<and>\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM stateA)) &&&\n    decisions (getM stateA) \\<noteq> [] &&&\n    getM stateB =\n    prefixBeforeLastDecision (getM stateA) @\n    [(opposite (lastDecision (getM stateA)), False)]", "by auto"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. applicableBacktrack stateA F0 \\<Longrightarrow>\n    formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []", "thus ?rhs"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM stateA)) \\<and>\n    decisions (getM stateA) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM stateA)) \\<and>\n  decisions (getM stateA) \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Final states are the ones where no rule is applicable.\\<close>"], ["", "lemma finalStateNonApplicable: \n  fixes state::State\n  shows \"isFinalState state F0 decisionVars = \n          (\\<not> applicableDecide state decisionVars \\<and> \n           \\<not> applicableUnitPropagate state F0 \\<and> \n           \\<not> applicableBacktrack state F0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state F0 \\<and>\n     \\<not> applicableBacktrack state F0)", "unfolding isFinalState_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'. transition state state' F0 decisionVars) =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state F0 \\<and>\n     \\<not> applicableBacktrack state F0)", "unfolding transition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 \\<or>\n        appliedBacktrack state state' F0) =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state F0 \\<and>\n     \\<not> applicableBacktrack state F0)", "unfolding applicableDecide_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 \\<or>\n        appliedBacktrack state state' F0) =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     \\<not> applicableUnitPropagate state F0 \\<and>\n     \\<not> applicableBacktrack state F0)", "unfolding applicableUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 \\<or>\n        appliedBacktrack state state' F0) =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'. appliedUnitPropagate state state' F0) \\<and>\n     \\<not> applicableBacktrack state F0)", "unfolding applicableBacktrack_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 \\<or>\n        appliedBacktrack state state' F0) =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'. appliedUnitPropagate state state' F0) \\<and>\n     (\\<nexists>state'. appliedBacktrack state state' F0))", "by auto"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>Invariants that are relevant for the rest of correctness proof.\\<close>"], ["", "definition\ninvariantsHoldInState :: \"State \\<Rightarrow> Formula \\<Rightarrow> Variable set \\<Rightarrow> bool\"\nwhere\n\"invariantsHoldInState state F0 decisionVars == \n    InvariantImpliedLiterals F0 (getM state) \\<and>\n    InvariantVarsM (getM state) F0 decisionVars \\<and>\n    InvariantConsistent (getM state) \\<and>\n    InvariantUniq (getM state)\n\""], ["", "text\\<open>Invariants hold in initial states.\\<close>"], ["", "lemma invariantsHoldInInitialState:\n  fixes state :: State and F0 :: Formula\n  assumes \"isInitialState state F0\" \n  shows \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using assms"], ["proof (prove)\nusing this:\n  isInitialState state F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by (auto simp add:\n  isInitialState_def \n  invariantsHoldInState_def \n  InvariantImpliedLiterals_def \n  InvariantVarsM_def\n  InvariantConsistent_def\n  InvariantUniq_def\n)"], ["", "text\\<open>Valid transitions preserve invariants.\\<close>"], ["", "lemma transitionsPreserveInvariants: \n  fixes stateA::State and stateB::State\n  assumes \"transition stateA stateB F0 decisionVars\" and \n  \"invariantsHoldInState stateA F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars", "have \n      \"InvariantImpliedLiterals F0 (getM stateA)\" and \n      \"InvariantVarsM (getM stateA) F0 decisionVars\" and\n      \"InvariantConsistent (getM stateA)\" and\n      \"InvariantUniq (getM stateA)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. (InvariantImpliedLiterals F0 (getM stateA) &&&\n     InvariantVarsM (getM stateA) F0 decisionVars) &&&\n    InvariantConsistent (getM stateA) &&& InvariantUniq (getM stateA)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateA) \\<and>\n  InvariantVarsM (getM stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and> InvariantUniq (getM stateA)\n\ngoal (1 subgoal):\n 1. (InvariantImpliedLiterals F0 (getM stateA) &&&\n     InvariantVarsM (getM stateA) F0 decisionVars) &&&\n    InvariantConsistent (getM stateA) &&& InvariantUniq (getM stateA)", "by auto"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateA)\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateA)\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedDecide stateA stateB decisionVars\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars", "obtain l::Literal where\n      \"(var l) \\<in> decisionVars\"\n      \"\\<not> literalTrue l (elements (getM stateA))\"\n      \"\\<not> literalFalse l (elements (getM stateA))\"\n      \"getM stateB = getM stateA @ [(l, True)]\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> literalTrue l (elements (getM stateA));\n         \\<not> literalFalse l (elements (getM stateA));\n         getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getM stateB = getM stateA @ [(l, True)]\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> literalTrue l (elements (getM stateA));\n         \\<not> literalFalse l (elements (getM stateA));\n         getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n  getM stateB = getM stateA @ [(l, True)]\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>\\<not> literalTrue l (elements (getM stateA))\\<close> \\<open>\\<not> literalFalse l (elements (getM stateA))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))", "have *: \"var l \\<notin> vars (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars (elements (getM stateA))", "using variableDefinedImpliesLiteralDefined[of \"l\" \"elements (getM stateA)\"]"], ["proof (prove)\nusing this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n  (var l \\<in> vars (elements (getM stateA))) =\n  (literalTrue l (elements (getM stateA)) \\<or>\n   literalFalse l (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  var l \\<notin> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantImpliedLiterals F0 (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB)", "using \n        \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantImpliedLiterals F0 (getM stateA)\\<close>\n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantImpliedLiteralsAfterDecide[of \"F0\" \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantImpliedLiterals F0 (getM stateA)\n  InvariantUniq (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantImpliedLiterals F0 (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>var l \\<in> decisionVars\\<close>\n        InvariantVarsMAfterDecide[of \"getM stateA\" \"F0\" \"decisionVars\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantVarsM (getM stateA) F0 decisionVars\n  var l \\<in> decisionVars\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   var l \\<in> decisionVars;\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantConsistentAfterDecide[of \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantConsistent (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantUniqAfterDecide[of \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantUniq (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantUniq (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB) \\<and>\n    InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and> InvariantUniq (getM stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedUnitPropagate stateA stateB F0\""], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedUnitPropagate stateA stateB F0", "obtain uc::Clause and ul::Literal where \n      \"uc el F0\"\n      \"isUnitClause uc ul (elements (getM stateA))\"\n      \"getM stateB = getM stateA @ [(ul, False)]\""], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA stateB F0\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el F0; isUnitClause uc ul (elements (getM stateA));\n         getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getM stateB = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>uc el F0; isUnitClause uc ul (elements (getM stateA));\n         getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  uc el F0\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>"], ["proof (chain)\npicking this:\n  isUnitClause uc ul (elements (getM stateA))", "have \"ul el uc\""], ["proof (prove)\nusing this:\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. ul el uc", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  ul el uc \\<and>\n  \\<not> literalTrue ul (elements (getM stateA)) \\<and>\n  \\<not> literalFalse ul (elements (getM stateA)) \\<and>\n  (\\<forall>literal.\n      literal el uc \\<and> literal \\<noteq> ul \\<longrightarrow>\n      literalFalse literal (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. ul el uc", "by simp"], ["proof (state)\nthis:\n  ul el uc\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>uc el F0\\<close>"], ["proof (chain)\npicking this:\n  uc el F0", "have \"formulaEntailsClause F0 uc\""], ["proof (prove)\nusing this:\n  uc el F0\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F0 uc", "by (simp add: formulaEntailsItsClauses)"], ["proof (state)\nthis:\n  formulaEntailsClause F0 uc\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantImpliedLiterals F0 (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB)", "using\n        \\<open>InvariantImpliedLiterals F0 (getM stateA)\\<close> \n        \\<open>formulaEntailsClause F0 uc\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantImpliedLiteralsAfterUnitPropagate[of \"F0\" \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateA)\n  formulaEntailsClause F0 uc\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantImpliedLiterals F0 (getM stateA);\n   formulaEntailsClause F0 uc; isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>ul el uc\\<close> \\<open>uc el F0\\<close>"], ["proof (chain)\npicking this:\n  ul el uc\n  uc el F0", "have \"ul el F0\""], ["proof (prove)\nusing this:\n  ul el uc\n  uc el F0\n\ngoal (1 subgoal):\n 1. ul el F0", "by (auto simp add: literalElFormulaCharacterization)"], ["proof (state)\nthis:\n  ul el F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "hence \"var ul \\<in> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  ul el F0\n\ngoal (1 subgoal):\n 1. var ul \\<in> vars F0 \\<union> decisionVars", "using formulaContainsItsLiteralsVariable [of \"ul\" \"F0\"]"], ["proof (prove)\nusing this:\n  ul el F0\n  ul el F0 \\<Longrightarrow> var ul \\<in> vars F0\n\ngoal (1 subgoal):\n 1. var ul \\<in> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  var ul \\<in> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>var ul \\<in> vars F0 \\<union> decisionVars\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantVarsMAfterUnitPropagate[of \"getM stateA\" \"F0\" \"decisionVars\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  var ul \\<in> vars F0 \\<union> decisionVars\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   var ul \\<in> vars F0 \\<union> decisionVars;\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantConsistentAfterUnitPropagate [of \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantUniqAfterUnitPropagate [of \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantUniq (getM stateA);\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB) \\<and>\n    InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and> InvariantUniq (getM stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedBacktrack stateA stateB F0\""], ["proof (state)\nthis:\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "hence \"formulaFalse F0 (elements (getM stateA))\" \n      \"formulaFalse F0 (elements (getM stateA))\"\n      \"decisions (getM stateA) \\<noteq> []\"\n      \"getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\""], ["proof (prove)\nusing this:\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. (formulaFalse F0 (elements (getM stateA)) &&&\n     formulaFalse F0 (elements (getM stateA))) &&&\n    decisions (getM stateA) \\<noteq> [] &&&\n    getM stateB =\n    prefixBeforeLastDecision (getM stateA) @\n    [(opposite (lastDecision (getM stateA)), False)]", "unfolding appliedBacktrack_def"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA)) \\<and>\n  decisions (getM stateA) \\<noteq> [] \\<and>\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. (formulaFalse F0 (elements (getM stateA)) &&&\n     formulaFalse F0 (elements (getM stateA))) &&&\n    decisions (getM stateA) \\<noteq> [] &&&\n    getM stateB =\n    prefixBeforeLastDecision (getM stateA) @\n    [(opposite (lastDecision (getM stateA)), False)]", "by auto"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM stateA))\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantImpliedLiterals F0 (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB)", "using \\<open>InvariantImpliedLiterals F0 (getM stateA)\\<close>\n        \\<open>formulaFalse F0 (elements (getM stateA))\\<close>\n        \\<open>decisions (getM stateA) \\<noteq> []\\<close>\n        \\<open>getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\\<close>\n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>InvariantConsistent (getM stateA)\\<close>\n        InvariantImpliedLiteralsAfterBacktrack[of \"F0\" \"getM stateA\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateA)\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n  InvariantUniq (getM stateA)\n  InvariantConsistent (getM stateA)\n  \\<lbrakk>InvariantImpliedLiterals F0 (getM stateA);\n   InvariantUniq (getM stateA); InvariantConsistent (getM stateA);\n   decisions (getM stateA) \\<noteq> [];\n   formulaFalse F0 (elements (getM stateA));\n   getM stateB =\n   prefixBeforeLastDecision (getM stateA) @\n   [(opposite (lastDecision (getM stateA)), False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>decisions (getM stateA) \\<noteq> []\\<close>\n        \\<open>getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\\<close>\n        InvariantVarsMAfterBacktrack[of \"getM stateA\" \"F0\" \"decisionVars\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   decisions (getM stateA) \\<noteq> [];\n   getM stateB =\n   prefixBeforeLastDecision (getM stateA) @\n   [(opposite (lastDecision (getM stateA)), False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>decisions (getM stateA) \\<noteq> []\\<close>\n        \\<open>getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\\<close>\n        InvariantConsistentAfterBacktrack[of \"getM stateA\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n  \\<lbrakk>InvariantUniq (getM stateA); InvariantConsistent (getM stateA);\n   decisions (getM stateA) \\<noteq> [];\n   getM stateB =\n   prefixBeforeLastDecision (getM stateA) @\n   [(opposite (lastDecision (getM stateA)), False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>decisions (getM stateA) \\<noteq> []\\<close>\n        \\<open>getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\\<close>\n        InvariantUniqAfterBacktrack[of \"getM stateA\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n  \\<lbrakk>InvariantUniq (getM stateA); InvariantConsistent (getM stateA);\n   decisions (getM stateA) \\<noteq> [];\n   getM stateB =\n   prefixBeforeLastDecision (getM stateA) @\n   [(opposite (lastDecision (getM stateA)), False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB)\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM stateB) \\<and>\n    InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and> InvariantUniq (getM stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using \\<open>transition stateA stateB F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  transition stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The consequence is that invariants hold in all valid runs.\\<close>"], ["", "lemma invariantsHoldInValidRuns: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"(stateA, stateB) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using assms"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using transitionsPreserveInvariants"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using rtrancl_induct[of \"stateA\" \"stateB\" \n  \"{(stateA, stateB). transition stateA stateB F0 decisionVars}\" \"\\<lambda> x. invariantsHoldInState x F0 decisionVars\"]"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n  \\<lbrakk>(stateA, stateB)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   invariantsHoldInState stateA F0 decisionVars;\n   \\<And>y z.\n      \\<lbrakk>(stateA, y)\n               \\<in> {(stateA, stateB).\n                      transition stateA stateB F0 decisionVars}\\<^sup>*;\n       (y, z)\n       \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars};\n       invariantsHoldInState y F0 decisionVars\\<rbrakk>\n      \\<Longrightarrow> invariantsHoldInState z F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n  \\<lbrakk>(stateA, stateB)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   invariantsHoldInState stateA F0 decisionVars;\n   \\<And>y z.\n      \\<lbrakk>(stateA, y)\n               \\<in> {(stateA, stateB).\n                      transition stateA stateB F0 decisionVars}\\<^sup>*;\n       (y, z)\n       \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars};\n       invariantsHoldInState y F0 decisionVars\\<rbrakk>\n      \\<Longrightarrow> invariantsHoldInState z F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["", "lemma invariantsHoldInValidRunsFromInitialState:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"isInitialState state0 F0\" \n  and \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "from \\<open>isInitialState state0 F0\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0", "have \"invariantsHoldInState state0 F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state0 F0 decisionVars", "by (simp add:invariantsHoldInInitialState)"], ["proof (state)\nthis:\n  invariantsHoldInState state0 F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "with assms"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  invariantsHoldInState state0 F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  invariantsHoldInState state0 F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRuns [of \"state0\"  \"F0\" \"decisionVars\" \"state\"]"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  invariantsHoldInState state0 F0 decisionVars\n  \\<lbrakk>invariantsHoldInState state0 F0 decisionVars;\n   (state0, state) \\<in> transitionRelation F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n In the following text we will show that there are two kinds of states:\n \\begin{enumerate}\n  \\item \\textit{UNSAT} states where @{term \"formulaFalse F0 (elements (getM state))\"}\n  and @{term \"decisions (getM state) = []\"}. \n  \\item \\textit{SAT} states where @{term \"\\<not> formulaFalse F0 (elements (getM state))\"}\n  and @{term \"vars (elements (getM state)) \\<supseteq> decisionVars\"}.\n \\end{enumerate}\n  \n The soundness theorems claim that if \\textit{UNSAT} state is reached\n the formula is unsatisfiable and if \\textit{SAT} state is reached,\n the formula is satisfiable.\n\n Completeness theorems claim that every final state is either\n \\textit{UNSAT} or \\textit{SAT}. A consequence of this and soundness\n theorems, is that if formula is unsatisfiable the solver will finish\n in an \\textit{UNSAT} state, and if the formula is satisfiable the\n solver will finish in a \\textit{SAT} state.\\<close>"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Soundness\\<close>"], ["", "(******************************************************************************)\n\n(*----------------------------------------------------------------------------*)"], ["", "theorem soundnessForUNSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n\n  \"formulaFalse F0 (elements (getM state))\"\n  \"decisions (getM state) = []\"\n  shows \"\\<not> satisfiable F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "hence \"InvariantImpliedLiterals F0 (getM state)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM state)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM state) \\<and>\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and> InvariantUniq (getM state)\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F0 (getM state)", "by auto"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F0 (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "with \\<open>formulaFalse F0 (elements (getM state))\\<close>\n    \\<open>decisions (getM state) = []\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n  InvariantImpliedLiterals F0 (getM state)", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n  InvariantImpliedLiterals F0 (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "using unsatReport[of \"F0\" \"getM state\" \"F0\"]"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n  InvariantImpliedLiterals F0 (getM state)\n  \\<lbrakk>InvariantImpliedLiterals F0 (getM state);\n   InvariantEquivalent F0 F0; decisions (getM state) = [];\n   formulaFalse F0 (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "unfolding InvariantEquivalent_def equivalentFormulae_def"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n  InvariantImpliedLiterals F0 (getM state)\n  \\<lbrakk>InvariantImpliedLiterals F0 (getM state);\n   \\<forall>valuation. model valuation F0 = model valuation F0;\n   decisions (getM state) = [];\n   formulaFalse F0 (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem soundnessForSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n\n  \"\\<not> formulaFalse F0 (elements (getM state))\"\n  \"vars (elements (getM state)) \\<supseteq> decisionVars\"  \n\n  shows \n  \"model (elements (getM state)) F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "hence \n    \"InvariantConsistent (getM state)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM state) \\<and>\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and> InvariantUniq (getM state)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state)", "by auto"], ["proof (state)\nthis:\n  InvariantConsistent (getM state)\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "with assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)", "show ?thesis"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "using satReport[of \"F0\" \"decisionVars\" \"F0\" \"getM state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars;\n   InvariantVarsF F0 F0 decisionVars; InvariantConsistent (getM state);\n   InvariantEquivalent F0 F0;\n   \\<not> formulaFalse F0 (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "unfolding InvariantEquivalent_def equivalentFormulae_def\n  InvariantVarsF_def"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars;\n   vars F0 \\<subseteq> vars F0 \\<union> decisionVars;\n   InvariantConsistent (getM state);\n   \\<forall>valuation. model valuation F0 = model valuation F0;\n   \\<not> formulaFalse F0 (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "by auto"], ["proof (state)\nthis:\n  model (elements (getM state)) F0\n\ngoal:\nNo subgoals!", "qed"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>We now define a termination ordering on the set of states based\non the @{term lexLessRestricted} trail ordering. This ordering will be central\nin termination proof.\\<close>"], ["", "definition \"terminationLess (F0::Formula) decisionVars == {((stateA::State), (stateB::State)).\n  (getM stateA, getM stateB) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\""], ["", "text\\<open>We want to show that every valid transition decreases a state\n  with respect to the constructed termination ordering. Therefore, we\n  show that $Decide$, $UnitPropagate$ and $Backtrack$ rule decrease the\n  trail with respect to the restricted trail ordering. Invariants\n  ensure that trails are indeed @{term uniq}, @{term consistent} and with \n  finite variable sets.\\<close>"], ["", "lemma trailIsDecreasedByDeciedUnitPropagateAndBacktrack:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 \\<or> appliedBacktrack stateA stateB F0\"\n  shows \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 \\<or> appliedBacktrack stateA stateB F0\\<close>\n    \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n  invariantsHoldInState stateA F0 decisionVars", "have \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using transitionsPreserveInvariants"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n  invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n  invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>appliedDecide ?stateA ?stateB ?decisionVars \\<or>\n           appliedUnitPropagate ?stateA ?stateB ?F0.0 \\<or>\n           appliedBacktrack ?stateA ?stateB ?F0.0;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars", "have *: \"uniq (elements (getM stateA))\" \"consistent (elements (getM stateA))\" \"vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateA) \\<and>\n  InvariantVarsM (getM stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and> InvariantUniq (getM stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateA) \\<and>\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and> InvariantUniq (getM stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateA) \\<and>\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  consistent (elements (getM stateA)) \\<and> InvariantUniq (getM stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateA) \\<and>\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  consistent (elements (getM stateA)) \\<and> uniq (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>invariantsHoldInState stateB F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateB F0 decisionVars", "have **: \"uniq (elements (getM stateB))\" \"consistent (elements (getM stateB))\" \"vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB) \\<and>\n  InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateB) \\<and> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB) \\<and>\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantConsistent (getM stateB) \\<and> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB) \\<and>\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  consistent (elements (getM stateB)) \\<and> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F0 (getM stateB) \\<and>\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  consistent (elements (getM stateB)) \\<and> uniq (elements (getM stateB))\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedDecide stateA stateB decisionVars\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getM stateB = getM stateA @ [(l, True)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (auto simp add:lexLessAppend)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"((getM stateB), (getM stateA)) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedUnitPropagate stateA stateB F0\""], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA stateB F0\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     uc el F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getM stateB = getM stateA @ [(ul, False)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (auto simp add:lexLessAppend)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "moreover"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedBacktrack stateA stateB F0\""], ["proof (state)\nthis:\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence\n      \"formulaFalse F0 (elements (getM stateA))\"\n      \"decisions (getM stateA) \\<noteq> []\"\n      \"getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\""], ["proof (prove)\nusing this:\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM stateA)) &&&\n    decisions (getM stateA) \\<noteq> [] &&&\n    getM stateB =\n    prefixBeforeLastDecision (getM stateA) @\n    [(opposite (lastDecision (getM stateA)), False)]", "unfolding appliedBacktrack_def"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA)) \\<and>\n  decisions (getM stateA) \\<noteq> [] \\<and>\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM stateA)) &&&\n    decisions (getM stateA) \\<noteq> [] &&&\n    getM stateB =\n    prefixBeforeLastDecision (getM stateA) @\n    [(opposite (lastDecision (getM stateA)), False)]", "by auto"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "using \\<open>decisions (getM stateA) \\<noteq> []\\<close>\n        \\<open>getM stateB = prefixBeforeLastDecision (getM stateA) @ [(opposite (lastDecision (getM stateA)), False)]\\<close>"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM stateA))\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n  decisions (getM stateA) \\<noteq> []\n  getM stateB =\n  prefixBeforeLastDecision (getM stateA) @\n  [(opposite (lastDecision (getM stateA)), False)]\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (simp add:lexLessBacktrack)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "using assms"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBacktrack stateA stateB F0 \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we can show that every rule application decreases a state\nwith respect to the constructed termination ordering.\\<close>"], ["", "lemma stateIsDecreasedByValidTransitions:\n  fixes stateA::State and stateB::State \n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and \"transition stateA stateB F0 decisionVars\"\n  shows \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "from \\<open>transition stateA stateB F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  transition stateA stateB F0 decisionVars", "have \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 \\<or> appliedBacktrack stateA stateB F0\""], ["proof (prove)\nusing this:\n  transition stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. appliedDecide stateA stateB decisionVars \\<or>\n    appliedUnitPropagate stateA stateB F0 \\<or>\n    appliedBacktrack stateA stateB F0", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. appliedDecide stateA stateB decisionVars \\<or>\n    appliedUnitPropagate stateA stateB F0 \\<or>\n    appliedBacktrack stateA stateB F0", "by simp"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "with \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "using trailIsDecreasedByDeciedUnitPropagateAndBacktrack"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 \\<or>\n  appliedBacktrack stateA stateB F0\n  \\<lbrakk>invariantsHoldInState ?stateA ?F0.0 ?decisionVars;\n   appliedDecide ?stateA ?stateB ?decisionVars \\<or>\n   appliedUnitPropagate ?stateA ?stateB ?F0.0 \\<or>\n   appliedBacktrack ?stateA ?stateB ?F0.0\\<rbrakk>\n  \\<Longrightarrow> (getM ?stateB, getM ?stateA)\n                    \\<in> lexLessRestricted\n                           (vars ?F0.0 \\<union> ?decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by simp"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (getM stateA, getM stateB)\n           \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The minimal states with respect to the termination ordering are\n  final i.e., no further transition rules are applicable.\\<close>"], ["", "definition \n\"isMinimalState stateMin F0 decisionVars == (\\<forall> state::State. (state, stateMin) \\<notin> terminationLess F0 decisionVars)\""], ["", "lemma minimalStatesAreFinal:\n  fixes stateA::State\n  assumes \"invariantsHoldInState state F0 decisionVars\" and \"isMinimalState state F0 decisionVars\"\n  shows \"isFinalState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<not> isFinalState state F0 decisionVars", "obtain state'::State \n      where \"transition state state' F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition state state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isFinalState_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>state'. transition state state' F0 decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition state state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transition state state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "with \\<open>invariantsHoldInState state F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState state F0 decisionVars\n  transition state state' F0 decisionVars", "have \"(state', state) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  transition state state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars", "using stateIsDecreasedByValidTransitions[of \"state\" \"F0\" \"decisionVars\" \"state'\"]"], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  transition state state' F0 decisionVars\n  \\<lbrakk>invariantsHoldInState state F0 decisionVars;\n   transition state state' F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  appliedDecide state state' decisionVars \\<or>\n  appliedUnitPropagate state state' F0 \\<or>\n  appliedBacktrack state state' F0\n  \\<lbrakk>invariantsHoldInState state F0 decisionVars;\n   appliedDecide state state' decisionVars \\<or>\n   appliedUnitPropagate state state' F0 \\<or>\n   appliedBacktrack state state' F0\\<rbrakk>\n  \\<Longrightarrow> (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "with \\<open>isMinimalState state F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isMinimalState state F0 decisionVars\n  (state', state) \\<in> terminationLess F0 decisionVars", "have False"], ["proof (prove)\nusing this:\n  isMinimalState state F0 decisionVars\n  (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. False", "unfolding isMinimalState_def"], ["proof (prove)\nusing this:\n  \\<forall>statea. (statea, state) \\<notin> terminationLess F0 decisionVars\n  (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "}"], ["proof (state)\nthis:\n  \\<not> isFinalState state F0 decisionVars \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> isFinalState state F0 decisionVars \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  isFinalState state F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The following key lemma shows that the termination ordering is well founded.\\<close>"], ["", "lemma wfTerminationLess: \n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\"\n  shows \"wf (terminationLess F0 decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars)", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists>stateMin\\<in>Q. \\<forall>state'. (state', stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{M::LiteralTrail. \\<exists> state. state \\<in> Q \\<and> (getM state) = M}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getM state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getM state\n    \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by auto"], ["proof (state)\nthis:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>finite decisionVars\\<close>"], ["proof (chain)\npicking this:\n  finite decisionVars", "have \"finite (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  finite decisionVars\n\ngoal (1 subgoal):\n 1. finite (vars F0 \\<union> decisionVars)", "using finiteVarsFormula[of \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars\n  finite (vars F0)\n\ngoal (1 subgoal):\n 1. finite (vars F0 \\<union> decisionVars)", "by simp"], ["proof (state)\nthis:\n  finite (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "hence \"wf (lexLessRestricted (vars F0 \\<union> decisionVars))\""], ["proof (prove)\nusing this:\n  finite (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "using  wfLexLessRestricted[of \"vars F0 \\<union> decisionVars\"]"], ["proof (prove)\nusing this:\n  finite (vars F0 \\<union> decisionVars)\n  finite (vars F0 \\<union> decisionVars) \\<Longrightarrow>\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "by simp"], ["proof (state)\nthis:\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>getM state \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "obtain Mmin where \"Mmin \\<in> ?Q1\" \"\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars) \\<longrightarrow> M' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> decisionVars) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     \\<forall>x.\n        x \\<in> {M. \\<exists>state.\n                       state \\<in> Q \\<and>\n                       getM state = M} \\<longrightarrow>\n        (\\<exists>z\\<in>{M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}.\n            \\<forall>y.\n               (y, z)\n               \\<in> lexLessRestricted\n                      (vars F0 \\<union> decisionVars) \\<longrightarrow>\n               y \\<notin> {M. \\<exists>state.\n                                 state \\<in> Q \\<and>\n                                 getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getM state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> decisionVars) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     getM state\n     \\<in> {M. \\<exists>state.\n                  state \\<in> Q \\<and> getM state = M} \\<longrightarrow>\n     (\\<exists>z\\<in>{M. \\<exists>state.\n                            state \\<in> Q \\<and> getM state = M}.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            y \\<notin> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>Mmin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "obtain stateMin\n        where \"stateMin \\<in> Q\" \"(getM stateMin) = Mmin\""], ["proof (prove)\nusing this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = Mmin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin)\n       \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> terminationLess F0 decisionVars\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "hence \"(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  (state', stateMin) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (state', stateMin)\n  \\<in> {(stateA, stateB).\n         (getM stateA, getM stateB)\n         \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by auto"], ["proof (state)\nthis:\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars) \\<longrightarrow> M' \\<notin> ?Q1\\<close>\n            \\<open>(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\\<close> \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  getM stateMin = Mmin", "have \"getM state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. getM state'\n    \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by simp"], ["proof (state)\nthis:\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin)\n     \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin)\n     \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin)\n     \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin)\n          \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Using the termination ordering we show that the transition\nrelation is well founded on states reachable from initial state.\\<close>"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem wfTransitionRelation:\n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\" and state0 :: \"State\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\"\n  shows \"wf {(stateB, stateA). \n             (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and> (transition stateA stateB F0 decisionVars)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "let ?rel = \"{(stateB, stateA). \n                  (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and> (transition stateA stateB F0 decisionVars)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "let ?rel'= \"terminationLess F0 decisionVars\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "have \"\\<forall>x y. (x, y) \\<in> ?rel \\<longrightarrow> (x, y) \\<in> ?rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "fix stateA::State and stateB::State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "assume \"(stateB, stateA) \\<in> ?rel\""], ["proof (state)\nthis:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> ?rel'\""], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "using \\<open>isInitialState state0 F0\\<close>"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState[of \"state0\" \"F0\" \"stateA\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n  isInitialState state0 F0\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, stateA) \\<in> transitionRelation F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "using stateIsDecreasedByValidTransitions[of \"stateA\" \"F0\" \"decisionVars\" \"stateB\"]"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n  isInitialState state0 F0\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, stateA) \\<in> transitionRelation F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>invariantsHoldInState stateA F0 decisionVars;\n   transition stateA stateB F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "}"], ["proof (state)\nthis:\n  (?stateB2, ?stateA2)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars} \\<Longrightarrow>\n  (?stateB2, ?stateA2) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?stateB2, ?stateA2)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars} \\<Longrightarrow>\n  (?stateB2, ?stateA2) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "have \"wf ?rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars)", "using \\<open>finite decisionVars\\<close>"], ["proof (prove)\nusing this:\n  finite decisionVars\n\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars)", "by (rule wfTerminationLess)"], ["proof (state)\nthis:\n  wf (terminationLess F0 decisionVars)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n  wf (terminationLess F0 decisionVars)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n  wf (terminationLess F0 decisionVars)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "using wellFoundedEmbed[of \"?rel\" \"?rel'\"]"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n  wf (terminationLess F0 decisionVars)\n  \\<lbrakk>\\<forall>x y.\n              (x, y)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              (x, y) \\<in> terminationLess F0 decisionVars;\n   wf (terminationLess F0 decisionVars)\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (state0, stateA)\n                        \\<in> transitionRelation F0 decisionVars \\<and>\n                        transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We will now give two corollaries of the previous theorem. First\n  is a weak termination result that shows that there is a terminating\n  run from every intial state to the final one.\\<close>"], ["", "corollary\n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\" and state0 :: \"State\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\"\n  shows \"\\<exists> state. (state0, state) \\<in> transitionRelation F0 decisionVars \\<and> isFinalState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "let ?Q = \"{state. (state0, state) \\<in> transitionRelation F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "let ?rel = \"{(stateB, stateA). (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n                         transition stateA stateB F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "have \"state0 \\<in> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state0\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "hence \"\\<exists> state. state \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state0\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       state\n       \\<in> {state.\n              (state0, state) \\<in> transitionRelation F0 decisionVars}", "by auto"], ["proof (state)\nthis:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "from assms"], ["proof (chain)\npicking this:\n  finite decisionVars\n  isInitialState state0 F0", "have \"wf ?rel\""], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "using wfTransitionRelation[of \"decisionVars\" \"state0\" \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<lbrakk>finite decisionVars; isInitialState state0 F0\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (state0, stateA)\n                        \\<in> transitionRelation F0 decisionVars \\<and>\n                        transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "by auto"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "hence \"\\<forall> Q. (\\<exists> x. x \\<in> Q) \\<longrightarrow> (\\<exists> stateMin \\<in> Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state.\n              (state, stateMin)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              state \\<notin> Q)", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state.\n              (state, stateMin)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              state \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            state \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "hence \" (\\<exists> x. x \\<in> ?Q) \\<longrightarrow> (\\<exists> stateMin \\<in> ?Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q)\""], ["proof (prove)\nusing this:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            state \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        x \\<in> {state.\n                 (state0, state)\n                 \\<in> transitionRelation F0\n                        decisionVars}) \\<longrightarrow>\n    (\\<exists>stateMin\n              \\<in>{state.\n                    (state0, state)\n                    \\<in> transitionRelation F0 decisionVars}.\n        \\<forall>state.\n           (state, stateMin)\n           \\<in> {(stateB, stateA).\n                  (state0, stateA)\n                  \\<in> transitionRelation F0 decisionVars \\<and>\n                  transition stateA stateB F0\n                   decisionVars} \\<longrightarrow>\n           state\n           \\<notin> {state.\n                     (state0, state)\n                     \\<in> transitionRelation F0 decisionVars})", "by rule"], ["proof (state)\nthis:\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation F0 decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation F0 decisionVars \\<and>\n                transition stateA stateB F0 decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars})\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "with \\<open>\\<exists> state. state \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation F0 decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation F0 decisionVars \\<and>\n                transition stateA stateB F0 decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars})", "have \"\\<exists> stateMin \\<in> ?Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation F0 decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation F0 decisionVars \\<and>\n                transition stateA stateB F0 decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars})\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\n             \\<in>{state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars}.\n       \\<forall>state.\n          (state, stateMin)\n          \\<in> {(stateB, stateA).\n                 (state0, stateA)\n                 \\<in> transitionRelation F0 decisionVars \\<and>\n                 transition stateA stateB F0 decisionVars} \\<longrightarrow>\n          state\n          \\<notin> {state.\n                    (state0, state)\n                    \\<in> transitionRelation F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA)\n               \\<in> transitionRelation F0 decisionVars \\<and>\n               transition stateA stateB F0 decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA)\n               \\<in> transitionRelation F0 decisionVars \\<and>\n               transition stateA stateB F0 decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}", "obtain stateMin\n      where \"stateMin \\<in> ?Q\" and \"\\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA)\n               \\<in> transitionRelation F0 decisionVars \\<and>\n               transition stateA stateB F0 decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin\n                 \\<in> {state.\n                        (state0, state)\n                        \\<in> transitionRelation F0 decisionVars};\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            state\n            \\<notin> {state.\n                      (state0, state)\n                      \\<in> transitionRelation F0 decisionVars}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state.\n               (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "from \\<open>stateMin \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "have \"(state0, stateMin) \\<in> transitionRelation F0 decisionVars\""], ["proof (prove)\nusing this:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "with \\<open>\\<not> ?thesis\\<close>"], ["proof (chain)\npicking this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "have \"\\<not> isFinalState stateMin F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> isFinalState stateMin F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  \\<not> isFinalState stateMin F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<not> isFinalState stateMin F0 decisionVars", "obtain state'::State\n      where \"transition stateMin state' F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> isFinalState stateMin F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition stateMin state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isFinalState_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>state'. transition stateMin state' F0 decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition stateMin state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "have \"(state', stateMin) \\<in> ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n           transition stateA stateB F0 decisionVars}", "using \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close>\n            \\<open>transition stateMin state' F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n           transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "with \\<open>\\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state.\n               (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}", "have \"state' \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state.\n               (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state.\n              (state0, state) \\<in> transitionRelation F0 decisionVars}", "by force"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "from \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close> \\<open>transition stateMin state' F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars", "have \"state' \\<in> ?Q\""], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "using rtrancl_into_rtrancl[of \"state0\" \"stateMin\" \"{(stateA, stateB). transition stateA stateB F0 decisionVars}\" \"state'\"]"], ["proof (prove)\nusing this:\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n  \\<lbrakk>(state0, stateMin)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   (stateMin, state')\n   \\<in> {(stateA, stateB).\n          transition stateA stateB F0 decisionVars}\\<rbrakk>\n  \\<Longrightarrow> (state0, state')\n                    \\<in> {(stateA, stateB).\n                           transition stateA stateB F0 decisionVars}\\<^sup>*\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "have False"], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "}"], ["proof (state)\nthis:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  \\<exists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we prove the final strong termination result which states\nthat there cannot be infinite chains of transitions. If there is an\ninfinite transition chain that starts from an initial state, its\nelements would for a set that would contain initial state and for\nevery element of that set there would be another element of that set\nthat is directly reachable from it. We show that no such set exists.\\<close>"], ["", "corollary noInfiniteTransitionChains:\n  fixes F0::Formula and decisionVars::\"Variable set\"\n  assumes \"finite decisionVars\"\n  shows \"\\<not> (\\<exists> Q::(State set). \\<exists> state0 \\<in> Q. isInitialState state0 F0 \\<and> \n                              (\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' F0 decisionVars))\n            )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0 decisionVars))\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0 decisionVars))", "obtain Q::\"State set\" and state0::\"State\"\n    where \"isInitialState state0 F0\" \"state0 \\<in> Q\"\n          \"\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' F0 decisionVars)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0 decisionVars))\n\ngoal (1 subgoal):\n 1. (\\<And>state0 Q.\n        \\<lbrakk>isInitialState state0 F0; state0 \\<in> Q;\n         \\<forall>state\\<in>Q.\n            \\<exists>state'\\<in>Q.\n               transition state state' F0 decisionVars\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isInitialState state0 F0\n  state0 \\<in> Q\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "let ?rel = \"{(stateB, stateA). (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n                         transition stateA stateB F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>finite decisionVars\\<close> \\<open>isInitialState state0 F0\\<close>"], ["proof (chain)\npicking this:\n  finite decisionVars\n  isInitialState state0 F0", "have \"wf ?rel\""], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "using wfTransitionRelation"], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<lbrakk>finite ?decisionVars; isInitialState ?state0.0 ?F0.0\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (?state0.0, stateA)\n                        \\<in> transitionRelation ?F0.0 ?decisionVars \\<and>\n                        transition stateA stateB ?F0.0 ?decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "hence wfmin: \"\\<forall>Q x. x \\<in> Q \\<longrightarrow>\n         (\\<exists>z\\<in>Q. \\<forall>y. (y, z) \\<in> ?rel \\<longrightarrow> y \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              y \\<notin> Q)", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              y \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "let ?Q = \"{state \\<in> Q. (state0, state) \\<in> transitionRelation F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>state0 \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state0 \\<in> Q", "have \"state0 \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state \\<in> Q.\n           (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with wfmin"], ["proof (chain)\npicking this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}", "obtain stateMin::State\n    where \"stateMin \\<in> ?Q\" and \"\\<forall>y. (y, stateMin) \\<in> ?rel \\<longrightarrow> y \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin\n                 \\<in> {state \\<in> Q.\n                        (state0, state)\n                        \\<in> transitionRelation F0 decisionVars};\n         \\<forall>y.\n            (y, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> {state \\<in> Q.\n                        (state0, state)\n                        \\<in> transitionRelation F0 decisionVars}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>stateMin.\n                \\<lbrakk>stateMin\n                         \\<in> {state \\<in> Q.\n                                (state0, state)\n                                \\<in> transitionRelation F0 decisionVars};\n                 \\<forall>y.\n                    (y, stateMin)\n                    \\<in> {(stateB, stateA).\n                           (state0, stateA)\n                           \\<in> transitionRelation F0 decisionVars \\<and>\n                           transition stateA stateB F0\n                            decisionVars} \\<longrightarrow>\n                    y \\<notin> {state \\<in> Q.\n                                (state0, state)\n                                \\<in> transitionRelation F0\n decisionVars}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state0\n     \\<in> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars};\n     \\<forall>x.\n        x \\<in> {state \\<in> Q.\n                 (state0, state)\n                 \\<in> transitionRelation F0 decisionVars} \\<longrightarrow>\n        (\\<exists>z\\<in>{state \\<in> Q.\n                         (state0, state)\n                         \\<in> transitionRelation F0 decisionVars}.\n            \\<forall>y.\n               (y, z)\n               \\<in> {(stateB, stateA).\n                      (state0, stateA)\n                      \\<in> transitionRelation F0 decisionVars \\<and>\n                      transition stateA stateB F0\n                       decisionVars} \\<longrightarrow>\n               y \\<notin> {state \\<in> Q.\n                           (state0, state)\n                           \\<in> transitionRelation F0\n                                  decisionVars})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>stateMin \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}", "have \"stateMin \\<in> Q\" \"(state0, stateMin) \\<in> transitionRelation F0 decisionVars\""], ["proof (prove)\nusing this:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. stateMin \\<in> Q &&&\n    (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' F0 decisionVars)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' F0 decisionVars\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "obtain state'::State\n    where \"state' \\<in> Q\" \"transition stateMin state' F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' F0 decisionVars\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        \\<lbrakk>state' \\<in> Q;\n         transition stateMin state' F0 decisionVars\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  state' \\<in> Q\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  state' \\<in> Q\n  transition stateMin state' F0 decisionVars", "have \"(state', stateMin) \\<in> ?rel\""], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  state' \\<in> Q\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n           transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>\\<forall>y. (y, stateMin) \\<in> ?rel \\<longrightarrow> y \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}", "have \"state' \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state \\<in> Q.\n              (state0, state) \\<in> transitionRelation F0 decisionVars}", "by force"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>state' \\<in> Q\\<close> \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close>\n    \\<open>transition stateMin state' F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  state' \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars", "have \"state' \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "using rtrancl_into_rtrancl[of \"state0\" \"stateMin\" \"{(stateA, stateB). transition stateA stateB F0 decisionVars}\" \"state'\"]"], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n  \\<lbrakk>(state0, stateMin)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   (stateMin, state')\n   \\<in> {(stateA, stateB).\n          transition stateA stateB F0 decisionVars}\\<rbrakk>\n  \\<Longrightarrow> (state0, state')\n                    \\<in> {(stateA, stateB).\n                           transition stateA stateB F0 decisionVars}\\<^sup>*\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>state' \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}", "have False"], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "}"], ["proof (state)\nthis:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0\n                        decisionVars)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0\n                        decisionVars)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "by force"], ["proof (state)\nthis:\n  \\<nexists>Q.\n     \\<exists>state0\\<in>Q.\n        isInitialState state0 F0 \\<and>\n        (\\<forall>state\\<in>Q.\n            \\<exists>state'\\<in>Q. transition state state' F0 decisionVars)\n\ngoal:\nNo subgoals!", "qed"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Completeness\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>In this section we will first show that each final state is\neither \\textit{SAT} or \\textit{UNSAT} state.\\<close>"], ["", "lemma finalNonConflictState: \n  fixes state::State and FO :: Formula\n  assumes \n  \"\\<not> applicableDecide state decisionVars\"\n  shows \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "fix x :: Variable"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "let ?l = \"Pos x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "assume \"x \\<in> decisionVars\""], ["proof (state)\nthis:\n  x \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "hence \"var ?l = x\" and \"var ?l \\<in> decisionVars\" and \"var (opposite ?l) \\<in> decisionVars\""], ["proof (prove)\nusing this:\n  x \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. var (Pos x) = x &&&\n    var (Pos x) \\<in> decisionVars &&&\n    var (opposite (Pos x)) \\<in> decisionVars", "by auto"], ["proof (state)\nthis:\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "with \\<open>\\<not> applicableDecide state decisionVars\\<close>"], ["proof (chain)\npicking this:\n  \\<not> applicableDecide state decisionVars\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars", "have \"literalTrue ?l (elements (getM state)) \\<or> literalFalse ?l (elements (getM state))\""], ["proof (prove)\nusing this:\n  \\<not> applicableDecide state decisionVars\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. literalTrue (Pos x) (elements (getM state)) \\<or>\n    literalFalse (Pos x) (elements (getM state))", "unfolding applicableDecideCharacterization"], ["proof (prove)\nusing this:\n  \\<nexists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM state) \\<and>\n     \\<not> opposite l el elements (getM state)\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. literalTrue (Pos x) (elements (getM state)) \\<or>\n    literalFalse (Pos x) (elements (getM state))", "by force"], ["proof (state)\nthis:\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "with \\<open>var ?l = x\\<close>"], ["proof (chain)\npicking this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))", "show \"x \\<in> vars (elements (getM state))\""], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"?l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n  Pos x el elements (getM state) \\<Longrightarrow>\n  var (Pos x) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"opposite ?l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n  Pos x el elements (getM state) \\<Longrightarrow>\n  var (Pos x) \\<in> vars (elements (getM state))\n  opposite (Pos x) el elements (getM state) \\<Longrightarrow>\n  var (opposite (Pos x)) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finalConflictingState: \n  fixes state :: State\n  assumes \n  \"\\<not> applicableBacktrack state F0\" and\n  \"formulaFalse F0 (elements (getM state))\"  \n  shows\n  \"decisions (getM state) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "using assms"], ["proof (prove)\nusing this:\n  \\<not> applicableBacktrack state F0\n  formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "using applicableBacktrackCharacterization"], ["proof (prove)\nusing this:\n  \\<not> applicableBacktrack state F0\n  formulaFalse F0 (elements (getM state))\n  applicableBacktrack ?stateA ?F0.0 =\n  (formulaFalse ?F0.0 (elements (getM ?stateA)) \\<and>\n   decisions (getM ?stateA) \\<noteq> [])\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "by auto"], ["", "lemma finalStateCharacterizationLemma:\n  fixes state :: State\n  assumes \n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableBacktrack state F0\"\n  shows\n  \"(\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "proof (cases \"formulaFalse F0 (elements (getM state))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []\n 2. \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "case True"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM state))\n\ngoal (2 subgoals):\n 1. formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []\n 2. \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "hence \"decisions (getM state) = []\""], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "using assms"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM state))\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBacktrack state F0\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "using finalConflictingState"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM state))\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBacktrack state F0\n  \\<lbrakk>\\<not> applicableBacktrack ?state ?F0.0;\n   formulaFalse ?F0.0 (elements (getM ?state))\\<rbrakk>\n  \\<Longrightarrow> decisions (getM ?state) = []\n\ngoal (1 subgoal):\n 1. decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  decisions (getM state) = []\n\ngoal (2 subgoals):\n 1. formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []\n 2. \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with True"], ["proof (chain)\npicking this:\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by simp"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "case False"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "hence  \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state))\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBacktrack state F0\n\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "using finalNonConflictState"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state))\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableBacktrack state F0\n  \\<not> applicableDecide ?state ?decisionVars \\<Longrightarrow>\n  ?decisionVars \\<subseteq> vars (elements (getM ?state))\n\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow>\n    \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with False"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by simp"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem finalStateCharacterization:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n  shows \n  \"(\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "from \\<open>isFinalState state F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isFinalState state F0 decisionVars", "have **: \n    \"\\<not> applicableBacktrack state F0\"\n    \"\\<not> applicableDecide state decisionVars\""], ["proof (prove)\nusing this:\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> applicableBacktrack state F0 &&&\n    \\<not> applicableDecide state decisionVars", "unfolding finalStateNonApplicable"], ["proof (prove)\nusing this:\n  \\<not> applicableDecide state decisionVars \\<and>\n  \\<not> applicableUnitPropagate state F0 \\<and>\n  \\<not> applicableBacktrack state F0\n\ngoal (1 subgoal):\n 1. \\<not> applicableBacktrack state F0 &&&\n    \\<not> applicableDecide state decisionVars", "by auto"], ["proof (state)\nthis:\n  \\<not> applicableBacktrack state F0\n  \\<not> applicableDecide state decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> applicableBacktrack state F0\n  \\<not> applicableDecide state decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "using finalStateCharacterizationLemma[of \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  \\<not> applicableBacktrack state F0\n  \\<not> applicableDecide state decisionVars\n  \\<lbrakk>\\<not> applicableDecide state decisionVars;\n   \\<not> applicableBacktrack state ?F0.0\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse ?F0.0 (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    formulaFalse ?F0.0 (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by simp"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Completeness theorems are easy consequences of this characterization and \n soundness.\\<close>"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem completenessForSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \"\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "from assms"], ["proof (chain)\npicking this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars", "have *: \"(\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n    (formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = [])\""], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "using finalStateCharacterization[of \"state0\" \"F0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    formulaFalse F0 (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "{"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "assume \"formulaFalse F0 (elements (getM state))\""], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  formulaFalse F0 (elements (getM state))", "have \"formulaFalse F0 (elements (getM state))\" \"decisions (getM state) = []\""], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) &&& decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with assms"], ["proof (chain)\npicking this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []", "have \"\\<not> satisfiable F0\""], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "using soundnessForUNSAT"], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  formulaFalse F0 (elements (getM state))\n  decisions (getM state) = []\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?F0.0 ?decisionVars;\n   formulaFalse ?F0.0 (elements (getM ?state));\n   decisions (getM ?state) = []\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable ?F0.0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with \\<open>satisfiable F0\\<close>"], ["proof (chain)\npicking this:\n  satisfiable F0\n  \\<not> satisfiable F0", "have False"], ["proof (prove)\nusing this:\n  satisfiable F0\n  \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "}"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM state)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  formulaFalse F0 (elements (getM state)) \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  formulaFalse F0 (elements (getM state)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem completenessForUNSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n  \"\\<not> satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "from assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars", "have *: \n  \"(\\<not> formulaFalse F0 (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (formulaFalse F0 (elements (getM state))  \\<and> decisions (getM state) = [])\""], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "using finalStateCharacterization[of \"state0\" \"F0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    formulaFalse F0 (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "{"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "assume \"\\<not> formulaFalse F0 (elements (getM state))\""], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  \\<not> formulaFalse F0 (elements (getM state))", "have \"\\<not> formulaFalse F0 (elements (getM state))\" \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  \\<not> formulaFalse F0 (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse F0 (elements (getM state)) &&&\n    decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))", "have \"satisfiable F0\""], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. satisfiable F0", "using soundnessForSAT[of \"F0\" \"decisionVars\" \"state0\" \"state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   \\<not> formulaFalse F0 (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. satisfiable F0", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<nexists>valuation. model valuation F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<not> formulaFalse F0 (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   \\<not> formulaFalse F0 (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation F0", "by auto"], ["proof (state)\nthis:\n  satisfiable F0\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with \\<open>\\<not> satisfiable F0\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable F0\n  satisfiable F0", "have False"], ["proof (prove)\nusing this:\n  \\<not> satisfiable F0\n  satisfiable F0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "}"], ["proof (state)\nthis:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "with *"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n  \\<not> formulaFalse F0 (elements (getM state)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. formulaFalse F0 (elements (getM state)) \\<and>\n    decisions (getM state) = []", "by auto"], ["proof (state)\nthis:\n  formulaFalse F0 (elements (getM state)) \\<and> decisions (getM state) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem partialCorrectness: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and  \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"satisfiable F0 = (\\<not> formulaFalse F0 (elements (getM state)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> formulaFalse F0 (elements (getM state)))", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> formulaFalse F0 (elements (getM state)))", "using assms"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> formulaFalse F0 (elements (getM state)))", "using completenessForUNSAT[of \"F0\" \"decisionVars\" \"state0\" \"state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; \\<not> satisfiable F0;\n   isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> formulaFalse F0 (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> formulaFalse F0 (elements (getM state)))", "using completenessForSAT[of \"F0\" \"state0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; \\<not> satisfiable F0;\n   isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> formulaFalse F0 (elements (getM state)) \\<and>\n                    decisions (getM state) = []\n  \\<lbrakk>satisfiable F0; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse F0 (elements (getM state)) \\<and>\n                    decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> formulaFalse F0 (elements (getM state)))", "by auto"], ["", "end"]]}