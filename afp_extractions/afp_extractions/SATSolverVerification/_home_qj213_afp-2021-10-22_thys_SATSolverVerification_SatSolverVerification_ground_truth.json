{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/SatSolverVerification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma InvariantImpliedLiteralsWeakerVariant:\n  fixes M :: LiteralTrail and F :: Formula\n  assumes \"\\<forall> l. l el elements M \\<longrightarrow> formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\"\n  shows \"\\<forall> l. l el elements M \\<longrightarrow> formulaEntailsLiteral (F @ val2form (decisions M)) l\"", "lemma InvariantImpliedLiteralsAndElementsEntailLiteralThenDecisionsEntailLiteral: \n  fixes M :: LiteralTrail and F :: Formula and literal :: Literal\n  assumes \"InvariantImpliedLiterals F M\" and \"formulaEntailsLiteral (F @ (val2form (elements M))) literal\"\n  shows \"formulaEntailsLiteral (F @ val2form (decisions M)) literal\"", "lemma InvariantImpliedLiteralsAndFormulaFalseThenFormulaAndDecisionsAreNotSatisfiable: \n  fixes M :: LiteralTrail and F :: Formula\n  assumes \"InvariantImpliedLiterals F M\" and \"formulaFalse F (elements M)\" \n  shows \"\\<not> satisfiable (F @ val2form (decisions M))\"", "lemma InvariantImpliedLiteralsHoldsForPrefix:\n  fixes M :: LiteralTrail and prefix :: LiteralTrail and F :: Formula\n  assumes \"InvariantImpliedLiterals F M\"  and \"isPrefix prefix M\" \n  shows \"InvariantImpliedLiterals F prefix\"", "lemma InvariantReasonClausesHoldsForPrefix:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail\n  assumes \"InvariantReasonClauses F M\" and \"InvariantUniq M\"  and\n  \"isPrefix p M\" \n  shows \"InvariantReasonClauses F p\"", "lemma InvariantReasonClausesHoldsForPrefixElements:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail\n  assumes \"InvariantReasonClauses F p\" and\n  \"isPrefix p M\" and\n  \"literal el (elements p)\" and \"\\<not> literal el decisions M\"\n  shows \"\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal (elements M)\"", "lemma InvariantUniqAfterDecide: \n  fixes M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantUniq M\" and \n  \"var literal \\<notin> vars (elements M)\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantUniq M'\"", "lemma InvariantImpliedLiteralsAfterDecide: \n  fixes F :: Formula and M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"var literal \\<notin> vars (elements M)\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantImpliedLiterals F M'\"", "lemma InvariantVarsMAfterDecide: \n  fixes F :: Formula and F0 :: Formula and M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantVarsM M F0 Vbl\" and \n  \"var literal \\<in> Vbl\" and \n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantVarsM M' F0 Vbl\"", "lemma InvariantConsistentAfterDecide: \n  fixes M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantConsistent M\" and \n  \"var literal \\<notin> vars (elements M)\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantConsistent M'\"", "lemma InvariantReasonClausesAfterDecide:\n  fixes F :: Formula and M :: LiteralTrail and M' :: LiteralTrail\n  assumes \"InvariantReasonClauses F M\" and \"InvariantUniq M\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantReasonClauses F M'\"", "lemma InvariantCFalseAfterDecide:\n  fixes conflictFlag::bool and M::LiteralTrail and C::Clause\n  assumes \"InvariantCFalse conflictFlag M C\" and \"M' = M @ [(literal, True)]\"\n  shows \"InvariantCFalse conflictFlag M' C\"", "lemma InvariantImpliedLiteralsHoldsForUnitLiteral:\n  fixes M :: LiteralTrail and F :: Formula and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"formulaEntailsClause F uClause\" and \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral\"", "lemma InvariantImpliedLiteralsAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"formulaEntailsClause F uClause\" and \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantImpliedLiterals F M'\"", "lemma InvariantVarsMAfterUnitPropagate: \n  fixes F :: Formula and F0 :: Formula and M :: LiteralTrail and uClause :: Clause and uLiteral :: Literal and M' :: LiteralTrail\n  assumes \"InvariantVarsM M F0 Vbl\" and\n  \"var uLiteral \\<in> vars F0 \\<union> Vbl\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantVarsM M' F0 Vbl\"", "lemma InvariantConsistentAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantConsistent M\" and\n  \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantConsistent M'\"", "lemma InvariantUniqAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantUniq M\" and\n  \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantUniq M'\"", "lemma InvariantReasonClausesAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantReasonClauses F M\" and\n  \"formulaEntailsClause F uClause\" and \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantReasonClauses F M'\"", "lemma InvariantCFalseAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantCFalse conflictFlag M C\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantCFalse conflictFlag M' C\"", "lemma InvariantImpliedLiteralsAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantImpliedLiterals F M\" and \"InvariantUniq M\" and \"InvariantConsistent M\" and \n  \"decisions M \\<noteq> []\" and \"formulaFalse F (elements M)\"\n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantImpliedLiterals F M'\"", "lemma InvariantConsistentAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantUniq M\" and \"InvariantConsistent M\" and\n  \"decisions M \\<noteq> []\" and \n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantConsistent M'\"", "lemma InvariantUniqAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantUniq M\" and \"InvariantConsistent M\" and\n  \"decisions M \\<noteq> []\" and\n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantUniq M'\"", "lemma InvariantVarsMAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantVarsM M F0 Vbl\"\n  \"decisions M \\<noteq> []\" and\n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantVarsM M' F0 Vbl\"", "lemma InvariantImpliedLiteralsAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"isPrefix p M\" and \"formulaEntailsClause F bClause\" and \"isUnitClause bClause bLiteral (elements p)\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantImpliedLiterals F M'\"", "lemma InvariantVarsMAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantVarsM M F0 Vbl\" and\n  \"isPrefix p M\" and \"var bLiteral \\<in> vars F0 \\<union> Vbl\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantVarsM M' F0 Vbl\"", "lemma InvariantConsistentAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantConsistent M\" and\n  \"isPrefix p M\" and \"isUnitClause bClause bLiteral (elements p)\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantConsistent M'\"", "lemma InvariantUniqAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantUniq M\" and\n  \"isPrefix p M\"  and \"isUnitClause bClause bLiteral (elements p)\" and\n  \"M' = p @ [(bLiteral, False)]\" \n  shows \"InvariantUniq M'\"", "lemma InvariantReasonClausesAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantReasonClauses F M\" and \"InvariantUniq M\"  and\n  \"isPrefix p M\"  and \"isUnitClause bClause bLiteral (elements p)\" and \"formulaEntailsClause F bClause\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantReasonClauses F M'\"", "lemma InvariantImpliedLiteralsAfterLearn: \n  fixes F :: Formula and F' :: Formula and M :: LiteralTrail and C :: Clause\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantImpliedLiterals F' M\"", "lemma InvariantReasonClausesAfterLearn:\n  fixes F :: Formula and F' :: Formula and M :: LiteralTrail and C :: Clause\n  assumes \"InvariantReasonClauses F M\" and\n  \"formulaEntailsClause F C\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantReasonClauses F' M\"", "lemma InvariantVarsFAfterLearn:\n  fixes F0 :: Formula and F :: Formula and F' :: Formula and C :: Clause\n  assumes \"InvariantVarsF F F0 Vbl\" and \n  \"vars C \\<subseteq> (vars F0) \\<union> Vbl\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantVarsF F' F0 Vbl\"", "lemma InvariantEquivalentAfterLearn: \n  fixes F0 :: Formula and F :: Formula and F' :: Formula and C :: Clause\n  assumes \"InvariantEquivalent F0 F\" and \n  \"formulaEntailsClause F C\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantEquivalent F0 F'\"", "lemma InvariantCEntailedAfterLearn:\n  fixes F0 :: Formula and F :: Formula and F' :: Formula and C :: Clause\n  assumes \"InvariantCEntailed conflictFlag F C\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantCEntailed conflictFlag F' C\"", "lemma InvariantCFalseAfterExplain: \n  fixes conflictFlag::bool and M::LiteralTrail and C::Clause and literal :: Literal\n  assumes \"InvariantCFalse conflictFlag M C\" and\n  \"opposite literal el C\" and \"isReason reason literal (elements M)\" and\n  \"C' = resolve C reason (opposite literal)\"\n  shows \"InvariantCFalse conflictFlag M C'\"", "lemma InvariantCEntailedAfterExplain: \n  fixes conflictFlag::bool and M::LiteralTrail and C::Clause and literal :: Literal and reason :: Clause\n  assumes \"InvariantCEntailed conflictFlag F C\" and\n  \"formulaEntailsClause F reason\" and \"C' = (resolve C reason (opposite l))\"\n  shows \"InvariantCEntailed conflictFlag F C'\"", "lemma invariantCFalseAfterConflict:\n  fixes conflictFlag::bool and conflictFlag'::bool and M::LiteralTrail and F :: Formula and clause :: Clause and C' :: Clause\n  assumes \"conflictFlag = False\" and\n  \"formulaFalse F (elements M)\" and \"clause el F\" \"clauseFalse clause (elements M)\" and\n  \"C' = clause\" and \"conflictFlag' = True\"\n  shows \"InvariantCFalse conflictFlag' M C'\"", "lemma invariantCEntailedAfterConflict:\n  fixes conflictFlag::bool and conflictFlag'::bool and M::LiteralTrail and F :: Formula and clause :: Clause and C' :: Clause\n  assumes \"conflictFlag = False\" and\n  \"formulaFalse F (elements M)\" and \"clause el F\" and \"clauseFalse clause (elements M)\" and\n  \"C' = clause\" and \"conflictFlag' = True\"\n  shows \"InvariantCEntailed conflictFlag' F C'\"", "lemma unsatReport: \n  fixes F :: Formula and M :: LiteralTrail and F0 :: Formula\n  assumes \"InvariantImpliedLiterals F M\" and \"InvariantEquivalent F0 F\" and\n  \"decisions M = []\" and \"formulaFalse F (elements M)\"\n  shows \"\\<not> satisfiable F0\"", "lemma unsatReportExtensiveExplain:\n  fixes F :: Formula and M :: LiteralTrail and F0 :: Formula and C :: Clause and conflictFlag :: bool\n  assumes \"InvariantEquivalent F0 F\" and \"InvariantCEntailed conflictFlag F C\" and\n  \"conflictFlag\" and \"C = []\"\n  shows \"\\<not> satisfiable F0\"", "lemma satReport:\n  fixes F0 :: Formula and F :: Formula and M::LiteralTrail\n  assumes \"vars F0 \\<subseteq> Vbl\" and \"InvariantVarsF F F0 Vbl\" and \"InvariantConsistent M\" and \"InvariantEquivalent F0 F\" and\n  \"\\<not> formulaFalse F (elements M)\" and \"vars (elements M) \\<supseteq> Vbl\"\n  shows \"model (elements M) F0\"", "lemma lastAssertedLiteralHasHighestElementLevel: \n  fixes literal :: Literal and clause :: Clause and M :: LiteralTrail\n  assumes \"isLastAssertedLiteral literal clause (elements M)\" and \"uniq (elements M)\"\n  shows \"\\<forall> l'. l' el clause \\<and> l' el elements M \\<longrightarrow> elementLevel l' M <= elementLevel literal M\"", "lemma backjumpLevelZero:\n  fixes M :: LiteralTrail and C :: Clause and l :: Literal\n  assumes \n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\" and\n  \"elementLevel (opposite l) M > 0\" and\n  \"set C = {l}\"\n  shows\n  \"isBackjumpLevel 0 l C M\"", "lemma backjumpLevelLastLast:\n  fixes M :: LiteralTrail and C :: Clause and l :: Literal\n  assumes \n  \"isUIP l C M\" and\n  \"uniq (elements M)\" and\n  \"clauseFalse C (elements M)\" and\n  \"isLastAssertedLiteral (opposite ll) (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\"\n  shows\n  \"isBackjumpLevel (elementLevel (opposite ll) M) l C M\"", "lemma isUIPExistsBackjumpLevel:\n  fixes M :: LiteralTrail and c :: Clause and l :: Literal\n  assumes \n  \"clauseFalse c (elements M)\" and\n  \"isUIP l c M\" and\n  \"uniq (elements M)\" and\n  \"elementLevel (opposite l) M > 0\"\n  shows\n  \"\\<exists> level. (isBackjumpLevel level l c M)\"", "lemma isBackjumpLevelEnsuresIsUnitInPrefix: \n  fixes M :: LiteralTrail and conflictFlag :: bool and c :: Clause and l :: Literal\n  assumes \"consistent (elements M)\" and \"uniq (elements M)\" and\n  \"clauseFalse c (elements M)\" and \"isBackjumpLevel level l c M\"\n  shows \"isUnitClause c l (elements (prefixToLevel level M))\"", "lemma isMinimalBackjumpLevelCharacterization:\nassumes\n\"isUIP l c M\"\n\"clauseFalse c (elements M)\"\n\"uniq (elements M)\"\nshows\n\"isMinimalBackjumpLevel level l c M = \n  (isBackjumpLevel level l c M \\<and> \n   (\\<forall> level'. level' < level \\<longrightarrow> \\<not> isBackjumpLevel level' l c M))\" (is \"?lhs = ?rhs\")", "lemma isMinimalBackjumpLevelEnsuresIsNotUnitBeforePrefix:\n  fixes M :: LiteralTrail and conflictFlag :: bool and c :: Clause and l :: Literal\n  assumes \"consistent (elements M)\" and \"uniq (elements M)\" and \n  \"clauseFalse c (elements M)\" \"isMinimalBackjumpLevel level l c M\" and\n  \"level' < level\"\n  shows \"\\<not> (\\<exists> l'. isUnitClause c l' (elements (prefixToLevel level' M)))\"", "lemma allDecisionsThenUIP:\n  fixes M :: LiteralTrail and c:: Clause\n  assumes \"(uniq (elements M))\" and\n  \"\\<forall> l'. l' el c \\<longrightarrow> (opposite l') el (decisions M)\"\n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\"\n  shows \"isUIP l c M\"", "lemma lastDecisionThenUIP:\n  fixes M :: LiteralTrail and c:: Clause\n  assumes \"(uniq (elements M))\" and\n  \"(opposite l) el (decisions M)\"\n  \"clauseFalse c (elements M)\"\n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\"\n  shows \"isUIP l c M\"", "lemma allDecisionsThenExistsBackjumpLevel:\n  fixes M :: LiteralTrail and c:: Clause\n  assumes \"(uniq (elements M))\" and\n  \"\\<forall> l'. l' el c \\<longrightarrow> (opposite l') el (decisions M)\"\n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\"\n  shows \"\\<exists> level. (isBackjumpLevel level l c M)\"", "lemma explainApplicableToEachNonDecision:\n  fixes F :: Formula and M :: LiteralTrail and conflictFlag :: bool and C :: Clause and literal :: Literal\n  assumes \"InvariantReasonClauses F M\" and \"InvariantCFalse conflictFlag M C\" and\n  \"conflictFlag = True\" and \"opposite literal el C\" and \"\\<not> literal el (decisions M)\"\n  shows \"\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal (elements M)\"", "lemma transIrreflexiveOrderingIsAcyclic:\n  assumes \"trans r\" and \"\\<forall> x. (x, x) \\<notin> r\"\n  shows \"acyclic r\"", "lemma lexLessAppend:\n  assumes \"b \\<noteq> []\" \n  shows \"(a @ b, a) \\<in> lexLess\"", "lemma lexLessBackjump:\n  assumes \"p = prefixToLevel level a\" and \"level >= 0\" and \"level < currentLevel a\" \n  shows \"(p @ [(x, False)], a) \\<in> lexLess\"", "lemma lexLessBacktrack:\n  assumes \"p = prefixBeforeLastDecision a\" \"decisions a \\<noteq> []\"\n  shows \"(p @ [(x, False)], a) \\<in> lexLess\"", "lemma transDecisionLess:\n  shows \"trans decisionLess\"", "lemma translexLess: \n  shows \"trans lexLess\"", "lemma irreflexiveDecisionLess:\n  shows \"(x, x) \\<notin> decisionLess\"", "lemma irreflexiveLexLess: \n  shows \"(x, x) \\<notin> lexLess\"", "lemma acyclicLexLess:\n  shows \"acyclic lexLess\"", "lemma finiteVarsClause:\n  fixes c :: Clause\n  shows \"finite (vars c)\"", "lemma finiteVarsFormula:\n  fixes F :: Formula\n  shows \"finite (vars F)\"", "lemma finiteListDecompose:\n  shows \"finite {(a, b). l = a @ b}\"", "lemma finiteListDecomposeSet:\n  fixes L :: \"'a list set\"\n  assumes \"finite L\"\n  shows \"finite {(a, b). \\<exists> l. l \\<in> L \\<and> l = a @ b}\"", "lemma finiteUniqAndConsistentTrailsWithGivenVariableSet: \n  fixes V :: \"Variable set\"\n  assumes \"finite V\"\n  shows \"finite {(M::LiteralTrail). vars (elements M) = V \\<and> uniq (elements M) \\<and> consistent (elements M)}\"\n        (is \"finite (?trails V)\")", "lemma finiteUniqAndConsistentTrailsWithGivenVariableSuperset: \n  fixes V :: \"Variable set\"\n  assumes \"finite V\"\n  shows \"finite {(M::LiteralTrail). vars (elements M) \\<subseteq> V \\<and> uniq (elements M) \\<and> consistent (elements M)}\" (is \"finite (?trails V)\")", "lemma wfLexLessRestricted:\n  assumes \"finite Vbl\"\n  shows \"wf (lexLessRestricted Vbl)\"", "lemma transLexLessRestricted:\n  shows \"trans (lexLessRestricted Vbl)\"", "lemma multLessResolve:\n  assumes \n  \"opposite l el C\" and\n  \"isReason reason l (elements M)\"\n  shows\n  \"(resolve C reason (opposite l), C) \\<in> multLess  M\"", "lemma multLessListDiff:\nassumes \n  \"(a, b) \\<in> multLess M\"\nshows\n  \"(list_diff a x, b) \\<in> multLess M\"", "lemma multLessRemdups:\nassumes \n  \"(a, b) \\<in> multLess M\"\nshows\n  \"(remdups a, remdups b) \\<in> multLess M \\<and> \n   (remdups a, b) \\<in> multLess M \\<and> \n   (a, remdups b) \\<in> multLess M\"", "lemma wfMultLess: \n  shows \"wf (multLess M)\"", "lemma transBoolLess:\n  shows \"trans boolLess\"", "lemma wfBoolLess:\n  shows \"wf boolLess\"", "lemma wfLearnLess:\n  fixes C::Clause\n  shows \"wf (learnLess C)\"", "lemma wellFoundedEmbed: \n  fixes rel :: \"('a \\<times> 'a) set\" and rel' :: \"('a \\<times> 'a) set\"\n  assumes \"\\<forall> x y. (x, y) \\<in> rel \\<longrightarrow> (x, y) \\<in> rel'\" and \"wf rel'\"\n  shows \"wf rel\""], "translations": [["", "lemma InvariantImpliedLiteralsWeakerVariant:\n  fixes M :: LiteralTrail and F :: Formula\n  assumes \"\\<forall> l. l el elements M \\<longrightarrow> formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\"\n  shows \"\\<forall> l. l el elements M \\<longrightarrow> formulaEntailsLiteral (F @ val2form (decisions M)) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "fix l :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "assume \"l el elements M\""], ["proof (state)\nthis:\n  l el elements M\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  l el elements M", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\""], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  l el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "have \"isPrefix (decisionsTo l M) (decisions M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (decisionsTo l M) (decisions M)", "by (simp add: markedElementsToArePrefixOfMarkedElements)"], ["proof (state)\nthis:\n  isPrefix (decisionsTo l M) (decisions M)\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "then"], ["proof (chain)\npicking this:\n  isPrefix (decisionsTo l M) (decisions M)", "obtain s :: Valuation \n      where \"(decisionsTo l M) @ s = (decisions M)\""], ["proof (prove)\nusing this:\n  isPrefix (decisionsTo l M) (decisions M)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        decisionsTo l M @ s = decisions M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using isPrefix_def [of \"decisionsTo l M\" \"decisions M\"]"], ["proof (prove)\nusing this:\n  isPrefix (decisionsTo l M) (decisions M)\n  isPrefix (decisionsTo l M) (decisions M) =\n  (\\<exists>s. decisionsTo l M @ s = decisions M)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        decisionsTo l M @ s = decisions M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  decisionsTo l M @ s = decisions M\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "hence \"(decisions M) = (decisionsTo l M) @ s\""], ["proof (prove)\nusing this:\n  decisionsTo l M @ s = decisions M\n\ngoal (1 subgoal):\n 1. decisions M = decisionsTo l M @ s", "by (rule sym)"], ["proof (state)\nthis:\n  decisions M = decisionsTo l M @ s\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "with \\<open>formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  decisions M = decisionsTo l M @ s", "have \"formulaEntailsLiteral (F @ val2form (decisions M)) l\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  decisions M = decisionsTo l M @ s\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) l", "using formulaEntailsLiteralAppend [of \"F @ val2form (decisionsTo l M)\" \"l\" \"val2form s\"]"], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  decisions M = decisionsTo l M @ s\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l \\<Longrightarrow>\n  formulaEntailsLiteral ((F @ val2form (decisionsTo l M)) @ val2form s) l\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) l", "by (auto simp add:formulaEntailsLiteralAppend val2formAppend)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisions M)) l\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "}"], ["proof (state)\nthis:\n  ?l2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisions M)) ?l2\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisions M)) ?l2\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "by simp"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisions M)) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantImpliedLiteralsAndElementsEntailLiteralThenDecisionsEntailLiteral: \n  fixes M :: LiteralTrail and F :: Formula and literal :: Literal\n  assumes \"InvariantImpliedLiterals F M\" and \"formulaEntailsLiteral (F @ (val2form (elements M))) literal\"\n  shows \"formulaEntailsLiteral (F @ val2form (decisions M)) literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "assume \"model valuation (F @ val2form (decisions M))\""], ["proof (state)\nthis:\n  model valuation (F @ val2form (decisions M))\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "hence \"formulaTrue F valuation\" and \"formulaTrue (val2form (decisions M)) valuation\" and \"consistent valuation\""], ["proof (prove)\nusing this:\n  model valuation (F @ val2form (decisions M))\n\ngoal (1 subgoal):\n 1. formulaTrue F valuation &&&\n    formulaTrue (val2form (decisions M)) valuation &&& consistent valuation", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  formulaTrue F valuation\n  formulaTrue (val2form (decisions M)) valuation\n  consistent valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "{"], ["proof (state)\nthis:\n  formulaTrue F valuation\n  formulaTrue (val2form (decisions M)) valuation\n  consistent valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "fix l :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "assume \"l el (elements M)\""], ["proof (state)\nthis:\n  l el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "from \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M", "have \"\\<forall> l. l el (elements M) \\<longrightarrow> formulaEntailsLiteral (F @ val2form (decisions M)) l\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) l", "by (simp add: InvariantImpliedLiteralsWeakerVariant InvariantImpliedLiterals_def)"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisions M)) l\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "with \\<open>l el (elements M)\\<close>"], ["proof (chain)\npicking this:\n  l el elements M\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisions M)) l", "have \"formulaEntailsLiteral (F @ val2form (decisions M)) l\""], ["proof (prove)\nusing this:\n  l el elements M\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisions M)) l\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) l", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisions M)) l\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "with \\<open>model valuation (F @ val2form (decisions M))\\<close>"], ["proof (chain)\npicking this:\n  model valuation (F @ val2form (decisions M))\n  formulaEntailsLiteral (F @ val2form (decisions M)) l", "have \"literalTrue l valuation\""], ["proof (prove)\nusing this:\n  model valuation (F @ val2form (decisions M))\n  formulaEntailsLiteral (F @ val2form (decisions M)) l\n\ngoal (1 subgoal):\n 1. literalTrue l valuation", "by (simp add: formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue l valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "}"], ["proof (state)\nthis:\n  ?l2 el elements M \\<Longrightarrow> literalTrue ?l2 valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "hence \"formulaTrue (val2form (elements M)) valuation\""], ["proof (prove)\nusing this:\n  ?l2 el elements M \\<Longrightarrow> literalTrue ?l2 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue (val2form (elements M)) valuation", "by (simp add: val2formFormulaTrue)"], ["proof (state)\nthis:\n  formulaTrue (val2form (elements M)) valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "with \\<open>formulaTrue F valuation\\<close> \\<open>consistent valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue F valuation\n  consistent valuation\n  formulaTrue (val2form (elements M)) valuation", "have \"model valuation (F @ (val2form (elements M)))\""], ["proof (prove)\nusing this:\n  formulaTrue F valuation\n  consistent valuation\n  formulaTrue (val2form (elements M)) valuation\n\ngoal (1 subgoal):\n 1. model valuation (F @ val2form (elements M))", "by (auto simp add:formulaTrueAppend)"], ["proof (state)\nthis:\n  model valuation (F @ val2form (elements M))\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "with \\<open>formulaEntailsLiteral (F @ (val2form (elements M))) literal\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral (F @ val2form (elements M)) literal\n  model valuation (F @ val2form (elements M))", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F @ val2form (elements M)) literal\n  model valuation (F @ val2form (elements M))\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (simp add: formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "}"], ["proof (state)\nthis:\n  model ?valuation2 (F @ val2form (decisions M)) \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 (F @ val2form (decisions M)) \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) literal", "by (simp add: formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisions M)) literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantImpliedLiteralsAndFormulaFalseThenFormulaAndDecisionsAreNotSatisfiable: \n  fixes M :: LiteralTrail and F :: Formula\n  assumes \"InvariantImpliedLiterals F M\" and \"formulaFalse F (elements M)\" \n  shows \"\\<not> satisfiable (F @ val2form (decisions M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "from \\<open>formulaFalse F (elements M)\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse F (elements M)", "have \"formulaFalse (F @ val2form (decisions M)) (elements M)\""], ["proof (prove)\nusing this:\n  formulaFalse F (elements M)\n\ngoal (1 subgoal):\n 1. formulaFalse (F @ val2form (decisions M)) (elements M)", "by (simp add: formulaFalseAppend)"], ["proof (state)\nthis:\n  formulaFalse (F @ val2form (decisions M)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "moreover"], ["proof (state)\nthis:\n  formulaFalse (F @ val2form (decisions M)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "from \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M", "have \"formulaEntailsValuation (F @ val2form (decisions M)) (elements M)\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F @ val2form (decisions M)) (elements M)", "unfolding formulaEntailsValuation_def"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) literal", "unfolding InvariantImpliedLiterals_def"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) literal", "using InvariantImpliedLiteralsWeakerVariant[of \"M\" \"F\"]"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M))\n      l \\<Longrightarrow>\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisions M)) l\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisions M)) literal", "by simp"], ["proof (state)\nthis:\n  formulaEntailsValuation (F @ val2form (decisions M)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "ultimately"], ["proof (chain)\npicking this:\n  formulaFalse (F @ val2form (decisions M)) (elements M)\n  formulaEntailsValuation (F @ val2form (decisions M)) (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaFalse (F @ val2form (decisions M)) (elements M)\n  formulaEntailsValuation (F @ val2form (decisions M)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "using formulaFalseInEntailedValuationIsUnsatisfiable [of \"F @ val2form (decisions M)\" \"elements M\"]"], ["proof (prove)\nusing this:\n  formulaFalse (F @ val2form (decisions M)) (elements M)\n  formulaEntailsValuation (F @ val2form (decisions M)) (elements M)\n  \\<lbrakk>formulaFalse (F @ val2form (decisions M)) (elements M);\n   formulaEntailsValuation (F @ val2form (decisions M))\n    (elements M)\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable (F @ val2form (decisions M))\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable (F @ val2form (decisions M))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantImpliedLiteralsHoldsForPrefix:\n  fixes M :: LiteralTrail and prefix :: LiteralTrail and F :: Formula\n  assumes \"InvariantImpliedLiterals F M\"  and \"isPrefix prefix M\" \n  shows \"InvariantImpliedLiterals F prefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "fix l :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "assume *: \"l el elements prefix\""], ["proof (state)\nthis:\n  l el elements prefix\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "from * \\<open>isPrefix prefix M\\<close>"], ["proof (chain)\npicking this:\n  l el elements prefix\n  isPrefix prefix M", "have \"l el elements M\""], ["proof (prove)\nusing this:\n  l el elements prefix\n  isPrefix prefix M\n\ngoal (1 subgoal):\n 1. l el elements M", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  l el elements prefix\n  \\<exists>s. prefix @ s = M\n\ngoal (1 subgoal):\n 1. l el elements M", "by auto"], ["proof (state)\nthis:\n  l el elements M\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "from * and \\<open>isPrefix prefix M\\<close>"], ["proof (chain)\npicking this:\n  l el elements prefix\n  isPrefix prefix M", "have \"decisionsTo l prefix = decisionsTo l M\""], ["proof (prove)\nusing this:\n  l el elements prefix\n  isPrefix prefix M\n\ngoal (1 subgoal):\n 1. decisionsTo l prefix = decisionsTo l M", "using markedElementsToPrefixElement [of \"prefix\" \"M\" \"l\"]"], ["proof (prove)\nusing this:\n  l el elements prefix\n  isPrefix prefix M\n  \\<lbrakk>isPrefix prefix M; l \\<in> set (elements prefix)\\<rbrakk>\n  \\<Longrightarrow> decisionsTo l M = decisionsTo l prefix\n\ngoal (1 subgoal):\n 1. decisionsTo l prefix = decisionsTo l M", "by simp"], ["proof (state)\nthis:\n  decisionsTo l prefix = decisionsTo l M\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "from \\<open>InvariantImpliedLiterals F M\\<close> and \\<open>l el elements M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  l el elements M", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  l el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l", "by (simp add:InvariantImpliedLiterals_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "with \\<open>decisionsTo l prefix = decisionsTo l M\\<close>"], ["proof (chain)\npicking this:\n  decisionsTo l prefix = decisionsTo l M\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l prefix)) l\""], ["proof (prove)\nusing this:\n  decisionsTo l prefix = decisionsTo l M\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l prefix)) l", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l prefix)) l\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "}"], ["proof (state)\nthis:\n  ?l2 el elements prefix \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l2 prefix)) ?l2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el elements prefix \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l2 prefix)) ?l2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F prefix", "by (auto simp add: InvariantImpliedLiterals_def)"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F prefix\n\ngoal:\nNo subgoals!", "qed"], ["", "(*-------------------------   InvariantReasonClauses    ---------------------*)"], ["", "text\\<open>Lemmas about @{term InvariantReasonClauses}.\\<close>"], ["", "lemma InvariantReasonClausesHoldsForPrefix:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail\n  assumes \"InvariantReasonClauses F M\" and \"InvariantUniq M\"  and\n  \"isPrefix p M\" \n  shows \"InvariantReasonClauses F p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "from \\<open>InvariantReasonClauses F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F M", "have *: \"\\<forall> literal. literal el elements M \\<and> \\<not> literal el decisions M \\<longrightarrow> \n                    (\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal (elements M))\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<and>\n       \\<not> literal el decisions M \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F clause \\<and>\n           isReason clause literal (elements M))", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<and>\n       \\<not> literal el decisions M \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F clause \\<and>\n           isReason clause literal (elements M))", "by simp"], ["proof (state)\nthis:\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "from \\<open>InvariantUniq M\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq M", "have \"uniq (elements M)\""], ["proof (prove)\nusing this:\n  InvariantUniq M\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "by simp"], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "{"], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "fix literal::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "assume \"literal el elements p\" and \"\\<not> literal el decisions p\""], ["proof (state)\nthis:\n  literal el elements p\n  \\<not> literal el decisions p\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "from \\<open>isPrefix p M\\<close> \\<open>literal el (elements p)\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  literal el elements p", "have \"literal el (elements M)\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  literal el elements p\n\ngoal (1 subgoal):\n 1. literal el elements M", "by (auto simp add: isPrefix_def)"], ["proof (state)\nthis:\n  literal el elements M\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "moreover"], ["proof (state)\nthis:\n  literal el elements M\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "from \\<open>isPrefix p M\\<close> \\<open>literal el (elements p)\\<close> \\<open>\\<not> literal el (decisions p)\\<close> \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  literal el elements p\n  \\<not> literal el decisions p\n  uniq (elements M)", "have \"\\<not> literal el decisions M\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  literal el elements p\n  \\<not> literal el decisions p\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literal el decisions M", "using markedElementsTrailMemPrefixAreMarkedElementsPrefix [of \"M\" \"p\" \"literal\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  literal el elements p\n  \\<not> literal el decisions p\n  uniq (elements M)\n  \\<lbrakk>uniq (elements M); isPrefix p M; literal \\<in> set (elements p);\n   literal \\<in> set (decisions M)\\<rbrakk>\n  \\<Longrightarrow> literal \\<in> set (decisions p)\n\ngoal (1 subgoal):\n 1. \\<not> literal el decisions M", "by auto"], ["proof (state)\nthis:\n  \\<not> literal el decisions M\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "ultimately"], ["proof (chain)\npicking this:\n  literal el elements M\n  \\<not> literal el decisions M", "obtain clause::Clause where\n        \"formulaEntailsClause F clause\" \"isReason clause literal (elements M)\""], ["proof (prove)\nusing this:\n  literal el elements M\n  \\<not> literal el decisions M\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>formulaEntailsClause F clause;\n         isReason clause literal (elements M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using *"], ["proof (prove)\nusing this:\n  literal el elements M\n  \\<not> literal el decisions M\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>formulaEntailsClause F clause;\n         isReason clause literal (elements M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause F clause\n  isReason clause literal (elements M)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "with \\<open>literal el elements p\\<close> \\<open>\\<not>  literal el decisions p\\<close> \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  literal el elements p\n  \\<not> literal el decisions p\n  isPrefix p M\n  formulaEntailsClause F clause\n  isReason clause literal (elements M)", "have \"isReason clause literal (elements p)\""], ["proof (prove)\nusing this:\n  literal el elements p\n  \\<not> literal el decisions p\n  isPrefix p M\n  formulaEntailsClause F clause\n  isReason clause literal (elements M)\n\ngoal (1 subgoal):\n 1. isReason clause literal (elements p)", "using isReasonHoldsInPrefix[of \"literal\" \"elements p\" \"elements M\" \"clause\"]"], ["proof (prove)\nusing this:\n  literal el elements p\n  \\<not> literal el decisions p\n  isPrefix p M\n  formulaEntailsClause F clause\n  isReason clause literal (elements M)\n  \\<lbrakk>literal el elements p; isPrefix (elements p) (elements M);\n   isReason clause literal (elements M)\\<rbrakk>\n  \\<Longrightarrow> isReason clause literal (elements p)\n\ngoal (1 subgoal):\n 1. isReason clause literal (elements p)", "by (simp add:isPrefixElements)"], ["proof (state)\nthis:\n  isReason clause literal (elements p)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "with \\<open>formulaEntailsClause F clause\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsClause F clause\n  isReason clause literal (elements p)", "have \"\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal (elements p)\""], ["proof (prove)\nusing this:\n  formulaEntailsClause F clause\n  isReason clause literal (elements p)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements p)", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal (elements p)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?literal2 el elements p; \\<not> ?literal2 el decisions p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal2 (elements p)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?literal2 el elements p; \\<not> ?literal2 el decisions p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal2 (elements p)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?literal2 el elements p; \\<not> ?literal2 el decisions p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal2 (elements p)\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements p \\<and>\n       \\<not> literal el decisions p \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F clause \\<and>\n           isReason clause literal (elements p))", "by auto"], ["proof (state)\nthis:\n  InvariantReasonClauses F p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantReasonClausesHoldsForPrefixElements:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail\n  assumes \"InvariantReasonClauses F p\" and\n  \"isPrefix p M\" and\n  \"literal el (elements p)\" and \"\\<not> literal el decisions M\"\n  shows \"\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "from \\<open>isPrefix p M\\<close> \\<open>\\<not> literal el (decisions M)\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  \\<not> literal el decisions M", "have \"\\<not> literal el (decisions p)\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  \\<not> literal el decisions M\n\ngoal (1 subgoal):\n 1. \\<not> literal el decisions p", "using markedElementsPrefixAreMarkedElementsTrail[of \"p\" \"M\" \"literal\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  \\<not> literal el decisions M\n  \\<lbrakk>isPrefix p M; literal \\<in> set (decisions p)\\<rbrakk>\n  \\<Longrightarrow> literal \\<in> set (decisions M)\n\ngoal (1 subgoal):\n 1. \\<not> literal el decisions p", "by auto"], ["proof (state)\nthis:\n  \\<not> literal el decisions p\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "from \\<open>InvariantReasonClauses F p\\<close> \\<open>literal el (elements p)\\<close> \\<open>\\<not> literal el (decisions p)\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F p\n  literal el elements p\n  \\<not> literal el decisions p", "obtain clause :: Clause\n    where \"formulaEntailsClause F clause\" \"isReason clause literal (elements p)\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses F p\n  literal el elements p\n  \\<not> literal el decisions p\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>formulaEntailsClause F clause;\n         isReason clause literal (elements p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<forall>literal.\n     literal el elements p \\<and>\n     \\<not> literal el decisions p \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements p))\n  literal el elements p\n  \\<not> literal el decisions p\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>formulaEntailsClause F clause;\n         isReason clause literal (elements p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause F clause\n  isReason clause literal (elements p)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "with \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  formulaEntailsClause F clause\n  isReason clause literal (elements p)", "have \"isReason clause literal (elements M)\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  formulaEntailsClause F clause\n  isReason clause literal (elements p)\n\ngoal (1 subgoal):\n 1. isReason clause literal (elements M)", "using isReasonAppend [of \"clause\" \"literal\" \"elements p\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  formulaEntailsClause F clause\n  isReason clause literal (elements p)\n  isReason clause literal (elements p) \\<Longrightarrow>\n  isReason clause literal (elements p @ ?valuation')\n\ngoal (1 subgoal):\n 1. isReason clause literal (elements M)", "by (auto simp add: isPrefix_def)"], ["proof (state)\nthis:\n  isReason clause literal (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "with \\<open>formulaEntailsClause F clause\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsClause F clause\n  isReason clause literal (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaEntailsClause F clause\n  isReason clause literal (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------*)\n(*           V E R I F I C A T I O N     L E M M A S                    *)\n(*----------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Transition rules preserve invariants\\<close>"], ["", "text\\<open>In this section it will be proved that the different DPLL-based\ntransition rules preserves given invariants. Rules are implicitly given\nin their most general form. Explicit definition of transition rules will be\ndone in theories that describe specific solvers.\\<close>"], ["", "(************************************************************************)\n(*                       A P P L Y    D E C I D E                       *)\n(************************************************************************)"], ["", "text\\<open>$Decide$ transition rule.\\<close>"], ["", "lemma InvariantUniqAfterDecide: \n  fixes M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantUniq M\" and \n  \"var literal \\<notin> vars (elements M)\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantUniq M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "from \\<open>InvariantUniq M\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq M", "have \"uniq (elements M)\""], ["proof (prove)\nusing this:\n  InvariantUniq M\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "."], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "{"], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "assume \"\\<not> uniq (elements M')\""], ["proof (state)\nthis:\n  \\<not> uniq (elements M')\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "with \\<open>uniq (elements M)\\<close> \\<open>M' = M @ [(literal, True)]\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  M' = M @ [(literal, True)]\n  \\<not> uniq (elements M')", "have \"literal el (elements M)\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  M' = M @ [(literal, True)]\n  \\<not> uniq (elements M')\n\ngoal (1 subgoal):\n 1. literal el elements M", "using uniqButlastNotUniqListImpliesLastMemButlast [of \"elements M'\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  M' = M @ [(literal, True)]\n  \\<not> uniq (elements M')\n  \\<lbrakk>uniq (butlast (elements M')); \\<not> uniq (elements M')\\<rbrakk>\n  \\<Longrightarrow> last (elements M') \\<in> set (butlast (elements M'))\n\ngoal (1 subgoal):\n 1. literal el elements M", "by auto"], ["proof (state)\nthis:\n  literal el elements M\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "hence \"var literal \\<in> vars (elements M)\""], ["proof (prove)\nusing this:\n  literal el elements M\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars (elements M)", "using valuationContainsItsLiteralsVariable [of \"literal\" \"elements M\"]"], ["proof (prove)\nusing this:\n  literal el elements M\n  literal el elements M \\<Longrightarrow>\n  var literal \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars (elements M)", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "with \\<open>var literal \\<notin> vars (elements M)\\<close>"], ["proof (chain)\npicking this:\n  var literal \\<notin> vars (elements M)\n  var literal \\<in> vars (elements M)", "have \"False\""], ["proof (prove)\nusing this:\n  var literal \\<notin> vars (elements M)\n  var literal \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "}"], ["proof (state)\nthis:\n  \\<not> uniq (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> uniq (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  \\<not> uniq (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. uniq (elements M')", "by auto"], ["proof (state)\nthis:\n  InvariantUniq M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantImpliedLiteralsAfterDecide: \n  fixes F :: Formula and M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"var literal \\<notin> vars (elements M)\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantImpliedLiterals F M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "fix l :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "assume \"l el elements M'\""], ["proof (state)\nthis:\n  l el elements M'\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "proof (cases \"l el elements M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "case True"], ["proof (state)\nthis:\n  l el elements M\n\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "with \\<open>M' = M @ [(literal, True)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(literal, True)]\n  l el elements M", "have \"decisionsTo l M' = decisionsTo l M\""], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n  l el elements M\n\ngoal (1 subgoal):\n 1. decisionsTo l M' = decisionsTo l M", "by (simp add: markedElementsToAppend)"], ["proof (state)\nthis:\n  decisionsTo l M' = decisionsTo l M\n\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "with \\<open>InvariantImpliedLiterals F M\\<close> \\<open>l el elements M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  l el elements M\n  decisionsTo l M' = decisionsTo l M", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  l el elements M\n  decisionsTo l M' = decisionsTo l M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "by (simp add: InvariantImpliedLiterals_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "case False"], ["proof (state)\nthis:\n  \\<not> l el elements M\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "with \\<open>l el elements M'\\<close> and \\<open>M' = M @ [(literal, True)]\\<close>"], ["proof (chain)\npicking this:\n  l el elements M'\n  M' = M @ [(literal, True)]\n  \\<not> l el elements M", "have \"l = literal\""], ["proof (prove)\nusing this:\n  l el elements M'\n  M' = M @ [(literal, True)]\n  \\<not> l el elements M\n\ngoal (1 subgoal):\n 1. l = literal", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  l = literal\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "have \"clauseEntailsLiteral [literal] literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseEntailsLiteral [literal] literal", "by (simp add: clauseEntailsLiteral_def)"], ["proof (state)\nthis:\n  clauseEntailsLiteral [literal] literal\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "moreover"], ["proof (state)\nthis:\n  clauseEntailsLiteral [literal] literal\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "have \"[literal] el (F @ val2form (decisions M) @ [[literal]])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [literal] el F @ val2form (decisions M) @ [[literal]]", "by simp"], ["proof (state)\nthis:\n  [literal] el F @ val2form (decisions M) @ [[literal]]\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "moreover"], ["proof (state)\nthis:\n  [literal] el F @ val2form (decisions M) @ [[literal]]\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "{"], ["proof (state)\nthis:\n  [literal] el F @ val2form (decisions M) @ [[literal]]\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "have \"isDecision (last (M @ [(literal, True)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isDecision (last (M @ [(literal, True)]))", "by simp"], ["proof (state)\nthis:\n  isDecision (last (M @ [(literal, True)]))\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "moreover"], ["proof (state)\nthis:\n  isDecision (last (M @ [(literal, True)]))\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "from \\<open>var literal \\<notin> vars (elements M)\\<close>"], ["proof (chain)\npicking this:\n  var literal \\<notin> vars (elements M)", "have \"\\<not> literal el (elements M)\""], ["proof (prove)\nusing this:\n  var literal \\<notin> vars (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literal el elements M", "using valuationContainsItsLiteralsVariable[of \"literal\" \"elements M\"]"], ["proof (prove)\nusing this:\n  var literal \\<notin> vars (elements M)\n  literal el elements M \\<Longrightarrow>\n  var literal \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literal el elements M", "by auto"], ["proof (state)\nthis:\n  \\<not> literal el elements M\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "ultimately"], ["proof (chain)\npicking this:\n  isDecision (last (M @ [(literal, True)]))\n  \\<not> literal el elements M", "have \"decisionsTo literal (M @ [(literal, True)])  = ((decisions M) @ [literal])\""], ["proof (prove)\nusing this:\n  isDecision (last (M @ [(literal, True)]))\n  \\<not> literal el elements M\n\ngoal (1 subgoal):\n 1. decisionsTo literal (M @ [(literal, True)]) = decisions M @ [literal]", "using lastTrailElementMarkedImpliesMarkedElementsToLastElementAreAllMarkedElements [of \"M @ [(literal, True)]\"]"], ["proof (prove)\nusing this:\n  isDecision (last (M @ [(literal, True)]))\n  \\<not> literal el elements M\n  \\<lbrakk>isDecision (last (M @ [(literal, True)]));\n   last (elements (M @ [(literal, True)]))\n   \\<notin> set (butlast (elements (M @ [(literal, True)])))\\<rbrakk>\n  \\<Longrightarrow> decisionsTo (last (elements (M @ [(literal, True)])))\n                     (M @ [(literal, True)]) =\n                    decisions (M @ [(literal, True)])\n\ngoal (1 subgoal):\n 1. decisionsTo literal (M @ [(literal, True)]) = decisions M @ [literal]", "by (simp add:markedElementsAppend)"], ["proof (state)\nthis:\n  decisionsTo literal (M @ [(literal, True)]) = decisions M @ [literal]\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "}"], ["proof (state)\nthis:\n  decisionsTo literal (M @ [(literal, True)]) = decisions M @ [literal]\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "ultimately"], ["proof (chain)\npicking this:\n  clauseEntailsLiteral [literal] literal\n  [literal] el F @ val2form (decisions M) @ [[literal]]\n  decisionsTo literal (M @ [(literal, True)]) = decisions M @ [literal]", "show ?thesis"], ["proof (prove)\nusing this:\n  clauseEntailsLiteral [literal] literal\n  [literal] el F @ val2form (decisions M) @ [[literal]]\n  decisionsTo literal (M @ [(literal, True)]) = decisions M @ [literal]\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "using \\<open>M' = M @ [(literal, True)]\\<close> \\<open>l = literal\\<close> \n           clauseEntailsLiteralThenFormulaEntailsLiteral [of \"[literal]\" \"F @ val2form (decisions M) @ [[literal]]\" \"literal\"]"], ["proof (prove)\nusing this:\n  clauseEntailsLiteral [literal] literal\n  [literal] el F @ val2form (decisions M) @ [[literal]]\n  decisionsTo literal (M @ [(literal, True)]) = decisions M @ [literal]\n  M' = M @ [(literal, True)]\n  l = literal\n  \\<lbrakk>[literal] el F @ val2form (decisions M) @ [[literal]];\n   clauseEntailsLiteral [literal] literal\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral\n                     (F @ val2form (decisions M) @ [[literal]]) literal\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "by (simp add:val2formAppend)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "}"], ["proof (state)\nthis:\n  ?l2 el elements M' \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l2 M')) ?l2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el elements M' \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l2 M')) ?l2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "by (simp add:InvariantImpliedLiterals_def)"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantVarsMAfterDecide: \n  fixes F :: Formula and F0 :: Formula and M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantVarsM M F0 Vbl\" and \n  \"var literal \\<in> Vbl\" and \n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantVarsM M' F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "from \\<open>InvariantVarsM M F0 Vbl\\<close>"], ["proof (chain)\npicking this:\n  InvariantVarsM M F0 Vbl", "have \"vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\""], ["proof (prove)\nusing this:\n  InvariantVarsM M F0 Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M) \\<subseteq> vars F0 \\<union> Vbl", "by (simp only:InvariantVarsM_def)"], ["proof (state)\nthis:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "from \\<open>M' = M @ [(literal, True)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(literal, True)]", "have \"vars (elements M') = vars (elements (M @ [(literal, True)]))\""], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n\ngoal (1 subgoal):\n 1. vars (elements M') = vars (elements (M @ [(literal, True)]))", "by simp"], ["proof (state)\nthis:\n  vars (elements M') = vars (elements (M @ [(literal, True)]))\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "also"], ["proof (state)\nthis:\n  vars (elements M') = vars (elements (M @ [(literal, True)]))\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "have \"... = vars (elements M @ [literal])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (elements (M @ [(literal, True)])) = vars (elements M @ [literal])", "by simp"], ["proof (state)\nthis:\n  vars (elements (M @ [(literal, True)])) = vars (elements M @ [literal])\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "also"], ["proof (state)\nthis:\n  vars (elements (M @ [(literal, True)])) = vars (elements M @ [literal])\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "have \"... = vars (elements M) \\<union>  vars [literal]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (elements M @ [literal]) =\n    vars (elements M) \\<union> vars [literal]", "using varsAppendClauses [of \"elements M\" \"[literal]\"]"], ["proof (prove)\nusing this:\n  vars (elements M @ [literal]) = vars (elements M) \\<union> vars [literal]\n\ngoal (1 subgoal):\n 1. vars (elements M @ [literal]) =\n    vars (elements M) \\<union> vars [literal]", "by simp"], ["proof (state)\nthis:\n  vars (elements M @ [literal]) = vars (elements M) \\<union> vars [literal]\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "finally"], ["proof (chain)\npicking this:\n  vars (elements M') = vars (elements M) \\<union> vars [literal]", "show ?thesis"], ["proof (prove)\nusing this:\n  vars (elements M') = vars (elements M) \\<union> vars [literal]\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "using \\<open>vars (elements M) \\<subseteq> (vars F0) \\<union> Vbl\\<close> \\<open>var literal \\<in> Vbl\\<close>"], ["proof (prove)\nusing this:\n  vars (elements M') = vars (elements M) \\<union> vars [literal]\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  var literal \\<in> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements M') = vars (elements M) \\<union> vars [literal]\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  var literal \\<in> Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M') \\<subseteq> vars F0 \\<union> Vbl", "by auto"], ["proof (state)\nthis:\n  InvariantVarsM M' F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConsistentAfterDecide: \n  fixes M :: LiteralTrail and literal :: Literal and M' :: LiteralTrail\n  assumes \"InvariantConsistent M\" and \n  \"var literal \\<notin> vars (elements M)\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantConsistent M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "from \\<open>InvariantConsistent M\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent M", "have \"consistent (elements M)\""], ["proof (prove)\nusing this:\n  InvariantConsistent M\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "."], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "{"], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "assume \"inconsistent (elements M')\""], ["proof (state)\nthis:\n  inconsistent (elements M')\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>M' = M @ [(literal, True)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(literal, True)]\n  inconsistent (elements M')", "have \"inconsistent (elements M) \\<or> inconsistent [literal] \\<or> (\\<exists> l. literalTrue l (elements M) \\<and> literalFalse l [literal])\""], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n  inconsistent (elements M')\n\ngoal (1 subgoal):\n 1. inconsistent (elements M) \\<or>\n    inconsistent [literal] \\<or>\n    (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [literal])", "using inconsistentAppend [of \"elements M\" \"[literal]\"]"], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n  inconsistent (elements M')\n  inconsistent (elements M @ [literal]) \\<Longrightarrow>\n  inconsistent (elements M) \\<or>\n  inconsistent [literal] \\<or>\n  (\\<exists>literala.\n      literalTrue literala (elements M) \\<and>\n      literalFalse literala [literal])\n\ngoal (1 subgoal):\n 1. inconsistent (elements M) \\<or>\n    inconsistent [literal] \\<or>\n    (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [literal])", "by simp"], ["proof (state)\nthis:\n  inconsistent (elements M) \\<or>\n  inconsistent [literal] \\<or>\n  (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [literal])\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>consistent (elements M)\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements M)\n  inconsistent (elements M) \\<or>\n  inconsistent [literal] \\<or>\n  (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [literal])", "obtain l :: Literal \n      where \"literalTrue l (elements M)\" and \"literalFalse l [literal]\""], ["proof (prove)\nusing this:\n  consistent (elements M)\n  inconsistent (elements M) \\<or>\n  inconsistent [literal] \\<or>\n  (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [literal])\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>literalTrue l (elements M);\n         literalFalse l [literal]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  literalTrue l (elements M)\n  literalFalse l [literal]\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "hence \"(opposite l) = literal\""], ["proof (prove)\nusing this:\n  literalTrue l (elements M)\n  literalFalse l [literal]\n\ngoal (1 subgoal):\n 1. opposite l = literal", "by auto"], ["proof (state)\nthis:\n  opposite l = literal\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "hence \"var literal = var l\""], ["proof (prove)\nusing this:\n  opposite l = literal\n\ngoal (1 subgoal):\n 1. var literal = var l", "by auto"], ["proof (state)\nthis:\n  var literal = var l\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>literalTrue l (elements M)\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l (elements M)\n  var literal = var l", "have \"var l \\<in> vars (elements M)\""], ["proof (prove)\nusing this:\n  literalTrue l (elements M)\n  var literal = var l\n\ngoal (1 subgoal):\n 1. var l \\<in> vars (elements M)", "using valuationContainsItsLiteralsVariable [of \"l\" \"elements M\"]"], ["proof (prove)\nusing this:\n  literalTrue l (elements M)\n  var literal = var l\n  l el elements M \\<Longrightarrow> var l \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. var l \\<in> vars (elements M)", "by simp"], ["proof (state)\nthis:\n  var l \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>var literal = var l\\<close> \\<open>var literal \\<notin> vars (elements M)\\<close>"], ["proof (chain)\npicking this:\n  var literal = var l\n  var literal \\<notin> vars (elements M)\n  var l \\<in> vars (elements M)", "have \"False\""], ["proof (prove)\nusing this:\n  var literal = var l\n  var literal \\<notin> vars (elements M)\n  var l \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "}"], ["proof (state)\nthis:\n  inconsistent (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  inconsistent (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  inconsistent (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (elements M')", "by auto"], ["proof (state)\nthis:\n  InvariantConsistent M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantReasonClausesAfterDecide:\n  fixes F :: Formula and M :: LiteralTrail and M' :: LiteralTrail\n  assumes \"InvariantReasonClauses F M\" and \"InvariantUniq M\" and\n  \"M' = M @ [(literal, True)]\"\n  shows \"InvariantReasonClauses F M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "fix literal' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "assume \"literal' el elements M'\" and \"\\<not> literal' el decisions M'\""], ["proof (state)\nthis:\n  literal' el elements M'\n  \\<not> literal' el decisions M'\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "have \"\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal' (elements M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "proof (cases \"literal' el elements M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')\n 2. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "case True"], ["proof (state)\nthis:\n  literal' el elements M\n\ngoal (2 subgoals):\n 1. literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')\n 2. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "with assms \\<open>\\<not> literal' el decisions M'\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  M' = M @ [(literal, True)]\n  \\<not> literal' el decisions M'\n  literal' el elements M", "obtain clause::Clause\n        where \"formulaEntailsClause F clause \\<and> isReason clause literal' (elements M')\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  M' = M @ [(literal, True)]\n  \\<not> literal' el decisions M'\n  literal' el elements M\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        formulaEntailsClause F clause \\<and>\n        isReason clause literal' (elements M') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using InvariantReasonClausesHoldsForPrefixElements [of \"F\" \"M\" \"M'\" \"literal'\"]"], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  M' = M @ [(literal, True)]\n  \\<not> literal' el decisions M'\n  literal' el elements M\n  \\<lbrakk>InvariantReasonClauses F M; isPrefix M M';\n   literal' el elements M; \\<not> literal' el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause literal' (elements M')\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        formulaEntailsClause F clause \\<and>\n        isReason clause literal' (elements M') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:isPrefix_def)"], ["proof (state)\nthis:\n  formulaEntailsClause F clause \\<and>\n  isReason clause literal' (elements M')\n\ngoal (2 subgoals):\n 1. literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')\n 2. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "thus ?thesis"], ["proof (prove)\nusing this:\n  formulaEntailsClause F clause \\<and>\n  isReason clause literal' (elements M')\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal' (elements M')\n\ngoal (1 subgoal):\n 1. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "case False"], ["proof (state)\nthis:\n  \\<not> literal' el elements M\n\ngoal (1 subgoal):\n 1. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "with \\<open>M' = M @ [(literal, True)]\\<close> \\<open>literal' el elements M'\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(literal, True)]\n  literal' el elements M'\n  \\<not> literal' el elements M", "have \"literal = literal'\""], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n  literal' el elements M'\n  \\<not> literal' el elements M\n\ngoal (1 subgoal):\n 1. literal = literal'", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  literal = literal'\n\ngoal (1 subgoal):\n 1. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "with \\<open>M' = M @ [(literal, True)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(literal, True)]\n  literal = literal'", "have \"literal' el decisions M'\""], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n  literal = literal'\n\ngoal (1 subgoal):\n 1. literal' el decisions M'", "using markedElementIsMarkedTrue[of \"literal\" \"M'\"]"], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n  literal = literal'\n  (literal \\<in> set (decisions M')) = ((literal, True) \\<in> set M')\n\ngoal (1 subgoal):\n 1. literal' el decisions M'", "by simp"], ["proof (state)\nthis:\n  literal' el decisions M'\n\ngoal (1 subgoal):\n 1. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "with \\<open>\\<not> literal' el decisions M'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literal' el decisions M'\n  literal' el decisions M'", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> literal' el decisions M'\n  literal' el decisions M'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> literal' el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal' (elements M')", "by simp"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal' (elements M')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal' (elements M')\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?literal'2 el elements M';\n   \\<not> ?literal'2 el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal'2 (elements M')\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?literal'2 el elements M';\n   \\<not> ?literal'2 el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal'2 (elements M')\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?literal'2 el elements M';\n   \\<not> ?literal'2 el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal'2 (elements M')\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M' \\<and>\n       \\<not> literal el decisions M' \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F clause \\<and>\n           isReason clause literal (elements M'))", "by auto"], ["proof (state)\nthis:\n  InvariantReasonClauses F M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantCFalseAfterDecide:\n  fixes conflictFlag::bool and M::LiteralTrail and C::Clause\n  assumes \"InvariantCFalse conflictFlag M C\" and \"M' = M @ [(literal, True)]\"\n  shows \"InvariantCFalse conflictFlag M' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "unfolding InvariantCFalse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> clauseFalse C (elements M')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C (elements M')", "assume \"conflictFlag\""], ["proof (state)\nthis:\n  conflictFlag\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C (elements M')", "show \"clauseFalse C (elements M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse C (elements M')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse C (elements M')", "from \\<open>InvariantCFalse conflictFlag M C\\<close>"], ["proof (chain)\npicking this:\n  InvariantCFalse conflictFlag M C", "have \"conflictFlag \\<longrightarrow> clauseFalse C (elements M)\""], ["proof (prove)\nusing this:\n  InvariantCFalse conflictFlag M C\n\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> clauseFalse C (elements M)", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> clauseFalse C (elements M)", "."], ["proof (state)\nthis:\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M')", "with \\<open>conflictFlag\\<close>"], ["proof (chain)\npicking this:\n  conflictFlag\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)", "have \"clauseFalse C (elements M)\""], ["proof (prove)\nusing this:\n  conflictFlag\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M)", "by simp"], ["proof (state)\nthis:\n  clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M')", "with \\<open>M' = M @ [(literal, True)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(literal, True)]\n  clauseFalse C (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  M' = M @ [(literal, True)]\n  clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M')", "by (simp add:clauseFalseAppendValuation)"], ["proof (state)\nthis:\n  clauseFalse C (elements M')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseFalse C (elements M')\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)\n(*             A P P L Y    U N I T   P R O P A G A T E                 *)\n(************************************************************************)"], ["", "text\\<open>$UnitPropagate$ transition rule.\\<close>"], ["", "lemma InvariantImpliedLiteralsHoldsForUnitLiteral:\n  fixes M :: LiteralTrail and F :: Formula and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"formulaEntailsClause F uClause\" and \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "have \"decisionsTo uLiteral M' = decisions M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisionsTo uLiteral M' = decisions M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decisionsTo uLiteral M' = decisions M", "from \\<open>isUnitClause uClause uLiteral (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isUnitClause uClause uLiteral (elements M)", "have \"\\<not> uLiteral el (elements M)\""], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> uLiteral el elements M", "by (simp add: isUnitClause_def)"], ["proof (state)\nthis:\n  \\<not> uLiteral el elements M\n\ngoal (1 subgoal):\n 1. decisionsTo uLiteral M' = decisions M", "with \\<open>M' = M @ [(uLiteral, False)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(uLiteral, False)]\n  \\<not> uLiteral el elements M", "show ?thesis"], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  \\<not> uLiteral el elements M\n\ngoal (1 subgoal):\n 1. decisionsTo uLiteral M' = decisions M", "using markedElementsToAppend[of \"uLiteral\" \"M\" \"[(uLiteral, False)]\"]"], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  \\<not> uLiteral el elements M\n  decisionsTo uLiteral (M @ [(uLiteral, False)]) =\n  (if uLiteral \\<in> set (elements M) then decisionsTo uLiteral M\n   else decisions M @ decisionsTo uLiteral [(uLiteral, False)])\n\ngoal (1 subgoal):\n 1. decisionsTo uLiteral M' = decisions M", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  \\<not> uLiteral el elements M\n  decisions (prefixToElement uLiteral (M @ [(uLiteral, False)])) =\n  (if uLiteral \\<in> set (elements M)\n   then decisions (prefixToElement uLiteral M)\n   else decisions M @\n        decisions (prefixToElement uLiteral [(uLiteral, False)]))\n\ngoal (1 subgoal):\n 1. decisions (prefixToElement uLiteral M') = decisions M", "by simp"], ["proof (state)\nthis:\n  decisionsTo uLiteral M' = decisions M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decisionsTo uLiteral M' = decisions M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "moreover"], ["proof (state)\nthis:\n  decisionsTo uLiteral M' = decisions M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "from \\<open>formulaEntailsClause F uClause\\<close> \\<open>isUnitClause uClause uLiteral (elements M)\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)", "have \"formulaEntailsLiteral (F @ val2form (elements M)) uLiteral\""], ["proof (prove)\nusing this:\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (elements M)) uLiteral", "using unitLiteralIsEntailed [of \"uClause\" \"uLiteral\" \"elements M\" \"F\"]"], ["proof (prove)\nusing this:\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n  \\<lbrakk>isUnitClause uClause uLiteral (elements M);\n   formulaEntailsClause F uClause\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral (F @ val2form (elements M))\n                     uLiteral\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (elements M)) uLiteral", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (elements M)) uLiteral\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "with \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  formulaEntailsLiteral (F @ val2form (elements M)) uLiteral", "have \"formulaEntailsLiteral (F @ val2form (decisions M)) uLiteral\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  formulaEntailsLiteral (F @ val2form (elements M)) uLiteral\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisions M)) uLiteral", "by (simp add: InvariantImpliedLiteralsAndElementsEntailLiteralThenDecisionsEntailLiteral)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisions M)) uLiteral\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "ultimately"], ["proof (chain)\npicking this:\n  decisionsTo uLiteral M' = decisions M\n  formulaEntailsLiteral (F @ val2form (decisions M)) uLiteral", "show ?thesis"], ["proof (prove)\nusing this:\n  decisionsTo uLiteral M' = decisions M\n  formulaEntailsLiteral (F @ val2form (decisions M)) uLiteral\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantImpliedLiteralsAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"formulaEntailsClause F uClause\" and \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantImpliedLiterals F M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "fix l :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "assume \"l el (elements M')\""], ["proof (state)\nthis:\n  l el elements M'\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "proof (cases \"l el elements M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "case True"], ["proof (state)\nthis:\n  l el elements M\n\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "with \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  l el elements M", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  l el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l", "by (simp add:InvariantImpliedLiterals_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "moreover"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "from \\<open>M' = M @ [(uLiteral, False)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(uLiteral, False)]", "have \"(isPrefix M M')\""], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n\ngoal (1 subgoal):\n 1. isPrefix M M'", "by (simp add:isPrefix_def)"], ["proof (state)\nthis:\n  isPrefix M M'\n\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "with True"], ["proof (chain)\npicking this:\n  l el elements M\n  isPrefix M M'", "have \"decisionsTo l M' = decisionsTo l M\""], ["proof (prove)\nusing this:\n  l el elements M\n  isPrefix M M'\n\ngoal (1 subgoal):\n 1. decisionsTo l M' = decisionsTo l M", "by (simp add: markedElementsToPrefixElement)"], ["proof (state)\nthis:\n  decisionsTo l M' = decisionsTo l M\n\ngoal (2 subgoals):\n 1. l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n 2. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "ultimately"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  decisionsTo l M' = decisionsTo l M", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  decisionsTo l M' = decisionsTo l M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "case False"], ["proof (state)\nthis:\n  \\<not> l el elements M\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "with \\<open>l el (elements M')\\<close> \\<open>M' = M @ [(uLiteral, False)]\\<close>"], ["proof (chain)\npicking this:\n  l el elements M'\n  M' = M @ [(uLiteral, False)]\n  \\<not> l el elements M", "have \"l = uLiteral\""], ["proof (prove)\nusing this:\n  l el elements M'\n  M' = M @ [(uLiteral, False)]\n  \\<not> l el elements M\n\ngoal (1 subgoal):\n 1. l = uLiteral", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  l = uLiteral\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "moreover"], ["proof (state)\nthis:\n  l = uLiteral\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "from assms"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "using InvariantImpliedLiteralsHoldsForUnitLiteral [of \"F\" \"M\" \"uClause\" \"uLiteral\" \"M'\"]"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]\n  \\<lbrakk>InvariantImpliedLiterals F M; formulaEntailsClause F uClause;\n   isUnitClause uClause uLiteral (elements M);\n   M' = M @ [(uLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral\n                     (F @ val2form (decisionsTo uLiteral M')) uLiteral\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral\n\ngoal (1 subgoal):\n 1. \\<not> l el elements M \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "ultimately"], ["proof (chain)\npicking this:\n  l = uLiteral\n  formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral", "show ?thesis"], ["proof (prove)\nusing this:\n  l = uLiteral\n  formulaEntailsLiteral (F @ val2form (decisionsTo uLiteral M')) uLiteral\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "}"], ["proof (state)\nthis:\n  ?l2 el elements M' \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l2 M')) ?l2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el elements M' \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l2 M')) ?l2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "by (simp add:InvariantImpliedLiterals_def)"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantVarsMAfterUnitPropagate: \n  fixes F :: Formula and F0 :: Formula and M :: LiteralTrail and uClause :: Clause and uLiteral :: Literal and M' :: LiteralTrail\n  assumes \"InvariantVarsM M F0 Vbl\" and\n  \"var uLiteral \\<in> vars F0 \\<union> Vbl\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantVarsM M' F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "from \\<open>InvariantVarsM M F0 Vbl\\<close>"], ["proof (chain)\npicking this:\n  InvariantVarsM M F0 Vbl", "have \"vars (elements M) \\<subseteq>  vars F0 \\<union> Vbl\""], ["proof (prove)\nusing this:\n  InvariantVarsM M F0 Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M) \\<subseteq> vars F0 \\<union> Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M) \\<subseteq> vars F0 \\<union> Vbl", "."], ["proof (state)\nthis:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M') \\<subseteq> vars F0 \\<union> Vbl", "using \\<open>var uLiteral \\<in> vars F0 \\<union> Vbl\\<close>"], ["proof (prove)\nusing this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  var uLiteral \\<in> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M') \\<subseteq> vars F0 \\<union> Vbl", "using \\<open>M' = M @ [(uLiteral, False)]\\<close>\n      varsAppendClauses [of \"elements M\" \"[uLiteral]\"]"], ["proof (prove)\nusing this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  var uLiteral \\<in> vars F0 \\<union> Vbl\n  M' = M @ [(uLiteral, False)]\n  vars (elements M @ [uLiteral]) =\n  vars (elements M) \\<union> vars [uLiteral]\n\ngoal (1 subgoal):\n 1. vars (elements M') \\<subseteq> vars F0 \\<union> Vbl", "by auto"], ["proof (state)\nthis:\n  InvariantVarsM M' F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConsistentAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantConsistent M\" and\n  \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantConsistent M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "from \\<open>InvariantConsistent M\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent M", "have \"consistent (elements M)\""], ["proof (prove)\nusing this:\n  InvariantConsistent M\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "."], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "from \\<open>isUnitClause uClause uLiteral (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isUnitClause uClause uLiteral (elements M)", "have \"\\<not> literalFalse uLiteral (elements M)\""], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse uLiteral (elements M)", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  uLiteral el uClause \\<and>\n  \\<not> literalTrue uLiteral (elements M) \\<and>\n  \\<not> literalFalse uLiteral (elements M) \\<and>\n  (\\<forall>literal.\n      literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n      literalFalse literal (elements M))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse uLiteral (elements M)", "by simp"], ["proof (state)\nthis:\n  \\<not> literalFalse uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "{"], ["proof (state)\nthis:\n  \\<not> literalFalse uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "assume \"inconsistent (elements M')\""], ["proof (state)\nthis:\n  inconsistent (elements M')\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>M' = M @ [(uLiteral, False)]\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(uLiteral, False)]\n  inconsistent (elements M')", "have \"inconsistent (elements M) \\<or> inconsistent [unitLiteral] \\<or> (\\<exists> l. literalTrue l (elements M) \\<and> literalFalse l [uLiteral])\""], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  inconsistent (elements M')\n\ngoal (1 subgoal):\n 1. inconsistent (elements M) \\<or>\n    inconsistent [unitLiteral] \\<or>\n    (\\<exists>l.\n        literalTrue l (elements M) \\<and> literalFalse l [uLiteral])", "using inconsistentAppend [of \"elements M\" \"[uLiteral]\"]"], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  inconsistent (elements M')\n  inconsistent (elements M @ [uLiteral]) \\<Longrightarrow>\n  inconsistent (elements M) \\<or>\n  inconsistent [uLiteral] \\<or>\n  (\\<exists>literal.\n      literalTrue literal (elements M) \\<and>\n      literalFalse literal [uLiteral])\n\ngoal (1 subgoal):\n 1. inconsistent (elements M) \\<or>\n    inconsistent [unitLiteral] \\<or>\n    (\\<exists>l.\n        literalTrue l (elements M) \\<and> literalFalse l [uLiteral])", "by simp"], ["proof (state)\nthis:\n  inconsistent (elements M) \\<or>\n  inconsistent [unitLiteral] \\<or>\n  (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [uLiteral])\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>consistent (elements M)\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements M)\n  inconsistent (elements M) \\<or>\n  inconsistent [unitLiteral] \\<or>\n  (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [uLiteral])", "obtain literal::Literal\n      where \"literalTrue literal (elements M)\" and \"literalFalse literal [uLiteral]\""], ["proof (prove)\nusing this:\n  consistent (elements M)\n  inconsistent (elements M) \\<or>\n  inconsistent [unitLiteral] \\<or>\n  (\\<exists>l. literalTrue l (elements M) \\<and> literalFalse l [uLiteral])\n\ngoal (1 subgoal):\n 1. (\\<And>literal.\n        \\<lbrakk>literalTrue literal (elements M);\n         literalFalse literal [uLiteral]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  literalTrue literal (elements M)\n  literalFalse literal [uLiteral]\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "hence \"literal = opposite uLiteral\""], ["proof (prove)\nusing this:\n  literalTrue literal (elements M)\n  literalFalse literal [uLiteral]\n\ngoal (1 subgoal):\n 1. literal = opposite uLiteral", "by auto"], ["proof (state)\nthis:\n  literal = opposite uLiteral\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>literalTrue literal (elements M)\\<close> \\<open>\\<not> literalFalse uLiteral (elements M)\\<close>"], ["proof (chain)\npicking this:\n  literalTrue literal (elements M)\n  \\<not> literalFalse uLiteral (elements M)\n  literal = opposite uLiteral", "have False"], ["proof (prove)\nusing this:\n  literalTrue literal (elements M)\n  \\<not> literalFalse uLiteral (elements M)\n  literal = opposite uLiteral\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "}"], ["proof (state)\nthis:\n  inconsistent (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  inconsistent (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  inconsistent (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (elements M')", "by auto"], ["proof (state)\nthis:\n  InvariantConsistent M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantUniqAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantUniq M\" and\n  \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantUniq M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "from \\<open>InvariantUniq M\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq M", "have \"uniq (elements M)\""], ["proof (prove)\nusing this:\n  InvariantUniq M\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "."], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "moreover"], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "from \\<open>isUnitClause uClause uLiteral (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isUnitClause uClause uLiteral (elements M)", "have \"\\<not> literalTrue uLiteral (elements M)\""], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue uLiteral (elements M)", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  uLiteral el uClause \\<and>\n  \\<not> literalTrue uLiteral (elements M) \\<and>\n  \\<not> literalFalse uLiteral (elements M) \\<and>\n  (\\<forall>literal.\n      literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n      literalFalse literal (elements M))\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue uLiteral (elements M)", "by simp"], ["proof (state)\nthis:\n  \\<not> literalTrue uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "ultimately"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  \\<not> literalTrue uLiteral (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  \\<not> literalTrue uLiteral (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "using \\<open>M' = M @ [(uLiteral, False)]\\<close> uniqAppendElement[of \"elements M\" \"uLiteral\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  \\<not> literalTrue uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]\n  uniq (elements M) \\<Longrightarrow>\n  (uLiteral \\<notin> set (elements M)) = uniq (elements M @ [uLiteral])\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  \\<not> literalTrue uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]\n  uniq (elements M) \\<Longrightarrow>\n  (uLiteral \\<notin> set (elements M)) = uniq (elements M @ [uLiteral])\n\ngoal (1 subgoal):\n 1. uniq (elements M')", "by simp"], ["proof (state)\nthis:\n  InvariantUniq M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantReasonClausesAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantReasonClauses F M\" and\n  \"formulaEntailsClause F uClause\" and \"isUnitClause uClause uLiteral (elements M)\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantReasonClauses F M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "from \\<open>InvariantReasonClauses F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F M", "have *: \"(\\<forall> literal. (literal el (elements M)) \\<and> \\<not> (literal el (decisions M)) \\<longrightarrow> \n    (\\<exists> clause. formulaEntailsClause F clause \\<and> (isReason clause literal (elements M))))\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<and>\n       \\<not> literal el decisions M \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F clause \\<and>\n           isReason clause literal (elements M))", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<and>\n       \\<not> literal el decisions M \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F clause \\<and>\n           isReason clause literal (elements M))", "by simp"], ["proof (state)\nthis:\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "{"], ["proof (state)\nthis:\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "fix literal::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "assume \"literal el elements M'\" \"\\<not> literal el decisions M'\""], ["proof (state)\nthis:\n  literal el elements M'\n  \\<not> literal el decisions M'\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "have \"\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal (elements M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "proof (cases \"literal el elements M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')\n 2. \\<not> literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "case True"], ["proof (state)\nthis:\n  literal el elements M\n\ngoal (2 subgoals):\n 1. literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')\n 2. \\<not> literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "with assms \\<open>\\<not> literal el decisions M'\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F M\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]\n  \\<not> literal el decisions M'\n  literal el elements M", "obtain clause::Clause\n        where \"formulaEntailsClause F clause \\<and> isReason clause literal (elements M')\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]\n  \\<not> literal el decisions M'\n  literal el elements M\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        formulaEntailsClause F clause \\<and>\n        isReason clause literal (elements M') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using InvariantReasonClausesHoldsForPrefixElements [of \"F\" \"M\" \"M'\" \"literal\"]"], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  formulaEntailsClause F uClause\n  isUnitClause uClause uLiteral (elements M)\n  M' = M @ [(uLiteral, False)]\n  \\<not> literal el decisions M'\n  literal el elements M\n  \\<lbrakk>InvariantReasonClauses F M; isPrefix M M'; literal el elements M;\n   \\<not> literal el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause literal (elements M')\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        formulaEntailsClause F clause \\<and>\n        isReason clause literal (elements M') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:isPrefix_def)"], ["proof (state)\nthis:\n  formulaEntailsClause F clause \\<and> isReason clause literal (elements M')\n\ngoal (2 subgoals):\n 1. literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')\n 2. \\<not> literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "thus ?thesis"], ["proof (prove)\nusing this:\n  formulaEntailsClause F clause \\<and> isReason clause literal (elements M')\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal (elements M')\n\ngoal (1 subgoal):\n 1. \\<not> literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "case False"], ["proof (state)\nthis:\n  \\<not> literal el elements M\n\ngoal (1 subgoal):\n 1. \\<not> literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "with \\<open>literal el (elements M')\\<close> \\<open>M' = M @ [(uLiteral, False)]\\<close>"], ["proof (chain)\npicking this:\n  literal el elements M'\n  M' = M @ [(uLiteral, False)]\n  \\<not> literal el elements M", "have \"literal = uLiteral\""], ["proof (prove)\nusing this:\n  literal el elements M'\n  M' = M @ [(uLiteral, False)]\n  \\<not> literal el elements M\n\ngoal (1 subgoal):\n 1. literal = uLiteral", "by simp"], ["proof (state)\nthis:\n  literal = uLiteral\n\ngoal (1 subgoal):\n 1. \\<not> literal el elements M \\<Longrightarrow>\n    \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "with \\<open>M' = M @ [(uLiteral, False)]\\<close> \\<open>isUnitClause uClause uLiteral (elements M)\\<close> \\<open>formulaEntailsClause F uClause\\<close>"], ["proof (chain)\npicking this:\n  M' = M @ [(uLiteral, False)]\n  isUnitClause uClause uLiteral (elements M)\n  formulaEntailsClause F uClause\n  literal = uLiteral", "show ?thesis"], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  isUnitClause uClause uLiteral (elements M)\n  formulaEntailsClause F uClause\n  literal = uLiteral\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "using isUnitClauseIsReason [of \"uClause\" \"uLiteral\" \"elements M\"]"], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  isUnitClause uClause uLiteral (elements M)\n  formulaEntailsClause F uClause\n  literal = uLiteral\n  \\<lbrakk>isUnitClause uClause uLiteral (elements M);\n   uLiteral el ?valuation'\\<rbrakk>\n  \\<Longrightarrow> isReason uClause uLiteral (elements M @ ?valuation')\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M')", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal (elements M')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal (elements M')\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?literal2 el elements M';\n   \\<not> ?literal2 el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal2 (elements M')\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?literal2 el elements M';\n   \\<not> ?literal2 el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal2 (elements M')\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?literal2 el elements M';\n   \\<not> ?literal2 el decisions M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause F clause \\<and>\n                       isReason clause ?literal2 (elements M')\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M' \\<and>\n       \\<not> literal el decisions M' \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F clause \\<and>\n           isReason clause literal (elements M'))", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses F M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantCFalseAfterUnitPropagate:\n  fixes M :: LiteralTrail and F :: Formula and M' :: LiteralTrail and uClause :: Clause and uLiteral :: Literal\n  assumes \"InvariantCFalse conflictFlag M C\" and\n  \"M' = M @ [(uLiteral, False)]\"\n  shows \"InvariantCFalse conflictFlag M' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "from \\<open>InvariantCFalse conflictFlag M C\\<close>"], ["proof (chain)\npicking this:\n  InvariantCFalse conflictFlag M C", "have *: \"conflictFlag \\<longrightarrow> clauseFalse C (elements M)\""], ["proof (prove)\nusing this:\n  InvariantCFalse conflictFlag M C\n\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> clauseFalse C (elements M)", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> clauseFalse C (elements M)", "."], ["proof (state)\nthis:\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "{"], ["proof (state)\nthis:\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "assume \"conflictFlag\""], ["proof (state)\nthis:\n  conflictFlag\n\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "with \\<open>M' = M @ [(uLiteral, False)]\\<close> *"], ["proof (chain)\npicking this:\n  M' = M @ [(uLiteral, False)]\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n  conflictFlag", "have \"clauseFalse C (elements M')\""], ["proof (prove)\nusing this:\n  M' = M @ [(uLiteral, False)]\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n  conflictFlag\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M')", "by (simp add:clauseFalseAppendValuation)"], ["proof (state)\nthis:\n  clauseFalse C (elements M')\n\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "}"], ["proof (state)\nthis:\n  conflictFlag \\<Longrightarrow> clauseFalse C (elements M')\n\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "thus ?thesis"], ["proof (prove)\nusing this:\n  conflictFlag \\<Longrightarrow> clauseFalse C (elements M')\n\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M' C", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  conflictFlag \\<Longrightarrow> clauseFalse C (elements M')\n\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> clauseFalse C (elements M')", "by simp"], ["proof (state)\nthis:\n  InvariantCFalse conflictFlag M' C\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)\n(*                   A P P L Y    B A C K T R A C K                     *)\n(************************************************************************)"], ["", "text\\<open>$Backtrack$ transition rule.\\<close>"], ["", "lemma InvariantImpliedLiteralsAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantImpliedLiterals F M\" and \"InvariantUniq M\" and \"InvariantConsistent M\" and \n  \"decisions M \\<noteq> []\" and \"formulaFalse F (elements M)\"\n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantImpliedLiterals F M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "have \"isPrefix (prefixBeforeLastDecision M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixBeforeLastDecision M) M", "by (simp add: isPrefixPrefixBeforeLastMarked)"], ["proof (state)\nthis:\n  isPrefix (prefixBeforeLastDecision M) M\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "{"], ["proof (state)\nthis:\n  isPrefix (prefixBeforeLastDecision M) M\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "fix l'::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "assume \"l' el (elements M')\""], ["proof (state)\nthis:\n  l' el elements M'\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "let ?p = \"(prefixBeforeLastDecision M)\""], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "let ?l = \"lastDecision M\""], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "proof (cases \"l' el (elements ?p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n 2. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "case True"], ["proof (state)\nthis:\n  l' el elements (prefixBeforeLastDecision M)\n\ngoal (2 subgoals):\n 1. l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n 2. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>isPrefix ?p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix (prefixBeforeLastDecision M) M\n  l' el elements (prefixBeforeLastDecision M)", "have \"l' el (elements M)\""], ["proof (prove)\nusing this:\n  isPrefix (prefixBeforeLastDecision M) M\n  l' el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. l' el elements M", "using prefixElementsAreTrailElements[of \"?p\" \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix (prefixBeforeLastDecision M) M\n  l' el elements (prefixBeforeLastDecision M)\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  set (elements (prefixBeforeLastDecision M)) \\<subseteq> set (elements M)\n\ngoal (1 subgoal):\n 1. l' el elements M", "by auto"], ["proof (state)\nthis:\n  l' el elements M\n\ngoal (2 subgoals):\n 1. l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n 2. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  l' el elements M", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo l' M)) l'\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  l' el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l' M)) l'", "unfolding InvariantImpliedLiterals_def"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  l' el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l' M)) l'", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l' M)) l'\n\ngoal (2 subgoals):\n 1. l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n 2. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "moreover"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l' M)) l'\n\ngoal (2 subgoals):\n 1. l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n 2. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "from \\<open>M' = ?p @ [(opposite ?l, False)]\\<close> True \\<open>isPrefix ?p M\\<close>"], ["proof (chain)\npicking this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  l' el elements (prefixBeforeLastDecision M)\n  isPrefix (prefixBeforeLastDecision M) M", "have \"(decisionsTo l' M') = (decisionsTo l' M)\""], ["proof (prove)\nusing this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  l' el elements (prefixBeforeLastDecision M)\n  isPrefix (prefixBeforeLastDecision M) M\n\ngoal (1 subgoal):\n 1. decisionsTo l' M' = decisionsTo l' M", "using prefixToElementToPrefixElement[of \"?p\" \"M\" \"l'\"]"], ["proof (prove)\nusing this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  l' el elements (prefixBeforeLastDecision M)\n  isPrefix (prefixBeforeLastDecision M) M\n  \\<lbrakk>isPrefix (prefixBeforeLastDecision M) M;\n   l' \\<in> set (elements (prefixBeforeLastDecision M))\\<rbrakk>\n  \\<Longrightarrow> prefixToElement l' M =\n                    prefixToElement l' (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. decisionsTo l' M' = decisionsTo l' M", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  l' el elements (prefixBeforeLastDecision M)\n  isPrefix (prefixBeforeLastDecision M) M\n  \\<lbrakk>isPrefix (prefixBeforeLastDecision M) M;\n   l' \\<in> set (elements (prefixBeforeLastDecision M))\\<rbrakk>\n  \\<Longrightarrow> prefixToElement l' M =\n                    prefixToElement l' (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. decisions (prefixToElement l' M') = decisions (prefixToElement l' M)", "by (auto simp add: prefixToElementAppend)"], ["proof (state)\nthis:\n  decisionsTo l' M' = decisionsTo l' M\n\ngoal (2 subgoals):\n 1. l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n 2. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "ultimately"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l' M)) l'\n  decisionsTo l' M' = decisionsTo l' M", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l' M)) l'\n  decisionsTo l' M' = decisionsTo l' M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "by auto"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "case False"], ["proof (state)\nthis:\n  \\<not> l' el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>l' el (elements M')\\<close> and \\<open>M' = ?p @ [(opposite ?l, False)]\\<close>"], ["proof (chain)\npicking this:\n  l' el elements M'\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  \\<not> l' el elements (prefixBeforeLastDecision M)", "have \"?l = (opposite l')\""], ["proof (prove)\nusing this:\n  l' el elements M'\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  \\<not> l' el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. lastDecision M = opposite l'", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  lastDecision M = opposite l'\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "hence \"l' = (opposite ?l)\""], ["proof (prove)\nusing this:\n  lastDecision M = opposite l'\n\ngoal (1 subgoal):\n 1. l' = opposite (lastDecision M)", "by simp"], ["proof (state)\nthis:\n  l' = opposite (lastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "from \\<open>InvariantUniq M\\<close> and \\<open>markedElements M \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq M\n  decisions M \\<noteq> []", "have \"(decisionsTo ?l M) = (decisions M)\""], ["proof (prove)\nusing this:\n  InvariantUniq M\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. decisionsTo (lastDecision M) M = decisions M", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. decisionsTo (lastDecision M) M = decisions M", "using markedElementsToLastMarkedAreAllMarkedElements"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  decisions M \\<noteq> []\n  \\<lbrakk>uniq (elements ?M); markedElements ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> markedElementsTo (lastMarked ?M) ?M = markedElements ?M\n\ngoal (1 subgoal):\n 1. decisionsTo (lastDecision M) M = decisions M", "by auto"], ["proof (state)\nthis:\n  decisionsTo (lastDecision M) M = decisions M\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "moreover"], ["proof (state)\nthis:\n  decisionsTo (lastDecision M) M = decisions M\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "from \\<open>decisions M \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  decisions M \\<noteq> []", "have \"?l el (elements M)\""], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. lastDecision M el elements M", "by (simp add: lastMarkedIsMarkedElement markedElementsAreElements)"], ["proof (state)\nthis:\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>InvariantConsistent M\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent M\n  lastDecision M el elements M", "have \"\\<not> (opposite ?l) el (elements M)\""], ["proof (prove)\nusing this:\n  InvariantConsistent M\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el elements M", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el elements M", "by (simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> opposite (lastDecision M) el elements M\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>isPrefix ?p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix (prefixBeforeLastDecision M) M\n  \\<not> opposite (lastDecision M) el elements M", "have \"\\<not> (opposite ?l) el (elements ?p)\""], ["proof (prove)\nusing this:\n  isPrefix (prefixBeforeLastDecision M) M\n  \\<not> opposite (lastDecision M) el elements M\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el\n           elements (prefixBeforeLastDecision M)", "using prefixElementsAreTrailElements[of \"?p\" \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix (prefixBeforeLastDecision M) M\n  \\<not> opposite (lastDecision M) el elements M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  set (elements (prefixBeforeLastDecision M)) \\<subseteq> set (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el\n           elements (prefixBeforeLastDecision M)", "by auto"], ["proof (state)\nthis:\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>M' = ?p @ [(opposite ?l, False)]\\<close>"], ["proof (chain)\npicking this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)", "have \"decisionsTo (opposite ?l) M' = decisions ?p\""], ["proof (prove)\nusing this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. decisionsTo (opposite (lastDecision M)) M' =\n    decisions (prefixBeforeLastDecision M)", "using markedElementsToAppend [of \"opposite ?l\" \"?p\" \"[(opposite ?l, False)]\"]"], ["proof (prove)\nusing this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n  decisionsTo (opposite (lastDecision M))\n   (prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]) =\n  (if opposite (lastDecision M)\n      \\<in> set (elements (prefixBeforeLastDecision M))\n   then decisionsTo (opposite (lastDecision M)) (prefixBeforeLastDecision M)\n   else decisions (prefixBeforeLastDecision M) @\n        decisionsTo (opposite (lastDecision M))\n         [(opposite (lastDecision M), False)])\n\ngoal (1 subgoal):\n 1. decisionsTo (opposite (lastDecision M)) M' =\n    decisions (prefixBeforeLastDecision M)", "unfolding markedElementsTo_def"], ["proof (prove)\nusing this:\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n  decisions\n   (prefixToElement (opposite (lastDecision M))\n     (prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)])) =\n  (if opposite (lastDecision M)\n      \\<in> set (elements (prefixBeforeLastDecision M))\n   then decisions\n         (prefixToElement (opposite (lastDecision M))\n           (prefixBeforeLastDecision M))\n   else decisions (prefixBeforeLastDecision M) @\n        decisions\n         (prefixToElement (opposite (lastDecision M))\n           [(opposite (lastDecision M), False)]))\n\ngoal (1 subgoal):\n 1. decisions (prefixToElement (opposite (lastDecision M)) M') =\n    decisions (prefixBeforeLastDecision M)", "by simp"], ["proof (state)\nthis:\n  decisionsTo (opposite (lastDecision M)) M' =\n  decisions (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "moreover"], ["proof (state)\nthis:\n  decisionsTo (opposite (lastDecision M)) M' =\n  decisions (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "from \\<open>InvariantUniq M\\<close> \\<open>decisions M \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq M\n  decisions M \\<noteq> []", "have \"\\<not> ?l el (elements ?p)\""], ["proof (prove)\nusing this:\n  InvariantUniq M\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> lastDecision M el elements (prefixBeforeLastDecision M)", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> lastDecision M el elements (prefixBeforeLastDecision M)", "using lastMarkedNotInPrefixBeforeLastMarked[of \"M\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  decisions M \\<noteq> []\n  \\<lbrakk>uniq (elements M); decisions M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> lastDecision M\n                    \\<notin> set (elements (prefixBeforeLastDecision M))\n\ngoal (1 subgoal):\n 1. \\<not> lastDecision M el elements (prefixBeforeLastDecision M)", "by simp"], ["proof (state)\nthis:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "hence \"\\<not> ?l el (decisions ?p)\""], ["proof (prove)\nusing this:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> lastDecision M el decisions (prefixBeforeLastDecision M)", "by (auto simp add: markedElementsAreElements)"], ["proof (state)\nthis:\n  \\<not> lastDecision M el decisions (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "hence \"(removeAll ?l (decisions ?p)) = (decisions ?p)\""], ["proof (prove)\nusing this:\n  \\<not> lastDecision M el decisions (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. removeAll (lastDecision M) (decisions (prefixBeforeLastDecision M)) =\n    decisions (prefixBeforeLastDecision M)", "by (simp add: removeAll_id)"], ["proof (state)\nthis:\n  removeAll (lastDecision M) (decisions (prefixBeforeLastDecision M)) =\n  decisions (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "hence \"(removeAll ?l ((decisions ?p) @ [?l])) = (decisions ?p)\""], ["proof (prove)\nusing this:\n  removeAll (lastDecision M) (decisions (prefixBeforeLastDecision M)) =\n  decisions (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. removeAll (lastDecision M)\n     (decisions (prefixBeforeLastDecision M) @ [lastDecision M]) =\n    decisions (prefixBeforeLastDecision M)", "by simp"], ["proof (state)\nthis:\n  removeAll (lastDecision M)\n   (decisions (prefixBeforeLastDecision M) @ [lastDecision M]) =\n  decisions (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "from \\<open>decisions M \\<noteq> []\\<close> False \\<open>l' = (opposite ?l)\\<close>"], ["proof (chain)\npicking this:\n  decisions M \\<noteq> []\n  \\<not> l' el elements (prefixBeforeLastDecision M)\n  l' = opposite (lastDecision M)", "have \"(decisions ?p) @ [?l] = (decisions M)\""], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  \\<not> l' el elements (prefixBeforeLastDecision M)\n  l' = opposite (lastDecision M)\n\ngoal (1 subgoal):\n 1. decisions (prefixBeforeLastDecision M) @ [lastDecision M] = decisions M", "using markedElementsAreElementsBeforeLastDecisionAndLastDecision[of \"M\"]"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  \\<not> l' el elements (prefixBeforeLastDecision M)\n  l' = opposite (lastDecision M)\n  decisions M \\<noteq> [] \\<Longrightarrow>\n  decisions M = decisions (prefixBeforeLastDecision M) @ [lastDecision M]\n\ngoal (1 subgoal):\n 1. decisions (prefixBeforeLastDecision M) @ [lastDecision M] = decisions M", "by simp"], ["proof (state)\nthis:\n  decisions (prefixBeforeLastDecision M) @ [lastDecision M] = decisions M\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>(removeAll ?l ((decisions ?p) @ [?l])) = (decisions ?p)\\<close>"], ["proof (chain)\npicking this:\n  removeAll (lastDecision M)\n   (decisions (prefixBeforeLastDecision M) @ [lastDecision M]) =\n  decisions (prefixBeforeLastDecision M)\n  decisions (prefixBeforeLastDecision M) @ [lastDecision M] = decisions M", "have \"(decisions ?p) = (removeAll ?l (decisions M))\""], ["proof (prove)\nusing this:\n  removeAll (lastDecision M)\n   (decisions (prefixBeforeLastDecision M) @ [lastDecision M]) =\n  decisions (prefixBeforeLastDecision M)\n  decisions (prefixBeforeLastDecision M) @ [lastDecision M] = decisions M\n\ngoal (1 subgoal):\n 1. decisions (prefixBeforeLastDecision M) =\n    removeAll (lastDecision M) (decisions M)", "by simp"], ["proof (state)\nthis:\n  decisions (prefixBeforeLastDecision M) =\n  removeAll (lastDecision M) (decisions M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "moreover"], ["proof (state)\nthis:\n  decisions (prefixBeforeLastDecision M) =\n  removeAll (lastDecision M) (decisions M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "from \\<open>formulaFalse F (elements M)\\<close> \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse F (elements M)\n  InvariantImpliedLiterals F M", "have \"\\<not> satisfiable (F @ (val2form (decisions M)))\""], ["proof (prove)\nusing this:\n  formulaFalse F (elements M)\n  InvariantImpliedLiterals F M\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "using InvariantImpliedLiteralsAndFormulaFalseThenFormulaAndDecisionsAreNotSatisfiable[of \"F\" \"M\"]"], ["proof (prove)\nusing this:\n  formulaFalse F (elements M)\n  InvariantImpliedLiterals F M\n  \\<lbrakk>InvariantImpliedLiterals F M;\n   formulaFalse F (elements M)\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable (F @ val2form (decisions M))\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (F @ val2form (decisions M))", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable (F @ val2form (decisions M))\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "from \\<open>decisions M \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  decisions M \\<noteq> []", "have \"?l el (decisions M)\""], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. lastDecision M el decisions M", "unfolding lastMarked_def"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (decisions M) el decisions M", "by simp"], ["proof (state)\nthis:\n  lastDecision M el decisions M\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "hence \"[?l] el val2form (decisions M)\""], ["proof (prove)\nusing this:\n  lastDecision M el decisions M\n\ngoal (1 subgoal):\n 1. [lastDecision M] el val2form (decisions M)", "using val2FormEl[of \"?l\" \"(decisions M)\"]"], ["proof (prove)\nusing this:\n  lastDecision M el decisions M\n  lastDecision M el decisions M = [lastDecision M] el val2form (decisions M)\n\ngoal (1 subgoal):\n 1. [lastDecision M] el val2form (decisions M)", "by simp"], ["proof (state)\nthis:\n  [lastDecision M] el val2form (decisions M)\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "with \\<open>\\<not> satisfiable (F @ (val2form (decisions M)))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable (F @ val2form (decisions M))\n  [lastDecision M] el val2form (decisions M)", "have \"formulaEntailsLiteral (removeAll [?l] (F @ val2form (decisions M))) (opposite ?l)\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable (F @ val2form (decisions M))\n  [lastDecision M] el val2form (decisions M)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (removeAll [lastDecision M] (F @ val2form (decisions M)))\n     (opposite (lastDecision M))", "using unsatisfiableFormulaWithSingleLiteralClause[of \"F @ val2form (decisions M)\" \"lastDecision M\"]"], ["proof (prove)\nusing this:\n  \\<not> satisfiable (F @ val2form (decisions M))\n  [lastDecision M] el val2form (decisions M)\n  \\<lbrakk>\\<not> satisfiable (F @ val2form (decisions M));\n   [lastDecision M] el F @ val2form (decisions M)\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral\n                     (removeAll [lastDecision M]\n                       (F @ val2form (decisions M)))\n                     (opposite (lastDecision M))\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (removeAll [lastDecision M] (F @ val2form (decisions M)))\n     (opposite (lastDecision M))", "by auto"], ["proof (state)\nthis:\n  formulaEntailsLiteral\n   (removeAll [lastDecision M] (F @ val2form (decisions M)))\n   (opposite (lastDecision M))\n\ngoal (1 subgoal):\n 1. \\<not> l' el elements (prefixBeforeLastDecision M) \\<Longrightarrow>\n    formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "ultimately"], ["proof (chain)\npicking this:\n  decisionsTo (lastDecision M) M = decisions M\n  decisionsTo (opposite (lastDecision M)) M' =\n  decisions (prefixBeforeLastDecision M)\n  decisions (prefixBeforeLastDecision M) =\n  removeAll (lastDecision M) (decisions M)\n  formulaEntailsLiteral\n   (removeAll [lastDecision M] (F @ val2form (decisions M)))\n   (opposite (lastDecision M))", "show ?thesis"], ["proof (prove)\nusing this:\n  decisionsTo (lastDecision M) M = decisions M\n  decisionsTo (opposite (lastDecision M)) M' =\n  decisions (prefixBeforeLastDecision M)\n  decisions (prefixBeforeLastDecision M) =\n  removeAll (lastDecision M) (decisions M)\n  formulaEntailsLiteral\n   (removeAll [lastDecision M] (F @ val2form (decisions M)))\n   (opposite (lastDecision M))\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "using \\<open>l' = (opposite ?l)\\<close>"], ["proof (prove)\nusing this:\n  decisionsTo (lastDecision M) M = decisions M\n  decisionsTo (opposite (lastDecision M)) M' =\n  decisions (prefixBeforeLastDecision M)\n  decisions (prefixBeforeLastDecision M) =\n  removeAll (lastDecision M) (decisions M)\n  formulaEntailsLiteral\n   (removeAll [lastDecision M] (F @ val2form (decisions M)))\n   (opposite (lastDecision M))\n  l' = opposite (lastDecision M)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "using formulaEntailsLiteralRemoveAllAppend[of \"[?l]\" \"F\" \"val2form (removeAll ?l (decisions M))\" \"opposite ?l\"]"], ["proof (prove)\nusing this:\n  decisionsTo (lastDecision M) M = decisions M\n  decisionsTo (opposite (lastDecision M)) M' =\n  decisions (prefixBeforeLastDecision M)\n  decisions (prefixBeforeLastDecision M) =\n  removeAll (lastDecision M) (decisions M)\n  formulaEntailsLiteral\n   (removeAll [lastDecision M] (F @ val2form (decisions M)))\n   (opposite (lastDecision M))\n  l' = opposite (lastDecision M)\n  formulaEntailsLiteral\n   (removeAll [lastDecision M] F @\n    val2form (removeAll (lastDecision M) (decisions M)))\n   (opposite (lastDecision M)) \\<Longrightarrow>\n  formulaEntailsLiteral\n   (F @ val2form (removeAll (lastDecision M) (decisions M)))\n   (opposite (lastDecision M))\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'", "by (auto simp add: val2FormRemoveAll)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo l' M')) l'\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "}"], ["proof (state)\nthis:\n  ?l'2 el elements M' \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l'2 M')) ?l'2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l'2 el elements M' \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l'2 M')) ?l'2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "unfolding InvariantImpliedLiterals_def"], ["proof (prove)\nusing this:\n  ?l'2 el elements M' \\<Longrightarrow>\n  formulaEntailsLiteral (F @ val2form (decisionsTo ?l'2 M')) ?l'2\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M' \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisionsTo l M')) l", "by auto"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConsistentAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantUniq M\" and \"InvariantConsistent M\" and\n  \"decisions M \\<noteq> []\" and \n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantConsistent M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "from \\<open>decisions M \\<noteq> []\\<close> \\<open>InvariantUniq M\\<close>"], ["proof (chain)\npicking this:\n  decisions M \\<noteq> []\n  InvariantUniq M", "have \"\\<not> lastDecision M el elements (prefixBeforeLastDecision M)\""], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  InvariantUniq M\n\ngoal (1 subgoal):\n 1. \\<not> lastDecision M el elements (prefixBeforeLastDecision M)", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> lastDecision M el elements (prefixBeforeLastDecision M)", "using lastMarkedNotInPrefixBeforeLastMarked"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  uniq (elements M)\n  \\<lbrakk>uniq (elements ?M); markedElements ?M \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> lastMarked ?M\n                    \\<notin> set (elements (prefixBeforeLastMarked ?M))\n\ngoal (1 subgoal):\n 1. \\<not> lastDecision M el elements (prefixBeforeLastDecision M)", "by simp"], ["proof (state)\nthis:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "moreover"], ["proof (state)\nthis:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "from \\<open>InvariantConsistent M\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent M", "have \"consistent (elements (prefixBeforeLastDecision M))\""], ["proof (prove)\nusing this:\n  InvariantConsistent M\n\ngoal (1 subgoal):\n 1. consistent (elements (prefixBeforeLastDecision M))", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements (prefixBeforeLastDecision M))", "using isPrefixPrefixBeforeLastMarked[of \"M\"]"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  isPrefix (prefixBeforeLastDecision M) M\n\ngoal (1 subgoal):\n 1. consistent (elements (prefixBeforeLastDecision M))", "using isPrefixElements[of \"prefixBeforeLastDecision M\" \"M\"]"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements (prefixBeforeLastDecision M))", "using consistentPrefix[of \"elements (prefixBeforeLastDecision M)\" \"elements M\"]"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n  \\<lbrakk>isPrefix (elements (prefixBeforeLastDecision M)) (elements M);\n   consistent (elements M)\\<rbrakk>\n  \\<Longrightarrow> consistent (elements (prefixBeforeLastDecision M))\n\ngoal (1 subgoal):\n 1. consistent (elements (prefixBeforeLastDecision M))", "by simp"], ["proof (state)\nthis:\n  consistent (elements (prefixBeforeLastDecision M))\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n  consistent (elements (prefixBeforeLastDecision M))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n  consistent (elements (prefixBeforeLastDecision M))\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n  consistent (elements (prefixBeforeLastDecision M))\n\ngoal (1 subgoal):\n 1. consistent (elements M')", "using \\<open>M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\\<close>"], ["proof (prove)\nusing this:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n  consistent (elements (prefixBeforeLastDecision M))\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n\ngoal (1 subgoal):\n 1. consistent (elements M')", "using inconsistentAppend[of \"elements (prefixBeforeLastDecision M)\" \"[opposite (lastDecision M)]\"]"], ["proof (prove)\nusing this:\n  \\<not> lastDecision M el elements (prefixBeforeLastDecision M)\n  consistent (elements (prefixBeforeLastDecision M))\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  inconsistent\n   (elements (prefixBeforeLastDecision M) @\n    [opposite (lastDecision M)]) \\<Longrightarrow>\n  inconsistent (elements (prefixBeforeLastDecision M)) \\<or>\n  inconsistent [opposite (lastDecision M)] \\<or>\n  (\\<exists>literal.\n      literalTrue literal (elements (prefixBeforeLastDecision M)) \\<and>\n      literalFalse literal [opposite (lastDecision M)])\n\ngoal (1 subgoal):\n 1. consistent (elements M')", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  InvariantConsistent M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantUniqAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantUniq M\" and \"InvariantConsistent M\" and\n  \"decisions M \\<noteq> []\" and\n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantUniq M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "from \\<open>InvariantUniq M\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq M", "have \"uniq (elements (prefixBeforeLastDecision M))\""], ["proof (prove)\nusing this:\n  InvariantUniq M\n\ngoal (1 subgoal):\n 1. uniq (elements (prefixBeforeLastDecision M))", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. uniq (elements (prefixBeforeLastDecision M))", "using isPrefixPrefixBeforeLastMarked[of \"M\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  isPrefix (prefixBeforeLastDecision M) M\n\ngoal (1 subgoal):\n 1. uniq (elements (prefixBeforeLastDecision M))", "using isPrefixElements[of \"prefixBeforeLastDecision M\" \"M\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n\ngoal (1 subgoal):\n 1. uniq (elements (prefixBeforeLastDecision M))", "using uniqListImpliesUniqPrefix"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n  \\<lbrakk>isPrefix ?p ?l; uniq ?l\\<rbrakk> \\<Longrightarrow> uniq ?p\n\ngoal (1 subgoal):\n 1. uniq (elements (prefixBeforeLastDecision M))", "by simp"], ["proof (state)\nthis:\n  uniq (elements (prefixBeforeLastDecision M))\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "moreover"], ["proof (state)\nthis:\n  uniq (elements (prefixBeforeLastDecision M))\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "from \\<open>decisions M \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  decisions M \\<noteq> []", "have \"lastDecision M el (elements M)\""], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. lastDecision M el elements M", "using lastMarkedIsMarkedElement[of \"M\"]"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  decisions M \\<noteq> [] \\<Longrightarrow>\n  lastDecision M \\<in> set (decisions M)\n\ngoal (1 subgoal):\n 1. lastDecision M el elements M", "using markedElementsAreElements[of \"lastDecision M\" \"M\"]"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  decisions M \\<noteq> [] \\<Longrightarrow>\n  lastDecision M \\<in> set (decisions M)\n  lastDecision M \\<in> set (decisions M) \\<Longrightarrow>\n  lastDecision M \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. lastDecision M el elements M", "by simp"], ["proof (state)\nthis:\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "with \\<open>InvariantConsistent M\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent M\n  lastDecision M el elements M", "have \"\\<not> opposite (lastDecision M) el (elements M)\""], ["proof (prove)\nusing this:\n  InvariantConsistent M\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el elements M", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el elements M", "using inconsistentCharacterization"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  lastDecision M el elements M\n  inconsistent ?valuation =\n  (\\<exists>literal.\n      literalTrue literal ?valuation \\<and> literalFalse literal ?valuation)\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el elements M", "by simp"], ["proof (state)\nthis:\n  \\<not> opposite (lastDecision M) el elements M\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "hence \"\\<not> opposite (lastDecision M) el (elements (prefixBeforeLastDecision M))\""], ["proof (prove)\nusing this:\n  \\<not> opposite (lastDecision M) el elements M\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el\n           elements (prefixBeforeLastDecision M)", "using isPrefixPrefixBeforeLastMarked[of \"M\"]"], ["proof (prove)\nusing this:\n  \\<not> opposite (lastDecision M) el elements M\n  isPrefix (prefixBeforeLastDecision M) M\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el\n           elements (prefixBeforeLastDecision M)", "using isPrefixElements[of \"prefixBeforeLastDecision M\" \"M\"]"], ["proof (prove)\nusing this:\n  \\<not> opposite (lastDecision M) el elements M\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el\n           elements (prefixBeforeLastDecision M)", "using prefixIsSubset[of \"elements (prefixBeforeLastDecision M)\" \"elements M\"]"], ["proof (prove)\nusing this:\n  \\<not> opposite (lastDecision M) el elements M\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n  isPrefix (elements (prefixBeforeLastDecision M))\n   (elements M) \\<Longrightarrow>\n  set (elements (prefixBeforeLastDecision M)) \\<subseteq> set (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> opposite (lastDecision M) el\n           elements (prefixBeforeLastDecision M)", "by auto"], ["proof (state)\nthis:\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "ultimately"], ["proof (chain)\npicking this:\n  uniq (elements (prefixBeforeLastDecision M))\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)", "show ?thesis"], ["proof (prove)\nusing this:\n  uniq (elements (prefixBeforeLastDecision M))\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "using \n      \\<open>M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\\<close>\n      uniqAppendElement[of \"elements (prefixBeforeLastDecision M)\" \"opposite (lastDecision M)\"]"], ["proof (prove)\nusing this:\n  uniq (elements (prefixBeforeLastDecision M))\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  uniq (elements (prefixBeforeLastDecision M)) \\<Longrightarrow>\n  (opposite (lastDecision M)\n   \\<notin> set (elements (prefixBeforeLastDecision M))) =\n  uniq (elements (prefixBeforeLastDecision M) @ [opposite (lastDecision M)])\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements (prefixBeforeLastDecision M))\n  \\<not> opposite (lastDecision M) el elements (prefixBeforeLastDecision M)\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  uniq (elements (prefixBeforeLastDecision M)) \\<Longrightarrow>\n  (opposite (lastDecision M)\n   \\<notin> set (elements (prefixBeforeLastDecision M))) =\n  uniq (elements (prefixBeforeLastDecision M) @ [opposite (lastDecision M)])\n\ngoal (1 subgoal):\n 1. uniq (elements M')", "by simp"], ["proof (state)\nthis:\n  InvariantUniq M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantVarsMAfterBacktrack:\n  fixes F::Formula and M::LiteralTrail\n  assumes \"InvariantVarsM M F0 Vbl\"\n  \"decisions M \\<noteq> []\" and\n  \"M' = (prefixBeforeLastDecision M) @ [(opposite (lastDecision M), False)]\"\n  shows \"InvariantVarsM M' F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "from \\<open>decisions M \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  decisions M \\<noteq> []", "have \"lastDecision M el (elements M)\""], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n\ngoal (1 subgoal):\n 1. lastDecision M el elements M", "using lastMarkedIsMarkedElement[of \"M\"]"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  decisions M \\<noteq> [] \\<Longrightarrow>\n  lastDecision M \\<in> set (decisions M)\n\ngoal (1 subgoal):\n 1. lastDecision M el elements M", "using markedElementsAreElements[of \"lastDecision M\" \"M\"]"], ["proof (prove)\nusing this:\n  decisions M \\<noteq> []\n  decisions M \\<noteq> [] \\<Longrightarrow>\n  lastDecision M \\<in> set (decisions M)\n  lastDecision M \\<in> set (decisions M) \\<Longrightarrow>\n  lastDecision M \\<in> set (elements M)\n\ngoal (1 subgoal):\n 1. lastDecision M el elements M", "by simp"], ["proof (state)\nthis:\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "hence \"var (lastDecision M) \\<in> vars (elements M)\""], ["proof (prove)\nusing this:\n  lastDecision M el elements M\n\ngoal (1 subgoal):\n 1. var (lastDecision M) \\<in> vars (elements M)", "using valuationContainsItsLiteralsVariable[of \"lastDecision M\" \"elements M\"]"], ["proof (prove)\nusing this:\n  lastDecision M el elements M\n  lastDecision M el elements M \\<Longrightarrow>\n  var (lastDecision M) \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. var (lastDecision M) \\<in> vars (elements M)", "by simp"], ["proof (state)\nthis:\n  var (lastDecision M) \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "moreover"], ["proof (state)\nthis:\n  var (lastDecision M) \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "have \"vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (elements (prefixBeforeLastDecision M))\n    \\<subseteq> vars (elements M)", "using isPrefixPrefixBeforeLastMarked[of \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix (prefixBeforeLastDecision M) M\n\ngoal (1 subgoal):\n 1. vars (elements (prefixBeforeLastDecision M))\n    \\<subseteq> vars (elements M)", "using isPrefixElements[of \"prefixBeforeLastDecision M\" \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n\ngoal (1 subgoal):\n 1. vars (elements (prefixBeforeLastDecision M))\n    \\<subseteq> vars (elements M)", "using varsPrefixValuation[of \"elements (prefixBeforeLastDecision M)\" \"elements M\"]"], ["proof (prove)\nusing this:\n  isPrefix (prefixBeforeLastDecision M) M\n  isPrefix (prefixBeforeLastDecision M) M \\<Longrightarrow>\n  isPrefix (elements (prefixBeforeLastDecision M)) (elements M)\n  isPrefix (elements (prefixBeforeLastDecision M))\n   (elements M) \\<Longrightarrow>\n  vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. vars (elements (prefixBeforeLastDecision M))\n    \\<subseteq> vars (elements M)", "by auto"], ["proof (state)\nthis:\n  vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "ultimately"], ["proof (chain)\npicking this:\n  var (lastDecision M) \\<in> vars (elements M)\n  vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  var (lastDecision M) \\<in> vars (elements M)\n  vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "using assms"], ["proof (prove)\nusing this:\n  var (lastDecision M) \\<in> vars (elements M)\n  vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)\n  InvariantVarsM M F0 Vbl\n  decisions M \\<noteq> []\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "using varsAppendValuation[of \"elements (prefixBeforeLastDecision M)\" \"[opposite (lastDecision M)]\"]"], ["proof (prove)\nusing this:\n  var (lastDecision M) \\<in> vars (elements M)\n  vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)\n  InvariantVarsM M F0 Vbl\n  decisions M \\<noteq> []\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  vars\n   (elements (prefixBeforeLastDecision M) @ [opposite (lastDecision M)]) =\n  vars (elements (prefixBeforeLastDecision M)) \\<union>\n  vars [opposite (lastDecision M)]\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  var (lastDecision M) \\<in> vars (elements M)\n  vars (elements (prefixBeforeLastDecision M)) \\<subseteq> vars (elements M)\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  decisions M \\<noteq> []\n  M' = prefixBeforeLastDecision M @ [(opposite (lastDecision M), False)]\n  vars\n   (elements (prefixBeforeLastDecision M) @ [opposite (lastDecision M)]) =\n  vars (elements (prefixBeforeLastDecision M)) \\<union>\n  vars [opposite (lastDecision M)]\n\ngoal (1 subgoal):\n 1. vars (elements M') \\<subseteq> vars F0 \\<union> Vbl", "by auto"], ["proof (state)\nthis:\n  InvariantVarsM M' F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)\n(*                     A P P L Y    B A C K J U M P                     *)\n(************************************************************************)"], ["", "text\\<open>$Backjump$ transition rule.\\<close>"], ["", "lemma InvariantImpliedLiteralsAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"isPrefix p M\" and \"formulaEntailsClause F bClause\" and \"isUnitClause bClause bLiteral (elements p)\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantImpliedLiterals F M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "from \\<open>InvariantImpliedLiterals F M\\<close> \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  isPrefix p M", "have \"InvariantImpliedLiterals F p\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  isPrefix p M\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F p", "using InvariantImpliedLiteralsHoldsForPrefix [of \"F\" \"M\" \"p\"]"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  isPrefix p M\n  \\<lbrakk>InvariantImpliedLiterals F M; isPrefix p M\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals F p\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F p", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F p\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "with assms"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M\n  isPrefix p M\n  formulaEntailsClause F bClause\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  InvariantImpliedLiterals F p", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  isPrefix p M\n  formulaEntailsClause F bClause\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  InvariantImpliedLiterals F p\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "using InvariantImpliedLiteralsAfterUnitPropagate [of \"F\" \"p\" \"bClause\" \"bLiteral\" \"M'\"]"], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n  isPrefix p M\n  formulaEntailsClause F bClause\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  InvariantImpliedLiterals F p\n  \\<lbrakk>InvariantImpliedLiterals F p; formulaEntailsClause F bClause;\n   isUnitClause bClause bLiteral (elements p);\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantImpliedLiterals F M'\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F M'", "by simp"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantVarsMAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantVarsM M F0 Vbl\" and\n  \"isPrefix p M\" and \"var bLiteral \\<in> vars F0 \\<union> Vbl\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantVarsM M' F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "from \\<open>InvariantVarsM M F0 Vbl\\<close>"], ["proof (chain)\npicking this:\n  InvariantVarsM M F0 Vbl", "have \"vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\""], ["proof (prove)\nusing this:\n  InvariantVarsM M F0 Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M) \\<subseteq> vars F0 \\<union> Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M) \\<subseteq> vars F0 \\<union> Vbl", "."], ["proof (state)\nthis:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "moreover"], ["proof (state)\nthis:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "from \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M", "have \"vars (elements p) \\<subseteq> vars (elements M)\""], ["proof (prove)\nusing this:\n  isPrefix p M\n\ngoal (1 subgoal):\n 1. vars (elements p) \\<subseteq> vars (elements M)", "using varsPrefixValuation [of \"elements p\" \"elements M\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  isPrefix (elements p) (elements M) \\<Longrightarrow>\n  vars (elements p) \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. vars (elements p) \\<subseteq> vars (elements M)", "by (simp add: isPrefixElements)"], ["proof (state)\nthis:\n  vars (elements p) \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "ultimately"], ["proof (chain)\npicking this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  vars (elements p) \\<subseteq> vars (elements M)", "have \"vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\""], ["proof (prove)\nusing this:\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  vars (elements p) \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. vars (elements p) \\<subseteq> vars F0 \\<union> Vbl", "by simp"], ["proof (state)\nthis:\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "with \\<open>vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\\<close> assms"], ["proof (chain)\npicking this:\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n  InvariantVarsM M F0 Vbl\n  isPrefix p M\n  var bLiteral \\<in> vars F0 \\<union> Vbl\n  M' = p @ [(bLiteral, False)]\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl", "show ?thesis"], ["proof (prove)\nusing this:\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n  InvariantVarsM M F0 Vbl\n  isPrefix p M\n  var bLiteral \\<in> vars F0 \\<union> Vbl\n  M' = p @ [(bLiteral, False)]\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "using InvariantVarsMAfterUnitPropagate[of  \"p\" \"F0\" \"Vbl\" \"bLiteral\" \"M'\"]"], ["proof (prove)\nusing this:\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n  InvariantVarsM M F0 Vbl\n  isPrefix p M\n  var bLiteral \\<in> vars F0 \\<union> Vbl\n  M' = p @ [(bLiteral, False)]\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n  \\<lbrakk>InvariantVarsM p F0 Vbl; var bLiteral \\<in> vars F0 \\<union> Vbl;\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM M' F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM M' F0 Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n  vars (elements M) \\<subseteq> vars F0 \\<union> Vbl\n  isPrefix p M\n  var bLiteral \\<in> vars F0 \\<union> Vbl\n  M' = p @ [(bLiteral, False)]\n  vars (elements p) \\<subseteq> vars F0 \\<union> Vbl\n  \\<lbrakk>vars (elements p) \\<subseteq> vars F0 \\<union> Vbl;\n   var bLiteral \\<in> vars F0 \\<union> Vbl;\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> vars (elements M') \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars (elements M') \\<subseteq> vars F0 \\<union> Vbl", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM M' F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConsistentAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantConsistent M\" and\n  \"isPrefix p M\" and \"isUnitClause bClause bLiteral (elements p)\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantConsistent M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "from \\<open>InvariantConsistent M\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent M", "have \"consistent (elements M)\""], ["proof (prove)\nusing this:\n  InvariantConsistent M\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "."], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  consistent (elements M)", "have \"consistent (elements p)\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements p)", "using consistentPrefix [of \"elements p\" \"elements M\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  consistent (elements M)\n  \\<lbrakk>isPrefix (elements p) (elements M);\n   consistent (elements M)\\<rbrakk>\n  \\<Longrightarrow> consistent (elements p)\n\ngoal (1 subgoal):\n 1. consistent (elements p)", "by (simp add: isPrefixElements)"], ["proof (state)\nthis:\n  consistent (elements p)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "with assms"], ["proof (chain)\npicking this:\n  InvariantConsistent M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  consistent (elements p)", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantConsistent M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  consistent (elements p)\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "using InvariantConsistentAfterUnitPropagate [of \"p\" \"bClause\" \"bLiteral\" \"M'\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  consistent (elements p)\n  \\<lbrakk>InvariantConsistent p;\n   isUnitClause bClause bLiteral (elements p);\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent M'\n\ngoal (1 subgoal):\n 1. InvariantConsistent M'", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  consistent (elements p)\n  \\<lbrakk>consistent (elements p);\n   isUnitClause bClause bLiteral (elements p);\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> consistent (elements M')\n\ngoal (1 subgoal):\n 1. consistent (elements M')", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantUniqAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantUniq M\" and\n  \"isPrefix p M\"  and \"isUnitClause bClause bLiteral (elements p)\" and\n  \"M' = p @ [(bLiteral, False)]\" \n  shows \"InvariantUniq M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantUniq M'", "from \\<open>InvariantUniq M\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq M", "have \"uniq (elements M)\""], ["proof (prove)\nusing this:\n  InvariantUniq M\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "."], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "with \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  isPrefix p M\n  uniq (elements M)", "have \"uniq (elements p)\""], ["proof (prove)\nusing this:\n  isPrefix p M\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. uniq (elements p)", "using uniqElementsTrailImpliesUniqElementsPrefix [of \"p\" \"M\"]"], ["proof (prove)\nusing this:\n  isPrefix p M\n  uniq (elements M)\n  \\<lbrakk>isPrefix p M; uniq (elements M)\\<rbrakk>\n  \\<Longrightarrow> uniq (elements p)\n\ngoal (1 subgoal):\n 1. uniq (elements p)", "by simp"], ["proof (state)\nthis:\n  uniq (elements p)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "with assms"], ["proof (chain)\npicking this:\n  InvariantUniq M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  uniq (elements p)", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantUniq M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  uniq (elements p)\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "using InvariantUniqAfterUnitPropagate[of \"p\" \"bClause\" \"bLiteral\" \"M'\"]"], ["proof (prove)\nusing this:\n  InvariantUniq M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  uniq (elements p)\n  \\<lbrakk>InvariantUniq p; isUnitClause bClause bLiteral (elements p);\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq M'\n\ngoal (1 subgoal):\n 1. InvariantUniq M'", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  M' = p @ [(bLiteral, False)]\n  uniq (elements p)\n  \\<lbrakk>uniq (elements p); isUnitClause bClause bLiteral (elements p);\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> uniq (elements M')\n\ngoal (1 subgoal):\n 1. uniq (elements M')", "by simp"], ["proof (state)\nthis:\n  InvariantUniq M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantReasonClausesAfterBackjump:\n  fixes F::Formula and M::LiteralTrail and p::LiteralTrail and bClause::Clause and bLiteral::Literal\n  assumes \"InvariantReasonClauses F M\" and \"InvariantUniq M\"  and\n  \"isPrefix p M\"  and \"isUnitClause bClause bLiteral (elements p)\" and \"formulaEntailsClause F bClause\" and\n  \"M' = p @ [(bLiteral, False)]\"\n  shows \"InvariantReasonClauses F M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "from \\<open>InvariantReasonClauses F M\\<close> \\<open>InvariantUniq M\\<close> \\<open>isPrefix p M\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  isPrefix p M", "have \"InvariantReasonClauses F p\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  isPrefix p M\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F p", "by (rule InvariantReasonClausesHoldsForPrefix)"], ["proof (state)\nthis:\n  InvariantReasonClauses F p\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "with assms"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  formulaEntailsClause F bClause\n  M' = p @ [(bLiteral, False)]\n  InvariantReasonClauses F p", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  formulaEntailsClause F bClause\n  M' = p @ [(bLiteral, False)]\n  InvariantReasonClauses F p\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "using InvariantReasonClausesAfterUnitPropagate [of \"F\" \"p\" \"bClause\" \"bLiteral\" \"M'\"]"], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  InvariantUniq M\n  isPrefix p M\n  isUnitClause bClause bLiteral (elements p)\n  formulaEntailsClause F bClause\n  M' = p @ [(bLiteral, False)]\n  InvariantReasonClauses F p\n  \\<lbrakk>InvariantReasonClauses F p; formulaEntailsClause F bClause;\n   isUnitClause bClause bLiteral (elements p);\n   M' = p @ [(bLiteral, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantReasonClauses F M'\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F M'", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses F M'\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)\n(*                       A P P L Y    L E A R N                         *)\n(************************************************************************)"], ["", "text\\<open>$Learn$ transition rule.\\<close>"], ["", "lemma InvariantImpliedLiteralsAfterLearn: \n  fixes F :: Formula and F' :: Formula and M :: LiteralTrail and C :: Clause\n  assumes \"InvariantImpliedLiterals F M\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantImpliedLiterals F' M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "from \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantImpliedLiterals F M", "have *: \"\\<forall> l. l el (elements M) \\<longrightarrow> formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\""], ["proof (prove)\nusing this:\n  InvariantImpliedLiterals F M\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l", "unfolding InvariantImpliedLiterals_def"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l", "."], ["proof (state)\nthis:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "{"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "fix literal :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "assume \"literal el (elements M)\""], ["proof (state)\nthis:\n  literal el elements M\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "with *"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  literal el elements M", "have \"formulaEntailsLiteral (F @ val2form (decisionsTo literal M)) literal\""], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  literal el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo literal M)) literal", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ val2form (decisionsTo literal M)) literal\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "hence \"formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo literal M)) literal\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo literal M)) literal\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo literal M))\n     literal", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo literal M))\n     literal \\<Longrightarrow>\n    formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo literal M))\n     literal", "have \"\\<forall> clause::Clause. clause el (F @ val2form (decisionsTo literal M)) \\<longrightarrow> clause el (F @ [C] @ val2form (decisionsTo literal M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n       clause el F @ [C] @ val2form (decisionsTo literal M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n       clause el F @ [C] @ val2form (decisionsTo literal M)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n       clause el F @ [C] @ val2form (decisionsTo literal M)", "fix clause :: Clause"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n       clause el F @ [C] @ val2form (decisionsTo literal M)", "have \"clause el (F @ val2form (decisionsTo literal M)) \\<longrightarrow> clause el (F @ [C] @ val2form (decisionsTo literal M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n    clause el F @ [C] @ val2form (decisionsTo literal M)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. clause el F @ val2form (decisionsTo literal M) \\<Longrightarrow>\n    clause el F @ [C] @ val2form (decisionsTo literal M)", "assume \"clause el (F @ val2form (decisionsTo literal M))\""], ["proof (state)\nthis:\n  clause el F @ val2form (decisionsTo literal M)\n\ngoal (1 subgoal):\n 1. clause el F @ val2form (decisionsTo literal M) \\<Longrightarrow>\n    clause el F @ [C] @ val2form (decisionsTo literal M)", "thus \"clause el (F @ [C] @ val2form (decisionsTo literal M))\""], ["proof (prove)\nusing this:\n  clause el F @ val2form (decisionsTo literal M)\n\ngoal (1 subgoal):\n 1. clause el F @ [C] @ val2form (decisionsTo literal M)", "by auto"], ["proof (state)\nthis:\n  clause el F @ [C] @ val2form (decisionsTo literal M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n  clause el F @ [C] @ val2form (decisionsTo literal M)\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n       clause el F @ [C] @ val2form (decisionsTo literal M)", "}"], ["proof (state)\nthis:\n  ?clause2 el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n  ?clause2 el F @ [C] @ val2form (decisionsTo literal M)\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n       clause el F @ [C] @ val2form (decisionsTo literal M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?clause2 el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n  ?clause2 el F @ [C] @ val2form (decisionsTo literal M)\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n       clause el F @ [C] @ val2form (decisionsTo literal M)", "by auto"], ["proof (state)\nthis:\n  \\<forall>clause.\n     clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n     clause el F @ [C] @ val2form (decisionsTo literal M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>clause.\n     clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n     clause el F @ [C] @ val2form (decisionsTo literal M)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ val2form (decisionsTo literal M))\n     literal \\<Longrightarrow>\n    formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo literal M))\n     literal", "with \\<open>formulaEntailsLiteral (F @ val2form (decisionsTo literal M)) literal\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo literal M)) literal\n  \\<forall>clause.\n     clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n     clause el F @ [C] @ val2form (decisionsTo literal M)", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F @ val2form (decisionsTo literal M)) literal\n  \\<forall>clause.\n     clause el F @ val2form (decisionsTo literal M) \\<longrightarrow>\n     clause el F @ [C] @ val2form (decisionsTo literal M)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo literal M))\n     literal", "by (rule formulaEntailsLiteralSubset)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo literal M)) literal\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo literal M)) literal\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "}"], ["proof (state)\nthis:\n  ?literal2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo ?literal2 M))\n   ?literal2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?literal2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo ?literal2 M))\n   ?literal2\n\ngoal (1 subgoal):\n 1. InvariantImpliedLiterals F' M", "unfolding InvariantImpliedLiterals_def"], ["proof (prove)\nusing this:\n  ?literal2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo ?literal2 M))\n   ?literal2\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F' @ val2form (decisionsTo l M)) l", "using \\<open>F' = F @ [C]\\<close>"], ["proof (prove)\nusing this:\n  ?literal2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral (F @ [C] @ val2form (decisionsTo ?literal2 M))\n   ?literal2\n  F' = F @ [C]\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el elements M \\<longrightarrow>\n       formulaEntailsLiteral (F' @ val2form (decisionsTo l M)) l", "by auto"], ["proof (state)\nthis:\n  InvariantImpliedLiterals F' M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantReasonClausesAfterLearn:\n  fixes F :: Formula and F' :: Formula and M :: LiteralTrail and C :: Clause\n  assumes \"InvariantReasonClauses F M\" and\n  \"formulaEntailsClause F C\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantReasonClauses F' M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "fix literal :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "assume \"literal el elements M \\<and> \\<not> literal el decisions M\""], ["proof (state)\nthis:\n  literal el elements M \\<and> \\<not> literal el decisions M\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "with \\<open>InvariantReasonClauses F M\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses F M\n  literal el elements M \\<and> \\<not> literal el decisions M", "obtain clause::Clause\n      where \"formulaEntailsClause F clause\" \"isReason clause literal (elements M)\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses F M\n  literal el elements M \\<and> \\<not> literal el decisions M\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>formulaEntailsClause F clause;\n         isReason clause literal (elements M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n  literal el elements M \\<and> \\<not> literal el decisions M\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>formulaEntailsClause F clause;\n         isReason clause literal (elements M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause F clause\n  isReason clause literal (elements M)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "from \\<open>formulaEntailsClause F clause\\<close> \\<open>F' = F @ [C]\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsClause F clause\n  F' = F @ [C]", "have \"formulaEntailsClause F' clause\""], ["proof (prove)\nusing this:\n  formulaEntailsClause F clause\n  F' = F @ [C]\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F' clause", "by (simp add:formulaEntailsClauseAppend)"], ["proof (state)\nthis:\n  formulaEntailsClause F' clause\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "with \\<open>isReason clause literal (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isReason clause literal (elements M)\n  formulaEntailsClause F' clause", "have \"\\<exists> clause. formulaEntailsClause F' clause \\<and> isReason clause literal (elements M)\""], ["proof (prove)\nusing this:\n  isReason clause literal (elements M)\n  formulaEntailsClause F' clause\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F' clause \\<and>\n       isReason clause literal (elements M)", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F' clause \\<and>\n     isReason clause literal (elements M)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "}"], ["proof (state)\nthis:\n  ?literal2 el elements M \\<and>\n  \\<not> ?literal2 el decisions M \\<Longrightarrow>\n  \\<exists>clause.\n     formulaEntailsClause F' clause \\<and>\n     isReason clause ?literal2 (elements M)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?literal2 el elements M \\<and>\n  \\<not> ?literal2 el decisions M \\<Longrightarrow>\n  \\<exists>clause.\n     formulaEntailsClause F' clause \\<and>\n     isReason clause ?literal2 (elements M)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses F' M", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  ?literal2 el elements M \\<and>\n  \\<not> ?literal2 el decisions M \\<Longrightarrow>\n  \\<exists>clause.\n     formulaEntailsClause F' clause \\<and>\n     isReason clause ?literal2 (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<and>\n       \\<not> literal el decisions M \\<longrightarrow>\n       (\\<exists>clause.\n           formulaEntailsClause F' clause \\<and>\n           isReason clause literal (elements M))", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses F' M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantVarsFAfterLearn:\n  fixes F0 :: Formula and F :: Formula and F' :: Formula and C :: Clause\n  assumes \"InvariantVarsF F F0 Vbl\" and \n  \"vars C \\<subseteq> (vars F0) \\<union> Vbl\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantVarsF F' F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF F' F0 Vbl", "using assms"], ["proof (prove)\nusing this:\n  InvariantVarsF F F0 Vbl\n  vars C \\<subseteq> vars F0 \\<union> Vbl\n  F' = F @ [C]\n\ngoal (1 subgoal):\n 1. InvariantVarsF F' F0 Vbl", "using varsAppendFormulae[of \"F\" \"[C]\"]"], ["proof (prove)\nusing this:\n  InvariantVarsF F F0 Vbl\n  vars C \\<subseteq> vars F0 \\<union> Vbl\n  F' = F @ [C]\n  vars (F @ [C]) = vars F \\<union> vars [C]\n\ngoal (1 subgoal):\n 1. InvariantVarsF F' F0 Vbl", "unfolding InvariantVarsF_def"], ["proof (prove)\nusing this:\n  vars F \\<subseteq> vars F0 \\<union> Vbl\n  vars C \\<subseteq> vars F0 \\<union> Vbl\n  F' = F @ [C]\n  vars (F @ [C]) = vars F \\<union> vars [C]\n\ngoal (1 subgoal):\n 1. vars F' \\<subseteq> vars F0 \\<union> Vbl", "by auto"], ["", "lemma InvariantEquivalentAfterLearn: \n  fixes F0 :: Formula and F :: Formula and F' :: Formula and C :: Clause\n  assumes \"InvariantEquivalent F0 F\" and \n  \"formulaEntailsClause F C\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantEquivalent F0 F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 F'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 F'", "from \\<open>InvariantEquivalent F0 F\\<close>"], ["proof (chain)\npicking this:\n  InvariantEquivalent F0 F", "have \"equivalentFormulae F0 F\""], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 F\n\ngoal (1 subgoal):\n 1. equivalentFormulae F0 F", "unfolding InvariantEquivalent_def"], ["proof (prove)\nusing this:\n  equivalentFormulae F0 F\n\ngoal (1 subgoal):\n 1. equivalentFormulae F0 F", "."], ["proof (state)\nthis:\n  equivalentFormulae F0 F\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 F'", "with \\<open>formulaEntailsClause F C\\<close> \\<open>F' = F @ [C]\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsClause F C\n  F' = F @ [C]\n  equivalentFormulae F0 F", "have \"equivalentFormulae F0 (F @ [C])\""], ["proof (prove)\nusing this:\n  formulaEntailsClause F C\n  F' = F @ [C]\n  equivalentFormulae F0 F\n\ngoal (1 subgoal):\n 1. equivalentFormulae F0 (F @ [C])", "using extendEquivalentFormulaWithEntailedClause [of \"F0\" \"F\" \"C\"]"], ["proof (prove)\nusing this:\n  formulaEntailsClause F C\n  F' = F @ [C]\n  equivalentFormulae F0 F\n  \\<lbrakk>equivalentFormulae F0 F; formulaEntailsClause F C\\<rbrakk>\n  \\<Longrightarrow> equivalentFormulae F0 (F @ [C])\n\ngoal (1 subgoal):\n 1. equivalentFormulae F0 (F @ [C])", "by simp"], ["proof (state)\nthis:\n  equivalentFormulae F0 (F @ [C])\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 F'", "thus ?thesis"], ["proof (prove)\nusing this:\n  equivalentFormulae F0 (F @ [C])\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 F'", "unfolding InvariantEquivalent_def"], ["proof (prove)\nusing this:\n  equivalentFormulae F0 (F @ [C])\n\ngoal (1 subgoal):\n 1. equivalentFormulae F0 F'", "using \\<open>F' = F @ [C]\\<close>"], ["proof (prove)\nusing this:\n  equivalentFormulae F0 (F @ [C])\n  F' = F @ [C]\n\ngoal (1 subgoal):\n 1. equivalentFormulae F0 F'", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 F'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantCEntailedAfterLearn:\n  fixes F0 :: Formula and F :: Formula and F' :: Formula and C :: Clause\n  assumes \"InvariantCEntailed conflictFlag F C\" and\n  \"F' = F @ [C]\"\n  shows \"InvariantCEntailed conflictFlag F' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed conflictFlag F' C", "using assms"], ["proof (prove)\nusing this:\n  InvariantCEntailed conflictFlag F C\n  F' = F @ [C]\n\ngoal (1 subgoal):\n 1. InvariantCEntailed conflictFlag F' C", "unfolding InvariantCEntailed_def"], ["proof (prove)\nusing this:\n  conflictFlag \\<longrightarrow> formulaEntailsClause F C\n  F' = F @ [C]\n\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> formulaEntailsClause F' C", "by (auto simp add:formulaEntailsClauseAppend)"], ["", "(************************************************************************)\n(*                     A P P L Y    E X P L A I N                       *)\n(************************************************************************)"], ["", "text\\<open>$Explain$ transition rule.\\<close>"], ["", "lemma InvariantCFalseAfterExplain: \n  fixes conflictFlag::bool and M::LiteralTrail and C::Clause and literal :: Literal\n  assumes \"InvariantCFalse conflictFlag M C\" and\n  \"opposite literal el C\" and \"isReason reason literal (elements M)\" and\n  \"C' = resolve C reason (opposite literal)\"\n  shows \"InvariantCFalse conflictFlag M C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag M C'", "unfolding InvariantCFalse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> clauseFalse C' (elements M)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C' (elements M)", "assume \"conflictFlag\""], ["proof (state)\nthis:\n  conflictFlag\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C' (elements M)", "with \\<open>InvariantCFalse conflictFlag M C\\<close>"], ["proof (chain)\npicking this:\n  InvariantCFalse conflictFlag M C\n  conflictFlag", "have \"clauseFalse C (elements M)\""], ["proof (prove)\nusing this:\n  InvariantCFalse conflictFlag M C\n  conflictFlag\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M)", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n  conflictFlag\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M)", "by simp"], ["proof (state)\nthis:\n  clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C' (elements M)", "hence \"clauseFalse (removeAll (opposite literal) C) (elements M)\""], ["proof (prove)\nusing this:\n  clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll (opposite literal) C) (elements M)", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  clauseFalse (removeAll (opposite literal) C) (elements M)\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C' (elements M)", "moreover"], ["proof (state)\nthis:\n  clauseFalse (removeAll (opposite literal) C) (elements M)\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C' (elements M)", "from \\<open>isReason reason literal (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isReason reason literal (elements M)", "have \"clauseFalse (removeAll literal reason) (elements M)\""], ["proof (prove)\nusing this:\n  isReason reason literal (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal reason) (elements M)", "unfolding isReason_def"], ["proof (prove)\nusing this:\n  literal el reason \\<and>\n  clauseFalse (removeAll literal reason) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll literal reason \\<longrightarrow>\n      precedes (opposite literal') literal (elements M) \\<and>\n      opposite literal' \\<noteq> literal)\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal reason) (elements M)", "by simp"], ["proof (state)\nthis:\n  clauseFalse (removeAll literal reason) (elements M)\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> clauseFalse C' (elements M)", "ultimately"], ["proof (chain)\npicking this:\n  clauseFalse (removeAll (opposite literal) C) (elements M)\n  clauseFalse (removeAll literal reason) (elements M)", "show \"clauseFalse C' (elements M)\""], ["proof (prove)\nusing this:\n  clauseFalse (removeAll (opposite literal) C) (elements M)\n  clauseFalse (removeAll literal reason) (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse C' (elements M)", "using \\<open>C' = resolve C reason (opposite literal)\\<close>\n    resolveFalseClauses [of \"opposite literal\" \"C\" \"elements M\" \"reason\"]"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll (opposite literal) C) (elements M)\n  clauseFalse (removeAll literal reason) (elements M)\n  C' = resolve C reason (opposite literal)\n  \\<lbrakk>clauseFalse (removeAll (opposite literal) C) (elements M);\n   clauseFalse (removeAll (opposite (opposite literal)) reason)\n    (elements M)\\<rbrakk>\n  \\<Longrightarrow> clauseFalse (resolve C reason (opposite literal))\n                     (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse C' (elements M)", "by simp"], ["proof (state)\nthis:\n  clauseFalse C' (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantCEntailedAfterExplain: \n  fixes conflictFlag::bool and M::LiteralTrail and C::Clause and literal :: Literal and reason :: Clause\n  assumes \"InvariantCEntailed conflictFlag F C\" and\n  \"formulaEntailsClause F reason\" and \"C' = (resolve C reason (opposite l))\"\n  shows \"InvariantCEntailed conflictFlag F C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed conflictFlag F C'", "unfolding InvariantCEntailed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conflictFlag \\<longrightarrow> formulaEntailsClause F C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> formulaEntailsClause F C'", "assume \"conflictFlag\""], ["proof (state)\nthis:\n  conflictFlag\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> formulaEntailsClause F C'", "with \\<open>InvariantCEntailed conflictFlag F C\\<close>"], ["proof (chain)\npicking this:\n  InvariantCEntailed conflictFlag F C\n  conflictFlag", "have \"formulaEntailsClause F C\""], ["proof (prove)\nusing this:\n  InvariantCEntailed conflictFlag F C\n  conflictFlag\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C", "unfolding InvariantCEntailed_def"], ["proof (prove)\nusing this:\n  conflictFlag \\<longrightarrow> formulaEntailsClause F C\n  conflictFlag\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause F C\n\ngoal (1 subgoal):\n 1. conflictFlag \\<Longrightarrow> formulaEntailsClause F C'", "with \\<open>formulaEntailsClause F reason\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsClause F reason\n  formulaEntailsClause F C", "show \"formulaEntailsClause F C'\""], ["proof (prove)\nusing this:\n  formulaEntailsClause F reason\n  formulaEntailsClause F C\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C'", "using \\<open>C' = (resolve C reason (opposite l))\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsClause F reason\n  formulaEntailsClause F C\n  C' = resolve C reason (opposite l)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C'", "by (simp add:formulaEntailsResolvent)"], ["proof (state)\nthis:\n  formulaEntailsClause F C'\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)\n(*                     A P P L Y    C O N F L I C T                     *)\n(************************************************************************)"], ["", "text\\<open>$Conflict$ transition rule.\\<close>"], ["", "lemma invariantCFalseAfterConflict:\n  fixes conflictFlag::bool and conflictFlag'::bool and M::LiteralTrail and F :: Formula and clause :: Clause and C' :: Clause\n  assumes \"conflictFlag = False\" and\n  \"formulaFalse F (elements M)\" and \"clause el F\" \"clauseFalse clause (elements M)\" and\n  \"C' = clause\" and \"conflictFlag' = True\"\n  shows \"InvariantCFalse conflictFlag' M C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse conflictFlag' M C'", "unfolding InvariantCFalse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conflictFlag' \\<longrightarrow> clauseFalse C' (elements M)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. conflictFlag' \\<Longrightarrow> clauseFalse C' (elements M)", "from \\<open>conflictFlag' = True\\<close>"], ["proof (chain)\npicking this:\n  conflictFlag' = True", "show \"clauseFalse C' (elements M)\""], ["proof (prove)\nusing this:\n  conflictFlag' = True\n\ngoal (1 subgoal):\n 1. clauseFalse C' (elements M)", "using \\<open>clauseFalse clause (elements M)\\<close> \\<open>C' = clause\\<close>"], ["proof (prove)\nusing this:\n  conflictFlag' = True\n  clauseFalse clause (elements M)\n  C' = clause\n\ngoal (1 subgoal):\n 1. clauseFalse C' (elements M)", "by simp"], ["proof (state)\nthis:\n  clauseFalse C' (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariantCEntailedAfterConflict:\n  fixes conflictFlag::bool and conflictFlag'::bool and M::LiteralTrail and F :: Formula and clause :: Clause and C' :: Clause\n  assumes \"conflictFlag = False\" and\n  \"formulaFalse F (elements M)\" and \"clause el F\" and \"clauseFalse clause (elements M)\" and\n  \"C' = clause\" and \"conflictFlag' = True\"\n  shows \"InvariantCEntailed conflictFlag' F C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed conflictFlag' F C'", "unfolding InvariantCEntailed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conflictFlag' \\<longrightarrow> formulaEntailsClause F C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. conflictFlag' \\<Longrightarrow> formulaEntailsClause F C'", "from \\<open>conflictFlag' = True\\<close>"], ["proof (chain)\npicking this:\n  conflictFlag' = True", "show \"formulaEntailsClause F C'\""], ["proof (prove)\nusing this:\n  conflictFlag' = True\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C'", "using \\<open>clause el F\\<close> \\<open>C' = clause\\<close>"], ["proof (prove)\nusing this:\n  conflictFlag' = True\n  clause el F\n  C' = clause\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C'", "by (simp add:formulaEntailsItsClauses)"], ["proof (state)\nthis:\n  formulaEntailsClause F C'\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)\n(*                   U N S A T     R E P O R T                          *)\n(************************************************************************)"], ["", "text\\<open>UNSAT report\\<close>"], ["", "lemma unsatReport: \n  fixes F :: Formula and M :: LiteralTrail and F0 :: Formula\n  assumes \"InvariantImpliedLiterals F M\" and \"InvariantEquivalent F0 F\" and\n  \"decisions M = []\" and \"formulaFalse F (elements M)\"\n  shows \"\\<not> satisfiable F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "have \"formulaEntailsValuation F (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "fix literal::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "assume \"literal el (elements M)\""], ["proof (state)\nthis:\n  literal el elements M\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "from \\<open>decisions M = []\\<close>"], ["proof (chain)\npicking this:\n  decisions M = []", "have \"decisionsTo literal M = []\""], ["proof (prove)\nusing this:\n  decisions M = []\n\ngoal (1 subgoal):\n 1. decisionsTo literal M = []", "by (simp add:markedElementsEmptyImpliesMarkedElementsToEmpty)"], ["proof (state)\nthis:\n  decisionsTo literal M = []\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "with \\<open>literal el (elements M)\\<close> \\<open>InvariantImpliedLiterals F M\\<close>"], ["proof (chain)\npicking this:\n  literal el elements M\n  InvariantImpliedLiterals F M\n  decisionsTo literal M = []", "have \"formulaEntailsLiteral F literal\""], ["proof (prove)\nusing this:\n  literal el elements M\n  InvariantImpliedLiterals F M\n  decisionsTo literal M = []\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral F literal", "unfolding InvariantImpliedLiterals_def"], ["proof (prove)\nusing this:\n  literal el elements M\n  \\<forall>l.\n     l el elements M \\<longrightarrow>\n     formulaEntailsLiteral (F @ val2form (decisionsTo l M)) l\n  decisionsTo literal M = []\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral F literal", "by auto"], ["proof (state)\nthis:\n  formulaEntailsLiteral F literal\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "}"], ["proof (state)\nthis:\n  ?literal2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral F ?literal2\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?literal2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral F ?literal2\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation F (elements M)", "unfolding formulaEntailsValuation_def"], ["proof (prove)\nusing this:\n  ?literal2 el elements M \\<Longrightarrow>\n  formulaEntailsLiteral F ?literal2\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el elements M \\<longrightarrow>\n       formulaEntailsLiteral F literal", "by simp"], ["proof (state)\nthis:\n  formulaEntailsValuation F (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsValuation F (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "with \\<open>formulaFalse F (elements M)\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse F (elements M)\n  formulaEntailsValuation F (elements M)", "have \"\\<not> satisfiable F\""], ["proof (prove)\nusing this:\n  formulaFalse F (elements M)\n  formulaEntailsValuation F (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F", "by (simp add:formulaFalseInEntailedValuationIsUnsatisfiable)"], ["proof (state)\nthis:\n  \\<not> satisfiable F\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "with \\<open>InvariantEquivalent F0 F\\<close>"], ["proof (chain)\npicking this:\n  InvariantEquivalent F0 F\n  \\<not> satisfiable F", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 F\n  \\<not> satisfiable F\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "unfolding InvariantEquivalent_def"], ["proof (prove)\nusing this:\n  equivalentFormulae F0 F\n  \\<not> satisfiable F\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by (simp add:satisfiableEquivalent)"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unsatReportExtensiveExplain:\n  fixes F :: Formula and M :: LiteralTrail and F0 :: Formula and C :: Clause and conflictFlag :: bool\n  assumes \"InvariantEquivalent F0 F\" and \"InvariantCEntailed conflictFlag F C\" and\n  \"conflictFlag\" and \"C = []\"\n  shows \"\\<not> satisfiable F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "from \\<open>conflictFlag\\<close> \\<open>InvariantCEntailed conflictFlag F C\\<close>"], ["proof (chain)\npicking this:\n  conflictFlag\n  InvariantCEntailed conflictFlag F C", "have \"formulaEntailsClause F C\""], ["proof (prove)\nusing this:\n  conflictFlag\n  InvariantCEntailed conflictFlag F C\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C", "unfolding InvariantCEntailed_def"], ["proof (prove)\nusing this:\n  conflictFlag\n  conflictFlag \\<longrightarrow> formulaEntailsClause F C\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F C", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause F C\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "with \\<open>C=[]\\<close>"], ["proof (chain)\npicking this:\n  C = []\n  formulaEntailsClause F C", "have \"\\<not> satisfiable F\""], ["proof (prove)\nusing this:\n  C = []\n  formulaEntailsClause F C\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F", "by (simp add:formulaUnsatIffImpliesEmptyClause)"], ["proof (state)\nthis:\n  \\<not> satisfiable F\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "with \\<open>InvariantEquivalent F0 F\\<close>"], ["proof (chain)\npicking this:\n  InvariantEquivalent F0 F\n  \\<not> satisfiable F", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 F\n  \\<not> satisfiable F\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "unfolding InvariantEquivalent_def"], ["proof (prove)\nusing this:\n  equivalentFormulae F0 F\n  \\<not> satisfiable F\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by (simp add:satisfiableEquivalent)"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)\n(*                       S A T     R E P O R T                          *)\n(************************************************************************)"], ["", "text\\<open>SAT Report\\<close>"], ["", "lemma satReport:\n  fixes F0 :: Formula and F :: Formula and M::LiteralTrail\n  assumes \"vars F0 \\<subseteq> Vbl\" and \"InvariantVarsF F F0 Vbl\" and \"InvariantConsistent M\" and \"InvariantEquivalent F0 F\" and\n  \"\\<not> formulaFalse F (elements M)\" and \"vars (elements M) \\<supseteq> Vbl\"\n  shows \"model (elements M) F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model (elements M) F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. model (elements M) F0", "from \\<open>InvariantConsistent M\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent M", "have \"consistent (elements M)\""], ["proof (prove)\nusing this:\n  InvariantConsistent M\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "."], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "moreover"], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "from \\<open>InvariantVarsF F F0 Vbl\\<close>"], ["proof (chain)\npicking this:\n  InvariantVarsF F F0 Vbl", "have \"vars F \\<subseteq> vars F0 \\<union> Vbl\""], ["proof (prove)\nusing this:\n  InvariantVarsF F F0 Vbl\n\ngoal (1 subgoal):\n 1. vars F \\<subseteq> vars F0 \\<union> Vbl", "unfolding InvariantVarsF_def"], ["proof (prove)\nusing this:\n  vars F \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars F \\<subseteq> vars F0 \\<union> Vbl", "."], ["proof (state)\nthis:\n  vars F \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "with \\<open>vars F0 \\<subseteq> Vbl\\<close>"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> Vbl\n  vars F \\<subseteq> vars F0 \\<union> Vbl", "have \"vars F \\<subseteq> Vbl\""], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> Vbl\n  vars F \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars F \\<subseteq> Vbl", "by auto"], ["proof (state)\nthis:\n  vars F \\<subseteq> Vbl\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "with \\<open>vars (elements M) \\<supseteq> Vbl\\<close>"], ["proof (chain)\npicking this:\n  Vbl \\<subseteq> vars (elements M)\n  vars F \\<subseteq> Vbl", "have \"vars F \\<subseteq> vars (elements M)\""], ["proof (prove)\nusing this:\n  Vbl \\<subseteq> vars (elements M)\n  vars F \\<subseteq> Vbl\n\ngoal (1 subgoal):\n 1. vars F \\<subseteq> vars (elements M)", "by simp"], ["proof (state)\nthis:\n  vars F \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "hence \"formulaTrue F (elements M) \\<or> formulaFalse F (elements M)\""], ["proof (prove)\nusing this:\n  vars F \\<subseteq> vars (elements M)\n\ngoal (1 subgoal):\n 1. formulaTrue F (elements M) \\<or> formulaFalse F (elements M)", "by (simp add:totalValuationForFormulaDefinesItsValue)"], ["proof (state)\nthis:\n  formulaTrue F (elements M) \\<or> formulaFalse F (elements M)\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "with \\<open>\\<not> formulaFalse F (elements M)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> formulaFalse F (elements M)\n  formulaTrue F (elements M) \\<or> formulaFalse F (elements M)", "have \"formulaTrue F (elements M)\""], ["proof (prove)\nusing this:\n  \\<not> formulaFalse F (elements M)\n  formulaTrue F (elements M) \\<or> formulaFalse F (elements M)\n\ngoal (1 subgoal):\n 1. formulaTrue F (elements M)", "by simp"], ["proof (state)\nthis:\n  formulaTrue F (elements M)\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "ultimately"], ["proof (chain)\npicking this:\n  consistent (elements M)\n  formulaTrue F (elements M)", "have \"model (elements M) F\""], ["proof (prove)\nusing this:\n  consistent (elements M)\n  formulaTrue F (elements M)\n\ngoal (1 subgoal):\n 1. model (elements M) F", "by simp"], ["proof (state)\nthis:\n  model (elements M) F\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "with \\<open>InvariantEquivalent F0 F\\<close>"], ["proof (chain)\npicking this:\n  InvariantEquivalent F0 F\n  model (elements M) F", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 F\n  model (elements M) F\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "unfolding InvariantEquivalent_def"], ["proof (prove)\nusing this:\n  equivalentFormulae F0 F\n  model (elements M) F\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation F0 = model valuation F\n  model (elements M) F\n\ngoal (1 subgoal):\n 1. model (elements M) F0", "by auto"], ["proof (state)\nthis:\n  model (elements M) F0\n\ngoal:\nNo subgoals!", "qed"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Different characterizations of backjumping\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>In this section, different characterization of applicability of\nbackjumping will be given.\\<close>"], ["", "text\\<open>The clause satisfies the @{term \"Unique Implication Point (UIP)\"} condition\n  if the level of all its literals is stricly lower then the level of its last asserted literal\\<close>"], ["", "definition\n\"isUIP l c M ==\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c)(elements M)  \\<and> \n  (\\<forall> l'. l' el c \\<and> l' \\<noteq> l \\<longrightarrow> elementLevel (opposite l') M < elementLevel (opposite l) M)\""], ["", "text\\<open>@{term \"Backjump level\"} is a nonegative integer such that it is stricly \n  lower than the level of the last asserted literal of a clause, and greater or \n  equal then levels of all its other literals.\\<close>"], ["", "definition\n\"isBackjumpLevel level l c M == \n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c)(elements M)  \\<and> \n  0 \\<le> level \\<and> level < elementLevel (opposite l) M \\<and>\n  (\\<forall> l'. l' el c \\<and> l' \\<noteq> l \\<longrightarrow> elementLevel (opposite l') M \\<le> level)\""], ["", "lemma lastAssertedLiteralHasHighestElementLevel: \n  fixes literal :: Literal and clause :: Clause and M :: LiteralTrail\n  assumes \"isLastAssertedLiteral literal clause (elements M)\" and \"uniq (elements M)\"\n  shows \"\\<forall> l'. l' el clause \\<and> l' el elements M \\<longrightarrow> elementLevel l' M <= elementLevel literal M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "fix l' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "assume \"l' el clause\" \"l' el elements M\""], ["proof (state)\nthis:\n  l' el clause\n  l' el elements M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "hence \"elementLevel l' M <= elementLevel literal M\""], ["proof (prove)\nusing this:\n  l' el clause\n  l' el elements M\n\ngoal (1 subgoal):\n 1. elementLevel l' M \\<le> elementLevel literal M", "proof (cases \"l' = literal\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' = literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M\n 2. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "case True"], ["proof (state)\nthis:\n  l' = literal\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' = literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M\n 2. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "thus ?thesis"], ["proof (prove)\nusing this:\n  l' = literal\n\ngoal (1 subgoal):\n 1. elementLevel l' M \\<le> elementLevel literal M", "by simp"], ["proof (state)\nthis:\n  elementLevel l' M \\<le> elementLevel literal M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "case False"], ["proof (state)\nthis:\n  l' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "from \\<open>isLastAssertedLiteral literal clause (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral literal clause (elements M)", "have \"literalTrue literal (elements M)\" \n        \"\\<forall> l. l el clause \\<and> l \\<noteq> literal \\<longrightarrow> \\<not>  precedes literal l (elements M)\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral literal clause (elements M)\n\ngoal (1 subgoal):\n 1. literalTrue literal (elements M) &&&\n    \\<forall>l.\n       l el clause \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (elements M)", "by (auto simp add:isLastAssertedLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal (elements M)\n  \\<forall>l.\n     l el clause \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (elements M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "with \\<open>l' el clause\\<close> False"], ["proof (chain)\npicking this:\n  l' el clause\n  l' \\<noteq> literal\n  literalTrue literal (elements M)\n  \\<forall>l.\n     l el clause \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (elements M)", "have \"\\<not> precedes literal l' (elements M)\""], ["proof (prove)\nusing this:\n  l' el clause\n  l' \\<noteq> literal\n  literalTrue literal (elements M)\n  \\<forall>l.\n     l el clause \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> precedes literal l' (elements M)", "by simp"], ["proof (state)\nthis:\n  \\<not> precedes literal l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "with False \\<open>l' el (elements M)\\<close> \\<open>literalTrue literal (elements M)\\<close>"], ["proof (chain)\npicking this:\n  l' \\<noteq> literal\n  l' el elements M\n  literalTrue literal (elements M)\n  \\<not> precedes literal l' (elements M)", "have \"precedes l' literal (elements M)\""], ["proof (prove)\nusing this:\n  l' \\<noteq> literal\n  l' el elements M\n  literalTrue literal (elements M)\n  \\<not> precedes literal l' (elements M)\n\ngoal (1 subgoal):\n 1. precedes l' literal (elements M)", "using precedesTotalOrder [of \"l'\"  \"elements M\" \"literal\"]"], ["proof (prove)\nusing this:\n  l' \\<noteq> literal\n  l' el elements M\n  literalTrue literal (elements M)\n  \\<not> precedes literal l' (elements M)\n  \\<lbrakk>l' \\<in> set (elements M);\n   literal \\<in> set (elements M)\\<rbrakk>\n  \\<Longrightarrow> l' = literal \\<or>\n                    precedes l' literal (elements M) \\<or>\n                    precedes literal l' (elements M)\n\ngoal (1 subgoal):\n 1. precedes l' literal (elements M)", "by simp"], ["proof (state)\nthis:\n  precedes l' literal (elements M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' el clause; l' el elements M; l' \\<noteq> literal\\<rbrakk>\n    \\<Longrightarrow> elementLevel l' M \\<le> elementLevel literal M", "with \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  precedes l' literal (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  precedes l' literal (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel l' M \\<le> elementLevel literal M", "using elementLevelPrecedesLeq [of \"l'\" \"literal\" \"M\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  precedes l' literal (elements M)\n  precedes l' literal (elements M) \\<Longrightarrow>\n  elementLevel l' M \\<le> elementLevel literal M\n\ngoal (1 subgoal):\n 1. elementLevel l' M \\<le> elementLevel literal M", "by auto"], ["proof (state)\nthis:\n  elementLevel l' M \\<le> elementLevel literal M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elementLevel l' M \\<le> elementLevel literal M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l'2 el clause; ?l'2 el elements M\\<rbrakk>\n  \\<Longrightarrow> elementLevel ?l'2 M \\<le> elementLevel literal M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el clause; ?l'2 el elements M\\<rbrakk>\n  \\<Longrightarrow> elementLevel ?l'2 M \\<le> elementLevel literal M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el clause \\<and> l' el elements M \\<longrightarrow>\n       elementLevel l' M \\<le> elementLevel literal M", "by simp"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el clause \\<and> l' el elements M \\<longrightarrow>\n     elementLevel l' M \\<le> elementLevel literal M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>When backjump clause contains only a single literal, then the backjump level is 0.\\<close>"], ["", "(* additional assumption: (elementLevel l M) > 0 *)"], ["", "lemma backjumpLevelZero:\n  fixes M :: LiteralTrail and C :: Clause and l :: Literal\n  assumes \n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\" and\n  \"elementLevel (opposite l) M > 0\" and\n  \"set C = {l}\"\n  shows\n  \"isBackjumpLevel 0 l C M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isBackjumpLevel 0 l C M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isBackjumpLevel 0 l C M", "have \"\\<forall> l'. l' el C \\<and> l' \\<noteq> l \\<longrightarrow> elementLevel (opposite l') M \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "fix l'::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "assume \"l' el C \\<and> l' \\<noteq> l\""], ["proof (state)\nthis:\n  l' el C \\<and> l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "hence \"False\""], ["proof (prove)\nusing this:\n  l' el C \\<and> l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. False", "using \\<open>set C = {l}\\<close>"], ["proof (prove)\nusing this:\n  l' el C \\<and> l' \\<noteq> l\n  set C = {l}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "}"], ["proof (state)\nthis:\n  ?l'2 el C \\<and> ?l'2 \\<noteq> l \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l'2 el C \\<and> ?l'2 \\<noteq> l \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> 0\n\ngoal (1 subgoal):\n 1. isBackjumpLevel 0 l C M", "with \\<open>elementLevel (opposite l) M > 0\\<close>\n    \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  0 < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> 0\n\ngoal (1 subgoal):\n 1. isBackjumpLevel 0 l C M", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  0 < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> 0\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList C)\n     (elements M) \\<and>\n    0 \\<le> 0 \\<and>\n    0 < elementLevel (opposite l) M \\<and>\n    (\\<forall>l'.\n        l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n        elementLevel (opposite l') M \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  isBackjumpLevel 0 l C M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>When backjump clause contains more than one literal, then the level of the \n  second last asserted literal can be taken as a backjump level.\\<close>"], ["", "lemma backjumpLevelLastLast:\n  fixes M :: LiteralTrail and C :: Clause and l :: Literal\n  assumes \n  \"isUIP l C M\" and\n  \"uniq (elements M)\" and\n  \"clauseFalse C (elements M)\" and\n  \"isLastAssertedLiteral (opposite ll) (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\"\n  shows\n  \"isBackjumpLevel (elementLevel (opposite ll) M) l C M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "from \\<open>isUIP l C M\\<close>"], ["proof (chain)\npicking this:\n  isUIP l C M", "have \"isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\""], ["proof (prove)\nusing this:\n  isUIP l C M\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)", "unfolding isUIP_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C)\n   (elements M) \\<and>\n  (\\<forall>l'.\n      l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') M < elementLevel (opposite l) M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "from \\<open>isLastAssertedLiteral (opposite ll) (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral (opposite ll)\n   (removeAll (opposite l) (oppositeLiteralList C)) (elements M)", "have \"literalTrue (opposite ll) (elements M)\" \"(opposite ll) el (removeAll (opposite l) (oppositeLiteralList C))\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite ll)\n   (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\n\ngoal (1 subgoal):\n 1. literalTrue (opposite ll) (elements M) &&&\n    opposite ll el removeAll (opposite l) (oppositeLiteralList C)", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  opposite ll el removeAll (opposite l) (oppositeLiteralList C) \\<and>\n  literalTrue (opposite ll) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll (opposite l) (oppositeLiteralList C) \\<and>\n      literal' \\<noteq> opposite ll \\<longrightarrow>\n      \\<not> precedes (opposite ll) literal' (elements M))\n\ngoal (1 subgoal):\n 1. literalTrue (opposite ll) (elements M) &&&\n    opposite ll el removeAll (opposite l) (oppositeLiteralList C)", "by auto"], ["proof (state)\nthis:\n  literalTrue (opposite ll) (elements M)\n  opposite ll el removeAll (opposite l) (oppositeLiteralList C)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "have \"\\<forall> l'. l' el (oppositeLiteralList C) \\<longrightarrow> literalTrue l' (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "fix l'::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "assume \"l' el oppositeLiteralList C\""], ["proof (state)\nthis:\n  l' el oppositeLiteralList C\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "hence \"opposite l' el C\""], ["proof (prove)\nusing this:\n  l' el oppositeLiteralList C\n\ngoal (1 subgoal):\n 1. opposite l' el C", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"opposite l'\" \"C\"]"], ["proof (prove)\nusing this:\n  l' el oppositeLiteralList C\n  opposite l' el C = opposite (opposite l') el oppositeLiteralList C\n\ngoal (1 subgoal):\n 1. opposite l' el C", "by simp"], ["proof (state)\nthis:\n  opposite l' el C\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "with \\<open>clauseFalse C (elements M)\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse C (elements M)\n  opposite l' el C", "have \"literalTrue l' (elements M)\""], ["proof (prove)\nusing this:\n  clauseFalse C (elements M)\n  opposite l' el C\n\ngoal (1 subgoal):\n 1. literalTrue l' (elements M)", "by (auto simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalTrue l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "}"], ["proof (state)\nthis:\n  ?l'2 el oppositeLiteralList C \\<Longrightarrow>\n  literalTrue ?l'2 (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l'2 el oppositeLiteralList C \\<Longrightarrow>\n  literalTrue ?l'2 (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el oppositeLiteralList C \\<longrightarrow>\n       literalTrue l' (elements M)", "by simp"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el oppositeLiteralList C \\<longrightarrow>\n     literalTrue l' (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el oppositeLiteralList C \\<longrightarrow>\n     literalTrue l' (elements M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "have \"\\<forall> l'. l' el C \\<and> l' \\<noteq> l  \\<longrightarrow> \n    elementLevel (opposite l') M <= elementLevel (opposite ll) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "fix l' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "assume \"l' el C \\<and> l' \\<noteq> l\""], ["proof (state)\nthis:\n  l' el C \\<and> l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "hence \"(opposite l') el (oppositeLiteralList C)\" \"opposite l' \\<noteq> opposite l\""], ["proof (prove)\nusing this:\n  l' el C \\<and> l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. opposite l' el oppositeLiteralList C &&& opposite l' \\<noteq> opposite l", "using literalElListIffOppositeLiteralElOppositeLiteralList"], ["proof (prove)\nusing this:\n  l' el C \\<and> l' \\<noteq> l\n  ?literal el ?literalList =\n  opposite ?literal el oppositeLiteralList ?literalList\n\ngoal (1 subgoal):\n 1. opposite l' el oppositeLiteralList C &&& opposite l' \\<noteq> opposite l", "by auto"], ["proof (state)\nthis:\n  opposite l' el oppositeLiteralList C\n  opposite l' \\<noteq> opposite l\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "hence \"opposite l' el (removeAll (opposite l) (oppositeLiteralList C))\""], ["proof (prove)\nusing this:\n  opposite l' el oppositeLiteralList C\n  opposite l' \\<noteq> opposite l\n\ngoal (1 subgoal):\n 1. opposite l' el removeAll (opposite l) (oppositeLiteralList C)", "by simp"], ["proof (state)\nthis:\n  opposite l' el removeAll (opposite l) (oppositeLiteralList C)\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "from \\<open>opposite l' el (oppositeLiteralList C)\\<close>\n        \\<open>\\<forall> l'. l' el (oppositeLiteralList C) \\<longrightarrow> literalTrue l' (elements M)\\<close>"], ["proof (chain)\npicking this:\n  opposite l' el oppositeLiteralList C\n  \\<forall>l'.\n     l' el oppositeLiteralList C \\<longrightarrow>\n     literalTrue l' (elements M)", "have \"literalTrue (opposite l') (elements M)\""], ["proof (prove)\nusing this:\n  opposite l' el oppositeLiteralList C\n  \\<forall>l'.\n     l' el oppositeLiteralList C \\<longrightarrow>\n     literalTrue l' (elements M)\n\ngoal (1 subgoal):\n 1. literalTrue (opposite l') (elements M)", "by simp"], ["proof (state)\nthis:\n  literalTrue (opposite l') (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "with \\<open>opposite l' el (removeAll (opposite l) (oppositeLiteralList C))\\<close> \n        \\<open>isLastAssertedLiteral (opposite ll) (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\\<close>\n        \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  opposite l' el removeAll (opposite l) (oppositeLiteralList C)\n  isLastAssertedLiteral (opposite ll)\n   (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\n  uniq (elements M)\n  literalTrue (opposite l') (elements M)", "have \"elementLevel (opposite l') M <= elementLevel (opposite ll) M\""], ["proof (prove)\nusing this:\n  opposite l' el removeAll (opposite l) (oppositeLiteralList C)\n  isLastAssertedLiteral (opposite ll)\n   (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\n  uniq (elements M)\n  literalTrue (opposite l') (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "using lastAssertedLiteralHasHighestElementLevel[of \"opposite ll\" \"removeAll (opposite l) (oppositeLiteralList C)\" \"M\"]"], ["proof (prove)\nusing this:\n  opposite l' el removeAll (opposite l) (oppositeLiteralList C)\n  isLastAssertedLiteral (opposite ll)\n   (removeAll (opposite l) (oppositeLiteralList C)) (elements M)\n  uniq (elements M)\n  literalTrue (opposite l') (elements M)\n  \\<lbrakk>isLastAssertedLiteral (opposite ll)\n            (removeAll (opposite l) (oppositeLiteralList C)) (elements M);\n   uniq (elements M)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>l'.\n                       l' el\n                       removeAll (opposite l) (oppositeLiteralList C) \\<and>\n                       l' el elements M \\<longrightarrow>\n                       elementLevel l' M \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "by auto"], ["proof (state)\nthis:\n  elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "}"], ["proof (state)\nthis:\n  ?l'2 el C \\<and> ?l'2 \\<noteq> l \\<Longrightarrow>\n  elementLevel (opposite ?l'2) M \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l'2 el C \\<and> ?l'2 \\<noteq> l \\<Longrightarrow>\n  elementLevel (opposite ?l'2) M \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M", "by simp"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "moreover"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "from \\<open>literalTrue (opposite ll) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  literalTrue (opposite ll) (elements M)", "have \"elementLevel (opposite ll) M \\<ge> 0\""], ["proof (prove)\nusing this:\n  literalTrue (opposite ll) (elements M)\n\ngoal (1 subgoal):\n 1. 0 \\<le> elementLevel (opposite ll) M", "by simp"], ["proof (state)\nthis:\n  0 \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "moreover"], ["proof (state)\nthis:\n  0 \\<le> elementLevel (opposite ll) M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "from \\<open>(opposite ll) el (removeAll (opposite l) (oppositeLiteralList C))\\<close>"], ["proof (chain)\npicking this:\n  opposite ll el removeAll (opposite l) (oppositeLiteralList C)", "have \"ll el C\" and \"ll \\<noteq> l\""], ["proof (prove)\nusing this:\n  opposite ll el removeAll (opposite l) (oppositeLiteralList C)\n\ngoal (1 subgoal):\n 1. ll el C &&& ll \\<noteq> l", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"ll\" \"C\"]"], ["proof (prove)\nusing this:\n  opposite ll el removeAll (opposite l) (oppositeLiteralList C)\n  ll el C = opposite ll el oppositeLiteralList C\n\ngoal (1 subgoal):\n 1. ll el C &&& ll \\<noteq> l", "by auto"], ["proof (state)\nthis:\n  ll el C\n  ll \\<noteq> l\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "from \\<open>isUIP l C M\\<close>"], ["proof (chain)\npicking this:\n  isUIP l C M", "have \"\\<forall> l'. l' el C \\<and> l' \\<noteq> l \\<longrightarrow> elementLevel (opposite l') M < elementLevel (opposite l) M\""], ["proof (prove)\nusing this:\n  isUIP l C M\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M < elementLevel (opposite l) M", "unfolding isUIP_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C)\n   (elements M) \\<and>\n  (\\<forall>l'.\n      l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') M < elementLevel (opposite l) M)\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M < elementLevel (opposite l) M", "by simp"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "with \\<open>ll el C\\<close> \\<open>ll \\<noteq> l\\<close>"], ["proof (chain)\npicking this:\n  ll el C\n  ll \\<noteq> l\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M < elementLevel (opposite l) M", "have \"elementLevel (opposite ll) M < elementLevel (opposite l) M\""], ["proof (prove)\nusing this:\n  ll el C\n  ll \\<noteq> l\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. elementLevel (opposite ll) M < elementLevel (opposite l) M", "by simp"], ["proof (state)\nthis:\n  elementLevel (opposite ll) M < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n  0 \\<le> elementLevel (opposite ll) M\n  elementLevel (opposite ll) M < elementLevel (opposite l) M", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n  0 \\<le> elementLevel (opposite ll) M\n  elementLevel (opposite ll) M < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "using \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n  0 \\<le> elementLevel (opposite ll) M\n  elementLevel (opposite ll) M < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel (opposite ll) M) l C M", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  \\<forall>l'.\n     l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M\n  0 \\<le> elementLevel (opposite ll) M\n  elementLevel (opposite ll) M < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList C) (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList C)\n     (elements M) \\<and>\n    0 \\<le> elementLevel (opposite ll) M \\<and>\n    elementLevel (opposite ll) M < elementLevel (opposite l) M \\<and>\n    (\\<forall>l'.\n        l' el C \\<and> l' \\<noteq> l \\<longrightarrow>\n        elementLevel (opposite l') M \\<le> elementLevel (opposite ll) M)", "by simp"], ["proof (state)\nthis:\n  isBackjumpLevel (elementLevel (opposite ll) M) l C M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>if UIP is reached then there exists correct backjump level.\\<close>"], ["", "(* additional assumption: (elementLevel l M) > 0 *)"], ["", "lemma isUIPExistsBackjumpLevel:\n  fixes M :: LiteralTrail and c :: Clause and l :: Literal\n  assumes \n  \"clauseFalse c (elements M)\" and\n  \"isUIP l c M\" and\n  \"uniq (elements M)\" and\n  \"elementLevel (opposite l) M > 0\"\n  shows\n  \"\\<exists> level. (isBackjumpLevel level l c M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "from \\<open>isUIP l c M\\<close>"], ["proof (chain)\npicking this:\n  isUIP l c M", "have \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\""], ["proof (prove)\nusing this:\n  isUIP l c M\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "unfolding isUIP_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n   (elements M) \\<and>\n  (\\<forall>l'.\n      l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') M < elementLevel (opposite l) M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "proof (cases \"set c = {l}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set c = {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M\n 2. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "case True"], ["proof (state)\nthis:\n  set c = {l}\n\ngoal (2 subgoals):\n 1. set c = {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M\n 2. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "with \\<open>elementLevel (opposite l) M > 0\\<close> \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  0 < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n  set c = {l}", "have \"isBackjumpLevel 0 l c M\""], ["proof (prove)\nusing this:\n  0 < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n  set c = {l}\n\ngoal (1 subgoal):\n 1. isBackjumpLevel 0 l c M", "using backjumpLevelZero[of \"l\" \"c\" \"M\"]"], ["proof (prove)\nusing this:\n  0 < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n  set c = {l}\n  \\<lbrakk>isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n            (elements M);\n   0 < elementLevel (opposite l) M; set c = {l}\\<rbrakk>\n  \\<Longrightarrow> isBackjumpLevel 0 l c M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel 0 l c M", "by auto"], ["proof (state)\nthis:\n  isBackjumpLevel 0 l c M\n\ngoal (2 subgoals):\n 1. set c = {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M\n 2. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "thus ?thesis"], ["proof (prove)\nusing this:\n  isBackjumpLevel 0 l c M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "by auto"], ["proof (state)\nthis:\n  \\<exists>level. isBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "case False"], ["proof (state)\nthis:\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "have \"\\<exists> literal. isLastAssertedLiteral literal (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "let ?ll = \"getLastAssertedLiteral (oppositeLiteralList (removeAll l c)) (elements M)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "from \\<open>clauseFalse c (elements M)\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse c (elements M)", "have \"clauseFalse (removeAll l c) (elements M)\""], ["proof (prove)\nusing this:\n  clauseFalse c (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll l c) (elements M)", "by (simp add:clauseFalseRemove)"], ["proof (state)\nthis:\n  clauseFalse (removeAll l c) (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "moreover"], ["proof (state)\nthis:\n  clauseFalse (removeAll l c) (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "have \"removeAll l c \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "have \"(set c) \\<subseteq> {l} \\<union> set (removeAll l c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set c \\<subseteq> {l} \\<union> set (removeAll l c)", "by auto"], ["proof (state)\nthis:\n  set c \\<subseteq> {l} \\<union> set (removeAll l c)\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "from \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "have \"(opposite l) el oppositeLiteralList c\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. opposite l el oppositeLiteralList c", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c \\<and>\n  literalTrue (opposite l) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList c \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements M))\n\ngoal (1 subgoal):\n 1. opposite l el oppositeLiteralList c", "by simp"], ["proof (state)\nthis:\n  opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "hence \"l el c\""], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. l el c", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"c\"]"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c\n  l el c = opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. l el c", "by simp"], ["proof (state)\nthis:\n  l el c\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "hence \"l \\<in> set c\""], ["proof (prove)\nusing this:\n  l el c\n\ngoal (1 subgoal):\n 1. l \\<in> set c", "by simp"], ["proof (state)\nthis:\n  l \\<in> set c\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "{"], ["proof (state)\nthis:\n  l \\<in> set c\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "hence \"set (removeAll l c) = {}\""], ["proof (prove)\nusing this:\n  \\<not> removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (removeAll l c) = {}", "by simp"], ["proof (state)\nthis:\n  set (removeAll l c) = {}\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "with \\<open>(set c) \\<subseteq> {l} \\<union> set (removeAll l c)\\<close>"], ["proof (chain)\npicking this:\n  set c \\<subseteq> {l} \\<union> set (removeAll l c)\n  set (removeAll l c) = {}", "have \"set c \\<subseteq> {l}\""], ["proof (prove)\nusing this:\n  set c \\<subseteq> {l} \\<union> set (removeAll l c)\n  set (removeAll l c) = {}\n\ngoal (1 subgoal):\n 1. set c \\<subseteq> {l}", "by simp"], ["proof (state)\nthis:\n  set c \\<subseteq> {l}\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "with \\<open>l \\<in> set c\\<close>"], ["proof (chain)\npicking this:\n  l \\<in> set c\n  set c \\<subseteq> {l}", "have \"set c = {l}\""], ["proof (prove)\nusing this:\n  l \\<in> set c\n  set c \\<subseteq> {l}\n\ngoal (1 subgoal):\n 1. set c = {l}", "by auto"], ["proof (state)\nthis:\n  set c = {l}\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "with False"], ["proof (chain)\npicking this:\n  set c \\<noteq> {l}\n  set c = {l}", "have \"False\""], ["proof (prove)\nusing this:\n  set c \\<noteq> {l}\n  set c = {l}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "}"], ["proof (state)\nthis:\n  \\<not> removeAll l c \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> removeAll l c \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  removeAll l c \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "ultimately"], ["proof (chain)\npicking this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []", "have \"isLastAssertedLiteral ?ll (oppositeLiteralList (removeAll l c)) (elements M)\""], ["proof (prove)\nusing this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n       (elements M))\n     (oppositeLiteralList (removeAll l c)) (elements M)", "using \\<open>uniq (elements M)\\<close>"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n       (elements M))\n     (oppositeLiteralList (removeAll l c)) (elements M)", "using getLastAssertedLiteralCharacterization [of \"removeAll l c\" \"elements M\"]"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []\n  uniq (elements M)\n  \\<lbrakk>clauseFalse (removeAll l c) (elements M);\n   removeAll l c \\<noteq> []; uniq (elements M)\\<rbrakk>\n  \\<Longrightarrow> isLastAssertedLiteral\n                     (getLastAssertedLiteral\n                       (oppositeLiteralList (removeAll l c)) (elements M))\n                     (oppositeLiteralList (removeAll l c)) (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n       (elements M))\n     (oppositeLiteralList (removeAll l c)) (elements M)", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n     (elements M))\n   (oppositeLiteralList (removeAll l c)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "hence \"isLastAssertedLiteral ?ll (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n     (elements M))\n   (oppositeLiteralList (removeAll l c)) (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n       (elements M))\n     (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "using oppositeLiteralListRemove[of \"l\" \"c\"]"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n     (elements M))\n   (oppositeLiteralList (removeAll l c)) (elements M)\n  oppositeLiteralList (removeAll l c) =\n  removeAll (opposite l) (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n       (elements M))\n     (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n     (elements M))\n   (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (removeAll l c))\n     (elements M))\n   (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       isLastAssertedLiteral literal\n        (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "by auto"], ["proof (state)\nthis:\n  \\<exists>literal.\n     isLastAssertedLiteral literal\n      (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>literal.\n     isLastAssertedLiteral literal\n      (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "then"], ["proof (chain)\npicking this:\n  \\<exists>literal.\n     isLastAssertedLiteral literal\n      (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "obtain ll::Literal where \"isLastAssertedLiteral ll (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\""], ["proof (prove)\nusing this:\n  \\<exists>literal.\n     isLastAssertedLiteral literal\n      (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        isLastAssertedLiteral ll\n         (removeAll (opposite l) (oppositeLiteralList c))\n         (elements M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isLastAssertedLiteral ll (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M)\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "with \\<open>uniq (elements M)\\<close> \\<open>clauseFalse c (elements M)\\<close> \\<open>isUIP l c M\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  clauseFalse c (elements M)\n  isUIP l c M\n  isLastAssertedLiteral ll (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M)", "have \"isBackjumpLevel (elementLevel ll M) l c M\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  clauseFalse c (elements M)\n  isUIP l c M\n  isLastAssertedLiteral ll (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel ll M) l c M", "using backjumpLevelLastLast[of \"l\" \"c\" \"M\" \"opposite ll\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  clauseFalse c (elements M)\n  isUIP l c M\n  isLastAssertedLiteral ll (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M)\n  \\<lbrakk>isUIP l c M; uniq (elements M); clauseFalse c (elements M);\n   isLastAssertedLiteral (opposite (opposite ll))\n    (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\\<rbrakk>\n  \\<Longrightarrow> isBackjumpLevel\n                     (elementLevel (opposite (opposite ll)) M) l c M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel (elementLevel ll M) l c M", "by auto"], ["proof (state)\nthis:\n  isBackjumpLevel (elementLevel ll M) l c M\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<exists>level. isBackjumpLevel level l c M", "thus ?thesis"], ["proof (prove)\nusing this:\n  isBackjumpLevel (elementLevel ll M) l c M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "by auto"], ["proof (state)\nthis:\n  \\<exists>level. isBackjumpLevel level l c M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>level. isBackjumpLevel level l c M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Backjump level condition ensures that the backjump clause is\nunit in the prefix to backjump level.\\<close>"], ["", "lemma isBackjumpLevelEnsuresIsUnitInPrefix: \n  fixes M :: LiteralTrail and conflictFlag :: bool and c :: Clause and l :: Literal\n  assumes \"consistent (elements M)\" and \"uniq (elements M)\" and\n  \"clauseFalse c (elements M)\" and \"isBackjumpLevel level l c M\"\n  shows \"isUnitClause c l (elements (prefixToLevel level M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "from \\<open>isBackjumpLevel level l c M\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel level l c M", "have \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c)(elements M)\"\n    \"0 \\<le> level\"   \"level < elementLevel (opposite l) M\" and\n    *: \"\\<forall> l'. l' el c \\<and> l' \\<noteq> l \\<longrightarrow> elementLevel (opposite l') M \\<le> level\""], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n      (elements M) &&&\n     0 \\<le> level &&& level < elementLevel (opposite l) M) &&&\n    \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n   (elements M) \\<and>\n  0 \\<le> level \\<and>\n  level < elementLevel (opposite l) M \\<and>\n  (\\<forall>l'.\n      l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') M \\<le> level)\n\ngoal (1 subgoal):\n 1. (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n      (elements M) &&&\n     0 \\<le> level &&& level < elementLevel (opposite l) M) &&&\n    \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level", "by auto"], ["proof (state)\nthis:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n  0 \\<le> level\n  level < elementLevel (opposite l) M\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> level\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "from \\<open>isLastAssertedLiteral (opposite l)(oppositeLiteralList c) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "have \"l el c\" \"literalTrue (opposite l) (elements M)\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. l el c &&& literalTrue (opposite l) (elements M)", "using isLastAssertedCharacterization [of \"opposite l\" \"c\" \"elements M\"]"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n   (elements M) \\<Longrightarrow>\n  opposite (opposite l) el c\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n   (elements M) \\<Longrightarrow>\n  literalTrue (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. l el c &&& literalTrue (opposite l) (elements M)", "by auto"], ["proof (state)\nthis:\n  l el c\n  literalTrue (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "have \"\\<not> literalFalse l (elements (prefixToLevel level M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level M))", "using \\<open>level < elementLevel (opposite l) M\\<close> \\<open>0 <= level\\<close> \\<open>uniq (elements M)\\<close>"], ["proof (prove)\nusing this:\n  level < elementLevel (opposite l) M\n  0 \\<le> level\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level M))", "by (simp add: literalNotInEarlierLevelsThanItsLevel)"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "moreover"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "have \"\\<not> literalTrue l (elements (prefixToLevel level M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements (prefixToLevel level M))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements (prefixToLevel level M))", "from \\<open>consistent (elements M)\\<close> \\<open>literalTrue (opposite l) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements M)\n  literalTrue (opposite l) (elements M)", "have \"\\<not> literalFalse (opposite l) (elements M)\""], ["proof (prove)\nusing this:\n  consistent (elements M)\n  literalTrue (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse (opposite l) (elements M)", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> literalFalse (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements (prefixToLevel level M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> literalFalse (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements (prefixToLevel level M))", "using isPrefixPrefixToLevel[of \"level\" \"M\"]\n        prefixElementsAreTrailElements[of \"prefixToLevel level M\" \"M\"]"], ["proof (prove)\nusing this:\n  \\<not> literalFalse (opposite l) (elements M)\n  isPrefix (prefixToLevel level M) M\n  isPrefix (prefixToLevel level M) M \\<Longrightarrow>\n  set (elements (prefixToLevel level M)) \\<subseteq> set (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements (prefixToLevel level M))", "unfolding prefixToLevel_def"], ["proof (prove)\nusing this:\n  \\<not> literalFalse (opposite l) (elements M)\n  isPrefix (prefixToLevel_aux M level 0) M\n  isPrefix (prefixToLevel_aux M level 0) M \\<Longrightarrow>\n  set (elements (prefixToLevel_aux M level 0)) \\<subseteq> set (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements (prefixToLevel_aux M level 0))", "by auto"], ["proof (state)\nthis:\n  \\<not> literalTrue l (elements (prefixToLevel level M))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> literalTrue l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "moreover"], ["proof (state)\nthis:\n  \\<not> literalTrue l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "have \"\\<forall> l'. l' el c \\<and> l' \\<noteq> l \\<longrightarrow> literalFalse l' (elements (prefixToLevel level M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "fix l' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "assume \"l' el c\" \"l' \\<noteq> l\""], ["proof (state)\nthis:\n  l' el c\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "from \\<open>l' el c\\<close> \\<open>clauseFalse c (elements M)\\<close>"], ["proof (chain)\npicking this:\n  l' el c\n  clauseFalse c (elements M)", "have \"literalFalse l' (elements M)\""], ["proof (prove)\nusing this:\n  l' el c\n  clauseFalse c (elements M)\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements M)", "by (simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "have \"literalFalse l' (elements (prefixToLevel level M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literalFalse l' (elements (prefixToLevel level M))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. literalFalse l' (elements (prefixToLevel level M))", "from \\<open>l' el c\\<close> \\<open>l' \\<noteq> l\\<close>"], ["proof (chain)\npicking this:\n  l' el c\n  l' \\<noteq> l", "have \"elementLevel (opposite l') M <= level\""], ["proof (prove)\nusing this:\n  l' el c\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M \\<le> level", "using *"], ["proof (prove)\nusing this:\n  l' el c\n  l' \\<noteq> l\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     elementLevel (opposite l') M \\<le> level\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M \\<le> level", "by auto"], ["proof (state)\nthis:\n  elementLevel (opposite l') M \\<le> level\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements (prefixToLevel level M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  elementLevel (opposite l') M \\<le> level\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements (prefixToLevel level M))", "using \\<open>literalFalse l' (elements M)\\<close> \n          \\<open>0 <= level\\<close>\n          elementLevelLtLevelImpliesMemberPrefixToLevel[of \"opposite l'\" \"M\" \"level\"]"], ["proof (prove)\nusing this:\n  elementLevel (opposite l') M \\<le> level\n  literalFalse l' (elements M)\n  0 \\<le> level\n  \\<lbrakk>opposite l' \\<in> set (elements M);\n   elementLevel (opposite l') M \\<le> level\\<rbrakk>\n  \\<Longrightarrow> opposite l' \\<in> set (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements (prefixToLevel level M))", "by simp"], ["proof (state)\nthis:\n  literalFalse l' (elements (prefixToLevel level M))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literalFalse l' (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> literalFalse ?l'2 (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> literalFalse ?l'2 (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       literalFalse l' (elements (prefixToLevel level M))", "by auto"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     literalFalse l' (elements (prefixToLevel level M))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     literalFalse l' (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n  \\<not> literalTrue l (elements (prefixToLevel level M))\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     literalFalse l' (elements (prefixToLevel level M))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n  \\<not> literalTrue l (elements (prefixToLevel level M))\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     literalFalse l' (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "using \\<open>l el c\\<close>"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n  \\<not> literalTrue l (elements (prefixToLevel level M))\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     literalFalse l' (elements (prefixToLevel level M))\n  l el c\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n  \\<not> literalTrue l (elements (prefixToLevel level M))\n  \\<forall>l'.\n     l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n     literalFalse l' (elements (prefixToLevel level M))\n  l el c\n\ngoal (1 subgoal):\n 1. l el c \\<and>\n    \\<not> literalTrue l (elements (prefixToLevel level M)) \\<and>\n    \\<not> literalFalse l (elements (prefixToLevel level M)) \\<and>\n    (\\<forall>literal.\n        literal el c \\<and> literal \\<noteq> l \\<longrightarrow>\n        literalFalse literal (elements (prefixToLevel level M)))", "by simp"], ["proof (state)\nthis:\n  isUnitClause c l (elements (prefixToLevel level M))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Backjump level is minimal if there is no smaller level which\n       satisfies the backjump level condition. The following definition gives\n       operative characterization of this notion.\\<close>"], ["", "definition \n\"isMinimalBackjumpLevel level l c M ==\n     isBackjumpLevel level l c M \\<and> \n     (if set c \\<noteq> {l} then \n         (\\<exists> ll. ll el c \\<and> elementLevel (opposite ll) M = level) \n      else \n         level = 0\n     )\""], ["", "lemma isMinimalBackjumpLevelCharacterization:\nassumes\n\"isUIP l c M\"\n\"clauseFalse c (elements M)\"\n\"uniq (elements M)\"\nshows\n\"isMinimalBackjumpLevel level l c M = \n  (isBackjumpLevel level l c M \\<and> \n   (\\<forall> level'. level' < level \\<longrightarrow> \\<not> isBackjumpLevel level' l c M))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M =\n    (isBackjumpLevel level l c M \\<and>\n     (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. isMinimalBackjumpLevel level l c M \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n 2. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level.\n        \\<not> isBackjumpLevel level' l c M) \\<Longrightarrow>\n    isMinimalBackjumpLevel level l c M", "assume \"?lhs\""], ["proof (state)\nthis:\n  isMinimalBackjumpLevel level l c M\n\ngoal (2 subgoals):\n 1. isMinimalBackjumpLevel level l c M \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n 2. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level.\n        \\<not> isBackjumpLevel level' l c M) \\<Longrightarrow>\n    isMinimalBackjumpLevel level l c M", "show \"?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "proof (cases \"set c = {l}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set c = {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n 2. set c \\<noteq> {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "case True"], ["proof (state)\nthis:\n  set c = {l}\n\ngoal (2 subgoals):\n 1. set c = {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n 2. set c \\<noteq> {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  set c = {l}\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  set c = {l}\n  isMinimalBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  set c = {l}\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "by auto"], ["proof (state)\nthis:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "case False"], ["proof (state)\nthis:\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "with \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  isMinimalBackjumpLevel level l c M\n  set c \\<noteq> {l}", "obtain ll \n      where \"ll el c\" \"elementLevel (opposite ll) M = level\" \"isBackjumpLevel level l c M\""], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        \\<lbrakk>ll el c; elementLevel (opposite ll) M = level;\n         isBackjumpLevel level l c M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        \\<lbrakk>ll el c; elementLevel (opposite ll) M = level;\n         isBackjumpLevel level l c M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ll el c\n  elementLevel (opposite ll) M = level\n  isBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "have \"l \\<noteq> ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "using \\<open>isMinimalBackjumpLevel level l c M\\<close>"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "using \\<open>elementLevel (opposite ll) M = level\\<close>"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n    (elements M) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> ll\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "using \\<open>isBackjumpLevel level l c M\\<close>"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "using \\<open>elementLevel (opposite ll) M = level\\<close>"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "using \\<open>ll el c\\<close> \\<open>l \\<noteq> ll\\<close>"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M\n  elementLevel (opposite ll) M = level\n  ll el c\n  l \\<noteq> ll\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n   (elements M) \\<and>\n  0 \\<le> level \\<and>\n  level < elementLevel (opposite l) M \\<and>\n  (\\<forall>l'.\n      l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') M \\<le> level)\n  elementLevel (opposite ll) M = level\n  ll el c\n  l \\<noteq> ll\n\ngoal (1 subgoal):\n 1. (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n      (elements M) \\<and>\n     0 \\<le> level \\<and>\n     level < elementLevel (opposite l) M \\<and>\n     (\\<forall>l'.\n         l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n         elementLevel (opposite l') M \\<le> level)) \\<and>\n    (\\<forall>level'<level.\n        \\<not> (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n                 (elements M) \\<and>\n                0 \\<le> level' \\<and>\n                level' < elementLevel (opposite l) M \\<and>\n                (\\<forall>l'.\n                    l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n                    elementLevel (opposite l') M \\<le> level')))", "by force"], ["proof (state)\nthis:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level.\n        \\<not> isBackjumpLevel level' l c M) \\<Longrightarrow>\n    isMinimalBackjumpLevel level l c M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level.\n        \\<not> isBackjumpLevel level' l c M) \\<Longrightarrow>\n    isMinimalBackjumpLevel level l c M", "assume \"?rhs\""], ["proof (state)\nthis:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (\\<forall>level'<level.\n        \\<not> isBackjumpLevel level' l c M) \\<Longrightarrow>\n    isMinimalBackjumpLevel level l c M", "show \"?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "proof (cases \"set c = {l}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set c = {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M\n 2. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "case True"], ["proof (state)\nthis:\n  set c = {l}\n\ngoal (2 subgoals):\n 1. set c = {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M\n 2. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "thus ?thesis"], ["proof (prove)\nusing this:\n  set c = {l}\n\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "using \\<open>?rhs\\<close>"], ["proof (prove)\nusing this:\n  set c = {l}\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "using backjumpLevelZero[of \"l\" \"c\" \"M\"]"], ["proof (prove)\nusing this:\n  set c = {l}\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n  \\<lbrakk>isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n            (elements M);\n   0 < elementLevel (opposite l) M; set c = {l}\\<rbrakk>\n  \\<Longrightarrow> isBackjumpLevel 0 l c M\n\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  set c = {l}\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n  \\<lbrakk>isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n            (elements M);\n   0 < elementLevel (opposite l) M; set c = {l}\\<rbrakk>\n  \\<Longrightarrow> isBackjumpLevel 0 l c M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (if set c \\<noteq> {l}\n     then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n     else level = 0)", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  set c = {l}\n  (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n    (elements M) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (\\<forall>level'<level.\n      \\<not> (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n               (elements M) \\<and>\n              0 \\<le> level' \\<and>\n              level' < elementLevel (opposite l) M \\<and>\n              (\\<forall>l'.\n                  l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n                  elementLevel (opposite l') M \\<le> level')))\n  \\<lbrakk>isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n            (elements M);\n   0 < elementLevel (opposite l) M; set c = {l}\\<rbrakk>\n  \\<Longrightarrow> isLastAssertedLiteral (opposite l)\n                     (oppositeLiteralList c) (elements M) \\<and>\n                    0 \\<le> 0 \\<and>\n                    0 < elementLevel (opposite l) M \\<and>\n                    (\\<forall>l'.\n                        l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n                        elementLevel (opposite l') M \\<le> 0)\n\ngoal (1 subgoal):\n 1. (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n      (elements M) \\<and>\n     0 \\<le> level \\<and>\n     level < elementLevel (opposite l) M \\<and>\n     (\\<forall>l'.\n         l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n         elementLevel (opposite l') M \\<le> level)) \\<and>\n    (if set c \\<noteq> {l}\n     then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n     else level = 0)", "by auto"], ["proof (state)\nthis:\n  isMinimalBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "case False"], ["proof (state)\nthis:\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "from \\<open>?rhs\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "have \"l el c\""], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. l el c", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n    (elements M) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (\\<forall>level'<level.\n      \\<not> (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n               (elements M) \\<and>\n              0 \\<le> level' \\<and>\n              level' < elementLevel (opposite l) M \\<and>\n              (\\<forall>l'.\n                  l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n                  elementLevel (opposite l') M \\<le> level')))\n\ngoal (1 subgoal):\n 1. l el c", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"c\"]"], ["proof (prove)\nusing this:\n  (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n    (elements M) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (\\<forall>level'<level.\n      \\<not> (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n               (elements M) \\<and>\n              0 \\<le> level' \\<and>\n              level' < elementLevel (opposite l) M \\<and>\n              (\\<forall>l'.\n                  l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n                  elementLevel (opposite l') M \\<le> level')))\n  l el c = opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. l el c", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  ((opposite l el oppositeLiteralList c \\<and>\n    literalTrue (opposite l) (elements M) \\<and>\n    (\\<forall>literal'.\n        literal' el oppositeLiteralList c \\<and>\n        literal' \\<noteq> opposite l \\<longrightarrow>\n        \\<not> precedes (opposite l) literal' (elements M))) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (\\<forall>level'<level.\n      \\<not> ((opposite l el oppositeLiteralList c \\<and>\n               literalTrue (opposite l) (elements M) \\<and>\n               (\\<forall>literal'.\n                   literal' el oppositeLiteralList c \\<and>\n                   literal' \\<noteq> opposite l \\<longrightarrow>\n                   \\<not> precedes (opposite l) literal'\n                           (elements M))) \\<and>\n              0 \\<le> level' \\<and>\n              level' < elementLevel (opposite l) M \\<and>\n              (\\<forall>l'.\n                  l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n                  elementLevel (opposite l') M \\<le> level')))\n  l el c = opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. l el c", "by simp"], ["proof (state)\nthis:\n  l el c\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "let ?oll = \"getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "have \"clauseFalse (removeAll l c) (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll l c) (elements M)", "using \\<open>clauseFalse c (elements M)\\<close>"], ["proof (prove)\nusing this:\n  clauseFalse c (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll l c) (elements M)", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  clauseFalse (removeAll l c) (elements M)\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "moreover"], ["proof (state)\nthis:\n  clauseFalse (removeAll l c) (elements M)\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "have \"removeAll l c \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "hence \"set (removeAll l c) = {}\""], ["proof (prove)\nusing this:\n  \\<not> removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (removeAll l c) = {}", "by simp"], ["proof (state)\nthis:\n  set (removeAll l c) = {}\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "hence \"set c \\<subseteq> {l}\""], ["proof (prove)\nusing this:\n  set (removeAll l c) = {}\n\ngoal (1 subgoal):\n 1. set c \\<subseteq> {l}", "by simp"], ["proof (state)\nthis:\n  set c \\<subseteq> {l}\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "hence False"], ["proof (prove)\nusing this:\n  set c \\<subseteq> {l}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>set c \\<noteq> {l}\\<close>"], ["proof (prove)\nusing this:\n  set c \\<subseteq> {l}\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>l el c\\<close>"], ["proof (prove)\nusing this:\n  set c \\<subseteq> {l}\n  set c \\<noteq> {l}\n  l el c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "}"], ["proof (state)\nthis:\n  \\<not> removeAll l c \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> removeAll l c \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. removeAll l c \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  removeAll l c \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "ultimately"], ["proof (chain)\npicking this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []", "have \"isLastAssertedLiteral ?oll (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\""], ["proof (prove)\nusing this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "using \\<open>uniq (elements M)\\<close>"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "using getLastAssertedLiteralCharacterization[of \"removeAll l c\" \"elements M\"]"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []\n  uniq (elements M)\n  \\<lbrakk>clauseFalse (removeAll l c) (elements M);\n   removeAll l c \\<noteq> []; uniq (elements M)\\<rbrakk>\n  \\<Longrightarrow> isLastAssertedLiteral\n                     (getLastAssertedLiteral\n                       (oppositeLiteralList (removeAll l c)) (elements M))\n                     (oppositeLiteralList (removeAll l c)) (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "using oppositeLiteralListRemove[of \"l\" \"c\"]"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll l c) (elements M)\n  removeAll l c \\<noteq> []\n  uniq (elements M)\n  \\<lbrakk>clauseFalse (removeAll l c) (elements M);\n   removeAll l c \\<noteq> []; uniq (elements M)\\<rbrakk>\n  \\<Longrightarrow> isLastAssertedLiteral\n                     (getLastAssertedLiteral\n                       (oppositeLiteralList (removeAll l c)) (elements M))\n                     (oppositeLiteralList (removeAll l c)) (elements M)\n  oppositeLiteralList (removeAll l c) =\n  removeAll (opposite l) (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     (removeAll (opposite l) (oppositeLiteralList c)) (elements M)", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "hence  \"isBackjumpLevel  (elementLevel ?oll M) l c M\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel\n     (elementLevel\n       (getLastAssertedLiteral\n         (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n       M)\n     l c M", "using assms"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n  isUIP l c M\n  clauseFalse c (elements M)\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. isBackjumpLevel\n     (elementLevel\n       (getLastAssertedLiteral\n         (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n       M)\n     l c M", "using backjumpLevelLastLast[of \"l\" \"c\" \"M\" \"opposite ?oll\"]"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n  isUIP l c M\n  clauseFalse c (elements M)\n  uniq (elements M)\n  \\<lbrakk>isUIP l c M; uniq (elements M); clauseFalse c (elements M);\n   isLastAssertedLiteral\n    (opposite\n      (opposite\n        (getLastAssertedLiteral\n          (removeAll (opposite l) (oppositeLiteralList c)) (elements M))))\n    (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\\<rbrakk>\n  \\<Longrightarrow> isBackjumpLevel\n                     (elementLevel\n                       (opposite\n                         (opposite\n                           (getLastAssertedLiteral\n                             (removeAll (opposite l)\n                               (oppositeLiteralList c))\n                             (elements M))))\n                       M)\n                     l c M\n\ngoal (1 subgoal):\n 1. isBackjumpLevel\n     (elementLevel\n       (getLastAssertedLiteral\n         (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n       M)\n     l c M", "by auto"], ["proof (state)\nthis:\n  isBackjumpLevel\n   (elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M)\n   l c M\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "have \"?oll el (removeAll (opposite l) (oppositeLiteralList c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M) el\n    removeAll (opposite l) (oppositeLiteralList c)", "using \\<open>isLastAssertedLiteral ?oll (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\\<close>"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   (removeAll (opposite l) (oppositeLiteralList c)) (elements M)\n\ngoal (1 subgoal):\n 1. getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M) el\n    removeAll (opposite l) (oppositeLiteralList c)", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) el\n  removeAll (opposite l) (oppositeLiteralList c) \\<and>\n  literalTrue\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll (opposite l) (oppositeLiteralList c) \\<and>\n      literal' \\<noteq>\n      getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c))\n       (elements M) \\<longrightarrow>\n      \\<not> precedes\n              (getLastAssertedLiteral\n                (removeAll (opposite l) (oppositeLiteralList c))\n                (elements M))\n              literal' (elements M))\n\ngoal (1 subgoal):\n 1. getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M) el\n    removeAll (opposite l) (oppositeLiteralList c)", "by simp"], ["proof (state)\nthis:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) el\n  removeAll (opposite l) (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "hence \"?oll el (oppositeLiteralList c)\" \"?oll \\<noteq> opposite l\""], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) el\n  removeAll (opposite l) (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M) el\n    oppositeLiteralList c &&&\n    getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M) \\<noteq>\n    opposite l", "by auto"], ["proof (state)\nthis:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) el\n  oppositeLiteralList c\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) \\<noteq>\n  opposite l\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "hence \"opposite ?oll el c\""], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) el\n  oppositeLiteralList c\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) \\<noteq>\n  opposite l\n\ngoal (1 subgoal):\n 1. opposite\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M)) el\n    c", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"?oll\" \"oppositeLiteralList c\"]"], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) el\n  oppositeLiteralList c\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) \\<noteq>\n  opposite l\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) el\n  oppositeLiteralList c =\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  oppositeLiteralList (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. opposite\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M)) el\n    c", "by simp"], ["proof (state)\nthis:\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "from \\<open>?oll \\<noteq> opposite l\\<close>"], ["proof (chain)\npicking this:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) \\<noteq>\n  opposite l", "have \"opposite ?oll \\<noteq> l\""], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) \\<noteq>\n  opposite l\n\ngoal (1 subgoal):\n 1. opposite\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c))\n       (elements M)) \\<noteq>\n    l", "using oppositeSymmetry[of \"?oll\" \"l\"]"], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n   (elements M) \\<noteq>\n  opposite l\n  (opposite\n    (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n      (elements M)) =\n   l) =\n  (opposite l =\n   getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n    (elements M))\n\ngoal (1 subgoal):\n 1. opposite\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c))\n       (elements M)) \\<noteq>\n    l", "by simp"], ["proof (state)\nthis:\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) \\<noteq>\n  l\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "have \"elementLevel ?oll M \\<ge> level\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "assume \"elementLevel ?oll M < level\""], ["proof (state)\nthis:\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  < level\n\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "hence \"\\<not> isBackjumpLevel  (elementLevel ?oll M) l c M\""], ["proof (prove)\nusing this:\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  < level\n\ngoal (1 subgoal):\n 1. \\<not> isBackjumpLevel\n            (elementLevel\n              (getLastAssertedLiteral\n                (removeAll (opposite l) (oppositeLiteralList c))\n                (elements M))\n              M)\n            l c M", "using \\<open>?rhs\\<close>"], ["proof (prove)\nusing this:\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  < level\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. \\<not> isBackjumpLevel\n            (elementLevel\n              (getLastAssertedLiteral\n                (removeAll (opposite l) (oppositeLiteralList c))\n                (elements M))\n              M)\n            l c M", "by simp"], ["proof (state)\nthis:\n  \\<not> isBackjumpLevel\n          (elementLevel\n            (getLastAssertedLiteral\n              (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n            M)\n          l c M\n\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "with \\<open>isBackjumpLevel  (elementLevel ?oll M) l c M\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel\n   (elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M)\n   l c M\n  \\<not> isBackjumpLevel\n          (elementLevel\n            (getLastAssertedLiteral\n              (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n            M)\n          l c M", "have False"], ["proof (prove)\nusing this:\n  isBackjumpLevel\n   (elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M)\n   l c M\n  \\<not> isBackjumpLevel\n          (elementLevel\n            (getLastAssertedLiteral\n              (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n            M)\n          l c M\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "}"], ["proof (state)\nthis:\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  < level \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "thus ?thesis"], ["proof (prove)\nusing this:\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  < level \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. level\n    \\<le> elementLevel\n           (getLastAssertedLiteral\n             (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n           M", "by force"], ["proof (state)\nthis:\n  level\n  \\<le> elementLevel\n         (getLastAssertedLiteral\n           (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n         M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  level\n  \\<le> elementLevel\n         (getLastAssertedLiteral\n           (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n         M\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "moreover"], ["proof (state)\nthis:\n  level\n  \\<le> elementLevel\n         (getLastAssertedLiteral\n           (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n         M\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "from \\<open>?rhs\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)", "have \"elementLevel ?oll M \\<le> level\""], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M\n    \\<le> level", "using \\<open>opposite ?oll el c\\<close>"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n\ngoal (1 subgoal):\n 1. elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M\n    \\<le> level", "using \\<open>opposite ?oll \\<noteq> l\\<close>"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) \\<noteq>\n  l\n\ngoal (1 subgoal):\n 1. elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M\n    \\<le> level", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n    (elements M) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (\\<forall>level'<level.\n      \\<not> (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n               (elements M) \\<and>\n              0 \\<le> level' \\<and>\n              level' < elementLevel (opposite l) M \\<and>\n              (\\<forall>l'.\n                  l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n                  elementLevel (opposite l') M \\<le> level')))\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) \\<noteq>\n  l\n\ngoal (1 subgoal):\n 1. elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M\n    \\<le> level", "by auto"], ["proof (state)\nthis:\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  \\<le> level\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "ultimately"], ["proof (chain)\npicking this:\n  level\n  \\<le> elementLevel\n         (getLastAssertedLiteral\n           (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n         M\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  \\<le> level", "have \"elementLevel ?oll M = level\""], ["proof (prove)\nusing this:\n  level\n  \\<le> elementLevel\n         (getLastAssertedLiteral\n           (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n         M\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M\n  \\<le> level\n\ngoal (1 subgoal):\n 1. elementLevel\n     (getLastAssertedLiteral\n       (removeAll (opposite l) (oppositeLiteralList c)) (elements M))\n     M =\n    level", "by simp"], ["proof (state)\nthis:\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M =\n  level\n\ngoal (1 subgoal):\n 1. set c \\<noteq> {l} \\<Longrightarrow> isMinimalBackjumpLevel level l c M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "using \\<open>opposite ?oll el c\\<close>"], ["proof (prove)\nusing this:\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "using \\<open>elementLevel ?oll M = level\\<close>"], ["proof (prove)\nusing this:\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M =\n  level\n\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "using \\<open>?rhs\\<close>"], ["proof (prove)\nusing this:\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M =\n  level\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "using \\<open>set c \\<noteq> {l}\\<close>"], ["proof (prove)\nusing this:\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M =\n  level\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. isMinimalBackjumpLevel level l c M", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  opposite\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M)) el\n  c\n  elementLevel\n   (getLastAssertedLiteral (removeAll (opposite l) (oppositeLiteralList c))\n     (elements M))\n   M =\n  level\n  isBackjumpLevel level l c M \\<and>\n  (\\<forall>level'<level. \\<not> isBackjumpLevel level' l c M)\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. isBackjumpLevel level l c M \\<and>\n    (if set c \\<noteq> {l}\n     then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n     else level = 0)", "by (auto simp del: set_removeAll)"], ["proof (state)\nthis:\n  isMinimalBackjumpLevel level l c M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isMinimalBackjumpLevel level l c M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isMinimalBackjumpLevelEnsuresIsNotUnitBeforePrefix:\n  fixes M :: LiteralTrail and conflictFlag :: bool and c :: Clause and l :: Literal\n  assumes \"consistent (elements M)\" and \"uniq (elements M)\" and \n  \"clauseFalse c (elements M)\" \"isMinimalBackjumpLevel level l c M\" and\n  \"level' < level\"\n  shows \"\\<not> (\\<exists> l'. isUnitClause c l' (elements (prefixToLevel level' M)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "from \\<open>isMinimalBackjumpLevel level l c M\\<close>"], ["proof (chain)\npicking this:\n  isMinimalBackjumpLevel level l c M", "have \"isUnitClause c l (elements (prefixToLevel level M))\""], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "using assms"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n  consistent (elements M)\n  uniq (elements M)\n  clauseFalse c (elements M)\n  isMinimalBackjumpLevel level l c M\n  level' < level\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "using isBackjumpLevelEnsuresIsUnitInPrefix[of \"M\" \"c\" \"level\" \"l\"]"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n  consistent (elements M)\n  uniq (elements M)\n  clauseFalse c (elements M)\n  isMinimalBackjumpLevel level l c M\n  level' < level\n  \\<lbrakk>consistent (elements M); uniq (elements M);\n   clauseFalse c (elements M); isBackjumpLevel level l c M\\<rbrakk>\n  \\<Longrightarrow> isUnitClause c l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  consistent (elements M)\n  uniq (elements M)\n  clauseFalse c (elements M)\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  level' < level\n  \\<lbrakk>consistent (elements M); uniq (elements M);\n   clauseFalse c (elements M); isBackjumpLevel level l c M\\<rbrakk>\n  \\<Longrightarrow> isUnitClause c l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. isUnitClause c l (elements (prefixToLevel level M))", "by simp"], ["proof (state)\nthis:\n  isUnitClause c l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "hence \"\\<not> literalFalse l (elements (prefixToLevel level M))\""], ["proof (prove)\nusing this:\n  isUnitClause c l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level M))", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  l el c \\<and>\n  \\<not> literalTrue l (elements (prefixToLevel level M)) \\<and>\n  \\<not> literalFalse l (elements (prefixToLevel level M)) \\<and>\n  (\\<forall>literal.\n      literal el c \\<and> literal \\<noteq> l \\<longrightarrow>\n      literalFalse literal (elements (prefixToLevel level M)))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level M))", "by auto"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "hence \"\\<not> literalFalse  l (elements M) \\<or> elementLevel (opposite l) M > level\""], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements M) \\<or>\n    level < elementLevel (opposite l) M", "using elementLevelLtLevelImpliesMemberPrefixToLevel[of \"l\" \"M\" \"level\"]"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n  \\<lbrakk>l \\<in> set (elements M); elementLevel l M \\<le> level\\<rbrakk>\n  \\<Longrightarrow> l \\<in> set (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements M) \\<or>\n    level < elementLevel (opposite l) M", "using elementLevelLtLevelImpliesMemberPrefixToLevel[of \"opposite l\" \"M\" \"level\"]"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements (prefixToLevel level M))\n  \\<lbrakk>l \\<in> set (elements M); elementLevel l M \\<le> level\\<rbrakk>\n  \\<Longrightarrow> l \\<in> set (elements (prefixToLevel level M))\n  \\<lbrakk>opposite l \\<in> set (elements M);\n   elementLevel (opposite l) M \\<le> level\\<rbrakk>\n  \\<Longrightarrow> opposite l \\<in> set (elements (prefixToLevel level M))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements M) \\<or>\n    level < elementLevel (opposite l) M", "by (force)+"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements M) \\<or>\n  level < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "have \"\\<not> literalFalse l (elements (prefixToLevel level' M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "proof (cases \"\\<not> literalFalse l (elements M)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))\n 2. \\<not> \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))", "case True"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements M)\n\ngoal (2 subgoals):\n 1. \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))\n 2. \\<not> \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "using prefixIsSubset[of \"elements (prefixToLevel level' M)\" \"elements M\"]"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements M)\n  isPrefix (elements (prefixToLevel level' M))\n   (elements M) \\<Longrightarrow>\n  set (elements (prefixToLevel level' M)) \\<subseteq> set (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "using isPrefixPrefixToLevel[of \"level'\" \"M\"]"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements M)\n  isPrefix (elements (prefixToLevel level' M))\n   (elements M) \\<Longrightarrow>\n  set (elements (prefixToLevel level' M)) \\<subseteq> set (elements M)\n  isPrefix (prefixToLevel level' M) M\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "using isPrefixElements[of \"prefixToLevel level' M\" \"M\"]"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements M)\n  isPrefix (elements (prefixToLevel level' M))\n   (elements M) \\<Longrightarrow>\n  set (elements (prefixToLevel level' M)) \\<subseteq> set (elements M)\n  isPrefix (prefixToLevel level' M) M\n  isPrefix (prefixToLevel level' M) M \\<Longrightarrow>\n  isPrefix (elements (prefixToLevel level' M)) (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "by auto"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))", "case False"], ["proof (state)\nthis:\n  \\<not> \\<not> literalFalse l (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))", "with \\<open>\\<not> literalFalse l (elements M) \\<or> elementLevel (opposite l) M > level\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalFalse l (elements M) \\<or>\n  level < elementLevel (opposite l) M\n  \\<not> \\<not> literalFalse l (elements M)", "have \"level < elementLevel (opposite l) M\""], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements M) \\<or>\n  level < elementLevel (opposite l) M\n  \\<not> \\<not> literalFalse l (elements M)\n\ngoal (1 subgoal):\n 1. level < elementLevel (opposite l) M", "by simp"], ["proof (state)\nthis:\n  level < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> literalFalse l (elements M) \\<Longrightarrow>\n    \\<not> literalFalse l (elements (prefixToLevel level' M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  level < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "using prefixToLevelElementsElementLevel[of \"opposite l\" \"level'\" \"M\"]"], ["proof (prove)\nusing this:\n  level < elementLevel (opposite l) M\n  opposite l \\<in> set (elements (prefixToLevel level' M)) \\<Longrightarrow>\n  elementLevel (opposite l) M \\<le> level'\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "using \\<open>level' < level\\<close>"], ["proof (prove)\nusing this:\n  level < elementLevel (opposite l) M\n  opposite l \\<in> set (elements (prefixToLevel level' M)) \\<Longrightarrow>\n  elementLevel (opposite l) M \\<le> level'\n  level' < level\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l (elements (prefixToLevel level' M))", "by auto"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements (prefixToLevel level' M))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> literalFalse l (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "proof (cases \"set c \\<noteq> {l}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "case True"], ["proof (state)\nthis:\n  set c \\<noteq> {l}\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "from \\<open>isMinimalBackjumpLevel level l c M\\<close>"], ["proof (chain)\npicking this:\n  isMinimalBackjumpLevel level l c M", "obtain ll \n      where \"ll el c\" \"elementLevel (opposite ll) M = level\""], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        \\<lbrakk>ll el c; elementLevel (opposite ll) M = level\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>set c \\<noteq> {l}\\<close>"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        \\<lbrakk>ll el c; elementLevel (opposite ll) M = level\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. (\\<And>ll.\n        \\<lbrakk>ll el c; elementLevel (opposite ll) M = level\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ll el c\n  elementLevel (opposite ll) M = level\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "hence \"\\<not> literalFalse ll (elements (prefixToLevel level' M))\""], ["proof (prove)\nusing this:\n  ll el c\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse ll (elements (prefixToLevel level' M))", "using literalNotInEarlierLevelsThanItsLevel[of \"level'\" \"opposite ll\" \"M\"]"], ["proof (prove)\nusing this:\n  ll el c\n  elementLevel (opposite ll) M = level\n  level' < elementLevel (opposite ll) M \\<Longrightarrow>\n  opposite ll \\<notin> set (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse ll (elements (prefixToLevel level' M))", "using \\<open>level' < level\\<close>"], ["proof (prove)\nusing this:\n  ll el c\n  elementLevel (opposite ll) M = level\n  level' < elementLevel (opposite ll) M \\<Longrightarrow>\n  opposite ll \\<notin> set (elements (prefixToLevel level' M))\n  level' < level\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse ll (elements (prefixToLevel level' M))", "by simp"], ["proof (state)\nthis:\n  \\<not> literalFalse ll (elements (prefixToLevel level' M))\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "have \"l \\<noteq> ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "using \\<open>isMinimalBackjumpLevel level l c M\\<close>"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "using \\<open>elementLevel (opposite ll) M = level\\<close>"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n    (elements M) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  elementLevel (opposite ll) M = level\n\ngoal (1 subgoal):\n 1. l \\<noteq> ll", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> ll\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "{"], ["proof (state)\nthis:\n  l \\<noteq> ll\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<nexists>l'.\n             isUnitClause c l' (elements (prefixToLevel level' M)))\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<nexists>l'.\n             isUnitClause c l' (elements (prefixToLevel level' M)))", "obtain l'\n        where \"isUnitClause c l' (elements (prefixToLevel level' M))\""], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>l'.\n             isUnitClause c l' (elements (prefixToLevel level' M)))\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        isUnitClause c l'\n         (elements (prefixToLevel level' M)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isUnitClause c l' (elements (prefixToLevel level' M))\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "have \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"l = l'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = l' \\<Longrightarrow> False\n 2. l \\<noteq> l' \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  l = l'\n\ngoal (2 subgoals):\n 1. l = l' \\<Longrightarrow> False\n 2. l \\<noteq> l' \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = l'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>l \\<noteq> ll\\<close> \\<open>ll el c\\<close>"], ["proof (prove)\nusing this:\n  l = l'\n  l \\<noteq> ll\n  ll el c\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> literalFalse ll (elements (prefixToLevel level' M))\\<close>"], ["proof (prove)\nusing this:\n  l = l'\n  l \\<noteq> ll\n  ll el c\n  \\<not> literalFalse ll (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. False", "using \\<open>isUnitClause c l' (elements (prefixToLevel level' M))\\<close>"], ["proof (prove)\nusing this:\n  l = l'\n  l \\<noteq> ll\n  ll el c\n  \\<not> literalFalse ll (elements (prefixToLevel level' M))\n  isUnitClause c l' (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. False", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  l = l'\n  l \\<noteq> ll\n  ll el c\n  \\<not> literalFalse ll (elements (prefixToLevel level' M))\n  l' el c \\<and>\n  \\<not> literalTrue l' (elements (prefixToLevel level' M)) \\<and>\n  \\<not> literalFalse l' (elements (prefixToLevel level' M)) \\<and>\n  (\\<forall>literal.\n      literal el c \\<and> literal \\<noteq> l' \\<longrightarrow>\n      literalFalse literal (elements (prefixToLevel level' M)))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. l \\<noteq> l' \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> l' \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  l \\<noteq> l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> l' \\<Longrightarrow> False", "have \"l el c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l el c", "using \\<open>isMinimalBackjumpLevel level l c M\\<close>"], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n\ngoal (1 subgoal):\n 1. l el c", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n\ngoal (1 subgoal):\n 1. l el c", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  (isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n    (elements M) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n\ngoal (1 subgoal):\n 1. l el c", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  ((opposite l el oppositeLiteralList c \\<and>\n    literalTrue (opposite l) (elements M) \\<and>\n    (\\<forall>literal'.\n        literal' el oppositeLiteralList c \\<and>\n        literal' \\<noteq> opposite l \\<longrightarrow>\n        \\<not> precedes (opposite l) literal' (elements M))) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n\ngoal (1 subgoal):\n 1. l el c", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"c\"]"], ["proof (prove)\nusing this:\n  ((opposite l el oppositeLiteralList c \\<and>\n    literalTrue (opposite l) (elements M) \\<and>\n    (\\<forall>literal'.\n        literal' el oppositeLiteralList c \\<and>\n        literal' \\<noteq> opposite l \\<longrightarrow>\n        \\<not> precedes (opposite l) literal' (elements M))) \\<and>\n   0 \\<le> level \\<and>\n   level < elementLevel (opposite l) M \\<and>\n   (\\<forall>l'.\n       l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n       elementLevel (opposite l') M \\<le> level)) \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  l el c = opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. l el c", "by simp"], ["proof (state)\nthis:\n  l el c\n\ngoal (1 subgoal):\n 1. l \\<noteq> l' \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  l el c\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  l el c\n  l \\<noteq> l'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> literalFalse l (elements (prefixToLevel level' M))\\<close>"], ["proof (prove)\nusing this:\n  l el c\n  l \\<noteq> l'\n  \\<not> literalFalse l (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. False", "using \\<open>isUnitClause c l' (elements (prefixToLevel level' M))\\<close>"], ["proof (prove)\nusing this:\n  l el c\n  l \\<noteq> l'\n  \\<not> literalFalse l (elements (prefixToLevel level' M))\n  isUnitClause c l' (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. False", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  l el c\n  l \\<noteq> l'\n  \\<not> literalFalse l (elements (prefixToLevel level' M))\n  l' el c \\<and>\n  \\<not> literalTrue l' (elements (prefixToLevel level' M)) \\<and>\n  \\<not> literalFalse l' (elements (prefixToLevel level' M)) \\<and>\n  (\\<forall>literal.\n      literal el c \\<and> literal \\<noteq> l' \\<longrightarrow>\n      literalFalse literal (elements (prefixToLevel level' M)))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "}"], ["proof (state)\nthis:\n  \\<not> (\\<nexists>l'.\n             isUnitClause c l'\n              (elements (prefixToLevel level' M))) \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n 2. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>l'.\n             isUnitClause c l'\n              (elements (prefixToLevel level' M))) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "by auto"], ["proof (state)\nthis:\n  \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n\ngoal (1 subgoal):\n 1. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "case False"], ["proof (state)\nthis:\n  \\<not> set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "with \\<open>isMinimalBackjumpLevel level l c M\\<close>"], ["proof (chain)\npicking this:\n  isMinimalBackjumpLevel level l c M\n  \\<not> set c \\<noteq> {l}", "have \"level = 0\""], ["proof (prove)\nusing this:\n  isMinimalBackjumpLevel level l c M\n  \\<not> set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. level = 0", "unfolding isMinimalBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isBackjumpLevel level l c M \\<and>\n  (if set c \\<noteq> {l}\n   then \\<exists>ll. ll el c \\<and> elementLevel (opposite ll) M = level\n   else level = 0)\n  \\<not> set c \\<noteq> {l}\n\ngoal (1 subgoal):\n 1. level = 0", "by simp"], ["proof (state)\nthis:\n  level = 0\n\ngoal (1 subgoal):\n 1. \\<not> set c \\<noteq> {l} \\<Longrightarrow>\n    \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "with \\<open>level' < level\\<close>"], ["proof (chain)\npicking this:\n  level' < level\n  level = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  level' < level\n  level = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))", "by simp"], ["proof (state)\nthis:\n  \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>l'. isUnitClause c l' (elements (prefixToLevel level' M))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>If all literals in a clause are decision literals, then UIP is reached.\\<close>"], ["", "lemma allDecisionsThenUIP:\n  fixes M :: LiteralTrail and c:: Clause\n  assumes \"(uniq (elements M))\" and\n  \"\\<forall> l'. l' el c \\<longrightarrow> (opposite l') el (decisions M)\"\n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\"\n  shows \"isUIP l c M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isUIP l c M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isUIP l c M", "from \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "have \"l el c\" \"(opposite l) el (elements M)\"\n    and *: \"\\<forall>l'. l' el (oppositeLiteralList c) \\<and> l' \\<noteq> opposite l \\<longrightarrow> \\<not> precedes (opposite l) l' (elements M)\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. (l el c &&& opposite l el elements M) &&&\n    \\<forall>l'.\n       l' el oppositeLiteralList c \\<and>\n       l' \\<noteq> opposite l \\<longrightarrow>\n       \\<not> precedes (opposite l) l' (elements M)", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c \\<and>\n  literalTrue (opposite l) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList c \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements M))\n\ngoal (1 subgoal):\n 1. (l el c &&& opposite l el elements M) &&&\n    \\<forall>l'.\n       l' el oppositeLiteralList c \\<and>\n       l' \\<noteq> opposite l \\<longrightarrow>\n       \\<not> precedes (opposite l) l' (elements M)", "using \"literalElListIffOppositeLiteralElOppositeLiteralList\""], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c \\<and>\n  literalTrue (opposite l) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList c \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements M))\n  ?literal el ?literalList =\n  opposite ?literal el oppositeLiteralList ?literalList\n\ngoal (1 subgoal):\n 1. (l el c &&& opposite l el elements M) &&&\n    \\<forall>l'.\n       l' el oppositeLiteralList c \\<and>\n       l' \\<noteq> opposite l \\<longrightarrow>\n       \\<not> precedes (opposite l) l' (elements M)", "by auto"], ["proof (state)\nthis:\n  l el c\n  opposite l el elements M\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "with \\<open>\\<forall> l'. l' el c \\<longrightarrow> (opposite l') el (decisions M)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  l el c\n  opposite l el elements M\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)", "have \"(opposite l) el (decisions M)\""], ["proof (prove)\nusing this:\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  l el c\n  opposite l el elements M\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n\ngoal (1 subgoal):\n 1. opposite l el decisions M", "by simp"], ["proof (state)\nthis:\n  opposite l el decisions M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "{"], ["proof (state)\nthis:\n  opposite l el decisions M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "fix l' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. isUIP l c M", "assume \"l' el c\" \"l' \\<noteq> l\""], ["proof (state)\nthis:\n  l' el c\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. isUIP l c M", "hence \"opposite l' el (oppositeLiteralList c)\" and \"opposite l' \\<noteq> opposite l\""], ["proof (prove)\nusing this:\n  l' el c\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. opposite l' el oppositeLiteralList c &&& opposite l' \\<noteq> opposite l", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l'\" \"c\"]"], ["proof (prove)\nusing this:\n  l' el c\n  l' \\<noteq> l\n  l' el c = opposite l' el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. opposite l' el oppositeLiteralList c &&& opposite l' \\<noteq> opposite l", "by auto"], ["proof (state)\nthis:\n  opposite l' el oppositeLiteralList c\n  opposite l' \\<noteq> opposite l\n\ngoal (1 subgoal):\n 1. isUIP l c M", "with *"], ["proof (chain)\npicking this:\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n  opposite l' el oppositeLiteralList c\n  opposite l' \\<noteq> opposite l", "have \"\\<not> precedes (opposite l) (opposite l') (elements M)\""], ["proof (prove)\nusing this:\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n  opposite l' el oppositeLiteralList c\n  opposite l' \\<noteq> opposite l\n\ngoal (1 subgoal):\n 1. \\<not> precedes (opposite l) (opposite l') (elements M)", "by simp"], ["proof (state)\nthis:\n  \\<not> precedes (opposite l) (opposite l') (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "from \\<open>l' el c\\<close> \\<open>\\<forall> l. l el c \\<longrightarrow> (opposite l) el (decisions M)\\<close>"], ["proof (chain)\npicking this:\n  l' el c\n  \\<forall>l. l el c \\<longrightarrow> opposite l el decisions M", "have \"(opposite l') el (decisions M)\""], ["proof (prove)\nusing this:\n  l' el c\n  \\<forall>l. l el c \\<longrightarrow> opposite l el decisions M\n\ngoal (1 subgoal):\n 1. opposite l' el decisions M", "by auto"], ["proof (state)\nthis:\n  opposite l' el decisions M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "hence \"(opposite l') el (elements M)\""], ["proof (prove)\nusing this:\n  opposite l' el decisions M\n\ngoal (1 subgoal):\n 1. opposite l' el elements M", "by (simp add:markedElementsAreElements)"], ["proof (state)\nthis:\n  opposite l' el elements M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "from \\<open>(opposite l) el (elements M)\\<close> \\<open>(opposite l') el (elements M)\\<close> \\<open>l' \\<noteq> l\\<close> \n      \\<open>\\<not> precedes (opposite l) (opposite l') (elements M)\\<close>"], ["proof (chain)\npicking this:\n  opposite l el elements M\n  opposite l' el elements M\n  l' \\<noteq> l\n  \\<not> precedes (opposite l) (opposite l') (elements M)", "have \"precedes (opposite l') (opposite l) (elements M)\""], ["proof (prove)\nusing this:\n  opposite l el elements M\n  opposite l' el elements M\n  l' \\<noteq> l\n  \\<not> precedes (opposite l) (opposite l') (elements M)\n\ngoal (1 subgoal):\n 1. precedes (opposite l') (opposite l) (elements M)", "using precedesTotalOrder [of \"opposite l\" \"elements M\" \"opposite l'\"]"], ["proof (prove)\nusing this:\n  opposite l el elements M\n  opposite l' el elements M\n  l' \\<noteq> l\n  \\<not> precedes (opposite l) (opposite l') (elements M)\n  \\<lbrakk>opposite l \\<in> set (elements M);\n   opposite l' \\<in> set (elements M)\\<rbrakk>\n  \\<Longrightarrow> opposite l = opposite l' \\<or>\n                    precedes (opposite l) (opposite l') (elements M) \\<or>\n                    precedes (opposite l') (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. precedes (opposite l') (opposite l) (elements M)", "by simp"], ["proof (state)\nthis:\n  precedes (opposite l') (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "with \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  precedes (opposite l') (opposite l) (elements M)", "have \"elementLevel (opposite l') M <= elementLevel (opposite l) M\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  precedes (opposite l') (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M \\<le> elementLevel (opposite l) M", "by (auto simp add:elementLevelPrecedesLeq)"], ["proof (state)\nthis:\n  elementLevel (opposite l') M \\<le> elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "moreover"], ["proof (state)\nthis:\n  elementLevel (opposite l') M \\<le> elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "from \\<open>uniq (elements M)\\<close> \\<open>(opposite l) el (decisions M)\\<close> \\<open>(opposite l') el (decisions M)\\<close> \\<open>l' \\<noteq> l\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  opposite l el decisions M\n  opposite l' el decisions M\n  l' \\<noteq> l", "have \"elementLevel (opposite l) M \\<noteq> elementLevel (opposite l') M\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  opposite l el decisions M\n  opposite l' el decisions M\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l) M \\<noteq> elementLevel (opposite l') M", "using differentMarkedElementsHaveDifferentLevels[of \"M\" \"opposite l\" \"opposite l'\"]"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  opposite l el decisions M\n  opposite l' el decisions M\n  l' \\<noteq> l\n  \\<lbrakk>uniq (elements M); opposite l \\<in> set (decisions M);\n   opposite l' \\<in> set (decisions M);\n   opposite l \\<noteq> opposite l'\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite l) M \\<noteq>\n                    elementLevel (opposite l') M\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l) M \\<noteq> elementLevel (opposite l') M", "by simp"], ["proof (state)\nthis:\n  elementLevel (opposite l) M \\<noteq> elementLevel (opposite l') M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "ultimately"], ["proof (chain)\npicking this:\n  elementLevel (opposite l') M \\<le> elementLevel (opposite l) M\n  elementLevel (opposite l) M \\<noteq> elementLevel (opposite l') M", "have \"elementLevel (opposite l') M < elementLevel (opposite l) M\""], ["proof (prove)\nusing this:\n  elementLevel (opposite l') M \\<le> elementLevel (opposite l) M\n  elementLevel (opposite l) M \\<noteq> elementLevel (opposite l') M\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M < elementLevel (opposite l) M", "by simp"], ["proof (state)\nthis:\n  elementLevel (opposite l') M < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "using \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "unfolding isUIP_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n     (elements M) \\<and>\n    (\\<forall>l'.\n        l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n        elementLevel (opposite l') M < elementLevel (opposite l) M)", "by simp"], ["proof (state)\nthis:\n  isUIP l c M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>If last asserted literal of a clause is a decision literal, then UIP is reached.\\<close>"], ["", "lemma lastDecisionThenUIP:\n  fixes M :: LiteralTrail and c:: Clause\n  assumes \"(uniq (elements M))\" and\n  \"(opposite l) el (decisions M)\"\n  \"clauseFalse c (elements M)\"\n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\"\n  shows \"isUIP l c M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isUIP l c M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isUIP l c M", "from \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "have \"l el c\" \"(opposite l) el (elements M)\"\n    and *: \"\\<forall>l'. l' el (oppositeLiteralList c) \\<and> l' \\<noteq> opposite l \\<longrightarrow> \\<not> precedes (opposite l) l' (elements M)\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. (l el c &&& opposite l el elements M) &&&\n    \\<forall>l'.\n       l' el oppositeLiteralList c \\<and>\n       l' \\<noteq> opposite l \\<longrightarrow>\n       \\<not> precedes (opposite l) l' (elements M)", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c \\<and>\n  literalTrue (opposite l) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList c \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements M))\n\ngoal (1 subgoal):\n 1. (l el c &&& opposite l el elements M) &&&\n    \\<forall>l'.\n       l' el oppositeLiteralList c \\<and>\n       l' \\<noteq> opposite l \\<longrightarrow>\n       \\<not> precedes (opposite l) l' (elements M)", "using \"literalElListIffOppositeLiteralElOppositeLiteralList\""], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c \\<and>\n  literalTrue (opposite l) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList c \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements M))\n  ?literal el ?literalList =\n  opposite ?literal el oppositeLiteralList ?literalList\n\ngoal (1 subgoal):\n 1. (l el c &&& opposite l el elements M) &&&\n    \\<forall>l'.\n       l' el oppositeLiteralList c \\<and>\n       l' \\<noteq> opposite l \\<longrightarrow>\n       \\<not> precedes (opposite l) l' (elements M)", "by auto"], ["proof (state)\nthis:\n  l el c\n  opposite l el elements M\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "{"], ["proof (state)\nthis:\n  l el c\n  opposite l el elements M\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "fix l' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. isUIP l c M", "assume \"l' el c\" \"l' \\<noteq> l\""], ["proof (state)\nthis:\n  l' el c\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. isUIP l c M", "hence \"opposite l' el (oppositeLiteralList c)\" and \"opposite l' \\<noteq> opposite l\""], ["proof (prove)\nusing this:\n  l' el c\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. opposite l' el oppositeLiteralList c &&& opposite l' \\<noteq> opposite l", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l'\" \"c\"]"], ["proof (prove)\nusing this:\n  l' el c\n  l' \\<noteq> l\n  l' el c = opposite l' el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. opposite l' el oppositeLiteralList c &&& opposite l' \\<noteq> opposite l", "by auto"], ["proof (state)\nthis:\n  opposite l' el oppositeLiteralList c\n  opposite l' \\<noteq> opposite l\n\ngoal (1 subgoal):\n 1. isUIP l c M", "with *"], ["proof (chain)\npicking this:\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n  opposite l' el oppositeLiteralList c\n  opposite l' \\<noteq> opposite l", "have \"\\<not> precedes (opposite l) (opposite l') (elements M)\""], ["proof (prove)\nusing this:\n  \\<forall>l'.\n     l' el oppositeLiteralList c \\<and>\n     l' \\<noteq> opposite l \\<longrightarrow>\n     \\<not> precedes (opposite l) l' (elements M)\n  opposite l' el oppositeLiteralList c\n  opposite l' \\<noteq> opposite l\n\ngoal (1 subgoal):\n 1. \\<not> precedes (opposite l) (opposite l') (elements M)", "by simp"], ["proof (state)\nthis:\n  \\<not> precedes (opposite l) (opposite l') (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "have \"(opposite l') el (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opposite l' el elements M", "using \\<open>l' el c\\<close> \\<open>clauseFalse c (elements M)\\<close>"], ["proof (prove)\nusing this:\n  l' el c\n  clauseFalse c (elements M)\n\ngoal (1 subgoal):\n 1. opposite l' el elements M", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  opposite l' el elements M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "from \\<open>(opposite l) el (elements M)\\<close> \\<open>(opposite l') el (elements M)\\<close> \\<open>l' \\<noteq> l\\<close> \n      \\<open>\\<not> precedes (opposite l) (opposite l') (elements M)\\<close>"], ["proof (chain)\npicking this:\n  opposite l el elements M\n  opposite l' el elements M\n  l' \\<noteq> l\n  \\<not> precedes (opposite l) (opposite l') (elements M)", "have \"precedes (opposite l') (opposite l) (elements M)\""], ["proof (prove)\nusing this:\n  opposite l el elements M\n  opposite l' el elements M\n  l' \\<noteq> l\n  \\<not> precedes (opposite l) (opposite l') (elements M)\n\ngoal (1 subgoal):\n 1. precedes (opposite l') (opposite l) (elements M)", "using precedesTotalOrder [of \"opposite l\" \"elements M\" \"opposite l'\"]"], ["proof (prove)\nusing this:\n  opposite l el elements M\n  opposite l' el elements M\n  l' \\<noteq> l\n  \\<not> precedes (opposite l) (opposite l') (elements M)\n  \\<lbrakk>opposite l \\<in> set (elements M);\n   opposite l' \\<in> set (elements M)\\<rbrakk>\n  \\<Longrightarrow> opposite l = opposite l' \\<or>\n                    precedes (opposite l) (opposite l') (elements M) \\<or>\n                    precedes (opposite l') (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. precedes (opposite l') (opposite l) (elements M)", "by simp"], ["proof (state)\nthis:\n  precedes (opposite l') (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "hence \"elementLevel (opposite l') M < elementLevel (opposite l) M\""], ["proof (prove)\nusing this:\n  precedes (opposite l') (opposite l) (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M < elementLevel (opposite l) M", "using elementLevelPrecedesMarkedElementLt[of \"M\" \"opposite l'\" \"opposite l\"]"], ["proof (prove)\nusing this:\n  precedes (opposite l') (opposite l) (elements M)\n  \\<lbrakk>uniq (elements M); opposite l' \\<noteq> opposite l;\n   opposite l \\<in> set (decisions M);\n   precedes (opposite l') (opposite l) (elements M)\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite l') M\n                    < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M < elementLevel (opposite l) M", "using \\<open>uniq (elements M)\\<close>"], ["proof (prove)\nusing this:\n  precedes (opposite l') (opposite l) (elements M)\n  \\<lbrakk>uniq (elements M); opposite l' \\<noteq> opposite l;\n   opposite l \\<in> set (decisions M);\n   precedes (opposite l') (opposite l) (elements M)\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite l') M\n                    < elementLevel (opposite l) M\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M < elementLevel (opposite l) M", "using \\<open>opposite l el (decisions M)\\<close>"], ["proof (prove)\nusing this:\n  precedes (opposite l') (opposite l) (elements M)\n  \\<lbrakk>uniq (elements M); opposite l' \\<noteq> opposite l;\n   opposite l \\<in> set (decisions M);\n   precedes (opposite l') (opposite l) (elements M)\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite l') M\n                    < elementLevel (opposite l) M\n  uniq (elements M)\n  opposite l el decisions M\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M < elementLevel (opposite l) M", "using \\<open>l' \\<noteq> l\\<close>"], ["proof (prove)\nusing this:\n  precedes (opposite l') (opposite l) (elements M)\n  \\<lbrakk>uniq (elements M); opposite l' \\<noteq> opposite l;\n   opposite l \\<in> set (decisions M);\n   precedes (opposite l') (opposite l) (elements M)\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite l') M\n                    < elementLevel (opposite l) M\n  uniq (elements M)\n  opposite l el decisions M\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l') M < elementLevel (opposite l) M", "by simp"], ["proof (state)\nthis:\n  elementLevel (opposite l') M < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "using \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "unfolding SatSolverVerification.isUIP_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l'2 el c; ?l'2 \\<noteq> l\\<rbrakk>\n  \\<Longrightarrow> elementLevel (opposite ?l'2) M\n                    < elementLevel (opposite l) M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList c)\n     (elements M) \\<and>\n    (\\<forall>l'.\n        l' el c \\<and> l' \\<noteq> l \\<longrightarrow>\n        elementLevel (opposite l') M < elementLevel (opposite l) M)", "by simp"], ["proof (state)\nthis:\n  isUIP l c M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>If all literals in a clause are decision literals, then there\nexists a backjump level for that clause.\\<close>"], ["", "lemma allDecisionsThenExistsBackjumpLevel:\n  fixes M :: LiteralTrail and c:: Clause\n  assumes \"(uniq (elements M))\" and\n  \"\\<forall> l'. l' el c \\<longrightarrow> (opposite l') el (decisions M)\"\n  \"isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\"\n  shows \"\\<exists> level. (isBackjumpLevel level l c M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "from assms"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "have \"isUIP l c M\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. isUIP l c M", "using allDecisionsThenUIP"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n  \\<lbrakk>uniq (elements ?M);\n   \\<forall>l'. l' el ?c \\<longrightarrow> opposite l' el decisions ?M;\n   isLastAssertedLiteral (opposite ?l) (oppositeLiteralList ?c)\n    (elements ?M)\\<rbrakk>\n  \\<Longrightarrow> isUIP ?l ?c ?M\n\ngoal (1 subgoal):\n 1. isUIP l c M", "by simp"], ["proof (state)\nthis:\n  isUIP l c M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "moreover"], ["proof (state)\nthis:\n  isUIP l c M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "from \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)", "have \"l el c\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList c) (elements M)\n\ngoal (1 subgoal):\n 1. l el c", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c \\<and>\n  literalTrue (opposite l) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList c \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements M))\n\ngoal (1 subgoal):\n 1. l el c", "using literalElListIffOppositeLiteralElOppositeLiteralList"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList c \\<and>\n  literalTrue (opposite l) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList c \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements M))\n  ?literal el ?literalList =\n  opposite ?literal el oppositeLiteralList ?literalList\n\ngoal (1 subgoal):\n 1. l el c", "by simp"], ["proof (state)\nthis:\n  l el c\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "with \\<open>\\<forall> l'. l' el c \\<longrightarrow> (opposite l') el (decisions M)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  l el c", "have \"(opposite l) el (decisions M)\""], ["proof (prove)\nusing this:\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  l el c\n\ngoal (1 subgoal):\n 1. opposite l el decisions M", "by simp"], ["proof (state)\nthis:\n  opposite l el decisions M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "hence \"elementLevel (opposite l) M > 0\""], ["proof (prove)\nusing this:\n  opposite l el decisions M\n\ngoal (1 subgoal):\n 1. 0 < elementLevel (opposite l) M", "using \\<open>uniq (elements M)\\<close>\n      elementLevelMarkedGeq1[of \"M\" \"opposite l\"]"], ["proof (prove)\nusing this:\n  opposite l el decisions M\n  uniq (elements M)\n  \\<lbrakk>uniq (elements M); opposite l \\<in> set (decisions M)\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. 0 < elementLevel (opposite l) M", "by auto"], ["proof (state)\nthis:\n  0 < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "moreover"], ["proof (state)\nthis:\n  0 < elementLevel (opposite l) M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "have \"clauseFalse c (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "fix l'::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "assume \"l' el c\""], ["proof (state)\nthis:\n  l' el c\n\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "with \\<open>\\<forall> l'. l' el c \\<longrightarrow> (opposite l') el (decisions M)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  l' el c", "have \"(opposite l') el (decisions M)\""], ["proof (prove)\nusing this:\n  \\<forall>l'. l' el c \\<longrightarrow> opposite l' el decisions M\n  l' el c\n\ngoal (1 subgoal):\n 1. opposite l' el decisions M", "by simp"], ["proof (state)\nthis:\n  opposite l' el decisions M\n\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "hence \"literalFalse l' (elements M)\""], ["proof (prove)\nusing this:\n  opposite l' el decisions M\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements M)", "using markedElementsAreElements"], ["proof (prove)\nusing this:\n  opposite l' el decisions M\n  ?m \\<in> set (markedElements ?M) \\<Longrightarrow>\n  ?m \\<in> set (elements ?M)\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements M)", "by simp"], ["proof (state)\nthis:\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "}"], ["proof (state)\nthis:\n  ?l'2 el c \\<Longrightarrow> literalFalse ?l'2 (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l'2 el c \\<Longrightarrow> literalFalse ?l'2 (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "using clauseFalseIffAllLiteralsAreFalse"], ["proof (prove)\nusing this:\n  ?l'2 el c \\<Longrightarrow> literalFalse ?l'2 (elements M)\n  clauseFalse ?clause ?valuation =\n  (\\<forall>literal.\n      literal el ?clause \\<longrightarrow> literalFalse literal ?valuation)\n\ngoal (1 subgoal):\n 1. clauseFalse c (elements M)", "by simp"], ["proof (state)\nthis:\n  clauseFalse c (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseFalse c (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "ultimately"], ["proof (chain)\npicking this:\n  isUIP l c M\n  0 < elementLevel (opposite l) M\n  clauseFalse c (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  isUIP l c M\n  0 < elementLevel (opposite l) M\n  clauseFalse c (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "using \\<open>uniq (elements M)\\<close>"], ["proof (prove)\nusing this:\n  isUIP l c M\n  0 < elementLevel (opposite l) M\n  clauseFalse c (elements M)\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "using isUIPExistsBackjumpLevel"], ["proof (prove)\nusing this:\n  isUIP l c M\n  0 < elementLevel (opposite l) M\n  clauseFalse c (elements M)\n  uniq (elements M)\n  \\<lbrakk>clauseFalse ?c (elements ?M); isUIP ?l ?c ?M; uniq (elements ?M);\n   0 < elementLevel (opposite ?l) ?M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>level. isBackjumpLevel level ?l ?c ?M\n\ngoal (1 subgoal):\n 1. \\<exists>level. isBackjumpLevel level l c M", "by simp"], ["proof (state)\nthis:\n  \\<exists>level. isBackjumpLevel level l c M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>$Explain$ is applicable to each non-decision literal in a clause.\\<close>"], ["", "lemma explainApplicableToEachNonDecision:\n  fixes F :: Formula and M :: LiteralTrail and conflictFlag :: bool and C :: Clause and literal :: Literal\n  assumes \"InvariantReasonClauses F M\" and \"InvariantCFalse conflictFlag M C\" and\n  \"conflictFlag = True\" and \"opposite literal el C\" and \"\\<not> literal el (decisions M)\"\n  shows \"\\<exists> clause. formulaEntailsClause F clause \\<and> isReason clause literal (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "from \\<open>conflictFlag = True\\<close> \\<open>InvariantCFalse conflictFlag M C\\<close>"], ["proof (chain)\npicking this:\n  conflictFlag = True\n  InvariantCFalse conflictFlag M C", "have \"clauseFalse C (elements M)\""], ["proof (prove)\nusing this:\n  conflictFlag = True\n  InvariantCFalse conflictFlag M C\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M)", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  conflictFlag = True\n  conflictFlag \\<longrightarrow> clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. clauseFalse C (elements M)", "by simp"], ["proof (state)\nthis:\n  clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "with \\<open>opposite literal el C\\<close>"], ["proof (chain)\npicking this:\n  opposite literal el C\n  clauseFalse C (elements M)", "have \"literalTrue literal (elements M)\""], ["proof (prove)\nusing this:\n  opposite literal el C\n  clauseFalse C (elements M)\n\ngoal (1 subgoal):\n 1. literalTrue literal (elements M)", "by (auto simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalTrue literal (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "with \\<open>\\<not> literal el (decisions M)\\<close> \\<open>InvariantReasonClauses F M\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literal el decisions M\n  InvariantReasonClauses F M\n  literalTrue literal (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> literal el decisions M\n  InvariantReasonClauses F M\n  literalTrue literal (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "unfolding InvariantReasonClauses_def"], ["proof (prove)\nusing this:\n  \\<not> literal el decisions M\n  \\<forall>literal.\n     literal el elements M \\<and>\n     \\<not> literal el decisions M \\<longrightarrow>\n     (\\<exists>clause.\n         formulaEntailsClause F clause \\<and>\n         isReason clause literal (elements M))\n  literalTrue literal (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       formulaEntailsClause F clause \\<and>\n       isReason clause literal (elements M)", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     formulaEntailsClause F clause \\<and>\n     isReason clause literal (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["", "(**************************************************************************)\n(*                          T E R M I N A T I O N                         *)\n(**************************************************************************)"], ["", "subsection\\<open>Termination\\<close>"], ["", "text\\<open>In this section different ordering relations will be defined. These \n  well-founded orderings will be the basic building blocks of termination \n  orderings that will prove the termination of the SAT solving procedures\\<close>"], ["", "text\\<open>First we prove a simple lemma about acyclic orderings.\\<close>"], ["", "lemma transIrreflexiveOrderingIsAcyclic:\n  assumes \"trans r\" and \"\\<forall> x. (x, x) \\<notin> r\"\n  shows \"acyclic r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic r", "proof (rule acyclicI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "assume \"\\<exists> x. (x, x) \\<in> r^+\""], ["proof (state)\nthis:\n  \\<exists>x. (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. (x, x) \\<in> r\\<^sup>+", "obtain x where \"(x, x) \\<in> r^+\""], ["proof (prove)\nusing this:\n  \\<exists>x. (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, x) \\<in> r\\<^sup>+ \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "from \\<open>trans r\\<close>"], ["proof (chain)\npicking this:\n  trans r", "have \"r^+ = r\""], ["proof (prove)\nusing this:\n  trans r\n\ngoal (1 subgoal):\n 1. r\\<^sup>+ = r", "by (rule trancl_id)"], ["proof (state)\nthis:\n  r\\<^sup>+ = r\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  (x, x) \\<in> r\\<^sup>+\n  r\\<^sup>+ = r", "have \"(x, x) \\<in> r\""], ["proof (prove)\nusing this:\n  (x, x) \\<in> r\\<^sup>+\n  r\\<^sup>+ = r\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> r", "by simp"], ["proof (state)\nthis:\n  (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "with \\<open>\\<forall> x. (x, x) \\<notin> r\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x. (x, x) \\<notin> r\n  (x, x) \\<in> r", "have False"], ["proof (prove)\nusing this:\n  \\<forall>x. (x, x) \\<notin> r\n  (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "}"], ["proof (state)\nthis:\n  \\<exists>x. (x, x) \\<in> r\\<^sup>+ \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "thus \"\\<forall> x. (x, x) \\<notin> r^+\""], ["proof (prove)\nusing this:\n  \\<exists>x. (x, x) \\<in> r\\<^sup>+ \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> r\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. (x, x) \\<notin> r\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "(*-----------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Trail ordering\\<close>"], ["", "(*-----------------------------------------------------------------------*)"], ["", "text\\<open>We define a lexicographic ordering of trails, based on the\nnumber of literals on the different decision levels. It will be used\nfor transition rules that change the trail, i.e., for $Decide$,\n$UnitPropagate$, $Backjump$ and $Backtrack$ transition rules.\\<close>"], ["", "definition\n\"decisionLess = {(l1::('a*bool), l2::('a*bool)). isDecision l1 \\<and> \\<not> isDecision l2}\""], ["", "definition\n\"lexLess = {(M1::'a Trail, M2::'a Trail). (M2, M1) \\<in> lexord decisionLess}\""], ["", "text\\<open>Following several lemmas will help prove that application of\nsome DPLL-based transition rules decreases the trail in the @{term\nlexLess} ordering.\\<close>"], ["", "lemma lexLessAppend:\n  assumes \"b \\<noteq> []\" \n  shows \"(a @ b, a) \\<in> lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a @ b, a) \\<in> lexLess", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (a @ b, a) \\<in> lexLess", "from \\<open>b \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  b \\<noteq> []", "have \"\\<exists> aa list. b = aa # list\""], ["proof (prove)\nusing this:\n  b \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>aa list. b = aa # list", "by (simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  \\<exists>aa list. b = aa # list\n\ngoal (1 subgoal):\n 1. (a @ b, a) \\<in> lexLess", "then"], ["proof (chain)\npicking this:\n  \\<exists>aa list. b = aa # list", "obtain aa::\"'a \\<times> bool\" and list :: \"'a Trail\"\n    where \"b = aa # list\""], ["proof (prove)\nusing this:\n  \\<exists>aa list. b = aa # list\n\ngoal (1 subgoal):\n 1. (\\<And>aa list.\n        b = aa # list \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = aa # list\n\ngoal (1 subgoal):\n 1. (a @ b, a) \\<in> lexLess", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = aa # list\n\ngoal (1 subgoal):\n 1. (a @ b, a) \\<in> lexLess", "unfolding lexLess_def"], ["proof (prove)\nusing this:\n  b = aa # list\n\ngoal (1 subgoal):\n 1. (a @ b, a) \\<in> {(M1, M2). (M2, M1) \\<in> lexord decisionLess}", "unfolding lexord_def"], ["proof (prove)\nusing this:\n  b = aa # list\n\ngoal (1 subgoal):\n 1. (a @ b, a)\n    \\<in> {(M1, M2).\n           (M2, M1)\n           \\<in> {(x, y).\n                  \\<exists>a v.\n                     y = x @ a # v \\<or>\n                     (\\<exists>u a b v w.\n                         (a, b) \\<in> decisionLess \\<and>\n                         x = u @ a # v \\<and> y = u @ b # w)}}", "by simp"], ["proof (state)\nthis:\n  (a @ b, a) \\<in> lexLess\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lexLessBackjump:\n  assumes \"p = prefixToLevel level a\" and \"level >= 0\" and \"level < currentLevel a\" \n  shows \"(p @ [(x, False)], a) \\<in> lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "from assms"], ["proof (chain)\npicking this:\n  p = prefixToLevel level a\n  0 \\<le> level\n  level < currentLevel a", "have \"\\<exists> rest. prefixToLevel level a @ rest = a \\<and> rest \\<noteq> [] \\<and> isDecision (hd rest)\""], ["proof (prove)\nusing this:\n  p = prefixToLevel level a\n  0 \\<le> level\n  level < currentLevel a\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       prefixToLevel level a @ rest = a \\<and>\n       rest \\<noteq> [] \\<and> isDecision (hd rest)", "using isProperPrefixPrefixToLevel"], ["proof (prove)\nusing this:\n  p = prefixToLevel level a\n  0 \\<le> level\n  level < currentLevel a\n  ?level < currentLevel ?t \\<Longrightarrow>\n  \\<exists>s.\n     prefixToLevel ?level ?t @ s = ?t \\<and>\n     s \\<noteq> [] \\<and> isDecision (hd s)\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       prefixToLevel level a @ rest = a \\<and>\n       rest \\<noteq> [] \\<and> isDecision (hd rest)", "by auto"], ["proof (state)\nthis:\n  \\<exists>rest.\n     prefixToLevel level a @ rest = a \\<and>\n     rest \\<noteq> [] \\<and> isDecision (hd rest)\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "with \\<open>p = prefixToLevel level a\\<close>"], ["proof (chain)\npicking this:\n  p = prefixToLevel level a\n  \\<exists>rest.\n     prefixToLevel level a @ rest = a \\<and>\n     rest \\<noteq> [] \\<and> isDecision (hd rest)", "obtain rest \n    where \"p @ rest = a \\<and> rest \\<noteq> [] \\<and> isDecision (hd rest)\""], ["proof (prove)\nusing this:\n  p = prefixToLevel level a\n  \\<exists>rest.\n     prefixToLevel level a @ rest = a \\<and>\n     rest \\<noteq> [] \\<and> isDecision (hd rest)\n\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        p @ rest = a \\<and>\n        rest \\<noteq> [] \\<and> isDecision (hd rest) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p @ rest = a \\<and> rest \\<noteq> [] \\<and> isDecision (hd rest)\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "thus ?thesis"], ["proof (prove)\nusing this:\n  p @ rest = a \\<and> rest \\<noteq> [] \\<and> isDecision (hd rest)\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "unfolding lexLess_def"], ["proof (prove)\nusing this:\n  p @ rest = a \\<and> rest \\<noteq> [] \\<and> isDecision (hd rest)\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a)\n    \\<in> {(M1, M2). (M2, M1) \\<in> lexord decisionLess}", "using lexord_append_left_rightI[of \"hd rest\" \"(x, False)\" \"decisionLess\" \"p\" \"tl rest\" \"[]\"]"], ["proof (prove)\nusing this:\n  p @ rest = a \\<and> rest \\<noteq> [] \\<and> isDecision (hd rest)\n  (hd rest, x, False) \\<in> decisionLess \\<Longrightarrow>\n  (p @ hd rest # tl rest, p @ [(x, False)]) \\<in> lexord decisionLess\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a)\n    \\<in> {(M1, M2). (M2, M1) \\<in> lexord decisionLess}", "unfolding decisionLess_def"], ["proof (prove)\nusing this:\n  p @ rest = a \\<and> rest \\<noteq> [] \\<and> isDecision (hd rest)\n  (hd rest, x, False)\n  \\<in> {(l1, l2).\n         isDecision l1 \\<and> \\<not> isDecision l2} \\<Longrightarrow>\n  (p @ hd rest # tl rest, p @ [(x, False)])\n  \\<in> lexord {(l1, l2). isDecision l1 \\<and> \\<not> isDecision l2}\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a)\n    \\<in> {(M1, M2).\n           (M2, M1)\n           \\<in> lexord\n                  {(l1, l2). isDecision l1 \\<and> \\<not> isDecision l2}}", "by simp"], ["proof (state)\nthis:\n  (p @ [(x, False)], a) \\<in> lexLess\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lexLessBacktrack:\n  assumes \"p = prefixBeforeLastDecision a\" \"decisions a \\<noteq> []\"\n  shows \"(p @ [(x, False)], a) \\<in> lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "using assms"], ["proof (prove)\nusing this:\n  p = prefixBeforeLastDecision a\n  decisions a \\<noteq> []\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "using prefixBeforeLastMarkedIsPrefixBeforeLastLevel[of \"a\"]"], ["proof (prove)\nusing this:\n  p = prefixBeforeLastDecision a\n  decisions a \\<noteq> []\n  decisions a \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastDecision a = prefixToLevel (currentLevel a - 1) a\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "using lexLessBackjump[of \"p\" \"currentLevel a - 1\" \"a\"]"], ["proof (prove)\nusing this:\n  p = prefixBeforeLastDecision a\n  decisions a \\<noteq> []\n  decisions a \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastDecision a = prefixToLevel (currentLevel a - 1) a\n  \\<lbrakk>p = prefixToLevel (currentLevel a - 1) a;\n   0 \\<le> currentLevel a - 1; currentLevel a - 1 < currentLevel a\\<rbrakk>\n  \\<Longrightarrow> (p @ [(?x, False)], a) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  p = prefixBeforeLastDecision a\n  decisions a \\<noteq> []\n  decisions a \\<noteq> [] \\<Longrightarrow>\n  prefixBeforeLastDecision a = prefixToLevel (length (decisions a) - 1) a\n  \\<lbrakk>p = prefixToLevel (length (decisions a) - 1) a;\n   0 \\<le> length (decisions a) - 1;\n   length (decisions a) - 1 < length (decisions a)\\<rbrakk>\n  \\<Longrightarrow> (p @ [(?x, False)], a) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (p @ [(x, False)], a) \\<in> lexLess", "by auto"], ["", "text\\<open>The following several lemmas prover that @{term lexLess} is\nacyclic. This property will play an important role in building a\nwell-founded ordering based on @{term lexLess}.\\<close>"], ["", "lemma transDecisionLess:\n  shows \"trans decisionLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans decisionLess", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. trans decisionLess", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. trans decisionLess", "fix x::\"('a*bool)\" and y::\"('a*bool)\" and z::\"('a*bool)\""], ["proof (state)\ngoal (1 subgoal):\n 1. trans decisionLess", "assume \"(x, y) \\<in> decisionLess\""], ["proof (state)\nthis:\n  (x, y) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. trans decisionLess", "hence \"\\<not> isDecision y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. \\<not> isDecision y", "unfolding decisionLess_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(l1, l2). isDecision l1 \\<and> \\<not> isDecision l2}\n\ngoal (1 subgoal):\n 1. \\<not> isDecision y", "by simp"], ["proof (state)\nthis:\n  \\<not> isDecision y\n\ngoal (1 subgoal):\n 1. trans decisionLess", "moreover"], ["proof (state)\nthis:\n  \\<not> isDecision y\n\ngoal (1 subgoal):\n 1. trans decisionLess", "assume \"(y, z) \\<in> decisionLess\""], ["proof (state)\nthis:\n  (y, z) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. trans decisionLess", "hence \"isDecision y\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. isDecision y", "unfolding decisionLess_def"], ["proof (prove)\nusing this:\n  (y, z) \\<in> {(l1, l2). isDecision l1 \\<and> \\<not> isDecision l2}\n\ngoal (1 subgoal):\n 1. isDecision y", "by simp"], ["proof (state)\nthis:\n  isDecision y\n\ngoal (1 subgoal):\n 1. trans decisionLess", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> isDecision y\n  isDecision y", "have False"], ["proof (prove)\nusing this:\n  \\<not> isDecision y\n  isDecision y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. trans decisionLess", "hence \"(x, z) \\<in> decisionLess\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> decisionLess", "by simp"], ["proof (state)\nthis:\n  (x, z) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. trans decisionLess", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?x2, ?y2) \\<in> decisionLess;\n   (?y2, ?z2) \\<in> decisionLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. trans decisionLess", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> decisionLess;\n   (?y2, ?z2) \\<in> decisionLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. trans decisionLess", "unfolding trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> decisionLess;\n   (?y2, ?z2) \\<in> decisionLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> decisionLess\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> decisionLess \\<longrightarrow>\n       (y, z) \\<in> decisionLess \\<longrightarrow> (x, z) \\<in> decisionLess", "by blast"], ["proof (state)\nthis:\n  trans decisionLess\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma translexLess: \n  shows \"trans lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans lexLess", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. trans lexLess", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. trans lexLess", "fix x :: \"'a Trail\" and y :: \"'a Trail\" and z :: \"'a Trail\""], ["proof (state)\ngoal (1 subgoal):\n 1. trans lexLess", "assume \"(x, y) \\<in> lexLess\" and \"(y, z) \\<in> lexLess\""], ["proof (state)\nthis:\n  (x, y) \\<in> lexLess\n  (y, z) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. trans lexLess", "hence \"(x, z) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> lexLess\n  (y, z) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> lexLess", "using lexord_trans transDecisionLess"], ["proof (prove)\nusing this:\n  (x, y) \\<in> lexLess\n  (y, z) \\<in> lexLess\n  \\<lbrakk>(?x, ?y) \\<in> lexord ?r; (?y, ?z) \\<in> lexord ?r;\n   trans ?r\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> lexord ?r\n  trans decisionLess\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> lexLess", "unfolding lexLess_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(M1, M2). (M2, M1) \\<in> lexord decisionLess}\n  (y, z) \\<in> {(M1, M2). (M2, M1) \\<in> lexord decisionLess}\n  \\<lbrakk>(?x, ?y) \\<in> lexord ?r; (?y, ?z) \\<in> lexord ?r;\n   trans ?r\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> lexord ?r\n  trans decisionLess\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> {(M1, M2). (M2, M1) \\<in> lexord decisionLess}", "by simp"], ["proof (state)\nthis:\n  (x, z) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. trans lexLess", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?x2, ?y2) \\<in> lexLess; (?y2, ?z2) \\<in> lexLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. trans lexLess", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> lexLess; (?y2, ?z2) \\<in> lexLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. trans lexLess", "unfolding trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> lexLess; (?y2, ?z2) \\<in> lexLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> lexLess \\<longrightarrow>\n       (y, z) \\<in> lexLess \\<longrightarrow> (x, z) \\<in> lexLess", "by blast"], ["proof (state)\nthis:\n  trans lexLess\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreflexiveDecisionLess:\n  shows \"(x, x) \\<notin> decisionLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<notin> decisionLess", "unfolding decisionLess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<notin> {(l1, l2). isDecision l1 \\<and> \\<not> isDecision l2}", "by simp"], ["", "lemma irreflexiveLexLess: \n  shows \"(x, x) \\<notin> lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<notin> lexLess", "using lexord_irreflexive[of \"decisionLess\" \"x\"] irreflexiveDecisionLess"], ["proof (prove)\nusing this:\n  \\<forall>x. (x, x) \\<notin> decisionLess \\<Longrightarrow>\n  (x, x) \\<notin> lexord decisionLess\n  (?x, ?x) \\<notin> decisionLess\n\ngoal (1 subgoal):\n 1. (x, x) \\<notin> lexLess", "unfolding lexLess_def"], ["proof (prove)\nusing this:\n  \\<forall>x. (x, x) \\<notin> decisionLess \\<Longrightarrow>\n  (x, x) \\<notin> lexord decisionLess\n  (?x, ?x) \\<notin> decisionLess\n\ngoal (1 subgoal):\n 1. (x, x) \\<notin> {(M1, M2). (M2, M1) \\<in> lexord decisionLess}", "by auto"], ["", "lemma acyclicLexLess:\n  shows \"acyclic lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic lexLess", "proof (rule transIrreflexiveOrderingIsAcyclic)"], ["proof (state)\ngoal (2 subgoals):\n 1. trans lexLess\n 2. \\<forall>x. (x, x) \\<notin> lexLess", "show \"trans lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans lexLess", "using translexLess"], ["proof (prove)\nusing this:\n  trans lexLess\n\ngoal (1 subgoal):\n 1. trans lexLess", "."], ["proof (state)\nthis:\n  trans lexLess\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> lexLess", "show \"\\<forall> x. (x, x) \\<notin> lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> lexLess", "using irreflexiveLexLess"], ["proof (prove)\nusing this:\n  (?x, ?x) \\<notin> lexLess\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> lexLess", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. (x, x) \\<notin> lexLess\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The @{term lexLess} ordering is not well-founded. In order to\n  get a well-founded ordering, we restrict the @{term lexLess}\n  ordering to cosistent and uniq trails with fixed variable set.\\<close>"], ["", "definition \"lexLessRestricted (Vbl::Variable set) == {(M1, M2). \n  vars (elements M1) \\<subseteq> Vbl \\<and> consistent (elements M1) \\<and> uniq (elements M1) \\<and>\n  vars (elements M2) \\<subseteq> Vbl \\<and> consistent (elements M2) \\<and> uniq (elements M2) \\<and>\n  (M1, M2) \\<in> lexLess}\""], ["", "text\\<open>First we show that the set of those trails is finite.\\<close>"], ["", "lemma finiteVarsClause:\n  fixes c :: Clause\n  shows \"finite (vars c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars c)", "by (induct c) auto"], ["", "lemma finiteVarsFormula:\n  fixes F :: Formula\n  shows \"finite (vars F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars F)", "proof (induct F)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (vars [])\n 2. \\<And>a F. finite (vars F) \\<Longrightarrow> finite (vars (a # F))", "case (Cons c F)"], ["proof (state)\nthis:\n  finite (vars F)\n\ngoal (2 subgoals):\n 1. finite (vars [])\n 2. \\<And>a F. finite (vars F) \\<Longrightarrow> finite (vars (a # F))", "thus ?case"], ["proof (prove)\nusing this:\n  finite (vars F)\n\ngoal (1 subgoal):\n 1. finite (vars (c # F))", "using finiteVarsClause[of \"c\"]"], ["proof (prove)\nusing this:\n  finite (vars F)\n  finite (vars c)\n\ngoal (1 subgoal):\n 1. finite (vars (c # F))", "by simp"], ["proof (state)\nthis:\n  finite (vars (c # F))\n\ngoal (1 subgoal):\n 1. finite (vars [])", "qed simp"], ["", "lemma finiteListDecompose:\n  shows \"finite {(a, b). l = a @ b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(a, b). l = a @ b}", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {a. case a of (a, b) \\<Rightarrow> [] = a @ b}\n 2. \\<And>a l.\n       finite\n        {a. case a of (a, b) \\<Rightarrow> l = a @ b} \\<Longrightarrow>\n       finite {b. case b of (aa, b) \\<Rightarrow> a # l = aa @ b}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. finite {a. case a of (a, b) \\<Rightarrow> [] = a @ b}\n 2. \\<And>a l.\n       finite\n        {a. case a of (a, b) \\<Rightarrow> l = a @ b} \\<Longrightarrow>\n       finite {b. case b of (aa, b) \\<Rightarrow> a # l = aa @ b}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> [] = a @ b}", "by simp"], ["proof (state)\nthis:\n  finite {a. case a of (a, b) \\<Rightarrow> [] = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       finite\n        {a. case a of (a, b) \\<Rightarrow> l = a @ b} \\<Longrightarrow>\n       finite {b. case b of (aa, b) \\<Rightarrow> a # l = aa @ b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       finite\n        {a. case a of (a, b) \\<Rightarrow> l = a @ b} \\<Longrightarrow>\n       finite {b. case b of (aa, b) \\<Rightarrow> a # l = aa @ b}", "case (Cons x l')"], ["proof (state)\nthis:\n  finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       finite\n        {a. case a of (a, b) \\<Rightarrow> l = a @ b} \\<Longrightarrow>\n       finite {b. case b of (aa, b) \\<Rightarrow> a # l = aa @ b}", "thus ?case"], ["proof (prove)\nusing this:\n  finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "let \"?S l\" = \"{(a, b). l = a @ b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "let \"?S' x l'\" = \"{(a', b). a' = [] \\<and> b = (x # l') \\<or> \n                                (\\<exists> a. a' = x # a \\<and> (a, b) \\<in> (?S l'))}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "have \"?S (x # l') = ?S' x l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b} =\n    {a. case a of\n        (a', b) \\<Rightarrow>\n          a' = [] \\<and> b = x # l' \\<or>\n          (\\<exists>a.\n              a' = x # a \\<and>\n              (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n    \\<subseteq> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow> l' = a @ b})}\n 2. {a. case a of\n        (a', b) \\<Rightarrow>\n          a' = [] \\<and> b = x # l' \\<or>\n          (\\<exists>a.\n              a' = x # a \\<and>\n              (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n    \\<subseteq> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "show \"?S (x # l') \\<subseteq> ?S' x l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n    \\<subseteq> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow> l' = a @ b})}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a, b) \\<Rightarrow> x # l' = a @ b} \\<Longrightarrow>\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow> l' = a @ b})}", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a, b) \\<Rightarrow> x # l' = a @ b} \\<Longrightarrow>\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow> l' = a @ b})}", "assume \"k \\<in> ?S (x # l')\""], ["proof (state)\nthis:\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a, b) \\<Rightarrow> x # l' = a @ b} \\<Longrightarrow>\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow> l' = a @ b})}", "then"], ["proof (chain)\npicking this:\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "obtain a and b\n          where \"k = (a, b)\" \"x # l' = a @ b\""], ["proof (prove)\nusing this:\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>k = (a, b); x # l' = a @ b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = (a, b)\n  x # l' = a @ b\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a, b) \\<Rightarrow> x # l' = a @ b} \\<Longrightarrow>\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow> l' = a @ b})}", "then"], ["proof (chain)\npicking this:\n  k = (a, b)\n  x # l' = a @ b", "obtain a' where \"a' = x # a\""], ["proof (prove)\nusing this:\n  k = (a, b)\n  x # l' = a @ b\n\ngoal (1 subgoal):\n 1. (\\<And>a'. a' = x # a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a' = x # a\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a, b) \\<Rightarrow> x # l' = a @ b} \\<Longrightarrow>\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow> l' = a @ b})}", "from \\<open>k = (a, b)\\<close> \\<open>x # l' = a @ b\\<close>"], ["proof (chain)\npicking this:\n  k = (a, b)\n  x # l' = a @ b", "show \"k \\<in> ?S' x l'\""], ["proof (prove)\nusing this:\n  k = (a, b)\n  x # l' = a @ b\n\ngoal (1 subgoal):\n 1. k \\<in> {a. case a of\n                (a', b) \\<Rightarrow>\n                  a' = [] \\<and> b = x # l' \\<or>\n                  (\\<exists>a.\n                      a' = x # a \\<and>\n                      (a, b)\n                      \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}", "using SimpleLevi[of \"a\" \"b\" \"x\" \"l'\"]"], ["proof (prove)\nusing this:\n  k = (a, b)\n  x # l' = a @ b\n  (a @ b = x # l') =\n  (a = [] \\<and> b = x # l' \\<or> (\\<exists>t. a = x # t \\<and> t @ b = l'))\n\ngoal (1 subgoal):\n 1. k \\<in> {a. case a of\n                (a', b) \\<Rightarrow>\n                  a' = [] \\<and> b = x # l' \\<or>\n                  (\\<exists>a.\n                      a' = x # a \\<and>\n                      (a, b)\n                      \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}", "by auto"], ["proof (state)\nthis:\n  k \\<in> {a. case a of\n              (a', b) \\<Rightarrow>\n                a' = [] \\<and> b = x # l' \\<or>\n                (\\<exists>a.\n                    a' = x # a \\<and>\n                    (a, b)\n                    \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n  \\<subseteq> {a. case a of\n                  (a', b) \\<Rightarrow>\n                    a' = [] \\<and> b = x # l' \\<or>\n                    (\\<exists>a.\n                        a' = x # a \\<and>\n                        (a, b)\n                        \\<in> {a. case a of\n                                  (a, b) \\<Rightarrow> l' = a @ b})}\n\ngoal (1 subgoal):\n 1. {a. case a of\n        (a', b) \\<Rightarrow>\n          a' = [] \\<and> b = x # l' \\<or>\n          (\\<exists>a.\n              a' = x # a \\<and>\n              (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n    \\<subseteq> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {a. case a of\n        (a', b) \\<Rightarrow>\n          a' = [] \\<and> b = x # l' \\<or>\n          (\\<exists>a.\n              a' = x # a \\<and>\n              (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n    \\<subseteq> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "show \"?S' x l' \\<subseteq> ?S (x # l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. case a of\n        (a', b) \\<Rightarrow>\n          a' = [] \\<and> b = x # l' \\<or>\n          (\\<exists>a.\n              a' = x # a \\<and>\n              (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n    \\<subseteq> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "assume \"k \\<in> ?S' x l'\""], ["proof (state)\nthis:\n  k \\<in> {a. case a of\n              (a', b) \\<Rightarrow>\n                a' = [] \\<and> b = x # l' \\<or>\n                (\\<exists>a.\n                    a' = x # a \\<and>\n                    (a, b)\n                    \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "then"], ["proof (chain)\npicking this:\n  k \\<in> {a. case a of\n              (a', b) \\<Rightarrow>\n                a' = [] \\<and> b = x # l' \\<or>\n                (\\<exists>a.\n                    a' = x # a \\<and>\n                    (a, b)\n                    \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}", "obtain a' and b where \n          \"k = (a', b)\" \"a' = [] \\<and> b = x # l' \\<or> (\\<exists> a . a' = x # a \\<and> (a, b) \\<in> ?S l')\""], ["proof (prove)\nusing this:\n  k \\<in> {a. case a of\n              (a', b) \\<Rightarrow>\n                a' = [] \\<and> b = x # l' \\<or>\n                (\\<exists>a.\n                    a' = x # a \\<and>\n                    (a, b)\n                    \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n\ngoal (1 subgoal):\n 1. (\\<And>a' b.\n        \\<lbrakk>k = (a', b);\n         a' = [] \\<and> b = x # l' \\<or>\n         (\\<exists>a.\n             a' = x # a \\<and>\n             (a, b)\n             \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = (a', b)\n  a' = [] \\<and> b = x # l' \\<or>\n  (\\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "moreover"], ["proof (state)\nthis:\n  k = (a', b)\n  a' = [] \\<and> b = x # l' \\<or>\n  (\\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "{"], ["proof (state)\nthis:\n  k = (a', b)\n  a' = [] \\<and> b = x # l' \\<or>\n  (\\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "assume \"a' = []\" \"b = x # l'\""], ["proof (state)\nthis:\n  a' = []\n  b = x # l'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "with \\<open>k = (a', b)\\<close>"], ["proof (chain)\npicking this:\n  k = (a', b)\n  a' = []\n  b = x # l'", "have \"k \\<in> ?S (x # l')\""], ["proof (prove)\nusing this:\n  k = (a', b)\n  a' = []\n  b = x # l'\n\ngoal (1 subgoal):\n 1. k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "by simp"], ["proof (state)\nthis:\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a' = []; b = x # l'\\<rbrakk>\n  \\<Longrightarrow> k \\<in> {a. case a of\n                                (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a' = []; b = x # l'\\<rbrakk>\n  \\<Longrightarrow> k \\<in> {a. case a of\n                                (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a' = []; b = x # l'\\<rbrakk>\n  \\<Longrightarrow> k \\<in> {a. case a of\n                                (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "assume \"\\<exists> a. a' = x # a \\<and> (a, b) \\<in> ?S l'\""], ["proof (state)\nthis:\n  \\<exists>a.\n     a' = x # a \\<and>\n     (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "then"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     a' = x # a \\<and>\n     (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}", "obtain a where\n            \"a' = x # a \\<and> (a, b) \\<in> ?S l'\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     a' = x # a \\<and>\n     (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a' = x # a \\<and>\n        (a, b)\n        \\<in> {a. case a of\n                  (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a' = x # a \\<and>\n  (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "with \\<open>k = (a', b)\\<close>"], ["proof (chain)\npicking this:\n  k = (a', b)\n  a' = x # a \\<and>\n  (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}", "have \"k \\<in> ?S (x # l')\""], ["proof (prove)\nusing this:\n  k = (a', b)\n  a' = x # a \\<and>\n  (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}\n\ngoal (1 subgoal):\n 1. k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "by auto"], ["proof (state)\nthis:\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "}"], ["proof (state)\nthis:\n  \\<exists>a.\n     a' = x # a \\<and>\n     (a, b)\n     \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {a. case a of\n                    (a', b) \\<Rightarrow>\n                      a' = [] \\<and> b = x # l' \\<or>\n                      (\\<exists>a.\n                          a' = x # a \\<and>\n                          (a, b)\n                          \\<in> {a. case a of\n                                    (a, b) \\<Rightarrow>\nl' = a @ b})} \\<Longrightarrow>\n       xa \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "ultimately"], ["proof (chain)\npicking this:\n  k = (a', b)\n  a' = [] \\<and> b = x # l' \\<or>\n  (\\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})\n  \\<lbrakk>a' = []; b = x # l'\\<rbrakk>\n  \\<Longrightarrow> k \\<in> {a. case a of\n                                (a, b) \\<Rightarrow> x # l' = a @ b}\n  \\<exists>a.\n     a' = x # a \\<and>\n     (a, b)\n     \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "show \"k \\<in> ?S (x # l')\""], ["proof (prove)\nusing this:\n  k = (a', b)\n  a' = [] \\<and> b = x # l' \\<or>\n  (\\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})\n  \\<lbrakk>a' = []; b = x # l'\\<rbrakk>\n  \\<Longrightarrow> k \\<in> {a. case a of\n                                (a, b) \\<Rightarrow> x # l' = a @ b}\n  \\<exists>a.\n     a' = x # a \\<and>\n     (a, b)\n     \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal (1 subgoal):\n 1. k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "by auto"], ["proof (state)\nthis:\n  k \\<in> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n  \\<subseteq> {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b} =\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "moreover"], ["proof (state)\nthis:\n  {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b} =\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "have \"?S' x l' = \n      {(a', b). a' = [] \\<and> b = x # l'} \\<union> {(a', b). \\<exists> a. a' = x # a \\<and> (a, b) \\<in> ?S l'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. case a of\n        (a', b) \\<Rightarrow>\n          a' = [] \\<and> b = x # l' \\<or>\n          (\\<exists>a.\n              a' = x # a \\<and>\n              (a, b)\n              \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})} =\n    {(a', b). a' = [] \\<and> b = x # l'} \\<union>\n    {(a', b).\n     \\<exists>a.\n        a' = x # a \\<and>\n        (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}", "by auto"], ["proof (state)\nthis:\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})} =\n  {(a', b). a' = [] \\<and> b = x # l'} \\<union>\n  {(a', b).\n   \\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "moreover"], ["proof (state)\nthis:\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})} =\n  {(a', b). a' = [] \\<and> b = x # l'} \\<union>\n  {(a', b).\n   \\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "have \"finite {(a', b). \\<exists> a. a' = x # a \\<and> (a, b) \\<in> ?S l'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(a', b).\n      \\<exists>a.\n         a' = x # a \\<and>\n         (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {(a', b).\n      \\<exists>a.\n         a' = x # a \\<and>\n         (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}", "let ?h = \"\\<lambda> (a, b). (x # a, b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {(a', b).\n      \\<exists>a.\n         a' = x # a \\<and>\n         (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}", "have \"{(a', b). \\<exists> a. a' = x # a \\<and>  (a, b) \\<in> ?S l'} = ?h ` {(a, b).  l' = a @ b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a', b).\n     \\<exists>a.\n        a' = x # a \\<and>\n        (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}} =\n    (\\<lambda>(a, b). (x # a, b)) ` {(a, b). l' = a @ b}", "by auto"], ["proof (state)\nthis:\n  {(a', b).\n   \\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}} =\n  (\\<lambda>(a, b). (x # a, b)) ` {(a, b). l' = a @ b}\n\ngoal (1 subgoal):\n 1. finite\n     {(a', b).\n      \\<exists>a.\n         a' = x # a \\<and>\n         (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {(a', b).\n   \\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}} =\n  (\\<lambda>(a, b). (x # a, b)) ` {(a, b). l' = a @ b}\n\ngoal (1 subgoal):\n 1. finite\n     {(a', b).\n      \\<exists>a.\n         a' = x # a \\<and>\n         (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}", "using Cons(1)"], ["proof (prove)\nusing this:\n  {(a', b).\n   \\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}} =\n  (\\<lambda>(a, b). (x # a, b)) ` {(a, b). l' = a @ b}\n  finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b}\n\ngoal (1 subgoal):\n 1. finite\n     {(a', b).\n      \\<exists>a.\n         a' = x # a \\<and>\n         (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}", "by auto"], ["proof (state)\nthis:\n  finite\n   {(a', b).\n    \\<exists>a.\n       a' = x # a \\<and>\n       (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {(a', b).\n    \\<exists>a.\n       a' = x # a \\<and>\n       (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "moreover"], ["proof (state)\nthis:\n  finite\n   {(a', b).\n    \\<exists>a.\n       a' = x # a \\<and>\n       (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "have \"finite {(a', b). a' = [] \\<and> b = x # l'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(a', b). a' = [] \\<and> b = x # l'}", "by auto"], ["proof (state)\nthis:\n  finite {(a', b). a' = [] \\<and> b = x # l'}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> l' = a @ b} \\<Longrightarrow>\n    finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "ultimately"], ["proof (chain)\npicking this:\n  {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b} =\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})} =\n  {(a', b). a' = [] \\<and> b = x # l'} \\<union>\n  {(a', b).\n   \\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n  finite\n   {(a', b).\n    \\<exists>a.\n       a' = x # a \\<and>\n       (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n  finite {(a', b). a' = [] \\<and> b = x # l'}", "show ?thesis"], ["proof (prove)\nusing this:\n  {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b} =\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})}\n  {a. case a of\n      (a', b) \\<Rightarrow>\n        a' = [] \\<and> b = x # l' \\<or>\n        (\\<exists>a.\n            a' = x # a \\<and>\n            (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b})} =\n  {(a', b). a' = [] \\<and> b = x # l'} \\<union>\n  {(a', b).\n   \\<exists>a.\n      a' = x # a \\<and>\n      (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n  finite\n   {(a', b).\n    \\<exists>a.\n       a' = x # a \\<and>\n       (a, b) \\<in> {a. case a of (a, b) \\<Rightarrow> l' = a @ b}}\n  finite {(a', b). a' = [] \\<and> b = x # l'}\n\ngoal (1 subgoal):\n 1. finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}", "by auto"], ["proof (state)\nthis:\n  finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {a. case a of (a, b) \\<Rightarrow> x # l' = a @ b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finiteListDecomposeSet:\n  fixes L :: \"'a list set\"\n  assumes \"finite L\"\n  shows \"finite {(a, b). \\<exists> l. l \\<in> L \\<and> l = a @ b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b}", "have \"{(a, b). \\<exists> l. l \\<in> L \\<and> l = a @ b} = (\\<Union> l \\<in> L. {(a, b). l = a @ b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b} =\n    (\\<Union>l\\<in>L. {(a, b). l = a @ b})", "by auto"], ["proof (state)\nthis:\n  {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b} =\n  (\\<Union>l\\<in>L. {(a, b). l = a @ b})\n\ngoal (1 subgoal):\n 1. finite {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b}", "moreover"], ["proof (state)\nthis:\n  {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b} =\n  (\\<Union>l\\<in>L. {(a, b). l = a @ b})\n\ngoal (1 subgoal):\n 1. finite {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b}", "have \"finite (\\<Union> l \\<in> L. {(a, b). l = a @ b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>l\\<in>L. {(a, b). l = a @ b})", "proof (rule finite_UN_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite L\n 2. \\<And>l. l \\<in> L \\<Longrightarrow> finite {(a, b). l = a @ b}", "from \\<open>finite L\\<close>"], ["proof (chain)\npicking this:\n  finite L", "show \"finite L\""], ["proof (prove)\nusing this:\n  finite L\n\ngoal (1 subgoal):\n 1. finite L", "."], ["proof (state)\nthis:\n  finite L\n\ngoal (1 subgoal):\n 1. \\<And>l. l \\<in> L \\<Longrightarrow> finite {(a, b). l = a @ b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. l \\<in> L \\<Longrightarrow> finite {(a, b). l = a @ b}", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. l \\<in> L \\<Longrightarrow> finite {(a, b). l = a @ b}", "assume \"l \\<in> L\""], ["proof (state)\nthis:\n  l \\<in> L\n\ngoal (1 subgoal):\n 1. \\<And>l. l \\<in> L \\<Longrightarrow> finite {(a, b). l = a @ b}", "show \"finite {(a, b). l = a @ b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(a, b). l = a @ b}", "by (rule finiteListDecompose)"], ["proof (state)\nthis:\n  finite {(a, b). l = a @ b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (\\<Union>l\\<in>L. {(a, b). l = a @ b})\n\ngoal (1 subgoal):\n 1. finite {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b}", "ultimately"], ["proof (chain)\npicking this:\n  {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b} =\n  (\\<Union>l\\<in>L. {(a, b). l = a @ b})\n  finite (\\<Union>l\\<in>L. {(a, b). l = a @ b})", "show ?thesis"], ["proof (prove)\nusing this:\n  {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b} =\n  (\\<Union>l\\<in>L. {(a, b). l = a @ b})\n  finite (\\<Union>l\\<in>L. {(a, b). l = a @ b})\n\ngoal (1 subgoal):\n 1. finite {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b}", "by simp"], ["proof (state)\nthis:\n  finite {(a, b). \\<exists>l. l \\<in> L \\<and> l = a @ b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finiteUniqAndConsistentTrailsWithGivenVariableSet: \n  fixes V :: \"Variable set\"\n  assumes \"finite V\"\n  shows \"finite {(M::LiteralTrail). vars (elements M) = V \\<and> uniq (elements M) \\<and> consistent (elements M)}\"\n        (is \"finite (?trails V)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "using assms"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite\n         {M. vars (elements M) = F \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {M. vars (elements M) = insert x F \\<and>\n                              uniq (elements M) \\<and>\n                              consistent (elements M)}", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite\n         {M. vars (elements M) = F \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {M. vars (elements M) = insert x F \\<and>\n                              uniq (elements M) \\<and>\n                              consistent (elements M)}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "have \"?trails {} = {M. M = []}\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {M. vars (elements M) = {} \\<and>\n        uniq (elements M) \\<and> consistent (elements M)} =\n    {M. M = []}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {M. vars (elements M) = {} \\<and>\n        uniq (elements M) \\<and> consistent (elements M)}\n    \\<subseteq> {M. M = []}\n 2. {M. M = []}\n    \\<subseteq> {M. vars (elements M) = {} \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {M. vars (elements M) = {} \\<and>\n        uniq (elements M) \\<and> consistent (elements M)}\n    \\<subseteq> {M. M = []}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M. M = []}", "fix M::LiteralTrail"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M. M = []}", "assume \"M \\<in> ?lhs\""], ["proof (state)\nthis:\n  M \\<in> {M. vars (elements M) = {} \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M. M = []}", "hence \"M = []\""], ["proof (prove)\nusing this:\n  M \\<in> {M. vars (elements M) = {} \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. M = []", "by (induct M) auto"], ["proof (state)\nthis:\n  M = []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M. M = []}", "thus \"M \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  M = []\n\ngoal (1 subgoal):\n 1. M \\<in> {M. M = []}", "by simp"], ["proof (state)\nthis:\n  M \\<in> {M. M = []}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M. vars (elements M) = {} \\<and>\n      uniq (elements M) \\<and> consistent (elements M)}\n  \\<subseteq> {M. M = []}\n\ngoal (1 subgoal):\n 1. {M. M = []}\n    \\<subseteq> {M. vars (elements M) = {} \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {M. M = []}\n    \\<subseteq> {M. vars (elements M) = {} \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {M. M = []}\n    \\<subseteq> {M. vars (elements M) = {} \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. M = []} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "fix M::LiteralTrail"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. M = []} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "assume \"M \\<in> ?rhs\""], ["proof (state)\nthis:\n  M \\<in> {M. M = []}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. M = []} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "hence \"M = []\""], ["proof (prove)\nusing this:\n  M \\<in> {M. M = []}\n\ngoal (1 subgoal):\n 1. M = []", "by simp"], ["proof (state)\nthis:\n  M = []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. M = []} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = {} \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "thus \"M \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  M = []\n\ngoal (1 subgoal):\n 1. M \\<in> {M. vars (elements M) = {} \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}", "by (induct M) auto"], ["proof (state)\nthis:\n  M \\<in> {M. vars (elements M) = {} \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M. M = []}\n  \\<subseteq> {M. vars (elements M) = {} \\<and>\n                  uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M. vars (elements M) = {} \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M. M = []}\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  {M. vars (elements M) = {} \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M. M = []}\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "have \"finite {M. M = []}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {M. M = []}", "by auto"], ["proof (state)\nthis:\n  finite {M. M = []}\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "ultimately"], ["proof (chain)\npicking this:\n  {M. vars (elements M) = {} \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M. M = []}\n  finite {M. M = []}", "show ?thesis"], ["proof (prove)\nusing this:\n  {M. vars (elements M) = {} \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M. M = []}\n  finite {M. M = []}\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = {} \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "by auto"], ["proof (state)\nthis:\n  finite\n   {M. vars (elements M) = {} \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {M. vars (elements M) = {} \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite\n         {M. vars (elements M) = F \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {M. vars (elements M) = insert x F \\<and>\n                              uniq (elements M) \\<and>\n                              consistent (elements M)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite\n         {M. vars (elements M) = F \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {M. vars (elements M) = insert x F \\<and>\n                              uniq (elements M) \\<and>\n                              consistent (elements M)}", "case (insert v V')"], ["proof (state)\nthis:\n  finite V'\n  v \\<notin> V'\n  finite\n   {M. vars (elements M) = V' \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite\n         {M. vars (elements M) = F \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {M. vars (elements M) = insert x F \\<and>\n                              uniq (elements M) \\<and>\n                              consistent (elements M)}", "thus ?case"], ["proof (prove)\nusing this:\n  finite V'\n  v \\<notin> V'\n  finite\n   {M. vars (elements M) = V' \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = insert v V' \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "let \"?trails' V'\" = \"{(M::LiteralTrail). \\<exists> M' l d M''. \n                                M = M' @ [(l, d)] @ M'' \\<and>\n                                M' @ M'' \\<in> (?trails V') \\<and>\n                                l \\<in> {Pos v, Neg v} \\<and>\n                                d \\<in> {True, False}}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "have \"?trails (insert v V') = ?trails' V'\"\n      (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {M. vars (elements M) = insert v V' \\<and>\n        uniq (elements M) \\<and> consistent (elements M)} =\n    {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {M. vars (elements M) = insert v V' \\<and>\n        uniq (elements M) \\<and> consistent (elements M)}\n    \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)} \\<and>\n                 l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n 2. {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n    \\<subseteq> {M. vars (elements M) = insert v V' \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {M. vars (elements M) = insert v V' \\<and>\n        uniq (elements M) \\<and> consistent (elements M)}\n    \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)} \\<and>\n                 l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "fix M::LiteralTrail"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "assume \"M \\<in> ?lhs\""], ["proof (state)\nthis:\n  M \\<in> {M. vars (elements M) = insert v V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "hence \"vars (elements M) = insert v V'\" \"uniq (elements M)\" \"consistent (elements M)\""], ["proof (prove)\nusing this:\n  M \\<in> {M. vars (elements M) = insert v V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. vars (elements M) = insert v V' &&&\n    uniq (elements M) &&& consistent (elements M)", "by auto"], ["proof (state)\nthis:\n  vars (elements M) = insert v V'\n  uniq (elements M)\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "hence \"v \\<in> vars (elements M)\""], ["proof (prove)\nusing this:\n  vars (elements M) = insert v V'\n  uniq (elements M)\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. v \\<in> vars (elements M)", "by simp"], ["proof (state)\nthis:\n  v \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "hence \"\\<exists> l. l el elements M \\<and> var l = v\""], ["proof (prove)\nusing this:\n  v \\<in> vars (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>l. l el elements M \\<and> var l = v", "by (induct M) auto"], ["proof (state)\nthis:\n  \\<exists>l. l el elements M \\<and> var l = v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. l el elements M \\<and> var l = v", "obtain l where \"l el elements M\" \"var l = v\""], ["proof (prove)\nusing this:\n  \\<exists>l. l el elements M \\<and> var l = v\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el elements M; var l = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l el elements M\n  var l = v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "hence \"\\<exists> M' M'' d. M = M' @ [(l, d)] @ M''\""], ["proof (prove)\nusing this:\n  l el elements M\n  var l = v\n\ngoal (1 subgoal):\n 1. \\<exists>M' M'' d. M = M' @ [(l, d)] @ M''", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l el elements []; var l = v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. [] = M' @ [(l, d)] @ M''\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>l el elements M; var l = v\\<rbrakk>\n                \\<Longrightarrow> \\<exists>M' M'' d.\n                                     M = M' @ [(l, d)] @ M'';\n        l el elements (a # M); var l = v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M' M'' d. a # M = M' @ [(l, d)] @ M''", "case (Cons m M1)"], ["proof (state)\nthis:\n  \\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M''\n  l el elements (m # M1)\n  var l = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l el elements []; var l = v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. [] = M' @ [(l, d)] @ M''\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>l el elements M; var l = v\\<rbrakk>\n                \\<Longrightarrow> \\<exists>M' M'' d.\n                                     M = M' @ [(l, d)] @ M'';\n        l el elements (a # M); var l = v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M' M'' d. a # M = M' @ [(l, d)] @ M''", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M''\n  l el elements (m # M1)\n  var l = v\n\ngoal (1 subgoal):\n 1. \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "proof (cases \"l = (element m)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l = element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n 2. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "case True"], ["proof (state)\nthis:\n  l = element m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l = element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n 2. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "then"], ["proof (chain)\npicking this:\n  l = element m", "obtain d where \"m = (l, d)\""], ["proof (prove)\nusing this:\n  l = element m\n\ngoal (1 subgoal):\n 1. (\\<And>d. m = (l, d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using eitherMarkedOrNotMarkedElement[of \"m\"]"], ["proof (prove)\nusing this:\n  l = element m\n  m = (element m, True) \\<or> m = (element m, False)\n\ngoal (1 subgoal):\n 1. (\\<And>d. m = (l, d) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  m = (l, d)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l = element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n 2. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "hence \"m # M1 = [] @ [(l, d)] @ M1\""], ["proof (prove)\nusing this:\n  m = (l, d)\n\ngoal (1 subgoal):\n 1. m # M1 = [] @ [(l, d)] @ M1", "by simp"], ["proof (state)\nthis:\n  m # M1 = [] @ [(l, d)] @ M1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l = element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n 2. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "then"], ["proof (chain)\npicking this:\n  m # M1 = [] @ [(l, d)] @ M1", "obtain M' M'' d where \"m # M1 = M' @ [(l, d)] @ M''\""], ["proof (prove)\nusing this:\n  m # M1 = [] @ [(l, d)] @ M1\n\ngoal (1 subgoal):\n 1. (\\<And>M' d M''.\n        m # M1 = M' @ [(l, d)] @ M'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  m # M1 = M' @ [(l, d)] @ M''\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l = element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n 2. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "thus ?thesis"], ["proof (prove)\nusing this:\n  m # M1 = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "by auto"], ["proof (state)\nthis:\n  \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "case False"], ["proof (state)\nthis:\n  l \\<noteq> element m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "with \\<open>l el elements (m # M1)\\<close>"], ["proof (chain)\npicking this:\n  l el elements (m # M1)\n  l \\<noteq> element m", "have \"l el elements M1\""], ["proof (prove)\nusing this:\n  l el elements (m # M1)\n  l \\<noteq> element m\n\ngoal (1 subgoal):\n 1. l el elements M1", "by simp"], ["proof (state)\nthis:\n  l el elements M1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "with Cons(1) \\<open>var l = v\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M''\n  var l = v\n  l el elements M1", "obtain M1' M'' d where \"M1 = M1' @ [(l, d)] @ M''\""], ["proof (prove)\nusing this:\n  \\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M''\n  var l = v\n  l el elements M1\n\ngoal (1 subgoal):\n 1. (\\<And>M1' d M''.\n        M1 = M1' @ [(l, d)] @ M'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M1 = M1' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "hence \"m # M1 = (m # M1') @ [(l, d)] @ M''\""], ["proof (prove)\nusing this:\n  M1 = M1' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. m # M1 = (m # M1') @ [(l, d)] @ M''", "by simp"], ["proof (state)\nthis:\n  m # M1 = (m # M1') @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "then"], ["proof (chain)\npicking this:\n  m # M1 = (m # M1') @ [(l, d)] @ M''", "obtain M' M'' d where \"m # M1 = M' @ [(l, d)] @ M''\""], ["proof (prove)\nusing this:\n  m # M1 = (m # M1') @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. (\\<And>M' d M''.\n        m # M1 = M' @ [(l, d)] @ M'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  m # M1 = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l el elements M1; var l = v\\<rbrakk>\n             \\<Longrightarrow> \\<exists>M' M'' d. M1 = M' @ [(l, d)] @ M'';\n     l el elements (m # M1); var l = v; l \\<noteq> element m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "thus ?thesis"], ["proof (prove)\nusing this:\n  m # M1 = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''", "by auto"], ["proof (state)\nthis:\n  \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M' M'' d. m # M1 = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el elements []; var l = v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M' M'' d. [] = M' @ [(l, d)] @ M''", "qed simp"], ["proof (state)\nthis:\n  \\<exists>M' M'' d. M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "then"], ["proof (chain)\npicking this:\n  \\<exists>M' M'' d. M = M' @ [(l, d)] @ M''", "obtain M' M'' d where \"M = M' @ [(l, d)] @ M''\""], ["proof (prove)\nusing this:\n  \\<exists>M' M'' d. M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. (\\<And>M' d M''.\n        M = M' @ [(l, d)] @ M'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "moreover"], ["proof (state)\nthis:\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "from \\<open>var l = v\\<close>"], ["proof (chain)\npicking this:\n  var l = v", "have \"l : {Pos v, Neg v}\""], ["proof (prove)\nusing this:\n  var l = v\n\ngoal (1 subgoal):\n 1. l \\<in> {Pos v, Neg v}", "by (cases l) auto"], ["proof (state)\nthis:\n  l \\<in> {Pos v, Neg v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "moreover"], ["proof (state)\nthis:\n  l \\<in> {Pos v, Neg v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "have *: \"vars (elements (M' @ M'')) = vars (elements M') \\<union> vars (elements M'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (elements (M' @ M'')) =\n    vars (elements M') \\<union> vars (elements M'')", "using varsAppendClauses[of \"elements M'\" \"elements M''\"]"], ["proof (prove)\nusing this:\n  vars (elements M' @ elements M'') =\n  vars (elements M') \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. vars (elements (M' @ M'')) =\n    vars (elements M') \\<union> vars (elements M'')", "by simp"], ["proof (state)\nthis:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "from \\<open>M = M' @ [(l, d)] @ M''\\<close> \\<open>var l = v\\<close>"], ["proof (chain)\npicking this:\n  M = M' @ [(l, d)] @ M''\n  var l = v", "have **: \"vars (elements M) = (vars (elements M')) \\<union> {v} \\<union> (vars (elements M''))\""], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  var l = v\n\ngoal (1 subgoal):\n 1. vars (elements M) =\n    vars (elements M') \\<union> {v} \\<union> vars (elements M'')", "using varsAppendClauses[of \"elements M'\" \"elements ([(l, d)] @ M'')\"]"], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  var l = v\n  vars (elements M' @ elements ([(l, d)] @ M'')) =\n  vars (elements M') \\<union> vars (elements ([(l, d)] @ M''))\n\ngoal (1 subgoal):\n 1. vars (elements M) =\n    vars (elements M') \\<union> {v} \\<union> vars (elements M'')", "using varsAppendClauses[of \"elements [(l, d)]\" \"elements M''\"]"], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  var l = v\n  vars (elements M' @ elements ([(l, d)] @ M'')) =\n  vars (elements M') \\<union> vars (elements ([(l, d)] @ M''))\n  vars (elements [(l, d)] @ elements M'') =\n  vars (elements [(l, d)]) \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. vars (elements M) =\n    vars (elements M') \\<union> {v} \\<union> vars (elements M'')", "by simp"], ["proof (state)\nthis:\n  vars (elements M) =\n  vars (elements M') \\<union> {v} \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "have ***: \"vars (elements M) = vars (elements (M' @ M'')) \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (elements M) = vars (elements (M' @ M'')) \\<union> {v}", "using * **"], ["proof (prove)\nusing this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  vars (elements M) =\n  vars (elements M') \\<union> {v} \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. vars (elements M) = vars (elements (M' @ M'')) \\<union> {v}", "by simp"], ["proof (state)\nthis:\n  vars (elements M) = vars (elements (M' @ M'')) \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "have \"M' @ M'' \\<in> (?trails V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "from \\<open>uniq (elements M)\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  M = M' @ [(l, d)] @ M''", "have \"uniq (elements (M' @ M''))\""], ["proof (prove)\nusing this:\n  uniq (elements M)\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. uniq (elements (M' @ M''))", "by (auto iff: uniqAppendIff)"], ["proof (state)\nthis:\n  uniq (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  uniq (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "have \"consistent (elements (M' @ M''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "assume \"\\<not> consistent (elements (M' @ M''))\""], ["proof (state)\nthis:\n  \\<not> consistent (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "then"], ["proof (chain)\npicking this:\n  \\<not> consistent (elements (M' @ M''))", "obtain l' where \"literalTrue l' (elements (M' @ M''))\" \"literalFalse l' (elements (M' @ M''))\""], ["proof (prove)\nusing this:\n  \\<not> consistent (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>literalTrue l' (elements (M' @ M''));\n         literalFalse l' (elements (M' @ M''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  literalTrue l' (elements (M' @ M''))\n  literalFalse l' (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "with \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  M = M' @ [(l, d)] @ M''\n  literalTrue l' (elements (M' @ M''))\n  literalFalse l' (elements (M' @ M''))", "have \"literalTrue l' (elements M)\" \"literalFalse l' (elements M)\""], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  literalTrue l' (elements (M' @ M''))\n  literalFalse l' (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. literalTrue l' (elements M) &&& literalFalse l' (elements M)", "by auto"], ["proof (state)\nthis:\n  literalTrue l' (elements M)\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "hence \"\\<not> consistent (elements M)\""], ["proof (prove)\nusing this:\n  literalTrue l' (elements M)\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "by (auto simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "with \\<open>consistent (elements M)\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements M)\n  \\<not> consistent (elements M)", "have False"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  \\<not> consistent (elements (M' @ M'')) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> consistent (elements (M' @ M'')) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (elements (M' @ M''))", "by auto"], ["proof (state)\nthis:\n  consistent (elements (M' @ M''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consistent (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  consistent (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "have \"v \\<notin> vars (elements (M' @ M''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "assume \"v \\<in> vars (elements (M' @ M''))\""], ["proof (state)\nthis:\n  v \\<in> vars (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "with *"], ["proof (chain)\npicking this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  v \\<in> vars (elements (M' @ M''))", "have \"v \\<in> vars (elements M') \\<or> v \\<in> vars (elements M'')\""], ["proof (prove)\nusing this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  v \\<in> vars (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. v \\<in> vars (elements M') \\<or> v \\<in> vars (elements M'')", "by simp"], ["proof (state)\nthis:\n  v \\<in> vars (elements M') \\<or> v \\<in> vars (elements M'')\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "moreover"], ["proof (state)\nthis:\n  v \\<in> vars (elements M') \\<or> v \\<in> vars (elements M'')\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "{"], ["proof (state)\nthis:\n  v \\<in> vars (elements M') \\<or> v \\<in> vars (elements M'')\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "assume \"v \\<in> (vars (elements M'))\""], ["proof (state)\nthis:\n  v \\<in> vars (elements M')\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "hence \"\\<exists> l. var l = v \\<and> l el elements M'\""], ["proof (prove)\nusing this:\n  v \\<in> vars (elements M')\n\ngoal (1 subgoal):\n 1. \\<exists>l. var l = v \\<and> l el elements M'", "by (induct M') auto"], ["proof (state)\nthis:\n  \\<exists>l. var l = v \\<and> l el elements M'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. var l = v \\<and> l el elements M'", "obtain l' where \"var l' = v\" \"l' el elements M'\""], ["proof (prove)\nusing this:\n  \\<exists>l. var l = v \\<and> l el elements M'\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>var l' = v; l' el elements M'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l' = v\n  l' el elements M'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "from \\<open>var l = v\\<close> \\<open>var l' = v\\<close>"], ["proof (chain)\npicking this:\n  var l = v\n  var l' = v", "have \"l = l' \\<or> opposite l = l'\""], ["proof (prove)\nusing this:\n  var l = v\n  var l' = v\n\ngoal (1 subgoal):\n 1. l = l' \\<or> opposite l = l'", "using literalsWithSameVariableAreEqualOrOpposite[of \"l\" \"l'\"]"], ["proof (prove)\nusing this:\n  var l = v\n  var l' = v\n  (var l = var l') = (l = l' \\<or> opposite l = l')\n\ngoal (1 subgoal):\n 1. l = l' \\<or> opposite l = l'", "by simp"], ["proof (state)\nthis:\n  l = l' \\<or> opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "moreover"], ["proof (state)\nthis:\n  l = l' \\<or> opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "{"], ["proof (state)\nthis:\n  l = l' \\<or> opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "assume \"l = l'\""], ["proof (state)\nthis:\n  l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "with \\<open>l' el elements M'\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  l' el elements M'\n  M = M' @ [(l, d)] @ M''\n  l = l'", "have \"\\<not> uniq (elements M)\""], ["proof (prove)\nusing this:\n  l' el elements M'\n  M = M' @ [(l, d)] @ M''\n  l = l'\n\ngoal (1 subgoal):\n 1. \\<not> uniq (elements M)", "by (auto iff: uniqAppendIff)"], ["proof (state)\nthis:\n  \\<not> uniq (elements M)\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "with \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  \\<not> uniq (elements M)", "have False"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  \\<not> uniq (elements M)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "moreover"], ["proof (state)\nthis:\n  l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "{"], ["proof (state)\nthis:\n  l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "assume \"opposite l = l'\""], ["proof (state)\nthis:\n  opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "have \"\\<not> consistent (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "from \\<open>l' el elements M'\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  l' el elements M'\n  M = M' @ [(l, d)] @ M''", "have \"literalTrue l' (elements M)\""], ["proof (prove)\nusing this:\n  l' el elements M'\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. literalTrue l' (elements M)", "by simp"], ["proof (state)\nthis:\n  literalTrue l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "moreover"], ["proof (state)\nthis:\n  literalTrue l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "from \\<open>l' el elements M'\\<close> \\<open>opposite l = l'\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  l' el elements M'\n  opposite l = l'\n  M = M' @ [(l, d)] @ M''", "have \"literalFalse l' (elements M)\""], ["proof (prove)\nusing this:\n  l' el elements M'\n  opposite l = l'\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements M)", "by simp"], ["proof (state)\nthis:\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "ultimately"], ["proof (chain)\npicking this:\n  literalTrue l' (elements M)\n  literalFalse l' (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue l' (elements M)\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "by (auto simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> consistent (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "with \\<open>consistent (elements M)\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements M)\n  \\<not> consistent (elements M)", "have False"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  opposite l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "ultimately"], ["proof (chain)\npicking this:\n  l = l' \\<or> opposite l = l'\n  l = l' \\<Longrightarrow> False\n  opposite l = l' \\<Longrightarrow> False", "have False"], ["proof (prove)\nusing this:\n  l = l' \\<or> opposite l = l'\n  l = l' \\<Longrightarrow> False\n  opposite l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  v \\<in> vars (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "moreover"], ["proof (state)\nthis:\n  v \\<in> vars (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "{"], ["proof (state)\nthis:\n  v \\<in> vars (elements M') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "assume \"v \\<in> (vars (elements M''))\""], ["proof (state)\nthis:\n  v \\<in> vars (elements M'')\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "hence \"\\<exists> l. var l = v \\<and> l el elements M''\""], ["proof (prove)\nusing this:\n  v \\<in> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<exists>l. var l = v \\<and> l el elements M''", "by (induct M'') auto"], ["proof (state)\nthis:\n  \\<exists>l. var l = v \\<and> l el elements M''\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. var l = v \\<and> l el elements M''", "obtain l' where \"var l' = v\" \"l' el (elements M'')\""], ["proof (prove)\nusing this:\n  \\<exists>l. var l = v \\<and> l el elements M''\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>var l' = v; l' el elements M''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l' = v\n  l' el elements M''\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "from \\<open>var l = v\\<close> \\<open>var l' = v\\<close>"], ["proof (chain)\npicking this:\n  var l = v\n  var l' = v", "have \"l = l' \\<or> opposite l = l'\""], ["proof (prove)\nusing this:\n  var l = v\n  var l' = v\n\ngoal (1 subgoal):\n 1. l = l' \\<or> opposite l = l'", "using literalsWithSameVariableAreEqualOrOpposite[of \"l\" \"l'\"]"], ["proof (prove)\nusing this:\n  var l = v\n  var l' = v\n  (var l = var l') = (l = l' \\<or> opposite l = l')\n\ngoal (1 subgoal):\n 1. l = l' \\<or> opposite l = l'", "by simp"], ["proof (state)\nthis:\n  l = l' \\<or> opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "moreover"], ["proof (state)\nthis:\n  l = l' \\<or> opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "{"], ["proof (state)\nthis:\n  l = l' \\<or> opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "assume \"l = l'\""], ["proof (state)\nthis:\n  l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "with \\<open>l' el elements M''\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  l' el elements M''\n  M = M' @ [(l, d)] @ M''\n  l = l'", "have \"\\<not> uniq (elements M)\""], ["proof (prove)\nusing this:\n  l' el elements M''\n  M = M' @ [(l, d)] @ M''\n  l = l'\n\ngoal (1 subgoal):\n 1. \\<not> uniq (elements M)", "by (auto iff: uniqAppendIff)"], ["proof (state)\nthis:\n  \\<not> uniq (elements M)\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "with \\<open>uniq (elements M)\\<close>"], ["proof (chain)\npicking this:\n  uniq (elements M)\n  \\<not> uniq (elements M)", "have False"], ["proof (prove)\nusing this:\n  uniq (elements M)\n  \\<not> uniq (elements M)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "moreover"], ["proof (state)\nthis:\n  l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "{"], ["proof (state)\nthis:\n  l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "assume \"opposite l = l'\""], ["proof (state)\nthis:\n  opposite l = l'\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "have \"\\<not> consistent (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "from \\<open>l' el elements M''\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  l' el elements M''\n  M = M' @ [(l, d)] @ M''", "have \"literalTrue l' (elements M)\""], ["proof (prove)\nusing this:\n  l' el elements M''\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. literalTrue l' (elements M)", "by simp"], ["proof (state)\nthis:\n  literalTrue l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "moreover"], ["proof (state)\nthis:\n  literalTrue l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "from \\<open>l' el elements M''\\<close> \\<open>opposite l = l'\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  l' el elements M''\n  opposite l = l'\n  M = M' @ [(l, d)] @ M''", "have \"literalFalse l' (elements M)\""], ["proof (prove)\nusing this:\n  l' el elements M''\n  opposite l = l'\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements M)", "by simp"], ["proof (state)\nthis:\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "ultimately"], ["proof (chain)\npicking this:\n  literalTrue l' (elements M)\n  literalFalse l' (elements M)", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue l' (elements M)\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. \\<not> consistent (elements M)", "by (auto simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> consistent (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "with \\<open>consistent (elements M)\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements M)\n  \\<not> consistent (elements M)", "have False"], ["proof (prove)\nusing this:\n  consistent (elements M)\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  opposite l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "ultimately"], ["proof (chain)\npicking this:\n  l = l' \\<or> opposite l = l'\n  l = l' \\<Longrightarrow> False\n  opposite l = l' \\<Longrightarrow> False", "have False"], ["proof (prove)\nusing this:\n  l = l' \\<or> opposite l = l'\n  l = l' \\<Longrightarrow> False\n  opposite l = l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  v \\<in> vars (elements M'') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> vars (elements M') \\<or> v \\<in> vars (elements M'')\n  v \\<in> vars (elements M') \\<Longrightarrow> False\n  v \\<in> vars (elements M'') \\<Longrightarrow> False", "have False"], ["proof (prove)\nusing this:\n  v \\<in> vars (elements M') \\<or> v \\<in> vars (elements M'')\n  v \\<in> vars (elements M') \\<Longrightarrow> False\n  v \\<in> vars (elements M'') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "}"], ["proof (state)\nthis:\n  v \\<in> vars (elements (M' @ M'')) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> vars (elements (M' @ M'')) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (elements (M' @ M''))", "by auto"], ["proof (state)\nthis:\n  v \\<notin> vars (elements (M' @ M''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> vars (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "from \n            * ** ***\n            \\<open>v \\<notin> vars (elements (M' @ M''))\\<close> \n            \\<open>vars (elements M) = insert v V'\\<close> \n            \\<open>\\<not> v \\<in> V'\\<close>"], ["proof (chain)\npicking this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  vars (elements M) =\n  vars (elements M') \\<union> {v} \\<union> vars (elements M'')\n  vars (elements M) = vars (elements (M' @ M'')) \\<union> {v}\n  v \\<notin> vars (elements (M' @ M''))\n  vars (elements M) = insert v V'\n  v \\<notin> V'", "have \"vars (elements (M' @ M'')) = V'\""], ["proof (prove)\nusing this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  vars (elements M) =\n  vars (elements M') \\<union> {v} \\<union> vars (elements M'')\n  vars (elements M) = vars (elements (M' @ M'')) \\<union> {v}\n  v \\<notin> vars (elements (M' @ M''))\n  vars (elements M) = insert v V'\n  v \\<notin> V'\n\ngoal (1 subgoal):\n 1. vars (elements (M' @ M'')) = V'", "by (auto simp del: vars_clause_def)"], ["proof (state)\nthis:\n  vars (elements (M' @ M'')) = V'\n\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "ultimately"], ["proof (chain)\npicking this:\n  uniq (elements (M' @ M''))\n  consistent (elements (M' @ M''))\n  vars (elements (M' @ M'')) = V'", "show ?thesis"], ["proof (prove)\nusing this:\n  uniq (elements (M' @ M''))\n  consistent (elements (M' @ M''))\n  vars (elements (M' @ M'')) = V'\n\ngoal (1 subgoal):\n 1. M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}", "by simp"], ["proof (state)\nthis:\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)} \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "ultimately"], ["proof (chain)\npicking this:\n  M = M' @ [(l, d)] @ M''\n  l \\<in> {Pos v, Neg v}\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}", "show \"M \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  l \\<in> {Pos v, Neg v}\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n             M' @ M''\n             \\<in> {M. vars (elements M) = V' \\<and>\n                       uniq (elements M) \\<and>\n                       consistent (elements M)} \\<and>\n             l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "by auto"], ["proof (state)\nthis:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M. vars (elements M) = insert v V' \\<and>\n      uniq (elements M) \\<and> consistent (elements M)}\n  \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n               M' @ M''\n               \\<in> {M. vars (elements M) = V' \\<and>\n                         uniq (elements M) \\<and>\n                         consistent (elements M)} \\<and>\n               l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal (1 subgoal):\n 1. {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n    \\<subseteq> {M. vars (elements M) = insert v V' \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n    \\<subseteq> {M. vars (elements M) = insert v V' \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n    \\<subseteq> {M. vars (elements M) = insert v V' \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "fix M :: LiteralTrail"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "assume \"M \\<in> ?rhs\""], ["proof (state)\nthis:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "then"], ["proof (chain)\npicking this:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "obtain M' M'' l d where \n          \"M = M' @ [(l, d)] @ M''\"\n          \"vars (elements (M' @ M'')) = V'\" \n          \"uniq (elements (M' @ M''))\" \"consistent (elements (M' @ M''))\" \"l \\<in> {Pos v, Neg v}\""], ["proof (prove)\nusing this:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal (1 subgoal):\n 1. (\\<And>M' l d M''.\n        \\<lbrakk>M = M' @ [(l, d)] @ M''; vars (elements (M' @ M'')) = V';\n         uniq (elements (M' @ M'')); consistent (elements (M' @ M''));\n         l \\<in> {Pos v, Neg v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = M' @ [(l, d)] @ M''\n  vars (elements (M' @ M'')) = V'\n  uniq (elements (M' @ M''))\n  consistent (elements (M' @ M''))\n  l \\<in> {Pos v, Neg v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "from \\<open>l \\<in> {Pos v, Neg v}\\<close>"], ["proof (chain)\npicking this:\n  l \\<in> {Pos v, Neg v}", "have \"var l = v\""], ["proof (prove)\nusing this:\n  l \\<in> {Pos v, Neg v}\n\ngoal (1 subgoal):\n 1. var l = v", "by auto"], ["proof (state)\nthis:\n  var l = v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "have *: \"vars (elements (M' @ M'')) = vars (elements M') \\<union> vars (elements M'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (elements (M' @ M'')) =\n    vars (elements M') \\<union> vars (elements M'')", "using varsAppendClauses[of \"elements M'\" \"elements M''\"]"], ["proof (prove)\nusing this:\n  vars (elements M' @ elements M'') =\n  vars (elements M') \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. vars (elements (M' @ M'')) =\n    vars (elements M') \\<union> vars (elements M'')", "by simp"], ["proof (state)\nthis:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "from \\<open>var l = v\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  var l = v\n  M = M' @ [(l, d)] @ M''", "have **: \"vars (elements M) = vars (elements M') \\<union> {v} \\<union> vars (elements M'')\""], ["proof (prove)\nusing this:\n  var l = v\n  M = M' @ [(l, d)] @ M''\n\ngoal (1 subgoal):\n 1. vars (elements M) =\n    vars (elements M') \\<union> {v} \\<union> vars (elements M'')", "using varsAppendClauses[of \"elements M'\" \"elements ([(l, d)] @ M'')\"]"], ["proof (prove)\nusing this:\n  var l = v\n  M = M' @ [(l, d)] @ M''\n  vars (elements M' @ elements ([(l, d)] @ M'')) =\n  vars (elements M') \\<union> vars (elements ([(l, d)] @ M''))\n\ngoal (1 subgoal):\n 1. vars (elements M) =\n    vars (elements M') \\<union> {v} \\<union> vars (elements M'')", "using varsAppendClauses[of \"elements [(l, d)]\" \"elements M''\"]"], ["proof (prove)\nusing this:\n  var l = v\n  M = M' @ [(l, d)] @ M''\n  vars (elements M' @ elements ([(l, d)] @ M'')) =\n  vars (elements M') \\<union> vars (elements ([(l, d)] @ M''))\n  vars (elements [(l, d)] @ elements M'') =\n  vars (elements [(l, d)]) \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. vars (elements M) =\n    vars (elements M') \\<union> {v} \\<union> vars (elements M'')", "by simp"], ["proof (state)\nthis:\n  vars (elements M) =\n  vars (elements M') \\<union> {v} \\<union> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "from * ** \\<open>vars (elements (M' @ M'')) = V'\\<close>"], ["proof (chain)\npicking this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  vars (elements M) =\n  vars (elements M') \\<union> {v} \\<union> vars (elements M'')\n  vars (elements (M' @ M'')) = V'", "have \"vars (elements M) = insert v V'\""], ["proof (prove)\nusing this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  vars (elements M) =\n  vars (elements M') \\<union> {v} \\<union> vars (elements M'')\n  vars (elements (M' @ M'')) = V'\n\ngoal (1 subgoal):\n 1. vars (elements M) = insert v V'", "by (auto simp del: vars_clause_def)"], ["proof (state)\nthis:\n  vars (elements M) = insert v V'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  vars (elements M) = insert v V'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "from *\n          \\<open>var l = v\\<close> \n          \\<open>v \\<notin> V'\\<close> \n          \\<open>vars (elements (M' @ M'')) = V'\\<close>"], ["proof (chain)\npicking this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  var l = v\n  v \\<notin> V'\n  vars (elements (M' @ M'')) = V'", "have \"var l \\<notin> vars (elements M')\" \"var l \\<notin> vars (elements M'')\""], ["proof (prove)\nusing this:\n  vars (elements (M' @ M'')) =\n  vars (elements M') \\<union> vars (elements M'')\n  var l = v\n  v \\<notin> V'\n  vars (elements (M' @ M'')) = V'\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars (elements M') &&& var l \\<notin> vars (elements M'')", "by auto"], ["proof (state)\nthis:\n  var l \\<notin> vars (elements M')\n  var l \\<notin> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "from \\<open>var l \\<notin> vars (elements M')\\<close>"], ["proof (chain)\npicking this:\n  var l \\<notin> vars (elements M')", "have \"\\<not> literalTrue l (elements M')\" \"\\<not> literalFalse l (elements M')\""], ["proof (prove)\nusing this:\n  var l \\<notin> vars (elements M')\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements M') &&&\n    \\<not> literalFalse l (elements M')", "using valuationContainsItsLiteralsVariable[of \"l\" \"elements M'\"]"], ["proof (prove)\nusing this:\n  var l \\<notin> vars (elements M')\n  l el elements M' \\<Longrightarrow> var l \\<in> vars (elements M')\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements M') &&&\n    \\<not> literalFalse l (elements M')", "using valuationContainsItsLiteralsVariable[of \"opposite l\" \"elements M'\"]"], ["proof (prove)\nusing this:\n  var l \\<notin> vars (elements M')\n  l el elements M' \\<Longrightarrow> var l \\<in> vars (elements M')\n  opposite l el elements M' \\<Longrightarrow>\n  var (opposite l) \\<in> vars (elements M')\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements M') &&&\n    \\<not> literalFalse l (elements M')", "by auto"], ["proof (state)\nthis:\n  \\<not> literalTrue l (elements M')\n  \\<not> literalFalse l (elements M')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "from \\<open>var l \\<notin> vars (elements M'')\\<close>"], ["proof (chain)\npicking this:\n  var l \\<notin> vars (elements M'')", "have \"\\<not> literalTrue l (elements M'')\" \"\\<not> literalFalse l (elements M'')\""], ["proof (prove)\nusing this:\n  var l \\<notin> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements M'') &&&\n    \\<not> literalFalse l (elements M'')", "using valuationContainsItsLiteralsVariable[of \"l\" \"elements M''\"]"], ["proof (prove)\nusing this:\n  var l \\<notin> vars (elements M'')\n  l el elements M'' \\<Longrightarrow> var l \\<in> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements M'') &&&\n    \\<not> literalFalse l (elements M'')", "using valuationContainsItsLiteralsVariable[of \"opposite l\" \"elements M''\"]"], ["proof (prove)\nusing this:\n  var l \\<notin> vars (elements M'')\n  l el elements M'' \\<Longrightarrow> var l \\<in> vars (elements M'')\n  opposite l el elements M'' \\<Longrightarrow>\n  var (opposite l) \\<in> vars (elements M'')\n\ngoal (1 subgoal):\n 1. \\<not> literalTrue l (elements M'') &&&\n    \\<not> literalFalse l (elements M'')", "by auto"], ["proof (state)\nthis:\n  \\<not> literalTrue l (elements M'')\n  \\<not> literalFalse l (elements M'')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "have \"uniq (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uniq (elements M)", "using \\<open>M = M' @ [(l, d)] @ M''\\<close> \\<open>uniq (elements (M' @ M''))\\<close>\n            \\<open>\\<not> literalTrue l (elements M'')\\<close> \\<open>\\<not> literalFalse l (elements M'')\\<close>\n            \\<open>\\<not> literalTrue l (elements M')\\<close> \\<open>\\<not> literalFalse l (elements M')\\<close>"], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  uniq (elements (M' @ M''))\n  \\<not> literalTrue l (elements M'')\n  \\<not> literalFalse l (elements M'')\n  \\<not> literalTrue l (elements M')\n  \\<not> literalFalse l (elements M')\n\ngoal (1 subgoal):\n 1. uniq (elements M)", "by (auto iff: uniqAppendIff)"], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  uniq (elements M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "have \"consistent (elements M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent (elements M)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent (elements M)", "assume \"\\<not> consistent (elements M)\""], ["proof (state)\nthis:\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "then"], ["proof (chain)\npicking this:\n  \\<not> consistent (elements M)", "obtain l' where \"literalTrue l' (elements M)\" \"literalFalse l' (elements M)\""], ["proof (prove)\nusing this:\n  \\<not> consistent (elements M)\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>literalTrue l' (elements M);\n         literalFalse l' (elements M)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  literalTrue l' (elements M)\n  literalFalse l' (elements M)\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"l' = l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l' = l \\<Longrightarrow> False\n 2. l' \\<noteq> l \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  l' = l\n\ngoal (2 subgoals):\n 1. l' = l \\<Longrightarrow> False\n 2. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>literalFalse l' (elements M)\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  literalFalse l' (elements M)\n  M = M' @ [(l, d)] @ M''\n  l' = l", "have \"literalFalse l' (elements (M' @ M''))\""], ["proof (prove)\nusing this:\n  literalFalse l' (elements M)\n  M = M' @ [(l, d)] @ M''\n  l' = l\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements (M' @ M''))", "using oppositeIsDifferentFromLiteral[of \"l\"]"], ["proof (prove)\nusing this:\n  literalFalse l' (elements M)\n  M = M' @ [(l, d)] @ M''\n  l' = l\n  opposite l \\<noteq> l\n\ngoal (1 subgoal):\n 1. literalFalse l' (elements (M' @ M''))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  literalFalse l' (elements (M' @ M''))\n\ngoal (2 subgoals):\n 1. l' = l \\<Longrightarrow> False\n 2. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>\\<not> literalFalse l (elements M')\\<close> \\<open>\\<not> literalFalse l (elements M'')\\<close> \\<open>l' = l\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalFalse l (elements M')\n  \\<not> literalFalse l (elements M'')\n  l' = l\n  literalFalse l' (elements (M' @ M''))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l (elements M')\n  \\<not> literalFalse l (elements M'')\n  l' = l\n  literalFalse l' (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>literalTrue l' (elements M)\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l' (elements M)\n  M = M' @ [(l, d)] @ M''\n  l' \\<noteq> l", "have \"literalTrue l' (elements (M' @ M''))\""], ["proof (prove)\nusing this:\n  literalTrue l' (elements M)\n  M = M' @ [(l, d)] @ M''\n  l' \\<noteq> l\n\ngoal (1 subgoal):\n 1. literalTrue l' (elements (M' @ M''))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  literalTrue l' (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>consistent (elements (M' @ M''))\\<close>"], ["proof (chain)\npicking this:\n  consistent (elements (M' @ M''))\n  literalTrue l' (elements (M' @ M''))", "have \"\\<not> literalFalse l' (elements (M' @ M''))\""], ["proof (prove)\nusing this:\n  consistent (elements (M' @ M''))\n  literalTrue l' (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l' (elements (M' @ M''))", "by (auto simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> literalFalse l' (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>literalFalse l' (elements M)\\<close> \\<open>M = M' @ [(l, d)] @ M''\\<close>"], ["proof (chain)\npicking this:\n  literalFalse l' (elements M)\n  M = M' @ [(l, d)] @ M''\n  \\<not> literalFalse l' (elements (M' @ M''))", "have \"opposite l' = l\""], ["proof (prove)\nusing this:\n  literalFalse l' (elements M)\n  M = M' @ [(l, d)] @ M''\n  \\<not> literalFalse l' (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. opposite l' = l", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  opposite l' = l\n\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>var l = v\\<close>"], ["proof (chain)\npicking this:\n  var l = v\n  opposite l' = l", "have \"var l' = v\""], ["proof (prove)\nusing this:\n  var l = v\n  opposite l' = l\n\ngoal (1 subgoal):\n 1. var l' = v", "by auto"], ["proof (state)\nthis:\n  var l' = v\n\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>literalTrue l' (elements (M' @ M''))\\<close> \\<open>vars (elements (M' @ M'')) = V'\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l' (elements (M' @ M''))\n  vars (elements (M' @ M'')) = V'\n  var l' = v", "have \"v \\<in> V'\""], ["proof (prove)\nusing this:\n  literalTrue l' (elements (M' @ M''))\n  vars (elements (M' @ M'')) = V'\n  var l' = v\n\ngoal (1 subgoal):\n 1. v \\<in> V'", "using valuationContainsItsLiteralsVariable[of \"l'\" \"elements (M' @ M'')\"]"], ["proof (prove)\nusing this:\n  literalTrue l' (elements (M' @ M''))\n  vars (elements (M' @ M'')) = V'\n  var l' = v\n  l' el elements (M' @ M'') \\<Longrightarrow>\n  var l' \\<in> vars (elements (M' @ M''))\n\ngoal (1 subgoal):\n 1. v \\<in> V'", "by simp"], ["proof (state)\nthis:\n  v \\<in> V'\n\ngoal (1 subgoal):\n 1. l' \\<noteq> l \\<Longrightarrow> False", "with \\<open>v \\<notin> V'\\<close>"], ["proof (chain)\npicking this:\n  v \\<notin> V'\n  v \\<in> V'", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> V'\n  v \\<in> V'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "}"], ["proof (state)\nthis:\n  \\<not> consistent (elements M) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> consistent (elements M) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (elements M)", "by auto"], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> {M. vars (elements M) = insert v V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)}", "ultimately"], ["proof (chain)\npicking this:\n  vars (elements M) = insert v V'\n  uniq (elements M)\n  consistent (elements M)", "show \"M \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  vars (elements M) = insert v V'\n  uniq (elements M)\n  consistent (elements M)\n\ngoal (1 subgoal):\n 1. M \\<in> {M. vars (elements M) = insert v V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}", "by auto"], ["proof (state)\nthis:\n  M \\<in> {M. vars (elements M) = insert v V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n  \\<subseteq> {M. vars (elements M) = insert v V' \\<and>\n                  uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M. vars (elements M) = insert v V' \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  {M. vars (elements M) = insert v V' \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "let ?f = \"\\<lambda> ((M', M''), l, d). M' @ [(l, d)] @ M''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "let ?Mset = \"{(M', M''). M' @ M'' \\<in> ?trails V'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "let ?lSet = \"{Pos v, Neg v}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "let ?dSet = \"{True, False}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "have \"?trails' V' = ?f ` (?Mset \\<times> ?lSet \\<times> ?dSet)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}} =\n    (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n    ({(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n     {Pos v, Neg v} \\<times> {True, False})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n    \\<subseteq> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n                ({(M', M'').\n                  M' @ M''\n                  \\<in> {M. vars (elements M) = V' \\<and>\n                            uniq (elements M) \\<and>\n                            consistent (elements M)}} \\<times>\n                 {Pos v, Neg v} \\<times> {True, False})\n 2. (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n    ({(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n     {Pos v, Neg v} \\<times> {True, False})\n    \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)} \\<and>\n                 l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {M' @ [(l, d)] @ M'' |M' l d M''.\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)} \\<and>\n     l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n    \\<subseteq> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n                ({(M', M'').\n                  M' @ M''\n                  \\<in> {M. vars (elements M) = V' \\<and>\n                            uniq (elements M) \\<and>\n                            consistent (elements M)}} \\<times>\n                 {Pos v, Neg v} \\<times> {True, False})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False})", "fix M :: LiteralTrail"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False})", "assume \"M \\<in> ?lhs\""], ["proof (state)\nthis:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False})", "then"], ["proof (chain)\npicking this:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "obtain M' M'' l d\n          where P: \"M = M' @ [(l, d)] @ M''\" \"M' @ M'' \\<in> (?trails V')\" \"l \\<in> {Pos v, Neg v}\" \"d \\<in> {True, False}\""], ["proof (prove)\nusing this:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal (1 subgoal):\n 1. (\\<And>M' l d M''.\n        \\<lbrakk>M = M' @ [(l, d)] @ M'';\n         M' @ M''\n         \\<in> {M. vars (elements M) = V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)};\n         l \\<in> {Pos v, Neg v}; d \\<in> {True, False}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = M' @ [(l, d)] @ M''\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n  l \\<in> {Pos v, Neg v}\n  d \\<in> {True, False}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and>\n                d \\<in> {True, False}} \\<Longrightarrow>\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False})", "show \"M \\<in> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n            ({(M', M'').\n              M' @ M''\n              \\<in> {M. vars (elements M) = V' \\<and>\n                        uniq (elements M) \\<and>\n                        consistent (elements M)}} \\<times>\n             {Pos v, Neg v} \\<times> {True, False})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M =\n    (case ?x of\n     (x, xa) \\<Rightarrow>\n       (case x of\n        (M', M'') \\<Rightarrow> \\<lambda>(l, d). M' @ [(l, d)] @ M'')\n        xa)\n 2. ?x \\<in> {(M', M'').\n              M' @ M''\n              \\<in> {M. vars (elements M) = V' \\<and>\n                        uniq (elements M) \\<and>\n                        consistent (elements M)}} \\<times>\n             {Pos v, Neg v} \\<times> {True, False}", "from P"], ["proof (chain)\npicking this:\n  M = M' @ [(l, d)] @ M''\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n  l \\<in> {Pos v, Neg v}\n  d \\<in> {True, False}", "show \"M = ?f ((M', M''), l, d)\""], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n  l \\<in> {Pos v, Neg v}\n  d \\<in> {True, False}\n\ngoal (1 subgoal):\n 1. M =\n    (case ((M', M''), l, d) of\n     (x, xa) \\<Rightarrow>\n       (case x of\n        (M', M'') \\<Rightarrow> \\<lambda>(l, d). M' @ [(l, d)] @ M'')\n        xa)", "by simp"], ["proof (state)\nthis:\n  M =\n  (case ((M', M''), l, d) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (M', M'') \\<Rightarrow> \\<lambda>(l, d). M' @ [(l, d)] @ M'')\n      xa)\n\ngoal (1 subgoal):\n 1. ((M', M''), l, d)\n    \\<in> {(M', M'').\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)}} \\<times>\n          {Pos v, Neg v} \\<times> {True, False}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((M', M''), l, d)\n    \\<in> {(M', M'').\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)}} \\<times>\n          {Pos v, Neg v} \\<times> {True, False}", "from P"], ["proof (chain)\npicking this:\n  M = M' @ [(l, d)] @ M''\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n  l \\<in> {Pos v, Neg v}\n  d \\<in> {True, False}", "show \"((M', M''), l, d) \\<in> ?Mset \\<times> ?lSet \\<times> ?dSet\""], ["proof (prove)\nusing this:\n  M = M' @ [(l, d)] @ M''\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n  l \\<in> {Pos v, Neg v}\n  d \\<in> {True, False}\n\ngoal (1 subgoal):\n 1. ((M', M''), l, d)\n    \\<in> {(M', M'').\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)}} \\<times>\n          {Pos v, Neg v} \\<times> {True, False}", "by auto"], ["proof (state)\nthis:\n  ((M', M''), l, d)\n  \\<in> {(M', M'').\n         M' @ M''\n         \\<in> {M. vars (elements M) = V' \\<and>\n                   uniq (elements M) \\<and>\n                   consistent (elements M)}} \\<times>\n        {Pos v, Neg v} \\<times> {True, False}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n          ({(M', M'').\n            M' @ M''\n            \\<in> {M. vars (elements M) = V' \\<and>\n                      uniq (elements M) \\<and>\n                      consistent (elements M)}} \\<times>\n           {Pos v, Neg v} \\<times> {True, False})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n  \\<subseteq> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n              ({(M', M'').\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)}} \\<times>\n               {Pos v, Neg v} \\<times> {True, False})\n\ngoal (1 subgoal):\n 1. (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n    ({(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n     {Pos v, Neg v} \\<times> {True, False})\n    \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)} \\<and>\n                 l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n    ({(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n     {Pos v, Neg v} \\<times> {True, False})\n    \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)} \\<and>\n                 l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n    ({(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n     {Pos v, Neg v} \\<times> {True, False})\n    \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)} \\<and>\n                 l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False}) \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "fix M::LiteralTrail"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False}) \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "assume \"M \\<in> ?rhs\""], ["proof (state)\nthis:\n  M \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n          ({(M', M'').\n            M' @ M''\n            \\<in> {M. vars (elements M) = V' \\<and>\n                      uniq (elements M) \\<and>\n                      consistent (elements M)}} \\<times>\n           {Pos v, Neg v} \\<times> {True, False})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False}) \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "then"], ["proof (chain)\npicking this:\n  M \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n          ({(M', M'').\n            M' @ M''\n            \\<in> {M. vars (elements M) = V' \\<and>\n                      uniq (elements M) \\<and>\n                      consistent (elements M)}} \\<times>\n           {Pos v, Neg v} \\<times> {True, False})", "obtain p l d where P: \"M = ?f (p, l, d)\" \"p \\<in> ?Mset\" \"l \\<in> ?lSet\" \"d \\<in> ?dSet\""], ["proof (prove)\nusing this:\n  M \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n          ({(M', M'').\n            M' @ M''\n            \\<in> {M. vars (elements M) = V' \\<and>\n                      uniq (elements M) \\<and>\n                      consistent (elements M)}} \\<times>\n           {Pos v, Neg v} \\<times> {True, False})\n\ngoal (1 subgoal):\n 1. (\\<And>p l d.\n        \\<lbrakk>M =\n                 (case (p, l, d) of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (M', M'') \\<Rightarrow>\n                       \\<lambda>(l, d). M' @ [(l, d)] @ M'')\n                     xa);\n         p \\<in> {(M', M'').\n                  M' @ M''\n                  \\<in> {M. vars (elements M) = V' \\<and>\n                            uniq (elements M) \\<and>\n                            consistent (elements M)}};\n         l \\<in> {Pos v, Neg v}; d \\<in> {True, False}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M =\n  (case (p, l, d) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (M', M'') \\<Rightarrow> \\<lambda>(l, d). M' @ [(l, d)] @ M'')\n      xa)\n  p \\<in> {(M', M'').\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and> consistent (elements M)}}\n  l \\<in> {Pos v, Neg v}\n  d \\<in> {True, False}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False}) \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "from \\<open>p \\<in> ?Mset\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> {(M', M'').\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and> consistent (elements M)}}", "obtain M' M'' where \"M' @ M'' \\<in> ?trails V'\""], ["proof (prove)\nusing this:\n  p \\<in> {(M', M'').\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and> consistent (elements M)}}\n\ngoal (1 subgoal):\n 1. (\\<And>M' M''.\n        M' @ M''\n        \\<in> {M. vars (elements M) = V' \\<and>\n                  uniq (elements M) \\<and>\n                  consistent (elements M)} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n               ({(M', M'').\n                 M' @ M''\n                 \\<in> {M. vars (elements M) = V' \\<and>\n                           uniq (elements M) \\<and>\n                           consistent (elements M)}} \\<times>\n                {Pos v, Neg v} \\<times> {True, False}) \\<Longrightarrow>\n       x \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n                M' @ M''\n                \\<in> {M. vars (elements M) = V' \\<and>\n                          uniq (elements M) \\<and>\n                          consistent (elements M)} \\<and>\n                l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "thus \"M \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n             M' @ M''\n             \\<in> {M. vars (elements M) = V' \\<and>\n                       uniq (elements M) \\<and>\n                       consistent (elements M)} \\<and>\n             l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "using P"], ["proof (prove)\nusing this:\n  M' @ M''\n  \\<in> {M. vars (elements M) = V' \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}\n  M =\n  (case (p, l, d) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (M', M'') \\<Rightarrow> \\<lambda>(l, d). M' @ [(l, d)] @ M'')\n      xa)\n  p \\<in> {(M', M'').\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and> consistent (elements M)}}\n  l \\<in> {Pos v, Neg v}\n  d \\<in> {True, False}\n\ngoal (1 subgoal):\n 1. M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n             M' @ M''\n             \\<in> {M. vars (elements M) = V' \\<and>\n                       uniq (elements M) \\<and>\n                       consistent (elements M)} \\<and>\n             l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}", "by auto"], ["proof (state)\nthis:\n  M \\<in> {M' @ [(l, d)] @ M'' |M' l d M''.\n           M' @ M''\n           \\<in> {M. vars (elements M) = V' \\<and>\n                     uniq (elements M) \\<and>\n                     consistent (elements M)} \\<and>\n           l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n  ({(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n   {Pos v, Neg v} \\<times> {True, False})\n  \\<subseteq> {M' @ [(l, d)] @ M'' |M' l d M''.\n               M' @ M''\n               \\<in> {M. vars (elements M) = V' \\<and>\n                         uniq (elements M) \\<and>\n                         consistent (elements M)} \\<and>\n               l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}} =\n  (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n  ({(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n   {Pos v, Neg v} \\<times> {True, False})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}} =\n  (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n  ({(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n   {Pos v, Neg v} \\<times> {True, False})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "have \"?Mset = {(M', M''). \\<exists> l. l \\<in> ?trails V' \\<and> l = M' @ M''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(M', M'').\n     M' @ M''\n     \\<in> {M. vars (elements M) = V' \\<and>\n               uniq (elements M) \\<and> consistent (elements M)}} =\n    {(M', M'').\n     \\<exists>l.\n        l \\<in> {M. vars (elements M) = V' \\<and>\n                    uniq (elements M) \\<and> consistent (elements M)} \\<and>\n        l = M' @ M''}", "by auto"], ["proof (state)\nthis:\n  {(M', M'').\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}} =\n  {(M', M'').\n   \\<exists>l.\n      l \\<in> {M. vars (elements M) = V' \\<and>\n                  uniq (elements M) \\<and> consistent (elements M)} \\<and>\n      l = M' @ M''}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "hence \"finite ?Mset\""], ["proof (prove)\nusing this:\n  {(M', M'').\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}} =\n  {(M', M'').\n   \\<exists>l.\n      l \\<in> {M. vars (elements M) = V' \\<and>\n                  uniq (elements M) \\<and> consistent (elements M)} \\<and>\n      l = M' @ M''}\n\ngoal (1 subgoal):\n 1. finite\n     {(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}}", "using insert(3)"], ["proof (prove)\nusing this:\n  {(M', M'').\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}} =\n  {(M', M'').\n   \\<exists>l.\n      l \\<in> {M. vars (elements M) = V' \\<and>\n                  uniq (elements M) \\<and> consistent (elements M)} \\<and>\n      l = M' @ M''}\n  finite\n   {M. vars (elements M) = V' \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. finite\n     {(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}}", "using finiteListDecomposeSet[of \"?trails V'\"]"], ["proof (prove)\nusing this:\n  {(M', M'').\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)}} =\n  {(M', M'').\n   \\<exists>l.\n      l \\<in> {M. vars (elements M) = V' \\<and>\n                  uniq (elements M) \\<and> consistent (elements M)} \\<and>\n      l = M' @ M''}\n  finite\n   {M. vars (elements M) = V' \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n  finite\n   {M. vars (elements M) = V' \\<and>\n       uniq (elements M) \\<and> consistent (elements M)} \\<Longrightarrow>\n  finite\n   {(a, b).\n    \\<exists>l.\n       l \\<in> {M. vars (elements M) = V' \\<and>\n                   uniq (elements M) \\<and> consistent (elements M)} \\<and>\n       l = a @ b}\n\ngoal (1 subgoal):\n 1. finite\n     {(M', M'').\n      M' @ M''\n      \\<in> {M. vars (elements M) = V' \\<and>\n                uniq (elements M) \\<and> consistent (elements M)}}", "by simp"], ["proof (state)\nthis:\n  finite\n   {(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V'; v \\<notin> V';\n     finite\n      {M. vars (elements M) = V' \\<and>\n          uniq (elements M) \\<and> consistent (elements M)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {M. vars (elements M) = insert v V' \\<and>\n                           uniq (elements M) \\<and> consistent (elements M)}", "ultimately"], ["proof (chain)\npicking this:\n  {M. vars (elements M) = insert v V' \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}} =\n  (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n  ({(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n   {Pos v, Neg v} \\<times> {True, False})\n  finite\n   {(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}}", "show ?thesis"], ["proof (prove)\nusing this:\n  {M. vars (elements M) = insert v V' \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}}\n  {M' @ [(l, d)] @ M'' |M' l d M''.\n   M' @ M''\n   \\<in> {M. vars (elements M) = V' \\<and>\n             uniq (elements M) \\<and> consistent (elements M)} \\<and>\n   l \\<in> {Pos v, Neg v} \\<and> d \\<in> {True, False}} =\n  (\\<lambda>((M', M''), l, d). M' @ [(l, d)] @ M'') `\n  ({(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}} \\<times>\n   {Pos v, Neg v} \\<times> {True, False})\n  finite\n   {(M', M'').\n    M' @ M''\n    \\<in> {M. vars (elements M) = V' \\<and>\n              uniq (elements M) \\<and> consistent (elements M)}}\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = insert v V' \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "by auto"], ["proof (state)\nthis:\n  finite\n   {M. vars (elements M) = insert v V' \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {M. vars (elements M) = insert v V' \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finiteUniqAndConsistentTrailsWithGivenVariableSuperset: \n  fixes V :: \"Variable set\"\n  assumes \"finite V\"\n  shows \"finite {(M::LiteralTrail). vars (elements M) \\<subseteq> V \\<and> uniq (elements M) \\<and> consistent (elements M)}\" (is \"finite (?trails V)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "have \"{M. vars (elements M) \\<subseteq> V \\<and> uniq (elements M) \\<and> consistent (elements M)} = \n    (\\<Union> v \\<in> Pow V.{M. vars (elements M) = v \\<and> uniq (elements M) \\<and> consistent (elements M)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {M. vars (elements M) \\<subseteq> V \\<and>\n        uniq (elements M) \\<and> consistent (elements M)} =\n    (\\<Union>v\\<in>Pow V.\n        {M. vars (elements M) = v \\<and>\n            uniq (elements M) \\<and> consistent (elements M)})", "by auto"], ["proof (state)\nthis:\n  {M. vars (elements M) \\<subseteq> V \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  (\\<Union>v\\<in>Pow V.\n      {M. vars (elements M) = v \\<and>\n          uniq (elements M) \\<and> consistent (elements M)})\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "moreover"], ["proof (state)\nthis:\n  {M. vars (elements M) \\<subseteq> V \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  (\\<Union>v\\<in>Pow V.\n      {M. vars (elements M) = v \\<and>\n          uniq (elements M) \\<and> consistent (elements M)})\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "have \"finite (\\<Union> v \\<in> Pow V.{M. vars (elements M) = v \\<and> uniq (elements M) \\<and> consistent (elements M)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>v\\<in>Pow V.\n         {M. vars (elements M) = v \\<and>\n             uniq (elements M) \\<and> consistent (elements M)})", "proof (rule finite_UN_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (Pow V)\n 2. \\<And>v.\n       v \\<in> Pow V \\<Longrightarrow>\n       finite\n        {M. vars (elements M) = v \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}", "from \\<open>finite V\\<close>"], ["proof (chain)\npicking this:\n  finite V", "show \"finite (Pow V)\""], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. finite (Pow V)", "by simp"], ["proof (state)\nthis:\n  finite (Pow V)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> Pow V \\<Longrightarrow>\n       finite\n        {M. vars (elements M) = v \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> Pow V \\<Longrightarrow>\n       finite\n        {M. vars (elements M) = v \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> Pow V \\<Longrightarrow>\n       finite\n        {M. vars (elements M) = v \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}", "assume \"v \\<in> Pow V\""], ["proof (state)\nthis:\n  v \\<in> Pow V\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> Pow V \\<Longrightarrow>\n       finite\n        {M. vars (elements M) = v \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}", "with \\<open>finite V\\<close>"], ["proof (chain)\npicking this:\n  finite V\n  v \\<in> Pow V", "have \"finite v\""], ["proof (prove)\nusing this:\n  finite V\n  v \\<in> Pow V\n\ngoal (1 subgoal):\n 1. finite v", "by (auto simp add: finite_subset)"], ["proof (state)\nthis:\n  finite v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> Pow V \\<Longrightarrow>\n       finite\n        {M. vars (elements M) = v \\<and>\n            uniq (elements M) \\<and> consistent (elements M)}", "thus \"finite {M. vars (elements M) = v \\<and> uniq (elements M) \\<and> consistent (elements M)}\""], ["proof (prove)\nusing this:\n  finite v\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = v \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "using finiteUniqAndConsistentTrailsWithGivenVariableSet[of \"v\"]"], ["proof (prove)\nusing this:\n  finite v\n  finite v \\<Longrightarrow>\n  finite\n   {M. vars (elements M) = v \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) = v \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "by simp"], ["proof (state)\nthis:\n  finite\n   {M. vars (elements M) = v \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   (\\<Union>v\\<in>Pow V.\n       {M. vars (elements M) = v \\<and>\n           uniq (elements M) \\<and> consistent (elements M)})\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "ultimately"], ["proof (chain)\npicking this:\n  {M. vars (elements M) \\<subseteq> V \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  (\\<Union>v\\<in>Pow V.\n      {M. vars (elements M) = v \\<and>\n          uniq (elements M) \\<and> consistent (elements M)})\n  finite\n   (\\<Union>v\\<in>Pow V.\n       {M. vars (elements M) = v \\<and>\n           uniq (elements M) \\<and> consistent (elements M)})", "show ?thesis"], ["proof (prove)\nusing this:\n  {M. vars (elements M) \\<subseteq> V \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} =\n  (\\<Union>v\\<in>Pow V.\n      {M. vars (elements M) = v \\<and>\n          uniq (elements M) \\<and> consistent (elements M)})\n  finite\n   (\\<Union>v\\<in>Pow V.\n       {M. vars (elements M) = v \\<and>\n           uniq (elements M) \\<and> consistent (elements M)})\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> V \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "by simp"], ["proof (state)\nthis:\n  finite\n   {M. vars (elements M) \\<subseteq> V \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Since the restricted ordering is acyclic and its domain is\nfinite, it has to be well-founded.\\<close>"], ["", "lemma wfLexLessRestricted:\n  assumes \"finite Vbl\"\n  shows \"wf (lexLessRestricted Vbl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (lexLessRestricted Vbl)", "proof (rule finite_acyclic_wf)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (lexLessRestricted Vbl)\n 2. acyclic (lexLessRestricted Vbl)", "show \"finite (lexLessRestricted Vbl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "let ?X = \"{(M1, M2). \n      consistent (elements M1) \\<and> uniq (elements M1) \\<and> vars (elements M1) \\<subseteq> Vbl \\<and>\n      consistent (elements M2) \\<and> uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "let ?Y = \"{M. vars (elements M) \\<subseteq> Vbl \\<and> uniq (elements M) \\<and> consistent (elements M)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "have \"?X = ?Y \\<times> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(M1, M2).\n     consistent (elements M1) \\<and>\n     uniq (elements M1) \\<and>\n     vars (elements M1) \\<subseteq> Vbl \\<and>\n     consistent (elements M2) \\<and>\n     uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl} =\n    {M. vars (elements M) \\<subseteq> Vbl \\<and>\n        uniq (elements M) \\<and> consistent (elements M)} \\<times>\n    {M. vars (elements M) \\<subseteq> Vbl \\<and>\n        uniq (elements M) \\<and> consistent (elements M)}", "by auto"], ["proof (state)\nthis:\n  {(M1, M2).\n   consistent (elements M1) \\<and>\n   uniq (elements M1) \\<and>\n   vars (elements M1) \\<subseteq> Vbl \\<and>\n   consistent (elements M2) \\<and>\n   uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl} =\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} \\<times>\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "moreover"], ["proof (state)\nthis:\n  {(M1, M2).\n   consistent (elements M1) \\<and>\n   uniq (elements M1) \\<and>\n   vars (elements M1) \\<subseteq> Vbl \\<and>\n   consistent (elements M2) \\<and>\n   uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl} =\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} \\<times>\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "have \"finite ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> Vbl \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "using finiteUniqAndConsistentTrailsWithGivenVariableSuperset[of \"Vbl\"]\n        \\<open>finite Vbl\\<close>"], ["proof (prove)\nusing this:\n  finite Vbl \\<Longrightarrow>\n  finite\n   {M. vars (elements M) \\<subseteq> Vbl \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n  finite Vbl\n\ngoal (1 subgoal):\n 1. finite\n     {M. vars (elements M) \\<subseteq> Vbl \\<and>\n         uniq (elements M) \\<and> consistent (elements M)}", "by auto"], ["proof (state)\nthis:\n  finite\n   {M. vars (elements M) \\<subseteq> Vbl \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "ultimately"], ["proof (chain)\npicking this:\n  {(M1, M2).\n   consistent (elements M1) \\<and>\n   uniq (elements M1) \\<and>\n   vars (elements M1) \\<subseteq> Vbl \\<and>\n   consistent (elements M2) \\<and>\n   uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl} =\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} \\<times>\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)}\n  finite\n   {M. vars (elements M) \\<subseteq> Vbl \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}", "have \"finite ?X\""], ["proof (prove)\nusing this:\n  {(M1, M2).\n   consistent (elements M1) \\<and>\n   uniq (elements M1) \\<and>\n   vars (elements M1) \\<subseteq> Vbl \\<and>\n   consistent (elements M2) \\<and>\n   uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl} =\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)} \\<times>\n  {M. vars (elements M) \\<subseteq> Vbl \\<and>\n      uniq (elements M) \\<and> consistent (elements M)}\n  finite\n   {M. vars (elements M) \\<subseteq> Vbl \\<and>\n       uniq (elements M) \\<and> consistent (elements M)}\n\ngoal (1 subgoal):\n 1. finite\n     {(M1, M2).\n      consistent (elements M1) \\<and>\n      uniq (elements M1) \\<and>\n      vars (elements M1) \\<subseteq> Vbl \\<and>\n      consistent (elements M2) \\<and>\n      uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}", "by simp"], ["proof (state)\nthis:\n  finite\n   {(M1, M2).\n    consistent (elements M1) \\<and>\n    uniq (elements M1) \\<and>\n    vars (elements M1) \\<subseteq> Vbl \\<and>\n    consistent (elements M2) \\<and>\n    uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}\n\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "moreover"], ["proof (state)\nthis:\n  finite\n   {(M1, M2).\n    consistent (elements M1) \\<and>\n    uniq (elements M1) \\<and>\n    vars (elements M1) \\<subseteq> Vbl \\<and>\n    consistent (elements M2) \\<and>\n    uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}\n\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "have \"lexLessRestricted Vbl \\<subseteq> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexLessRestricted Vbl\n    \\<subseteq> {(M1, M2).\n                 consistent (elements M1) \\<and>\n                 uniq (elements M1) \\<and>\n                 vars (elements M1) \\<subseteq> Vbl \\<and>\n                 consistent (elements M2) \\<and>\n                 uniq (elements M2) \\<and>\n                 vars (elements M2) \\<subseteq> Vbl}", "unfolding lexLessRestricted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(M1, M2).\n     vars (elements M1) \\<subseteq> Vbl \\<and>\n     consistent (elements M1) \\<and>\n     uniq (elements M1) \\<and>\n     vars (elements M2) \\<subseteq> Vbl \\<and>\n     consistent (elements M2) \\<and>\n     uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n    \\<subseteq> {(M1, M2).\n                 consistent (elements M1) \\<and>\n                 uniq (elements M1) \\<and>\n                 vars (elements M1) \\<subseteq> Vbl \\<and>\n                 consistent (elements M2) \\<and>\n                 uniq (elements M2) \\<and>\n                 vars (elements M2) \\<subseteq> Vbl}", "by auto"], ["proof (state)\nthis:\n  lexLessRestricted Vbl\n  \\<subseteq> {(M1, M2).\n               consistent (elements M1) \\<and>\n               uniq (elements M1) \\<and>\n               vars (elements M1) \\<subseteq> Vbl \\<and>\n               consistent (elements M2) \\<and>\n               uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}\n\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {(M1, M2).\n    consistent (elements M1) \\<and>\n    uniq (elements M1) \\<and>\n    vars (elements M1) \\<subseteq> Vbl \\<and>\n    consistent (elements M2) \\<and>\n    uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}\n  lexLessRestricted Vbl\n  \\<subseteq> {(M1, M2).\n               consistent (elements M1) \\<and>\n               uniq (elements M1) \\<and>\n               vars (elements M1) \\<subseteq> Vbl \\<and>\n               consistent (elements M2) \\<and>\n               uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   {(M1, M2).\n    consistent (elements M1) \\<and>\n    uniq (elements M1) \\<and>\n    vars (elements M1) \\<subseteq> Vbl \\<and>\n    consistent (elements M2) \\<and>\n    uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}\n  lexLessRestricted Vbl\n  \\<subseteq> {(M1, M2).\n               consistent (elements M1) \\<and>\n               uniq (elements M1) \\<and>\n               vars (elements M1) \\<subseteq> Vbl \\<and>\n               consistent (elements M2) \\<and>\n               uniq (elements M2) \\<and> vars (elements M2) \\<subseteq> Vbl}\n\ngoal (1 subgoal):\n 1. finite (lexLessRestricted Vbl)", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite (lexLessRestricted Vbl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (lexLessRestricted Vbl)\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "show \"acyclic (lexLessRestricted Vbl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> acyclic (lexLessRestricted Vbl)\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "then"], ["proof (chain)\npicking this:\n  \\<not> acyclic (lexLessRestricted Vbl)", "obtain x where \"(x, x) \\<in> (lexLessRestricted Vbl)^+\""], ["proof (prove)\nusing this:\n  \\<not> acyclic (lexLessRestricted Vbl)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, x) \\<in> (lexLessRestricted Vbl)\\<^sup>+ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding acyclic_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. (x, x) \\<notin> (lexLessRestricted Vbl)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, x) \\<in> (lexLessRestricted Vbl)\\<^sup>+ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, x) \\<in> (lexLessRestricted Vbl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "have \"lexLessRestricted Vbl \\<subseteq> lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexLessRestricted Vbl \\<subseteq> lexLess", "unfolding lexLessRestricted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(M1, M2).\n     vars (elements M1) \\<subseteq> Vbl \\<and>\n     consistent (elements M1) \\<and>\n     uniq (elements M1) \\<and>\n     vars (elements M2) \\<subseteq> Vbl \\<and>\n     consistent (elements M2) \\<and>\n     uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n    \\<subseteq> lexLess", "by auto"], ["proof (state)\nthis:\n  lexLessRestricted Vbl \\<subseteq> lexLess\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "have \"(lexLessRestricted Vbl)^+ \\<subseteq> lexLess^+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lexLessRestricted Vbl)\\<^sup>+ \\<subseteq> lexLess\\<^sup>+", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (lexLessRestricted Vbl)\\<^sup>+ \\<Longrightarrow>\n       x \\<in> lexLess\\<^sup>+", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (lexLessRestricted Vbl)\\<^sup>+ \\<Longrightarrow>\n       x \\<in> lexLess\\<^sup>+", "assume \"a \\<in> (lexLessRestricted Vbl)^+\""], ["proof (state)\nthis:\n  a \\<in> (lexLessRestricted Vbl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (lexLessRestricted Vbl)\\<^sup>+ \\<Longrightarrow>\n       x \\<in> lexLess\\<^sup>+", "with \\<open>lexLessRestricted Vbl \\<subseteq> lexLess\\<close>"], ["proof (chain)\npicking this:\n  lexLessRestricted Vbl \\<subseteq> lexLess\n  a \\<in> (lexLessRestricted Vbl)\\<^sup>+", "show \"a \\<in> lexLess^+\""], ["proof (prove)\nusing this:\n  lexLessRestricted Vbl \\<subseteq> lexLess\n  a \\<in> (lexLessRestricted Vbl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. a \\<in> lexLess\\<^sup>+", "using trancl_mono[of \"a\" \"lexLessRestricted Vbl\" \"lexLess\"]"], ["proof (prove)\nusing this:\n  lexLessRestricted Vbl \\<subseteq> lexLess\n  a \\<in> (lexLessRestricted Vbl)\\<^sup>+\n  \\<lbrakk>a \\<in> (lexLessRestricted Vbl)\\<^sup>+;\n   lexLessRestricted Vbl \\<subseteq> lexLess\\<rbrakk>\n  \\<Longrightarrow> a \\<in> lexLess\\<^sup>+\n\ngoal (1 subgoal):\n 1. a \\<in> lexLess\\<^sup>+", "by blast"], ["proof (state)\nthis:\n  a \\<in> lexLess\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (lexLessRestricted Vbl)\\<^sup>+ \\<subseteq> lexLess\\<^sup>+\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "with \\<open>(x, x) \\<in> (lexLessRestricted Vbl)^+\\<close>"], ["proof (chain)\npicking this:\n  (x, x) \\<in> (lexLessRestricted Vbl)\\<^sup>+\n  (lexLessRestricted Vbl)\\<^sup>+ \\<subseteq> lexLess\\<^sup>+", "have \"(x, x) \\<in> lexLess^+\""], ["proof (prove)\nusing this:\n  (x, x) \\<in> (lexLessRestricted Vbl)\\<^sup>+\n  (lexLessRestricted Vbl)\\<^sup>+ \\<subseteq> lexLess\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> lexLess\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (x, x) \\<in> lexLess\\<^sup>+\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "moreover"], ["proof (state)\nthis:\n  (x, x) \\<in> lexLess\\<^sup>+\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "have \"trans lexLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans lexLess", "using translexLess"], ["proof (prove)\nusing this:\n  trans lexLess\n\ngoal (1 subgoal):\n 1. trans lexLess", "."], ["proof (state)\nthis:\n  trans lexLess\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "hence \"lexLess^+ = lexLess\""], ["proof (prove)\nusing this:\n  trans lexLess\n\ngoal (1 subgoal):\n 1. lexLess\\<^sup>+ = lexLess", "by (rule trancl_id)"], ["proof (state)\nthis:\n  lexLess\\<^sup>+ = lexLess\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "ultimately"], ["proof (chain)\npicking this:\n  (x, x) \\<in> lexLess\\<^sup>+\n  lexLess\\<^sup>+ = lexLess", "have \"(x, x) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  (x, x) \\<in> lexLess\\<^sup>+\n  lexLess\\<^sup>+ = lexLess\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> lexLess", "by auto"], ["proof (state)\nthis:\n  (x, x) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "with irreflexiveLexLess[of \"x\"]"], ["proof (chain)\npicking this:\n  (x, x) \\<notin> lexLess\n  (x, x) \\<in> lexLess", "have False"], ["proof (prove)\nusing this:\n  (x, x) \\<notin> lexLess\n  (x, x) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "}"], ["proof (state)\nthis:\n  \\<not> acyclic (lexLessRestricted Vbl) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> acyclic (lexLessRestricted Vbl) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. acyclic (lexLessRestricted Vbl)", "by auto"], ["proof (state)\nthis:\n  acyclic (lexLessRestricted Vbl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic (lexLessRestricted Vbl)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>@{term lexLessRestricted} is also transitive.\\<close>"], ["", "lemma transLexLessRestricted:\n  shows \"trans (lexLessRestricted Vbl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "fix x::LiteralTrail and y::LiteralTrail and z::LiteralTrail"], ["proof (state)\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "assume \"(x, y) \\<in> lexLessRestricted Vbl\" \"(y, z) \\<in> lexLessRestricted Vbl\""], ["proof (state)\nthis:\n  (x, y) \\<in> lexLessRestricted Vbl\n  (y, z) \\<in> lexLessRestricted Vbl\n\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "hence \"(x, z) \\<in> lexLessRestricted Vbl\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> lexLessRestricted Vbl\n  (y, z) \\<in> lexLessRestricted Vbl\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> lexLessRestricted Vbl", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(M1, M2).\n         vars (elements M1) \\<subseteq> Vbl \\<and>\n         consistent (elements M1) \\<and>\n         uniq (elements M1) \\<and>\n         vars (elements M2) \\<subseteq> Vbl \\<and>\n         consistent (elements M2) \\<and>\n         uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n  (y, z)\n  \\<in> {(M1, M2).\n         vars (elements M1) \\<subseteq> Vbl \\<and>\n         consistent (elements M1) \\<and>\n         uniq (elements M1) \\<and>\n         vars (elements M2) \\<subseteq> Vbl \\<and>\n         consistent (elements M2) \\<and>\n         uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n\ngoal (1 subgoal):\n 1. (x, z)\n    \\<in> {(M1, M2).\n           vars (elements M1) \\<subseteq> Vbl \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2) \\<subseteq> Vbl \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "using translexLess"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(M1, M2).\n         vars (elements M1) \\<subseteq> Vbl \\<and>\n         consistent (elements M1) \\<and>\n         uniq (elements M1) \\<and>\n         vars (elements M2) \\<subseteq> Vbl \\<and>\n         consistent (elements M2) \\<and>\n         uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n  (y, z)\n  \\<in> {(M1, M2).\n         vars (elements M1) \\<subseteq> Vbl \\<and>\n         consistent (elements M1) \\<and>\n         uniq (elements M1) \\<and>\n         vars (elements M2) \\<subseteq> Vbl \\<and>\n         consistent (elements M2) \\<and>\n         uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n  trans lexLess\n\ngoal (1 subgoal):\n 1. (x, z)\n    \\<in> {(M1, M2).\n           vars (elements M1) \\<subseteq> Vbl \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2) \\<subseteq> Vbl \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(M1, M2).\n         vars (elements M1) \\<subseteq> Vbl \\<and>\n         consistent (elements M1) \\<and>\n         uniq (elements M1) \\<and>\n         vars (elements M2) \\<subseteq> Vbl \\<and>\n         consistent (elements M2) \\<and>\n         uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n  (y, z)\n  \\<in> {(M1, M2).\n         vars (elements M1) \\<subseteq> Vbl \\<and>\n         consistent (elements M1) \\<and>\n         uniq (elements M1) \\<and>\n         vars (elements M2) \\<subseteq> Vbl \\<and>\n         consistent (elements M2) \\<and>\n         uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}\n  \\<forall>x y z.\n     (x, y) \\<in> lexLess \\<longrightarrow>\n     (y, z) \\<in> lexLess \\<longrightarrow> (x, z) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (x, z)\n    \\<in> {(M1, M2).\n           vars (elements M1) \\<subseteq> Vbl \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2) \\<subseteq> Vbl \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> lexLessRestricted Vbl\n\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?x2, ?y2) \\<in> lexLessRestricted Vbl;\n   (?y2, ?z2) \\<in> lexLessRestricted Vbl\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> lexLessRestricted Vbl\n\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> lexLessRestricted Vbl;\n   (?y2, ?z2) \\<in> lexLessRestricted Vbl\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> lexLessRestricted Vbl\n\ngoal (1 subgoal):\n 1. trans (lexLessRestricted Vbl)", "unfolding trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> lexLessRestricted Vbl;\n   (?y2, ?z2) \\<in> lexLessRestricted Vbl\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> lexLessRestricted Vbl\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> lexLessRestricted Vbl \\<longrightarrow>\n       (y, z) \\<in> lexLessRestricted Vbl \\<longrightarrow>\n       (x, z) \\<in> lexLessRestricted Vbl", "by blast"], ["proof (state)\nthis:\n  trans (lexLessRestricted Vbl)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*-----------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Conflict clause ordering\\<close>"], ["", "(*-----------------------------------------------------------------------*)"], ["", "text\\<open>The ordering of conflict clauses is the multiset ordering induced by the ordering of elements in the trail.\nSince, resolution operator is defined so that it removes all occurrences of clashing literal, it is also neccessary \nto remove duplicate literals before comparison.\\<close>"], ["", "definition\n\"multLess M = inv_image  (mult (precedesOrder (elements M))) (\\<lambda> x. mset (remdups (oppositeLiteralList x)))\""], ["", "text\\<open>The following lemma will help prove that application of the\n$Explain$ DPLL transition rule decreases the conflict clause in the\n@{term multLess} ordering.\\<close>"], ["", "lemma multLessResolve:\n  assumes \n  \"opposite l el C\" and\n  \"isReason reason l (elements M)\"\n  shows\n  \"(resolve C reason (opposite l), C) \\<in> multLess  M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "let ?X = \"mset (remdups (oppositeLiteralList C))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "let ?Y = \"mset (remdups (oppositeLiteralList (resolve C reason (opposite l))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "let ?ord = \"precedesOrder (elements M)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "have \"(?Y, ?X) \\<in> (mult1 ?ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "let ?Z = \"mset (remdups (oppositeLiteralList (removeAll (opposite l) C)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "let ?W = \"mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "let ?a = \"l\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "from \\<open>(opposite l) el C\\<close>"], ["proof (chain)\npicking this:\n  opposite l el C", "have \"?X = ?Z + {#?a#}\""], ["proof (prove)\nusing this:\n  opposite l el C\n\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList C)) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}", "using removeAll_multiset[of \"remdups (oppositeLiteralList C)\" \"l\"]"], ["proof (prove)\nusing this:\n  opposite l el C\n  \\<lbrakk>distinct (remdups (oppositeLiteralList C));\n   l \\<in> set (remdups (oppositeLiteralList C))\\<rbrakk>\n  \\<Longrightarrow> mset (remdups (oppositeLiteralList C)) =\n                    {#l#} +\n                    mset (removeAll l (remdups (oppositeLiteralList C)))\n\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList C)) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}", "using oppositeLiteralListRemove[of \"opposite l\" \"C\"]"], ["proof (prove)\nusing this:\n  opposite l el C\n  \\<lbrakk>distinct (remdups (oppositeLiteralList C));\n   l \\<in> set (remdups (oppositeLiteralList C))\\<rbrakk>\n  \\<Longrightarrow> mset (remdups (oppositeLiteralList C)) =\n                    {#l#} +\n                    mset (removeAll l (remdups (oppositeLiteralList C)))\n  oppositeLiteralList (removeAll (opposite l) C) =\n  removeAll (opposite (opposite l)) (oppositeLiteralList C)\n\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList C)) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"oppositeLiteralList C\"]"], ["proof (prove)\nusing this:\n  opposite l el C\n  \\<lbrakk>distinct (remdups (oppositeLiteralList C));\n   l \\<in> set (remdups (oppositeLiteralList C))\\<rbrakk>\n  \\<Longrightarrow> mset (remdups (oppositeLiteralList C)) =\n                    {#l#} +\n                    mset (removeAll l (remdups (oppositeLiteralList C)))\n  oppositeLiteralList (removeAll (opposite l) C) =\n  removeAll (opposite (opposite l)) (oppositeLiteralList C)\n  l el oppositeLiteralList C =\n  opposite l el oppositeLiteralList (oppositeLiteralList C)\n\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList C)) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}", "by auto"], ["proof (state)\nthis:\n  mset (remdups (oppositeLiteralList C)) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "moreover"], ["proof (state)\nthis:\n  mset (remdups (oppositeLiteralList C)) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "have \"?Y = ?Z + ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n    mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n    mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))", "have \"list_diff (oppositeLiteralList (removeAll l reason)) (oppositeLiteralList (removeAll (opposite l) C)) = \n        oppositeLiteralList (removeAll l (list_diff reason C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_diff (oppositeLiteralList (removeAll l reason))\n     (oppositeLiteralList (removeAll (opposite l) C)) =\n    oppositeLiteralList (removeAll l (list_diff reason C))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. list_diff (oppositeLiteralList (removeAll l reason))\n     (oppositeLiteralList (removeAll (opposite l) C)) =\n    oppositeLiteralList (removeAll l (list_diff reason C))", "from \\<open>isReason reason l (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isReason reason l (elements M)", "have \"opposite l \\<notin> set (removeAll l reason)\""], ["proof (prove)\nusing this:\n  isReason reason l (elements M)\n\ngoal (1 subgoal):\n 1. opposite l \\<notin> set (removeAll l reason)", "unfolding isReason_def"], ["proof (prove)\nusing this:\n  l el reason \\<and>\n  clauseFalse (removeAll l reason) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll l reason \\<longrightarrow>\n      precedes (opposite literal') l (elements M) \\<and>\n      opposite literal' \\<noteq> l)\n\ngoal (1 subgoal):\n 1. opposite l \\<notin> set (removeAll l reason)", "by auto"], ["proof (state)\nthis:\n  opposite l \\<notin> set (removeAll l reason)\n\ngoal (1 subgoal):\n 1. list_diff (oppositeLiteralList (removeAll l reason))\n     (oppositeLiteralList (removeAll (opposite l) C)) =\n    oppositeLiteralList (removeAll l (list_diff reason C))", "hence \"list_diff (removeAll l reason) (removeAll (opposite l) C) = list_diff (removeAll l reason) C\""], ["proof (prove)\nusing this:\n  opposite l \\<notin> set (removeAll l reason)\n\ngoal (1 subgoal):\n 1. list_diff (removeAll l reason) (removeAll (opposite l) C) =\n    list_diff (removeAll l reason) C", "using listDiffRemoveAllNonMember[of \"opposite l\" \"removeAll l reason\" \"C\"]"], ["proof (prove)\nusing this:\n  opposite l \\<notin> set (removeAll l reason)\n  opposite l \\<notin> set (removeAll l reason) \\<Longrightarrow>\n  list_diff (removeAll l reason) C =\n  list_diff (removeAll l reason) (removeAll (opposite l) C)\n\ngoal (1 subgoal):\n 1. list_diff (removeAll l reason) (removeAll (opposite l) C) =\n    list_diff (removeAll l reason) C", "by simp"], ["proof (state)\nthis:\n  list_diff (removeAll l reason) (removeAll (opposite l) C) =\n  list_diff (removeAll l reason) C\n\ngoal (1 subgoal):\n 1. list_diff (oppositeLiteralList (removeAll l reason))\n     (oppositeLiteralList (removeAll (opposite l) C)) =\n    oppositeLiteralList (removeAll l (list_diff reason C))", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_diff (removeAll l reason) (removeAll (opposite l) C) =\n  list_diff (removeAll l reason) C\n\ngoal (1 subgoal):\n 1. list_diff (oppositeLiteralList (removeAll l reason))\n     (oppositeLiteralList (removeAll (opposite l) C)) =\n    oppositeLiteralList (removeAll l (list_diff reason C))", "unfolding oppositeLiteralList_def"], ["proof (prove)\nusing this:\n  list_diff (removeAll l reason) (removeAll (opposite l) C) =\n  list_diff (removeAll l reason) C\n\ngoal (1 subgoal):\n 1. list_diff (map opposite (removeAll l reason))\n     (map opposite (removeAll (opposite l) C)) =\n    map opposite (removeAll l (list_diff reason C))", "using listDiffMap[of \"opposite\" \"removeAll l reason\" \"removeAll (opposite l) C\"]"], ["proof (prove)\nusing this:\n  list_diff (removeAll l reason) (removeAll (opposite l) C) =\n  list_diff (removeAll l reason) C\n  \\<forall>x y.\n     x \\<noteq> y \\<longrightarrow>\n     opposite x \\<noteq> opposite y \\<Longrightarrow>\n  map opposite (list_diff (removeAll l reason) (removeAll (opposite l) C)) =\n  list_diff (map opposite (removeAll l reason))\n   (map opposite (removeAll (opposite l) C))\n\ngoal (1 subgoal):\n 1. list_diff (map opposite (removeAll l reason))\n     (map opposite (removeAll (opposite l) C)) =\n    map opposite (removeAll l (list_diff reason C))", "by auto"], ["proof (state)\nthis:\n  list_diff (oppositeLiteralList (removeAll l reason))\n   (oppositeLiteralList (removeAll (opposite l) C)) =\n  oppositeLiteralList (removeAll l (list_diff reason C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_diff (oppositeLiteralList (removeAll l reason))\n   (oppositeLiteralList (removeAll (opposite l) C)) =\n  oppositeLiteralList (removeAll l (list_diff reason C))\n\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n    mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_diff (oppositeLiteralList (removeAll l reason))\n   (oppositeLiteralList (removeAll (opposite l) C)) =\n  oppositeLiteralList (removeAll l (list_diff reason C))\n\ngoal (1 subgoal):\n 1. mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n    mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))", "unfolding resolve_def"], ["proof (prove)\nusing this:\n  list_diff (oppositeLiteralList (removeAll l reason))\n   (oppositeLiteralList (removeAll (opposite l) C)) =\n  oppositeLiteralList (removeAll l (list_diff reason C))\n\ngoal (1 subgoal):\n 1. mset\n     (remdups\n       (oppositeLiteralList\n         (removeAll (opposite l) C @\n          removeAll (opposite (opposite l)) reason))) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n    mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))", "using remdupsAppendMultiSet[of \"oppositeLiteralList (removeAll (opposite l) C)\" \"oppositeLiteralList (removeAll l reason)\"]"], ["proof (prove)\nusing this:\n  list_diff (oppositeLiteralList (removeAll l reason))\n   (oppositeLiteralList (removeAll (opposite l) C)) =\n  oppositeLiteralList (removeAll l (list_diff reason C))\n  mset\n   (remdups\n     (oppositeLiteralList (removeAll (opposite l) C) @\n      oppositeLiteralList (removeAll l reason))) =\n  mset\n   (remdups (oppositeLiteralList (removeAll (opposite l) C)) @\n    remdups\n     (list_diff (oppositeLiteralList (removeAll l reason))\n       (oppositeLiteralList (removeAll (opposite l) C))))\n\ngoal (1 subgoal):\n 1. mset\n     (remdups\n       (oppositeLiteralList\n         (removeAll (opposite l) C @\n          removeAll (opposite (opposite l)) reason))) =\n    mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n    mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))", "unfolding oppositeLiteralList_def"], ["proof (prove)\nusing this:\n  list_diff (map opposite (removeAll l reason))\n   (map opposite (removeAll (opposite l) C)) =\n  map opposite (removeAll l (list_diff reason C))\n  mset\n   (remdups\n     (map opposite (removeAll (opposite l) C) @\n      map opposite (removeAll l reason))) =\n  mset\n   (remdups (map opposite (removeAll (opposite l) C)) @\n    remdups\n     (list_diff (map opposite (removeAll l reason))\n       (map opposite (removeAll (opposite l) C))))\n\ngoal (1 subgoal):\n 1. mset\n     (remdups\n       (map opposite\n         (removeAll (opposite l) C @\n          removeAll (opposite (opposite l)) reason))) =\n    mset (remdups (map opposite (removeAll (opposite l) C))) +\n    mset (remdups (map opposite (removeAll l (list_diff reason C))))", "by auto"], ["proof (state)\nthis:\n  mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n  mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n  mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "moreover"], ["proof (state)\nthis:\n  mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n  mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "have \"\\<forall> b. b \\<in># ?W \\<longrightarrow> (b, ?a) \\<in> ?ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "assume \"b \\<in># ?W\""], ["proof (state)\nthis:\n  b \\<in># mset\n            (remdups\n              (oppositeLiteralList (removeAll l (list_diff reason C))))\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "hence \"opposite b \\<in> set (removeAll l reason)\""], ["proof (prove)\nusing this:\n  b \\<in># mset\n            (remdups\n              (oppositeLiteralList (removeAll l (list_diff reason C))))\n\ngoal (1 subgoal):\n 1. opposite b \\<in> set (removeAll l reason)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in># mset\n              (remdups\n                (oppositeLiteralList\n                  (removeAll l (list_diff reason C)))) \\<Longrightarrow>\n    opposite b \\<in> set (removeAll l reason)", "from \\<open>b \\<in># ?W\\<close>"], ["proof (chain)\npicking this:\n  b \\<in># mset\n            (remdups\n              (oppositeLiteralList (removeAll l (list_diff reason C))))", "have \"b el remdups (oppositeLiteralList (removeAll l (list_diff reason C)))\""], ["proof (prove)\nusing this:\n  b \\<in># mset\n            (remdups\n              (oppositeLiteralList (removeAll l (list_diff reason C))))\n\ngoal (1 subgoal):\n 1. b el remdups (oppositeLiteralList (removeAll l (list_diff reason C)))", "by simp"], ["proof (state)\nthis:\n  b el remdups (oppositeLiteralList (removeAll l (list_diff reason C)))\n\ngoal (1 subgoal):\n 1. b \\<in># mset\n              (remdups\n                (oppositeLiteralList\n                  (removeAll l (list_diff reason C)))) \\<Longrightarrow>\n    opposite b \\<in> set (removeAll l reason)", "hence \"opposite b el removeAll l (list_diff reason C)\""], ["proof (prove)\nusing this:\n  b el remdups (oppositeLiteralList (removeAll l (list_diff reason C)))\n\ngoal (1 subgoal):\n 1. opposite b el removeAll l (list_diff reason C)", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"opposite b\" \"removeAll l (list_diff reason C)\"]"], ["proof (prove)\nusing this:\n  b el remdups (oppositeLiteralList (removeAll l (list_diff reason C)))\n  opposite b el removeAll l (list_diff reason C) =\n  opposite (opposite b) el\n  oppositeLiteralList (removeAll l (list_diff reason C))\n\ngoal (1 subgoal):\n 1. opposite b el removeAll l (list_diff reason C)", "by auto"], ["proof (state)\nthis:\n  opposite b el removeAll l (list_diff reason C)\n\ngoal (1 subgoal):\n 1. b \\<in># mset\n              (remdups\n                (oppositeLiteralList\n                  (removeAll l (list_diff reason C)))) \\<Longrightarrow>\n    opposite b \\<in> set (removeAll l reason)", "hence \"opposite b el list_diff (removeAll l reason) C\""], ["proof (prove)\nusing this:\n  opposite b el removeAll l (list_diff reason C)\n\ngoal (1 subgoal):\n 1. opposite b el list_diff (removeAll l reason) C", "by simp"], ["proof (state)\nthis:\n  opposite b el list_diff (removeAll l reason) C\n\ngoal (1 subgoal):\n 1. b \\<in># mset\n              (remdups\n                (oppositeLiteralList\n                  (removeAll l (list_diff reason C)))) \\<Longrightarrow>\n    opposite b \\<in> set (removeAll l reason)", "thus ?thesis"], ["proof (prove)\nusing this:\n  opposite b el list_diff (removeAll l reason) C\n\ngoal (1 subgoal):\n 1. opposite b \\<in> set (removeAll l reason)", "using listDiffIff[of \"opposite b\" \"removeAll l reason\" \"C\"]"], ["proof (prove)\nusing this:\n  opposite b el list_diff (removeAll l reason) C\n  (opposite b \\<in> set (removeAll l reason) \\<and>\n   opposite b \\<notin> set C) =\n  (opposite b \\<in> set (list_diff (removeAll l reason) C))\n\ngoal (1 subgoal):\n 1. opposite b \\<in> set (removeAll l reason)", "by simp"], ["proof (state)\nthis:\n  opposite b \\<in> set (removeAll l reason)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  opposite b \\<in> set (removeAll l reason)\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "with \\<open>isReason reason l (elements M)\\<close>"], ["proof (chain)\npicking this:\n  isReason reason l (elements M)\n  opposite b \\<in> set (removeAll l reason)", "have \"precedes b l (elements M)\" \"b \\<noteq> l\""], ["proof (prove)\nusing this:\n  isReason reason l (elements M)\n  opposite b \\<in> set (removeAll l reason)\n\ngoal (1 subgoal):\n 1. precedes b l (elements M) &&& b \\<noteq> l", "unfolding isReason_def"], ["proof (prove)\nusing this:\n  l el reason \\<and>\n  clauseFalse (removeAll l reason) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll l reason \\<longrightarrow>\n      precedes (opposite literal') l (elements M) \\<and>\n      opposite literal' \\<noteq> l)\n  opposite b \\<in> set (removeAll l reason)\n\ngoal (1 subgoal):\n 1. precedes b l (elements M) &&& b \\<noteq> l", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  l el reason \\<and>\n  clauseFalse (removeAll l reason) (elements M) \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll l reason \\<longrightarrow>\n      (opposite literal' \\<in> set (elements M) \\<and>\n       l \\<in> set (elements M) \\<and>\n       firstPos (opposite literal') (elements M)\n       \\<le> firstPos l (elements M)) \\<and>\n      opposite literal' \\<noteq> l)\n  opposite b \\<in> set (removeAll l reason)\n\ngoal (1 subgoal):\n 1. b \\<in> set (elements M) \\<and>\n    l \\<in> set (elements M) \\<and>\n    firstPos b (elements M) \\<le> firstPos l (elements M) &&&\n    b \\<noteq> l", "by auto"], ["proof (state)\nthis:\n  precedes b l (elements M)\n  b \\<noteq> l\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "hence \"(b, ?a) \\<in> ?ord\""], ["proof (prove)\nusing this:\n  precedes b l (elements M)\n  b \\<noteq> l\n\ngoal (1 subgoal):\n 1. (b, l) \\<in> precedesOrder (elements M)", "unfolding precedesOrder_def"], ["proof (prove)\nusing this:\n  precedes b l (elements M)\n  b \\<noteq> l\n\ngoal (1 subgoal):\n 1. (b, l) \\<in> {(a, b). precedes a b (elements M) \\<and> a \\<noteq> b}", "by simp"], ["proof (state)\nthis:\n  (b, l) \\<in> precedesOrder (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "}"], ["proof (state)\nthis:\n  ?b2\n  \\<in># mset\n          (remdups\n            (oppositeLiteralList\n              (removeAll l (list_diff reason C)))) \\<Longrightarrow>\n  (?b2, l) \\<in> precedesOrder (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?b2\n  \\<in># mset\n          (remdups\n            (oppositeLiteralList\n              (removeAll l (list_diff reason C)))) \\<Longrightarrow>\n  (?b2, l) \\<in> precedesOrder (elements M)\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in># mset\n                 (remdups\n                   (oppositeLiteralList\n                     (removeAll l (list_diff reason C)))) \\<longrightarrow>\n       (b, l) \\<in> precedesOrder (elements M)", "by auto"], ["proof (state)\nthis:\n  \\<forall>b.\n     b \\<in># mset\n               (remdups\n                 (oppositeLiteralList\n                   (removeAll l (list_diff reason C)))) \\<longrightarrow>\n     (b, l) \\<in> precedesOrder (elements M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b.\n     b \\<in># mset\n               (remdups\n                 (oppositeLiteralList\n                   (removeAll l (list_diff reason C)))) \\<longrightarrow>\n     (b, l) \\<in> precedesOrder (elements M)\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "ultimately"], ["proof (chain)\npicking this:\n  mset (remdups (oppositeLiteralList C)) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}\n  mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n  mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))\n  \\<forall>b.\n     b \\<in># mset\n               (remdups\n                 (oppositeLiteralList\n                   (removeAll l (list_diff reason C)))) \\<longrightarrow>\n     (b, l) \\<in> precedesOrder (elements M)", "have \"\\<exists> a M0 K. ?X = M0 + {#a#} \\<and> ?Y = M0 + K \\<and> (\\<forall>b. b \\<in># K \\<longrightarrow> (b, a) \\<in> ?ord)\""], ["proof (prove)\nusing this:\n  mset (remdups (oppositeLiteralList C)) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) + {#l#}\n  mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n  mset (remdups (oppositeLiteralList (removeAll (opposite l) C))) +\n  mset (remdups (oppositeLiteralList (removeAll l (list_diff reason C))))\n  \\<forall>b.\n     b \\<in># mset\n               (remdups\n                 (oppositeLiteralList\n                   (removeAll l (list_diff reason C)))) \\<longrightarrow>\n     (b, l) \\<in> precedesOrder (elements M)\n\ngoal (1 subgoal):\n 1. \\<exists>a M0 K.\n       mset (remdups (oppositeLiteralList C)) = M0 + {#a#} \\<and>\n       mset\n        (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n       M0 + K \\<and>\n       (\\<forall>b.\n           b \\<in># K \\<longrightarrow>\n           (b, a) \\<in> precedesOrder (elements M))", "by blast"], ["proof (state)\nthis:\n  \\<exists>a M0 K.\n     mset (remdups (oppositeLiteralList C)) = M0 + {#a#} \\<and>\n     mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n     M0 + K \\<and>\n     (\\<forall>b.\n         b \\<in># K \\<longrightarrow>\n         (b, a) \\<in> precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a M0 K.\n     mset (remdups (oppositeLiteralList C)) = M0 + {#a#} \\<and>\n     mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n     M0 + K \\<and>\n     (\\<forall>b.\n         b \\<in># K \\<longrightarrow>\n         (b, a) \\<in> precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> mult1 (precedesOrder (elements M))", "unfolding mult1_def"], ["proof (prove)\nusing this:\n  \\<exists>a M0 K.\n     mset (remdups (oppositeLiteralList C)) = M0 + {#a#} \\<and>\n     mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))) =\n     M0 + K \\<and>\n     (\\<forall>b.\n         b \\<in># K \\<longrightarrow>\n         (b, a) \\<in> precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> {(N, Ma).\n           \\<exists>a M0 K.\n              Ma = add_mset a M0 \\<and>\n              N = M0 + K \\<and>\n              (\\<forall>b.\n                  b \\<in># K \\<longrightarrow>\n                  (b, a) \\<in> precedesOrder (elements M))}", "by auto"], ["proof (state)\nthis:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> mult1 (precedesOrder (elements M))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> mult1 (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "hence \"(?Y, ?X) \\<in> (mult1 ?ord)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> mult1 (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n     mset (remdups (oppositeLiteralList C)))\n    \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "thus ?thesis"], ["proof (prove)\nusing this:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C) \\<in> multLess M", "unfolding multLess_def"], ["proof (prove)\nusing this:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (oppositeLiteralList x)))", "unfolding mult_def"], ["proof (prove)\nusing this:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C)\n    \\<in> inv_image ((mult1 (precedesOrder (elements M)))\\<^sup>+)\n           (\\<lambda>x. mset (remdups (oppositeLiteralList x)))", "unfolding inv_image_def"], ["proof (prove)\nusing this:\n  (mset (remdups (oppositeLiteralList (resolve C reason (opposite l)))),\n   mset (remdups (oppositeLiteralList C)))\n  \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (resolve C reason (opposite l), C)\n    \\<in> {(x, y).\n           (mset (remdups (oppositeLiteralList x)),\n            mset (remdups (oppositeLiteralList y)))\n           \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+}", "by auto"], ["proof (state)\nthis:\n  (resolve C reason (opposite l), C) \\<in> multLess M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multLessListDiff:\nassumes \n  \"(a, b) \\<in> multLess M\"\nshows\n  \"(list_diff a x, b) \\<in> multLess M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "let ?pOrd = \"precedesOrder (elements M)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "let ?f = \"\\<lambda> l. remdups (map opposite l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "have \"trans ?pOrd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (precedesOrder (elements M))", "using transPrecedesOrder[of \"elements M\"]"], ["proof (prove)\nusing this:\n  trans (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. trans (precedesOrder (elements M))", "by simp"], ["proof (state)\nthis:\n  trans (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "have  \"(mset (?f a), mset (?f b)) \\<in> mult ?pOrd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n    \\<in> mult (precedesOrder (elements M))", "using assms"], ["proof (prove)\nusing this:\n  (a, b) \\<in> multLess M\n\ngoal (1 subgoal):\n 1. (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n    \\<in> mult (precedesOrder (elements M))", "unfolding multLess_def"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> inv_image (mult (precedesOrder (elements M)))\n         (\\<lambda>x. mset (remdups (oppositeLiteralList x)))\n\ngoal (1 subgoal):\n 1. (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n    \\<in> mult (precedesOrder (elements M))", "unfolding oppositeLiteralList_def"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> inv_image (mult (precedesOrder (elements M)))\n         (\\<lambda>x. mset (remdups (map opposite x)))\n\ngoal (1 subgoal):\n 1. (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n    \\<in> mult (precedesOrder (elements M))", "by simp"], ["proof (state)\nthis:\n  (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "moreover"], ["proof (state)\nthis:\n  (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "have \"multiset_le (mset (list_diff (?f a) (?f x)))\n                    (mset (?f a))\n                    ?pOrd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiset_le\n     (mset\n       (list_diff (remdups (map opposite a)) (remdups (map opposite x))))\n     (mset (remdups (map opposite a))) (precedesOrder (elements M))", "using \\<open>trans ?pOrd\\<close>"], ["proof (prove)\nusing this:\n  trans (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. multiset_le\n     (mset\n       (list_diff (remdups (map opposite a)) (remdups (map opposite x))))\n     (mset (remdups (map opposite a))) (precedesOrder (elements M))", "using multisetLeListDiff[of \"?pOrd\" \"?f a\" \"?f x\"]"], ["proof (prove)\nusing this:\n  trans (precedesOrder (elements M))\n  trans (precedesOrder (elements M)) \\<Longrightarrow>\n  multiset_le\n   (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))))\n   (mset (remdups (map opposite a))) (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. multiset_le\n     (mset\n       (list_diff (remdups (map opposite a)) (remdups (map opposite x))))\n     (mset (remdups (map opposite a))) (precedesOrder (elements M))", "by simp"], ["proof (state)\nthis:\n  multiset_le\n   (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))))\n   (mset (remdups (map opposite a))) (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "ultimately"], ["proof (chain)\npicking this:\n  (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n  multiset_le\n   (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))))\n   (mset (remdups (map opposite a))) (precedesOrder (elements M))", "have \"(mset (list_diff (?f a) (?f x)), mset (?f b)) \\<in> mult ?pOrd\""], ["proof (prove)\nusing this:\n  (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n  multiset_le\n   (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))))\n   (mset (remdups (map opposite a))) (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n     mset (remdups (map opposite b)))\n    \\<in> mult (precedesOrder (elements M))", "unfolding multiset_le_def"], ["proof (prove)\nusing this:\n  (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n  mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))) =\n  mset (remdups (map opposite a)) \\<or>\n  (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n   mset (remdups (map opposite a)))\n  \\<in> mult (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n     mset (remdups (map opposite b)))\n    \\<in> mult (precedesOrder (elements M))", "unfolding mult_def"], ["proof (prove)\nusing this:\n  (mset (remdups (map opposite a)), mset (remdups (map opposite b)))\n  \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+\n  mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))) =\n  mset (remdups (map opposite a)) \\<or>\n  (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n   mset (remdups (map opposite a)))\n  \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n     mset (remdups (map opposite b)))\n    \\<in> (mult1 (precedesOrder (elements M)))\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n   mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "thus ?thesis"], ["proof (prove)\nusing this:\n  (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n   mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b) \\<in> multLess M", "unfolding multLess_def"], ["proof (prove)\nusing this:\n  (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n   mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (oppositeLiteralList x)))", "unfolding oppositeLiteralList_def"], ["proof (prove)\nusing this:\n  (mset (list_diff (remdups (map opposite a)) (remdups (map opposite x))),\n   mset (remdups (map opposite b)))\n  \\<in> mult (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. (list_diff a x, b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (map opposite x)))", "by (simp add: listDiffMap remdupsListDiff)"], ["proof (state)\nthis:\n  (list_diff a x, b) \\<in> multLess M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multLessRemdups:\nassumes \n  \"(a, b) \\<in> multLess M\"\nshows\n  \"(remdups a, remdups b) \\<in> multLess M \\<and> \n   (remdups a, b) \\<in> multLess M \\<and> \n   (a, remdups b) \\<in> multLess M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "have \"remdups (map opposite l) = remdups (map opposite (remdups l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (map opposite l) = remdups (map opposite (remdups l))", "by (induct l) auto"], ["proof (state)\nthis:\n  remdups (map opposite l) = remdups (map opposite (remdups l))\n\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "}"], ["proof (state)\nthis:\n  remdups (map opposite ?l2) = remdups (map opposite (remdups ?l2))\n\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "thus ?thesis"], ["proof (prove)\nusing this:\n  remdups (map opposite ?l2) = remdups (map opposite (remdups ?l2))\n\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "using assms"], ["proof (prove)\nusing this:\n  remdups (map opposite ?l2) = remdups (map opposite (remdups ?l2))\n  (a, b) \\<in> multLess M\n\ngoal (1 subgoal):\n 1. (remdups a, remdups b) \\<in> multLess M \\<and>\n    (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M", "unfolding multLess_def"], ["proof (prove)\nusing this:\n  remdups (map opposite ?l2) = remdups (map opposite (remdups ?l2))\n  (a, b)\n  \\<in> inv_image (mult (precedesOrder (elements M)))\n         (\\<lambda>x. mset (remdups (oppositeLiteralList x)))\n\ngoal (1 subgoal):\n 1. (remdups a, remdups b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (oppositeLiteralList x))) \\<and>\n    (remdups a, b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (oppositeLiteralList x))) \\<and>\n    (a, remdups b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (oppositeLiteralList x)))", "unfolding oppositeLiteralList_def"], ["proof (prove)\nusing this:\n  remdups (map opposite ?l2) = remdups (map opposite (remdups ?l2))\n  (a, b)\n  \\<in> inv_image (mult (precedesOrder (elements M)))\n         (\\<lambda>x. mset (remdups (map opposite x)))\n\ngoal (1 subgoal):\n 1. (remdups a, remdups b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (map opposite x))) \\<and>\n    (remdups a, b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (map opposite x))) \\<and>\n    (a, remdups b)\n    \\<in> inv_image (mult (precedesOrder (elements M)))\n           (\\<lambda>x. mset (remdups (map opposite x)))", "by simp"], ["proof (state)\nthis:\n  (remdups a, remdups b) \\<in> multLess M \\<and>\n  (remdups a, b) \\<in> multLess M \\<and> (a, remdups b) \\<in> multLess M\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we show that @{term multLess} is well-founded.\\<close>"], ["", "lemma wfMultLess: \n  shows \"wf (multLess M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (multLess M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. wf (multLess M)", "have \"wf (precedesOrder (elements M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (precedesOrder (elements M))", "by (simp add: wellFoundedPrecedesOrder)"], ["proof (state)\nthis:\n  wf (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. wf (multLess M)", "hence \"wf (mult (precedesOrder (elements M)))\""], ["proof (prove)\nusing this:\n  wf (precedesOrder (elements M))\n\ngoal (1 subgoal):\n 1. wf (mult (precedesOrder (elements M)))", "by (simp add: wf_mult)"], ["proof (state)\nthis:\n  wf (mult (precedesOrder (elements M)))\n\ngoal (1 subgoal):\n 1. wf (multLess M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf (mult (precedesOrder (elements M)))\n\ngoal (1 subgoal):\n 1. wf (multLess M)", "unfolding multLess_def"], ["proof (prove)\nusing this:\n  wf (mult (precedesOrder (elements M)))\n\ngoal (1 subgoal):\n 1. wf (inv_image (mult (precedesOrder (elements M)))\n         (\\<lambda>x. mset (remdups (oppositeLiteralList x))))", "using wf_inv_image[of \"(mult (precedesOrder (elements M)))\"]"], ["proof (prove)\nusing this:\n  wf (mult (precedesOrder (elements M)))\n  wf (mult (precedesOrder (elements M))) \\<Longrightarrow>\n  wf (inv_image (mult (precedesOrder (elements M))) ?f)\n\ngoal (1 subgoal):\n 1. wf (inv_image (mult (precedesOrder (elements M)))\n         (\\<lambda>x. mset (remdups (oppositeLiteralList x))))", "by auto"], ["proof (state)\nthis:\n  wf (multLess M)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*-----------------------------------------------------------------------*)"], ["", "subsubsection\\<open>ConflictFlag ordering\\<close>"], ["", "(*-----------------------------------------------------------------------*)"], ["", "text\\<open>A trivial ordering on Booleans. It will be used for the\n$Conflict$ transition rule.\\<close>"], ["", "definition\n  \"boolLess = {(True, False)}\""], ["", "text\\<open>We show that it is well-founded\\<close>"], ["", "lemma transBoolLess:\n  shows \"trans boolLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans boolLess", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. trans boolLess", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. trans boolLess", "fix x::bool and y::bool and z::bool"], ["proof (state)\ngoal (1 subgoal):\n 1. trans boolLess", "assume \"(x, y) \\<in> boolLess\""], ["proof (state)\nthis:\n  (x, y) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. trans boolLess", "hence \"x = True\" \"y = False\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. x = True &&& y = False", "unfolding boolLess_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(True, False)}\n\ngoal (1 subgoal):\n 1. x = True &&& y = False", "by auto"], ["proof (state)\nthis:\n  x = True\n  y = False\n\ngoal (1 subgoal):\n 1. trans boolLess", "assume \"(y, z) \\<in> boolLess\""], ["proof (state)\nthis:\n  (y, z) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. trans boolLess", "hence \"y = True\" \"z = False\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. y = True &&& z = False", "unfolding boolLess_def"], ["proof (prove)\nusing this:\n  (y, z) \\<in> {(True, False)}\n\ngoal (1 subgoal):\n 1. y = True &&& z = False", "by auto"], ["proof (state)\nthis:\n  y = True\n  z = False\n\ngoal (1 subgoal):\n 1. trans boolLess", "from \\<open>y = False\\<close> \\<open>y = True\\<close>"], ["proof (chain)\npicking this:\n  y = False\n  y = True", "have False"], ["proof (prove)\nusing this:\n  y = False\n  y = True\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. trans boolLess", "hence \"(x, z) \\<in> boolLess\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> boolLess", "by simp"], ["proof (state)\nthis:\n  (x, z) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. trans boolLess", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?x2, ?y2) \\<in> boolLess; (?y2, ?z2) \\<in> boolLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. trans boolLess", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> boolLess; (?y2, ?z2) \\<in> boolLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. trans boolLess", "unfolding trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> boolLess; (?y2, ?z2) \\<in> boolLess\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> boolLess \\<longrightarrow>\n       (y, z) \\<in> boolLess \\<longrightarrow> (x, z) \\<in> boolLess", "by blast"], ["proof (state)\nthis:\n  trans boolLess\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfBoolLess:\n  shows \"wf boolLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf boolLess", "proof (rule finite_acyclic_wf)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite boolLess\n 2. acyclic boolLess", "show \"finite boolLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite boolLess", "unfolding boolLess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(True, False)}", "by simp"], ["proof (state)\nthis:\n  finite boolLess\n\ngoal (1 subgoal):\n 1. acyclic boolLess", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic boolLess", "have \"boolLess^+ = boolLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boolLess\\<^sup>+ = boolLess", "using transBoolLess"], ["proof (prove)\nusing this:\n  trans boolLess\n\ngoal (1 subgoal):\n 1. boolLess\\<^sup>+ = boolLess", "by simp"], ["proof (state)\nthis:\n  boolLess\\<^sup>+ = boolLess\n\ngoal (1 subgoal):\n 1. acyclic boolLess", "thus \"acyclic boolLess\""], ["proof (prove)\nusing this:\n  boolLess\\<^sup>+ = boolLess\n\ngoal (1 subgoal):\n 1. acyclic boolLess", "unfolding boolLess_def"], ["proof (prove)\nusing this:\n  {(True, False)}\\<^sup>+ = {(True, False)}\n\ngoal (1 subgoal):\n 1. acyclic {(True, False)}", "unfolding acyclic_def"], ["proof (prove)\nusing this:\n  {(True, False)}\\<^sup>+ = {(True, False)}\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> {(True, False)}\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  acyclic boolLess\n\ngoal:\nNo subgoals!", "qed"], ["", "(*-----------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Formulae ordering\\<close>"], ["", "(*-----------------------------------------------------------------------*)"], ["", "text\\<open>A partial ordering of formulae, based on a membersip of a\nsingle fixed clause. This ordering will be used for the $Learn$\ntranstion rule.\\<close>"], ["", "definition \"learnLess (C::Clause) == {((F1::Formula), (F2::Formula)). C el F1 \\<and> \\<not> C el F2}\""], ["", "text\\<open>We show that it is well founded\\<close>"], ["", "lemma wfLearnLess:\n  fixes C::Clause\n  shows \"wf (learnLess C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (learnLess C)", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> learnLess C \\<longrightarrow> y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> learnLess C \\<longrightarrow> y \\<notin> Q)", "show \"\\<forall>Q F. F \\<in> Q \\<longrightarrow> (\\<exists>Fmin\\<in>Q. \\<forall>F'. (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "fix F::Formula and Q::\"Formula set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "assume \"F \\<in> Q\""], ["proof (state)\nthis:\n  F \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "have \"\\<exists>Fmin\\<in>Q. \\<forall>F'. (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "proof (cases \"\\<exists> Fc \\<in> Q. C el Fc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>Fc\\<in>Q. C el Fc \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n 2. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "case True"], ["proof (state)\nthis:\n  \\<exists>Fc\\<in>Q. C el Fc\n\ngoal (2 subgoals):\n 1. \\<exists>Fc\\<in>Q. C el Fc \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n 2. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>Fc\\<in>Q. C el Fc", "obtain Fc where \"Fc \\<in> Q\" \"C el Fc\""], ["proof (prove)\nusing this:\n  \\<exists>Fc\\<in>Q. C el Fc\n\ngoal (1 subgoal):\n 1. (\\<And>Fc.\n        \\<lbrakk>Fc \\<in> Q; C el Fc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Fc \\<in> Q\n  C el Fc\n\ngoal (2 subgoals):\n 1. \\<exists>Fc\\<in>Q. C el Fc \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n 2. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "have \"\\<forall>F'. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F'. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F'. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "fix F'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F'. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "show \"(F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (F', Fc) \\<in> learnLess C \\<Longrightarrow> F' \\<notin> Q", "assume \"(F', Fc) \\<in> learnLess C\""], ["proof (state)\nthis:\n  (F', Fc) \\<in> learnLess C\n\ngoal (1 subgoal):\n 1. (F', Fc) \\<in> learnLess C \\<Longrightarrow> F' \\<notin> Q", "hence \"\\<not> C el Fc\""], ["proof (prove)\nusing this:\n  (F', Fc) \\<in> learnLess C\n\ngoal (1 subgoal):\n 1. \\<not> C el Fc", "unfolding learnLess_def"], ["proof (prove)\nusing this:\n  (F', Fc) \\<in> {(F1, F2). C el F1 \\<and> \\<not> C el F2}\n\ngoal (1 subgoal):\n 1. \\<not> C el Fc", "by auto"], ["proof (state)\nthis:\n  \\<not> C el Fc\n\ngoal (1 subgoal):\n 1. (F', Fc) \\<in> learnLess C \\<Longrightarrow> F' \\<notin> Q", "with \\<open>C el Fc\\<close>"], ["proof (chain)\npicking this:\n  C el Fc\n  \\<not> C el Fc", "have False"], ["proof (prove)\nusing this:\n  C el Fc\n  \\<not> C el Fc\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (F', Fc) \\<in> learnLess C \\<Longrightarrow> F' \\<notin> Q", "thus \"F' \\<notin> Q\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. F' \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  F' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>F'. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal (2 subgoals):\n 1. \\<exists>Fc\\<in>Q. C el Fc \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n 2. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "with \\<open>Fc \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  Fc \\<in> Q\n  \\<forall>F'. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  Fc \\<in> Q\n  \\<forall>F'. (F', Fc) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>Fmin\\<in>Q.\n     \\<forall>F'.\n        (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>Fc\\<in>Q. C el Fc)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "have \"\\<forall>F'. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F'. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F'. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "fix F'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F'. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "show \"(F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (F', F) \\<in> learnLess C \\<Longrightarrow> F' \\<notin> Q", "assume \"(F', F) \\<in> learnLess C\""], ["proof (state)\nthis:\n  (F', F) \\<in> learnLess C\n\ngoal (1 subgoal):\n 1. (F', F) \\<in> learnLess C \\<Longrightarrow> F' \\<notin> Q", "hence \"C el F'\""], ["proof (prove)\nusing this:\n  (F', F) \\<in> learnLess C\n\ngoal (1 subgoal):\n 1. C el F'", "unfolding learnLess_def"], ["proof (prove)\nusing this:\n  (F', F) \\<in> {(F1, F2). C el F1 \\<and> \\<not> C el F2}\n\ngoal (1 subgoal):\n 1. C el F'", "by simp"], ["proof (state)\nthis:\n  C el F'\n\ngoal (1 subgoal):\n 1. (F', F) \\<in> learnLess C \\<Longrightarrow> F' \\<notin> Q", "with False"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>Fc\\<in>Q. C el Fc)\n  C el F'", "show \"F' \\<notin> Q\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>Fc\\<in>Q. C el Fc)\n  C el F'\n\ngoal (1 subgoal):\n 1. F' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  F' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>F'. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Fc\\<in>Q. C el Fc) \\<Longrightarrow>\n    \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "with \\<open>F \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  F \\<in> Q\n  \\<forall>F'. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  F \\<in> Q\n  \\<forall>F'. (F', F) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>Fmin\\<in>Q.\n       \\<forall>F'.\n          (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>Fmin\\<in>Q.\n     \\<forall>F'.\n        (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Fmin\\<in>Q.\n     \\<forall>F'.\n        (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?F2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>Fmin\\<in>?Q2.\n     \\<forall>F'.\n        (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?F2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>Fmin\\<in>?Q2.\n     \\<forall>F'.\n        (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q F.\n       F \\<in> Q \\<longrightarrow>\n       (\\<exists>Fmin\\<in>Q.\n           \\<forall>F'.\n              (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q F.\n     F \\<in> Q \\<longrightarrow>\n     (\\<exists>Fmin\\<in>Q.\n         \\<forall>F'.\n            (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q F.\n     F \\<in> Q \\<longrightarrow>\n     (\\<exists>Fmin\\<in>Q.\n         \\<forall>F'.\n            (F', Fmin) \\<in> learnLess C \\<longrightarrow> F' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*-----------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Properties of well-founded relations.\\<close>"], ["", "(*-----------------------------------------------------------------------*)"], ["", "lemma wellFoundedEmbed: \n  fixes rel :: \"('a \\<times> 'a) set\" and rel' :: \"('a \\<times> 'a) set\"\n  assumes \"\\<forall> x y. (x, y) \\<in> rel \\<longrightarrow> (x, y) \\<in> rel'\" and \"wf rel'\"\n  shows \"wf rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf rel", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y. (y, z) \\<in> rel \\<longrightarrow> y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y. (y, z) \\<in> rel \\<longrightarrow> y \\<notin> Q)", "show \"\\<forall>Q x. x \\<in> Q \\<longrightarrow> (\\<exists>zmin\\<in>Q. \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "fix x::\"'a\" and Q::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "assume \"x \\<in> Q\""], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "have \"\\<exists>zmin\\<in>Q. \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "from \\<open>wf rel'\\<close> \\<open>x \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  wf rel'\n  x \\<in> Q", "obtain zmin::\"'a\"\n          where \"zmin \\<in> Q\" and \"\\<forall>z. (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\""], ["proof (prove)\nusing this:\n  wf rel'\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. (\\<And>zmin.\n        \\<lbrakk>zmin \\<in> Q;\n         \\<forall>z.\n            (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y. (y, z) \\<in> rel' \\<longrightarrow> y \\<notin> Q)\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. (\\<And>zmin.\n        \\<lbrakk>zmin \\<in> Q;\n         \\<forall>z.\n            (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  zmin \\<in> Q\n  \\<forall>z. (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "{"], ["proof (state)\nthis:\n  zmin \\<in> Q\n  \\<forall>z. (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "fix z::\"'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "assume \"(z, zmin) \\<in> rel\""], ["proof (state)\nthis:\n  (z, zmin) \\<in> rel\n\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "have \"z \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> Q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<notin> Q", "from \\<open>\\<forall> x y. (x, y) \\<in> rel \\<longrightarrow> (x, y) \\<in> rel'\\<close> \\<open>(z, zmin) \\<in> rel\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x y. (x, y) \\<in> rel \\<longrightarrow> (x, y) \\<in> rel'\n  (z, zmin) \\<in> rel", "have \"(z, zmin) \\<in> rel'\""], ["proof (prove)\nusing this:\n  \\<forall>x y. (x, y) \\<in> rel \\<longrightarrow> (x, y) \\<in> rel'\n  (z, zmin) \\<in> rel\n\ngoal (1 subgoal):\n 1. (z, zmin) \\<in> rel'", "by simp"], ["proof (state)\nthis:\n  (z, zmin) \\<in> rel'\n\ngoal (1 subgoal):\n 1. z \\<notin> Q", "with \\<open>\\<forall>z. (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>z. (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\n  (z, zmin) \\<in> rel'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>z. (z, zmin) \\<in> rel' \\<longrightarrow> z \\<notin> Q\n  (z, zmin) \\<in> rel'\n\ngoal (1 subgoal):\n 1. z \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  z \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "}"], ["proof (state)\nthis:\n  (?z2, zmin) \\<in> rel \\<Longrightarrow> ?z2 \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "with \\<open>zmin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  zmin \\<in> Q\n  (?z2, zmin) \\<in> rel \\<Longrightarrow> ?z2 \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  zmin \\<in> Q\n  (?z2, zmin) \\<in> rel \\<Longrightarrow> ?z2 \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>zmin\\<in>Q.\n       \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>zmin\\<in>Q.\n     \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>zmin\\<in>Q.\n     \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>zmin\\<in>?Q2.\n     \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>zmin\\<in>?Q2.\n     \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>zmin\\<in>Q.\n           \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>zmin\\<in>Q.\n         \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>zmin\\<in>Q.\n         \\<forall>z. (z, zmin) \\<in> rel \\<longrightarrow> z \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}