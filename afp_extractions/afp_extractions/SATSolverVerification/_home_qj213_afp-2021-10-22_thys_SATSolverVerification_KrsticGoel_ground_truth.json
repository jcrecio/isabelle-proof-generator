{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/KrsticGoel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma applicableDecideCharacterization:\n  fixes stateA::State\n  shows \"applicableDecide stateA decisionVars = \n  (\\<exists> l. \n        (var l) \\<in> decisionVars \\<and> \n        \\<not> l el (elements (getM stateA)) \\<and> \n        \\<not> opposite l el (elements (getM stateA))) \n  \" (is \"?lhs = ?rhs\")", "lemma applicableUnitPropagateCharacterization:\n  fixes stateA::State and F0::Formula\n  shows \"applicableUnitPropagate stateA F0 decisionVars = \n  (\\<exists> (uc::Clause) (ul::Literal). \n        formulaEntailsClause (getF stateA) uc \\<and> \n        (var ul) \\<in> decisionVars \\<union> vars F0 \\<and>\n        isUnitClause uc ul (elements (getM stateA)))\n  \" (is \"?lhs = ?rhs\")", "lemma applicableBackjumpCharacterization:\n  fixes stateA::State\n  shows \"applicableBackjump stateA = \n     (\\<exists> l level. \n         getConflictFlag stateA = True \\<and> \n         isBackjumpLevel level l (getC stateA) (getM stateA)\n     )\" (is \"?lhs = ?rhs\")", "lemma applicableExplainCharacterization:\n  fixes stateA::State\n  shows \"applicableExplain stateA = \n  (\\<exists> l reason. \n       getConflictFlag stateA = True \\<and>  \n       l el getC stateA \\<and> \n       formulaEntailsClause (getF stateA) reason \\<and> \n       isReason reason (opposite l) (elements (getM stateA))\n  )\n  \" (is \"?lhs = ?rhs\")", "lemma applicableConflictCharacterization:\n  fixes stateA::State\n  shows \"applicableConflict stateA = \n    (\\<exists> clause. \n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and> \n       clauseFalse clause (elements (getM stateA)))\" (is \"?lhs = ?rhs\")", "lemma applicableLearnCharacterization:\n  fixes stateA::State\n  shows \"applicableLearn stateA = \n           (getConflictFlag stateA = True \\<and> \n           \\<not> getC stateA el getF stateA)\" (is \"?lhs = ?rhs\")", "lemma finalStateNonApplicable: \n  fixes state::State\n  shows \"isFinalState state F0 decisionVars = \n          (\\<not> applicableDecide state decisionVars \\<and> \n           \\<not> applicableUnitPropagate state F0 decisionVars \\<and> \n           \\<not> applicableBackjump state \\<and> \n           \\<not> applicableLearn state \\<and> \n           \\<not> applicableConflict state \\<and> \n           \\<not> applicableExplain state)\"", "lemma invariantsHoldInInitialState:\n  fixes state :: State and F0 :: Formula\n  assumes \"isInitialState state F0\" \n  shows \"invariantsHoldInState state F0 decisionVars\"", "lemma transitionsPreserveInvariants: \n  fixes stateA::State and stateB::State\n  assumes \"transition stateA stateB F0 decisionVars\" and \n  \"invariantsHoldInState stateA F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\"", "lemma invariantsHoldInValidRuns: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"(stateA, stateB) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\"", "lemma invariantsHoldInValidRunsFromInitialState:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"isInitialState state0 F0\" \n  and \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState state F0 decisionVars\"", "theorem soundnessForUNSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n\n  \"getConflictFlag state = True\" and\n  \"getC state = []\"\n  shows \"\\<not> satisfiable F0\"", "theorem soundnessForSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n\n  \"getConflictFlag state = False\"\n  \"\\<not> formulaFalse (getF state) (elements (getM state))\"\n  \"vars (elements (getM state)) \\<supseteq> decisionVars\"  \n  shows \n  \"model (elements (getM state)) F0\"", "lemma trailIsDecreasedByDeciedUnitPropagateAndBackjump:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 decisionVars \\<or> appliedBackjump stateA stateB\"\n  shows \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\"", "lemma conflictFlagIsDecreasedByConflict:\n  fixes stateA::State and stateB::State\n  assumes \"appliedConflict stateA stateB\"\n  shows \"getM stateA = getM stateB\" and \"(getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess\"", "lemma conflictClauseIsDecreasedByExplain:\n  fixes stateA::State and stateB::State\n  assumes \"appliedExplain stateA stateB\"\n  shows \n  \"getM stateA = getM stateB\" and \n  \"getConflictFlag stateA = getConflictFlag stateB\" and \n  \"(getC stateB, getC stateA) \\<in> multLess (getM stateA)\"", "lemma formulaIsDecreasedByLearn:\n  fixes stateA::State and stateB::State\n  assumes \"appliedLearn stateA stateB\"\n  shows \n  \"getM stateA = getM stateB\" and \n  \"getConflictFlag stateA = getConflictFlag stateB\" and \n  \"getC stateA = getC stateB\" and \n  \"(getF stateB, getF stateA) \\<in> learnLess (getC stateA)\"", "lemma stateIsDecreasedByValidTransitions:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and \"transition stateA stateB F0 decisionVars\"\n  shows \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\"", "lemma minimalStatesAreFinal:\n  fixes stateA::State\n  assumes\n  \"invariantsHoldInState state F0 decisionVars\" and \"isMinimalState state F0 decisionVars\"\n  shows \"isFinalState state F0 decisionVars\"", "lemma wfLexLessState: \n  fixes decisionVars :: \"Variable set\" and F0 :: Formula\n  assumes \"finite decisionVars\"\n  shows \"wf (lexLessState F0 decisionVars)\"", "lemma wfBoolLessState: \n  shows \"wf boolLessState\"", "lemma wfMultLessState:\n  shows \"wf multLessState\"", "lemma wfLearnLessState:\n  shows \"wf learnLessState\"", "lemma wfTerminationLess:\n  fixes decisionVars::\"Variable set\" and F0::\"Formula\"\n  assumes \"finite decisionVars\"\n  shows \"wf (terminationLess F0 decisionVars)\"", "theorem wfTransitionRelation:\n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\"\n  shows \"wf {(stateB, stateA). \n             (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and> (transition stateA stateB F0 decisionVars)}\"", "lemma finalNonConflictState: \n  fixes state::State and FO :: Formula\n  assumes \n  \"getConflictFlag state = False\" and\n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableConflict state\"\n  shows \"\\<not> formulaFalse (getF state) (elements (getM state))\" and \n  \"vars (elements (getM state)) \\<supseteq> decisionVars\"", "lemma finalConflictingState: \n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantReasonClauses (getF state) (getM state)\" and\n  \"InvariantCFalse (getConflictFlag state) (getM state) (getC state)\" and\n  \"\\<not> applicableExplain state\" and\n  \"\\<not> applicableBackjump state\" and\n  \"getConflictFlag state\"\n  shows\n  \"getC state = []\"", "lemma finalStateCharacterizationLemma:\n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantReasonClauses (getF state) (getM state)\" and\n  \"InvariantCFalse (getConflictFlag state) (getM state) (getC state)\" and\n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableConflict state\"\n  \"\\<not> applicableExplain state\" and\n  \"\\<not> applicableBackjump state\"\n  shows\n  \"(getConflictFlag state = False \\<and> \n           \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n           vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (getConflictFlag state = True \\<and> \n           getC state = [])\"", "theorem finalStateCharacterization:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n  shows \n  \"(getConflictFlag state = False \\<and> \n      \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n      vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (getConflictFlag state = True \\<and> \n      getC state = [])\"", "theorem completenessForSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"satisfiable F0\" and \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \"getConflictFlag state = False \\<and> \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n               vars (elements (getM state)) \\<supseteq> decisionVars\"", "theorem completenessForUNSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"\\<not> satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"getConflictFlag state = True \\<and> getC state = []\"", "theorem partialCorrectness: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and  \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"satisfiable F0 = (\\<not> getConflictFlag state)\""], "translations": [["", "lemma applicableDecideCharacterization:\n  fixes stateA::State\n  shows \"applicableDecide stateA decisionVars = \n  (\\<exists> l. \n        (var l) \\<in> decisionVars \\<and> \n        \\<not> l el (elements (getM stateA)) \\<and> \n        \\<not> opposite l el (elements (getM stateA))) \n  \" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars =\n    (\\<exists>l.\n        var l \\<in> decisionVars \\<and>\n        \\<not> l el elements (getM stateA) \\<and>\n        \\<not> opposite l el elements (getM stateA))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)", "obtain l where \n    *: \"(var l) \\<in> decisionVars\" \"\\<not> l el (elements (getM stateA))\" \"\\<not> opposite l el (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "let ?stateB = \"stateA\\<lparr> getM := (getM stateA) @ [(l, True)] \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "from *"], ["proof (chain)\npicking this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)", "have \"appliedDecide stateA ?stateB decisionVars\""], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. appliedDecide stateA\n     (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>la.\n       var la \\<in> decisionVars \\<and>\n       \\<not> la el elements (getM stateA) \\<and>\n       \\<not> opposite la el elements (getM stateA) \\<and>\n       getF (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) =\n       getF stateA \\<and>\n       getM (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) =\n       getM stateA @ [(la, True)] \\<and>\n       getConflictFlag\n        (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) =\n       getConflictFlag stateA \\<and>\n       getC (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) =\n       getC stateA", "by auto"], ["proof (state)\nthis:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (2 subgoals):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)\n 2. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA) \\<Longrightarrow>\n    applicableDecide stateA decisionVars", "thus ?lhs"], ["proof (prove)\nusing this:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA\n   (stateA\\<lparr>getM := getM stateA @ [(l, True)]\\<rparr>) decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedDecide stateA state' decisionVars", "by auto"], ["proof (state)\nthis:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "assume ?lhs"], ["proof (state)\nthis:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "then"], ["proof (chain)\npicking this:\n  applicableDecide stateA decisionVars", "obtain stateB l\n    where \"(var l) \\<in> decisionVars\" \"\\<not> l el (elements (getM stateA))\"\n    \"\\<not> opposite l el (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableDecide stateA decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedDecide stateA state' decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>state' l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getF state' = getF stateA \\<and>\n     getM state' = getM stateA @ [(l, True)] \\<and>\n     getConflictFlag state' = getConflictFlag stateA \\<and>\n     getC state' = getC stateA\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> l el elements (getM stateA);\n         \\<not> opposite l el elements (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. applicableDecide stateA decisionVars \\<Longrightarrow>\n    \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "thus ?rhs"], ["proof (prove)\nusing this:\n  var l \\<in> decisionVars\n  \\<not> l el elements (getM stateA)\n  \\<not> opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       var l \\<in> decisionVars \\<and>\n       \\<not> l el elements (getM stateA) \\<and>\n       \\<not> opposite l el elements (getM stateA)", "by auto"], ["proof (state)\nthis:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableUnitPropagateCharacterization:\n  fixes stateA::State and F0::Formula\n  shows \"applicableUnitPropagate stateA F0 decisionVars = \n  (\\<exists> (uc::Clause) (ul::Literal). \n        formulaEntailsClause (getF stateA) uc \\<and> \n        (var ul) \\<in> decisionVars \\<union> vars F0 \\<and>\n        isUnitClause uc ul (elements (getM stateA)))\n  \" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 decisionVars =\n    (\\<exists>uc ul.\n        formulaEntailsClause (getF stateA) uc \\<and>\n        var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n        isUnitClause uc ul (elements (getM stateA)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0 decisionVars", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<exists>uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA))", "obtain ul uc \n    where *: \n    \"formulaEntailsClause (getF stateA) uc\"\n    \"(var ul) \\<in> decisionVars \\<union> vars F0\"\n    \"isUnitClause uc ul (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>formulaEntailsClause (getF stateA) uc;\n         var ul \\<in> decisionVars \\<union> vars F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>formulaEntailsClause (getF stateA) uc;\n         var ul \\<in> decisionVars \\<union> vars F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) uc\n  var ul \\<in> decisionVars \\<union> vars F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0 decisionVars", "let ?stateB = \"stateA\\<lparr> getM := getM stateA @ [(ul, False)] \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0 decisionVars", "from *"], ["proof (chain)\npicking this:\n  formulaEntailsClause (getF stateA) uc\n  var ul \\<in> decisionVars \\<union> vars F0\n  isUnitClause uc ul (elements (getM stateA))", "have \"appliedUnitPropagate stateA ?stateB F0 decisionVars\""], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF stateA) uc\n  var ul \\<in> decisionVars \\<union> vars F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. appliedUnitPropagate stateA\n     (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0\n     decisionVars", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF stateA) uc\n  var ul \\<in> decisionVars \\<union> vars F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>uc ula.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ula \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ula (elements (getM stateA)) \\<and>\n       getF (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) =\n       getF stateA \\<and>\n       getM (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) =\n       getM stateA @ [(ula, False)] \\<and>\n       getConflictFlag\n        (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) =\n       getConflictFlag stateA \\<and>\n       getC (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) =\n       getC stateA", "by auto"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0\n   decisionVars\n\ngoal (2 subgoals):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))\n 2. \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA)) \\<Longrightarrow>\n    applicableUnitPropagate stateA F0 decisionVars", "thus ?lhs"], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0\n   decisionVars\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 decisionVars", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA\n   (stateA\\<lparr>getM := getM stateA @ [(ul, False)]\\<rparr>) F0\n   decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedUnitPropagate stateA state' F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  applicableUnitPropagate stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))", "assume ?lhs"], ["proof (state)\nthis:\n  applicableUnitPropagate stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))", "then"], ["proof (chain)\npicking this:\n  applicableUnitPropagate stateA F0 decisionVars", "obtain stateB uc ul\n    where\n     \"formulaEntailsClause (getF stateA) uc\"\n    \"(var ul) \\<in> decisionVars \\<union> vars F0\"\n    \"isUnitClause uc ul (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableUnitPropagate stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>formulaEntailsClause (getF stateA) uc;\n         var ul \\<in> decisionVars \\<union> vars F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedUnitPropagate stateA state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>formulaEntailsClause (getF stateA) uc;\n         var ul \\<in> decisionVars \\<union> vars F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>state' uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getF state' = getF stateA \\<and>\n     getM state' = getM stateA @ [(ul, False)] \\<and>\n     getConflictFlag state' = getConflictFlag stateA \\<and>\n     getC state' = getC stateA\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>formulaEntailsClause (getF stateA) uc;\n         var ul \\<in> decisionVars \\<union> vars F0;\n         isUnitClause uc ul (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) uc\n  var ul \\<in> decisionVars \\<union> vars F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. applicableUnitPropagate stateA F0 decisionVars \\<Longrightarrow>\n    \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))", "thus ?rhs"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF stateA) uc\n  var ul \\<in> decisionVars \\<union> vars F0\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>uc ul.\n       formulaEntailsClause (getF stateA) uc \\<and>\n       var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n       isUnitClause uc ul (elements (getM stateA))", "by auto"], ["proof (state)\nthis:\n  \\<exists>uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableBackjumpCharacterization:\n  fixes stateA::State\n  shows \"applicableBackjump stateA = \n     (\\<exists> l level. \n         getConflictFlag stateA = True \\<and> \n         isBackjumpLevel level l (getC stateA) (getM stateA)\n     )\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableBackjump stateA =\n    (\\<exists>l level.\n        getConflictFlag stateA = True \\<and>\n        isBackjumpLevel level l (getC stateA) (getM stateA))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)\n 2. \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)\n 2. \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "then"], ["proof (chain)\npicking this:\n  \\<exists>l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA)", "obtain l level\n    where *: \n    \"getConflictFlag stateA = True\"\n    \"isBackjumpLevel level l (getC stateA) (getM stateA)\""], ["proof (prove)\nusing this:\n  \\<exists>l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)\n 2. \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "let ?stateB = \"stateA\\<lparr> getM := prefixToLevel level (getM stateA) @ [(l, False)], \n                         getConflictFlag := False, \n                         getC := [] \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)\n 2. \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "from *"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)", "have \"appliedBackjump stateA ?stateB\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. appliedBackjump stateA\n     (stateA\n      \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n         getConflictFlag := False, getC := []\\<rparr>)", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>la levela.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel levela la (getC stateA) (getM stateA) \\<and>\n       getF\n        (stateA\n         \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n            getConflictFlag := False, getC := []\\<rparr>) =\n       getF stateA \\<and>\n       getM\n        (stateA\n         \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n            getConflictFlag := False, getC := []\\<rparr>) =\n       prefixToLevel levela (getM stateA) @ [(la, False)] \\<and>\n       getConflictFlag\n        (stateA\n         \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n            getConflictFlag := False, getC := []\\<rparr>) =\n       False \\<and>\n       getC\n        (stateA\n         \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n            getConflictFlag := False, getC := []\\<rparr>) =\n       []", "by auto"], ["proof (state)\nthis:\n  appliedBackjump stateA\n   (stateA\n    \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n       getConflictFlag := False, getC := []\\<rparr>)\n\ngoal (2 subgoals):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)\n 2. \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA) \\<Longrightarrow>\n    applicableBackjump stateA", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  appliedBackjump stateA\n   (stateA\n    \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n       getConflictFlag := False, getC := []\\<rparr>)\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA", "unfolding applicableBackjump_def"], ["proof (prove)\nusing this:\n  appliedBackjump stateA\n   (stateA\n    \\<lparr>getM := prefixToLevel level (getM stateA) @ [(l, False)],\n       getConflictFlag := False, getC := []\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedBackjump stateA state'", "by auto"], ["proof (state)\nthis:\n  applicableBackjump stateA\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)", "assume \"?lhs\""], ["proof (state)\nthis:\n  applicableBackjump stateA\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)", "then"], ["proof (chain)\npicking this:\n  applicableBackjump stateA", "obtain stateB l level\n    where  \"getConflictFlag stateA = True\"\n    \"isBackjumpLevel level l (getC stateA) (getM stateA)\""], ["proof (prove)\nusing this:\n  applicableBackjump stateA\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedBackjump stateA state'\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>state' l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA) \\<and>\n     getF state' = getF stateA \\<and>\n     getM state' = prefixToLevel level (getM stateA) @ [(l, False)] \\<and>\n     getConflictFlag state' = False \\<and> getC state' = []\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. applicableBackjump stateA \\<Longrightarrow>\n    \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)", "thus \"?rhs\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. \\<exists>l level.\n       getConflictFlag stateA = True \\<and>\n       isBackjumpLevel level l (getC stateA) (getM stateA)", "by auto"], ["proof (state)\nthis:\n  \\<exists>l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableExplainCharacterization:\n  fixes stateA::State\n  shows \"applicableExplain stateA = \n  (\\<exists> l reason. \n       getConflictFlag stateA = True \\<and>  \n       l el getC stateA \\<and> \n       formulaEntailsClause (getF stateA) reason \\<and> \n       isReason reason (opposite l) (elements (getM stateA))\n  )\n  \" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableExplain stateA =\n    (\\<exists>l reason.\n        getConflictFlag stateA = True \\<and>\n        l el getC stateA \\<and>\n        formulaEntailsClause (getF stateA) reason \\<and>\n        isReason reason (opposite l) (elements (getM stateA)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))\n 2. \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l)\n        (elements (getM stateA)) \\<Longrightarrow>\n    applicableExplain stateA", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))\n 2. \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l)\n        (elements (getM stateA)) \\<Longrightarrow>\n    applicableExplain stateA", "then"], ["proof (chain)\npicking this:\n  \\<exists>l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA))", "obtain l reason\n    where *: \n    \"getConflictFlag stateA = True\"\n    \"l el (getC stateA)\" \"formulaEntailsClause (getF stateA) reason\"\n    \"isReason reason (opposite l) (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         formulaEntailsClause (getF stateA) reason;\n         isReason reason (opposite l) (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableExplain_def"], ["proof (prove)\nusing this:\n  \\<exists>l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         formulaEntailsClause (getF stateA) reason;\n         isReason reason (opposite l) (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  l el getC stateA\n  formulaEntailsClause (getF stateA) reason\n  isReason reason (opposite l) (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))\n 2. \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l)\n        (elements (getM stateA)) \\<Longrightarrow>\n    applicableExplain stateA", "let ?stateB = \"stateA\\<lparr> getC := resolve (getC stateA) reason l \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))\n 2. \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l)\n        (elements (getM stateA)) \\<Longrightarrow>\n    applicableExplain stateA", "from *"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = True\n  l el getC stateA\n  formulaEntailsClause (getF stateA) reason\n  isReason reason (opposite l) (elements (getM stateA))", "have \"appliedExplain stateA ?stateB\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  l el getC stateA\n  formulaEntailsClause (getF stateA) reason\n  isReason reason (opposite l) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. appliedExplain stateA\n     (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>)", "unfolding appliedExplain_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  l el getC stateA\n  formulaEntailsClause (getF stateA) reason\n  isReason reason (opposite l) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>la reasona.\n       getConflictFlag stateA = True \\<and>\n       la el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reasona \\<and>\n       isReason reasona (opposite la) (elements (getM stateA)) \\<and>\n       getF (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>) =\n       getF stateA \\<and>\n       getM (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>) =\n       getM stateA \\<and>\n       getConflictFlag\n        (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>) =\n       True \\<and>\n       getC (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>) =\n       resolve (getC stateA) reasona la", "by auto"], ["proof (state)\nthis:\n  appliedExplain stateA\n   (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>)\n\ngoal (2 subgoals):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))\n 2. \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l)\n        (elements (getM stateA)) \\<Longrightarrow>\n    applicableExplain stateA", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  appliedExplain stateA\n   (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>)\n\ngoal (1 subgoal):\n 1. applicableExplain stateA", "unfolding applicableExplain_def"], ["proof (prove)\nusing this:\n  appliedExplain stateA\n   (stateA\\<lparr>getC := resolve (getC stateA) reason l\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedExplain stateA state'", "by auto"], ["proof (state)\nthis:\n  applicableExplain stateA\n\ngoal (1 subgoal):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))", "assume \"?lhs\""], ["proof (state)\nthis:\n  applicableExplain stateA\n\ngoal (1 subgoal):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))", "then"], ["proof (chain)\npicking this:\n  applicableExplain stateA", "obtain stateB l reason\n    where\n    \"getConflictFlag stateA = True\"\n    \"l el getC stateA\" \"formulaEntailsClause (getF stateA) reason\"\n    \"isReason reason (opposite l) (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableExplain stateA\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         formulaEntailsClause (getF stateA) reason;\n         isReason reason (opposite l) (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableExplain_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedExplain stateA state'\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         formulaEntailsClause (getF stateA) reason;\n         isReason reason (opposite l) (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedExplain_def"], ["proof (prove)\nusing this:\n  \\<exists>state' l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA)) \\<and>\n     getF state' = getF stateA \\<and>\n     getM state' = getM stateA \\<and>\n     getConflictFlag state' = True \\<and>\n     getC state' = resolve (getC stateA) reason l\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         formulaEntailsClause (getF stateA) reason;\n         isReason reason (opposite l) (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  l el getC stateA\n  formulaEntailsClause (getF stateA) reason\n  isReason reason (opposite l) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. applicableExplain stateA \\<Longrightarrow>\n    \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))", "thus \"?rhs\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  l el getC stateA\n  formulaEntailsClause (getF stateA) reason\n  isReason reason (opposite l) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>l reason.\n       getConflictFlag stateA = True \\<and>\n       l el getC stateA \\<and>\n       formulaEntailsClause (getF stateA) reason \\<and>\n       isReason reason (opposite l) (elements (getM stateA))", "by auto"], ["proof (state)\nthis:\n  \\<exists>l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableConflictCharacterization:\n  fixes stateA::State\n  shows \"applicableConflict stateA = \n    (\\<exists> clause. \n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and> \n       clauseFalse clause (elements (getM stateA)))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableConflict stateA =\n    (\\<exists>clause.\n        getConflictFlag stateA = False \\<and>\n        formulaEntailsClause (getF stateA) clause \\<and>\n        clauseFalse clause (elements (getM stateA)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))\n 2. \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA)) \\<Longrightarrow>\n    applicableConflict stateA", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))\n 2. \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA)) \\<Longrightarrow>\n    applicableConflict stateA", "then"], ["proof (chain)\npicking this:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA))", "obtain clause\n    where *: \n    \"getConflictFlag stateA = False\" \"formulaEntailsClause (getF stateA) clause\" \"clauseFalse clause (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>getConflictFlag stateA = False;\n         formulaEntailsClause (getF stateA) clause;\n         clauseFalse clause (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableConflict_def"], ["proof (prove)\nusing this:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>getConflictFlag stateA = False;\n         formulaEntailsClause (getF stateA) clause;\n         clauseFalse clause (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = False\n  formulaEntailsClause (getF stateA) clause\n  clauseFalse clause (elements (getM stateA))\n\ngoal (2 subgoals):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))\n 2. \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA)) \\<Longrightarrow>\n    applicableConflict stateA", "let ?stateB = \"stateA\\<lparr> getC := clause, \n                         getConflictFlag := True \\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))\n 2. \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA)) \\<Longrightarrow>\n    applicableConflict stateA", "from *"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = False\n  formulaEntailsClause (getF stateA) clause\n  clauseFalse clause (elements (getM stateA))", "have \"appliedConflict stateA ?stateB\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = False\n  formulaEntailsClause (getF stateA) clause\n  clauseFalse clause (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. appliedConflict stateA\n     (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>)", "unfolding appliedConflict_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = False\n  formulaEntailsClause (getF stateA) clause\n  clauseFalse clause (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>clausea.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clausea \\<and>\n       clauseFalse clausea (elements (getM stateA)) \\<and>\n       getF\n        (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>) =\n       getF stateA \\<and>\n       getM\n        (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>) =\n       getM stateA \\<and>\n       getConflictFlag\n        (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>) =\n       True \\<and>\n       getC\n        (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>) =\n       clausea", "by auto"], ["proof (state)\nthis:\n  appliedConflict stateA\n   (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>)\n\ngoal (2 subgoals):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))\n 2. \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA)) \\<Longrightarrow>\n    applicableConflict stateA", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  appliedConflict stateA\n   (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>)\n\ngoal (1 subgoal):\n 1. applicableConflict stateA", "unfolding applicableConflict_def"], ["proof (prove)\nusing this:\n  appliedConflict stateA\n   (stateA\\<lparr>getC := clause, getConflictFlag := True\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedConflict stateA state'", "by auto"], ["proof (state)\nthis:\n  applicableConflict stateA\n\ngoal (1 subgoal):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))", "assume \"?lhs\""], ["proof (state)\nthis:\n  applicableConflict stateA\n\ngoal (1 subgoal):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))", "then"], ["proof (chain)\npicking this:\n  applicableConflict stateA", "obtain stateB clause\n    where\n    \"getConflictFlag stateA = False\"\n    \"formulaEntailsClause (getF stateA) clause\"\n    \"clauseFalse clause (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  applicableConflict stateA\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>getConflictFlag stateA = False;\n         formulaEntailsClause (getF stateA) clause;\n         clauseFalse clause (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableConflict_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedConflict stateA state'\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>getConflictFlag stateA = False;\n         formulaEntailsClause (getF stateA) clause;\n         clauseFalse clause (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedConflict_def"], ["proof (prove)\nusing this:\n  \\<exists>state' clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA)) \\<and>\n     getF state' = getF stateA \\<and>\n     getM state' = getM stateA \\<and>\n     getConflictFlag state' = True \\<and> getC state' = clause\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>getConflictFlag stateA = False;\n         formulaEntailsClause (getF stateA) clause;\n         clauseFalse clause (elements (getM stateA))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = False\n  formulaEntailsClause (getF stateA) clause\n  clauseFalse clause (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. applicableConflict stateA \\<Longrightarrow>\n    \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))", "thus \"?rhs\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = False\n  formulaEntailsClause (getF stateA) clause\n  clauseFalse clause (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. \\<exists>clause.\n       getConflictFlag stateA = False \\<and>\n       formulaEntailsClause (getF stateA) clause \\<and>\n       clauseFalse clause (elements (getM stateA))", "by auto"], ["proof (state)\nthis:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma applicableLearnCharacterization:\n  fixes stateA::State\n  shows \"applicableLearn stateA = \n           (getConflictFlag stateA = True \\<and> \n           \\<not> getC stateA el getF stateA)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. applicableLearn stateA =\n    (getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n 2. getConflictFlag stateA = True \\<and>\n    \\<not> getC stateA el getF stateA \\<Longrightarrow>\n    applicableLearn stateA", "assume \"?rhs\""], ["proof (state)\nthis:\n  getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n 2. getConflictFlag stateA = True \\<and>\n    \\<not> getC stateA el getF stateA \\<Longrightarrow>\n    applicableLearn stateA", "hence *: \"getConflictFlag stateA = True\" \"\\<not> getC stateA el getF stateA\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n\ngoal (1 subgoal):\n 1. getConflictFlag stateA = True &&& \\<not> getC stateA el getF stateA", "unfolding applicableLearn_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n\ngoal (1 subgoal):\n 1. getConflictFlag stateA = True &&& \\<not> getC stateA el getF stateA", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n 2. getConflictFlag stateA = True \\<and>\n    \\<not> getC stateA el getF stateA \\<Longrightarrow>\n    applicableLearn stateA", "let ?stateB = \"stateA\\<lparr> getF := getF stateA @ [getC stateA]\\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n 2. getConflictFlag stateA = True \\<and>\n    \\<not> getC stateA el getF stateA \\<Longrightarrow>\n    applicableLearn stateA", "from *"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA", "have \"appliedLearn stateA ?stateB\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n\ngoal (1 subgoal):\n 1. appliedLearn stateA\n     (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>)", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n\ngoal (1 subgoal):\n 1. getConflictFlag stateA = True \\<and>\n    \\<not> getC stateA el getF stateA \\<and>\n    getF (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>) =\n    getF stateA @ [getC stateA] \\<and>\n    getM (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>) =\n    getM stateA \\<and>\n    getConflictFlag\n     (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>) =\n    True \\<and>\n    getC (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>) =\n    getC stateA", "by auto"], ["proof (state)\nthis:\n  appliedLearn stateA\n   (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>)\n\ngoal (2 subgoals):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n 2. getConflictFlag stateA = True \\<and>\n    \\<not> getC stateA el getF stateA \\<Longrightarrow>\n    applicableLearn stateA", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  appliedLearn stateA\n   (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>)\n\ngoal (1 subgoal):\n 1. applicableLearn stateA", "unfolding applicableLearn_def"], ["proof (prove)\nusing this:\n  appliedLearn stateA\n   (stateA\\<lparr>getF := getF stateA @ [getC stateA]\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>state'. appliedLearn stateA state'", "by auto"], ["proof (state)\nthis:\n  applicableLearn stateA\n\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA", "assume \"?lhs\""], ["proof (state)\nthis:\n  applicableLearn stateA\n\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA", "then"], ["proof (chain)\npicking this:\n  applicableLearn stateA", "obtain stateB\n    where\n    \"getConflictFlag stateA = True\" \"\\<not> (getC stateA) el (getF stateA)\""], ["proof (prove)\nusing this:\n  applicableLearn stateA\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>getConflictFlag stateA = True;\n      \\<not> getC stateA el getF stateA\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applicableLearn_def"], ["proof (prove)\nusing this:\n  \\<exists>state'. appliedLearn stateA state'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>getConflictFlag stateA = True;\n      \\<not> getC stateA el getF stateA\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  \\<exists>state'.\n     getConflictFlag stateA = True \\<and>\n     \\<not> getC stateA el getF stateA \\<and>\n     getF state' = getF stateA @ [getC stateA] \\<and>\n     getM state' = getM stateA \\<and>\n     getConflictFlag state' = True \\<and> getC state' = getC stateA\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>getConflictFlag stateA = True;\n      \\<not> getC stateA el getF stateA\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n\ngoal (1 subgoal):\n 1. applicableLearn stateA \\<Longrightarrow>\n    getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA", "thus \"?rhs\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n\ngoal (1 subgoal):\n 1. getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True \\<and> \\<not> getC stateA el getF stateA\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Final states are the ones where no rule is applicable.\\<close>"], ["", "lemma finalStateNonApplicable: \n  fixes state::State\n  shows \"isFinalState state F0 decisionVars = \n          (\\<not> applicableDecide state decisionVars \\<and> \n           \\<not> applicableUnitPropagate state F0 decisionVars \\<and> \n           \\<not> applicableBackjump state \\<and> \n           \\<not> applicableLearn state \\<and> \n           \\<not> applicableConflict state \\<and> \n           \\<not> applicableExplain state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state F0 decisionVars \\<and>\n     \\<not> applicableBackjump state \\<and>\n     \\<not> applicableLearn state \\<and>\n     \\<not> applicableConflict state \\<and> \\<not> applicableExplain state)", "unfolding isFinalState_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'. transition state state' F0 decisionVars) =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state F0 decisionVars \\<and>\n     \\<not> applicableBackjump state \\<and>\n     \\<not> applicableLearn state \\<and>\n     \\<not> applicableConflict state \\<and> \\<not> applicableExplain state)", "unfolding transition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 decisionVars \\<or>\n        appliedConflict state state' \\<or>\n        appliedExplain state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    (\\<not> applicableDecide state decisionVars \\<and>\n     \\<not> applicableUnitPropagate state F0 decisionVars \\<and>\n     \\<not> applicableBackjump state \\<and>\n     \\<not> applicableLearn state \\<and>\n     \\<not> applicableConflict state \\<and> \\<not> applicableExplain state)", "unfolding applicableDecide_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 decisionVars \\<or>\n        appliedConflict state state' \\<or>\n        appliedExplain state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     \\<not> applicableUnitPropagate state F0 decisionVars \\<and>\n     \\<not> applicableBackjump state \\<and>\n     \\<not> applicableLearn state \\<and>\n     \\<not> applicableConflict state \\<and> \\<not> applicableExplain state)", "unfolding applicableUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 decisionVars \\<or>\n        appliedConflict state state' \\<or>\n        appliedExplain state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'.\n         appliedUnitPropagate state state' F0 decisionVars) \\<and>\n     \\<not> applicableBackjump state \\<and>\n     \\<not> applicableLearn state \\<and>\n     \\<not> applicableConflict state \\<and> \\<not> applicableExplain state)", "unfolding applicableBackjump_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 decisionVars \\<or>\n        appliedConflict state state' \\<or>\n        appliedExplain state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'.\n         appliedUnitPropagate state state' F0 decisionVars) \\<and>\n     (\\<nexists>state'. appliedBackjump state state') \\<and>\n     \\<not> applicableLearn state \\<and>\n     \\<not> applicableConflict state \\<and> \\<not> applicableExplain state)", "unfolding applicableLearn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 decisionVars \\<or>\n        appliedConflict state state' \\<or>\n        appliedExplain state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'.\n         appliedUnitPropagate state state' F0 decisionVars) \\<and>\n     (\\<nexists>state'. appliedBackjump state state') \\<and>\n     (\\<nexists>state'. appliedLearn state state') \\<and>\n     \\<not> applicableConflict state \\<and> \\<not> applicableExplain state)", "unfolding applicableConflict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 decisionVars \\<or>\n        appliedConflict state state' \\<or>\n        appliedExplain state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'.\n         appliedUnitPropagate state state' F0 decisionVars) \\<and>\n     (\\<nexists>state'. appliedBackjump state state') \\<and>\n     (\\<nexists>state'. appliedLearn state state') \\<and>\n     (\\<nexists>state'. appliedConflict state state') \\<and>\n     \\<not> applicableExplain state)", "unfolding applicableExplain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>state'.\n        appliedDecide state state' decisionVars \\<or>\n        appliedUnitPropagate state state' F0 decisionVars \\<or>\n        appliedConflict state state' \\<or>\n        appliedExplain state state' \\<or>\n        appliedLearn state state' \\<or> appliedBackjump state state') =\n    ((\\<nexists>state'. appliedDecide state state' decisionVars) \\<and>\n     (\\<nexists>state'.\n         appliedUnitPropagate state state' F0 decisionVars) \\<and>\n     (\\<nexists>state'. appliedBackjump state state') \\<and>\n     (\\<nexists>state'. appliedLearn state state') \\<and>\n     (\\<nexists>state'. appliedConflict state state') \\<and>\n     (\\<nexists>state'. appliedExplain state state'))", "by auto"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text\\<open>Invariants that are relevant for the rest of correctness proof.\\<close>"], ["", "definition\ninvariantsHoldInState :: \"State \\<Rightarrow> Formula \\<Rightarrow> Variable set \\<Rightarrow> bool\"\nwhere\n\"invariantsHoldInState state F0 decisionVars == \n    InvariantVarsM (getM state) F0 decisionVars  \\<and>\n    InvariantVarsF (getF state) F0 decisionVars  \\<and>\n    InvariantConsistent (getM state) \\<and>\n    InvariantUniq (getM state) \\<and> \n    InvariantReasonClauses (getF state) (getM state) \\<and>\n    InvariantEquivalent F0 (getF state) \\<and>\n    InvariantCFalse (getConflictFlag state) (getM state) (getC state) \\<and>\n    InvariantCEntailed (getConflictFlag state) (getF state) (getC state)\n\""], ["", "text\\<open>Invariants hold in initial states\\<close>"], ["", "lemma invariantsHoldInInitialState:\n  fixes state :: State and F0 :: Formula\n  assumes \"isInitialState state F0\" \n  shows \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using assms"], ["proof (prove)\nusing this:\n  isInitialState state F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by (auto simp add:\n  isInitialState_def \n  invariantsHoldInState_def \n  InvariantVarsM_def\n  InvariantVarsF_def\n  InvariantConsistent_def\n  InvariantUniq_def\n  InvariantReasonClauses_def\n  InvariantEquivalent_def equivalentFormulae_def\n  InvariantCFalse_def\n  InvariantCEntailed_def\n)"], ["", "text\\<open>Valid transitions preserve invariants.\\<close>"], ["", "lemma transitionsPreserveInvariants: \n  fixes stateA::State and stateB::State\n  assumes \"transition stateA stateB F0 decisionVars\" and \n  \"invariantsHoldInState stateA F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars", "have \n      \"InvariantVarsM (getM stateA) F0 decisionVars\" and\n      \"InvariantVarsF (getF stateA) F0 decisionVars\" and\n      \"InvariantConsistent (getM stateA)\" and\n      \"InvariantUniq (getM stateA)\" and\n      \"InvariantReasonClauses (getF stateA) (getM stateA)\" and\n      \"InvariantEquivalent F0 (getF stateA)\" and\n      \"InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\" and\n      \"InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. ((InvariantVarsM (getM stateA) F0 decisionVars &&&\n      InvariantVarsF (getF stateA) F0 decisionVars) &&&\n     InvariantConsistent (getM stateA) &&& InvariantUniq (getM stateA)) &&&\n    (InvariantReasonClauses (getF stateA) (getM stateA) &&&\n     InvariantEquivalent F0 (getF stateA)) &&&\n    InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA) &&&\n    InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and>\n  InvariantUniq (getM stateA) \\<and>\n  InvariantReasonClauses (getF stateA) (getM stateA) \\<and>\n  InvariantEquivalent F0 (getF stateA) \\<and>\n  InvariantCFalse (getConflictFlag stateA) (getM stateA)\n   (getC stateA) \\<and>\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. ((InvariantVarsM (getM stateA) F0 decisionVars &&&\n      InvariantVarsF (getF stateA) F0 decisionVars) &&&\n     InvariantConsistent (getM stateA) &&& InvariantUniq (getM stateA)) &&&\n    (InvariantReasonClauses (getF stateA) (getM stateA) &&&\n     InvariantEquivalent F0 (getF stateA)) &&&\n    InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA) &&&\n    InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)", "by auto"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  InvariantReasonClauses (getF stateA) (getM stateA)\n  InvariantEquivalent F0 (getF stateA)\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  InvariantVarsF (getF stateA) F0 decisionVars\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  InvariantReasonClauses (getF stateA) (getM stateA)\n  InvariantEquivalent F0 (getF stateA)\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedDecide stateA stateB decisionVars\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars", "obtain l::Literal where\n      \"(var l) \\<in> decisionVars\"\n      \"\\<not> literalTrue l (elements (getM stateA))\"\n      \"\\<not> literalFalse l (elements (getM stateA))\"\n      \"getM stateB = getM stateA @ [(l, True)]\"\n      \"getF stateB = getF stateA\"\n      \"getConflictFlag stateB = getConflictFlag stateA\"\n      \"getC stateB = getC stateA\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> literalTrue l (elements (getM stateA));\n         \\<not> literalFalse l (elements (getM stateA));\n         getM stateB = getM stateA @ [(l, True)]; getF stateB = getF stateA;\n         getConflictFlag stateB = getConflictFlag stateA;\n         getC stateB = getC stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(l, True)] \\<and>\n     getConflictFlag stateB = getConflictFlag stateA \\<and>\n     getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l \\<in> decisionVars;\n         \\<not> literalTrue l (elements (getM stateA));\n         \\<not> literalFalse l (elements (getM stateA));\n         getM stateB = getM stateA @ [(l, True)]; getF stateB = getF stateA;\n         getConflictFlag stateB = getConflictFlag stateA;\n         getC stateB = getC stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l \\<in> decisionVars\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n  getM stateB = getM stateA @ [(l, True)]\n  getF stateB = getF stateA\n  getConflictFlag stateB = getConflictFlag stateA\n  getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>\\<not> literalTrue l (elements (getM stateA))\\<close> \\<open>\\<not> literalFalse l (elements (getM stateA))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))", "have *: \"var l \\<notin> vars (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars (elements (getM stateA))", "using variableDefinedImpliesLiteralDefined[of \"l\" \"elements (getM stateA)\"]"], ["proof (prove)\nusing this:\n  \\<not> literalTrue l (elements (getM stateA))\n  \\<not> literalFalse l (elements (getM stateA))\n  (var l \\<in> vars (elements (getM stateA))) =\n  (literalTrue l (elements (getM stateA)) \\<or>\n   literalFalse l (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  var l \\<notin> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>var l \\<in> decisionVars\\<close>\n        InvariantVarsMAfterDecide [of \"getM stateA\" \"F0\" \"decisionVars\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantVarsM (getM stateA) F0 decisionVars\n  var l \\<in> decisionVars\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   var l \\<in> decisionVars;\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA\\<close>\n        \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantVarsF (getF stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantConsistentAfterDecide[of \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantConsistent (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>var l \\<notin> vars (elements (getM stateA))\\<close>\n        InvariantUniqAfterDecide[of \"getM stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantUniq (getM stateA)\n  var l \\<notin> vars (elements (getM stateA))\n  \\<lbrakk>InvariantUniq (getM stateA);\n   var l \\<notin> vars (elements (getM stateA));\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantReasonClauses (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "using \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>InvariantReasonClauses (getF stateA) (getM stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantUniq (getM stateA)\n  InvariantReasonClauses (getF stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "using InvariantReasonClausesAfterDecide[of \"getF stateA\" \"getM stateA\" \"getM stateB\" \"l\"]"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  getM stateB = getM stateA @ [(l, True)]\n  InvariantUniq (getM stateA)\n  InvariantReasonClauses (getF stateA) (getM stateA)\n  \\<lbrakk>InvariantReasonClauses (getF stateA) (getM stateA);\n   InvariantUniq (getM stateA);\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantReasonClauses (getF stateA) (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using \\<open>getF stateB = getF stateA\\<close>\n      \\<open>InvariantEquivalent F0 (getF stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "using \\<open>getM stateB = getM stateA @ [(l, True)]\\<close> \n        \\<open>getConflictFlag stateB = getConflictFlag stateA\\<close>\n        \\<open>getC stateB = getC stateA\\<close>\n        \\<open>InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\\<close>\n        InvariantCFalseAfterDecide[of \"getConflictFlag stateA\" \"getM stateA\" \"getC stateA\" \"getM stateB\" \"l\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(l, True)]\n  getConflictFlag stateB = getConflictFlag stateA\n  getC stateB = getC stateA\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  \\<lbrakk>InvariantCFalse (getConflictFlag stateA) (getM stateA)\n            (getC stateA);\n   getM stateB = getM stateA @ [(l, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantCFalse (getConflictFlag stateA) (getM stateB)\n                     (getC stateA)\n\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "using \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getConflictFlag stateB = getConflictFlag stateA\\<close>\n        \\<open>getC stateB = getC stateA\\<close>\n        \\<open>InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  getConflictFlag stateB = getConflictFlag stateA\n  getC stateB = getC stateA\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and>\n    InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n    InvariantEquivalent F0 (getF stateB) \\<and>\n    InvariantCFalse (getConflictFlag stateB) (getM stateB)\n     (getC stateB) \\<and>\n    InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedUnitPropagate stateA stateB F0 decisionVars\""], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedUnitPropagate stateA stateB F0 decisionVars", "obtain uc::Clause and ul::Literal where \n      \"formulaEntailsClause (getF stateA) uc\"\n      \"(var ul) \\<in> decisionVars \\<union> vars F0\" \n      \"isUnitClause uc ul (elements (getM stateA))\"\n      \"getF stateB = getF stateA\"\n      \"getM stateB = getM stateA @ [(ul, False)]\"\n      \"getConflictFlag stateB = getConflictFlag stateA\"\n      \"getC stateB = getC stateA\""], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>formulaEntailsClause (getF stateA) uc;\n         var ul \\<in> decisionVars \\<union> vars F0;\n         isUnitClause uc ul (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB = getM stateA @ [(ul, False)];\n         getConflictFlag stateB = getConflictFlag stateA;\n         getC stateB = getC stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(ul, False)] \\<and>\n     getConflictFlag stateB = getConflictFlag stateA \\<and>\n     getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (\\<And>uc ul.\n        \\<lbrakk>formulaEntailsClause (getF stateA) uc;\n         var ul \\<in> decisionVars \\<union> vars F0;\n         isUnitClause uc ul (elements (getM stateA));\n         getF stateB = getF stateA;\n         getM stateB = getM stateA @ [(ul, False)];\n         getConflictFlag stateB = getConflictFlag stateA;\n         getC stateB = getC stateA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) uc\n  var ul \\<in> decisionVars \\<union> vars F0\n  isUnitClause uc ul (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = getM stateA @ [(ul, False)]\n  getConflictFlag stateB = getConflictFlag stateA\n  getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>"], ["proof (chain)\npicking this:\n  isUnitClause uc ul (elements (getM stateA))", "have \"ul el uc\""], ["proof (prove)\nusing this:\n  isUnitClause uc ul (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. ul el uc", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  ul el uc \\<and>\n  \\<not> literalTrue ul (elements (getM stateA)) \\<and>\n  \\<not> literalFalse ul (elements (getM stateA)) \\<and>\n  (\\<forall>literal.\n      literal el uc \\<and> literal \\<noteq> ul \\<longrightarrow>\n      literalFalse literal (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. ul el uc", "by simp"], ["proof (state)\nthis:\n  ul el uc\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>var ul \\<in> decisionVars \\<union> vars F0\\<close>"], ["proof (chain)\npicking this:\n  var ul \\<in> decisionVars \\<union> vars F0", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\nusing this:\n  var ul \\<in> decisionVars \\<union> vars F0\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA\\<close> \n        \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantVarsMAfterUnitPropagate[of \"getM stateA\" \"F0\" \"decisionVars\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  var ul \\<in> decisionVars \\<union> vars F0\n  getF stateB = getF stateA\n  InvariantVarsM (getM stateA) F0 decisionVars\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   var ul \\<in> vars F0 \\<union> decisionVars;\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA\\<close>\n        \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantVarsF (getF stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantConsistentAfterUnitPropagate [of \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        InvariantUniqAfterUnitPropagate [of \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  \\<lbrakk>InvariantUniq (getM stateA);\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantReasonClauses (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "using \\<open>getF stateB = getF stateA\\<close> \n        \\<open>InvariantReasonClauses (getF stateA) (getM stateA)\\<close>\n        \\<open>isUnitClause uc ul (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close>\n        \\<open>formulaEntailsClause (getF stateA) uc\\<close>\n        InvariantReasonClausesAfterUnitPropagate[of \"getF stateA\" \"getM stateA\" \"uc\" \"ul\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantReasonClauses (getF stateA) (getM stateA)\n  isUnitClause uc ul (elements (getM stateA))\n  getM stateB = getM stateA @ [(ul, False)]\n  formulaEntailsClause (getF stateA) uc\n  \\<lbrakk>InvariantReasonClauses (getF stateA) (getM stateA);\n   formulaEntailsClause (getF stateA) uc;\n   isUnitClause uc ul (elements (getM stateA));\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantReasonClauses (getF stateA) (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using \\<open>getF stateB = getF stateA\\<close> \n      \\<open>InvariantEquivalent F0 (getF stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "using \\<open>getM stateB = getM stateA @ [(ul, False)]\\<close> \n        \\<open>getConflictFlag stateB = getConflictFlag stateA\\<close>\n        \\<open>getC stateB = getC stateA\\<close>\n        \\<open>InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\\<close>\n        InvariantCFalseAfterUnitPropagate[of \"getConflictFlag stateA\" \"getM stateA\" \"getC stateA\" \"getM stateB\" \"ul\"]"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA @ [(ul, False)]\n  getConflictFlag stateB = getConflictFlag stateA\n  getC stateB = getC stateA\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  \\<lbrakk>InvariantCFalse (getConflictFlag stateA) (getM stateA)\n            (getC stateA);\n   getM stateB = getM stateA @ [(ul, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantCFalse (getConflictFlag stateA) (getM stateB)\n                     (getC stateA)\n\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "using \\<open>getF stateB = getF stateA\\<close> \n        \\<open>getConflictFlag stateB = getConflictFlag stateA\\<close>\n        \\<open>getC stateB = getC stateA\\<close>\n        \\<open>InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  getConflictFlag stateB = getConflictFlag stateA\n  getC stateB = getC stateA\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and>\n    InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n    InvariantEquivalent F0 (getF stateB) \\<and>\n    InvariantCFalse (getConflictFlag stateB) (getM stateB)\n     (getC stateB) \\<and>\n    InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedConflict stateA stateB\""], ["proof (state)\nthis:\n  appliedConflict stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedConflict stateA stateB", "obtain clause::Clause where\n      \"getConflictFlag stateA = False\"\n      \"formulaEntailsClause (getF stateA) clause\"\n      \"clauseFalse clause (elements (getM stateA))\"\n      \"getF stateB = getF stateA\"\n      \"getM stateB = getM stateA\"\n      \"getConflictFlag stateB = True\"\n      \"getC stateB = clause\""], ["proof (prove)\nusing this:\n  appliedConflict stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>getConflictFlag stateA = False;\n         formulaEntailsClause (getF stateA) clause;\n         clauseFalse clause (elements (getM stateA));\n         getF stateB = getF stateA; getM stateB = getM stateA;\n         getConflictFlag stateB = True; getC stateB = clause\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedConflict_def"], ["proof (prove)\nusing this:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA \\<and>\n     getConflictFlag stateB = True \\<and> getC stateB = clause\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>getConflictFlag stateA = False;\n         formulaEntailsClause (getF stateA) clause;\n         clauseFalse clause (elements (getM stateA));\n         getF stateB = getF stateA; getM stateB = getM stateA;\n         getConflictFlag stateB = True; getC stateB = clause\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = False\n  formulaEntailsClause (getF stateA) clause\n  clauseFalse clause (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = clause\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>\n        \\<open>getF stateB = getF stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  getF stateB = getF stateA\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantReasonClauses (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "using \\<open>InvariantReasonClauses (getF stateA) (getM stateA)\\<close>\n        \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantReasonClauses (getF stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using \\<open>InvariantEquivalent F0 (getF stateA)\\<close>\n        \\<open>getF stateB = getF stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 (getF stateA)\n  getF stateB = getF stateA\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "using\n      \\<open>clauseFalse clause (elements (getM stateA))\\<close>\n      \\<open>getM stateB = getM stateA\\<close>\n      \\<open>getConflictFlag stateB = True\\<close>\n      \\<open>getC stateB = clause\\<close>"], ["proof (prove)\nusing this:\n  clauseFalse clause (elements (getM stateA))\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = clause\n\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  clauseFalse clause (elements (getM stateA))\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = clause\n\ngoal (1 subgoal):\n 1. getConflictFlag stateB \\<longrightarrow>\n    clauseFalse (getC stateB) (elements (getM stateB))", "by simp"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "unfolding InvariantCEntailed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag stateB \\<longrightarrow>\n    formulaEntailsClause (getF stateB) (getC stateB)", "using\n      \\<open>getConflictFlag stateB = True\\<close>\n      \\<open>formulaEntailsClause (getF stateA) clause\\<close>\n      \\<open>getF stateB = getF stateA\\<close>\n      \\<open>getC stateB = clause\\<close>"], ["proof (prove)\nusing this:\n  getConflictFlag stateB = True\n  formulaEntailsClause (getF stateA) clause\n  getF stateB = getF stateA\n  getC stateB = clause\n\ngoal (1 subgoal):\n 1. getConflictFlag stateB \\<longrightarrow>\n    formulaEntailsClause (getF stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and>\n    InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n    InvariantEquivalent F0 (getF stateB) \\<and>\n    InvariantCFalse (getConflictFlag stateB) (getM stateB)\n     (getC stateB) \\<and>\n    InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedConflict stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedConflict stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedConflict stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedExplain stateA stateB\""], ["proof (state)\nthis:\n  appliedExplain stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedExplain stateA stateB", "obtain l::Literal and reason::Clause where\n        \"getConflictFlag stateA = True\"\n        \"l el getC stateA\"\n        \"formulaEntailsClause (getF stateA) reason\"\n        \"isReason reason (opposite l) (elements (getM stateA))\"\n        \"getF stateB = getF stateA\"\n        \"getM stateB = getM stateA\"\n        \"getConflictFlag stateB = True\"\n        \"getC stateB = resolve (getC stateA) reason l\""], ["proof (prove)\nusing this:\n  appliedExplain stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         formulaEntailsClause (getF stateA) reason;\n         isReason reason (opposite l) (elements (getM stateA));\n         getF stateB = getF stateA; getM stateB = getM stateA;\n         getConflictFlag stateB = True;\n         getC stateB = resolve (getC stateA) reason l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedExplain_def"], ["proof (prove)\nusing this:\n  \\<exists>l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA \\<and>\n     getConflictFlag stateB = True \\<and>\n     getC stateB = resolve (getC stateA) reason l\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         formulaEntailsClause (getF stateA) reason;\n         isReason reason (opposite l) (elements (getM stateA));\n         getF stateB = getF stateA; getM stateB = getM stateA;\n         getConflictFlag stateB = True;\n         getC stateB = resolve (getC stateA) reason l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  l el getC stateA\n  formulaEntailsClause (getF stateA) reason\n  isReason reason (opposite l) (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = resolve (getC stateA) reason l\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>\n        \\<open>getF stateB = getF stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  getF stateB = getF stateA\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \n        \\<open>getM stateB = getM stateA\\<close>\n        \\<open>InvariantConsistent (getM stateA)\\<close>"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA\n  InvariantConsistent (getM stateA)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \n        \\<open>getM stateB = getM stateA\\<close>\n        \\<open>InvariantUniq (getM stateA)\\<close>"], ["proof (prove)\nusing this:\n  getM stateB = getM stateA\n  InvariantUniq (getM stateA)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantReasonClauses (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "using \n        \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = getM stateA\\<close>\n        \\<open>InvariantReasonClauses (getF stateA) (getM stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  getM stateB = getM stateA\n  InvariantReasonClauses (getF stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using \n        \\<open>getF stateB = getF stateA\\<close>\n        \\<open>InvariantEquivalent F0 (getF stateA)\\<close>"], ["proof (prove)\nusing this:\n  getF stateB = getF stateA\n  InvariantEquivalent F0 (getF stateA)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "using \n        \\<open>InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\\<close>\n        \\<open>l el getC stateA\\<close>\n        \\<open>isReason reason (opposite l) (elements (getM stateA))\\<close>\n        \\<open>getM stateB = getM stateA\\<close>\n        \\<open>getC stateB = resolve (getC stateA) reason l\\<close>\n        \\<open>getConflictFlag stateA = True\\<close>\n        \\<open>getConflictFlag stateB = True\\<close>\n        InvariantCFalseAfterExplain[of \"getConflictFlag stateA\" \"getM stateA\" \"getC stateA\" \"opposite l\" \"reason\" \"getC stateB\"]"], ["proof (prove)\nusing this:\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  l el getC stateA\n  isReason reason (opposite l) (elements (getM stateA))\n  getM stateB = getM stateA\n  getC stateB = resolve (getC stateA) reason l\n  getConflictFlag stateA = True\n  getConflictFlag stateB = True\n  \\<lbrakk>InvariantCFalse (getConflictFlag stateA) (getM stateA)\n            (getC stateA);\n   opposite (opposite l) el getC stateA;\n   isReason reason (opposite l) (elements (getM stateA));\n   getC stateB =\n   resolve (getC stateA) reason (opposite (opposite l))\\<rbrakk>\n  \\<Longrightarrow> InvariantCFalse (getConflictFlag stateA) (getM stateA)\n                     (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "using \n        \\<open>InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\\<close>\n        \\<open>l el getC stateA\\<close>\n        \\<open>isReason reason (opposite l) (elements (getM stateA))\\<close>\n        \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getC stateB = resolve (getC stateA) reason l\\<close>\n        \\<open>getConflictFlag stateA = True\\<close>\n        \\<open>getConflictFlag stateB = True\\<close>\n        \\<open>formulaEntailsClause (getF stateA) reason\\<close>\n        InvariantCEntailedAfterExplain[of \"getConflictFlag stateA\" \"getF stateA\" \"getC stateA\" \"reason\" \"getC stateB\" \"opposite l\"]"], ["proof (prove)\nusing this:\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n  l el getC stateA\n  isReason reason (opposite l) (elements (getM stateA))\n  getF stateB = getF stateA\n  getC stateB = resolve (getC stateA) reason l\n  getConflictFlag stateA = True\n  getConflictFlag stateB = True\n  formulaEntailsClause (getF stateA) reason\n  \\<lbrakk>InvariantCEntailed (getConflictFlag stateA) (getF stateA)\n            (getC stateA);\n   formulaEntailsClause (getF stateA) reason;\n   getC stateB =\n   resolve (getC stateA) reason (opposite (opposite l))\\<rbrakk>\n  \\<Longrightarrow> InvariantCEntailed (getConflictFlag stateA)\n                     (getF stateA) (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and>\n    InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n    InvariantEquivalent F0 (getF stateB) \\<and>\n    InvariantCFalse (getConflictFlag stateB) (getM stateB)\n     (getC stateB) \\<and>\n    InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedExplain stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedExplain stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedExplain stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedLearn stateA stateB\""], ["proof (state)\nthis:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "hence\n      \"getConflictFlag stateA = True\"\n      \"\\<not>  getC stateA el getF stateA\"\n      \"getF stateB = getF stateA @ [getC stateA]\"\n      \"getM stateB = getM stateA\"\n      \"getConflictFlag stateB = True\"\n      \"getC stateB = getC stateA\""], ["proof (prove)\nusing this:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. (getConflictFlag stateA = True &&&\n     \\<not> getC stateA el getF stateA &&&\n     getF stateB = getF stateA @ [getC stateA]) &&&\n    getM stateB = getM stateA &&&\n    getConflictFlag stateB = True &&& getC stateB = getC stateA", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True \\<and>\n  \\<not> getC stateA el getF stateA \\<and>\n  getF stateB = getF stateA @ [getC stateA] \\<and>\n  getM stateB = getM stateA \\<and>\n  getConflictFlag stateB = True \\<and> getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (getConflictFlag stateA = True &&&\n     \\<not> getC stateA el getF stateA &&&\n     getF stateB = getF stateA @ [getC stateA]) &&&\n    getM stateB = getM stateA &&&\n    getConflictFlag stateB = True &&& getC stateB = getC stateA", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n  getF stateB = getF stateA @ [getC stateA]\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>getConflictFlag stateA = True\\<close> \\<open>InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\\<close>"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = True\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)", "have \"formulaEntailsClause (getF stateA) (getC stateA)\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF stateA) (getC stateA)", "unfolding InvariantCEntailed_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  getConflictFlag stateA \\<longrightarrow>\n  formulaEntailsClause (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF stateA) (getC stateA)", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\\<close> \\<open>getConflictFlag stateA = True\\<close>"], ["proof (chain)\npicking this:\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  getConflictFlag stateA = True", "have \"clauseFalse (getC stateA) (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  getConflictFlag stateA = True\n\ngoal (1 subgoal):\n 1. clauseFalse (getC stateA) (elements (getM stateA))", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA \\<longrightarrow>\n  clauseFalse (getC stateA) (elements (getM stateA))\n  getConflictFlag stateA = True\n\ngoal (1 subgoal):\n 1. clauseFalse (getC stateA) (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  clauseFalse (getC stateA) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "with \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  clauseFalse (getC stateA) (elements (getM stateA))", "have \"(vars (getC stateA)) \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  clauseFalse (getC stateA) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. vars (getC stateA) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  clauseFalse (getC stateA) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. vars (getC stateA) \\<subseteq> vars F0 \\<union> decisionVars", "using valuationContainsItsFalseClausesVariables[of \"getC stateA\" \"elements (getM stateA)\"]"], ["proof (prove)\nusing this:\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  clauseFalse (getC stateA) (elements (getM stateA))\n  clauseFalse (getC stateA) (elements (getM stateA)) \\<Longrightarrow>\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. vars (getC stateA) \\<subseteq> vars F0 \\<union> decisionVars", "by simp"], ["proof (state)\nthis:\n  vars (getC stateA) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "hence \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\nusing this:\n  vars (getC stateA) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>getF stateB = getF stateA @ [getC stateA]\\<close>\n        \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>\n        InvariantVarsFAfterLearn [of \"getF stateA\" \"F0\" \"decisionVars\" \"getC stateA\" \"getF stateB\"]"], ["proof (prove)\nusing this:\n  vars (getC stateA) \\<subseteq> vars F0 \\<union> decisionVars\n  getF stateB = getF stateA @ [getC stateA]\n  InvariantVarsF (getF stateA) F0 decisionVars\n  \\<lbrakk>InvariantVarsF (getF stateA) F0 decisionVars;\n   vars (getC stateA) \\<subseteq> vars F0 \\<union> decisionVars;\n   getF stateB = getF stateA @ [getC stateA]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>getM stateB = getM stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  getM stateB = getM stateA\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantReasonClauses (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "using\n        \\<open>InvariantReasonClauses (getF stateA) (getM stateA)\\<close>\n        \\<open>formulaEntailsClause (getF stateA) (getC stateA)\\<close>\n        \\<open>getF stateB = getF stateA @ [getC stateA]\\<close>\n        \\<open>getM stateB = getM stateA\\<close>\n        InvariantReasonClausesAfterLearn[of \"getF stateA\" \"getM stateA\" \"getC stateA\" \"getF stateB\"]"], ["proof (prove)\nusing this:\n  InvariantReasonClauses (getF stateA) (getM stateA)\n  formulaEntailsClause (getF stateA) (getC stateA)\n  getF stateB = getF stateA @ [getC stateA]\n  getM stateB = getM stateA\n  \\<lbrakk>InvariantReasonClauses (getF stateA) (getM stateA);\n   formulaEntailsClause (getF stateA) (getC stateA);\n   getF stateB = getF stateA @ [getC stateA]\\<rbrakk>\n  \\<Longrightarrow> InvariantReasonClauses (getF stateB) (getM stateA)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using\n        \\<open>InvariantEquivalent F0 (getF stateA)\\<close>\n        \\<open>formulaEntailsClause (getF stateA) (getC stateA)\\<close>\n        \\<open>getF stateB = getF stateA @ [getC stateA]\\<close>\n        InvariantEquivalentAfterLearn[of \"F0\" \"getF stateA\" \"getC stateA\" \"getF stateB\"]"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 (getF stateA)\n  formulaEntailsClause (getF stateA) (getC stateA)\n  getF stateB = getF stateA @ [getC stateA]\n  \\<lbrakk>InvariantEquivalent F0 (getF stateA);\n   formulaEntailsClause (getF stateA) (getC stateA);\n   getF stateB = getF stateA @ [getC stateA]\\<rbrakk>\n  \\<Longrightarrow> InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "using \\<open>InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\\<close>\n        \\<open>getM stateB = getM stateA\\<close>\n        \\<open>getConflictFlag stateA = True\\<close>\n        \\<open>getConflictFlag stateB = True\\<close>\n        \\<open>getM stateB = getM stateA\\<close>\n        \\<open>getC stateB = getC stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  getM stateB = getM stateA\n  getConflictFlag stateA = True\n  getConflictFlag stateB = True\n  getM stateB = getM stateA\n  getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "using\n        \\<open>InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\\<close>\n        \\<open>formulaEntailsClause (getF stateA) (getC stateA)\\<close>\n        \\<open>getF stateB = getF stateA @ [getC stateA]\\<close>\n        \\<open>getConflictFlag stateA = True\\<close>\n        \\<open>getConflictFlag stateB = True\\<close>\n        \\<open>getC stateB = getC stateA\\<close>\n        InvariantCEntailedAfterLearn[of \"getConflictFlag stateA\" \"getF stateA\" \"getC stateA\" \"getF stateB\"]"], ["proof (prove)\nusing this:\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n  formulaEntailsClause (getF stateA) (getC stateA)\n  getF stateB = getF stateA @ [getC stateA]\n  getConflictFlag stateA = True\n  getConflictFlag stateB = True\n  getC stateB = getC stateA\n  \\<lbrakk>InvariantCEntailed (getConflictFlag stateA) (getF stateA)\n            (getC stateA);\n   getF stateB = getF stateA @ [getC stateA]\\<rbrakk>\n  \\<Longrightarrow> InvariantCEntailed (getConflictFlag stateA)\n                     (getF stateB) (getC stateA)\n\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and>\n    InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n    InvariantEquivalent F0 (getF stateB) \\<and>\n    InvariantCFalse (getConflictFlag stateB) (getM stateB)\n     (getC stateB) \\<and>\n    InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "assume \"appliedBackjump stateA stateB\""], ["proof (state)\nthis:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  appliedBackjump stateA stateB", "obtain l::Literal and level::nat\n      where \n      \"getConflictFlag stateA = True\"\n      \"isBackjumpLevel level l (getC stateA) (getM stateA)\"\n      \"getF stateB = getF stateA\"\n      \"getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\"\n      \"getConflictFlag stateB = False\"\n      \"getC stateB = []\""], ["proof (prove)\nusing this:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA);\n         getF stateB = getF stateA;\n         getM stateB = prefixToLevel level (getM stateA) @ [(l, False)];\n         getConflictFlag stateB = False; getC stateB = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = prefixToLevel level (getM stateA) @ [(l, False)] \\<and>\n     getConflictFlag stateB = False \\<and> getC stateB = []\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA);\n         getF stateB = getF stateA;\n         getM stateB = prefixToLevel level (getM stateA) @ [(l, False)];\n         getConflictFlag stateB = False; getC stateB = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "with \\<open>InvariantConsistent (getM stateA)\\<close> \\<open>InvariantUniq (getM stateA)\\<close>\n      \\<open>InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\\<close>"], ["proof (chain)\npicking this:\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []", "have \"isUnitClause (getC stateA) l (elements (prefixToLevel level (getM stateA)))\""], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  InvariantUniq (getM stateA)\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []\n\ngoal (1 subgoal):\n 1. isUnitClause (getC stateA) l\n     (elements (prefixToLevel level (getM stateA)))", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  uniq (elements (getM stateA))\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []\n\ngoal (1 subgoal):\n 1. isUnitClause (getC stateA) l\n     (elements (prefixToLevel level (getM stateA)))", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  consistent (elements (getM stateA))\n  uniq (elements (getM stateA))\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []\n\ngoal (1 subgoal):\n 1. isUnitClause (getC stateA) l\n     (elements (prefixToLevel level (getM stateA)))", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  consistent (elements (getM stateA))\n  uniq (elements (getM stateA))\n  getConflictFlag stateA \\<longrightarrow>\n  clauseFalse (getC stateA) (elements (getM stateA))\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []\n\ngoal (1 subgoal):\n 1. isUnitClause (getC stateA) l\n     (elements (prefixToLevel level (getM stateA)))", "using isBackjumpLevelEnsuresIsUnitInPrefix[of \"getM stateA\" \"getC stateA\" \"level\" \"l\"]"], ["proof (prove)\nusing this:\n  consistent (elements (getM stateA))\n  uniq (elements (getM stateA))\n  getConflictFlag stateA \\<longrightarrow>\n  clauseFalse (getC stateA) (elements (getM stateA))\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []\n  \\<lbrakk>consistent (elements (getM stateA));\n   uniq (elements (getM stateA));\n   clauseFalse (getC stateA) (elements (getM stateA));\n   isBackjumpLevel level l (getC stateA) (getM stateA)\\<rbrakk>\n  \\<Longrightarrow> isUnitClause (getC stateA) l\n                     (elements (prefixToLevel level (getM stateA)))\n\ngoal (1 subgoal):\n 1. isUnitClause (getC stateA) l\n     (elements (prefixToLevel level (getM stateA)))", "by simp"], ["proof (state)\nthis:\n  isUnitClause (getC stateA) l\n   (elements (prefixToLevel level (getM stateA)))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>getConflictFlag stateA = True\\<close> \\<open>InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\\<close>"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = True\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)", "have \"formulaEntailsClause (getF stateA) (getC stateA)\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF stateA) (getC stateA)", "unfolding InvariantCEntailed_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  getConflictFlag stateA \\<longrightarrow>\n  formulaEntailsClause (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF stateA) (getC stateA)", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>isBackjumpLevel level l (getC stateA) (getM stateA)\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel level l (getC stateA) (getM stateA)", "have \"isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA)) (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n     (elements (getM stateA))", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA)) \\<and>\n  0 \\<le> level \\<and>\n  level < elementLevel (opposite l) (getM stateA) \\<and>\n  (\\<forall>l'.\n      l' el getC stateA \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') (getM stateA) \\<le> level)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n     (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "hence \"l el getC stateA\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. l el getC stateA", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList (getC stateA) \\<and>\n  literalTrue (opposite l) (elements (getM stateA)) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList (getC stateA) \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. l el getC stateA", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"getC stateA\"]"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList (getC stateA) \\<and>\n  literalTrue (opposite l) (elements (getM stateA)) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList (getC stateA) \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements (getM stateA)))\n  l el getC stateA = opposite l el oppositeLiteralList (getC stateA)\n\ngoal (1 subgoal):\n 1. l el getC stateA", "by simp"], ["proof (state)\nthis:\n  l el getC stateA\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefix (prefixToLevel level (getM stateA)) (getM stateA)", "by (simp add:isPrefixPrefixToLevel)"], ["proof (state)\nthis:\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>getConflictFlag stateA = True\\<close> \\<open>InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\\<close>"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = True\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)", "have \"formulaEntailsClause (getF stateA) (getC stateA)\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF stateA) (getC stateA)", "unfolding InvariantCEntailed_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  getConflictFlag stateA \\<longrightarrow>\n  formulaEntailsClause (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (getF stateA) (getC stateA)", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>getConflictFlag stateA = True\\<close> \\<open>InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\\<close>"], ["proof (chain)\npicking this:\n  getConflictFlag stateA = True\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)", "have \"clauseFalse (getC stateA) (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  InvariantCFalse (getConflictFlag stateA) (getM stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. clauseFalse (getC stateA) (elements (getM stateA))", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  getConflictFlag stateA \\<longrightarrow>\n  clauseFalse (getC stateA) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. clauseFalse (getC stateA) (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  clauseFalse (getC stateA) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "hence \"vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  clauseFalse (getC stateA) (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. vars (getC stateA) \\<subseteq> vars (elements (getM stateA))", "using valuationContainsItsFalseClausesVariables[of \"getC stateA\" \"elements (getM stateA)\"]"], ["proof (prove)\nusing this:\n  clauseFalse (getC stateA) (elements (getM stateA))\n  clauseFalse (getC stateA) (elements (getM stateA)) \\<Longrightarrow>\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. vars (getC stateA) \\<subseteq> vars (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "from \\<open>l el getC stateA\\<close>"], ["proof (chain)\npicking this:\n  l el getC stateA", "have \"var l \\<in> vars (getC stateA)\""], ["proof (prove)\nusing this:\n  l el getC stateA\n\ngoal (1 subgoal):\n 1. var l \\<in> vars (getC stateA)", "using clauseContainsItsLiteralsVariable[of \"l\" \"getC stateA\"]"], ["proof (prove)\nusing this:\n  l el getC stateA\n  l el getC stateA \\<Longrightarrow> var l \\<in> vars (getC stateA)\n\ngoal (1 subgoal):\n 1. var l \\<in> vars (getC stateA)", "by simp"], ["proof (state)\nthis:\n  var l \\<in> vars (getC stateA)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n  var l \\<in> vars (getC stateA)", "have \"var l \\<in> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n  var l \\<in> vars (getC stateA)\n\ngoal (1 subgoal):\n 1. var l \\<in> vars F0 \\<union> decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n  var l \\<in> vars (getC stateA)\n  InvariantVarsM (getM stateA) F0 decisionVars\n\ngoal (1 subgoal):\n 1. var l \\<in> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (getC stateA) \\<subseteq> vars (elements (getM stateA))\n  var l \\<in> vars (getC stateA)\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. var l \\<in> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  var l \\<in> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsM (getM stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "using \\<open>InvariantVarsM (getM stateA) F0 decisionVars\\<close>\n        \\<open>isUnitClause (getC stateA) l (elements (prefixToLevel level (getM stateA)))\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>var l \\<in> vars F0 \\<union> decisionVars\\<close>\n        \\<open>formulaEntailsClause (getF stateA) (getC stateA)\\<close>\n        \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<close>\n        InvariantVarsMAfterBackjump[of \"getM stateA\" \"F0\" \"decisionVars\" \"prefixToLevel level (getM stateA)\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars\n  isUnitClause (getC stateA) l\n   (elements (prefixToLevel level (getM stateA)))\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  var l \\<in> vars F0 \\<union> decisionVars\n  formulaEntailsClause (getF stateA) (getC stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  \\<lbrakk>InvariantVarsM (getM stateA) F0 decisionVars;\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   var l \\<in> vars F0 \\<union> decisionVars;\n   getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantVarsF (getF stateB) F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "using \\<open>InvariantVarsF (getF stateA) F0 decisionVars\\<close>\n        \\<open>getF stateB = getF stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantVarsF (getF stateA) F0 decisionVars\n  getF stateB = getF stateA\n\ngoal (1 subgoal):\n 1. InvariantVarsF (getF stateB) F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF stateB) F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantConsistent (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "using \\<open>InvariantConsistent (getM stateA)\\<close>\n        \\<open>isUnitClause (getC stateA) l (elements (prefixToLevel level (getM stateA)))\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<close>\n        InvariantConsistentAfterBackjump[of \"getM stateA\" \"prefixToLevel level (getM stateA)\" \"getC stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM stateA)\n  isUnitClause (getC stateA) l\n   (elements (prefixToLevel level (getM stateA)))\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  \\<lbrakk>InvariantConsistent (getM stateA);\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   isUnitClause (getC stateA) l\n    (elements (prefixToLevel level (getM stateA)));\n   getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantUniq (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close>\n        \\<open>isUnitClause (getC stateA) l (elements (prefixToLevel level (getM stateA)))\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<close>\n        InvariantUniqAfterBackjump[of \"getM stateA\" \"prefixToLevel level (getM stateA)\" \"getC stateA\" \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  isUnitClause (getC stateA) l\n   (elements (prefixToLevel level (getM stateA)))\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  \\<lbrakk>InvariantUniq (getM stateA);\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   isUnitClause (getC stateA) l\n    (elements (prefixToLevel level (getM stateA)));\n   getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantReasonClauses (getF stateB) (getM stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "using \\<open>InvariantUniq (getM stateA)\\<close> \\<open>InvariantReasonClauses (getF stateA) (getM stateA)\\<close>\n        \\<open>isUnitClause (getC stateA) l (elements (prefixToLevel level (getM stateA)))\\<close>\n        \\<open>isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\\<close>\n        \\<open>formulaEntailsClause (getF stateA) (getC stateA)\\<close>\n        \\<open>getF stateB = getF stateA\\<close>\n        \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<close>\n        InvariantReasonClausesAfterBackjump[of \"getF stateA\" \"getM stateA\"\n        \"prefixToLevel level (getM stateA)\" \"getC stateA\"  \"l\" \"getM stateB\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM stateA)\n  InvariantReasonClauses (getF stateA) (getM stateA)\n  isUnitClause (getC stateA) l\n   (elements (prefixToLevel level (getM stateA)))\n  isPrefix (prefixToLevel level (getM stateA)) (getM stateA)\n  formulaEntailsClause (getF stateA) (getC stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  \\<lbrakk>InvariantReasonClauses (getF stateA) (getM stateA);\n   InvariantUniq (getM stateA);\n   isPrefix (prefixToLevel level (getM stateA)) (getM stateA);\n   isUnitClause (getC stateA) l\n    (elements (prefixToLevel level (getM stateA)));\n   formulaEntailsClause (getF stateA) (getC stateA);\n   getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantReasonClauses (getF stateA) (getM stateB)\n\ngoal (1 subgoal):\n 1. InvariantReasonClauses (getF stateB) (getM stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantReasonClauses (getF stateB) (getM stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantEquivalent F0 (getF stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "using\n      \\<open>InvariantEquivalent F0 (getF stateA)\\<close>\n      \\<open>getF stateB = getF stateA\\<close>"], ["proof (prove)\nusing this:\n  InvariantEquivalent F0 (getF stateA)\n  getF stateB = getF stateA\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "using \\<open>getConflictFlag stateB = False\\<close>"], ["proof (prove)\nusing this:\n  getConflictFlag stateB = False\n\ngoal (1 subgoal):\n 1. InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateB = False\n\ngoal (1 subgoal):\n 1. getConflictFlag stateB \\<longrightarrow>\n    clauseFalse (getC stateB) (elements (getM stateB))", "by simp"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "have \"InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "using \\<open>getConflictFlag stateB = False\\<close>"], ["proof (prove)\nusing this:\n  getConflictFlag stateB = False\n\ngoal (1 subgoal):\n 1. InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "unfolding InvariantCEntailed_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateB = False\n\ngoal (1 subgoal):\n 1. getConflictFlag stateB \\<longrightarrow>\n    formulaEntailsClause (getF stateB) (getC stateB)", "by simp"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "have ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars\n  InvariantVarsF (getF stateB) F0 decisionVars\n  InvariantConsistent (getM stateB)\n  InvariantUniq (getM stateB)\n  InvariantReasonClauses (getF stateB) (getM stateB)\n  InvariantEquivalent F0 (getF stateB)\n  InvariantCFalse (getConflictFlag stateB) (getM stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n    InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n    InvariantConsistent (getM stateB) \\<and>\n    InvariantUniq (getM stateB) \\<and>\n    InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n    InvariantEquivalent F0 (getF stateB) \\<and>\n    InvariantCFalse (getConflictFlag stateB) (getM stateB)\n     (getC stateB) \\<and>\n    InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using \\<open>transition stateA stateB F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  transition stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  invariantsHoldInState stateB F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedConflict stateA stateB \\<or>\n  appliedExplain stateA stateB \\<or>\n  appliedLearn stateA stateB \\<or> appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The consequence is that invariants hold in all valid runs.\\<close>"], ["", "lemma invariantsHoldInValidRuns: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"(stateA, stateB) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using assms"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using transitionsPreserveInvariants"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using rtrancl_induct[of \"stateA\" \"stateB\" \n  \"{(stateA, stateB). transition stateA stateB F0 decisionVars}\" \"\\<lambda> x. invariantsHoldInState x F0 decisionVars\"]"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n  \\<lbrakk>(stateA, stateB)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   invariantsHoldInState stateA F0 decisionVars;\n   \\<And>y z.\n      \\<lbrakk>(stateA, y)\n               \\<in> {(stateA, stateB).\n                      transition stateA stateB F0 decisionVars}\\<^sup>*;\n       (y, z)\n       \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars};\n       invariantsHoldInState y F0 decisionVars\\<rbrakk>\n      \\<Longrightarrow> invariantsHoldInState z F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  (stateA, stateB)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n  \\<lbrakk>(stateA, stateB)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   invariantsHoldInState stateA F0 decisionVars;\n   \\<And>y z.\n      \\<lbrakk>(stateA, y)\n               \\<in> {(stateA, stateB).\n                      transition stateA stateB F0 decisionVars}\\<^sup>*;\n       (y, z)\n       \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars};\n       invariantsHoldInState y F0 decisionVars\\<rbrakk>\n      \\<Longrightarrow> invariantsHoldInState z F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["", "lemma invariantsHoldInValidRunsFromInitialState:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\"\n  assumes \"isInitialState state0 F0\" \n  and \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n  shows \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "from \\<open>isInitialState state0 F0\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0", "have \"invariantsHoldInState state0 F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state0 F0 decisionVars", "by (simp add:invariantsHoldInInitialState)"], ["proof (state)\nthis:\n  invariantsHoldInState state0 F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "with assms"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  invariantsHoldInState state0 F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  invariantsHoldInState state0 F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRuns [of \"state0\"  \"F0\" \"decisionVars\" \"state\"]"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  invariantsHoldInState state0 F0 decisionVars\n  \\<lbrakk>invariantsHoldInState state0 F0 decisionVars;\n   (state0, state) \\<in> transitionRelation F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n In the following text we will show that there are two kinds of states:\n \\begin{enumerate}\n  \\item \\textit{UNSAT} states where @{term \"getConflictFlag state = True\"}\n  and @{term \"getC state = []\"}. \n  \\item \\textit{SAT} states where @{term \"getConflictFlag state = False\"}, \n  @{term \"\\<not> formulaFalse F0 (elements (getM state))\"} and \n  @{term \"vars (elements (getM state)) \\<supseteq> decisionVars\"}. \n \\end{enumerate}\n  \n The soundness theorems claim that if \\textit{UNSAT} state is reached\n the formula is unsatisfiable and if \\textit{SAT} state is reached,\n the formula is satisfiable.\n\n Completeness theorems claim that every final state is either\n \\textit{UNSAT} or \\textit{SAT}. A consequence of this and soundness\n theorems, is that if formula is unsatisfiable the solver will finish\n in an \\textit{UNSAT} state, and if the formula is satisfiable the\n solver will finish in a \\textit{SAT} state.\n\\<close>"], ["", "(******************************************************************************)"], ["", "subsection\\<open>Soundness\\<close>"], ["", "(******************************************************************************)"], ["", "theorem soundnessForUNSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\"\n\n  \"getConflictFlag state = True\" and\n  \"getC state = []\"\n  shows \"\\<not> satisfiable F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "hence \n    \"InvariantEquivalent F0 (getF state)\"\n    \"InvariantCEntailed (getConflictFlag state) (getF state) (getC state)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF state) &&&\n    InvariantCEntailed (getConflictFlag state) (getF state) (getC state)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantVarsF (getF state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and>\n  InvariantUniq (getM state) \\<and>\n  InvariantReasonClauses (getF state) (getM state) \\<and>\n  InvariantEquivalent F0 (getF state) \\<and>\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state) \\<and>\n  InvariantCEntailed (getConflictFlag state) (getF state) (getC state)\n\ngoal (1 subgoal):\n 1. InvariantEquivalent F0 (getF state) &&&\n    InvariantCEntailed (getConflictFlag state) (getF state) (getC state)", "by auto"], ["proof (state)\nthis:\n  InvariantEquivalent F0 (getF state)\n  InvariantCEntailed (getConflictFlag state) (getF state) (getC state)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "with \\<open>getConflictFlag state = True\\<close> \\<open>getC state = []\\<close>"], ["proof (chain)\npicking this:\n  getConflictFlag state = True\n  getC state = []\n  InvariantEquivalent F0 (getF state)\n  InvariantCEntailed (getConflictFlag state) (getF state) (getC state)", "show ?thesis"], ["proof (prove)\nusing this:\n  getConflictFlag state = True\n  getC state = []\n  InvariantEquivalent F0 (getF state)\n  InvariantCEntailed (getConflictFlag state) (getF state) (getC state)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by (simp add:unsatReportExtensiveExplain)"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem soundnessForSAT:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n\n  \"getConflictFlag state = False\"\n  \"\\<not> formulaFalse (getF state) (elements (getM state))\"\n  \"vars (elements (getM state)) \\<supseteq> decisionVars\"  \n  shows \n  \"model (elements (getM state)) F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "hence \n    \"InvariantConsistent (getM state)\" \n    \"InvariantEquivalent F0 (getF state)\"\n    \"InvariantVarsF (getF state) F0 decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state) &&&\n    InvariantEquivalent F0 (getF state) &&&\n    InvariantVarsF (getF state) F0 decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantVarsF (getF state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and>\n  InvariantUniq (getM state) \\<and>\n  InvariantReasonClauses (getF state) (getM state) \\<and>\n  InvariantEquivalent F0 (getF state) \\<and>\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state) \\<and>\n  InvariantCEntailed (getConflictFlag state) (getF state) (getC state)\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state) &&&\n    InvariantEquivalent F0 (getF state) &&&\n    InvariantVarsF (getF state) F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "with assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  getConflictFlag state = False\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  getConflictFlag state = False\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "using satReport[of \"F0\" \"decisionVars\" \"getF state\" \"getM state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  getConflictFlag state = False\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantEquivalent F0 (getF state)\n  InvariantVarsF (getF state) F0 decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars;\n   InvariantVarsF (getF state) F0 decisionVars;\n   InvariantConsistent (getM state); InvariantEquivalent F0 (getF state);\n   \\<not> formulaFalse (getF state) (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. model (elements (getM state)) F0", "by simp"], ["proof (state)\nthis:\n  model (elements (getM state)) F0\n\ngoal:\nNo subgoals!", "qed"], ["", "(**************************************************************************)\n(*                          T E R M I N A T I O N                         *)\n(**************************************************************************)"], ["", "subsection\\<open>Termination\\<close>"], ["", "text\\<open>We now define a termination ordering which is a lexicographic combination\nof @{term lexLessRestricted} trail ordering, @{term boolLess} conflict flag ordering, \n@{term multLess} conflict clause ordering and @{term learnLess} formula ordering. \nThis ordering will be central in termination proof.\\<close>"], ["", "definition \"lexLessState (F0::Formula) decisionVars == {((stateA::State), (stateB::State)).\n  (getM stateA, getM stateB) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\""], ["", "definition \"boolLessState == {((stateA::State), (stateB::State)).\n  getM stateA = getM stateB \\<and>\n  (getConflictFlag stateA, getConflictFlag stateB) \\<in> boolLess}\""], ["", "definition \"multLessState == {((stateA::State), (stateB::State)).\n  getM stateA = getM stateB \\<and>\n  getConflictFlag stateA = getConflictFlag stateB \\<and>\n  (getC stateA, getC stateB) \\<in> multLess (getM stateA)}\""], ["", "definition \"learnLessState == {((stateA::State), (stateB::State)).\n  getM stateA = getM stateB \\<and>\n  getConflictFlag stateA = getConflictFlag stateB \\<and>\n  getC stateA = getC stateB \\<and>\n  (getF stateA, getF stateB) \\<in> learnLess (getC stateA)}\""], ["", "definition \"terminationLess F0 decisionVars == {((stateA::State), (stateB::State)).\n  (stateA,stateB) \\<in> lexLessState F0 decisionVars \\<or>\n  (stateA,stateB) \\<in> boolLessState   \\<or>\n  (stateA,stateB) \\<in> multLessState   \\<or>\n  (stateA,stateB) \\<in> learnLessState}\""], ["", "text\\<open>We want to show that every valid transition decreases a state\n  with respect to the constructed termination ordering.\\<close>"], ["", "text\\<open>First we show that $Decide$, $UnitPropagate$ and $Backjump$ rule\ndecrease the trail with respect to the restricted trail ordering\n@{term lexLessRestricted}. Invariants ensure that trails are indeed\nuniq, consistent and with finite variable sets.\\<close>"], ["", "lemma trailIsDecreasedByDeciedUnitPropagateAndBackjump:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and\n  \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 decisionVars \\<or> appliedBackjump stateA stateB\"\n  shows \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 decisionVars \\<or> appliedBackjump stateA stateB\\<close>\n    \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars", "have \"invariantsHoldInState stateB F0 decisionVars\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "using transitionsPreserveInvariants"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>transition ?stateA ?stateB ?F0.0 ?decisionVars;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n  invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>appliedDecide ?stateA ?stateB ?decisionVars \\<or>\n           appliedUnitPropagate ?stateA ?stateB ?F0.0 ?decisionVars \\<or>\n           appliedConflict ?stateA ?stateB \\<or>\n           appliedExplain ?stateA ?stateB \\<or>\n           appliedLearn ?stateA ?stateB \\<or>\n           appliedBackjump ?stateA ?stateB;\n   invariantsHoldInState ?stateA ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?stateB ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState stateB F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars", "have *: \"uniq (elements (getM stateA))\" \"consistent (elements (getM stateA))\" \"vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateA) F0 decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and>\n  InvariantUniq (getM stateA) \\<and>\n  InvariantReasonClauses (getF stateA) (getM stateA) \\<and>\n  InvariantEquivalent F0 (getF stateA) \\<and>\n  InvariantCFalse (getConflictFlag stateA) (getM stateA)\n   (getC stateA) \\<and>\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateA) \\<and>\n  InvariantUniq (getM stateA) \\<and>\n  InvariantReasonClauses (getF stateA) (getM stateA) \\<and>\n  InvariantEquivalent F0 (getF stateA) \\<and>\n  InvariantCFalse (getConflictFlag stateA) (getM stateA)\n   (getC stateA) \\<and>\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  consistent (elements (getM stateA)) \\<and>\n  InvariantUniq (getM stateA) \\<and>\n  InvariantReasonClauses (getF stateA) (getM stateA) \\<and>\n  InvariantEquivalent F0 (getF stateA) \\<and>\n  InvariantCFalse (getConflictFlag stateA) (getM stateA)\n   (getC stateA) \\<and>\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  vars (elements (getM stateA))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateA) F0 decisionVars \\<and>\n  consistent (elements (getM stateA)) \\<and>\n  uniq (elements (getM stateA)) \\<and>\n  InvariantReasonClauses (getF stateA) (getM stateA) \\<and>\n  InvariantEquivalent F0 (getF stateA) \\<and>\n  InvariantCFalse (getConflictFlag stateA) (getM stateA)\n   (getC stateA) \\<and>\n  InvariantCEntailed (getConflictFlag stateA) (getF stateA) (getC stateA)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateA)) &&&\n    consistent (elements (getM stateA)) &&&\n    vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>invariantsHoldInState stateB F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateB F0 decisionVars", "have **: \"uniq (elements (getM stateB))\" \"consistent (elements (getM stateB))\" \"vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM stateB) F0 decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateB) \\<and>\n  InvariantUniq (getM stateB) \\<and>\n  InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n  InvariantEquivalent F0 (getF stateB) \\<and>\n  InvariantCFalse (getConflictFlag stateB) (getM stateB)\n   (getC stateB) \\<and>\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  InvariantConsistent (getM stateB) \\<and>\n  InvariantUniq (getM stateB) \\<and>\n  InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n  InvariantEquivalent F0 (getF stateB) \\<and>\n  InvariantCFalse (getConflictFlag stateB) (getM stateB)\n   (getC stateB) \\<and>\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  consistent (elements (getM stateB)) \\<and>\n  InvariantUniq (getM stateB) \\<and>\n  InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n  InvariantEquivalent F0 (getF stateB) \\<and>\n  InvariantCFalse (getConflictFlag stateB) (getM stateB)\n   (getC stateB) \\<and>\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  vars (elements (getM stateB))\n  \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n  InvariantVarsF (getF stateB) F0 decisionVars \\<and>\n  consistent (elements (getM stateB)) \\<and>\n  uniq (elements (getM stateB)) \\<and>\n  InvariantReasonClauses (getF stateB) (getM stateB) \\<and>\n  InvariantEquivalent F0 (getF stateB) \\<and>\n  InvariantCFalse (getConflictFlag stateB) (getM stateB)\n   (getC stateB) \\<and>\n  InvariantCEntailed (getConflictFlag stateB) (getF stateB) (getC stateB)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM stateB)) &&&\n    consistent (elements (getM stateB)) &&&\n    vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars", "by auto"], ["proof (state)\nthis:\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedDecide stateA stateB decisionVars\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "unfolding appliedDecide_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM stateA) \\<and>\n     \\<not> opposite l el elements (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(l, True)] \\<and>\n     getConflictFlag stateB = getConflictFlag stateA \\<and>\n     getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (auto simp add:lexLessAppend)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"((getM stateB), (getM stateA)) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedUnitPropagate stateA stateB F0 decisionVars\""], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  appliedUnitPropagate stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "unfolding appliedUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<exists>uc ul.\n     formulaEntailsClause (getF stateA) uc \\<and>\n     var ul \\<in> decisionVars \\<union> vars F0 \\<and>\n     isUnitClause uc ul (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA @ [(ul, False)] \\<and>\n     getConflictFlag stateB = getConflictFlag stateA \\<and>\n     getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (auto simp add:lexLessAppend)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "moreover"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "{"], ["proof (state)\nthis:\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "assume \"appliedBackjump stateA stateB\""], ["proof (state)\nthis:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "then"], ["proof (chain)\npicking this:\n  appliedBackjump stateA stateB", "obtain l::Literal and level::nat\n      where \n      \"getConflictFlag stateA = True\"\n      \"isBackjumpLevel level l (getC stateA) (getM stateA)\"\n      \"getF stateB = getF stateA\"\n      \"getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\"\n      \"getConflictFlag stateB = False\"\n      \"getC stateB = []\""], ["proof (prove)\nusing this:\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA);\n         getF stateB = getF stateA;\n         getM stateB = prefixToLevel level (getM stateA) @ [(l, False)];\n         getConflictFlag stateB = False; getC stateB = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedBackjump_def"], ["proof (prove)\nusing this:\n  \\<exists>l level.\n     getConflictFlag stateA = True \\<and>\n     isBackjumpLevel level l (getC stateA) (getM stateA) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = prefixToLevel level (getM stateA) @ [(l, False)] \\<and>\n     getConflictFlag stateB = False \\<and> getC stateB = []\n\ngoal (1 subgoal):\n 1. (\\<And>level l.\n        \\<lbrakk>getConflictFlag stateA = True;\n         isBackjumpLevel level l (getC stateA) (getM stateA);\n         getF stateB = getF stateA;\n         getM stateB = prefixToLevel level (getM stateA) @ [(l, False)];\n         getConflictFlag stateB = False; getC stateB = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n  getF stateB = getF stateA\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  getConflictFlag stateB = False\n  getC stateB = []\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>isBackjumpLevel level l (getC stateA) (getM stateA)\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel level l (getC stateA) (getM stateA)", "have \"isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA)) (elements (getM stateA))\""], ["proof (prove)\nusing this:\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n     (elements (getM stateA))", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA)) \\<and>\n  0 \\<le> level \\<and>\n  level < elementLevel (opposite l) (getM stateA) \\<and>\n  (\\<forall>l'.\n      l' el getC stateA \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') (getM stateA) \\<le> level)\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n     (elements (getM stateA))", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"(opposite l) el elements (getM stateA)\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. opposite l el elements (getM stateA)", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  opposite l el oppositeLiteralList (getC stateA) \\<and>\n  literalTrue (opposite l) (elements (getM stateA)) \\<and>\n  (\\<forall>literal'.\n      literal' el oppositeLiteralList (getC stateA) \\<and>\n      literal' \\<noteq> opposite l \\<longrightarrow>\n      \\<not> precedes (opposite l) literal' (elements (getM stateA)))\n\ngoal (1 subgoal):\n 1. opposite l el elements (getM stateA)", "by simp"], ["proof (state)\nthis:\n  opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "hence \"elementLevel (opposite l) (getM stateA) <= currentLevel (getM stateA)\""], ["proof (prove)\nusing this:\n  opposite l el elements (getM stateA)\n\ngoal (1 subgoal):\n 1. elementLevel (opposite l) (getM stateA) \\<le> currentLevel (getM stateA)", "by (simp add: elementLevelLeqCurrentLevel)"], ["proof (state)\nthis:\n  elementLevel (opposite l) (getM stateA) \\<le> currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "moreover"], ["proof (state)\nthis:\n  elementLevel (opposite l) (getM stateA) \\<le> currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "from \\<open>isBackjumpLevel level l (getC stateA) (getM stateA)\\<close>"], ["proof (chain)\npicking this:\n  isBackjumpLevel level l (getC stateA) (getM stateA)", "have \"0 \\<le> level\" and \"level < elementLevel (opposite l) (getM stateA)\""], ["proof (prove)\nusing this:\n  isBackjumpLevel level l (getC stateA) (getM stateA)\n\ngoal (1 subgoal):\n 1. 0 \\<le> level &&& level < elementLevel (opposite l) (getM stateA)", "unfolding isBackjumpLevel_def"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA)) \\<and>\n  0 \\<le> level \\<and>\n  level < elementLevel (opposite l) (getM stateA) \\<and>\n  (\\<forall>l'.\n      l' el getC stateA \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') (getM stateA) \\<le> level)\n\ngoal (1 subgoal):\n 1. 0 \\<le> level &&& level < elementLevel (opposite l) (getM stateA)", "using \\<open>isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA)) (elements (getM stateA))\\<close>"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA)) \\<and>\n  0 \\<le> level \\<and>\n  level < elementLevel (opposite l) (getM stateA) \\<and>\n  (\\<forall>l'.\n      l' el getC stateA \\<and> l' \\<noteq> l \\<longrightarrow>\n      elementLevel (opposite l') (getM stateA) \\<le> level)\n  isLastAssertedLiteral (opposite l) (oppositeLiteralList (getC stateA))\n   (elements (getM stateA))\n\ngoal (1 subgoal):\n 1. 0 \\<le> level &&& level < elementLevel (opposite l) (getM stateA)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> level\n  level < elementLevel (opposite l) (getM stateA)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "ultimately"], ["proof (chain)\npicking this:\n  elementLevel (opposite l) (getM stateA) \\<le> currentLevel (getM stateA)\n  0 \\<le> level\n  level < elementLevel (opposite l) (getM stateA)", "have \"level < currentLevel (getM stateA)\""], ["proof (prove)\nusing this:\n  elementLevel (opposite l) (getM stateA) \\<le> currentLevel (getM stateA)\n  0 \\<le> level\n  level < elementLevel (opposite l) (getM stateA)\n\ngoal (1 subgoal):\n 1. level < currentLevel (getM stateA)", "by simp"], ["proof (state)\nthis:\n  level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with \\<open>0 \\<le> level\\<close> \\<open>getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> level\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  level < currentLevel (getM stateA)", "have \"(getM stateB, getM stateA) \\<in> lexLess\""], ["proof (prove)\nusing this:\n  0 \\<le> level\n  getM stateB = prefixToLevel level (getM stateA) @ [(l, False)]\n  level < currentLevel (getM stateA)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA) \\<in> lexLess", "by (simp add:lexLessBackjump)"], ["proof (state)\nthis:\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "with * **"], ["proof (chain)\npicking this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM stateA))\n  consistent (elements (getM stateA))\n  vars (elements (getM stateA)) \\<subseteq> vars F0 \\<union> decisionVars\n  uniq (elements (getM stateB))\n  consistent (elements (getM stateB))\n  vars (elements (getM stateB)) \\<subseteq> vars F0 \\<union> decisionVars\n  (getM stateB, getM stateA) \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> {(M1, M2).\n           vars (elements M1)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M1) \\<and>\n           uniq (elements M1) \\<and>\n           vars (elements M2)\n           \\<subseteq> vars F0 \\<union> decisionVars \\<and>\n           consistent (elements M2) \\<and>\n           uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "}"], ["proof (state)\nthis:\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "using assms"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by auto"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Next we show that $Conflict$ decreases the conflict flag in the @{term boolLess} ordering.\\<close>"], ["", "lemma conflictFlagIsDecreasedByConflict:\n  fixes stateA::State and stateB::State\n  assumes \"appliedConflict stateA stateB\"\n  shows \"getM stateA = getM stateB\" and \"(getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess", "using assms"], ["proof (prove)\nusing this:\n  appliedConflict stateA stateB\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess", "unfolding appliedConflict_def"], ["proof (prove)\nusing this:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA \\<and>\n     getConflictFlag stateB = True \\<and> getC stateB = clause\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess", "unfolding boolLess_def"], ["proof (prove)\nusing this:\n  \\<exists>clause.\n     getConflictFlag stateA = False \\<and>\n     formulaEntailsClause (getF stateA) clause \\<and>\n     clauseFalse clause (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA \\<and>\n     getConflictFlag stateB = True \\<and> getC stateB = clause\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    (getConflictFlag stateB, getConflictFlag stateA) \\<in> {(True, False)}", "by auto"], ["", "text\\<open>Next we show that $Explain$ decreases the conflict clause with\nrespect to the @{term multLess} clause ordering.\\<close>"], ["", "lemma conflictClauseIsDecreasedByExplain:\n  fixes stateA::State and stateB::State\n  assumes \"appliedExplain stateA stateB\"\n  shows \n  \"getM stateA = getM stateB\" and \n  \"getConflictFlag stateA = getConflictFlag stateB\" and \n  \"(getC stateB, getC stateA) \\<in> multLess (getM stateA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    getConflictFlag stateA = getConflictFlag stateB &&&\n    (getC stateB, getC stateA) \\<in> multLess (getM stateA)", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. getM stateA = getM stateB\n 2. getConflictFlag stateA = getConflictFlag stateB\n 3. (getC stateB, getC stateA) \\<in> multLess (getM stateA)", "from \\<open>appliedExplain stateA stateB\\<close>"], ["proof (chain)\npicking this:\n  appliedExplain stateA stateB", "obtain l::Literal and reason::Clause where\n    \"getConflictFlag stateA = True\"\n    \"l el (getC stateA)\"\n    \"isReason reason (opposite l) (elements (getM stateA))\"\n    \"getF stateB = getF stateA\"\n    \"getM stateB = getM stateA\"\n    \"getConflictFlag stateB = True\"\n    \"getC stateB = resolve (getC stateA) reason l\""], ["proof (prove)\nusing this:\n  appliedExplain stateA stateB\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         isReason reason (opposite l) (elements (getM stateA));\n         getF stateB = getF stateA; getM stateB = getM stateA;\n         getConflictFlag stateB = True;\n         getC stateB = resolve (getC stateA) reason l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding appliedExplain_def"], ["proof (prove)\nusing this:\n  \\<exists>l reason.\n     getConflictFlag stateA = True \\<and>\n     l el getC stateA \\<and>\n     formulaEntailsClause (getF stateA) reason \\<and>\n     isReason reason (opposite l) (elements (getM stateA)) \\<and>\n     getF stateB = getF stateA \\<and>\n     getM stateB = getM stateA \\<and>\n     getConflictFlag stateB = True \\<and>\n     getC stateB = resolve (getC stateA) reason l\n\ngoal (1 subgoal):\n 1. (\\<And>l reason.\n        \\<lbrakk>getConflictFlag stateA = True; l el getC stateA;\n         isReason reason (opposite l) (elements (getM stateA));\n         getF stateB = getF stateA; getM stateB = getM stateA;\n         getConflictFlag stateB = True;\n         getC stateB = resolve (getC stateA) reason l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  l el getC stateA\n  isReason reason (opposite l) (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = resolve (getC stateA) reason l\n\ngoal (3 subgoals):\n 1. getM stateA = getM stateB\n 2. getConflictFlag stateA = getConflictFlag stateB\n 3. (getC stateB, getC stateA) \\<in> multLess (getM stateA)", "thus \"getM stateA = getM stateB\" \"getConflictFlag stateA = getConflictFlag stateB\" \"(getC stateB, getC stateA) \\<in> multLess (getM stateA)\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  l el getC stateA\n  isReason reason (opposite l) (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = resolve (getC stateA) reason l\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    getConflictFlag stateA = getConflictFlag stateB &&&\n    (getC stateB, getC stateA) \\<in> multLess (getM stateA)", "using multLessResolve[of \"opposite l\" \"getC stateA\" \"reason\" \"getM stateA\"]"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  l el getC stateA\n  isReason reason (opposite l) (elements (getM stateA))\n  getF stateB = getF stateA\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = resolve (getC stateA) reason l\n  \\<lbrakk>opposite (opposite l) el getC stateA;\n   isReason reason (opposite l) (elements (getM stateA))\\<rbrakk>\n  \\<Longrightarrow> (resolve (getC stateA) reason (opposite (opposite l)),\n                     getC stateA)\n                    \\<in> multLess (getM stateA)\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    getConflictFlag stateA = getConflictFlag stateB &&&\n    (getC stateB, getC stateA) \\<in> multLess (getM stateA)", "by auto"], ["proof (state)\nthis:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  (getC stateB, getC stateA) \\<in> multLess (getM stateA)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Finally, we show that $Learn$ decreases the formula in the @{term learnLess} formula ordering.\\<close>"], ["", "lemma formulaIsDecreasedByLearn:\n  fixes stateA::State and stateB::State\n  assumes \"appliedLearn stateA stateB\"\n  shows \n  \"getM stateA = getM stateB\" and \n  \"getConflictFlag stateA = getConflictFlag stateB\" and \n  \"getC stateA = getC stateB\" and \n  \"(getF stateB, getF stateA) \\<in> learnLess (getC stateA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (getM stateA = getM stateB &&&\n     getConflictFlag stateA = getConflictFlag stateB) &&&\n    getC stateA = getC stateB &&&\n    (getF stateB, getF stateA) \\<in> learnLess (getC stateA)", "proof-"], ["proof (state)\ngoal (4 subgoals):\n 1. getM stateA = getM stateB\n 2. getConflictFlag stateA = getConflictFlag stateB\n 3. getC stateA = getC stateB\n 4. (getF stateB, getF stateA) \\<in> learnLess (getC stateA)", "from \\<open>appliedLearn stateA stateB\\<close>"], ["proof (chain)\npicking this:\n  appliedLearn stateA stateB", "have\n      \"getConflictFlag stateA = True\"\n      \"\\<not> getC stateA el getF stateA\"\n      \"getF stateB = getF stateA @ [getC stateA]\"\n      \"getM stateB = getM stateA\"\n      \"getConflictFlag stateB = True\"\n      \"getC stateB = getC stateA\""], ["proof (prove)\nusing this:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. (getConflictFlag stateA = True &&&\n     \\<not> getC stateA el getF stateA &&&\n     getF stateB = getF stateA @ [getC stateA]) &&&\n    getM stateB = getM stateA &&&\n    getConflictFlag stateB = True &&& getC stateB = getC stateA", "unfolding appliedLearn_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True \\<and>\n  \\<not> getC stateA el getF stateA \\<and>\n  getF stateB = getF stateA @ [getC stateA] \\<and>\n  getM stateB = getM stateA \\<and>\n  getConflictFlag stateB = True \\<and> getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (getConflictFlag stateA = True &&&\n     \\<not> getC stateA el getF stateA &&&\n     getF stateB = getF stateA @ [getC stateA]) &&&\n    getM stateB = getM stateA &&&\n    getConflictFlag stateB = True &&& getC stateB = getC stateA", "by auto"], ["proof (state)\nthis:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n  getF stateB = getF stateA @ [getC stateA]\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = getC stateA\n\ngoal (4 subgoals):\n 1. getM stateA = getM stateB\n 2. getConflictFlag stateA = getConflictFlag stateB\n 3. getC stateA = getC stateB\n 4. (getF stateB, getF stateA) \\<in> learnLess (getC stateA)", "thus \n    \"getM stateA = getM stateB\"\n    \"getConflictFlag stateA = getConflictFlag stateB\"\n    \"getC stateA = getC stateB\"\n    \"(getF stateB, getF stateA) \\<in> learnLess (getC stateA)\""], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n  getF stateB = getF stateA @ [getC stateA]\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (getM stateA = getM stateB &&&\n     getConflictFlag stateA = getConflictFlag stateB) &&&\n    getC stateA = getC stateB &&&\n    (getF stateB, getF stateA) \\<in> learnLess (getC stateA)", "unfolding learnLess_def"], ["proof (prove)\nusing this:\n  getConflictFlag stateA = True\n  \\<not> getC stateA el getF stateA\n  getF stateB = getF stateA @ [getC stateA]\n  getM stateB = getM stateA\n  getConflictFlag stateB = True\n  getC stateB = getC stateA\n\ngoal (1 subgoal):\n 1. (getM stateA = getM stateB &&&\n     getConflictFlag stateA = getConflictFlag stateB) &&&\n    getC stateA = getC stateB &&&\n    (getF stateB, getF stateA)\n    \\<in> {(F1, F2). getC stateA el F1 \\<and> \\<not> getC stateA el F2}", "by auto"], ["proof (state)\nthis:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  getC stateA = getC stateB\n  (getF stateB, getF stateA) \\<in> learnLess (getC stateA)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we can prove that every rule application decreases a state\nwith respect to the constructed termination ordering.\\<close>"], ["", "lemma stateIsDecreasedByValidTransitions:\n  fixes stateA::State and stateB::State\n  assumes \"invariantsHoldInState stateA F0 decisionVars\" and \"transition stateA stateB F0 decisionVars\"\n  shows \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "assume \"appliedDecide stateA stateB decisionVars \\<or> appliedUnitPropagate stateA stateB F0 decisionVars \\<or> appliedBackjump stateA stateB\""], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "with \\<open>invariantsHoldInState stateA F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB", "have \"(getM stateB, getM stateA) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "using trailIsDecreasedByDeciedUnitPropagateAndBackjump"], ["proof (prove)\nusing this:\n  invariantsHoldInState stateA F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB\n  \\<lbrakk>invariantsHoldInState ?stateA ?F0.0 ?decisionVars;\n   appliedDecide ?stateA ?stateB ?decisionVars \\<or>\n   appliedUnitPropagate ?stateA ?stateB ?F0.0 ?decisionVars \\<or>\n   appliedBackjump ?stateA ?stateB\\<rbrakk>\n  \\<Longrightarrow> (getM ?stateB, getM ?stateA)\n                    \\<in> lexLessRestricted\n                           (vars ?F0.0 \\<union> ?decisionVars)\n\ngoal (1 subgoal):\n 1. (getM stateB, getM stateA)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by simp"], ["proof (state)\nthis:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> lexLessState F0 decisionVars\""], ["proof (prove)\nusing this:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> lexLessState F0 decisionVars", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  (getM stateB, getM stateA)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (getM stateA, getM stateB)\n           \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n           (stateA, stateB) \\<in> boolLessState \\<or>\n           (stateA, stateB) \\<in> multLessState \\<or>\n           (stateA, stateB) \\<in> learnLessState}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "assume \"appliedConflict stateA stateB\""], ["proof (state)\nthis:\n  appliedConflict stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"getM stateA = getM stateB\" \"(getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess\""], ["proof (prove)\nusing this:\n  appliedConflict stateA stateB\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess", "using conflictFlagIsDecreasedByConflict"], ["proof (prove)\nusing this:\n  appliedConflict stateA stateB\n  appliedConflict ?stateA ?stateB \\<Longrightarrow>\n  getM ?stateA = getM ?stateB\n  appliedConflict ?stateA ?stateB \\<Longrightarrow>\n  (getConflictFlag ?stateB, getConflictFlag ?stateA) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess", "by auto"], ["proof (state)\nthis:\n  getM stateA = getM stateB\n  (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> boolLessState\""], ["proof (prove)\nusing this:\n  getM stateA = getM stateB\n  (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> boolLessState", "unfolding boolLessState_def"], ["proof (prove)\nusing this:\n  getM stateA = getM stateB\n  (getConflictFlag stateB, getConflictFlag stateA) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           getM stateA = getM stateB \\<and>\n           (getConflictFlag stateA, getConflictFlag stateB) \\<in> boolLess}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n           (stateA, stateB) \\<in> boolLessState \\<or>\n           (stateA, stateB) \\<in> multLessState \\<or>\n           (stateA, stateB) \\<in> learnLessState}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedConflict stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedConflict stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedConflict stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "assume \"appliedExplain stateA stateB\""], ["proof (state)\nthis:\n  appliedExplain stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"getM stateA = getM stateB\"\n      \"getConflictFlag stateA = getConflictFlag stateB\"\n      \"(getC stateB, getC stateA) \\<in> multLess (getM stateA)\""], ["proof (prove)\nusing this:\n  appliedExplain stateA stateB\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    getConflictFlag stateA = getConflictFlag stateB &&&\n    (getC stateB, getC stateA) \\<in> multLess (getM stateA)", "using conflictClauseIsDecreasedByExplain"], ["proof (prove)\nusing this:\n  appliedExplain stateA stateB\n  appliedExplain ?stateA ?stateB \\<Longrightarrow>\n  getM ?stateA = getM ?stateB\n  appliedExplain ?stateA ?stateB \\<Longrightarrow>\n  getConflictFlag ?stateA = getConflictFlag ?stateB\n  appliedExplain ?stateA ?stateB \\<Longrightarrow>\n  (getC ?stateB, getC ?stateA) \\<in> multLess (getM ?stateA)\n\ngoal (1 subgoal):\n 1. getM stateA = getM stateB &&&\n    getConflictFlag stateA = getConflictFlag stateB &&&\n    (getC stateB, getC stateA) \\<in> multLess (getM stateA)", "by auto"], ["proof (state)\nthis:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  (getC stateB, getC stateA) \\<in> multLess (getM stateA)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> multLessState\""], ["proof (prove)\nusing this:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  (getC stateB, getC stateA) \\<in> multLess (getM stateA)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> multLessState", "unfolding multLessState_def"], ["proof (prove)\nusing this:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  (getC stateB, getC stateA) \\<in> multLess (getM stateA)\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           getM stateA = getM stateB \\<and>\n           getConflictFlag stateA = getConflictFlag stateB \\<and>\n           (getC stateA, getC stateB) \\<in> multLess (getM stateA)}", "unfolding multLess_def"], ["proof (prove)\nusing this:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  (getC stateB, getC stateA)\n  \\<in> inv_image (mult (precedesOrder (elements (getM stateA))))\n         (\\<lambda>x. mset (remdups (oppositeLiteralList x)))\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           getM stateA = getM stateB \\<and>\n           getConflictFlag stateA = getConflictFlag stateB \\<and>\n           (getC stateA, getC stateB)\n           \\<in> inv_image (mult (precedesOrder (elements (getM stateA))))\n                  (\\<lambda>x. mset (remdups (oppositeLiteralList x)))}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n           (stateA, stateB) \\<in> boolLessState \\<or>\n           (stateA, stateB) \\<in> multLessState \\<or>\n           (stateA, stateB) \\<in> learnLessState}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedExplain stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  appliedExplain stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "{"], ["proof (state)\nthis:\n  appliedExplain stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "assume \"appliedLearn stateA stateB\""], ["proof (state)\nthis:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \n      \"getM stateA = getM stateB\"\n      \"getConflictFlag stateA = getConflictFlag stateB\"\n      \"getC stateA = getC stateB\"\n      \"(getF stateB, getF stateA) \\<in> learnLess (getC stateA)\""], ["proof (prove)\nusing this:\n  appliedLearn stateA stateB\n\ngoal (1 subgoal):\n 1. (getM stateA = getM stateB &&&\n     getConflictFlag stateA = getConflictFlag stateB) &&&\n    getC stateA = getC stateB &&&\n    (getF stateB, getF stateA) \\<in> learnLess (getC stateA)", "using formulaIsDecreasedByLearn"], ["proof (prove)\nusing this:\n  appliedLearn stateA stateB\n  appliedLearn ?stateA ?stateB \\<Longrightarrow> getM ?stateA = getM ?stateB\n  appliedLearn ?stateA ?stateB \\<Longrightarrow>\n  getConflictFlag ?stateA = getConflictFlag ?stateB\n  appliedLearn ?stateA ?stateB \\<Longrightarrow> getC ?stateA = getC ?stateB\n  appliedLearn ?stateA ?stateB \\<Longrightarrow>\n  (getF ?stateB, getF ?stateA) \\<in> learnLess (getC ?stateA)\n\ngoal (1 subgoal):\n 1. (getM stateA = getM stateB &&&\n     getConflictFlag stateA = getConflictFlag stateB) &&&\n    getC stateA = getC stateB &&&\n    (getF stateB, getF stateA) \\<in> learnLess (getC stateA)", "by auto"], ["proof (state)\nthis:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  getC stateA = getC stateB\n  (getF stateB, getF stateA) \\<in> learnLess (getC stateA)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> learnLessState\""], ["proof (prove)\nusing this:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  getC stateA = getC stateB\n  (getF stateB, getF stateA) \\<in> learnLess (getC stateA)\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> learnLessState", "unfolding learnLessState_def"], ["proof (prove)\nusing this:\n  getM stateA = getM stateB\n  getConflictFlag stateA = getConflictFlag stateB\n  getC stateA = getC stateB\n  (getF stateB, getF stateA) \\<in> learnLess (getC stateA)\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           getM stateA = getM stateB \\<and>\n           getConflictFlag stateA = getConflictFlag stateB \\<and>\n           getC stateA = getC stateB \\<and>\n           (getF stateA, getF stateB) \\<in> learnLess (getC stateA)}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (stateB, stateA) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (stateB, stateA)\n    \\<in> {(stateA, stateB).\n           (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n           (stateA, stateB) \\<in> boolLessState \\<or>\n           (stateA, stateB) \\<in> multLessState \\<or>\n           (stateA, stateB) \\<in> learnLessState}", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "}"], ["proof (state)\nthis:\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars", "show ?thesis"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "using \\<open>transition stateA stateB F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  transition stateA stateB F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedBackjump stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedConflict stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedExplain stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedLearn stateA stateB \\<Longrightarrow>\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n  appliedDecide stateA stateB decisionVars \\<or>\n  appliedUnitPropagate stateA stateB F0 decisionVars \\<or>\n  appliedConflict stateA stateB \\<or>\n  appliedExplain stateA stateB \\<or>\n  appliedLearn stateA stateB \\<or> appliedBackjump stateA stateB\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The minimal states with respect to the termination ordering are\n  final i.e., no further transition rules are applicable.\\<close>"], ["", "definition \n\"isMinimalState stateMin F0 decisionVars == (\\<forall> state::State. (state, stateMin) \\<notin> terminationLess F0 decisionVars)\""], ["", "lemma minimalStatesAreFinal:\n  fixes stateA::State\n  assumes\n  \"invariantsHoldInState state F0 decisionVars\" and \"isMinimalState state F0 decisionVars\"\n  shows \"isFinalState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<not> isFinalState state F0 decisionVars", "obtain state'::State \n      where \"transition state state' F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition state state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isFinalState_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>state'. transition state state' F0 decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition state state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transition state state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "with \\<open>invariantsHoldInState state F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  invariantsHoldInState state F0 decisionVars\n  transition state state' F0 decisionVars", "have \"(state', state) \\<in> terminationLess F0 decisionVars\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  transition state state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars", "using stateIsDecreasedByValidTransitions[of \"state\" \"F0\" \"decisionVars\" \"state'\"]"], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  transition state state' F0 decisionVars\n  \\<lbrakk>invariantsHoldInState state F0 decisionVars;\n   transition state state' F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars", "unfolding transition_def"], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n  appliedDecide state state' decisionVars \\<or>\n  appliedUnitPropagate state state' F0 decisionVars \\<or>\n  appliedConflict state state' \\<or>\n  appliedExplain state state' \\<or>\n  appliedLearn state state' \\<or> appliedBackjump state state'\n  \\<lbrakk>invariantsHoldInState state F0 decisionVars;\n   appliedDecide state state' decisionVars \\<or>\n   appliedUnitPropagate state state' F0 decisionVars \\<or>\n   appliedConflict state state' \\<or>\n   appliedExplain state state' \\<or>\n   appliedLearn state state' \\<or> appliedBackjump state state'\\<rbrakk>\n  \\<Longrightarrow> (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state) \\<in> terminationLess F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "with \\<open>isMinimalState state F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isMinimalState state F0 decisionVars\n  (state', state) \\<in> terminationLess F0 decisionVars", "have False"], ["proof (prove)\nusing this:\n  isMinimalState state F0 decisionVars\n  (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. False", "unfolding isMinimalState_def"], ["proof (prove)\nusing this:\n  \\<forall>statea. (statea, state) \\<notin> terminationLess F0 decisionVars\n  (state', state) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "}"], ["proof (state)\nthis:\n  \\<not> isFinalState state F0 decisionVars \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> isFinalState state F0 decisionVars \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. isFinalState state F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  isFinalState state F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We now prove that termination ordering is well founded. We\nstart with several auxiliary lemmas, one for each component of the termination ordering.\\<close>"], ["", "lemma wfLexLessState: \n  fixes decisionVars :: \"Variable set\" and F0 :: Formula\n  assumes \"finite decisionVars\"\n  shows \"wf (lexLessState F0 decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (lexLessState F0 decisionVars)", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists>stateMin\\<in>Q. \\<forall>state'. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{M::LiteralTrail. \\<exists> state. state \\<in> Q \\<and> (getM state) = M}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getM state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getM state\n    \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by auto"], ["proof (state)\nthis:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>finite decisionVars\\<close>"], ["proof (chain)\npicking this:\n  finite decisionVars", "have \"finite (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  finite decisionVars\n\ngoal (1 subgoal):\n 1. finite (vars F0 \\<union> decisionVars)", "using finiteVarsFormula[of \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars\n  finite (vars F0)\n\ngoal (1 subgoal):\n 1. finite (vars F0 \\<union> decisionVars)", "by simp"], ["proof (state)\nthis:\n  finite (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "hence \"wf (lexLessRestricted (vars F0 \\<union> decisionVars))\""], ["proof (prove)\nusing this:\n  finite (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "using  wfLexLessRestricted[of \"vars F0 \\<union> decisionVars\"]"], ["proof (prove)\nusing this:\n  finite (vars F0 \\<union> decisionVars)\n  finite (vars F0 \\<union> decisionVars) \\<Longrightarrow>\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "by simp"], ["proof (state)\nthis:\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>getM state \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))", "obtain Mmin where \"Mmin \\<in> ?Q1\" \"\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars) \\<longrightarrow> M' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> decisionVars))\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> decisionVars) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     \\<forall>x.\n        x \\<in> {M. \\<exists>state.\n                       state \\<in> Q \\<and>\n                       getM state = M} \\<longrightarrow>\n        (\\<exists>z\\<in>{M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}.\n            \\<forall>y.\n               (y, z)\n               \\<in> lexLessRestricted\n                      (vars F0 \\<union> decisionVars) \\<longrightarrow>\n               y \\<notin> {M. \\<exists>state.\n                                 state \\<in> Q \\<and>\n                                 getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getM state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> decisionVars) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     getM state\n     \\<in> {M. \\<exists>state.\n                  state \\<in> Q \\<and> getM state = M} \\<longrightarrow>\n     (\\<exists>z\\<in>{M. \\<exists>state.\n                            state \\<in> Q \\<and> getM state = M}.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted\n                   (vars F0 \\<union> decisionVars) \\<longrightarrow>\n            y \\<notin> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>Mmin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "obtain stateMin\n        where \"stateMin \\<in> Q\" \"(getM stateMin) = Mmin\""], ["proof (prove)\nusing this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = Mmin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin)\n       \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> lexLessState F0 decisionVars\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "hence \"(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\""], ["proof (prove)\nusing this:\n  (state', stateMin) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  (state', stateMin)\n  \\<in> {(stateA, stateB).\n         (getM stateA, getM stateB)\n         \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)", "by auto"], ["proof (state)\nthis:\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union>  decisionVars) \\<longrightarrow> M' \\<notin> ?Q1\\<close>\n            \\<open>(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\\<close> \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  getM stateMin = Mmin", "have \"getM state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted\n            (vars F0 \\<union> decisionVars) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. getM state'\n    \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by simp"], ["proof (state)\nthis:\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin)\n          \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfBoolLessState: \n  shows \"wf boolLessState\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf boolLessState", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> boolLessState \\<longrightarrow> y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> boolLessState \\<longrightarrow> y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists>stateMin\\<in>Q. \\<forall>state'. (state', stateMin) \\<in> boolLessState \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?M = \"(getM state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{b::bool. \\<exists> state. state \\<in> Q \\<and> (getM state) = ?M \\<and> (getConflictFlag state) = b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getConflictFlag state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getConflictFlag state\n    \\<in> {b. \\<exists>statea.\n                 statea \\<in> Q \\<and>\n                 getM statea = getM state \\<and> getConflictFlag statea = b}", "by auto"], ["proof (state)\nthis:\n  getConflictFlag state\n  \\<in> {b. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getConflictFlag statea = b}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "with wfBoolLess"], ["proof (chain)\npicking this:\n  wf boolLess\n  getConflictFlag state\n  \\<in> {b. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getConflictFlag statea = b}", "obtain bMin where \"bMin \\<in> ?Q1\" \"\\<forall>b'. (b', bMin) \\<in> boolLess \\<longrightarrow> b' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  wf boolLess\n  getConflictFlag state\n  \\<in> {b. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getConflictFlag statea = b}\n\ngoal (1 subgoal):\n 1. (\\<And>bMin.\n        \\<lbrakk>bMin\n                 \\<in> {b. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getConflictFlag statea = b};\n         \\<forall>b'.\n            (b', bMin) \\<in> boolLess \\<longrightarrow>\n            b' \\<notin> {b. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getConflictFlag statea = b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y. (y, z) \\<in> boolLess \\<longrightarrow> y \\<notin> Q)\n  getConflictFlag state\n  \\<in> {b. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getConflictFlag statea = b}\n\ngoal (1 subgoal):\n 1. (\\<And>bMin.\n        \\<lbrakk>bMin\n                 \\<in> {b. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getConflictFlag statea = b};\n         \\<forall>b'.\n            (b', bMin) \\<in> boolLess \\<longrightarrow>\n            b' \\<notin> {b. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getConflictFlag statea = b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>bMin.\n                \\<lbrakk>bMin\n                         \\<in> {b. \\<exists>statea.\nstatea \\<in> Q \\<and>\ngetM statea = getM state \\<and> getConflictFlag statea = b};\n                 \\<forall>b'.\n                    (b', bMin) \\<in> boolLess \\<longrightarrow>\n                    b' \\<notin> {b. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and> getConflictFlag statea = b}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getConflictFlag state\n     \\<in> {b. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = b};\n     \\<forall>x.\n        x \\<in> {b. \\<exists>statea.\n                       statea \\<in> Q \\<and>\n                       getM statea = getM state \\<and>\n                       getConflictFlag statea = b} \\<longrightarrow>\n        (\\<exists>z\\<in>{b. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getConflictFlag statea = b}.\n            \\<forall>y.\n               (y, z) \\<in> boolLess \\<longrightarrow>\n               y \\<notin> {b. \\<exists>statea.\n                                 statea \\<in> Q \\<and>\n                                 getM statea = getM state \\<and>\n                                 getConflictFlag statea = b})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getConflictFlag state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>bMin.\n                \\<lbrakk>bMin\n                         \\<in> {b. \\<exists>statea.\nstatea \\<in> Q \\<and>\ngetM statea = getM state \\<and> getConflictFlag statea = b};\n                 \\<forall>b'.\n                    (b', bMin) \\<in> boolLess \\<longrightarrow>\n                    b' \\<notin> {b. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and> getConflictFlag statea = b}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getConflictFlag state\n     \\<in> {b. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = b};\n     getConflictFlag state\n     \\<in> {b. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = b} \\<longrightarrow>\n     (\\<exists>z\\<in>{b. \\<exists>statea.\n                            statea \\<in> Q \\<and>\n                            getM statea = getM state \\<and>\n                            getConflictFlag statea = b}.\n         \\<forall>y.\n            (y, z) \\<in> boolLess \\<longrightarrow>\n            y \\<notin> {b. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getConflictFlag statea = b})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  bMin\n  \\<in> {b. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getConflictFlag statea = b}\n  \\<forall>b'.\n     (b', bMin) \\<in> boolLess \\<longrightarrow>\n     b' \\<notin> {b. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and>\n                        getConflictFlag statea = b}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>bMin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  bMin\n  \\<in> {b. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getConflictFlag statea = b}", "obtain stateMin\n        where \"stateMin \\<in> Q\" \"(getM stateMin) = ?M\" \"getConflictFlag stateMin = bMin\""], ["proof (prove)\nusing this:\n  bMin\n  \\<in> {b. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getConflictFlag statea = b}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = getM state;\n         getConflictFlag stateMin = bMin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = getM state\n  getConflictFlag stateMin = bMin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> boolLessState \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> boolLessState \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> boolLessState \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> boolLessState\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> boolLessState \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = ?M\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = getM state\n  (state', stateMin) \\<in> boolLessState", "have \"getM state' = getM stateMin\" \"(getConflictFlag state', getConflictFlag stateMin) \\<in> boolLess\""], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  (state', stateMin) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. getM state' = getM stateMin &&&\n    (getConflictFlag state', getConflictFlag stateMin) \\<in> boolLess", "unfolding boolLessState_def"], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  (state', stateMin)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         (getConflictFlag stateA, getConflictFlag stateB) \\<in> boolLess}\n\ngoal (1 subgoal):\n 1. getM state' = getM stateMin &&&\n    (getConflictFlag state', getConflictFlag stateMin) \\<in> boolLess", "by auto"], ["proof (state)\nthis:\n  getM state' = getM stateMin\n  (getConflictFlag state', getConflictFlag stateMin) \\<in> boolLess\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> boolLessState \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>b'. (b', bMin) \\<in> boolLess \\<longrightarrow> b' \\<notin> ?Q1\\<close> \n            \\<open>(getConflictFlag state', getConflictFlag stateMin) \\<in> boolLess\\<close> \\<open>getConflictFlag stateMin = bMin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>b'.\n     (b', bMin) \\<in> boolLess \\<longrightarrow>\n     b' \\<notin> {b. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and>\n                        getConflictFlag statea = b}\n  (getConflictFlag state', getConflictFlag stateMin) \\<in> boolLess\n  getConflictFlag stateMin = bMin", "have \"getConflictFlag state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>b'.\n     (b', bMin) \\<in> boolLess \\<longrightarrow>\n     b' \\<notin> {b. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and>\n                        getConflictFlag statea = b}\n  (getConflictFlag state', getConflictFlag stateMin) \\<in> boolLess\n  getConflictFlag stateMin = bMin\n\ngoal (1 subgoal):\n 1. getConflictFlag state'\n    \\<notin> {b. \\<exists>statea.\n                    statea \\<in> Q \\<and>\n                    getM statea = getM state \\<and>\n                    getConflictFlag statea = b}", "by simp"], ["proof (state)\nthis:\n  getConflictFlag state'\n  \\<notin> {b. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = b}\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> boolLessState \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM state' = getM stateMin\\<close> \\<open>getM stateMin = ?M\\<close>"], ["proof (chain)\npicking this:\n  getM state' = getM stateMin\n  getM stateMin = getM state\n  getConflictFlag state'\n  \\<notin> {b. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = b}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM state' = getM stateMin\n  getM stateMin = getM state\n  getConflictFlag state'\n  \\<notin> {b. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = b}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin) \\<in> boolLessState \\<longrightarrow> state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> boolLessState \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> boolLessState \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfMultLessState:\n  shows \"wf multLessState\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf multLessState", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> multLessState \\<longrightarrow> y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> multLessState \\<longrightarrow> y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists> stateMin \\<in> Q. \\<forall>state'. (state', stateMin) \\<in> multLessState \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?M = \"(getM state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{C::Clause. \\<exists> state. state \\<in> Q \\<and> (getM state) = ?M \\<and> (getC state) = C}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getC state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getC state\n    \\<in> {C. \\<exists>statea.\n                 statea \\<in> Q \\<and>\n                 getM statea = getM state \\<and> getC statea = C}", "by auto"], ["proof (state)\nthis:\n  getC state\n  \\<in> {C. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getC statea = C}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "with wfMultLess[of \"?M\"]"], ["proof (chain)\npicking this:\n  wf (multLess (getM state))\n  getC state\n  \\<in> {C. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getC statea = C}", "obtain Cmin where \"Cmin \\<in> ?Q1\" \"\\<forall>C'. (C', Cmin) \\<in> multLess ?M \\<longrightarrow> C' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  wf (multLess (getM state))\n  getC state\n  \\<in> {C. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getC statea = C}\n\ngoal (1 subgoal):\n 1. (\\<And>Cmin.\n        \\<lbrakk>Cmin\n                 \\<in> {C. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getC statea = C};\n         \\<forall>C'.\n            (C', Cmin) \\<in> multLess (getM state) \\<longrightarrow>\n            C' \\<notin> {C. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getC statea = C}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> multLess (getM state) \\<longrightarrow>\n            y \\<notin> Q)\n  getC state\n  \\<in> {C. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getC statea = C}\n\ngoal (1 subgoal):\n 1. (\\<And>Cmin.\n        \\<lbrakk>Cmin\n                 \\<in> {C. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getC statea = C};\n         \\<forall>C'.\n            (C', Cmin) \\<in> multLess (getM state) \\<longrightarrow>\n            C' \\<notin> {C. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getC statea = C}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Cmin.\n                \\<lbrakk>Cmin\n                         \\<in> {C. \\<exists>statea.\nstatea \\<in> Q \\<and> getM statea = getM state \\<and> getC statea = C};\n                 \\<forall>C'.\n                    (C', Cmin) \\<in> multLess (getM state) \\<longrightarrow>\n                    C' \\<notin> {C. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and> getC statea = C}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getC state\n     \\<in> {C. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getC statea = C};\n     \\<forall>x.\n        x \\<in> {C. \\<exists>statea.\n                       statea \\<in> Q \\<and>\n                       getM statea = getM state \\<and>\n                       getC statea = C} \\<longrightarrow>\n        (\\<exists>z\\<in>{C. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getC statea = C}.\n            \\<forall>y.\n               (y, z) \\<in> multLess (getM state) \\<longrightarrow>\n               y \\<notin> {C. \\<exists>statea.\n                                 statea \\<in> Q \\<and>\n                                 getM statea = getM state \\<and>\n                                 getC statea = C})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getC state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Cmin.\n                \\<lbrakk>Cmin\n                         \\<in> {C. \\<exists>statea.\nstatea \\<in> Q \\<and> getM statea = getM state \\<and> getC statea = C};\n                 \\<forall>C'.\n                    (C', Cmin) \\<in> multLess (getM state) \\<longrightarrow>\n                    C' \\<notin> {C. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and> getC statea = C}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getC state\n     \\<in> {C. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getC statea = C};\n     getC state\n     \\<in> {C. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getC statea = C} \\<longrightarrow>\n     (\\<exists>z\\<in>{C. \\<exists>statea.\n                            statea \\<in> Q \\<and>\n                            getM statea = getM state \\<and>\n                            getC statea = C}.\n         \\<forall>y.\n            (y, z) \\<in> multLess (getM state) \\<longrightarrow>\n            y \\<notin> {C. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getC statea = C})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Cmin\n  \\<in> {C. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getC statea = C}\n  \\<forall>C'.\n     (C', Cmin) \\<in> multLess (getM state) \\<longrightarrow>\n     C' \\<notin> {C. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and> getC statea = C}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>Cmin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  Cmin\n  \\<in> {C. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getC statea = C}", "obtain stateMin\n        where \"stateMin \\<in> Q\" \"(getM stateMin) = ?M\" \"getC stateMin = Cmin\""], ["proof (prove)\nusing this:\n  Cmin\n  \\<in> {C. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and> getC statea = C}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = getM state;\n         getC stateMin = Cmin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = getM state\n  getC stateMin = Cmin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> multLessState \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin) \\<in> multLessState \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> multLessState \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> multLessState \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> multLessState \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> multLessState \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> multLessState \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> multLessState\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> multLessState \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = ?M\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = getM state\n  (state', stateMin) \\<in> multLessState", "have \"getM state' = getM stateMin\" \"(getC state', getC stateMin) \\<in> multLess ?M\""], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  (state', stateMin) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. getM state' = getM stateMin &&&\n    (getC state', getC stateMin) \\<in> multLess (getM state)", "unfolding multLessState_def"], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  (state', stateMin)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         getConflictFlag stateA = getConflictFlag stateB \\<and>\n         (getC stateA, getC stateB) \\<in> multLess (getM stateA)}\n\ngoal (1 subgoal):\n 1. getM state' = getM stateMin &&&\n    (getC state', getC stateMin) \\<in> multLess (getM state)", "by auto"], ["proof (state)\nthis:\n  getM state' = getM stateMin\n  (getC state', getC stateMin) \\<in> multLess (getM state)\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> multLessState \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>C'. (C', Cmin) \\<in> multLess ?M \\<longrightarrow> C' \\<notin> ?Q1\\<close>\n            \\<open>(getC state', getC stateMin) \\<in> multLess ?M\\<close> \\<open>getC stateMin = Cmin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>C'.\n     (C', Cmin) \\<in> multLess (getM state) \\<longrightarrow>\n     C' \\<notin> {C. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and> getC statea = C}\n  (getC state', getC stateMin) \\<in> multLess (getM state)\n  getC stateMin = Cmin", "have \"getC state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>C'.\n     (C', Cmin) \\<in> multLess (getM state) \\<longrightarrow>\n     C' \\<notin> {C. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and> getC statea = C}\n  (getC state', getC stateMin) \\<in> multLess (getM state)\n  getC stateMin = Cmin\n\ngoal (1 subgoal):\n 1. getC state'\n    \\<notin> {C. \\<exists>statea.\n                    statea \\<in> Q \\<and>\n                    getM statea = getM state \\<and> getC statea = C}", "by simp"], ["proof (state)\nthis:\n  getC state'\n  \\<notin> {C. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getC statea = C}\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> multLessState \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM state' = getM stateMin\\<close> \\<open>getM stateMin = ?M\\<close>"], ["proof (chain)\npicking this:\n  getM state' = getM stateMin\n  getM stateMin = getM state\n  getC state'\n  \\<notin> {C. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getC statea = C}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM state' = getM stateMin\n  getM stateMin = getM state\n  getC state'\n  \\<notin> {C. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and> getC statea = C}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin) \\<in> multLessState \\<longrightarrow> state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin) \\<in> multLessState \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> multLessState \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> multLessState \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> multLessState \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin) \\<in> multLessState \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin) \\<in> multLessState \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> multLessState \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> multLessState \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> multLessState \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> multLessState \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> multLessState \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfLearnLessState:\n  shows \"wf learnLessState\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf learnLessState", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> learnLessState \\<longrightarrow> y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> learnLessState \\<longrightarrow> y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists> stateMin \\<in> Q. \\<forall>state'. (state', stateMin) \\<in> learnLessState \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?M = \"(getM state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?C = \"(getC state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?conflictFlag = \"(getConflictFlag state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{F::Formula. \\<exists> state. state \\<in> Q \\<and> \n        (getM state) = ?M \\<and>  (getConflictFlag state) = ?conflictFlag \\<and> (getC state) = ?C \\<and> (getF state) = F}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getF state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getF state\n    \\<in> {F. \\<exists>statea.\n                 statea \\<in> Q \\<and>\n                 getM statea = getM state \\<and>\n                 getConflictFlag statea = getConflictFlag state \\<and>\n                 getC statea = getC state \\<and> getF statea = F}", "by auto"], ["proof (state)\nthis:\n  getF state\n  \\<in> {F. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and>\n               getConflictFlag statea = getConflictFlag state \\<and>\n               getC statea = getC state \\<and> getF statea = F}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "with wfLearnLess[of \"?C\"]"], ["proof (chain)\npicking this:\n  wf (learnLess (getC state))\n  getF state\n  \\<in> {F. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and>\n               getConflictFlag statea = getConflictFlag state \\<and>\n               getC statea = getC state \\<and> getF statea = F}", "obtain Fmin where \"Fmin \\<in> ?Q1\" \"\\<forall>F'. (F', Fmin) \\<in> learnLess ?C \\<longrightarrow> F' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  wf (learnLess (getC state))\n  getF state\n  \\<in> {F. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and>\n               getConflictFlag statea = getConflictFlag state \\<and>\n               getC statea = getC state \\<and> getF statea = F}\n\ngoal (1 subgoal):\n 1. (\\<And>Fmin.\n        \\<lbrakk>Fmin\n                 \\<in> {F. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getConflictFlag statea =\n                              getConflictFlag state \\<and>\n                              getC statea = getC state \\<and>\n                              getF statea = F};\n         \\<forall>F'.\n            (F', Fmin) \\<in> learnLess (getC state) \\<longrightarrow>\n            F' \\<notin> {F. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getConflictFlag statea =\n                               getConflictFlag state \\<and>\n                               getC statea = getC state \\<and>\n                               getF statea = F}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> learnLess (getC state) \\<longrightarrow>\n            y \\<notin> Q)\n  getF state\n  \\<in> {F. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and>\n               getConflictFlag statea = getConflictFlag state \\<and>\n               getC statea = getC state \\<and> getF statea = F}\n\ngoal (1 subgoal):\n 1. (\\<And>Fmin.\n        \\<lbrakk>Fmin\n                 \\<in> {F. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getConflictFlag statea =\n                              getConflictFlag state \\<and>\n                              getC statea = getC state \\<and>\n                              getF statea = F};\n         \\<forall>F'.\n            (F', Fmin) \\<in> learnLess (getC state) \\<longrightarrow>\n            F' \\<notin> {F. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getConflictFlag statea =\n                               getConflictFlag state \\<and>\n                               getC statea = getC state \\<and>\n                               getF statea = F}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Fmin.\n                \\<lbrakk>Fmin\n                         \\<in> {F. \\<exists>statea.\nstatea \\<in> Q \\<and>\ngetM statea = getM state \\<and>\ngetConflictFlag statea = getConflictFlag state \\<and>\ngetC statea = getC state \\<and> getF statea = F};\n                 \\<forall>F'.\n                    (F', Fmin)\n                    \\<in> learnLess (getC state) \\<longrightarrow>\n                    F' \\<notin> {F. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and>\n getConflictFlag statea = getConflictFlag state \\<and>\n getC statea = getC state \\<and> getF statea = F}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getF state\n     \\<in> {F. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = getConflictFlag state \\<and>\n                  getC statea = getC state \\<and> getF statea = F};\n     \\<forall>x.\n        x \\<in> {F. \\<exists>statea.\n                       statea \\<in> Q \\<and>\n                       getM statea = getM state \\<and>\n                       getConflictFlag statea = getConflictFlag state \\<and>\n                       getC statea = getC state \\<and>\n                       getF statea = F} \\<longrightarrow>\n        (\\<exists>z\\<in>{F. \\<exists>statea.\n                               statea \\<in> Q \\<and>\n                               getM statea = getM state \\<and>\n                               getConflictFlag statea =\n                               getConflictFlag state \\<and>\n                               getC statea = getC state \\<and>\n                               getF statea = F}.\n            \\<forall>y.\n               (y, z) \\<in> learnLess (getC state) \\<longrightarrow>\n               y \\<notin> {F. \\<exists>statea.\n                                 statea \\<in> Q \\<and>\n                                 getM statea = getM state \\<and>\n                                 getConflictFlag statea =\n                                 getConflictFlag state \\<and>\n                                 getC statea = getC state \\<and>\n                                 getF statea = F})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getF state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Fmin.\n                \\<lbrakk>Fmin\n                         \\<in> {F. \\<exists>statea.\nstatea \\<in> Q \\<and>\ngetM statea = getM state \\<and>\ngetConflictFlag statea = getConflictFlag state \\<and>\ngetC statea = getC state \\<and> getF statea = F};\n                 \\<forall>F'.\n                    (F', Fmin)\n                    \\<in> learnLess (getC state) \\<longrightarrow>\n                    F' \\<notin> {F. \\<exists>statea.\n statea \\<in> Q \\<and>\n getM statea = getM state \\<and>\n getConflictFlag statea = getConflictFlag state \\<and>\n getC statea = getC state \\<and> getF statea = F}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getF state\n     \\<in> {F. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = getConflictFlag state \\<and>\n                  getC statea = getC state \\<and> getF statea = F};\n     getF state\n     \\<in> {F. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = getConflictFlag state \\<and>\n                  getC statea = getC state \\<and>\n                  getF statea = F} \\<longrightarrow>\n     (\\<exists>z\\<in>{F. \\<exists>statea.\n                            statea \\<in> Q \\<and>\n                            getM statea = getM state \\<and>\n                            getConflictFlag statea =\n                            getConflictFlag state \\<and>\n                            getC statea = getC state \\<and>\n                            getF statea = F}.\n         \\<forall>y.\n            (y, z) \\<in> learnLess (getC state) \\<longrightarrow>\n            y \\<notin> {F. \\<exists>statea.\n                              statea \\<in> Q \\<and>\n                              getM statea = getM state \\<and>\n                              getConflictFlag statea =\n                              getConflictFlag state \\<and>\n                              getC statea = getC state \\<and>\n                              getF statea = F})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Fmin\n  \\<in> {F. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and>\n               getConflictFlag statea = getConflictFlag state \\<and>\n               getC statea = getC state \\<and> getF statea = F}\n  \\<forall>F'.\n     (F', Fmin) \\<in> learnLess (getC state) \\<longrightarrow>\n     F' \\<notin> {F. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and>\n                        getConflictFlag statea =\n                        getConflictFlag state \\<and>\n                        getC statea = getC state \\<and> getF statea = F}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>Fmin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  Fmin\n  \\<in> {F. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and>\n               getConflictFlag statea = getConflictFlag state \\<and>\n               getC statea = getC state \\<and> getF statea = F}", "obtain stateMin\n        where \"stateMin \\<in> Q\" \"(getM stateMin) = ?M\" \"getC stateMin = ?C\" \"getConflictFlag stateMin = ?conflictFlag\" \"getF stateMin = Fmin\""], ["proof (prove)\nusing this:\n  Fmin\n  \\<in> {F. \\<exists>statea.\n               statea \\<in> Q \\<and>\n               getM statea = getM state \\<and>\n               getConflictFlag statea = getConflictFlag state \\<and>\n               getC statea = getC state \\<and> getF statea = F}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = getM state;\n         getC stateMin = getC state;\n         getConflictFlag stateMin = getConflictFlag state;\n         getF stateMin = Fmin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = getM state\n  getC stateMin = getC state\n  getConflictFlag stateMin = getConflictFlag state\n  getF stateMin = Fmin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> learnLessState \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> learnLessState \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> learnLessState\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = ?M\\<close> \\<open>getC stateMin = ?C\\<close> \\<open>getConflictFlag stateMin = ?conflictFlag\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = getM state\n  getC stateMin = getC state\n  getConflictFlag stateMin = getConflictFlag state\n  (state', stateMin) \\<in> learnLessState", "have \"getM state' = getM stateMin\" \"getC state' = getC stateMin\" \n            \"getConflictFlag state' = getConflictFlag stateMin\" \"(getF state', getF stateMin) \\<in> learnLess ?C\""], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  getC stateMin = getC state\n  getConflictFlag stateMin = getConflictFlag state\n  (state', stateMin) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (getM state' = getM stateMin &&& getC state' = getC stateMin) &&&\n    getConflictFlag state' = getConflictFlag stateMin &&&\n    (getF state', getF stateMin) \\<in> learnLess (getC state)", "unfolding learnLessState_def"], ["proof (prove)\nusing this:\n  getM stateMin = getM state\n  getC stateMin = getC state\n  getConflictFlag stateMin = getConflictFlag state\n  (state', stateMin)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         getConflictFlag stateA = getConflictFlag stateB \\<and>\n         getC stateA = getC stateB \\<and>\n         (getF stateA, getF stateB) \\<in> learnLess (getC stateA)}\n\ngoal (1 subgoal):\n 1. (getM state' = getM stateMin &&& getC state' = getC stateMin) &&&\n    getConflictFlag state' = getConflictFlag stateMin &&&\n    (getF state', getF stateMin) \\<in> learnLess (getC state)", "by auto"], ["proof (state)\nthis:\n  getM state' = getM stateMin\n  getC state' = getC stateMin\n  getConflictFlag state' = getConflictFlag stateMin\n  (getF state', getF stateMin) \\<in> learnLess (getC state)\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>F'. (F', Fmin) \\<in> learnLess ?C \\<longrightarrow> F' \\<notin> ?Q1\\<close>\n            \\<open>(getF state', getF stateMin) \\<in> learnLess ?C\\<close> \\<open>getF stateMin = Fmin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>F'.\n     (F', Fmin) \\<in> learnLess (getC state) \\<longrightarrow>\n     F' \\<notin> {F. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and>\n                        getConflictFlag statea =\n                        getConflictFlag state \\<and>\n                        getC statea = getC state \\<and> getF statea = F}\n  (getF state', getF stateMin) \\<in> learnLess (getC state)\n  getF stateMin = Fmin", "have \"getF state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>F'.\n     (F', Fmin) \\<in> learnLess (getC state) \\<longrightarrow>\n     F' \\<notin> {F. \\<exists>statea.\n                        statea \\<in> Q \\<and>\n                        getM statea = getM state \\<and>\n                        getConflictFlag statea =\n                        getConflictFlag state \\<and>\n                        getC statea = getC state \\<and> getF statea = F}\n  (getF state', getF stateMin) \\<in> learnLess (getC state)\n  getF stateMin = Fmin\n\ngoal (1 subgoal):\n 1. getF state'\n    \\<notin> {F. \\<exists>statea.\n                    statea \\<in> Q \\<and>\n                    getM statea = getM state \\<and>\n                    getConflictFlag statea = getConflictFlag state \\<and>\n                    getC statea = getC state \\<and> getF statea = F}", "by simp"], ["proof (state)\nthis:\n  getF state'\n  \\<notin> {F. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = getConflictFlag state \\<and>\n                  getC statea = getC state \\<and> getF statea = F}\n\ngoal (1 subgoal):\n 1. (state', stateMin) \\<in> learnLessState \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM state' = getM stateMin\\<close> \\<open>getC state' = getC stateMin\\<close> \\<open>getConflictFlag state' = getConflictFlag stateMin\\<close>\n            \\<open>getM stateMin = ?M\\<close> \\<open>getC stateMin = ?C\\<close> \\<open>getConflictFlag stateMin = ?conflictFlag\\<close> \\<open>getF stateMin = Fmin\\<close>"], ["proof (chain)\npicking this:\n  getM state' = getM stateMin\n  getC state' = getC stateMin\n  getConflictFlag state' = getConflictFlag stateMin\n  getM stateMin = getM state\n  getC stateMin = getC state\n  getConflictFlag stateMin = getConflictFlag state\n  getF stateMin = Fmin\n  getF state'\n  \\<notin> {F. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = getConflictFlag state \\<and>\n                  getC statea = getC state \\<and> getF statea = F}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM state' = getM stateMin\n  getC state' = getC stateMin\n  getConflictFlag state' = getConflictFlag stateMin\n  getM stateMin = getM state\n  getC stateMin = getC state\n  getConflictFlag stateMin = getConflictFlag state\n  getF stateMin = Fmin\n  getF state'\n  \\<notin> {F. \\<exists>statea.\n                  statea \\<in> Q \\<and>\n                  getM statea = getM state \\<and>\n                  getConflictFlag statea = getConflictFlag state \\<and>\n                  getC statea = getC state \\<and> getF statea = F}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> learnLessState \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin) \\<in> learnLessState \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we can prove the following key lemma which shows that the\ntermination ordering is well founded.\\<close>"], ["", "lemma wfTerminationLess:\n  fixes decisionVars::\"Variable set\" and F0::\"Formula\"\n  assumes \"finite decisionVars\"\n  shows \"wf (terminationLess F0 decisionVars)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars)", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              y \\<notin> Q)", "show \"\\<forall>Q state. state \\<in> Q \\<longrightarrow> (\\<exists> stateMin \\<in> Q. \\<forall>state'. (state', stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q::\"State set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "fix state::State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>finite decisionVars\\<close>"], ["proof (chain)\npicking this:\n  finite decisionVars", "have \"wf (lexLessState F0 decisionVars)\""], ["proof (prove)\nusing this:\n  finite decisionVars\n\ngoal (1 subgoal):\n 1. wf (lexLessState F0 decisionVars)", "using wfLexLessState[of \"decisionVars\" \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars\n  finite decisionVars \\<Longrightarrow> wf (lexLessState F0 decisionVars)\n\ngoal (1 subgoal):\n 1. wf (lexLessState F0 decisionVars)", "by simp"], ["proof (state)\nthis:\n  wf (lexLessState F0 decisionVars)\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q\n  wf (lexLessState F0 decisionVars)", "obtain state0\n        where \"state0 \\<in> Q\" \"\\<forall>state'. (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n  wf (lexLessState F0 decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state0.\n        \\<lbrakk>state0 \\<in> Q;\n         \\<forall>state'.\n            (state', state0)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  state \\<in> Q\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>state0.\n        \\<lbrakk>state0 \\<in> Q;\n         \\<forall>state'.\n            (state', state0)\n            \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  state0 \\<in> Q\n  \\<forall>state'.\n     (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q0 = \"{state. state \\<in> Q \\<and> (getM state) = (getM state0)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state0 \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state0 \\<in> Q", "have \"state0 \\<in> ?Q0\""], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0 \\<in> {state \\<in> Q. getM state = getM state0}", "by simp"], ["proof (state)\nthis:\n  state0 \\<in> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "have \"wf boolLessState\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf boolLessState", "using wfBoolLessState"], ["proof (prove)\nusing this:\n  wf boolLessState\n\ngoal (1 subgoal):\n 1. wf boolLessState", "."], ["proof (state)\nthis:\n  wf boolLessState\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>state0 \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state0 \\<in> Q\n  wf boolLessState", "obtain state1\n        where \"state1 \\<in> ?Q0\" \"\\<forall>state'. (state', state1) \\<in> boolLessState \\<longrightarrow> state' \\<notin> ?Q0\""], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n  wf boolLessState\n\ngoal (1 subgoal):\n 1. (\\<And>state1.\n        \\<lbrakk>state1 \\<in> {state \\<in> Q. getM state = getM state0};\n         \\<forall>state'.\n            (state', state1) \\<in> boolLessState \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q. getM state = getM state0}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> boolLessState \\<longrightarrow> y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>state1.\n        \\<lbrakk>state1 \\<in> {state \\<in> Q. getM state = getM state0};\n         \\<forall>state'.\n            (state', state1) \\<in> boolLessState \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q. getM state = getM state0}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q0\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state1.\n                \\<lbrakk>state1\n                         \\<in> {state \\<in> Q. getM state = getM state0};\n                 \\<forall>state'.\n                    (state', state1) \\<in> boolLessState \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state0 \\<in> Q;\n     \\<forall>x.\n        x \\<in> {state \\<in> Q. getM state = getM state0} \\<longrightarrow>\n        (\\<exists>z\\<in>{state \\<in> Q. getM state = getM state0}.\n            \\<forall>y.\n               (y, z) \\<in> boolLessState \\<longrightarrow>\n               y \\<notin> {state \\<in> Q.\n                           getM state = getM state0})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"state0\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state1.\n                \\<lbrakk>state1\n                         \\<in> {state \\<in> Q. getM state = getM state0};\n                 \\<forall>state'.\n                    (state', state1) \\<in> boolLessState \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state0 \\<in> Q;\n     state0\n     \\<in> {state \\<in> Q. getM state = getM state0} \\<longrightarrow>\n     (\\<exists>z\\<in>{state \\<in> Q. getM state = getM state0}.\n         \\<forall>y.\n            (y, z) \\<in> boolLessState \\<longrightarrow>\n            y \\<notin> {state \\<in> Q. getM state = getM state0})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}\n  \\<forall>state'.\n     (state', state1) \\<in> boolLessState \\<longrightarrow>\n     state' \\<notin> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{state. state \\<in> Q \\<and> getM state = getM state0 \\<and> getConflictFlag state = getConflictFlag state1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state1 \\<in> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}", "have \"state1 \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. state1\n    \\<in> {state \\<in> Q.\n           getM state = getM state0 \\<and>\n           getConflictFlag state = getConflictFlag state1}", "by simp"], ["proof (state)\nthis:\n  state1\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "have \"wf multLessState\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf multLessState", "using wfMultLessState"], ["proof (prove)\nusing this:\n  wf multLessState\n\ngoal (1 subgoal):\n 1. wf multLessState", "."], ["proof (state)\nthis:\n  wf multLessState\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>state1 \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  state1\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}\n  wf multLessState", "obtain state2\n        where \"state2 \\<in> ?Q1\" \"\\<forall>state'. (state', state2) \\<in> multLessState \\<longrightarrow> state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  state1\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}\n  wf multLessState\n\ngoal (1 subgoal):\n 1. (\\<And>state2.\n        \\<lbrakk>state2\n                 \\<in> {state \\<in> Q.\n                        getM state = getM state0 \\<and>\n                        getConflictFlag state = getConflictFlag state1};\n         \\<forall>state'.\n            (state', state2) \\<in> multLessState \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q.\n                      getM state = getM state0 \\<and>\n                      getConflictFlag state =\n                      getConflictFlag state1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  state1\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> multLessState \\<longrightarrow> y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>state2.\n        \\<lbrakk>state2\n                 \\<in> {state \\<in> Q.\n                        getM state = getM state0 \\<and>\n                        getConflictFlag state = getConflictFlag state1};\n         \\<forall>state'.\n            (state', state2) \\<in> multLessState \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q.\n                      getM state = getM state0 \\<and>\n                      getConflictFlag state =\n                      getConflictFlag state1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state2.\n                \\<lbrakk>state2\n                         \\<in> {state \\<in> Q.\n                                getM state = getM state0 \\<and>\n                                getConflictFlag state =\n                                getConflictFlag state1};\n                 \\<forall>state'.\n                    (state', state2) \\<in> multLessState \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0 \\<and>\n                              getConflictFlag state =\n                              getConflictFlag state1}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state1\n     \\<in> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1};\n     \\<forall>x.\n        x \\<in> {state \\<in> Q.\n                 getM state = getM state0 \\<and>\n                 getConflictFlag state =\n                 getConflictFlag state1} \\<longrightarrow>\n        (\\<exists>z\\<in>{state \\<in> Q.\n                         getM state = getM state0 \\<and>\n                         getConflictFlag state = getConflictFlag state1}.\n            \\<forall>y.\n               (y, z) \\<in> multLessState \\<longrightarrow>\n               y \\<notin> {state \\<in> Q.\n                           getM state = getM state0 \\<and>\n                           getConflictFlag state =\n                           getConflictFlag state1})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"state1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state2.\n                \\<lbrakk>state2\n                         \\<in> {state \\<in> Q.\n                                getM state = getM state0 \\<and>\n                                getConflictFlag state =\n                                getConflictFlag state1};\n                 \\<forall>state'.\n                    (state', state2) \\<in> multLessState \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0 \\<and>\n                              getConflictFlag state =\n                              getConflictFlag state1}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state1\n     \\<in> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1};\n     state1\n     \\<in> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state =\n            getConflictFlag state1} \\<longrightarrow>\n     (\\<exists>z\\<in>{state \\<in> Q.\n                      getM state = getM state0 \\<and>\n                      getConflictFlag state = getConflictFlag state1}.\n         \\<forall>y.\n            (y, z) \\<in> multLessState \\<longrightarrow>\n            y \\<notin> {state \\<in> Q.\n                        getM state = getM state0 \\<and>\n                        getConflictFlag state =\n                        getConflictFlag state1})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}\n  \\<forall>state'.\n     (state', state2) \\<in> multLessState \\<longrightarrow>\n     state'\n     \\<notin> {state \\<in> Q.\n               getM state = getM state0 \\<and>\n               getConflictFlag state = getConflictFlag state1}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q2 = \"{state. state \\<in> Q \\<and> getM state = getM state0 \\<and> \n        getConflictFlag state = getConflictFlag state1 \\<and>  getC state = getC state2}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state2 \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}", "have \"state2 \\<in> ?Q2\""], ["proof (prove)\nusing this:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}\n\ngoal (1 subgoal):\n 1. state2\n    \\<in> {state \\<in> Q.\n           getM state = getM state0 \\<and>\n           getConflictFlag state = getConflictFlag state1 \\<and>\n           getC state = getC state2}", "by simp"], ["proof (state)\nthis:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "have \"wf learnLessState\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf learnLessState", "using wfLearnLessState"], ["proof (prove)\nusing this:\n  wf learnLessState\n\ngoal (1 subgoal):\n 1. wf learnLessState", "."], ["proof (state)\nthis:\n  wf learnLessState\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>state2 \\<in> ?Q2\\<close>"], ["proof (chain)\npicking this:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  wf learnLessState", "obtain state3\n        where \"state3 \\<in> ?Q2\" \"\\<forall>state'. (state', state3) \\<in> learnLessState \\<longrightarrow> state' \\<notin> ?Q2\""], ["proof (prove)\nusing this:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  wf learnLessState\n\ngoal (1 subgoal):\n 1. (\\<And>state3.\n        \\<lbrakk>state3\n                 \\<in> {state \\<in> Q.\n                        getM state = getM state0 \\<and>\n                        getConflictFlag state =\n                        getConflictFlag state1 \\<and>\n                        getC state = getC state2};\n         \\<forall>state'.\n            (state', state3) \\<in> learnLessState \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q.\n                      getM state = getM state0 \\<and>\n                      getConflictFlag state = getConflictFlag state1 \\<and>\n                      getC state = getC state2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z) \\<in> learnLessState \\<longrightarrow> y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>state3.\n        \\<lbrakk>state3\n                 \\<in> {state \\<in> Q.\n                        getM state = getM state0 \\<and>\n                        getConflictFlag state =\n                        getConflictFlag state1 \\<and>\n                        getC state = getC state2};\n         \\<forall>state'.\n            (state', state3) \\<in> learnLessState \\<longrightarrow>\n            state'\n            \\<notin> {state \\<in> Q.\n                      getM state = getM state0 \\<and>\n                      getConflictFlag state = getConflictFlag state1 \\<and>\n                      getC state = getC state2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q2\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state3.\n                \\<lbrakk>state3\n                         \\<in> {state \\<in> Q.\n                                getM state = getM state0 \\<and>\n                                getConflictFlag state =\n                                getConflictFlag state1 \\<and>\n                                getC state = getC state2};\n                 \\<forall>state'.\n                    (state', state3) \\<in> learnLessState \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0 \\<and>\n                              getConflictFlag state =\n                              getConflictFlag state1 \\<and>\n                              getC state = getC state2}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state2\n     \\<in> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1 \\<and>\n            getC state = getC state2};\n     \\<forall>x.\n        x \\<in> {state \\<in> Q.\n                 getM state = getM state0 \\<and>\n                 getConflictFlag state = getConflictFlag state1 \\<and>\n                 getC state = getC state2} \\<longrightarrow>\n        (\\<exists>z\\<in>{state \\<in> Q.\n                         getM state = getM state0 \\<and>\n                         getConflictFlag state =\n                         getConflictFlag state1 \\<and>\n                         getC state = getC state2}.\n            \\<forall>y.\n               (y, z) \\<in> learnLessState \\<longrightarrow>\n               y \\<notin> {state \\<in> Q.\n                           getM state = getM state0 \\<and>\n                           getConflictFlag state =\n                           getConflictFlag state1 \\<and>\n                           getC state = getC state2})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"state2\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>state3.\n                \\<lbrakk>state3\n                         \\<in> {state \\<in> Q.\n                                getM state = getM state0 \\<and>\n                                getConflictFlag state =\n                                getConflictFlag state1 \\<and>\n                                getC state = getC state2};\n                 \\<forall>state'.\n                    (state', state3) \\<in> learnLessState \\<longrightarrow>\n                    state'\n                    \\<notin> {state \\<in> Q.\n                              getM state = getM state0 \\<and>\n                              getConflictFlag state =\n                              getConflictFlag state1 \\<and>\n                              getC state = getC state2}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state2\n     \\<in> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1 \\<and>\n            getC state = getC state2};\n     state2\n     \\<in> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1 \\<and>\n            getC state = getC state2} \\<longrightarrow>\n     (\\<exists>z\\<in>{state \\<in> Q.\n                      getM state = getM state0 \\<and>\n                      getConflictFlag state = getConflictFlag state1 \\<and>\n                      getC state = getC state2}.\n         \\<forall>y.\n            (y, z) \\<in> learnLessState \\<longrightarrow>\n            y \\<notin> {state \\<in> Q.\n                        getM state = getM state0 \\<and>\n                        getConflictFlag state =\n                        getConflictFlag state1 \\<and>\n                        getC state = getC state2})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  \\<forall>state'.\n     (state', state3) \\<in> learnLessState \\<longrightarrow>\n     state'\n     \\<notin> {state \\<in> Q.\n               getM state = getM state0 \\<and>\n               getConflictFlag state = getConflictFlag state1 \\<and>\n               getC state = getC state2}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state3 \\<in> ?Q2\\<close>"], ["proof (chain)\npicking this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}", "have \"state3 \\<in> Q\""], ["proof (prove)\nusing this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n\ngoal (1 subgoal):\n 1. state3 \\<in> Q", "by simp"], ["proof (state)\nthis:\n  state3 \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state1 \\<in> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}", "have \"getM state1 = getM state0\""], ["proof (prove)\nusing this:\n  state1 \\<in> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. getM state1 = getM state0", "by simp"], ["proof (state)\nthis:\n  getM state1 = getM state0\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state2 \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}", "have \"getM state2 = getM state0\" \"getConflictFlag state2 = getConflictFlag state1\""], ["proof (prove)\nusing this:\n  state2\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1}\n\ngoal (1 subgoal):\n 1. getM state2 = getM state0 &&&\n    getConflictFlag state2 = getConflictFlag state1", "by auto"], ["proof (state)\nthis:\n  getM state2 = getM state0\n  getConflictFlag state2 = getConflictFlag state1\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state3 \\<in> ?Q2\\<close>"], ["proof (chain)\npicking this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}", "have \"getM state3 = getM state0\" \"getConflictFlag state3 = getConflictFlag state1\" \"getC state3 = getC state2\""], ["proof (prove)\nusing this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n\ngoal (1 subgoal):\n 1. getM state3 = getM state0 &&&\n    getConflictFlag state3 = getConflictFlag state1 &&&\n    getC state3 = getC state2", "by auto"], ["proof (state)\nthis:\n  getM state3 = getM state0\n  getConflictFlag state3 = getConflictFlag state1\n  getC state3 = getC state2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "let ?stateMin = state3"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', ?stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', state3)\n       \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', state3)\n       \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', state3)\n       \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', ?stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> terminationLess F0 decisionVars\""], ["proof (state)\nthis:\n  (state', state3) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "hence \n            \"(state', ?stateMin) \\<in> lexLessState F0 decisionVars \\<or>\n            (state', ?stateMin) \\<in> boolLessState \\<or>\n            (state', ?stateMin) \\<in> multLessState \\<or>\n            (state', ?stateMin) \\<in> learnLessState\""], ["proof (prove)\nusing this:\n  (state', state3) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> lexLessState F0 decisionVars \\<or>\n    (state', state3) \\<in> boolLessState \\<or>\n    (state', state3) \\<in> multLessState \\<or>\n    (state', state3) \\<in> learnLessState", "unfolding terminationLess_def"], ["proof (prove)\nusing this:\n  (state', state3)\n  \\<in> {(stateA, stateB).\n         (stateA, stateB) \\<in> lexLessState F0 decisionVars \\<or>\n         (stateA, stateB) \\<in> boolLessState \\<or>\n         (stateA, stateB) \\<in> multLessState \\<or>\n         (stateA, stateB) \\<in> learnLessState}\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> lexLessState F0 decisionVars \\<or>\n    (state', state3) \\<in> boolLessState \\<or>\n    (state', state3) \\<in> multLessState \\<or>\n    (state', state3) \\<in> learnLessState", "by auto"], ["proof (state)\nthis:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state3) \\<in> boolLessState \\<or>\n  (state', state3) \\<in> multLessState \\<or>\n  (state', state3) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state3) \\<in> boolLessState \\<or>\n  (state', state3) \\<in> multLessState \\<or>\n  (state', state3) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "{"], ["proof (state)\nthis:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state3) \\<in> boolLessState \\<or>\n  (state', state3) \\<in> multLessState \\<or>\n  (state', state3) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> lexLessState F0 decisionVars\""], ["proof (state)\nthis:\n  (state', state3) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM state3 = getM state0\\<close>"], ["proof (chain)\npicking this:\n  getM state3 = getM state0\n  (state', state3) \\<in> lexLessState F0 decisionVars", "have \"(state', state0) \\<in> lexLessState F0 decisionVars\""], ["proof (prove)\nusing this:\n  getM state3 = getM state0\n  (state', state3) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state0) \\<in> lexLessState F0 decisionVars", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  getM state3 = getM state0\n  (state', state3)\n  \\<in> {(stateA, stateB).\n         (getM stateA, getM stateB)\n         \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}\n\ngoal (1 subgoal):\n 1. (state', state0)\n    \\<in> {(stateA, stateB).\n           (getM stateA, getM stateB)\n           \\<in> lexLessRestricted (vars F0 \\<union> decisionVars)}", "by simp"], ["proof (state)\nthis:\n  (state', state0) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>\\<forall>state'. (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow> state' \\<notin> Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state'.\n     (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n  (state', state0) \\<in> lexLessState F0 decisionVars", "have \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  \\<forall>state'.\n     (state', state0) \\<in> lexLessState F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n  (state', state0) \\<in> lexLessState F0 decisionVars\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "}"], ["proof (state)\nthis:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "{"], ["proof (state)\nthis:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> boolLessState\""], ["proof (state)\nthis:\n  (state', state3) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>?stateMin \\<in> ?Q2\\<close>\n              \\<open>getM state1 = getM state0\\<close>"], ["proof (chain)\npicking this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  getM state1 = getM state0", "have \"getConflictFlag state3 = getConflictFlag state1\" \"getM state3 = getM state1\""], ["proof (prove)\nusing this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  getM state1 = getM state0\n\ngoal (1 subgoal):\n 1. getConflictFlag state3 = getConflictFlag state1 &&&\n    getM state3 = getM state1", "by auto"], ["proof (state)\nthis:\n  getConflictFlag state3 = getConflictFlag state1\n  getM state3 = getM state1\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>(state', ?stateMin) \\<in> boolLessState\\<close>"], ["proof (chain)\npicking this:\n  (state', state3) \\<in> boolLessState\n  getConflictFlag state3 = getConflictFlag state1\n  getM state3 = getM state1", "have \"(state', state1) \\<in> boolLessState\""], ["proof (prove)\nusing this:\n  (state', state3) \\<in> boolLessState\n  getConflictFlag state3 = getConflictFlag state1\n  getM state3 = getM state1\n\ngoal (1 subgoal):\n 1. (state', state1) \\<in> boolLessState", "unfolding boolLessState_def"], ["proof (prove)\nusing this:\n  (state', state3)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         (getConflictFlag stateA, getConflictFlag stateB) \\<in> boolLess}\n  getConflictFlag state3 = getConflictFlag state1\n  getM state3 = getM state1\n\ngoal (1 subgoal):\n 1. (state', state1)\n    \\<in> {(stateA, stateB).\n           getM stateA = getM stateB \\<and>\n           (getConflictFlag stateA, getConflictFlag stateB) \\<in> boolLess}", "by simp"], ["proof (state)\nthis:\n  (state', state1) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>\\<forall>state'. (state', state1) \\<in> boolLessState \\<longrightarrow> state' \\<notin> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state'.\n     (state', state1) \\<in> boolLessState \\<longrightarrow>\n     state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  (state', state1) \\<in> boolLessState", "have \"state' \\<notin> ?Q0\""], ["proof (prove)\nusing this:\n  \\<forall>state'.\n     (state', state1) \\<in> boolLessState \\<longrightarrow>\n     state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  (state', state1) \\<in> boolLessState\n\ngoal (1 subgoal):\n 1. state' \\<notin> {state \\<in> Q. getM state = getM state0}", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> {state \\<in> Q. getM state = getM state0}\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>(state', state1) \\<in> boolLessState\\<close> \\<open>getM state1 = getM state0\\<close>"], ["proof (chain)\npicking this:\n  (state', state1) \\<in> boolLessState\n  getM state1 = getM state0", "have \"getM state' = getM state0\""], ["proof (prove)\nusing this:\n  (state', state1) \\<in> boolLessState\n  getM state1 = getM state0\n\ngoal (1 subgoal):\n 1. getM state' = getM state0", "unfolding boolLessState_def"], ["proof (prove)\nusing this:\n  (state', state1)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         (getConflictFlag stateA, getConflictFlag stateB) \\<in> boolLess}\n  getM state1 = getM state0\n\ngoal (1 subgoal):\n 1. getM state' = getM state0", "by auto"], ["proof (state)\nthis:\n  getM state' = getM state0\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>state' \\<notin> ?Q0\\<close>"], ["proof (chain)\npicking this:\n  state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  getM state' = getM state0", "have \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  state' \\<notin> {state \\<in> Q. getM state = getM state0}\n  getM state' = getM state0\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "}"], ["proof (state)\nthis:\n  (state', state3) \\<in> boolLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  (state', state3) \\<in> boolLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "{"], ["proof (state)\nthis:\n  (state', state3) \\<in> boolLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> multLessState\""], ["proof (state)\nthis:\n  (state', state3) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>?stateMin \\<in> ?Q2\\<close> \n              \\<open>getM state1 = getM state0\\<close> \\<open>getM state2 = getM state0\\<close>\n              \\<open>getConflictFlag state2 = getConflictFlag state1\\<close>"], ["proof (chain)\npicking this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  getM state1 = getM state0\n  getM state2 = getM state0\n  getConflictFlag state2 = getConflictFlag state1", "have \"getC state3 = getC state2\" \"getConflictFlag state3 = getConflictFlag state2\" \"getM state3 = getM state2\""], ["proof (prove)\nusing this:\n  state3\n  \\<in> {state \\<in> Q.\n         getM state = getM state0 \\<and>\n         getConflictFlag state = getConflictFlag state1 \\<and>\n         getC state = getC state2}\n  getM state1 = getM state0\n  getM state2 = getM state0\n  getConflictFlag state2 = getConflictFlag state1\n\ngoal (1 subgoal):\n 1. getC state3 = getC state2 &&&\n    getConflictFlag state3 = getConflictFlag state2 &&&\n    getM state3 = getM state2", "by auto"], ["proof (state)\nthis:\n  getC state3 = getC state2\n  getConflictFlag state3 = getConflictFlag state2\n  getM state3 = getM state2\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>(state', ?stateMin) \\<in> multLessState\\<close>"], ["proof (chain)\npicking this:\n  (state', state3) \\<in> multLessState\n  getC state3 = getC state2\n  getConflictFlag state3 = getConflictFlag state2\n  getM state3 = getM state2", "have \"(state', state2) \\<in> multLessState\""], ["proof (prove)\nusing this:\n  (state', state3) \\<in> multLessState\n  getC state3 = getC state2\n  getConflictFlag state3 = getConflictFlag state2\n  getM state3 = getM state2\n\ngoal (1 subgoal):\n 1. (state', state2) \\<in> multLessState", "unfolding multLessState_def"], ["proof (prove)\nusing this:\n  (state', state3)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         getConflictFlag stateA = getConflictFlag stateB \\<and>\n         (getC stateA, getC stateB) \\<in> multLess (getM stateA)}\n  getC state3 = getC state2\n  getConflictFlag state3 = getConflictFlag state2\n  getM state3 = getM state2\n\ngoal (1 subgoal):\n 1. (state', state2)\n    \\<in> {(stateA, stateB).\n           getM stateA = getM stateB \\<and>\n           getConflictFlag stateA = getConflictFlag stateB \\<and>\n           (getC stateA, getC stateB) \\<in> multLess (getM stateA)}", "by auto"], ["proof (state)\nthis:\n  (state', state2) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>\\<forall>state'. (state', state2) \\<in> multLessState \\<longrightarrow> state' \\<notin> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state'.\n     (state', state2) \\<in> multLessState \\<longrightarrow>\n     state'\n     \\<notin> {state \\<in> Q.\n               getM state = getM state0 \\<and>\n               getConflictFlag state = getConflictFlag state1}\n  (state', state2) \\<in> multLessState", "have \"state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>state'.\n     (state', state2) \\<in> multLessState \\<longrightarrow>\n     state'\n     \\<notin> {state \\<in> Q.\n               getM state = getM state0 \\<and>\n               getConflictFlag state = getConflictFlag state1}\n  (state', state2) \\<in> multLessState\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state \\<in> Q.\n              getM state = getM state0 \\<and>\n              getConflictFlag state = getConflictFlag state1}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1}\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>(state', state2) \\<in> multLessState\\<close> \\<open>getM state2 = getM state0\\<close> \\<open>getConflictFlag state2 = getConflictFlag state1\\<close>"], ["proof (chain)\npicking this:\n  (state', state2) \\<in> multLessState\n  getM state2 = getM state0\n  getConflictFlag state2 = getConflictFlag state1", "have \"getM state' = getM state0\" \"getConflictFlag state' = getConflictFlag state1\""], ["proof (prove)\nusing this:\n  (state', state2) \\<in> multLessState\n  getM state2 = getM state0\n  getConflictFlag state2 = getConflictFlag state1\n\ngoal (1 subgoal):\n 1. getM state' = getM state0 &&&\n    getConflictFlag state' = getConflictFlag state1", "unfolding multLessState_def"], ["proof (prove)\nusing this:\n  (state', state2)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         getConflictFlag stateA = getConflictFlag stateB \\<and>\n         (getC stateA, getC stateB) \\<in> multLess (getM stateA)}\n  getM state2 = getM state0\n  getConflictFlag state2 = getConflictFlag state1\n\ngoal (1 subgoal):\n 1. getM state' = getM state0 &&&\n    getConflictFlag state' = getConflictFlag state1", "by auto"], ["proof (state)\nthis:\n  getM state' = getM state0\n  getConflictFlag state' = getConflictFlag state1\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>state' \\<notin> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1}\n  getM state' = getM state0\n  getConflictFlag state' = getConflictFlag state1", "have \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1}\n  getM state' = getM state0\n  getConflictFlag state' = getConflictFlag state1\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "}"], ["proof (state)\nthis:\n  (state', state3) \\<in> multLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  (state', state3) \\<in> multLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "{"], ["proof (state)\nthis:\n  (state', state3) \\<in> multLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', ?stateMin) \\<in> learnLessState\""], ["proof (state)\nthis:\n  (state', state3) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>\\<forall>state'. (state', ?stateMin) \\<in> learnLessState \\<longrightarrow> state' \\<notin> ?Q2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state'.\n     (state', state3) \\<in> learnLessState \\<longrightarrow>\n     state'\n     \\<notin> {state \\<in> Q.\n               getM state = getM state0 \\<and>\n               getConflictFlag state = getConflictFlag state1 \\<and>\n               getC state = getC state2}\n  (state', state3) \\<in> learnLessState", "have \"state' \\<notin> ?Q2\""], ["proof (prove)\nusing this:\n  \\<forall>state'.\n     (state', state3) \\<in> learnLessState \\<longrightarrow>\n     state'\n     \\<notin> {state \\<in> Q.\n               getM state = getM state0 \\<and>\n               getConflictFlag state = getConflictFlag state1 \\<and>\n               getC state = getC state2}\n  (state', state3) \\<in> learnLessState\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state \\<in> Q.\n              getM state = getM state0 \\<and>\n              getConflictFlag state = getConflictFlag state1 \\<and>\n              getC state = getC state2}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1 \\<and>\n            getC state = getC state2}\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>(state', ?stateMin) \\<in> learnLessState\\<close>\n              \\<open>getM state3 = getM state0\\<close> \\<open>getConflictFlag state3 = getConflictFlag state1\\<close> \\<open>getC state3 = getC state2\\<close>"], ["proof (chain)\npicking this:\n  (state', state3) \\<in> learnLessState\n  getM state3 = getM state0\n  getConflictFlag state3 = getConflictFlag state1\n  getC state3 = getC state2", "have \"getM state' = getM state0\" \"getConflictFlag state' = getConflictFlag state1\" \"getC state' = getC state2\""], ["proof (prove)\nusing this:\n  (state', state3) \\<in> learnLessState\n  getM state3 = getM state0\n  getConflictFlag state3 = getConflictFlag state1\n  getC state3 = getC state2\n\ngoal (1 subgoal):\n 1. getM state' = getM state0 &&&\n    getConflictFlag state' = getConflictFlag state1 &&&\n    getC state' = getC state2", "unfolding learnLessState_def"], ["proof (prove)\nusing this:\n  (state', state3)\n  \\<in> {(stateA, stateB).\n         getM stateA = getM stateB \\<and>\n         getConflictFlag stateA = getConflictFlag stateB \\<and>\n         getC stateA = getC stateB \\<and>\n         (getF stateA, getF stateB) \\<in> learnLess (getC stateA)}\n  getM state3 = getM state0\n  getConflictFlag state3 = getConflictFlag state1\n  getC state3 = getC state2\n\ngoal (1 subgoal):\n 1. getM state' = getM state0 &&&\n    getConflictFlag state' = getConflictFlag state1 &&&\n    getC state' = getC state2", "by auto"], ["proof (state)\nthis:\n  getM state' = getM state0\n  getConflictFlag state' = getConflictFlag state1\n  getC state' = getC state2\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>state' \\<notin> ?Q2\\<close>"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1 \\<and>\n            getC state = getC state2}\n  getM state' = getM state0\n  getConflictFlag state' = getConflictFlag state1\n  getC state' = getC state2", "have \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state \\<in> Q.\n            getM state = getM state0 \\<and>\n            getConflictFlag state = getConflictFlag state1 \\<and>\n            getC state = getC state2}\n  getM state' = getM state0\n  getConflictFlag state' = getConflictFlag state1\n  getC state' = getC state2\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by simp"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "}"], ["proof (state)\nthis:\n  (state', state3) \\<in> learnLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. (state', state3) \\<in> terminationLess F0 decisionVars \\<Longrightarrow>\n    state' \\<notin> Q", "ultimately"], ["proof (chain)\npicking this:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state3) \\<in> boolLessState \\<or>\n  (state', state3) \\<in> multLessState \\<or>\n  (state', state3) \\<in> learnLessState\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n  (state', state3) \\<in> boolLessState \\<Longrightarrow> state' \\<notin> Q\n  (state', state3) \\<in> multLessState \\<Longrightarrow> state' \\<notin> Q\n  (state', state3) \\<in> learnLessState \\<Longrightarrow> state' \\<notin> Q", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<or>\n  (state', state3) \\<in> boolLessState \\<or>\n  (state', state3) \\<in> multLessState \\<or>\n  (state', state3) \\<in> learnLessState\n  (state', state3) \\<in> lexLessState F0 decisionVars \\<Longrightarrow>\n  state' \\<notin> Q\n  (state', state3) \\<in> boolLessState \\<Longrightarrow> state' \\<notin> Q\n  (state', state3) \\<in> multLessState \\<Longrightarrow> state' \\<notin> Q\n  (state', state3) \\<in> learnLessState \\<Longrightarrow> state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', state3) \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', state3)\n     \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>?stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state3 \\<in> Q\n  \\<forall>state'.\n     (state', state3)\n     \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q", "have \"(\\<exists> stateMin \\<in> Q. \\<forall>state'. (state', stateMin) \\<in> terminationLess F0 decisionVars \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  state3 \\<in> Q\n  \\<forall>state'.\n     (state', state3)\n     \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin)\n          \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?state2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n              state' \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> terminationLess F0 decisionVars \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Using the termination ordering we show that the transition\n relation is well founded on states reachable from initial state.\\<close>"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem wfTransitionRelation:\n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\"\n  shows \"wf {(stateB, stateA). \n             (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and> (transition stateA stateB F0 decisionVars)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "let ?rel = \"{(stateB, stateA). \n                  (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and> (transition stateA stateB F0 decisionVars)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "let ?rel'= \"terminationLess F0 decisionVars\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "have \"\\<forall>x y. (x, y) \\<in> ?rel \\<longrightarrow> (x, y) \\<in> ?rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "fix stateA::State and stateB::State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "assume \"(stateB, stateA) \\<in> ?rel\""], ["proof (state)\nthis:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "hence \"(stateB, stateA) \\<in> ?rel'\""], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "using \\<open>isInitialState state0 F0\\<close>"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState[of \"state0\" \"F0\" \"stateA\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n  isInitialState state0 F0\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, stateA) \\<in> transitionRelation F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateA F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "using stateIsDecreasedByValidTransitions[of \"stateA\" \"F0\" \"decisionVars\" \"stateB\"]"], ["proof (prove)\nusing this:\n  (stateB, stateA)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n  isInitialState state0 F0\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, stateA) \\<in> transitionRelation F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState stateA F0 decisionVars\n  \\<lbrakk>invariantsHoldInState stateA F0 decisionVars;\n   transition stateA stateB F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. (stateB, stateA) \\<in> terminationLess F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  (stateB, stateA) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "}"], ["proof (state)\nthis:\n  (?stateB2, ?stateA2)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars} \\<Longrightarrow>\n  (?stateB2, ?stateA2) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?stateB2, ?stateA2)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars} \\<Longrightarrow>\n  (?stateB2, ?stateA2) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> {(stateB, stateA).\n              (state0, stateA)\n              \\<in> transitionRelation F0 decisionVars \\<and>\n              transition stateA stateB F0 decisionVars} \\<longrightarrow>\n       (x, y) \\<in> terminationLess F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "have \"wf ?rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars)", "using \\<open>finite decisionVars\\<close>"], ["proof (prove)\nusing this:\n  finite decisionVars\n\ngoal (1 subgoal):\n 1. wf (terminationLess F0 decisionVars)", "by (rule wfTerminationLess)"], ["proof (state)\nthis:\n  wf (terminationLess F0 decisionVars)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n  wf (terminationLess F0 decisionVars)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n  wf (terminationLess F0 decisionVars)\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "using wellFoundedEmbed[of \"?rel\" \"?rel'\"]"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     (x, y) \\<in> terminationLess F0 decisionVars\n  wf (terminationLess F0 decisionVars)\n  \\<lbrakk>\\<forall>x y.\n              (x, y)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              (x, y) \\<in> terminationLess F0 decisionVars;\n   wf (terminationLess F0 decisionVars)\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (state0, stateA)\n                        \\<in> transitionRelation F0 decisionVars \\<and>\n                        transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We will now give two corollaries of the previous theorem. First\n  is a weak termination result that shows that there is a terminating\n  run from every intial state to the final one.\\<close>"], ["", "corollary \n  fixes decisionVars :: \"Variable set\" and F0 :: \"Formula\" and state0 :: \"State\"\n  assumes \"finite decisionVars\" and \"isInitialState state0 F0\"\n  shows \"\\<exists> state. (state0, state) \\<in> transitionRelation F0 decisionVars \\<and> isFinalState state F0 decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "let ?Q = \"{state. (state0, state) \\<in> transitionRelation F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "let ?rel = \"{(stateB, stateA). (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n                         transition stateA stateB F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "have \"state0 \\<in> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state0\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "hence \"\\<exists> state. state \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state0\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       state\n       \\<in> {state.\n              (state0, state) \\<in> transitionRelation F0 decisionVars}", "by auto"], ["proof (state)\nthis:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "from assms"], ["proof (chain)\npicking this:\n  finite decisionVars\n  isInitialState state0 F0", "have \"wf ?rel\""], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "using wfTransitionRelation[of \"decisionVars\" \"state0\" \"F0\"]"], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<lbrakk>finite decisionVars; isInitialState state0 F0\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (state0, stateA)\n                        \\<in> transitionRelation F0 decisionVars \\<and>\n                        transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "by auto"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "hence \"\\<forall> Q. (\\<exists> x. x \\<in> Q) \\<longrightarrow> (\\<exists> stateMin \\<in> Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state.\n              (state, stateMin)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              state \\<notin> Q)", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state.\n              (state, stateMin)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              state \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            state \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "hence \" (\\<exists> x. x \\<in> ?Q) \\<longrightarrow> (\\<exists> stateMin \\<in> ?Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q)\""], ["proof (prove)\nusing this:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            state \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        x \\<in> {state.\n                 (state0, state)\n                 \\<in> transitionRelation F0\n                        decisionVars}) \\<longrightarrow>\n    (\\<exists>stateMin\n              \\<in>{state.\n                    (state0, state)\n                    \\<in> transitionRelation F0 decisionVars}.\n        \\<forall>state.\n           (state, stateMin)\n           \\<in> {(stateB, stateA).\n                  (state0, stateA)\n                  \\<in> transitionRelation F0 decisionVars \\<and>\n                  transition stateA stateB F0\n                   decisionVars} \\<longrightarrow>\n           state\n           \\<notin> {state.\n                     (state0, state)\n                     \\<in> transitionRelation F0 decisionVars})", "by rule"], ["proof (state)\nthis:\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation F0 decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation F0 decisionVars \\<and>\n                transition stateA stateB F0 decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars})\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "with \\<open>\\<exists> state. state \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation F0 decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation F0 decisionVars \\<and>\n                transition stateA stateB F0 decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars})", "have \"\\<exists> stateMin \\<in> ?Q. \\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<exists>state.\n     state\n     \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (\\<exists>x.\n      x \\<in> {state.\n               (state0, state)\n               \\<in> transitionRelation F0 decisionVars}) \\<longrightarrow>\n  (\\<exists>stateMin\n            \\<in>{state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}.\n      \\<forall>state.\n         (state, stateMin)\n         \\<in> {(stateB, stateA).\n                (state0, stateA)\n                \\<in> transitionRelation F0 decisionVars \\<and>\n                transition stateA stateB F0 decisionVars} \\<longrightarrow>\n         state\n         \\<notin> {state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars})\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\n             \\<in>{state.\n                   (state0, state)\n                   \\<in> transitionRelation F0 decisionVars}.\n       \\<forall>state.\n          (state, stateMin)\n          \\<in> {(stateB, stateA).\n                 (state0, stateA)\n                 \\<in> transitionRelation F0 decisionVars \\<and>\n                 transition stateA stateB F0 decisionVars} \\<longrightarrow>\n          state\n          \\<notin> {state.\n                    (state0, state)\n                    \\<in> transitionRelation F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA)\n               \\<in> transitionRelation F0 decisionVars \\<and>\n               transition stateA stateB F0 decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA)\n               \\<in> transitionRelation F0 decisionVars \\<and>\n               transition stateA stateB F0 decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}", "obtain stateMin\n      where \"stateMin \\<in> ?Q\" and \"\\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<exists>stateMin\n           \\<in>{state.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}.\n     \\<forall>state.\n        (state, stateMin)\n        \\<in> {(stateB, stateA).\n               (state0, stateA)\n               \\<in> transitionRelation F0 decisionVars \\<and>\n               transition stateA stateB F0 decisionVars} \\<longrightarrow>\n        state\n        \\<notin> {state.\n                  (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin\n                 \\<in> {state.\n                        (state0, state)\n                        \\<in> transitionRelation F0 decisionVars};\n         \\<forall>state.\n            (state, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            state\n            \\<notin> {state.\n                      (state0, state)\n                      \\<in> transitionRelation F0 decisionVars}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state.\n               (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "from \\<open>stateMin \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "have \"(state0, stateMin) \\<in> transitionRelation F0 decisionVars\""], ["proof (prove)\nusing this:\n  stateMin\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "with \\<open>\\<not> ?thesis\\<close>"], ["proof (chain)\npicking this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "have \"\\<not> isFinalState stateMin F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<not> isFinalState stateMin F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  \\<not> isFinalState stateMin F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "then"], ["proof (chain)\npicking this:\n  \\<not> isFinalState stateMin F0 decisionVars", "obtain state'::State\n      where \"transition stateMin state' F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> isFinalState stateMin F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition stateMin state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isFinalState_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>state'. transition stateMin state' F0 decisionVars)\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        transition stateMin state' F0 decisionVars \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "have \"(state', stateMin) \\<in> ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n           transition stateA stateB F0 decisionVars}", "using \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close>\n            \\<open>transition stateMin state' F0 decisionVars\\<close>"], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n           transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "with \\<open>\\<forall> state. (state, stateMin) \\<in> ?rel \\<longrightarrow> state \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state.\n               (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}", "have \"state' \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>state.\n     (state, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     state\n     \\<notin> {state.\n               (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state.\n              (state0, state) \\<in> transitionRelation F0 decisionVars}", "by force"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "moreover"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "from \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close> \\<open>transition stateMin state' F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars", "have \"state' \\<in> ?Q\""], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "using rtrancl_into_rtrancl[of \"state0\" \"stateMin\" \"{(stateA, stateB). transition stateA stateB F0 decisionVars}\" \"state'\"]"], ["proof (prove)\nusing this:\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n  \\<lbrakk>(state0, stateMin)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   (stateMin, state')\n   \\<in> {(stateA, stateB).\n          transition stateA stateB F0 decisionVars}\\<rbrakk>\n  \\<Longrightarrow> (state0, state')\n                    \\<in> {(stateA, stateB).\n                           transition stateA stateB F0 decisionVars}\\<^sup>*\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "ultimately"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}", "have False"], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state. (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "}"], ["proof (state)\nthis:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>state.\n       (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n       isFinalState state F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  \\<exists>state.\n     (state0, state) \\<in> transitionRelation F0 decisionVars \\<and>\n     isFinalState state F0 decisionVars\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we prove the final strong termination result which states\nthat there cannot be infinite chains of transitions. If there is an\ninfinite transition chain that starts from an initial state, its\nelements would for a set that would contain initial state and for\nevery element of that set there would be another element of that set\nthat is directly reachable from it. We show that no such set exists.\\<close>"], ["", "corollary noInfiniteTransitionChains:\n  fixes F0::Formula and decisionVars::\"Variable set\"\n  assumes \"finite decisionVars\"\n  shows \"\\<not> (\\<exists> Q::(State set). \\<exists> state0 \\<in> Q. isInitialState state0 F0 \\<and> \n                              (\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' F0 decisionVars))\n            )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0 decisionVars))\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0 decisionVars))", "obtain Q::\"State set\" and state0::\"State\"\n    where \"isInitialState state0 F0\" \"state0 \\<in> Q\"\n          \"\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' F0 decisionVars)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0 decisionVars))\n\ngoal (1 subgoal):\n 1. (\\<And>state0 Q.\n        \\<lbrakk>isInitialState state0 F0; state0 \\<in> Q;\n         \\<forall>state\\<in>Q.\n            \\<exists>state'\\<in>Q.\n               transition state state' F0 decisionVars\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isInitialState state0 F0\n  state0 \\<in> Q\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "let ?rel = \"{(stateB, stateA). (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n                         transition stateA stateB F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>finite decisionVars\\<close> \\<open>isInitialState state0 F0\\<close>"], ["proof (chain)\npicking this:\n  finite decisionVars\n  isInitialState state0 F0", "have \"wf ?rel\""], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "using wfTransitionRelation"], ["proof (prove)\nusing this:\n  finite decisionVars\n  isInitialState state0 F0\n  \\<lbrakk>finite ?decisionVars; isInitialState ?state0.0 ?F0.0\\<rbrakk>\n  \\<Longrightarrow> wf {(stateB, stateA).\n                        (?state0.0, stateA)\n                        \\<in> transitionRelation ?F0.0 ?decisionVars \\<and>\n                        transition stateA stateB ?F0.0 ?decisionVars}\n\ngoal (1 subgoal):\n 1. wf {(stateB, stateA).\n        (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n        transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "hence wfmin: \"\\<forall>Q x. x \\<in> Q \\<longrightarrow>\n         (\\<exists>z\\<in>Q. \\<forall>y. (y, z) \\<in> ?rel \\<longrightarrow> y \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wf {(stateB, stateA).\n      (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n      transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              y \\<notin> Q)", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> {(stateB, stateA).\n                     (state0, stateA)\n                     \\<in> transitionRelation F0 decisionVars \\<and>\n                     transition stateA stateB F0\n                      decisionVars} \\<longrightarrow>\n              y \\<notin> Q)", "by simp"], ["proof (state)\nthis:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "let ?Q = \"{state \\<in> Q. (state0, state) \\<in> transitionRelation F0 decisionVars}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>state0 \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state0 \\<in> Q", "have \"state0 \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state \\<in> Q.\n           (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  state0 \\<in> Q\n\ngoal (1 subgoal):\n 1. state0\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with wfmin"], ["proof (chain)\npicking this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}", "obtain stateMin::State\n    where \"stateMin \\<in> ?Q\" and \"\\<forall>y. (y, stateMin) \\<in> ?rel \\<longrightarrow> y \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> Q)\n  state0\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin\n                 \\<in> {state \\<in> Q.\n                        (state0, state)\n                        \\<in> transitionRelation F0 decisionVars};\n         \\<forall>y.\n            (y, stateMin)\n            \\<in> {(stateB, stateA).\n                   (state0, stateA)\n                   \\<in> transitionRelation F0 decisionVars \\<and>\n                   transition stateA stateB F0\n                    decisionVars} \\<longrightarrow>\n            y \\<notin> {state \\<in> Q.\n                        (state0, state)\n                        \\<in> transitionRelation F0 decisionVars}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>stateMin.\n                \\<lbrakk>stateMin\n                         \\<in> {state \\<in> Q.\n                                (state0, state)\n                                \\<in> transitionRelation F0 decisionVars};\n                 \\<forall>y.\n                    (y, stateMin)\n                    \\<in> {(stateB, stateA).\n                           (state0, stateA)\n                           \\<in> transitionRelation F0 decisionVars \\<and>\n                           transition stateA stateB F0\n                            decisionVars} \\<longrightarrow>\n                    y \\<notin> {state \\<in> Q.\n                                (state0, state)\n                                \\<in> transitionRelation F0\n decisionVars}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     state0\n     \\<in> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars};\n     \\<forall>x.\n        x \\<in> {state \\<in> Q.\n                 (state0, state)\n                 \\<in> transitionRelation F0 decisionVars} \\<longrightarrow>\n        (\\<exists>z\\<in>{state \\<in> Q.\n                         (state0, state)\n                         \\<in> transitionRelation F0 decisionVars}.\n            \\<forall>y.\n               (y, z)\n               \\<in> {(stateB, stateA).\n                      (state0, stateA)\n                      \\<in> transitionRelation F0 decisionVars \\<and>\n                      transition stateA stateB F0\n                       decisionVars} \\<longrightarrow>\n               y \\<notin> {state \\<in> Q.\n                           (state0, state)\n                           \\<in> transitionRelation F0\n                                  decisionVars})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>stateMin \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}", "have \"stateMin \\<in> Q\" \"(state0, stateMin) \\<in> transitionRelation F0 decisionVars\""], ["proof (prove)\nusing this:\n  stateMin\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. stateMin \\<in> Q &&&\n    (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>\\<forall> state \\<in> Q. (\\<exists> state' \\<in> Q. transition state state' F0 decisionVars)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' F0 decisionVars\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars", "obtain state'::State\n    where \"state' \\<in> Q\" \"transition stateMin state' F0 decisionVars\""], ["proof (prove)\nusing this:\n  \\<forall>state\\<in>Q.\n     \\<exists>state'\\<in>Q. transition state state' F0 decisionVars\n  stateMin \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<And>state'.\n        \\<lbrakk>state' \\<in> Q;\n         transition stateMin state' F0 decisionVars\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  state' \\<in> Q\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  state' \\<in> Q\n  transition stateMin state' F0 decisionVars", "have \"(state', stateMin) \\<in> ?rel\""], ["proof (prove)\nusing this:\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  state' \\<in> Q\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> {(stateB, stateA).\n           (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n           transition stateA stateB F0 decisionVars}", "by simp"], ["proof (state)\nthis:\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>\\<forall>y. (y, stateMin) \\<in> ?rel \\<longrightarrow> y \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}", "have \"state' \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, stateMin)\n     \\<in> {(stateB, stateA).\n            (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n            transition stateA stateB F0 decisionVars} \\<longrightarrow>\n     y \\<notin> {state \\<in> Q.\n                 (state0, state) \\<in> transitionRelation F0 decisionVars}\n  (state', stateMin)\n  \\<in> {(stateB, stateA).\n         (state0, stateA) \\<in> transitionRelation F0 decisionVars \\<and>\n         transition stateA stateB F0 decisionVars}\n\ngoal (1 subgoal):\n 1. state'\n    \\<notin> {state \\<in> Q.\n              (state0, state) \\<in> transitionRelation F0 decisionVars}", "by force"], ["proof (state)\nthis:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "from \\<open>state' \\<in> Q\\<close> \\<open>(state0, stateMin) \\<in> transitionRelation F0 decisionVars\\<close>\n    \\<open>transition stateMin state' F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  state' \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars", "have \"state' \\<in> ?Q\""], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin) \\<in> transitionRelation F0 decisionVars\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state) \\<in> transitionRelation F0 decisionVars}", "unfolding transitionRelation_def"], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "using rtrancl_into_rtrancl[of \"state0\" \"stateMin\" \"{(stateA, stateB). transition stateA stateB F0 decisionVars}\" \"state'\"]"], ["proof (prove)\nusing this:\n  state' \\<in> Q\n  (state0, stateMin)\n  \\<in> {(stateA, stateB). transition stateA stateB F0 decisionVars}\\<^sup>*\n  transition stateMin state' F0 decisionVars\n  \\<lbrakk>(state0, stateMin)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*;\n   (stateMin, state')\n   \\<in> {(stateA, stateB).\n          transition stateA stateB F0 decisionVars}\\<rbrakk>\n  \\<Longrightarrow> (state0, state')\n                    \\<in> {(stateA, stateB).\n                           transition stateA stateB F0 decisionVars}\\<^sup>*\n\ngoal (1 subgoal):\n 1. state'\n    \\<in> {state \\<in> Q.\n           (state0, state)\n           \\<in> {(stateA, stateB).\n                  transition stateA stateB F0 decisionVars}\\<^sup>*}", "by simp"], ["proof (state)\nthis:\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "with \\<open>state' \\<notin> ?Q\\<close>"], ["proof (chain)\npicking this:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}", "have False"], ["proof (prove)\nusing this:\n  state'\n  \\<notin> {state \\<in> Q.\n            (state0, state) \\<in> transitionRelation F0 decisionVars}\n  state'\n  \\<in> {state \\<in> Q.\n         (state0, state) \\<in> transitionRelation F0 decisionVars}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "}"], ["proof (state)\nthis:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0\n                        decisionVars)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>Q.\n             \\<exists>state0\\<in>Q.\n                isInitialState state0 F0 \\<and>\n                (\\<forall>state\\<in>Q.\n                    \\<exists>state'\\<in>Q.\n                       transition state state' F0\n                        decisionVars)) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       \\<exists>state0\\<in>Q.\n          isInitialState state0 F0 \\<and>\n          (\\<forall>state\\<in>Q.\n              \\<exists>state'\\<in>Q.\n                 transition state state' F0 decisionVars)", "by force"], ["proof (state)\nthis:\n  \\<nexists>Q.\n     \\<exists>state0\\<in>Q.\n        isInitialState state0 F0 \\<and>\n        (\\<forall>state\\<in>Q.\n            \\<exists>state'\\<in>Q. transition state state' F0 decisionVars)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "subsection\\<open>Completeness\\<close>"], ["", "(*----------------------------------------------------------------------------*)"], ["", "text\\<open>In this section we will first show that each final state is\neither \\textit{SAT} or \\textit{UNSAT} state.\\<close>"], ["", "lemma finalNonConflictState: \n  fixes state::State and FO :: Formula\n  assumes \n  \"getConflictFlag state = False\" and\n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableConflict state\"\n  shows \"\\<not> formulaFalse (getF state) (elements (getM state))\" and \n  \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) &&&\n    decisionVars \\<subseteq> vars (elements (getM state))", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> formulaFalse (getF state) (elements (getM state))\n 2. decisionVars \\<subseteq> vars (elements (getM state))", "from \\<open>\\<not> applicableConflict state\\<close> \\<open>getConflictFlag state = False\\<close>"], ["proof (chain)\npicking this:\n  \\<not> applicableConflict state\n  getConflictFlag state = False", "show \"\\<not> formulaFalse (getF state) (elements (getM state))\""], ["proof (prove)\nusing this:\n  \\<not> applicableConflict state\n  getConflictFlag state = False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state))", "unfolding applicableConflictCharacterization"], ["proof (prove)\nusing this:\n  \\<nexists>clause.\n     getConflictFlag state = False \\<and>\n     formulaEntailsClause (getF state) clause \\<and>\n     clauseFalse clause (elements (getM state))\n  getConflictFlag state = False\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state))", "by (auto simp add:formulaFalseIffContainsFalseClause formulaEntailsItsClauses)"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "show \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisionVars \\<subseteq> vars (elements (getM state))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "fix x :: Variable"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "let ?l = \"Pos x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "assume \"x \\<in> decisionVars\""], ["proof (state)\nthis:\n  x \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "hence \"var ?l = x\" and \"var ?l \\<in> decisionVars\" and \"var (opposite ?l) \\<in> decisionVars\""], ["proof (prove)\nusing this:\n  x \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. var (Pos x) = x &&&\n    var (Pos x) \\<in> decisionVars &&&\n    var (opposite (Pos x)) \\<in> decisionVars", "by auto"], ["proof (state)\nthis:\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "with \\<open>\\<not> applicableDecide state decisionVars\\<close>"], ["proof (chain)\npicking this:\n  \\<not> applicableDecide state decisionVars\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars", "have \"literalTrue ?l (elements (getM state)) \\<or> literalFalse ?l (elements (getM state))\""], ["proof (prove)\nusing this:\n  \\<not> applicableDecide state decisionVars\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. literalTrue (Pos x) (elements (getM state)) \\<or>\n    literalFalse (Pos x) (elements (getM state))", "unfolding applicableDecideCharacterization"], ["proof (prove)\nusing this:\n  \\<nexists>l.\n     var l \\<in> decisionVars \\<and>\n     \\<not> l el elements (getM state) \\<and>\n     \\<not> opposite l el elements (getM state)\n  var (Pos x) = x\n  var (Pos x) \\<in> decisionVars\n  var (opposite (Pos x)) \\<in> decisionVars\n\ngoal (1 subgoal):\n 1. literalTrue (Pos x) (elements (getM state)) \\<or>\n    literalFalse (Pos x) (elements (getM state))", "by force"], ["proof (state)\nthis:\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> decisionVars \\<Longrightarrow>\n       x \\<in> vars (elements (getM state))", "with \\<open>var ?l = x\\<close>"], ["proof (chain)\npicking this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))", "show \"x \\<in> vars (elements (getM state))\""], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"?l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n  Pos x el elements (getM state) \\<Longrightarrow>\n  var (Pos x) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"opposite ?l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  var (Pos x) = x\n  literalTrue (Pos x) (elements (getM state)) \\<or>\n  literalFalse (Pos x) (elements (getM state))\n  Pos x el elements (getM state) \\<Longrightarrow>\n  var (Pos x) \\<in> vars (elements (getM state))\n  opposite (Pos x) el elements (getM state) \\<Longrightarrow>\n  var (opposite (Pos x)) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. x \\<in> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finalConflictingState: \n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantReasonClauses (getF state) (getM state)\" and\n  \"InvariantCFalse (getConflictFlag state) (getM state) (getC state)\" and\n  \"\\<not> applicableExplain state\" and\n  \"\\<not> applicableBackjump state\" and\n  \"getConflictFlag state\"\n  shows\n  \"getC state = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getC state = []", "proof (cases \"\\<forall> l. l el getC state \\<longrightarrow> opposite l el decisions (getM state)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "case True"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el getC state \\<longrightarrow> opposite l el decisions (getM state)\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "{"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el getC state \\<longrightarrow> opposite l el decisions (getM state)\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "assume \"getC state \\<noteq> []\""], ["proof (state)\nthis:\n  getC state \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "let ?l = \"getLastAssertedLiteral (oppositeLiteralList (getC state)) (elements (getM state))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "from \\<open>InvariantUniq (getM state)\\<close>"], ["proof (chain)\npicking this:\n  InvariantUniq (getM state)", "have \"uniq (elements (getM state))\""], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n\ngoal (1 subgoal):\n 1. uniq (elements (getM state))", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  uniq (elements (getM state))\n\ngoal (1 subgoal):\n 1. uniq (elements (getM state))", "."], ["proof (state)\nthis:\n  uniq (elements (getM state))\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "from \\<open>getConflictFlag state\\<close> \\<open>InvariantCFalse (getConflictFlag state) (getM state) (getC state)\\<close>"], ["proof (chain)\npicking this:\n  getConflictFlag state\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)", "have \"clauseFalse (getC state) (elements (getM state))\""], ["proof (prove)\nusing this:\n  getConflictFlag state\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n\ngoal (1 subgoal):\n 1. clauseFalse (getC state) (elements (getM state))", "unfolding InvariantCFalse_def"], ["proof (prove)\nusing this:\n  getConflictFlag state\n  getConflictFlag state \\<longrightarrow>\n  clauseFalse (getC state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. clauseFalse (getC state) (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  clauseFalse (getC state) (elements (getM state))\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "with \\<open>getC state \\<noteq> []\\<close>\n    \\<open>InvariantUniq (getM state)\\<close>"], ["proof (chain)\npicking this:\n  getC state \\<noteq> []\n  InvariantUniq (getM state)\n  clauseFalse (getC state) (elements (getM state))", "have \"isLastAssertedLiteral ?l (oppositeLiteralList (getC state)) (elements (getM state))\""], ["proof (prove)\nusing this:\n  getC state \\<noteq> []\n  InvariantUniq (getM state)\n  clauseFalse (getC state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (getC state))\n       (elements (getM state)))\n     (oppositeLiteralList (getC state)) (elements (getM state))", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  getC state \\<noteq> []\n  uniq (elements (getM state))\n  clauseFalse (getC state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (getC state))\n       (elements (getM state)))\n     (oppositeLiteralList (getC state)) (elements (getM state))", "using getLastAssertedLiteralCharacterization"], ["proof (prove)\nusing this:\n  getC state \\<noteq> []\n  uniq (elements (getM state))\n  clauseFalse (getC state) (elements (getM state))\n  \\<lbrakk>clauseFalse ?clause ?valuation; ?clause \\<noteq> [];\n   uniq ?valuation\\<rbrakk>\n  \\<Longrightarrow> isLastAssertedLiteral\n                     (getLastAssertedLiteral (oppositeLiteralList ?clause)\n                       ?valuation)\n                     (oppositeLiteralList ?clause) ?valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList (getC state))\n       (elements (getM state)))\n     (oppositeLiteralList (getC state)) (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (getC state))\n     (elements (getM state)))\n   (oppositeLiteralList (getC state)) (elements (getM state))\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "with True \\<open>uniq (elements (getM state))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     l el getC state \\<longrightarrow> opposite l el decisions (getM state)\n  uniq (elements (getM state))\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (getC state))\n     (elements (getM state)))\n   (oppositeLiteralList (getC state)) (elements (getM state))", "have \"\\<exists> level. (isBackjumpLevel level (opposite ?l) (getC state) (getM state))\""], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el getC state \\<longrightarrow> opposite l el decisions (getM state)\n  uniq (elements (getM state))\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (getC state))\n     (elements (getM state)))\n   (oppositeLiteralList (getC state)) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>level.\n       isBackjumpLevel level\n        (opposite\n          (getLastAssertedLiteral (oppositeLiteralList (getC state))\n            (elements (getM state))))\n        (getC state) (getM state)", "using allDecisionsThenExistsBackjumpLevel [of \"getM state\" \"getC state\" \"opposite ?l\"]"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el getC state \\<longrightarrow> opposite l el decisions (getM state)\n  uniq (elements (getM state))\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList (getC state))\n     (elements (getM state)))\n   (oppositeLiteralList (getC state)) (elements (getM state))\n  \\<lbrakk>uniq (elements (getM state));\n   \\<forall>l'.\n      l' el getC state \\<longrightarrow>\n      opposite l' el decisions (getM state);\n   isLastAssertedLiteral\n    (opposite\n      (opposite\n        (getLastAssertedLiteral (oppositeLiteralList (getC state))\n          (elements (getM state)))))\n    (oppositeLiteralList (getC state)) (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>level.\n                       isBackjumpLevel level\n                        (opposite\n                          (getLastAssertedLiteral\n                            (oppositeLiteralList (getC state))\n                            (elements (getM state))))\n                        (getC state) (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>level.\n       isBackjumpLevel level\n        (opposite\n          (getLastAssertedLiteral (oppositeLiteralList (getC state))\n            (elements (getM state))))\n        (getC state) (getM state)", "by simp"], ["proof (state)\nthis:\n  \\<exists>level.\n     isBackjumpLevel level\n      (opposite\n        (getLastAssertedLiteral (oppositeLiteralList (getC state))\n          (elements (getM state))))\n      (getC state) (getM state)\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "then"], ["proof (chain)\npicking this:\n  \\<exists>level.\n     isBackjumpLevel level\n      (opposite\n        (getLastAssertedLiteral (oppositeLiteralList (getC state))\n          (elements (getM state))))\n      (getC state) (getM state)", "obtain level::nat where\n      \"isBackjumpLevel level (opposite ?l) (getC state) (getM state)\""], ["proof (prove)\nusing this:\n  \\<exists>level.\n     isBackjumpLevel level\n      (opposite\n        (getLastAssertedLiteral (oppositeLiteralList (getC state))\n          (elements (getM state))))\n      (getC state) (getM state)\n\ngoal (1 subgoal):\n 1. (\\<And>level.\n        isBackjumpLevel level\n         (opposite\n           (getLastAssertedLiteral (oppositeLiteralList (getC state))\n             (elements (getM state))))\n         (getC state) (getM state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral (oppositeLiteralList (getC state))\n       (elements (getM state))))\n   (getC state) (getM state)\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "with \\<open>getConflictFlag state\\<close>"], ["proof (chain)\npicking this:\n  getConflictFlag state\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral (oppositeLiteralList (getC state))\n       (elements (getM state))))\n   (getC state) (getM state)", "have \"applicableBackjump state\""], ["proof (prove)\nusing this:\n  getConflictFlag state\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral (oppositeLiteralList (getC state))\n       (elements (getM state))))\n   (getC state) (getM state)\n\ngoal (1 subgoal):\n 1. applicableBackjump state", "unfolding applicableBackjumpCharacterization"], ["proof (prove)\nusing this:\n  getConflictFlag state\n  isBackjumpLevel level\n   (opposite\n     (getLastAssertedLiteral (oppositeLiteralList (getC state))\n       (elements (getM state))))\n   (getC state) (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>l level.\n       getConflictFlag state = True \\<and>\n       isBackjumpLevel level l (getC state) (getM state)", "by auto"], ["proof (state)\nthis:\n  applicableBackjump state\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "with \\<open>\\<not> applicableBackjump state\\<close>"], ["proof (chain)\npicking this:\n  \\<not> applicableBackjump state\n  applicableBackjump state", "have False"], ["proof (prove)\nusing this:\n  \\<not> applicableBackjump state\n  applicableBackjump state\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "}"], ["proof (state)\nthis:\n  getC state \\<noteq> [] \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<forall>l.\n       l el getC state \\<longrightarrow>\n       opposite l el decisions (getM state) \\<Longrightarrow>\n    getC state = []\n 2. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  getC state \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. getC state = []", "by auto"], ["proof (state)\nthis:\n  getC state = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>l.\n             l el getC state \\<longrightarrow>\n             opposite l el decisions (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>l.\n             l el getC state \\<longrightarrow>\n             opposite l el decisions (getM state))", "obtain literal::Literal where \"literal el getC state\" \"\\<not> opposite literal el decisions (getM state)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>l.\n             l el getC state \\<longrightarrow>\n             opposite l el decisions (getM state))\n\ngoal (1 subgoal):\n 1. (\\<And>literal.\n        \\<lbrakk>literal el getC state;\n         \\<not> opposite literal el decisions (getM state)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  literal el getC state\n  \\<not> opposite literal el decisions (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "with \\<open>InvariantReasonClauses (getF state) (getM state)\\<close> \\<open>InvariantCFalse (getConflictFlag state) (getM state) (getC state)\\<close> \\<open>getConflictFlag state\\<close>"], ["proof (chain)\npicking this:\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  getConflictFlag state\n  literal el getC state\n  \\<not> opposite literal el decisions (getM state)", "have \"\\<exists> c. formulaEntailsClause (getF state) c \\<and> isReason c (opposite literal) (elements (getM state))\""], ["proof (prove)\nusing this:\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  getConflictFlag state\n  literal el getC state\n  \\<not> opposite literal el decisions (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       formulaEntailsClause (getF state) c \\<and>\n       isReason c (opposite literal) (elements (getM state))", "using explainApplicableToEachNonDecision[of \"getF state\" \"getM state\" \"getConflictFlag state\" \"getC state\" \"opposite literal\"]"], ["proof (prove)\nusing this:\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  getConflictFlag state\n  literal el getC state\n  \\<not> opposite literal el decisions (getM state)\n  \\<lbrakk>InvariantReasonClauses (getF state) (getM state);\n   InvariantCFalse (getConflictFlag state) (getM state) (getC state);\n   getConflictFlag state = True; opposite (opposite literal) el getC state;\n   \\<not> opposite literal el decisions (getM state)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>clause.\n                       formulaEntailsClause (getF state) clause \\<and>\n                       isReason clause (opposite literal)\n                        (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       formulaEntailsClause (getF state) c \\<and>\n       isReason c (opposite literal) (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  \\<exists>c.\n     formulaEntailsClause (getF state) c \\<and>\n     isReason c (opposite literal) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     formulaEntailsClause (getF state) c \\<and>\n     isReason c (opposite literal) (elements (getM state))", "obtain c::Clause \n    where \"formulaEntailsClause (getF state) c\" \"isReason c (opposite literal) (elements (getM state))\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     formulaEntailsClause (getF state) c \\<and>\n     isReason c (opposite literal) (elements (getM state))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>formulaEntailsClause (getF state) c;\n         isReason c (opposite literal) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause (getF state) c\n  isReason c (opposite literal) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "with \\<open>\\<not> applicableExplain state\\<close> \\<open>getConflictFlag state\\<close> \\<open>literal el (getC state)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> applicableExplain state\n  getConflictFlag state\n  literal el getC state\n  formulaEntailsClause (getF state) c\n  isReason c (opposite literal) (elements (getM state))", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> applicableExplain state\n  getConflictFlag state\n  literal el getC state\n  formulaEntailsClause (getF state) c\n  isReason c (opposite literal) (elements (getM state))\n\ngoal (1 subgoal):\n 1. False", "unfolding applicableExplainCharacterization"], ["proof (prove)\nusing this:\n  \\<nexists>l reason.\n     getConflictFlag state = True \\<and>\n     l el getC state \\<and>\n     formulaEntailsClause (getF state) reason \\<and>\n     isReason reason (opposite l) (elements (getM state))\n  getConflictFlag state\n  literal el getC state\n  formulaEntailsClause (getF state) c\n  isReason c (opposite literal) (elements (getM state))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el getC state \\<longrightarrow>\n               opposite l el decisions (getM state)) \\<Longrightarrow>\n    getC state = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. getC state = []", "by simp"], ["proof (state)\nthis:\n  getC state = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finalStateCharacterizationLemma:\n  fixes state :: State\n  assumes \n  \"InvariantUniq (getM state)\" and\n  \"InvariantReasonClauses (getF state) (getM state)\" and\n  \"InvariantCFalse (getConflictFlag state) (getM state) (getC state)\" and\n  \"\\<not> applicableDecide state decisionVars\"  and\n  \"\\<not> applicableConflict state\"\n  \"\\<not> applicableExplain state\" and\n  \"\\<not> applicableBackjump state\"\n  shows\n  \"(getConflictFlag state = False \\<and> \n           \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n           vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (getConflictFlag state = True \\<and> \n           getC state = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "proof (cases \"getConflictFlag state\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []\n 2. \\<not> getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "case True"], ["proof (state)\nthis:\n  getConflictFlag state\n\ngoal (2 subgoals):\n 1. getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []\n 2. \\<not> getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "hence \"getC state = []\""], ["proof (prove)\nusing this:\n  getConflictFlag state\n\ngoal (1 subgoal):\n 1. getC state = []", "using assms"], ["proof (prove)\nusing this:\n  getConflictFlag state\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableBackjump state\n\ngoal (1 subgoal):\n 1. getC state = []", "using finalConflictingState"], ["proof (prove)\nusing this:\n  getConflictFlag state\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableBackjump state\n  \\<lbrakk>InvariantUniq (getM ?state);\n   InvariantReasonClauses (getF ?state) (getM ?state);\n   InvariantCFalse (getConflictFlag ?state) (getM ?state) (getC ?state);\n   \\<not> applicableExplain ?state; \\<not> applicableBackjump ?state;\n   getConflictFlag ?state\\<rbrakk>\n  \\<Longrightarrow> getC ?state = []\n\ngoal (1 subgoal):\n 1. getC state = []", "by auto"], ["proof (state)\nthis:\n  getC state = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []\n 2. \\<not> getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "with True"], ["proof (chain)\npicking this:\n  getConflictFlag state\n  getC state = []", "show ?thesis"], ["proof (prove)\nusing this:\n  getConflictFlag state\n  getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "by simp"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. \\<not> getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "case False"], ["proof (state)\nthis:\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. \\<not> getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "hence \"\\<not>formulaFalse (getF state) (elements (getM state))\" and \"vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\nusing this:\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) &&&\n    decisionVars \\<subseteq> vars (elements (getM state))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> getConflictFlag state\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableBackjump state\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) &&&\n    decisionVars \\<subseteq> vars (elements (getM state))", "using finalNonConflictState"], ["proof (prove)\nusing this:\n  \\<not> getConflictFlag state\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableBackjump state\n  \\<lbrakk>getConflictFlag ?state = False;\n   \\<not> applicableDecide ?state ?decisionVars;\n   \\<not> applicableConflict ?state\\<rbrakk>\n  \\<Longrightarrow> \\<not> formulaFalse (getF ?state)\n                            (elements (getM ?state))\n  \\<lbrakk>getConflictFlag ?state = False;\n   \\<not> applicableDecide ?state ?decisionVars;\n   \\<not> applicableConflict ?state\\<rbrakk>\n  \\<Longrightarrow> ?decisionVars \\<subseteq> vars (elements (getM ?state))\n\ngoal (1 subgoal):\n 1. \\<not> formulaFalse (getF state) (elements (getM state)) &&&\n    decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> getConflictFlag state \\<Longrightarrow>\n    getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "with False"], ["proof (chain)\npicking this:\n  \\<not> getConflictFlag state\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> getConflictFlag state\n  \\<not> formulaFalse (getF state) (elements (getM state))\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "by simp"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem finalStateCharacterization:\n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n  shows \n  \"(getConflictFlag state = False \\<and> \n      \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n      vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n   (getConflictFlag state = True \\<and> \n      getC state = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "from \\<open>isInitialState state0 F0\\<close> \\<open>(state0, state) \\<in> transitionRelation F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars", "have \"invariantsHoldInState state F0 decisionVars\""], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "using invariantsHoldInValidRunsFromInitialState"], ["proof (prove)\nusing this:\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?F0.0 ?decisionVars\\<rbrakk>\n  \\<Longrightarrow> invariantsHoldInState ?state ?F0.0 ?decisionVars\n\ngoal (1 subgoal):\n 1. invariantsHoldInState state F0 decisionVars", "by simp"], ["proof (state)\nthis:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "hence \n    *: \"InvariantUniq (getM state)\" \n    \"InvariantReasonClauses (getF state) (getM state)\" \n    \"InvariantCFalse (getConflictFlag state) (getM state) (getC state)\""], ["proof (prove)\nusing this:\n  invariantsHoldInState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM state) &&&\n    InvariantReasonClauses (getF state) (getM state) &&&\n    InvariantCFalse (getConflictFlag state) (getM state) (getC state)", "unfolding invariantsHoldInState_def"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM state) F0 decisionVars \\<and>\n  InvariantVarsF (getF state) F0 decisionVars \\<and>\n  InvariantConsistent (getM state) \\<and>\n  InvariantUniq (getM state) \\<and>\n  InvariantReasonClauses (getF state) (getM state) \\<and>\n  InvariantEquivalent F0 (getF state) \\<and>\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state) \\<and>\n  InvariantCEntailed (getConflictFlag state) (getF state) (getC state)\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM state) &&&\n    InvariantReasonClauses (getF state) (getM state) &&&\n    InvariantCFalse (getConflictFlag state) (getM state) (getC state)", "by auto"], ["proof (state)\nthis:\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "from \\<open>isFinalState state F0 decisionVars\\<close>"], ["proof (chain)\npicking this:\n  isFinalState state F0 decisionVars", "have **: \n    \"\\<not> applicableDecide state decisionVars\"\n    \"\\<not> applicableConflict state\"\n    \"\\<not> applicableExplain  state\" \n    \"\\<not> applicableLearn state\" \n    \"\\<not> applicableBackjump state\""], ["proof (prove)\nusing this:\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. (\\<not> applicableDecide state decisionVars &&&\n     \\<not> applicableConflict state) &&&\n    \\<not> applicableExplain state &&&\n    \\<not> applicableLearn state &&& \\<not> applicableBackjump state", "unfolding finalStateNonApplicable"], ["proof (prove)\nusing this:\n  \\<not> applicableDecide state decisionVars \\<and>\n  \\<not> applicableUnitPropagate state F0 decisionVars \\<and>\n  \\<not> applicableBackjump state \\<and>\n  \\<not> applicableLearn state \\<and>\n  \\<not> applicableConflict state \\<and> \\<not> applicableExplain state\n\ngoal (1 subgoal):\n 1. (\\<not> applicableDecide state decisionVars &&&\n     \\<not> applicableConflict state) &&&\n    \\<not> applicableExplain state &&&\n    \\<not> applicableLearn state &&& \\<not> applicableBackjump state", "by auto"], ["proof (state)\nthis:\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableLearn state\n  \\<not> applicableBackjump state\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "from * **"], ["proof (chain)\npicking this:\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableLearn state\n  \\<not> applicableBackjump state", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableLearn state\n  \\<not> applicableBackjump state\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "using finalStateCharacterizationLemma[of \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  InvariantReasonClauses (getF state) (getM state)\n  InvariantCFalse (getConflictFlag state) (getM state) (getC state)\n  \\<not> applicableDecide state decisionVars\n  \\<not> applicableConflict state\n  \\<not> applicableExplain state\n  \\<not> applicableLearn state\n  \\<not> applicableBackjump state\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantReasonClauses (getF state) (getM state);\n   InvariantCFalse (getConflictFlag state) (getM state) (getC state);\n   \\<not> applicableDecide state decisionVars;\n   \\<not> applicableConflict state; \\<not> applicableExplain state;\n   \\<not> applicableBackjump state\\<rbrakk>\n  \\<Longrightarrow> getConflictFlag state = False \\<and>\n                    \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "by simp"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Completeness theorems are easy consequences of this characterization and \n soundness.\\<close>"], ["", "(*----------------------------------------------------------------------------*)"], ["", "theorem completenessForSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"satisfiable F0\" and \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \"getConflictFlag state = False \\<and> \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n               vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "(*----------------------------------------------------------------------------*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "from assms"], ["proof (chain)\npicking this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars", "have *: \"(getConflictFlag state = False \\<and> \n               \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n               vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n           (getConflictFlag state = True \\<and> \n               getC state = [])\""], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "using finalStateCharacterization[of \"state0\" \"F0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> getConflictFlag state = False \\<and>\n                    \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "by auto"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "{"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "assume \"\\<not> (getConflictFlag state = False)\""], ["proof (state)\nthis:\n  getConflictFlag state \\<noteq> False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with *"], ["proof (chain)\npicking this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> False", "have \"getConflictFlag state = True\" \"getC state = []\""], ["proof (prove)\nusing this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True &&& getC state = []", "by auto"], ["proof (state)\nthis:\n  getConflictFlag state = True\n  getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with assms"], ["proof (chain)\npicking this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  getConflictFlag state = True\n  getC state = []", "have \"\\<not> satisfiable F0\""], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  getConflictFlag state = True\n  getC state = []\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "using soundnessForUNSAT"], ["proof (prove)\nusing this:\n  satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  getConflictFlag state = True\n  getC state = []\n  \\<lbrakk>isInitialState ?state0.0 ?F0.0;\n   (?state0.0, ?state) \\<in> transitionRelation ?F0.0 ?decisionVars;\n   getConflictFlag ?state = True; getC ?state = []\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable ?F0.0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable F0", "by simp"], ["proof (state)\nthis:\n  \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with \\<open>satisfiable F0\\<close>"], ["proof (chain)\npicking this:\n  satisfiable F0\n  \\<not> satisfiable F0", "have False"], ["proof (prove)\nusing this:\n  satisfiable F0\n  \\<not> satisfiable F0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "}"], ["proof (state)\nthis:\n  getConflictFlag state \\<noteq> False \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "with *"], ["proof (chain)\npicking this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> False \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> False \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "by auto"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)"], ["", "theorem completenessForUNSAT: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and\n\n  \"\\<not> satisfiable F0\" and\n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"getConflictFlag state = True \\<and> getC state = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "(************************************************************************)"], ["proof (prove)\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "from assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars", "have *: \"(getConflictFlag state = False \\<and> \n               \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> \n               vars (elements (getM state)) \\<supseteq> decisionVars) \\<or> \n           (getConflictFlag state = True \\<and> \n               getC state = [])\""], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "using finalStateCharacterization[of \"state0\" \"F0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> getConflictFlag state = False \\<and>\n                    \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars\n                    \\<subseteq> vars (elements (getM state)) \\<or>\n                    getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n    getConflictFlag state = True \\<and> getC state = []", "by auto"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "{"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "assume \"\\<not> getConflictFlag state = True\""], ["proof (state)\nthis:\n  getConflictFlag state \\<noteq> True\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "with *"], ["proof (chain)\npicking this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> True", "have \"getConflictFlag state = False \\<and> \\<not>formulaFalse (getF state) (elements (getM state)) \\<and> vars (elements (getM state)) \\<supseteq> decisionVars\""], ["proof (prove)\nusing this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> True\n\ngoal (1 subgoal):\n 1. getConflictFlag state = False \\<and>\n    \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n    decisionVars \\<subseteq> vars (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "with assms"], ["proof (chain)\npicking this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))", "have \"satisfiable F0\""], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. satisfiable F0", "using soundnessForSAT[of \"F0\" \"decisionVars\" \"state0\" \"state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<not> satisfiable F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   getConflictFlag state = False;\n   \\<not> formulaFalse (getF state) (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. satisfiable F0", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  \\<nexists>valuation. model valuation F0\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state))\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   getConflictFlag state = False;\n   \\<not> formulaFalse (getF state) (elements (getM state));\n   decisionVars \\<subseteq> vars (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> model (elements (getM state)) F0\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation F0", "by auto"], ["proof (state)\nthis:\n  satisfiable F0\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "with \\<open>\\<not> satisfiable F0\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable F0\n  satisfiable F0", "have False"], ["proof (prove)\nusing this:\n  \\<not> satisfiable F0\n  satisfiable F0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "}"], ["proof (state)\nthis:\n  getConflictFlag state \\<noteq> True \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "with *"], ["proof (chain)\npicking this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> True \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  getConflictFlag state = False \\<and>\n  \\<not> formulaFalse (getF state) (elements (getM state)) \\<and>\n  decisionVars \\<subseteq> vars (elements (getM state)) \\<or>\n  getConflictFlag state = True \\<and> getC state = []\n  getConflictFlag state \\<noteq> True \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. getConflictFlag state = True \\<and> getC state = []", "by auto"], ["proof (state)\nthis:\n  getConflictFlag state = True \\<and> getC state = []\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************************)"], ["", "theorem partialCorrectness: \n  fixes F0 :: Formula and decisionVars :: \"Variable set\" and state0 :: State and state :: State\n  assumes \n  \"vars F0 \\<subseteq> decisionVars\" and  \n\n  \"isInitialState state0 F0\" and\n  \"(state0, state) \\<in> transitionRelation F0 decisionVars\" and\n  \"isFinalState state F0 decisionVars\"\n\n  shows \n  \"satisfiable F0 = (\\<not> getConflictFlag state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> getConflictFlag state)", "(************************************************************************)"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> getConflictFlag state)", "using assms"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> getConflictFlag state)", "using completenessForUNSAT[of \"F0\" \"decisionVars\" \"state0\" \"state\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; \\<not> satisfiable F0;\n   isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> getConflictFlag state = True \\<and> getC state = []\n\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> getConflictFlag state)", "using completenessForSAT[of \"F0\" \"state0\" \"state\" \"decisionVars\"]"], ["proof (prove)\nusing this:\n  vars F0 \\<subseteq> decisionVars\n  isInitialState state0 F0\n  (state0, state) \\<in> transitionRelation F0 decisionVars\n  isFinalState state F0 decisionVars\n  \\<lbrakk>vars F0 \\<subseteq> decisionVars; \\<not> satisfiable F0;\n   isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> getConflictFlag state = True \\<and> getC state = []\n  \\<lbrakk>satisfiable F0; isInitialState state0 F0;\n   (state0, state) \\<in> transitionRelation F0 decisionVars;\n   isFinalState state F0 decisionVars\\<rbrakk>\n  \\<Longrightarrow> getConflictFlag state = False \\<and>\n                    \\<not> formulaFalse (getF state)\n                            (elements (getM state)) \\<and>\n                    decisionVars \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. satisfiable F0 = (\\<not> getConflictFlag state)", "by auto"], ["", "end"]]}