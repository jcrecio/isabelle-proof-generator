{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/Decide.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma applyDecideEffect:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\nshows \n  \"let literal = selectLiteral state Vbl in \n   let state' = applyDecide state Vbl in \n          var literal \\<notin> vars (elements (getM state)) \\<and> \n          var literal \\<in> Vbl \\<and> \n          getM state' = getM state @ [(literal, True)] \\<and> \n          getF state' = getF state\"", "lemma InvariantConsistentAfterApplyDecide:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\nshows\n  \"let state' = applyDecide state Vbl in\n         InvariantConsistent (getM state')\"", "lemma InvariantUniqAfterApplyDecide:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n  \"InvariantUniq (getM state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\nshows\n  \"let state' = applyDecide state Vbl in\n         InvariantUniq (getM state')\"", "lemma InvariantQCharacterizationAfterApplyDecide:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n\n  \"getQ state = []\"\nshows\n  \"let state' = applyDecide state Vbl in\n     InvariantQCharacterization (getConflictFlag state') (getQ state') (getF state') (getM state')\"", "lemma InvariantEquivalentZLAfterApplyDecide:\nassumes\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantEquivalentZL (getF state) (getM state) F0\"\nshows\n  \"let state' = applyDecide state Vbl in\n     InvariantEquivalentZL (getF state') (getM state') F0\"", "lemma InvariantGetReasonIsReasonAfterApplyDecide:\nassumes\n  \"\\<not> vars (elements (getM state)) \\<supseteq> Vbl\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\"\n  \"getQ state = []\"\nshows\n  \"let state' = applyDecide state Vbl in \n    InvariantGetReasonIsReason (getReason state') (getF state') (getM state') (set (getQ state'))\"", "lemma InvariantsVarsAfterApplyDecide:\nassumes\n  \"\\<not> vars (elements (getM state)) \\<supseteq> Vbl\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n\n  \"InvariantVarsM (getM state) F0 Vbl\"\n  \"InvariantVarsF (getF state) F0 Vbl\"\n  \"getQ state = []\"\nshows\n  \"let state' = applyDecide state Vbl in \n     InvariantVarsM (getM state') F0 Vbl \\<and> \n     InvariantVarsF (getF state') F0 Vbl \\<and> \n     InvariantVarsQ (getQ state') F0 Vbl\""], "translations": [["", "lemma applyDecideEffect:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\nshows \n  \"let literal = selectLiteral state Vbl in \n   let state' = applyDecide state Vbl in \n          var literal \\<notin> vars (elements (getM state)) \\<and> \n          var literal \\<in> Vbl \\<and> \n          getM state' = getM state @ [(literal, True)] \\<and> \n          getF state' = getF state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let literal = selectLiteral state Vbl; state' = applyDecide state Vbl\n    in var literal \\<notin> vars (elements (getM state)) \\<and>\n       var literal \\<in> Vbl \\<and>\n       getM state' = getM state @ [(literal, True)] \\<and>\n       getF state' = getF state", "using assms"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n\ngoal (1 subgoal):\n 1. let literal = selectLiteral state Vbl; state' = applyDecide state Vbl\n    in var literal \\<notin> vars (elements (getM state)) \\<and>\n       var literal \\<in> Vbl \\<and>\n       getM state' = getM state @ [(literal, True)] \\<and>\n       getF state' = getF state", "using selectLiteral_def[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  Vbl - vars (elements (getM state)) \\<noteq> {} \\<longrightarrow>\n  var (selectLiteral state Vbl) \\<in> Vbl - vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. let literal = selectLiteral state Vbl; state' = applyDecide state Vbl\n    in var literal \\<notin> vars (elements (getM state)) \\<and>\n       var literal \\<in> Vbl \\<and>\n       getM state' = getM state @ [(literal, True)] \\<and>\n       getF state' = getF state", "unfolding applyDecide_def"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  Vbl - vars (elements (getM state)) \\<noteq> {} \\<longrightarrow>\n  var (selectLiteral state Vbl) \\<in> Vbl - vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. let literal = selectLiteral state Vbl;\n        state' = assertLiteral (selectLiteral state Vbl) True state\n    in var literal \\<notin> vars (elements (getM state)) \\<and>\n       var literal \\<in> Vbl \\<and>\n       getM state' = getM state @ [(literal, True)] \\<and>\n       getF state' = getF state", "using assertLiteralEffect[of \"state\" \"selectLiteral state Vbl\" \"True\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  Vbl - vars (elements (getM state)) \\<noteq> {} \\<longrightarrow>\n  var (selectLiteral state Vbl) \\<in> Vbl - vars (elements (getM state))\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ\n                       (assertLiteral (selectLiteral state Vbl) True state))\n\ngoal (1 subgoal):\n 1. let literal = selectLiteral state Vbl;\n        state' = assertLiteral (selectLiteral state Vbl) True state\n    in var literal \\<notin> vars (elements (getM state)) \\<and>\n       var literal \\<in> Vbl \\<and>\n       getM state' = getM state @ [(literal, True)] \\<and>\n       getF state' = getF state", "by (simp add: Let_def)"], ["", "lemma InvariantConsistentAfterApplyDecide:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\nshows\n  \"let state' = applyDecide state Vbl in\n         InvariantConsistent (getM state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantConsistent (getM state')", "using assms"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantConsistent (getM state')", "using applyDecideEffect[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantConsistent (getM state')", "using InvariantConsistentAfterDecide[of \"getM state\" \"selectLiteral state Vbl\" \"getM (applyDecide state Vbl)\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n  \\<lbrakk>InvariantConsistent (getM state);\n   var (selectLiteral state Vbl) \\<notin> vars (elements (getM state));\n   getM (applyDecide state Vbl) =\n   getM state @ [(selectLiteral state Vbl, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM (applyDecide state Vbl))\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantConsistent (getM state')", "by (simp add: Let_def)"], ["", "lemma InvariantUniqAfterApplyDecide:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n  \"InvariantUniq (getM state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\nshows\n  \"let state' = applyDecide state Vbl in\n         InvariantUniq (getM state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantUniq (getM state')", "using assms"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantUniq (getM state')", "using applyDecideEffect[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantUniq (getM state')", "using InvariantUniqAfterDecide[of \"getM state\" \"selectLiteral state Vbl\" \"getM (applyDecide state Vbl)\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n  \\<lbrakk>InvariantUniq (getM state);\n   var (selectLiteral state Vbl) \\<notin> vars (elements (getM state));\n   getM (applyDecide state Vbl) =\n   getM state @ [(selectLiteral state Vbl, True)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM (applyDecide state Vbl))\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl in InvariantUniq (getM state')", "by (simp add: Let_def)"], ["", "lemma InvariantQCharacterizationAfterApplyDecide:\nassumes \n  \"\\<not> vars(elements (getM state)) \\<supseteq> Vbl\" and\n\n  \"InvariantConsistent (getM state)\" and\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n\n  \"getQ state = []\"\nshows\n  \"let state' = applyDecide state Vbl in\n     InvariantQCharacterization (getConflictFlag state') (getQ state') (getF state') (getM state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "let ?state' = \"applyDecide state Vbl\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "let ?literal = \"selectLiteral state Vbl\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "have \"getM ?state' = getM state @ [(?literal, True)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getM (applyDecide state Vbl) =\n    getM state @ [(selectLiteral state Vbl, True)]", "using assms"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state = []\n\ngoal (1 subgoal):\n 1. getM (applyDecide state Vbl) =\n    getM state @ [(selectLiteral state Vbl, True)]", "using applyDecideEffect[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n\ngoal (1 subgoal):\n 1. getM (applyDecide state Vbl) =\n    getM state @ [(selectLiteral state Vbl, True)]", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "hence \"InvariantConsistent (getM state @ [(?literal, True)])\""], ["proof (prove)\nusing this:\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])", "using InvariantConsistentAfterApplyDecide[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' = applyDecide state Vbl\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])", "using assms"], ["proof (prove)\nusing this:\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' = applyDecide state Vbl\n                    in InvariantConsistent (getM state')\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state = []\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "thus ?thesis"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state = []\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "using InvariantQCharacterizationAfterAssertLiteralNotInQ[of \"state\" \"?literal\" \"True\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state = []\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<not> selectLiteral state Vbl el getQ state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "unfolding applyDecide_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state @ [(selectLiteral state Vbl, True)])\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state = []\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<not> selectLiteral state Vbl el getQ state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' = assertLiteral (selectLiteral state Vbl) True state\n    in InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state')", "by simp"], ["proof (state)\nthis:\n  let state' = applyDecide state Vbl\n  in InvariantQCharacterization (getConflictFlag state') (getQ state')\n      (getF state') (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantEquivalentZLAfterApplyDecide:\nassumes\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantEquivalentZL (getF state) (getM state) F0\"\nshows\n  \"let state' = applyDecide state Vbl in\n     InvariantEquivalentZL (getF state') (getM state') F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "let ?state' = \"applyDecide state Vbl\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "let ?l = \"selectLiteral state Vbl\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "have \"getM ?state' = getM state @ [(?l, True)]\"\n    \"getF ?state' = getF state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getM (applyDecide state Vbl) =\n    getM state @ [(selectLiteral state Vbl, True)] &&&\n    getF (applyDecide state Vbl) = getF state", "unfolding applyDecide_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. getM (assertLiteral (selectLiteral state Vbl) True state) =\n    getM state @ [(selectLiteral state Vbl, True)] &&&\n    getF (assertLiteral (selectLiteral state Vbl) True state) = getF state", "using assertLiteralEffect[of \"state\" \"?l\" \"True\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ\n                       (assertLiteral (selectLiteral state Vbl) True state))\n\ngoal (1 subgoal):\n 1. getM (assertLiteral (selectLiteral state Vbl) True state) =\n    getM state @ [(selectLiteral state Vbl, True)] &&&\n    getF (assertLiteral (selectLiteral state Vbl) True state) = getF state", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ\n                       (assertLiteral (selectLiteral state Vbl) True state))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantEquivalentZL (getF state) (getM state) F0\n\ngoal (1 subgoal):\n 1. getM (assertLiteral (selectLiteral state Vbl) True state) =\n    getM state @ [(selectLiteral state Vbl, True)] &&&\n    getF (assertLiteral (selectLiteral state Vbl) True state) = getF state", "by (auto simp only: Let_def)"], ["proof (state)\nthis:\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n  getF (applyDecide state Vbl) = getF state\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "have \"prefixToLevel 0 (getM ?state') = prefixToLevel 0 (getM state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "proof (cases \"currentLevel (getM state) > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)\n 2. \\<not> 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "case True"], ["proof (state)\nthis:\n  0 < currentLevel (getM state)\n\ngoal (2 subgoals):\n 1. 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)\n 2. \\<not> 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "using prefixToLevelAppend[of \"0\" \"getM state\" \"[(?l, True)]\"]"], ["proof (prove)\nusing this:\n  0 < currentLevel (getM state)\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  (if 0 < currentLevel (getM state) then prefixToLevel 0 (getM state)\n   else getM state @\n        prefixToLevel_aux [(selectLiteral state Vbl, True)] 0\n         (currentLevel (getM state)))\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "using \\<open>getM ?state' = getM state @ [(?l, True)]\\<close>"], ["proof (prove)\nusing this:\n  0 < currentLevel (getM state)\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  (if 0 < currentLevel (getM state) then prefixToLevel 0 (getM state)\n   else getM state @\n        prefixToLevel_aux [(selectLiteral state Vbl, True)] 0\n         (currentLevel (getM state)))\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "by auto"], ["proof (state)\nthis:\n  prefixToLevel 0 (getM (applyDecide state Vbl)) =\n  prefixToLevel 0 (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "hence \"prefixToLevel 0 (getM state @ [(?l, True)]) = \n             getM state @ (prefixToLevel_aux [(?l, True)] 0 (currentLevel (getM state)))\""], ["proof (prove)\nusing this:\n  \\<not> 0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n    getM state @\n    prefixToLevel_aux [(selectLiteral state Vbl, True)] 0\n     (currentLevel (getM state))", "using prefixToLevelAppend[of \"0\" \"getM state\" \"[(?l, True)]\"]"], ["proof (prove)\nusing this:\n  \\<not> 0 < currentLevel (getM state)\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  (if 0 < currentLevel (getM state) then prefixToLevel 0 (getM state)\n   else getM state @\n        prefixToLevel_aux [(selectLiteral state Vbl, True)] 0\n         (currentLevel (getM state)))\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n    getM state @\n    prefixToLevel_aux [(selectLiteral state Vbl, True)] 0\n     (currentLevel (getM state))", "by simp"], ["proof (state)\nthis:\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  getM state @\n  prefixToLevel_aux [(selectLiteral state Vbl, True)] 0\n   (currentLevel (getM state))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "hence \"prefixToLevel 0 (getM state @ [(?l, True)]) = getM state\""], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  getM state @\n  prefixToLevel_aux [(selectLiteral state Vbl, True)] 0\n   (currentLevel (getM state))\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n    getM state", "by simp"], ["proof (state)\nthis:\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  getM state\n\ngoal (1 subgoal):\n 1. \\<not> 0 < currentLevel (getM state) \\<Longrightarrow>\n    prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "thus ?thesis"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  getM state\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "using \\<open>getM ?state' = getM state @ [(?l, True)]\\<close>"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  getM state\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "using currentLevelZeroTrailEqualsItsPrefixToLevelZero[of \"getM state\"]"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  getM state\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n  currentLevel (getM state) = 0 \\<Longrightarrow>\n  getM state = prefixToLevel 0 (getM state)\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "using False"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM state @ [(selectLiteral state Vbl, True)]) =\n  getM state\n  getM (applyDecide state Vbl) =\n  getM state @ [(selectLiteral state Vbl, True)]\n  currentLevel (getM state) = 0 \\<Longrightarrow>\n  getM state = prefixToLevel 0 (getM state)\n  \\<not> 0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. prefixToLevel 0 (getM (applyDecide state Vbl)) =\n    prefixToLevel 0 (getM state)", "by simp"], ["proof (state)\nthis:\n  prefixToLevel 0 (getM (applyDecide state Vbl)) =\n  prefixToLevel 0 (getM state)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixToLevel 0 (getM (applyDecide state Vbl)) =\n  prefixToLevel 0 (getM state)\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "thus ?thesis"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM (applyDecide state Vbl)) =\n  prefixToLevel 0 (getM state)\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "using \\<open>InvariantEquivalentZL (getF state) (getM state) F0\\<close>"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM (applyDecide state Vbl)) =\n  prefixToLevel 0 (getM state)\n  InvariantEquivalentZL (getF state) (getM state) F0\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantEquivalentZL (getF state') (getM state') F0", "unfolding InvariantEquivalentZL_def"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM (applyDecide state Vbl)) =\n  prefixToLevel 0 (getM state)\n  equivalentFormulae\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) F0\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in equivalentFormulae\n        (getF state' @ val2form (elements (prefixToLevel 0 (getM state'))))\n        F0", "using \\<open>getF ?state' = getF state\\<close>"], ["proof (prove)\nusing this:\n  prefixToLevel 0 (getM (applyDecide state Vbl)) =\n  prefixToLevel 0 (getM state)\n  equivalentFormulae\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) F0\n  getF (applyDecide state Vbl) = getF state\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in equivalentFormulae\n        (getF state' @ val2form (elements (prefixToLevel 0 (getM state'))))\n        F0", "by simp"], ["proof (state)\nthis:\n  let state' = applyDecide state Vbl\n  in InvariantEquivalentZL (getF state') (getM state') F0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantGetReasonIsReasonAfterApplyDecide:\nassumes\n  \"\\<not> vars (elements (getM state)) \\<supseteq> Vbl\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\"\n  \"getQ state = []\"\nshows\n  \"let state' = applyDecide state Vbl in \n    InvariantGetReasonIsReason (getReason state') (getF state') (getM state') (set (getQ state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "let ?l = \"selectLiteral state Vbl\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "let ?stateM = \"state \\<lparr> getM := getM state @ [(?l, True)] \\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantGetReasonIsReason (getReason ?stateM) (getF ?stateM) (getM ?stateM) (set (getQ ?stateM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "fix l::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "assume *: \"l el (elements (getM ?stateM))\" \"\\<not> l el (decisions (getM ?stateM))\" \"elementLevel l (getM ?stateM) > 0\""], ["proof (state)\nthis:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "have \"\\<exists> reason. getReason ?stateM l = Some reason \\<and>\n        0 \\<le> reason \\<and> reason < length (getF ?stateM) \\<and>\n        isReason (getF ?stateM ! reason) l (elements (getM ?stateM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "proof (cases \"l el (elements (getM state))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))\n 2. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "case True"], ["proof (state)\nthis:\n  l el elements (getM state)\n\ngoal (2 subgoals):\n 1. l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))\n 2. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "moreover"], ["proof (state)\nthis:\n  l el elements (getM state)\n\ngoal (2 subgoals):\n 1. l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))\n 2. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "hence \"\\<not> l el (decisions (getM state))\""], ["proof (prove)\nusing this:\n  l el elements (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> l el decisions (getM state)", "using *"], ["proof (prove)\nusing this:\n  l el elements (getM state)\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<not> l el decisions (getM state)", "by (simp add: markedElementsAppend)"], ["proof (state)\nthis:\n  \\<not> l el decisions (getM state)\n\ngoal (2 subgoals):\n 1. l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))\n 2. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "moreover"], ["proof (state)\nthis:\n  \\<not> l el decisions (getM state)\n\ngoal (2 subgoals):\n 1. l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))\n 2. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "have \"elementLevel l (getM state) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> 0 < elementLevel l (getM state)\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "with *"], ["proof (chain)\npicking this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> 0 < elementLevel l (getM state)", "have \"l = ?l\""], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> 0 < elementLevel l (getM state)\n\ngoal (1 subgoal):\n 1. l = selectLiteral state Vbl", "using True"], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> 0 < elementLevel l (getM state)\n  l el elements (getM state)\n\ngoal (1 subgoal):\n 1. l = selectLiteral state Vbl", "using elementLevelAppend[of \"l\" \"getM state\" \"[(?l, True)]\"]"], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> 0 < elementLevel l (getM state)\n  l el elements (getM state)\n  l \\<in> set (elements (getM state)) \\<Longrightarrow>\n  elementLevel l (getM state) =\n  elementLevel l (getM state @ [(selectLiteral state Vbl, True)])\n\ngoal (1 subgoal):\n 1. l = selectLiteral state Vbl", "by simp"], ["proof (state)\nthis:\n  l = selectLiteral state Vbl\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "hence \"var ?l \\<in> vars (elements (getM state))\""], ["proof (prove)\nusing this:\n  l = selectLiteral state Vbl\n\ngoal (1 subgoal):\n 1. var (selectLiteral state Vbl) \\<in> vars (elements (getM state))", "using True"], ["proof (prove)\nusing this:\n  l = selectLiteral state Vbl\n  l el elements (getM state)\n\ngoal (1 subgoal):\n 1. var (selectLiteral state Vbl) \\<in> vars (elements (getM state))", "using valuationContainsItsLiteralsVariable[of \"l\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  l = selectLiteral state Vbl\n  l el elements (getM state)\n  l el elements (getM state) \\<Longrightarrow>\n  var l \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. var (selectLiteral state Vbl) \\<in> vars (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  var (selectLiteral state Vbl) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "hence False"], ["proof (prove)\nusing this:\n  var (selectLiteral state Vbl) \\<in> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> vars (elements (getM state)) \\<supseteq> Vbl\\<close>"], ["proof (prove)\nusing this:\n  var (selectLiteral state Vbl) \\<in> vars (elements (getM state))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. False", "using selectLiteral_def[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  var (selectLiteral state Vbl) \\<in> vars (elements (getM state))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  Vbl - vars (elements (getM state)) \\<noteq> {} \\<longrightarrow>\n  var (selectLiteral state Vbl) \\<in> Vbl - vars (elements (getM state))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "}"], ["proof (state)\nthis:\n  \\<not> 0 < elementLevel l (getM state) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 < elementLevel l (getM state) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "by auto"], ["proof (state)\nthis:\n  0 < elementLevel l (getM state)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < elementLevel l (getM state)\n\ngoal (2 subgoals):\n 1. l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))\n 2. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "ultimately"], ["proof (chain)\npicking this:\n  l el elements (getM state)\n  \\<not> l el decisions (getM state)\n  0 < elementLevel l (getM state)", "obtain reason\n          where \"getReason state l = Some reason \\<and>\n          0 \\<le> reason \\<and> reason < length (getF state) \\<and>\n          isReason (getF state ! reason) l (elements (getM state))\""], ["proof (prove)\nusing this:\n  l el elements (getM state)\n  \\<not> l el decisions (getM state)\n  0 < elementLevel l (getM state)\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        getReason state l = Some reason \\<and>\n        0 \\<le> reason \\<and>\n        reason < length (getF state) \\<and>\n        isReason (getF state ! reason) l\n         (elements (getM state)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\\<close>"], ["proof (prove)\nusing this:\n  l el elements (getM state)\n  \\<not> l el decisions (getM state)\n  0 < elementLevel l (getM state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        getReason state l = Some reason \\<and>\n        0 \\<le> reason \\<and>\n        reason < length (getF state) \\<and>\n        isReason (getF state ! reason) l\n         (elements (getM state)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding InvariantGetReasonIsReason_def"], ["proof (prove)\nusing this:\n  l el elements (getM state)\n  \\<not> l el decisions (getM state)\n  0 < elementLevel l (getM state)\n  \\<forall>literal.\n     (literal el elements (getM state) \\<and>\n      \\<not> literal el decisions (getM state) \\<and>\n      0 < elementLevel literal (getM state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          isReason (getF state ! reason) literal\n           (elements (getM state)))) \\<and>\n     (0 < currentLevel (getM state) \\<and>\n      literal \\<in> set (getQ state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          (isUnitClause (getF state ! reason) literal\n            (elements (getM state)) \\<or>\n           clauseFalse (getF state ! reason) (elements (getM state)))))\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        getReason state l = Some reason \\<and>\n        0 \\<le> reason \\<and>\n        reason < length (getF state) \\<and>\n        isReason (getF state ! reason) l\n         (elements (getM state)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getReason state l = Some reason \\<and>\n  0 \\<le> reason \\<and>\n  reason < length (getF state) \\<and>\n  isReason (getF state ! reason) l (elements (getM state))\n\ngoal (2 subgoals):\n 1. l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))\n 2. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  getReason state l = Some reason \\<and>\n  0 \\<le> reason \\<and>\n  reason < length (getF state) \\<and>\n  isReason (getF state ! reason) l (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "using isReasonAppend[of \"nth (getF ?stateM) reason\" \"l\" \"elements (getM state)\" \"[?l]\"]"], ["proof (prove)\nusing this:\n  getReason state l = Some reason \\<and>\n  0 \\<le> reason \\<and>\n  reason < length (getF state) \\<and>\n  isReason (getF state ! reason) l (elements (getM state))\n  isReason\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) !\n    reason)\n   l (elements (getM state)) \\<Longrightarrow>\n  isReason\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) !\n    reason)\n   l (elements (getM state) @ [selectLiteral state Vbl])\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "by auto"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      l =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) !\n       reason)\n      l (elements\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "case False"], ["proof (state)\nthis:\n  \\<not> l el elements (getM state)\n\ngoal (1 subgoal):\n 1. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "hence \"l = ?l\""], ["proof (prove)\nusing this:\n  \\<not> l el elements (getM state)\n\ngoal (1 subgoal):\n 1. l = selectLiteral state Vbl", "using *"], ["proof (prove)\nusing this:\n  \\<not> l el elements (getM state)\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. l = selectLiteral state Vbl", "by auto"], ["proof (state)\nthis:\n  l = selectLiteral state Vbl\n\ngoal (1 subgoal):\n 1. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "hence \"l el (decisions (getM ?stateM))\""], ["proof (prove)\nusing this:\n  l = selectLiteral state Vbl\n\ngoal (1 subgoal):\n 1. l el\n    decisions\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))", "using markedElementIsMarkedTrue[of \"l\" \"getM ?stateM\"]"], ["proof (prove)\nusing this:\n  l = selectLiteral state Vbl\n  (l \\<in> set (decisions\n                 (getM\n                   (state\n                    \\<lparr>getM :=\n                              getM state @\n                              [(selectLiteral state Vbl,\n                                True)]\\<rparr>)))) =\n  ((l, True)\n   \\<in> set (getM\n               (state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. l el\n    decisions\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  l el\n  decisions\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "with *"], ["proof (chain)\npicking this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  l el\n  decisions\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))", "have False"], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>))\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n  l el\n  decisions\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> l el elements (getM state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)))", "by simp"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      l =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) !\n       reason)\n      l (elements\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      l =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM :=\n                   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) !\n       reason)\n      l (elements\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l2 el\n           elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<not> ?l2 el\n          decisions\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   0 < elementLevel ?l2\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(selectLiteral state Vbl,\n                                     True)]\\<rparr>)\n                        ?l2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n                       isReason\n                        (getF\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(selectLiteral state Vbl,\n True)]\\<rparr>) !\n                         reason)\n                        ?l2\n                        (elements\n                          (getM\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l2 el\n           elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<not> ?l2 el\n          decisions\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   0 < elementLevel ?l2\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(selectLiteral state Vbl,\n                                     True)]\\<rparr>)\n                        ?l2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n                       isReason\n                        (getF\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(selectLiteral state Vbl,\n True)]\\<rparr>) !\n                         reason)\n                        ?l2\n                        (elements\n                          (getM\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "using \\<open>getQ state = []\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l2 el\n           elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<not> ?l2 el\n          decisions\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   0 < elementLevel ?l2\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(selectLiteral state Vbl,\n                                     True)]\\<rparr>)\n                        ?l2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n                       isReason\n                        (getF\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(selectLiteral state Vbl,\n True)]\\<rparr>) !\n                         reason)\n                        ?l2\n                        (elements\n                          (getM\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)))\n  getQ state = []\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n     (set (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(selectLiteral state Vbl, True)]\\<rparr>)))", "unfolding InvariantGetReasonIsReason_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l2 el\n           elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<not> ?l2 el\n          decisions\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   0 < elementLevel ?l2\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(selectLiteral state Vbl,\n                                     True)]\\<rparr>)\n                        ?l2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n                       isReason\n                        (getF\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(selectLiteral state Vbl,\n True)]\\<rparr>) !\n                         reason)\n                        ?l2\n                        (elements\n                          (getM\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)))\n  getQ state = []\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       (literal el\n        elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @\n                      [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n        \\<not> literal el\n               decisions\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(selectLiteral state Vbl,\n                               True)]\\<rparr>)) \\<and>\n        0 < elementLevel literal\n             (getM\n               (state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl,\n                            True)]\\<rparr>)) \\<longrightarrow>\n        (\\<exists>reason.\n            getReason\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>)\n             literal =\n            Some reason \\<and>\n            0 \\<le> reason \\<and>\n            reason\n            < length\n               (getF\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(selectLiteral state Vbl,\n                              True)]\\<rparr>)) \\<and>\n            isReason\n             (getF\n               (state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>) !\n              reason)\n             literal\n             (elements\n               (getM\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(selectLiteral state Vbl,\n                              True)]\\<rparr>))))) \\<and>\n       (0 < currentLevel\n             (getM\n               (state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>)) \\<and>\n        literal\n        \\<in> set (getQ\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl,\n                                 True)]\\<rparr>)) \\<longrightarrow>\n        (\\<exists>reason.\n            getReason\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>)\n             literal =\n            Some reason \\<and>\n            0 \\<le> reason \\<and>\n            reason\n            < length\n               (getF\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(selectLiteral state Vbl,\n                              True)]\\<rparr>)) \\<and>\n            (isUnitClause\n              (getF\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(selectLiteral state Vbl, True)]\\<rparr>) !\n               reason)\n              literal\n              (elements\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(selectLiteral state Vbl,\n                               True)]\\<rparr>))) \\<or>\n             clauseFalse\n              (getF\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(selectLiteral state Vbl, True)]\\<rparr>) !\n               reason)\n              (elements\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(selectLiteral state Vbl, True)]\\<rparr>))))))", "by auto"], ["proof (state)\nthis:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using assms"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using InvariantGetReasonIsReasonAfterNotifyWatches[of \"?stateM\" \"getWatchList ?stateM (opposite ?l)\"\n      \"opposite ?l\" \"getM state\" \"True\" \"{}\" \"[]\"]"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "unfolding applyDecide_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. let state' = assertLiteral (selectLiteral state Vbl) True state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "unfolding assertLiteral_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          Let (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>)\n           (notifyWatches (opposite (selectLiteral state Vbl)))\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "unfolding notifyWatches_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>\n          in notifyWatches_loop (opposite (selectLiteral state Vbl))\n              (getWatchList state' (opposite (selectLiteral state Vbl))) []\n              state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "unfolding InvariantWatchListsCharacterization_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>\n          in notifyWatches_loop (opposite (selectLiteral state Vbl))\n              (getWatchList state' (opposite (selectLiteral state Vbl))) []\n              state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "unfolding InvariantWatchListsContainOnlyClausesFromF_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>\n          in notifyWatches_loop (opposite (selectLiteral state Vbl))\n              (getWatchList state' (opposite (selectLiteral state Vbl))) []\n              state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "unfolding InvariantWatchListsUniq_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  \\<forall>l. uniq (getWatchList state l)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>\n          in notifyWatches_loop (opposite (selectLiteral state Vbl))\n              (getWatchList state' (opposite (selectLiteral state Vbl))) []\n              state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using \\<open>getQ state = []\\<close>"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getF\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n   (set (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(selectLiteral state Vbl, True)]\\<rparr>)))\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  \\<forall>l. uniq (getWatchList state l)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state = []\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @\n                         [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(selectLiteral state Vbl, True)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(selectLiteral state Vbl, True)]\\<rparr>)\n                    (opposite (selectLiteral state Vbl))) \\<longrightarrow>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch1\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c \\<or>\n      Some (opposite (selectLiteral state Vbl)) =\n      getWatch2\n       (state\n        \\<lparr>getM :=\n                  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n      (opposite (selectLiteral state Vbl)));\n   getM\n    (state\n     \\<lparr>getM :=\n               getM state @ [(selectLiteral state Vbl, True)]\\<rparr>) =\n   getM state @ [(opposite (opposite (selectLiteral state Vbl)), True)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))\n    {}\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop\n                           (opposite (selectLiteral state Vbl))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                             (opposite (selectLiteral state Vbl)))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(selectLiteral state Vbl, True)]\\<rparr>)\n                    in Let ({} \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(selectLiteral state Vbl, True)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n  getQ state = []\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = state\n                \\<lparr>getM :=\n                          getM state @\n                          [(selectLiteral state Vbl, True)]\\<rparr>\n          in notifyWatches_loop (opposite (selectLiteral state Vbl))\n              (getWatchList state' (opposite (selectLiteral state Vbl))) []\n              state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyDecide state Vbl\n  in InvariantGetReasonIsReason (getReason state') (getF state')\n      (getM state') (set (getQ state'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantsVarsAfterApplyDecide:\nassumes\n  \"\\<not> vars (elements (getM state)) \\<supseteq> Vbl\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n\n  \"InvariantVarsM (getM state) F0 Vbl\"\n  \"InvariantVarsF (getF state) F0 Vbl\"\n  \"getQ state = []\"\nshows\n  \"let state' = applyDecide state Vbl in \n     InvariantVarsM (getM state') F0 Vbl \\<and> \n     InvariantVarsF (getF state') F0 Vbl \\<and> \n     InvariantVarsQ (getQ state') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "let ?state' = \"applyDecide state Vbl\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "let ?l = \"selectLiteral state Vbl\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "have \"InvariantVarsM (getM ?state') F0 Vbl\" \"InvariantVarsF (getF ?state') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl &&&\n    InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl", "using assms"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl &&&\n    InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl", "using applyDecideEffect[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl &&&\n    InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl", "using varsAppendValuation[of \"elements (getM state)\" \"[?l]\"]"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n  vars (elements (getM state) @ [selectLiteral state Vbl]) =\n  vars (elements (getM state)) \\<union> vars [selectLiteral state Vbl]\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl &&&\n    InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  vars (elements (getM state)) \\<subseteq> vars F0 \\<union> Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let literal = selectLiteral state Vbl;\n                        state' = applyDecide state Vbl\n                    in var literal\n                       \\<notin> vars (elements (getM state)) \\<and>\n                       var literal \\<in> Vbl \\<and>\n                       getM state' = getM state @ [(literal, True)] \\<and>\n                       getF state' = getF state\n  vars (elements (getM state) @ [selectLiteral state Vbl]) =\n  vars (elements (getM state)) \\<union> vars [selectLiteral state Vbl]\n\ngoal (1 subgoal):\n 1. vars (elements (getM (applyDecide state Vbl)))\n    \\<subseteq> vars F0 \\<union> Vbl &&&\n    InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl\n  InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl\n  InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "have \"InvariantVarsQ (getQ ?state') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl", "using InvariantVarsQAfterAssertLiteral[of \"state\" \"?l\" \"True\" \"F0\" \"Vbl\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantUniq (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantUniq (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl", "using InvariantConsistentAfterApplyDecide[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantUniq (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' = applyDecide state Vbl\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl", "using InvariantUniqAfterApplyDecide[of \"Vbl\" \"state\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantUniq (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' = applyDecide state Vbl\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' = applyDecide state Vbl\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl", "using assertLiteralEffect[of \"state\" \"?l\" \"True\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantUniq (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' = applyDecide state Vbl\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' = applyDecide state Vbl\n                    in InvariantUniq (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ\n                       (assertLiteral (selectLiteral state Vbl) True state))\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl", "unfolding applyDecide_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantUniq (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantUniq (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ\n                       (assertLiteral (selectLiteral state Vbl) True state))\n\ngoal (1 subgoal):\n 1. InvariantVarsQ\n     (getQ (assertLiteral (selectLiteral state Vbl) True state)) F0 Vbl", "unfolding InvariantVarsQ_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantConsistent\n            (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantUniq (getM state @ [(selectLiteral state Vbl, True)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   vars (getQ state) \\<subseteq> vars F0 \\<union> Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in vars (getQ state') \\<subseteq> vars F0 \\<union> Vbl\n  \\<not> Vbl \\<subseteq> vars (elements (getM state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  getQ state = []\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>\\<not> Vbl \\<subseteq> vars (elements (getM state));\n   InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state)\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (selectLiteral state Vbl) True state\n                    in InvariantUniq (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getM state @ [(selectLiteral state Vbl, True)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (selectLiteral state Vbl) True state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ\n                       (assertLiteral (selectLiteral state Vbl) True state))\n\ngoal (1 subgoal):\n 1. vars (getQ (assertLiteral (selectLiteral state Vbl) True state))\n    \\<subseteq> vars F0 \\<union> Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl\n  InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl\n  InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsM (getM (applyDecide state Vbl)) F0 Vbl\n  InvariantVarsF (getF (applyDecide state Vbl)) F0 Vbl\n  InvariantVarsQ (getQ (applyDecide state Vbl)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyDecide state Vbl\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyDecide state Vbl\n  in InvariantVarsM (getM state') F0 Vbl \\<and>\n     InvariantVarsF (getF state') F0 Vbl \\<and>\n     InvariantVarsQ (getQ state') F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}