{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/CNF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma literalElFormulaCharacterization:\n  fixes literal :: Literal and formula :: Formula\n  shows \"(literal el formula) = (\\<exists> (clause::Clause). clause el formula \\<and> literal el clause)\"", "lemma clauseContainsItsLiteralsVariable: \n  fixes literal :: Literal and clause :: Clause\n  assumes \"literal el clause\"\n  shows \"var literal \\<in> vars clause\"", "lemma formulaContainsItsLiteralsVariable:\n  fixes literal :: Literal and formula::Formula\n  assumes \"literal el formula\" \n  shows \"var literal \\<in> vars formula\"", "lemma formulaContainsItsClausesVariables:\n  fixes clause :: Clause and formula :: Formula\n  assumes \"clause el formula\"\n  shows \"vars clause \\<subseteq> vars formula\"", "lemma varsAppendFormulae:\n  fixes formula1 :: Formula and formula2 :: Formula\n  shows \"vars (formula1 @ formula2) = vars formula1 \\<union> vars formula2\"", "lemma varsAppendClauses:\n  fixes clause1 :: Clause and clause2 :: Clause\n  shows \"vars (clause1 @ clause2) = vars clause1 \\<union> vars clause2\"", "lemma varsRemoveLiteral:\n  fixes literal :: Literal and clause :: Clause\n  shows \"vars (removeAll literal clause) \\<subseteq> vars clause\"", "lemma varsRemoveLiteralSuperset:\n  fixes literal :: Literal and clause :: Clause\n  shows \"vars clause - {var literal}  \\<subseteq> vars (removeAll literal clause)\"", "lemma varsRemoveAllClause:\n  fixes clause :: Clause and formula :: Formula\n  shows \"vars (removeAll clause formula) \\<subseteq> vars formula\"", "lemma varsRemoveAllClauseSuperset:\n  fixes clause :: Clause and formula :: Formula\n  shows \"vars formula - vars clause \\<subseteq> vars (removeAll clause formula)\"", "lemma varInClauseVars:\n  fixes variable :: Variable and clause :: Clause\n  shows \"variable \\<in> vars clause = (\\<exists> literal. literal el clause \\<and> var literal = variable)\"", "lemma varInFormulaVars: \n  fixes variable :: Variable and formula :: Formula\n  shows \"variable \\<in> vars formula = (\\<exists> literal. literal el formula \\<and> var literal = variable)\" (is \"?lhs formula = ?rhs formula\")", "lemma varsSubsetFormula:\n  fixes F :: Formula and F' :: Formula\n  assumes \"\\<forall> c::Clause. c el F \\<longrightarrow> c el F'\"\n  shows \"vars F \\<subseteq> vars F'\"", "lemma varsClauseVarsSet:\nfixes \n  clause :: Clause\nshows\n  \"vars clause = vars (set clause)\"", "lemma oppositeIdempotency [simp]:\n  fixes literal::Literal\n  shows \"opposite (opposite literal) = literal\"", "lemma oppositeSymmetry [simp]:\n  fixes literal1::Literal and literal2::Literal\n  shows \"(opposite literal1 = literal2) = (opposite literal2 = literal1)\"", "lemma oppositeUniqueness [simp]:\n  fixes literal1::Literal and literal2::Literal\n  shows \"(opposite literal1 = opposite literal2) = (literal1 = literal2)\"", "lemma oppositeIsDifferentFromLiteral [simp]:\n  fixes literal::Literal\n  shows \"opposite literal \\<noteq> literal\"", "lemma oppositeLiteralsHaveSameVariable [simp]:\n  fixes literal::Literal\n  shows \"var (opposite literal) = var literal\"", "lemma literalsWithSameVariableAreEqualOrOpposite:\n  fixes literal1::Literal and literal2::Literal\n  shows \"(var literal1 = var literal2) = (literal1 = literal2 \\<or> opposite literal1 = literal2)\" (is \"?lhs = ?rhs\")", "lemma literalElListIffOppositeLiteralElOppositeLiteralList: \n  fixes literal :: Literal and literalList :: \"Literal list\"\n  shows \"literal el literalList = (opposite literal) el (oppositeLiteralList literalList)\"", "lemma oppositeLiteralListIdempotency [simp]: \n  fixes literalList :: \"Literal list\"\n  shows \"oppositeLiteralList (oppositeLiteralList literalList) = literalList\"", "lemma oppositeLiteralListRemove: \n  fixes literal :: Literal and literalList :: \"Literal list\"\n  shows \"oppositeLiteralList (removeAll literal literalList) = removeAll (opposite literal) (oppositeLiteralList literalList)\"", "lemma oppositeLiteralListNonempty:\n  fixes literalList :: \"Literal list\"\n  shows \"(literalList \\<noteq> []) = ((oppositeLiteralList literalList) \\<noteq> [])\"", "lemma varsOppositeLiteralList:\nshows \"vars (oppositeLiteralList clause) = vars clause\"", "lemma clauseTautologyCharacterization: \n  fixes clause :: Clause\n  shows \"clauseTautology clause = (\\<exists> literal. literal el clause \\<and> (opposite literal) el clause)\"", "lemma valuationContainsItsLiteralsVariable: \n  fixes literal :: Literal and valuation :: Valuation\n  assumes \"literal el valuation\"\n  shows \"var literal \\<in> vars valuation\"", "lemma varsSubsetValuation: \n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  assumes \"set valuation1  \\<subseteq> set valuation2\"\n  shows \"vars valuation1 \\<subseteq> vars valuation2\"", "lemma varsAppendValuation:\n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  shows \"vars (valuation1 @ valuation2) = vars valuation1 \\<union> vars valuation2\"", "lemma varsPrefixValuation:\n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  assumes \"isPrefix valuation1 valuation2\"\n  shows \"vars valuation1 \\<subseteq> vars valuation2\"", "lemma variableDefinedImpliesLiteralDefined:\n  fixes literal :: Literal and valuation :: Valuation\n  shows \"var literal \\<in> vars valuation = (literalTrue literal valuation \\<or> literalFalse literal valuation)\" \n    (is \"(?lhs valuation) = (?rhs valuation)\")", "lemma clauseTrueIffContainsTrueLiteral: \n  fixes clause :: Clause and valuation :: Valuation  \n  shows \"clauseTrue clause valuation = (\\<exists> literal. literal el clause \\<and> literalTrue literal valuation)\"", "lemma clauseFalseIffAllLiteralsAreFalse:\n  fixes clause :: Clause and valuation :: Valuation  \n  shows \"clauseFalse clause valuation = (\\<forall> literal. literal el clause \\<longrightarrow> literalFalse literal valuation)\"", "lemma clauseFalseRemove:\n  assumes \"clauseFalse clause valuation\"\n  shows \"clauseFalse (removeAll literal clause) valuation\"", "lemma clauseFalseAppendValuation: \n  fixes clause :: Clause and valuation :: Valuation and valuation' :: Valuation\n  assumes \"clauseFalse clause valuation\"\n  shows \"clauseFalse clause (valuation @ valuation')\"", "lemma clauseTrueAppendValuation:\n  fixes clause :: Clause and valuation :: Valuation and valuation' :: Valuation\n  assumes \"clauseTrue clause valuation\"\n  shows \"clauseTrue clause (valuation @ valuation')\"", "lemma emptyClauseIsFalse:\n  fixes valuation :: Valuation\n  shows \"clauseFalse [] valuation\"", "lemma emptyValuationFalsifiesOnlyEmptyClause:\n  fixes clause :: Clause\n  assumes \"clause \\<noteq> []\"\n  shows \"\\<not>  clauseFalse clause []\"", "lemma valuationContainsItsFalseClausesVariables:\n  fixes clause::Clause and valuation::Valuation\n  assumes \"clauseFalse clause valuation\"\n  shows \"vars clause \\<subseteq> vars valuation\"", "lemma formulaTrueIffAllClausesAreTrue: \n  fixes formula :: Formula and valuation :: Valuation\n  shows \"formulaTrue formula valuation = (\\<forall> clause. clause el formula \\<longrightarrow> clauseTrue clause valuation)\"", "lemma formulaFalseIffContainsFalseClause: \n  fixes formula :: Formula and valuation :: Valuation\n  shows \"formulaFalse formula valuation = (\\<exists> clause. clause el formula \\<and> clauseFalse clause valuation)\"", "lemma formulaTrueAssociativity:\n  fixes f1 :: Formula and f2 :: Formula and f3 :: Formula and valuation :: Valuation\n  shows \"formulaTrue ((f1 @ f2) @ f3) valuation = formulaTrue (f1 @ (f2 @ f3)) valuation\"", "lemma formulaTrueCommutativity:\n  fixes f1 :: Formula and f2 :: Formula and valuation :: Valuation\n  shows \"formulaTrue (f1 @ f2) valuation = formulaTrue (f2 @ f1) valuation\"", "lemma formulaTrueSubset:\n  fixes formula :: Formula and formula' :: Formula and valuation :: Valuation\n  assumes \n  formulaTrue: \"formulaTrue formula valuation\" and\n  subset: \"\\<forall> (clause::Clause). clause el formula' \\<longrightarrow> clause el formula\"\n  shows \"formulaTrue formula' valuation\"", "lemma formulaTrueAppend:\n  fixes formula1 :: Formula and formula2 :: Formula and valuation :: Valuation\n  shows \"formulaTrue (formula1 @ formula2) valuation = (formulaTrue formula1 valuation \\<and> formulaTrue formula2 valuation)\"", "lemma formulaTrueRemoveAll:\n  fixes formula :: Formula and clause :: Clause and valuation :: Valuation    \n  assumes \"formulaTrue formula valuation\"\n  shows \"formulaTrue (removeAll clause formula) valuation\"", "lemma formulaFalseAppend: \n  fixes formula :: Formula and formula' :: Formula and valuation :: Valuation  \n  assumes \"formulaFalse formula valuation\"\n  shows \"formulaFalse (formula @ formula') valuation\"", "lemma formulaTrueAppendValuation: \n  fixes formula :: Formula and valuation :: Valuation and valuation' :: Valuation\n  assumes \"formulaTrue formula valuation\"\n  shows \"formulaTrue formula (valuation @ valuation')\"", "lemma formulaFalseAppendValuation: \n  fixes formula :: Formula and valuation :: Valuation and valuation' :: Valuation\n  assumes \"formulaFalse formula valuation\"\n  shows \"formulaFalse formula (valuation @ valuation')\"", "lemma trueFormulaWithSingleLiteralClause:\n  fixes formula :: Formula and literal :: Literal and valuation :: Valuation\n  assumes \"formulaTrue (removeAll [literal] formula) (valuation @ [literal])\"\n  shows \"formulaTrue formula (valuation @ [literal])\"", "lemma val2FormEl: \n  fixes literal :: Literal and valuation :: Valuation \n  shows \"literal el valuation = [literal] el val2form valuation\"", "lemma val2FormAreSingleLiteralClauses: \n  fixes clause :: Clause and valuation :: Valuation\n  shows \"clause el val2form valuation \\<longrightarrow> (\\<exists> literal. clause = [literal] \\<and> literal el valuation)\"", "lemma val2formOfSingleLiteralValuation:\nassumes \"length v = 1\"\nshows \"val2form v = [[hd v]]\"", "lemma val2FormRemoveAll: \n  fixes literal :: Literal and valuation :: Valuation \n  shows \"removeAll [literal] (val2form valuation) = val2form (removeAll literal valuation)\"", "lemma val2formAppend: \n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  shows \"val2form (valuation1 @ valuation2) = (val2form valuation1 @ val2form valuation2)\"", "lemma val2formFormulaTrue: \n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  shows \"formulaTrue (val2form valuation1) valuation2 = (\\<forall> (literal :: Literal). literal el valuation1 \\<longrightarrow> literal el valuation2)\"", "lemma inconsistentCharacterization: \n  fixes valuation :: Valuation\n  shows \"inconsistent valuation = (\\<exists> literal. literalTrue literal valuation \\<and> literalFalse literal valuation)\"", "lemma clauseTrueAndClauseFalseImpliesInconsistent: \n  fixes clause :: Clause and valuation :: Valuation\n  assumes \"clauseTrue clause valuation\" and \"clauseFalse clause valuation\"\n  shows \"inconsistent valuation\"", "lemma formulaTrueAndFormulaFalseImpliesInconsistent: \n  fixes formula :: Formula and valuation :: Valuation\n  assumes \"formulaTrue formula valuation\" and \"formulaFalse formula valuation\"\n  shows \"inconsistent valuation\"", "lemma inconsistentAppend:\n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  assumes \"inconsistent (valuation1 @ valuation2)\"\n  shows \"inconsistent valuation1 \\<or> inconsistent valuation2 \\<or> (\\<exists> literal. literalTrue literal valuation1 \\<and> literalFalse literal valuation2)\"", "lemma consistentAppendElement:\nassumes \"consistent v\" and \"\\<not> literalFalse l v\"\nshows \"consistent (v @ [l])\"", "lemma inconsistentRemoveAll:\n  fixes literal :: Literal and valuation :: Valuation\n  assumes \"inconsistent (removeAll literal valuation)\" \n  shows \"inconsistent valuation\"", "lemma inconsistentPrefix: \n  assumes \"isPrefix valuation1 valuation2\" and \"inconsistent valuation1\"\n  shows \"inconsistent valuation2\"", "lemma consistentPrefix:\n  assumes \"isPrefix valuation1 valuation2\" and \"consistent valuation2\"\n  shows \"consistent valuation1\"", "lemma totalSubset: \n  fixes A :: \"Variable set\" and B :: \"Variable set\" and valuation :: \"Valuation\"\n  assumes \"A \\<subseteq> B\" and \"total valuation B\"\n  shows \"total valuation A\"", "lemma totalFormulaImpliesTotalClause:\n  fixes clause :: Clause and formula :: Formula and valuation :: Valuation\n  assumes clauseEl: \"clause el formula\" and totalFormula: \"total valuation (vars formula)\"\n  shows totalClause: \"total valuation (vars clause)\"", "lemma totalValuationForClauseDefinesAllItsLiterals:\n  fixes clause :: Clause and valuation :: Valuation and literal :: Literal\n  assumes \n  totalClause: \"total valuation (vars clause)\" and\n  literalEl: \"literal el clause\"\n  shows trueOrFalse: \"literalTrue literal valuation \\<or> literalFalse literal valuation\"", "lemma totalValuationForClauseDefinesItsValue:\n  fixes clause :: Clause and valuation :: Valuation\n  assumes totalClause: \"total valuation (vars clause)\"\n  shows \"clauseTrue clause valuation \\<or> clauseFalse clause valuation\"", "lemma totalValuationForFormulaDefinesAllItsLiterals: \n  fixes formula::Formula and valuation::Valuation\n  assumes totalFormula: \"total valuation (vars formula)\" and\n  literalElFormula: \"literal el formula\"\n  shows \"literalTrue literal valuation \\<or> literalFalse literal valuation\"", "lemma totalValuationForFormulaDefinesAllItsClauses:\n  fixes formula :: Formula and valuation :: Valuation and clause :: Clause\n  assumes totalFormula: \"total valuation (vars formula)\" and \n  clauseElFormula: \"clause el formula\" \n  shows \"clauseTrue clause valuation \\<or> clauseFalse clause valuation\"", "lemma totalValuationForFormulaDefinesItsValue:\n  assumes totalFormula: \"total valuation (vars formula)\"\n  shows \"formulaTrue formula valuation \\<or> formulaFalse formula valuation\"", "lemma totalRemoveAllSingleLiteralClause:\n  fixes literal :: Literal and valuation :: Valuation and formula :: Formula\n  assumes varLiteral: \"var literal \\<in> vars valuation\" and totalRemoveAll: \"total valuation (vars (removeAll [literal] formula))\"\n  shows \"total valuation (vars formula)\"", "lemma formulaWithEmptyClauseIsUnsatisfiable:\n  fixes formula :: Formula\n  assumes \"([]::Clause) el formula\"\n  shows \"\\<not> satisfiable formula\"", "lemma satisfiableSubset: \n  fixes formula0 :: Formula and formula :: Formula\n  assumes subset: \"\\<forall> (clause::Clause). clause el formula0 \\<longrightarrow> clause el formula\"\n  shows  \"satisfiable formula \\<longrightarrow> satisfiable formula0\"", "lemma satisfiableAppend: \n  fixes formula1 :: Formula and formula2 :: Formula\n  assumes \"satisfiable (formula1 @ formula2)\" \n  shows \"satisfiable formula1\" \"satisfiable formula2\"", "lemma modelExpand: \n  fixes formula :: Formula and literal :: Literal and valuation :: Valuation\n  assumes \"model valuation formula\" and \"var literal \\<notin> vars valuation\"\n  shows \"model (valuation @ [literal]) formula\"", "lemma tautologyNotFalse:\n  fixes clause :: Clause and valuation :: Valuation\n  assumes \"clauseTautology clause\" \"consistent valuation\"\n  shows \"\\<not> clauseFalse clause valuation\"", "lemma tautologyInTotalValuation:\nassumes \n  \"clauseTautology clause\"\n  \"vars clause \\<subseteq> vars valuation\"\nshows\n  \"clauseTrue clause valuation\"", "lemma modelAppendTautology:\nassumes\n  \"model valuation F\" \"clauseTautology c\"\n  \"vars valuation \\<supseteq> vars F \\<union> vars c\"\nshows\n  \"model valuation (F @ [c])\"", "lemma satisfiableAppendTautology:\nassumes \n  \"satisfiable F\" \"clauseTautology c\"\nshows\n  \"satisfiable (F @ [c])\"", "lemma modelAppendTautologicalFormula:\nfixes\n  F :: Formula and F' :: Formula\nassumes\n  \"model valuation F\" \"\\<forall> c. c el F' \\<longrightarrow> clauseTautology c\"\n  \"vars valuation \\<supseteq> vars F \\<union> vars F'\"\nshows\n  \"model valuation (F @ F')\"", "lemma satisfiableAppendTautologicalFormula:\nassumes \n  \"satisfiable F\" \"\\<forall> c. c el F' \\<longrightarrow> clauseTautology c\"\nshows\n  \"satisfiable (F @ F')\"", "lemma satisfiableFilterTautologies:\nshows \"satisfiable F = satisfiable (filter (% c. \\<not> clauseTautology c) F)\"", "lemma modelFilterTautologies:\nassumes \n  \"model valuation (filter (% c. \\<not> clauseTautology c) F)\" \n  \"vars F \\<subseteq> vars valuation\"\nshows \"model valuation F\"", "lemma singleLiteralClausesEntailItsLiteral: \n  fixes clause :: Clause and literal :: Literal\n  assumes \"length clause = 1\" and \"literal el clause\"\n  shows \"clauseEntailsLiteral clause literal\"", "lemma clauseEntailsLiteralThenFormulaEntailsLiteral:\n  fixes clause :: Clause and formula :: Formula and literal :: Literal\n  assumes \"clause el formula\" and \"clauseEntailsLiteral clause literal\"\n  shows \"formulaEntailsLiteral formula literal\"", "lemma formulaEntailsLiteralAppend: \n  fixes formula :: Formula and formula' :: Formula and literal :: Literal\n  assumes \"formulaEntailsLiteral formula literal\"\n  shows  \"formulaEntailsLiteral (formula @ formula') literal\"", "lemma formulaEntailsLiteralSubset: \n  fixes formula :: Formula and formula' :: Formula and literal :: Literal\n  assumes \"formulaEntailsLiteral formula literal\" and \"\\<forall> (c::Clause) . c el formula \\<longrightarrow> c el formula'\"\n  shows \"formulaEntailsLiteral formula' literal\"", "lemma formulaEntailsLiteralRemoveAll:\n  fixes formula :: Formula and clause :: Clause and literal :: Literal\n  assumes \"formulaEntailsLiteral (removeAll clause formula) literal\"\n  shows \"formulaEntailsLiteral formula literal\"", "lemma formulaEntailsLiteralRemoveAllAppend:\n  fixes formula1 :: Formula and formula2 :: Formula and clause :: Clause and valuation :: Valuation\n  assumes \"formulaEntailsLiteral ((removeAll clause formula1) @ formula2) literal\" \n  shows \"formulaEntailsLiteral (formula1 @ formula2) literal\"", "lemma formulaEntailsItsClauses: \n  fixes clause :: Clause and formula :: Formula\n  assumes \"clause el formula\"\n  shows \"formulaEntailsClause formula clause\"", "lemma formulaEntailsClauseAppend: \n  fixes clause :: Clause and formula :: Formula and formula' :: Formula\n  assumes \"formulaEntailsClause formula clause\"\n  shows \"formulaEntailsClause (formula @ formula') clause\"", "lemma formulaUnsatIffImpliesEmptyClause: \n  fixes formula :: Formula\n  shows \"formulaEntailsClause formula [] = (\\<not> satisfiable formula)\"", "lemma formulaTrueExtendWithEntailedClauses:\n  fixes formula :: Formula and formula0 :: Formula and valuation :: Valuation\n  assumes formulaEntailed: \"\\<forall> (clause::Clause). clause el formula \\<longrightarrow> formulaEntailsClause formula0 clause\" and \"consistent valuation\"\n  shows \"formulaTrue formula0 valuation \\<longrightarrow> formulaTrue formula valuation\"", "lemma formulaEntailsFormulaIffEntailsAllItsClauses: \n  fixes formula :: Formula and formula' :: Formula\n  shows \"formulaEntailsFormula formula formula' = (\\<forall> clause::Clause. clause el formula' \\<longrightarrow> formulaEntailsClause formula clause)\"\n     (is \"?lhs = ?rhs\")", "lemma formulaEntailsFormulaThatEntailsClause: \n  fixes formula1 :: Formula and formula2 :: Formula and clause :: Clause\n  assumes \"formulaEntailsFormula formula1 formula2\" and \"formulaEntailsClause formula2 clause\"\n  shows \"formulaEntailsClause formula1 clause\"", "lemma \n  fixes formula1 :: Formula and formula2 :: Formula and formula1' :: Formula and literal :: Literal\n  assumes \"formulaEntailsLiteral (formula1 @ formula2) literal\" and \"formulaEntailsFormula formula1' formula1\"\n  shows \"formulaEntailsLiteral (formula1' @ formula2) literal\"", "lemma formulaFalseInEntailedValuationIsUnsatisfiable: \n  fixes formula :: Formula and valuation :: Valuation\n  assumes \"formulaFalse formula valuation\" and \n          \"formulaEntailsValuation formula valuation\"\n  shows \"\\<not> satisfiable formula\"", "lemma formulaFalseInEntailedOrPureValuationIsUnsatisfiable: \n  fixes formula :: Formula and valuation :: Valuation\n  assumes \"formulaFalse formula valuation\" and \n  \"\\<forall> literal'. literal' el valuation \\<longrightarrow> formulaEntailsLiteral formula literal' \\<or>  \\<not> opposite literal' el formula\"\n  shows \"\\<not> satisfiable formula\"", "lemma unsatisfiableFormulaWithSingleLiteralClause:\n  fixes formula :: Formula and literal :: Literal\n  assumes \"\\<not> satisfiable formula\" and \"[literal] el formula\"\n  shows \"formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)\"", "lemma unsatisfiableFormulaWithSingleLiteralClauses:\n  fixes F::Formula and c::Clause\n  assumes \"\\<not> satisfiable (F @ val2form (oppositeLiteralList c))\" \"\\<not> clauseTautology c\"\n  shows \"formulaEntailsClause F c\"", "lemma satisfiableEntailedFormula:\n  fixes formula0 :: Formula and formula :: Formula\n  assumes \"formulaEntailsFormula formula0 formula\"\n  shows \"satisfiable formula0 \\<longrightarrow> satisfiable formula\"", "lemma val2formIsEntailed:\nshows \"formulaEntailsValuation (F' @ val2form valuation @ F'') valuation\"", "lemma equivalentFormulaeIffEntailEachOther:\n  fixes formula1 :: Formula and formula2 :: Formula\n  shows \"equivalentFormulae formula1 formula2 = (formulaEntailsFormula formula1 formula2 \\<and> formulaEntailsFormula formula2 formula1)\"", "lemma equivalentFormulaeReflexivity: \n  fixes formula :: Formula\n  shows \"equivalentFormulae formula formula\"", "lemma equivalentFormulaeSymmetry: \n  fixes formula1 :: Formula and formula2 :: Formula\n  shows \"equivalentFormulae formula1 formula2 = equivalentFormulae formula2 formula1\"", "lemma equivalentFormulaeTransitivity: \n  fixes formula1 :: Formula and formula2 :: Formula and formula3 :: Formula\n  assumes \"equivalentFormulae formula1 formula2\" and \"equivalentFormulae formula2 formula3\"\n  shows \"equivalentFormulae formula1 formula3\"", "lemma equivalentFormulaeAppend: \n  fixes formula1 :: Formula and formula1' :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula1 formula1'\"\n  shows \"equivalentFormulae (formula1 @ formula2) (formula1' @ formula2)\"", "lemma satisfiableEquivalent: \n  fixes formula1 :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula1 formula2\"\n  shows \"satisfiable formula1 = satisfiable formula2\"", "lemma satisfiableEquivalentAppend: \n  fixes formula1 :: Formula and formula1' :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula1 formula1'\" and \"satisfiable (formula1 @ formula2)\"\n  shows \"satisfiable (formula1' @ formula2)\"", "lemma replaceEquivalentByEquivalent:\n  fixes formula :: Formula and formula' :: Formula and formula1 :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula formula'\" \n  shows \"equivalentFormulae (formula1 @ formula @ formula2) (formula1 @ formula' @ formula2)\"", "lemma clauseOrderIrrelevant:\n  shows \"equivalentFormulae (F1 @ F @ F' @ F2) (F1 @ F' @ F @ F2)\"", "lemma extendEquivalentFormulaWithEntailedClause:\n  fixes formula1 :: Formula and formula2 :: Formula and clause :: Clause\n  assumes \"equivalentFormulae formula1 formula2\" and \"formulaEntailsClause formula2 clause\"\n  shows \"equivalentFormulae formula1 (formula2 @ [clause])\"", "lemma entailsLiteralRelpacePartWithEquivalent:\n  assumes \"equivalentFormulae F F'\" and \"formulaEntailsLiteral (F1 @ F @ F2) l\"\n  shows \"formulaEntailsLiteral (F1 @ F' @ F2) l\"", "lemma clauseTrueRemoveFalseLiterals:\n  assumes \"consistent v\"\n  shows \"clauseTrue c v = clauseTrue (removeFalseLiterals c v) v\"", "lemma clauseTrueRemoveDuplicateLiterals:\n  shows \"clauseTrue c v = clauseTrue (remdups c) v\"", "lemma removeDuplicateLiteralsEquivalentClause:\n  shows \"equivalentFormulae [remdups clause] [clause]\"", "lemma falseLiteralsCanBeRemoved:\n(* val2form v - some single literal clauses *)\nfixes F::Formula and F'::Formula and v::Valuation\nassumes \"equivalentFormulae (F1 @ val2form v @ F2) F'\"\nshows \"equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) (F' @ [c])\" \n            (is \"equivalentFormulae ?lhs ?rhs\")", "lemma falseAndDuplicateLiteralsCanBeRemoved:\n(* val2form v - some single literal clauses *)\nassumes \"equivalentFormulae (F1 @ val2form v @ F2) F'\"\nshows \"equivalentFormulae (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])\" \n  (is \"equivalentFormulae ?lhs ?rhs\")", "lemma satisfiedClauseCanBeRemoved:\nassumes\n  \"equivalentFormulae (F @ val2form v) F'\"\n  \"clauseTrue c v\"\nshows \"equivalentFormulae (F @ val2form v) (F' @ [c])\"", "lemma formulaEntailsClauseRemoveEntailedLiteralOpposites:\nassumes\n  \"formulaEntailsClause F clause\"\n  \"formulaEntailsValuation F valuation\"\nshows\n  \"formulaEntailsClause F (list_diff clause (oppositeLiteralList valuation))\"", "lemma resolventIsEntailed: \n  fixes clause1 :: Clause and clause2 :: Clause and literal :: Literal\n  shows \"formulaEntailsClause [clause1, clause2] (resolve clause1 clause2 literal)\"", "lemma formulaEntailsResolvent:\n  fixes formula :: Formula and clause1 :: Clause and clause2 :: Clause\n  assumes \"formulaEntailsClause formula clause1\" and \"formulaEntailsClause formula clause2\"\n  shows \"formulaEntailsClause formula (resolve clause1 clause2 literal)\"", "lemma resolveFalseClauses:\n  fixes literal :: Literal and clause1 :: Clause and clause2 :: Clause and valuation :: Valuation\n  assumes \n  \"clauseFalse (removeAll literal clause1) valuation\" and\n  \"clauseFalse (removeAll (opposite literal) clause2) valuation\"\n  shows \"clauseFalse (resolve clause1 clause2 literal) valuation\"", "lemma unitLiteralIsEntailed:\n  fixes uClause :: Clause and uLiteral :: Literal and formula :: Formula and valuation :: Valuation\n  assumes \"isUnitClause uClause uLiteral valuation\" and \"formulaEntailsClause formula uClause\"\n  shows \"formulaEntailsLiteral (formula @ val2form valuation) uLiteral\"", "lemma isUnitClauseRemoveAllUnitLiteralIsFalse: \n  fixes uClause :: Clause and uLiteral :: Literal and valuation :: Valuation\n  assumes \"isUnitClause uClause uLiteral valuation\"\n  shows \"clauseFalse (removeAll uLiteral uClause) valuation\"", "lemma isUnitClauseAppendValuation:\n  assumes \"isUnitClause uClause uLiteral valuation\" \"l \\<noteq> uLiteral\" \"l \\<noteq> opposite uLiteral\"\n  shows \"isUnitClause uClause uLiteral (valuation @ [l])\"", "lemma containsTrueNotUnit:\nassumes\n  \"l el c\" and \"literalTrue l v\" and \"consistent v\"\nshows\n  \"\\<not> (\\<exists> ul. isUnitClause c ul v)\"", "lemma unitBecomesFalse:\nassumes\n  \"isUnitClause uClause uLiteral valuation\" \nshows\n  \"clauseFalse uClause (valuation @ [opposite uLiteral])\"", "lemma isReasonAppend: \n  fixes clause :: Clause and literal :: Literal and valuation :: Valuation and valuation' :: Valuation\n  assumes \"isReason clause literal valuation\" \n  shows \"isReason clause literal (valuation @ valuation')\"", "lemma isUnitClauseIsReason: \n  fixes uClause :: Clause and uLiteral :: Literal and valuation :: Valuation\n  assumes \"isUnitClause uClause uLiteral valuation\" \"uLiteral el valuation'\"\n  shows \"isReason uClause uLiteral (valuation @ valuation')\"", "lemma isReasonHoldsInPrefix: \n  fixes prefix :: Valuation and valuation :: Valuation and clause :: Clause and literal :: Literal\n  assumes \n  \"literal el prefix\" and \n  \"isPrefix prefix valuation\" and \n  \"isReason clause literal valuation\"\n  shows \n  \"isReason clause literal prefix\"", "lemma getLastAssertedLiteralCharacterization:\nassumes\n  \"clauseFalse clause valuation\"\n  \"clause \\<noteq> []\"\n  \"uniq valuation\"\nshows\n  \"isLastAssertedLiteral (getLastAssertedLiteral (oppositeLiteralList clause) valuation) (oppositeLiteralList clause) valuation\"", "lemma lastAssertedLiteralIsUniq: \n  fixes literal :: Literal and literal' :: Literal and literalList :: \"Literal list\" and valuation :: Valuation\n  assumes \n  lastL: \"isLastAssertedLiteral literal  literalList valuation\" and\n  lastL': \"isLastAssertedLiteral literal' literalList valuation\"\n  shows \"literal = literal'\"", "lemma isLastAssertedCharacterization: \n  fixes literal :: Literal and literalList :: \"Literal list\" and v :: Valuation\n  assumes \"isLastAssertedLiteral literal (oppositeLiteralList literalList) valuation\"\n  shows \"opposite literal el literalList\" and \"literalTrue literal valuation\"", "lemma isLastAssertedLiteralSubset:\nassumes\n  \"isLastAssertedLiteral l c M\"\n  \"set c' \\<subseteq> set c\"\n  \"l el c'\"\nshows\n  \"isLastAssertedLiteral l c' M\"", "lemma lastAssertedLastInValuation: \n  fixes literal :: Literal and literalList :: \"Literal list\" and valuation :: Valuation\n  assumes \"literal el literalList\" and \"\\<not> literalTrue literal valuation\" \n  shows \"isLastAssertedLiteral literal literalList (valuation @ [literal])\""], "translations": [["", "lemma literalElFormulaCharacterization:\n  fixes literal :: Literal and formula :: Formula\n  shows \"(literal el formula) = (\\<exists> (clause::Clause). clause el formula \\<and> literal el clause)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal el formula =\n    (\\<exists>clause. clause el formula \\<and> literal el clause)", "by (induct formula) auto"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Variables\\<close>"], ["", "text\\<open>The variable of a given literal\\<close>"], ["", "primrec \nvar      :: \"Literal \\<Rightarrow> Variable\"\nwhere \n  \"var (Pos v) = v\"\n| \"var (Neg v) = v\""], ["", "text\\<open>Set of variables of a given clause, formula or valuation\\<close>"], ["", "primrec\nvarsClause :: \"(Literal list) \\<Rightarrow> (Variable set)\"\nwhere\n  \"varsClause [] = {}\"\n| \"varsClause (literal # list) = {var literal} \\<union> (varsClause list)\""], ["", "primrec\nvarsFormula :: \"Formula \\<Rightarrow> (Variable set)\"\nwhere\n  \"varsFormula [] = {}\"\n| \"varsFormula (clause # formula) = (varsClause clause) \\<union> (varsFormula formula)\""], ["", "consts vars :: \"'a \\<Rightarrow> Variable set\""], ["", "overloading vars_clause \\<equiv> \"vars :: Clause \\<Rightarrow> Variable set\"\nbegin"], ["", "definition [simp]: \"vars (clause::Clause) == varsClause clause\""], ["", "end"], ["", "overloading vars_formula \\<equiv> \"vars :: Formula \\<Rightarrow> Variable set\"\nbegin"], ["", "definition [simp]: \"vars (formula::Formula) == varsFormula formula\""], ["", "end"], ["", "overloading vars_set \\<equiv> \"vars :: Literal set \\<Rightarrow> Variable set\"\nbegin"], ["", "definition [simp]: \"vars (s::Literal set) == {vbl. \\<exists> l. l \\<in> s \\<and> var l = vbl}\""], ["", "end"], ["", "lemma clauseContainsItsLiteralsVariable: \n  fixes literal :: Literal and clause :: Clause\n  assumes \"literal el clause\"\n  shows \"var literal \\<in> vars clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "using assms"], ["proof (prove)\nusing this:\n  literal el clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "by (induct clause) auto"], ["", "lemma formulaContainsItsLiteralsVariable:\n  fixes literal :: Literal and formula::Formula\n  assumes \"literal el formula\" \n  shows \"var literal \\<in> vars formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var literal \\<in> vars formula", "using assms"], ["proof (prove)\nusing this:\n  literal el formula\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars formula", "proof (induct formula)"], ["proof (state)\ngoal (2 subgoals):\n 1. literal el [] \\<Longrightarrow> var literal \\<in> vars []\n 2. \\<And>a formula.\n       \\<lbrakk>literal el formula \\<Longrightarrow>\n                var literal \\<in> vars formula;\n        literal el a # formula\\<rbrakk>\n       \\<Longrightarrow> var literal \\<in> vars (a # formula)", "case Nil"], ["proof (state)\nthis:\n  literal el []\n\ngoal (2 subgoals):\n 1. literal el [] \\<Longrightarrow> var literal \\<in> vars []\n 2. \\<And>a formula.\n       \\<lbrakk>literal el formula \\<Longrightarrow>\n                var literal \\<in> vars formula;\n        literal el a # formula\\<rbrakk>\n       \\<Longrightarrow> var literal \\<in> vars (a # formula)", "thus ?case"], ["proof (prove)\nusing this:\n  literal el []\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars []", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars []\n\ngoal (1 subgoal):\n 1. \\<And>a formula.\n       \\<lbrakk>literal el formula \\<Longrightarrow>\n                var literal \\<in> vars formula;\n        literal el a # formula\\<rbrakk>\n       \\<Longrightarrow> var literal \\<in> vars (a # formula)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a formula.\n       \\<lbrakk>literal el formula \\<Longrightarrow>\n                var literal \\<in> vars formula;\n        literal el a # formula\\<rbrakk>\n       \\<Longrightarrow> var literal \\<in> vars (a # formula)", "case (Cons clause formula)"], ["proof (state)\nthis:\n  literal el formula \\<Longrightarrow> var literal \\<in> vars formula\n  literal el clause # formula\n\ngoal (1 subgoal):\n 1. \\<And>a formula.\n       \\<lbrakk>literal el formula \\<Longrightarrow>\n                var literal \\<in> vars formula;\n        literal el a # formula\\<rbrakk>\n       \\<Longrightarrow> var literal \\<in> vars (a # formula)", "thus ?case"], ["proof (prove)\nusing this:\n  literal el formula \\<Longrightarrow> var literal \\<in> vars formula\n  literal el clause # formula\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars (clause # formula)", "proof (cases \"literal el clause\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)\n 2. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; \\<not> literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)", "case True"], ["proof (state)\nthis:\n  literal el clause\n\ngoal (2 subgoals):\n 1. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)\n 2. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; \\<not> literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)", "with clauseContainsItsLiteralsVariable"], ["proof (chain)\npicking this:\n  ?literal el ?clause \\<Longrightarrow> var ?literal \\<in> vars ?clause\n  literal el clause", "have \"var literal \\<in> vars clause\""], ["proof (prove)\nusing this:\n  ?literal el ?clause \\<Longrightarrow> var ?literal \\<in> vars ?clause\n  literal el clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars clause\n\ngoal (2 subgoals):\n 1. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)\n 2. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; \\<not> literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)", "thus ?thesis"], ["proof (prove)\nusing this:\n  var literal \\<in> vars clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars (clause # formula)", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars (clause # formula)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; \\<not> literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; \\<not> literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)", "case False"], ["proof (state)\nthis:\n  \\<not> literal el clause\n\ngoal (1 subgoal):\n 1. \\<lbrakk>literal el formula \\<Longrightarrow>\n             var literal \\<in> vars formula;\n     literal el clause # formula; \\<not> literal el clause\\<rbrakk>\n    \\<Longrightarrow> var literal \\<in> vars (clause # formula)", "with Cons"], ["proof (chain)\npicking this:\n  literal el formula \\<Longrightarrow> var literal \\<in> vars formula\n  literal el clause # formula\n  \\<not> literal el clause", "show ?thesis"], ["proof (prove)\nusing this:\n  literal el formula \\<Longrightarrow> var literal \\<in> vars formula\n  literal el clause # formula\n  \\<not> literal el clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars (clause # formula)", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars (clause # formula)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var literal \\<in> vars (clause # formula)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaContainsItsClausesVariables:\n  fixes clause :: Clause and formula :: Formula\n  assumes \"clause el formula\"\n  shows \"vars clause \\<subseteq> vars formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars clause \\<subseteq> vars formula", "using assms"], ["proof (prove)\nusing this:\n  clause el formula\n\ngoal (1 subgoal):\n 1. vars clause \\<subseteq> vars formula", "by (induct formula) auto"], ["", "lemma varsAppendFormulae:\n  fixes formula1 :: Formula and formula2 :: Formula\n  shows \"vars (formula1 @ formula2) = vars formula1 \\<union> vars formula2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (formula1 @ formula2) = vars formula1 \\<union> vars formula2", "by (induct formula1) auto"], ["", "lemma varsAppendClauses:\n  fixes clause1 :: Clause and clause2 :: Clause\n  shows \"vars (clause1 @ clause2) = vars clause1 \\<union> vars clause2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (clause1 @ clause2) = vars clause1 \\<union> vars clause2", "by (induct clause1) auto"], ["", "lemma varsRemoveLiteral:\n  fixes literal :: Literal and clause :: Clause\n  shows \"vars (removeAll literal clause) \\<subseteq> vars clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (removeAll literal clause) \\<subseteq> vars clause", "by (induct clause) auto"], ["", "lemma varsRemoveLiteralSuperset:\n  fixes literal :: Literal and clause :: Clause\n  shows \"vars clause - {var literal}  \\<subseteq> vars (removeAll literal clause)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars clause - {var literal} \\<subseteq> vars (removeAll literal clause)", "by (induct clause) auto"], ["", "lemma varsRemoveAllClause:\n  fixes clause :: Clause and formula :: Formula\n  shows \"vars (removeAll clause formula) \\<subseteq> vars formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (removeAll clause formula) \\<subseteq> vars formula", "by (induct formula) auto"], ["", "lemma varsRemoveAllClauseSuperset:\n  fixes clause :: Clause and formula :: Formula\n  shows \"vars formula - vars clause \\<subseteq> vars (removeAll clause formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars formula - vars clause \\<subseteq> vars (removeAll clause formula)", "by (induct formula) auto"], ["", "lemma varInClauseVars:\n  fixes variable :: Variable and clause :: Clause\n  shows \"variable \\<in> vars clause = (\\<exists> literal. literal el clause \\<and> var literal = variable)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (variable \\<in> vars clause) =\n    (\\<exists>literal. literal el clause \\<and> var literal = variable)", "by (induct clause) auto"], ["", "lemma varInFormulaVars: \n  fixes variable :: Variable and formula :: Formula\n  shows \"variable \\<in> vars formula = (\\<exists> literal. literal el formula \\<and> var literal = variable)\" (is \"?lhs formula = ?rhs formula\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (variable \\<in> vars formula) =\n    (\\<exists>literal. literal el formula \\<and> var literal = variable)", "proof (induct formula)"], ["proof (state)\ngoal (2 subgoals):\n 1. (variable \\<in> vars []) =\n    (\\<exists>literal. literal el [] \\<and> var literal = variable)\n 2. \\<And>a formula.\n       (variable \\<in> vars formula) =\n       (\\<exists>literal.\n           literal el formula \\<and>\n           var literal = variable) \\<Longrightarrow>\n       (variable \\<in> vars (a # formula)) =\n       (\\<exists>literal.\n           literal el a # formula \\<and> var literal = variable)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (variable \\<in> vars []) =\n    (\\<exists>literal. literal el [] \\<and> var literal = variable)\n 2. \\<And>a formula.\n       (variable \\<in> vars formula) =\n       (\\<exists>literal.\n           literal el formula \\<and>\n           var literal = variable) \\<Longrightarrow>\n       (variable \\<in> vars (a # formula)) =\n       (\\<exists>literal.\n           literal el a # formula \\<and> var literal = variable)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (variable \\<in> vars []) =\n    (\\<exists>literal. literal el [] \\<and> var literal = variable)", "by simp"], ["proof (state)\nthis:\n  (variable \\<in> vars []) =\n  (\\<exists>literal. literal el [] \\<and> var literal = variable)\n\ngoal (1 subgoal):\n 1. \\<And>a formula.\n       (variable \\<in> vars formula) =\n       (\\<exists>literal.\n           literal el formula \\<and>\n           var literal = variable) \\<Longrightarrow>\n       (variable \\<in> vars (a # formula)) =\n       (\\<exists>literal.\n           literal el a # formula \\<and> var literal = variable)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a formula.\n       (variable \\<in> vars formula) =\n       (\\<exists>literal.\n           literal el formula \\<and>\n           var literal = variable) \\<Longrightarrow>\n       (variable \\<in> vars (a # formula)) =\n       (\\<exists>literal.\n           literal el a # formula \\<and> var literal = variable)", "case (Cons clause formula)"], ["proof (state)\nthis:\n  (variable \\<in> vars formula) =\n  (\\<exists>literal. literal el formula \\<and> var literal = variable)\n\ngoal (1 subgoal):\n 1. \\<And>a formula.\n       (variable \\<in> vars formula) =\n       (\\<exists>literal.\n           literal el formula \\<and>\n           var literal = variable) \\<Longrightarrow>\n       (variable \\<in> vars (a # formula)) =\n       (\\<exists>literal.\n           literal el a # formula \\<and> var literal = variable)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (variable \\<in> vars (clause # formula)) =\n    (\\<exists>literal.\n        literal el clause # formula \\<and> var literal = variable)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. variable \\<in> vars (clause # formula) \\<Longrightarrow>\n    \\<exists>literal.\n       literal el clause # formula \\<and> var literal = variable\n 2. \\<exists>literal.\n       literal el clause # formula \\<and>\n       var literal = variable \\<Longrightarrow>\n    variable \\<in> vars (clause # formula)", "assume P: \"?lhs (clause # formula)\""], ["proof (state)\nthis:\n  variable \\<in> vars (clause # formula)\n\ngoal (2 subgoals):\n 1. variable \\<in> vars (clause # formula) \\<Longrightarrow>\n    \\<exists>literal.\n       literal el clause # formula \\<and> var literal = variable\n 2. \\<exists>literal.\n       literal el clause # formula \\<and>\n       var literal = variable \\<Longrightarrow>\n    variable \\<in> vars (clause # formula)", "thus \"?rhs (clause # formula)\""], ["proof (prove)\nusing this:\n  variable \\<in> vars (clause # formula)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and> var literal = variable", "proof (cases \"variable \\<in> vars clause\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<in> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable\n 2. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<notin> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable", "case True"], ["proof (state)\nthis:\n  variable \\<in> vars clause\n\ngoal (2 subgoals):\n 1. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<in> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable\n 2. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<notin> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable", "with varInClauseVars"], ["proof (chain)\npicking this:\n  (?variable \\<in> vars ?clause) =\n  (\\<exists>literal. literal el ?clause \\<and> var literal = ?variable)\n  variable \\<in> vars clause", "have \"\\<exists> literal. literal el clause \\<and> var literal = variable\""], ["proof (prove)\nusing this:\n  (?variable \\<in> vars ?clause) =\n  (\\<exists>literal. literal el ?clause \\<and> var literal = ?variable)\n  variable \\<in> vars clause\n\ngoal (1 subgoal):\n 1. \\<exists>literal. literal el clause \\<and> var literal = variable", "by simp"], ["proof (state)\nthis:\n  \\<exists>literal. literal el clause \\<and> var literal = variable\n\ngoal (2 subgoals):\n 1. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<in> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable\n 2. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<notin> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>literal. literal el clause \\<and> var literal = variable\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and> var literal = variable", "by auto"], ["proof (state)\nthis:\n  \\<exists>literal.\n     literal el clause # formula \\<and> var literal = variable\n\ngoal (1 subgoal):\n 1. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<notin> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<notin> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable", "case False"], ["proof (state)\nthis:\n  variable \\<notin> vars clause\n\ngoal (1 subgoal):\n 1. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<notin> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable", "with P"], ["proof (chain)\npicking this:\n  variable \\<in> vars (clause # formula)\n  variable \\<notin> vars clause", "have \"variable \\<in> vars formula\""], ["proof (prove)\nusing this:\n  variable \\<in> vars (clause # formula)\n  variable \\<notin> vars clause\n\ngoal (1 subgoal):\n 1. variable \\<in> vars formula", "by simp"], ["proof (state)\nthis:\n  variable \\<in> vars formula\n\ngoal (1 subgoal):\n 1. \\<lbrakk>variable \\<in> vars (clause # formula);\n     variable \\<notin> vars clause\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literal el clause # formula \\<and>\n                         var literal = variable", "with Cons"], ["proof (chain)\npicking this:\n  (variable \\<in> vars formula) =\n  (\\<exists>literal. literal el formula \\<and> var literal = variable)\n  variable \\<in> vars formula", "show ?thesis"], ["proof (prove)\nusing this:\n  (variable \\<in> vars formula) =\n  (\\<exists>literal. literal el formula \\<and> var literal = variable)\n  variable \\<in> vars formula\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and> var literal = variable", "by auto"], ["proof (state)\nthis:\n  \\<exists>literal.\n     literal el clause # formula \\<and> var literal = variable\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>literal.\n     literal el clause # formula \\<and> var literal = variable\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and>\n       var literal = variable \\<Longrightarrow>\n    variable \\<in> vars (clause # formula)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and>\n       var literal = variable \\<Longrightarrow>\n    variable \\<in> vars (clause # formula)", "assume \"?rhs (clause # formula)\""], ["proof (state)\nthis:\n  \\<exists>literal.\n     literal el clause # formula \\<and> var literal = variable\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and>\n       var literal = variable \\<Longrightarrow>\n    variable \\<in> vars (clause # formula)", "then"], ["proof (chain)\npicking this:\n  \\<exists>literal.\n     literal el clause # formula \\<and> var literal = variable", "obtain l \n      where lEl: \"l el clause # formula\" and varL:\"var l = variable\""], ["proof (prove)\nusing this:\n  \\<exists>literal.\n     literal el clause # formula \\<and> var literal = variable\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el clause # formula; var l = variable\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l el clause # formula\n  var l = variable\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and>\n       var literal = variable \\<Longrightarrow>\n    variable \\<in> vars (clause # formula)", "from lEl formulaContainsItsLiteralsVariable [of \"l\" \"clause # formula\"]"], ["proof (chain)\npicking this:\n  l el clause # formula\n  l el clause # formula \\<Longrightarrow>\n  var l \\<in> vars (clause # formula)", "have \"var l \\<in> vars (clause # formula)\""], ["proof (prove)\nusing this:\n  l el clause # formula\n  l el clause # formula \\<Longrightarrow>\n  var l \\<in> vars (clause # formula)\n\ngoal (1 subgoal):\n 1. var l \\<in> vars (clause # formula)", "by auto"], ["proof (state)\nthis:\n  var l \\<in> vars (clause # formula)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literal el clause # formula \\<and>\n       var literal = variable \\<Longrightarrow>\n    variable \\<in> vars (clause # formula)", "with varL"], ["proof (chain)\npicking this:\n  var l = variable\n  var l \\<in> vars (clause # formula)", "show \"?lhs (clause # formula)\""], ["proof (prove)\nusing this:\n  var l = variable\n  var l \\<in> vars (clause # formula)\n\ngoal (1 subgoal):\n 1. variable \\<in> vars (clause # formula)", "by simp"], ["proof (state)\nthis:\n  variable \\<in> vars (clause # formula)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (variable \\<in> vars (clause # formula)) =\n  (\\<exists>literal.\n      literal el clause # formula \\<and> var literal = variable)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma varsSubsetFormula:\n  fixes F :: Formula and F' :: Formula\n  assumes \"\\<forall> c::Clause. c el F \\<longrightarrow> c el F'\"\n  shows \"vars F \\<subseteq> vars F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars F \\<subseteq> vars F'", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>c. c el F \\<longrightarrow> c el F'\n\ngoal (1 subgoal):\n 1. vars F \\<subseteq> vars F'", "proof (induct F)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c. c el [] \\<longrightarrow> c el F' \\<Longrightarrow>\n    vars [] \\<subseteq> vars F'\n 2. \\<And>a F.\n       \\<lbrakk>\\<forall>c.\n                   c el F \\<longrightarrow> c el F' \\<Longrightarrow>\n                vars F \\<subseteq> vars F';\n        \\<forall>c. c el a # F \\<longrightarrow> c el F'\\<rbrakk>\n       \\<Longrightarrow> vars (a # F) \\<subseteq> vars F'", "case Nil"], ["proof (state)\nthis:\n  \\<forall>c. c el [] \\<longrightarrow> c el F'\n\ngoal (2 subgoals):\n 1. \\<forall>c. c el [] \\<longrightarrow> c el F' \\<Longrightarrow>\n    vars [] \\<subseteq> vars F'\n 2. \\<And>a F.\n       \\<lbrakk>\\<forall>c.\n                   c el F \\<longrightarrow> c el F' \\<Longrightarrow>\n                vars F \\<subseteq> vars F';\n        \\<forall>c. c el a # F \\<longrightarrow> c el F'\\<rbrakk>\n       \\<Longrightarrow> vars (a # F) \\<subseteq> vars F'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>c. c el [] \\<longrightarrow> c el F'\n\ngoal (1 subgoal):\n 1. vars [] \\<subseteq> vars F'", "by simp"], ["proof (state)\nthis:\n  vars [] \\<subseteq> vars F'\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<forall>c.\n                   c el F \\<longrightarrow> c el F' \\<Longrightarrow>\n                vars F \\<subseteq> vars F';\n        \\<forall>c. c el a # F \\<longrightarrow> c el F'\\<rbrakk>\n       \\<Longrightarrow> vars (a # F) \\<subseteq> vars F'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<forall>c.\n                   c el F \\<longrightarrow> c el F' \\<Longrightarrow>\n                vars F \\<subseteq> vars F';\n        \\<forall>c. c el a # F \\<longrightarrow> c el F'\\<rbrakk>\n       \\<Longrightarrow> vars (a # F) \\<subseteq> vars F'", "case (Cons c' F'')"], ["proof (state)\nthis:\n  \\<forall>c. c el F'' \\<longrightarrow> c el F' \\<Longrightarrow>\n  vars F'' \\<subseteq> vars F'\n  \\<forall>c. c el c' # F'' \\<longrightarrow> c el F'\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<forall>c.\n                   c el F \\<longrightarrow> c el F' \\<Longrightarrow>\n                vars F \\<subseteq> vars F';\n        \\<forall>c. c el a # F \\<longrightarrow> c el F'\\<rbrakk>\n       \\<Longrightarrow> vars (a # F) \\<subseteq> vars F'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>c. c el F'' \\<longrightarrow> c el F' \\<Longrightarrow>\n  vars F'' \\<subseteq> vars F'\n  \\<forall>c. c el c' # F'' \\<longrightarrow> c el F'\n\ngoal (1 subgoal):\n 1. vars (c' # F'') \\<subseteq> vars F'", "using formulaContainsItsClausesVariables[of \"c'\" \"F'\"]"], ["proof (prove)\nusing this:\n  \\<forall>c. c el F'' \\<longrightarrow> c el F' \\<Longrightarrow>\n  vars F'' \\<subseteq> vars F'\n  \\<forall>c. c el c' # F'' \\<longrightarrow> c el F'\n  c' el F' \\<Longrightarrow> vars c' \\<subseteq> vars F'\n\ngoal (1 subgoal):\n 1. vars (c' # F'') \\<subseteq> vars F'", "by simp"], ["proof (state)\nthis:\n  vars (c' # F'') \\<subseteq> vars F'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma varsClauseVarsSet:\nfixes \n  clause :: Clause\nshows\n  \"vars clause = vars (set clause)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars clause = vars (set clause)", "by (induct clause) auto"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Opposite literals\\<close>"], ["", "primrec\nopposite :: \"Literal \\<Rightarrow> Literal\"\nwhere\n  \"opposite (Pos v) = (Neg v)\"\n| \"opposite (Neg v) = (Pos v)\""], ["", "lemma oppositeIdempotency [simp]:\n  fixes literal::Literal\n  shows \"opposite (opposite literal) = literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opposite (opposite literal) = literal", "by (induct literal) auto"], ["", "lemma oppositeSymmetry [simp]:\n  fixes literal1::Literal and literal2::Literal\n  shows \"(opposite literal1 = literal2) = (opposite literal2 = literal1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (opposite literal1 = literal2) = (opposite literal2 = literal1)", "by auto"], ["", "lemma oppositeUniqueness [simp]:\n  fixes literal1::Literal and literal2::Literal\n  shows \"(opposite literal1 = opposite literal2) = (literal1 = literal2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (opposite literal1 = opposite literal2) = (literal1 = literal2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. opposite literal1 = opposite literal2 \\<Longrightarrow>\n    literal1 = literal2\n 2. literal1 = literal2 \\<Longrightarrow>\n    opposite literal1 = opposite literal2", "assume \"opposite literal1 = opposite literal2\""], ["proof (state)\nthis:\n  opposite literal1 = opposite literal2\n\ngoal (2 subgoals):\n 1. opposite literal1 = opposite literal2 \\<Longrightarrow>\n    literal1 = literal2\n 2. literal1 = literal2 \\<Longrightarrow>\n    opposite literal1 = opposite literal2", "hence \"opposite (opposite literal1) = opposite (opposite literal2)\""], ["proof (prove)\nusing this:\n  opposite literal1 = opposite literal2\n\ngoal (1 subgoal):\n 1. opposite (opposite literal1) = opposite (opposite literal2)", "by simp"], ["proof (state)\nthis:\n  opposite (opposite literal1) = opposite (opposite literal2)\n\ngoal (2 subgoals):\n 1. opposite literal1 = opposite literal2 \\<Longrightarrow>\n    literal1 = literal2\n 2. literal1 = literal2 \\<Longrightarrow>\n    opposite literal1 = opposite literal2", "thus \"literal1 = literal2\""], ["proof (prove)\nusing this:\n  opposite (opposite literal1) = opposite (opposite literal2)\n\ngoal (1 subgoal):\n 1. literal1 = literal2", "by simp"], ["proof (state)\nthis:\n  literal1 = literal2\n\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<Longrightarrow>\n    opposite literal1 = opposite literal2", "qed simp"], ["", "lemma oppositeIsDifferentFromLiteral [simp]:\n  fixes literal::Literal\n  shows \"opposite literal \\<noteq> literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opposite literal \\<noteq> literal", "by (induct literal) auto"], ["", "lemma oppositeLiteralsHaveSameVariable [simp]:\n  fixes literal::Literal\n  shows \"var (opposite literal) = var literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var (opposite literal) = var literal", "by (induct literal) auto"], ["", "lemma literalsWithSameVariableAreEqualOrOpposite:\n  fixes literal1::Literal and literal2::Literal\n  shows \"(var literal1 = var literal2) = (literal1 = literal2 \\<or> opposite literal1 = literal2)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (var literal1 = var literal2) =\n    (literal1 = literal2 \\<or> opposite literal1 = literal2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. var literal1 = var literal2 \\<Longrightarrow>\n    literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. literal1 = literal2 \\<or> opposite literal1 = literal2 \\<Longrightarrow>\n    var literal1 = var literal2", "assume ?lhs"], ["proof (state)\nthis:\n  var literal1 = var literal2\n\ngoal (2 subgoals):\n 1. var literal1 = var literal2 \\<Longrightarrow>\n    literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. literal1 = literal2 \\<or> opposite literal1 = literal2 \\<Longrightarrow>\n    var literal1 = var literal2", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2", "proof (cases literal1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       literal1 = Pos x1 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. \\<And>x2.\n       literal1 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "case \"Pos\""], ["proof (state)\nthis:\n  literal1 = Pos x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       literal1 = Pos x1 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. \\<And>x2.\n       literal1 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "note Pos1 = this"], ["proof (state)\nthis:\n  literal1 = Pos x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       literal1 = Pos x1 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. \\<And>x2.\n       literal1 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2", "proof (cases literal2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       literal2 = Pos x1 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "case \"Pos\""], ["proof (state)\nthis:\n  literal2 = Pos x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       literal2 = Pos x1 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "with \\<open>?lhs\\<close> Pos1"], ["proof (chain)\npicking this:\n  var literal1 = var literal2\n  literal1 = Pos x1___\n  literal2 = Pos x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  var literal1 = var literal2\n  literal1 = Pos x1___\n  literal2 = Pos x1_\n\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2", "by simp"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "case \"Neg\""], ["proof (state)\nthis:\n  literal2 = Neg x2_\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "with \\<open>?lhs\\<close> Pos1"], ["proof (chain)\npicking this:\n  var literal1 = var literal2\n  literal1 = Pos x1_\n  literal2 = Neg x2_", "show ?thesis"], ["proof (prove)\nusing this:\n  var literal1 = var literal2\n  literal1 = Pos x1_\n  literal2 = Neg x2_\n\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2", "by simp"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal1 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal1 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "case \"Neg\""], ["proof (state)\nthis:\n  literal1 = Neg x2_\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal1 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "note Neg1 = this"], ["proof (state)\nthis:\n  literal1 = Neg x2_\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal1 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2", "proof (cases literal2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       literal2 = Pos x1 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "case \"Pos\""], ["proof (state)\nthis:\n  literal2 = Pos x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       literal2 = Pos x1 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2\n 2. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "with \\<open>?lhs\\<close> Neg1"], ["proof (chain)\npicking this:\n  var literal1 = var literal2\n  literal1 = Neg x2_\n  literal2 = Pos x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  var literal1 = var literal2\n  literal1 = Neg x2_\n  literal2 = Pos x1_\n\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2", "by simp"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "case \"Neg\""], ["proof (state)\nthis:\n  literal2 = Neg x2_\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       literal2 = Neg x2 \\<Longrightarrow>\n       literal1 = literal2 \\<or> opposite literal1 = literal2", "with \\<open>?lhs\\<close> Neg1"], ["proof (chain)\npicking this:\n  var literal1 = var literal2\n  literal1 = Neg x2___\n  literal2 = Neg x2_", "show ?thesis"], ["proof (prove)\nusing this:\n  var literal1 = var literal2\n  literal1 = Neg x2___\n  literal2 = Neg x2_\n\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2", "by simp"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2 \\<Longrightarrow>\n    var literal1 = var literal2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2 \\<Longrightarrow>\n    var literal1 = var literal2", "assume ?rhs"], ["proof (state)\nthis:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal (1 subgoal):\n 1. literal1 = literal2 \\<or> opposite literal1 = literal2 \\<Longrightarrow>\n    var literal1 = var literal2", "thus ?lhs"], ["proof (prove)\nusing this:\n  literal1 = literal2 \\<or> opposite literal1 = literal2\n\ngoal (1 subgoal):\n 1. var literal1 = var literal2", "by auto"], ["proof (state)\nthis:\n  var literal1 = var literal2\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The list of literals obtained by negating all literals of a\nliteral list (clause, valuation). Notice that this is not a negation \nof a clause, because the negation of a clause is a conjunction and \nnot a disjunction.\\<close>"], ["", "definition\noppositeLiteralList :: \"Literal list \\<Rightarrow> Literal list\"\nwhere\n\"oppositeLiteralList clause == map opposite clause\""], ["", "lemma literalElListIffOppositeLiteralElOppositeLiteralList: \n  fixes literal :: Literal and literalList :: \"Literal list\"\n  shows \"literal el literalList = (opposite literal) el (oppositeLiteralList literalList)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal el literalList =\n    opposite literal el oppositeLiteralList literalList", "unfolding oppositeLiteralList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. literal el literalList = opposite literal el map opposite literalList", "proof (induct literalList)"], ["proof (state)\ngoal (2 subgoals):\n 1. literal el [] = opposite literal el map opposite []\n 2. \\<And>a literalList.\n       literal el literalList =\n       opposite literal el map opposite literalList \\<Longrightarrow>\n       literal el a # literalList =\n       opposite literal el map opposite (a # literalList)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. literal el [] = opposite literal el map opposite []\n 2. \\<And>a literalList.\n       literal el literalList =\n       opposite literal el map opposite literalList \\<Longrightarrow>\n       literal el a # literalList =\n       opposite literal el map opposite (a # literalList)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. literal el [] = opposite literal el map opposite []", "by simp"], ["proof (state)\nthis:\n  literal el [] = opposite literal el map opposite []\n\ngoal (1 subgoal):\n 1. \\<And>a literalList.\n       literal el literalList =\n       opposite literal el map opposite literalList \\<Longrightarrow>\n       literal el a # literalList =\n       opposite literal el map opposite (a # literalList)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a literalList.\n       literal el literalList =\n       opposite literal el map opposite literalList \\<Longrightarrow>\n       literal el a # literalList =\n       opposite literal el map opposite (a # literalList)", "case (Cons l literalLlist')"], ["proof (state)\nthis:\n  literal el literalLlist' = opposite literal el map opposite literalLlist'\n\ngoal (1 subgoal):\n 1. \\<And>a literalList.\n       literal el literalList =\n       opposite literal el map opposite literalList \\<Longrightarrow>\n       literal el a # literalList =\n       opposite literal el map opposite (a # literalList)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "proof (cases \"l = literal\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = literal \\<Longrightarrow>\n    literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')\n 2. l \\<noteq> literal \\<Longrightarrow>\n    literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "case True"], ["proof (state)\nthis:\n  l = literal\n\ngoal (2 subgoals):\n 1. l = literal \\<Longrightarrow>\n    literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')\n 2. l \\<noteq> literal \\<Longrightarrow>\n    literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = literal\n\ngoal (1 subgoal):\n 1. literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "by simp"], ["proof (state)\nthis:\n  literal el l # literalLlist' =\n  opposite literal el map opposite (l # literalLlist')\n\ngoal (1 subgoal):\n 1. l \\<noteq> literal \\<Longrightarrow>\n    literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> literal \\<Longrightarrow>\n    literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "case False"], ["proof (state)\nthis:\n  l \\<noteq> literal\n\ngoal (1 subgoal):\n 1. l \\<noteq> literal \\<Longrightarrow>\n    literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "thus ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> literal\n\ngoal (1 subgoal):\n 1. literal el l # literalLlist' =\n    opposite literal el map opposite (l # literalLlist')", "by auto"], ["proof (state)\nthis:\n  literal el l # literalLlist' =\n  opposite literal el map opposite (l # literalLlist')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literal el l # literalLlist' =\n  opposite literal el map opposite (l # literalLlist')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oppositeLiteralListIdempotency [simp]: \n  fixes literalList :: \"Literal list\"\n  shows \"oppositeLiteralList (oppositeLiteralList literalList) = literalList\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oppositeLiteralList (oppositeLiteralList literalList) = literalList", "unfolding oppositeLiteralList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map opposite (map opposite literalList) = literalList", "by (induct literalList) auto"], ["", "lemma oppositeLiteralListRemove: \n  fixes literal :: Literal and literalList :: \"Literal list\"\n  shows \"oppositeLiteralList (removeAll literal literalList) = removeAll (opposite literal) (oppositeLiteralList literalList)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oppositeLiteralList (removeAll literal literalList) =\n    removeAll (opposite literal) (oppositeLiteralList literalList)", "unfolding oppositeLiteralList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map opposite (removeAll literal literalList) =\n    removeAll (opposite literal) (map opposite literalList)", "by (induct literalList) auto"], ["", "lemma oppositeLiteralListNonempty:\n  fixes literalList :: \"Literal list\"\n  shows \"(literalList \\<noteq> []) = ((oppositeLiteralList literalList) \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (literalList \\<noteq> []) =\n    (oppositeLiteralList literalList \\<noteq> [])", "unfolding oppositeLiteralList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (literalList \\<noteq> []) = (map opposite literalList \\<noteq> [])", "by (induct literalList) auto"], ["", "lemma varsOppositeLiteralList:\nshows \"vars (oppositeLiteralList clause) = vars clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (oppositeLiteralList clause) = vars clause", "unfolding oppositeLiteralList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (map opposite clause) = vars clause", "by (induct clause) auto"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Tautological clauses\\<close>"], ["", "text\\<open>Check if the clause contains both a literal and its opposite\\<close>"], ["", "primrec\nclauseTautology :: \"Clause \\<Rightarrow> bool\"\nwhere\n  \"clauseTautology [] = False\"\n| \"clauseTautology (literal # clause) = (opposite literal el clause \\<or> clauseTautology clause)\""], ["", "lemma clauseTautologyCharacterization: \n  fixes clause :: Clause\n  shows \"clauseTautology clause = (\\<exists> literal. literal el clause \\<and> (opposite literal) el clause)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTautology clause =\n    (\\<exists>literal. literal el clause \\<and> opposite literal el clause)", "by (induct clause) auto"], ["", "(********************************************************************)"], ["", "subsection\\<open>Semantics\\<close>"], ["", "(********************************************************************)\n\n(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Valuations\\<close>"], ["", "type_synonym Valuation = \"Literal list\""], ["", "lemma valuationContainsItsLiteralsVariable: \n  fixes literal :: Literal and valuation :: Valuation\n  assumes \"literal el valuation\"\n  shows \"var literal \\<in> vars valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "using assms"], ["proof (prove)\nusing this:\n  literal el valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "by (induct valuation) auto"], ["", "lemma varsSubsetValuation: \n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  assumes \"set valuation1  \\<subseteq> set valuation2\"\n  shows \"vars valuation1 \\<subseteq> vars valuation2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars valuation1 \\<subseteq> vars valuation2", "using assms"], ["proof (prove)\nusing this:\n  set valuation1 \\<subseteq> set valuation2\n\ngoal (1 subgoal):\n 1. vars valuation1 \\<subseteq> vars valuation2", "proof (induct valuation1)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set valuation2 \\<Longrightarrow>\n    vars [] \\<subseteq> vars valuation2\n 2. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> set valuation2\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set valuation2 \\<Longrightarrow>\n    vars [] \\<subseteq> vars valuation2\n 2. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars [] \\<subseteq> vars valuation2", "by simp"], ["proof (state)\nthis:\n  vars [] \\<subseteq> vars valuation2\n\ngoal (1 subgoal):\n 1. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "case (Cons literal valuation)"], ["proof (state)\nthis:\n  set valuation \\<subseteq> set valuation2 \\<Longrightarrow>\n  vars valuation \\<subseteq> vars valuation2\n  set (literal # valuation) \\<subseteq> set valuation2\n\ngoal (1 subgoal):\n 1. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "note caseCons = this"], ["proof (state)\nthis:\n  set valuation \\<subseteq> set valuation2 \\<Longrightarrow>\n  vars valuation \\<subseteq> vars valuation2\n  set (literal # valuation) \\<subseteq> set valuation2\n\ngoal (1 subgoal):\n 1. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "hence \"literal el valuation2\""], ["proof (prove)\nusing this:\n  set valuation \\<subseteq> set valuation2 \\<Longrightarrow>\n  vars valuation \\<subseteq> vars valuation2\n  set (literal # valuation) \\<subseteq> set valuation2\n\ngoal (1 subgoal):\n 1. literal el valuation2", "by auto"], ["proof (state)\nthis:\n  literal el valuation2\n\ngoal (1 subgoal):\n 1. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "with valuationContainsItsLiteralsVariable [of \"literal\" \"valuation2\"]"], ["proof (chain)\npicking this:\n  literal el valuation2 \\<Longrightarrow> var literal \\<in> vars valuation2\n  literal el valuation2", "have \"var literal \\<in> vars valuation2\""], ["proof (prove)\nusing this:\n  literal el valuation2 \\<Longrightarrow> var literal \\<in> vars valuation2\n  literal el valuation2\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation2", "."], ["proof (state)\nthis:\n  var literal \\<in> vars valuation2\n\ngoal (1 subgoal):\n 1. \\<And>a valuation1.\n       \\<lbrakk>set valuation1 \\<subseteq> set valuation2 \\<Longrightarrow>\n                vars valuation1 \\<subseteq> vars valuation2;\n        set (a # valuation1) \\<subseteq> set valuation2\\<rbrakk>\n       \\<Longrightarrow> vars (a # valuation1) \\<subseteq> vars valuation2", "with caseCons"], ["proof (chain)\npicking this:\n  set valuation \\<subseteq> set valuation2 \\<Longrightarrow>\n  vars valuation \\<subseteq> vars valuation2\n  set (literal # valuation) \\<subseteq> set valuation2\n  var literal \\<in> vars valuation2", "show ?case"], ["proof (prove)\nusing this:\n  set valuation \\<subseteq> set valuation2 \\<Longrightarrow>\n  vars valuation \\<subseteq> vars valuation2\n  set (literal # valuation) \\<subseteq> set valuation2\n  var literal \\<in> vars valuation2\n\ngoal (1 subgoal):\n 1. vars (literal # valuation) \\<subseteq> vars valuation2", "by simp"], ["proof (state)\nthis:\n  vars (literal # valuation) \\<subseteq> vars valuation2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma varsAppendValuation:\n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  shows \"vars (valuation1 @ valuation2) = vars valuation1 \\<union> vars valuation2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (valuation1 @ valuation2) =\n    vars valuation1 \\<union> vars valuation2", "by (induct valuation1) auto"], ["", "lemma varsPrefixValuation:\n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  assumes \"isPrefix valuation1 valuation2\"\n  shows \"vars valuation1 \\<subseteq> vars valuation2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars valuation1 \\<subseteq> vars valuation2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. vars valuation1 \\<subseteq> vars valuation2", "from assms"], ["proof (chain)\npicking this:\n  isPrefix valuation1 valuation2", "have \"set valuation1 \\<subseteq> set valuation2\""], ["proof (prove)\nusing this:\n  isPrefix valuation1 valuation2\n\ngoal (1 subgoal):\n 1. set valuation1 \\<subseteq> set valuation2", "by (auto simp add:isPrefix_def)"], ["proof (state)\nthis:\n  set valuation1 \\<subseteq> set valuation2\n\ngoal (1 subgoal):\n 1. vars valuation1 \\<subseteq> vars valuation2", "thus ?thesis"], ["proof (prove)\nusing this:\n  set valuation1 \\<subseteq> set valuation2\n\ngoal (1 subgoal):\n 1. vars valuation1 \\<subseteq> vars valuation2", "by (rule varsSubsetValuation)"], ["proof (state)\nthis:\n  vars valuation1 \\<subseteq> vars valuation2\n\ngoal:\nNo subgoals!", "qed"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>True/False literals\\<close>"], ["", "text\\<open>Check if the literal is contained in the given valuation\\<close>"], ["", "definition literalTrue     :: \"Literal \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\nliteralTrue_def [simp]: \"literalTrue literal valuation == literal el valuation\""], ["", "text\\<open>Check if the opposite literal is contained in the given valuation\\<close>"], ["", "definition literalFalse    :: \"Literal \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\nliteralFalse_def [simp]: \"literalFalse literal valuation == opposite literal el valuation\""], ["", "lemma variableDefinedImpliesLiteralDefined:\n  fixes literal :: Literal and valuation :: Valuation\n  shows \"var literal \\<in> vars valuation = (literalTrue literal valuation \\<or> literalFalse literal valuation)\" \n    (is \"(?lhs valuation) = (?rhs valuation)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (var literal \\<in> vars valuation) =\n    (literalTrue literal valuation \\<or> literalFalse literal valuation)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. var literal \\<in> vars valuation \\<Longrightarrow>\n    literalTrue literal valuation \\<or> literalFalse literal valuation\n 2. literalTrue literal valuation \\<or>\n    literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "assume \"?rhs valuation\""], ["proof (state)\nthis:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n\ngoal (2 subgoals):\n 1. var literal \\<in> vars valuation \\<Longrightarrow>\n    literalTrue literal valuation \\<or> literalFalse literal valuation\n 2. literalTrue literal valuation \\<or>\n    literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "thus \"?lhs valuation\""], ["proof (prove)\nusing this:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. literalTrue literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation\n 2. literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "assume \"literalTrue literal valuation\""], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (2 subgoals):\n 1. literalTrue literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation\n 2. literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "hence \"literal el valuation\""], ["proof (prove)\nusing this:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. literal el valuation", "by simp"], ["proof (state)\nthis:\n  literal el valuation\n\ngoal (2 subgoals):\n 1. literalTrue literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation\n 2. literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  literal el valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "using valuationContainsItsLiteralsVariable[of \"literal\" \"valuation\"]"], ["proof (prove)\nusing this:\n  literal el valuation\n  literal el valuation \\<Longrightarrow> var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "assume \"literalFalse literal valuation\""], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "hence \"opposite literal el valuation\""], ["proof (prove)\nusing this:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. opposite literal el valuation", "by simp"], ["proof (state)\nthis:\n  opposite literal el valuation\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation \\<Longrightarrow>\n    var literal \\<in> vars valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  opposite literal el valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "using valuationContainsItsLiteralsVariable[of \"opposite literal\" \"valuation\"]"], ["proof (prove)\nusing this:\n  opposite literal el valuation\n  opposite literal el valuation \\<Longrightarrow>\n  var (opposite literal) \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation \\<Longrightarrow>\n    literalTrue literal valuation \\<or> literalFalse literal valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation \\<Longrightarrow>\n    literalTrue literal valuation \\<or> literalFalse literal valuation", "assume \"?lhs valuation\""], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation \\<Longrightarrow>\n    literalTrue literal valuation \\<or> literalFalse literal valuation", "thus \"?rhs valuation\""], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "proof (induct valuation)"], ["proof (state)\ngoal (2 subgoals):\n 1. var literal \\<in> vars [] \\<Longrightarrow>\n    literalTrue literal [] \\<or> literalFalse literal []\n 2. \\<And>a valuation.\n       \\<lbrakk>var literal \\<in> vars valuation \\<Longrightarrow>\n                literalTrue literal valuation \\<or>\n                literalFalse literal valuation;\n        var literal \\<in> vars (a # valuation)\\<rbrakk>\n       \\<Longrightarrow> literalTrue literal (a # valuation) \\<or>\n                         literalFalse literal (a # valuation)", "case Nil"], ["proof (state)\nthis:\n  var literal \\<in> vars []\n\ngoal (2 subgoals):\n 1. var literal \\<in> vars [] \\<Longrightarrow>\n    literalTrue literal [] \\<or> literalFalse literal []\n 2. \\<And>a valuation.\n       \\<lbrakk>var literal \\<in> vars valuation \\<Longrightarrow>\n                literalTrue literal valuation \\<or>\n                literalFalse literal valuation;\n        var literal \\<in> vars (a # valuation)\\<rbrakk>\n       \\<Longrightarrow> literalTrue literal (a # valuation) \\<or>\n                         literalFalse literal (a # valuation)", "thus ?case"], ["proof (prove)\nusing this:\n  var literal \\<in> vars []\n\ngoal (1 subgoal):\n 1. literalTrue literal [] \\<or> literalFalse literal []", "by simp"], ["proof (state)\nthis:\n  literalTrue literal [] \\<or> literalFalse literal []\n\ngoal (1 subgoal):\n 1. \\<And>a valuation.\n       \\<lbrakk>var literal \\<in> vars valuation \\<Longrightarrow>\n                literalTrue literal valuation \\<or>\n                literalFalse literal valuation;\n        var literal \\<in> vars (a # valuation)\\<rbrakk>\n       \\<Longrightarrow> literalTrue literal (a # valuation) \\<or>\n                         literalFalse literal (a # valuation)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a valuation.\n       \\<lbrakk>var literal \\<in> vars valuation \\<Longrightarrow>\n                literalTrue literal valuation \\<or>\n                literalFalse literal valuation;\n        var literal \\<in> vars (a # valuation)\\<rbrakk>\n       \\<Longrightarrow> literalTrue literal (a # valuation) \\<or>\n                         literalFalse literal (a # valuation)", "case (Cons literal' valuation')"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation' \\<Longrightarrow>\n  literalTrue literal valuation' \\<or> literalFalse literal valuation'\n  var literal \\<in> vars (literal' # valuation')\n\ngoal (1 subgoal):\n 1. \\<And>a valuation.\n       \\<lbrakk>var literal \\<in> vars valuation \\<Longrightarrow>\n                literalTrue literal valuation \\<or>\n                literalFalse literal valuation;\n        var literal \\<in> vars (a # valuation)\\<rbrakk>\n       \\<Longrightarrow> literalTrue literal (a # valuation) \\<or>\n                         literalFalse literal (a # valuation)", "note ih=this"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation' \\<Longrightarrow>\n  literalTrue literal valuation' \\<or> literalFalse literal valuation'\n  var literal \\<in> vars (literal' # valuation')\n\ngoal (1 subgoal):\n 1. \\<And>a valuation.\n       \\<lbrakk>var literal \\<in> vars valuation \\<Longrightarrow>\n                literalTrue literal valuation \\<or>\n                literalFalse literal valuation;\n        var literal \\<in> vars (a # valuation)\\<rbrakk>\n       \\<Longrightarrow> literalTrue literal (a # valuation) \\<or>\n                         literalFalse literal (a # valuation)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "proof (cases \"var literal \\<in> vars valuation'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. var literal \\<in> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')\n 2. var literal \\<notin> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "case True"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation'\n\ngoal (2 subgoals):\n 1. var literal \\<in> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')\n 2. var literal \\<notin> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "with ih"], ["proof (chain)\npicking this:\n  var literal \\<in> vars valuation' \\<Longrightarrow>\n  literalTrue literal valuation' \\<or> literalFalse literal valuation'\n  var literal \\<in> vars (literal' # valuation')\n  var literal \\<in> vars valuation'", "show \"?rhs (literal' # valuation')\""], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation' \\<Longrightarrow>\n  literalTrue literal valuation' \\<or> literalFalse literal valuation'\n  var literal \\<in> vars (literal' # valuation')\n  var literal \\<in> vars valuation'\n\ngoal (1 subgoal):\n 1. literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "by auto"], ["proof (state)\nthis:\n  literalTrue literal (literal' # valuation') \\<or>\n  literalFalse literal (literal' # valuation')\n\ngoal (1 subgoal):\n 1. var literal \\<notin> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. var literal \\<notin> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "case False"], ["proof (state)\nthis:\n  var literal \\<notin> vars valuation'\n\ngoal (1 subgoal):\n 1. var literal \\<notin> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "with ih"], ["proof (chain)\npicking this:\n  var literal \\<in> vars valuation' \\<Longrightarrow>\n  literalTrue literal valuation' \\<or> literalFalse literal valuation'\n  var literal \\<in> vars (literal' # valuation')\n  var literal \\<notin> vars valuation'", "have \"var literal' = var literal\""], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation' \\<Longrightarrow>\n  literalTrue literal valuation' \\<or> literalFalse literal valuation'\n  var literal \\<in> vars (literal' # valuation')\n  var literal \\<notin> vars valuation'\n\ngoal (1 subgoal):\n 1. var literal' = var literal", "by simp"], ["proof (state)\nthis:\n  var literal' = var literal\n\ngoal (1 subgoal):\n 1. var literal \\<notin> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "hence \"literal' = literal \\<or> opposite literal' = literal\""], ["proof (prove)\nusing this:\n  var literal' = var literal\n\ngoal (1 subgoal):\n 1. literal' = literal \\<or> opposite literal' = literal", "by (simp add:literalsWithSameVariableAreEqualOrOpposite)"], ["proof (state)\nthis:\n  literal' = literal \\<or> opposite literal' = literal\n\ngoal (1 subgoal):\n 1. var literal \\<notin> vars valuation' \\<Longrightarrow>\n    literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "thus \"?rhs (literal' # valuation')\""], ["proof (prove)\nusing this:\n  literal' = literal \\<or> opposite literal' = literal\n\ngoal (1 subgoal):\n 1. literalTrue literal (literal' # valuation') \\<or>\n    literalFalse literal (literal' # valuation')", "by auto"], ["proof (state)\nthis:\n  literalTrue literal (literal' # valuation') \\<or>\n  literalFalse literal (literal' # valuation')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literalTrue literal (literal' # valuation') \\<or>\n  literalFalse literal (literal' # valuation')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>True/False clauses\\<close>"], ["", "text\\<open>Check if there is a literal from the clause which is true in the given valuation\\<close>"], ["", "primrec\nclauseTrue      :: \"Clause \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n  \"clauseTrue [] valuation = False\"\n| \"clauseTrue (literal # clause) valuation = (literalTrue literal valuation \\<or> clauseTrue clause valuation)\""], ["", "text\\<open>Check if all the literals from the clause are false in the given valuation\\<close>"], ["", "primrec\nclauseFalse     :: \"Clause \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n  \"clauseFalse [] valuation = True\"\n| \"clauseFalse (literal # clause) valuation = (literalFalse literal valuation \\<and> clauseFalse clause valuation)\""], ["", "lemma clauseTrueIffContainsTrueLiteral: \n  fixes clause :: Clause and valuation :: Valuation  \n  shows \"clauseTrue clause valuation = (\\<exists> literal. literal el clause \\<and> literalTrue literal valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue clause valuation =\n    (\\<exists>literal.\n        literal el clause \\<and> literalTrue literal valuation)", "by (induct clause) auto"], ["", "lemma clauseFalseIffAllLiteralsAreFalse:\n  fixes clause :: Clause and valuation :: Valuation  \n  shows \"clauseFalse clause valuation = (\\<forall> literal. literal el clause \\<longrightarrow> literalFalse literal valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse clause valuation =\n    (\\<forall>literal.\n        literal el clause \\<longrightarrow> literalFalse literal valuation)", "by (induct clause) auto"], ["", "lemma clauseFalseRemove:\n  assumes \"clauseFalse clause valuation\"\n  shows \"clauseFalse (removeAll literal clause) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "fix l::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "assume \"l el removeAll literal clause\""], ["proof (state)\nthis:\n  l el removeAll literal clause\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "hence \"l el clause\""], ["proof (prove)\nusing this:\n  l el removeAll literal clause\n\ngoal (1 subgoal):\n 1. l el clause", "by simp"], ["proof (state)\nthis:\n  l el clause\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "with \\<open>clauseFalse clause valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse clause valuation\n  l el clause", "have \"literalFalse l valuation\""], ["proof (prove)\nusing this:\n  clauseFalse clause valuation\n  l el clause\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "by (simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse l valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "}"], ["proof (state)\nthis:\n  ?l2 el removeAll literal clause \\<Longrightarrow>\n  literalFalse ?l2 valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el removeAll literal clause \\<Longrightarrow>\n  literalFalse ?l2 valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) valuation", "by (simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  clauseFalse (removeAll literal clause) valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clauseFalseAppendValuation: \n  fixes clause :: Clause and valuation :: Valuation and valuation' :: Valuation\n  assumes \"clauseFalse clause valuation\"\n  shows \"clauseFalse clause (valuation @ valuation')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse clause (valuation @ valuation')", "using assms"], ["proof (prove)\nusing this:\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. clauseFalse clause (valuation @ valuation')", "by (induct clause) auto"], ["", "lemma clauseTrueAppendValuation:\n  fixes clause :: Clause and valuation :: Valuation and valuation' :: Valuation\n  assumes \"clauseTrue clause valuation\"\n  shows \"clauseTrue clause (valuation @ valuation')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue clause (valuation @ valuation')", "using assms"], ["proof (prove)\nusing this:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause (valuation @ valuation')", "by (induct clause) auto"], ["", "lemma emptyClauseIsFalse:\n  fixes valuation :: Valuation\n  shows \"clauseFalse [] valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse [] valuation", "by auto"], ["", "lemma emptyValuationFalsifiesOnlyEmptyClause:\n  fixes clause :: Clause\n  assumes \"clause \\<noteq> []\"\n  shows \"\\<not>  clauseFalse clause []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause []", "using assms"], ["proof (prove)\nusing this:\n  clause \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause []", "by (induct clause) auto"], ["", "lemma valuationContainsItsFalseClausesVariables:\n  fixes clause::Clause and valuation::Valuation\n  assumes \"clauseFalse clause valuation\"\n  shows \"vars clause \\<subseteq> vars valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars clause \\<subseteq> vars valuation", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars clause \\<Longrightarrow> x \\<in> vars valuation", "fix v::Variable"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars clause \\<Longrightarrow> x \\<in> vars valuation", "assume \"v \\<in> vars clause\""], ["proof (state)\nthis:\n  v \\<in> vars clause\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars clause \\<Longrightarrow> x \\<in> vars valuation", "hence \"\\<exists> l. var l = v \\<and> l el clause\""], ["proof (prove)\nusing this:\n  v \\<in> vars clause\n\ngoal (1 subgoal):\n 1. \\<exists>l. var l = v \\<and> l el clause", "by (induct clause) auto"], ["proof (state)\nthis:\n  \\<exists>l. var l = v \\<and> l el clause\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars clause \\<Longrightarrow> x \\<in> vars valuation", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. var l = v \\<and> l el clause", "obtain l \n    where \"var l = v\" \"l el clause\""], ["proof (prove)\nusing this:\n  \\<exists>l. var l = v \\<and> l el clause\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>var l = v; l el clause\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  var l = v\n  l el clause\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars clause \\<Longrightarrow> x \\<in> vars valuation", "from \\<open>l el clause\\<close> \\<open>clauseFalse clause valuation\\<close>"], ["proof (chain)\npicking this:\n  l el clause\n  clauseFalse clause valuation", "have \"literalFalse l valuation\""], ["proof (prove)\nusing this:\n  l el clause\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse l valuation\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars clause \\<Longrightarrow> x \\<in> vars valuation", "with \\<open>var l = v\\<close>"], ["proof (chain)\npicking this:\n  var l = v\n  literalFalse l valuation", "show \"v \\<in> vars valuation\""], ["proof (prove)\nusing this:\n  var l = v\n  literalFalse l valuation\n\ngoal (1 subgoal):\n 1. v \\<in> vars valuation", "using valuationContainsItsLiteralsVariable[of \"opposite l\"]"], ["proof (prove)\nusing this:\n  var l = v\n  literalFalse l valuation\n  opposite l el ?valuation \\<Longrightarrow>\n  var (opposite l) \\<in> vars ?valuation\n\ngoal (1 subgoal):\n 1. v \\<in> vars valuation", "by simp"], ["proof (state)\nthis:\n  v \\<in> vars valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>True/False formulae\\<close>"], ["", "text\\<open>Check if all the clauses from the formula are false in the given valuation\\<close>"], ["", "primrec\nformulaTrue     :: \"Formula \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n  \"formulaTrue [] valuation = True\"\n| \"formulaTrue (clause # formula) valuation = (clauseTrue clause valuation \\<and> formulaTrue formula valuation)\""], ["", "text\\<open>Check if there is a clause from the formula which is false in the given valuation\\<close>"], ["", "primrec\nformulaFalse    :: \"Formula \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n  \"formulaFalse [] valuation = False\"\n| \"formulaFalse (clause # formula) valuation = (clauseFalse clause valuation \\<or> formulaFalse formula valuation)\""], ["", "lemma formulaTrueIffAllClausesAreTrue: \n  fixes formula :: Formula and valuation :: Valuation\n  shows \"formulaTrue formula valuation = (\\<forall> clause. clause el formula \\<longrightarrow> clauseTrue clause valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue formula valuation =\n    (\\<forall>clause.\n        clause el formula \\<longrightarrow> clauseTrue clause valuation)", "by (induct formula) auto"], ["", "lemma formulaFalseIffContainsFalseClause: \n  fixes formula :: Formula and valuation :: Valuation\n  shows \"formulaFalse formula valuation = (\\<exists> clause. clause el formula \\<and> clauseFalse clause valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaFalse formula valuation =\n    (\\<exists>clause. clause el formula \\<and> clauseFalse clause valuation)", "by (induct formula) auto"], ["", "lemma formulaTrueAssociativity:\n  fixes f1 :: Formula and f2 :: Formula and f3 :: Formula and valuation :: Valuation\n  shows \"formulaTrue ((f1 @ f2) @ f3) valuation = formulaTrue (f1 @ (f2 @ f3)) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue ((f1 @ f2) @ f3) valuation =\n    formulaTrue (f1 @ f2 @ f3) valuation", "by (auto simp add:formulaTrueIffAllClausesAreTrue)"], ["", "lemma formulaTrueCommutativity:\n  fixes f1 :: Formula and f2 :: Formula and valuation :: Valuation\n  shows \"formulaTrue (f1 @ f2) valuation = formulaTrue (f2 @ f1) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue (f1 @ f2) valuation = formulaTrue (f2 @ f1) valuation", "by (auto simp add:formulaTrueIffAllClausesAreTrue)"], ["", "lemma formulaTrueSubset:\n  fixes formula :: Formula and formula' :: Formula and valuation :: Valuation\n  assumes \n  formulaTrue: \"formulaTrue formula valuation\" and\n  subset: \"\\<forall> (clause::Clause). clause el formula' \\<longrightarrow> clause el formula\"\n  shows \"formulaTrue formula' valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "fix clause :: Clause"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "assume \"clause el formula'\""], ["proof (state)\nthis:\n  clause el formula'\n\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "with formulaTrue subset"], ["proof (chain)\npicking this:\n  formulaTrue formula valuation\n  \\<forall>clause. clause el formula' \\<longrightarrow> clause el formula\n  clause el formula'", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  formulaTrue formula valuation\n  \\<forall>clause. clause el formula' \\<longrightarrow> clause el formula\n  clause el formula'\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (simp add:formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "}"], ["proof (state)\nthis:\n  ?clause2 el formula' \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?clause2 el formula' \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "by (simp add:formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  formulaTrue formula' valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaTrueAppend:\n  fixes formula1 :: Formula and formula2 :: Formula and valuation :: Valuation\n  shows \"formulaTrue (formula1 @ formula2) valuation = (formulaTrue formula1 valuation \\<and> formulaTrue formula2 valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue (formula1 @ formula2) valuation =\n    (formulaTrue formula1 valuation \\<and> formulaTrue formula2 valuation)", "by (induct formula1) auto"], ["", "lemma formulaTrueRemoveAll:\n  fixes formula :: Formula and clause :: Clause and valuation :: Valuation    \n  assumes \"formulaTrue formula valuation\"\n  shows \"formulaTrue (removeAll clause formula) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue (removeAll clause formula) valuation", "using assms"], ["proof (prove)\nusing this:\n  formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. formulaTrue (removeAll clause formula) valuation", "by (induct formula) auto"], ["", "lemma formulaFalseAppend: \n  fixes formula :: Formula and formula' :: Formula and valuation :: Valuation  \n  assumes \"formulaFalse formula valuation\"\n  shows \"formulaFalse (formula @ formula') valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaFalse (formula @ formula') valuation", "using assms"], ["proof (prove)\nusing this:\n  formulaFalse formula valuation\n\ngoal (1 subgoal):\n 1. formulaFalse (formula @ formula') valuation", "by (induct formula) auto"], ["", "lemma formulaTrueAppendValuation: \n  fixes formula :: Formula and valuation :: Valuation and valuation' :: Valuation\n  assumes \"formulaTrue formula valuation\"\n  shows \"formulaTrue formula (valuation @ valuation')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ valuation')", "using assms"], ["proof (prove)\nusing this:\n  formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ valuation')", "by (induct formula) (auto simp add:clauseTrueAppendValuation)"], ["", "lemma formulaFalseAppendValuation: \n  fixes formula :: Formula and valuation :: Valuation and valuation' :: Valuation\n  assumes \"formulaFalse formula valuation\"\n  shows \"formulaFalse formula (valuation @ valuation')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaFalse formula (valuation @ valuation')", "using assms"], ["proof (prove)\nusing this:\n  formulaFalse formula valuation\n\ngoal (1 subgoal):\n 1. formulaFalse formula (valuation @ valuation')", "by (induct formula) (auto simp add:clauseFalseAppendValuation)"], ["", "lemma trueFormulaWithSingleLiteralClause:\n  fixes formula :: Formula and literal :: Literal and valuation :: Valuation\n  assumes \"formulaTrue (removeAll [literal] formula) (valuation @ [literal])\"\n  shows \"formulaTrue formula (valuation @ [literal])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "fix clause :: Clause"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "assume \"clause el formula\""], ["proof (state)\nthis:\n  clause el formula\n\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "with assms"], ["proof (chain)\npicking this:\n  formulaTrue (removeAll [literal] formula) (valuation @ [literal])\n  clause el formula", "have \"clauseTrue clause (valuation @ [literal])\""], ["proof (prove)\nusing this:\n  formulaTrue (removeAll [literal] formula) (valuation @ [literal])\n  clause el formula\n\ngoal (1 subgoal):\n 1. clauseTrue clause (valuation @ [literal])", "proof (cases \"clause = [literal]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause = [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])\n 2. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause \\<noteq> [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])", "case True"], ["proof (state)\nthis:\n  clause = [literal]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause = [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])\n 2. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause \\<noteq> [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])", "thus ?thesis"], ["proof (prove)\nusing this:\n  clause = [literal]\n\ngoal (1 subgoal):\n 1. clauseTrue clause (valuation @ [literal])", "by simp"], ["proof (state)\nthis:\n  clauseTrue clause (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause \\<noteq> [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause \\<noteq> [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])", "case False"], ["proof (state)\nthis:\n  clause \\<noteq> [literal]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause \\<noteq> [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])", "with \\<open>clause el formula\\<close>"], ["proof (chain)\npicking this:\n  clause el formula\n  clause \\<noteq> [literal]", "have \"clause el (removeAll [literal] formula)\""], ["proof (prove)\nusing this:\n  clause el formula\n  clause \\<noteq> [literal]\n\ngoal (1 subgoal):\n 1. clause el removeAll [literal] formula", "by simp"], ["proof (state)\nthis:\n  clause el removeAll [literal] formula\n\ngoal (1 subgoal):\n 1. \\<lbrakk>formulaTrue (removeAll [literal] formula)\n              (valuation @ [literal]);\n     clause el formula; clause \\<noteq> [literal]\\<rbrakk>\n    \\<Longrightarrow> clauseTrue clause (valuation @ [literal])", "with \\<open>formulaTrue (removeAll [literal] formula) (valuation @ [literal])\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue (removeAll [literal] formula) (valuation @ [literal])\n  clause el removeAll [literal] formula", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaTrue (removeAll [literal] formula) (valuation @ [literal])\n  clause el removeAll [literal] formula\n\ngoal (1 subgoal):\n 1. clauseTrue clause (valuation @ [literal])", "by (simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  clauseTrue clause (valuation @ [literal])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseTrue clause (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "}"], ["proof (state)\nthis:\n  ?clause2 el formula \\<Longrightarrow>\n  clauseTrue ?clause2 (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?clause2 el formula \\<Longrightarrow>\n  clauseTrue ?clause2 (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "by (simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  formulaTrue formula (valuation @ [literal])\n\ngoal:\nNo subgoals!", "qed"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Valuation viewed as a formula\\<close>"], ["", "text\\<open>Converts a valuation (the list of literals) into formula (list of single member lists of literals)\\<close>"], ["", "primrec\nval2form    :: \"Valuation \\<Rightarrow> Formula\"\nwhere\n  \"val2form [] = []\"\n| \"val2form (literal # valuation) = [literal] # val2form valuation\""], ["", "lemma val2FormEl: \n  fixes literal :: Literal and valuation :: Valuation \n  shows \"literal el valuation = [literal] el val2form valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal el valuation = [literal] el val2form valuation", "by (induct valuation) auto"], ["", "lemma val2FormAreSingleLiteralClauses: \n  fixes clause :: Clause and valuation :: Valuation\n  shows \"clause el val2form valuation \\<longrightarrow> (\\<exists> literal. clause = [literal] \\<and> literal el valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause el val2form valuation \\<longrightarrow>\n    (\\<exists>literal. clause = [literal] \\<and> literal el valuation)", "by (induct valuation) auto"], ["", "lemma val2formOfSingleLiteralValuation:\nassumes \"length v = 1\"\nshows \"val2form v = [[hd v]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val2form v = [[hd v]]", "using assms"], ["proof (prove)\nusing this:\n  length v = 1\n\ngoal (1 subgoal):\n 1. val2form v = [[hd v]]", "by (induct v) auto"], ["", "lemma val2FormRemoveAll: \n  fixes literal :: Literal and valuation :: Valuation \n  shows \"removeAll [literal] (val2form valuation) = val2form (removeAll literal valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll [literal] (val2form valuation) =\n    val2form (removeAll literal valuation)", "by (induct valuation) auto"], ["", "lemma val2formAppend: \n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  shows \"val2form (valuation1 @ valuation2) = (val2form valuation1 @ val2form valuation2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val2form (valuation1 @ valuation2) =\n    val2form valuation1 @ val2form valuation2", "by (induct valuation1) auto"], ["", "lemma val2formFormulaTrue: \n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  shows \"formulaTrue (val2form valuation1) valuation2 = (\\<forall> (literal :: Literal). literal el valuation1 \\<longrightarrow> literal el valuation2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue (val2form valuation1) valuation2 =\n    (\\<forall>literal.\n        literal el valuation1 \\<longrightarrow> literal el valuation2)", "by (induct valuation1) auto"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Consistency of valuations\\<close>"], ["", "text\\<open>Valuation is inconsistent if it contains both a literal and its opposite.\\<close>"], ["", "primrec\ninconsistent   :: \"Valuation \\<Rightarrow> bool\"\nwhere\n  \"inconsistent [] = False\"\n| \"inconsistent (literal # valuation) = (opposite literal el valuation \\<or> inconsistent valuation)\""], ["", "definition [simp]: \"consistent valuation == \\<not> inconsistent valuation\""], ["", "lemma inconsistentCharacterization: \n  fixes valuation :: Valuation\n  shows \"inconsistent valuation = (\\<exists> literal. literalTrue literal valuation \\<and> literalFalse literal valuation)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent valuation =\n    (\\<exists>literal.\n        literalTrue literal valuation \\<and> literalFalse literal valuation)", "by (induct valuation) auto"], ["", "lemma clauseTrueAndClauseFalseImpliesInconsistent: \n  fixes clause :: Clause and valuation :: Valuation\n  assumes \"clauseTrue clause valuation\" and \"clauseFalse clause valuation\"\n  shows \"inconsistent valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inconsistent valuation", "from \\<open>clauseTrue clause valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseTrue clause valuation", "obtain literal :: Literal \n    where \"literal el clause\" and \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. (\\<And>literal.\n        \\<lbrakk>literal el clause; literalTrue literal valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  literal el clause\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "with \\<open>clauseFalse clause valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse clause valuation\n  literal el clause\n  literalTrue literal valuation", "have \"literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  clauseFalse clause valuation\n  literal el clause\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "by (auto simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "from \\<open>literalTrue literal valuation\\<close> \\<open>literalFalse literal valuation\\<close>"], ["proof (chain)\npicking this:\n  literalTrue literal valuation\n  literalFalse literal valuation", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue literal valuation\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "by (auto simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  inconsistent valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaTrueAndFormulaFalseImpliesInconsistent: \n  fixes formula :: Formula and valuation :: Valuation\n  assumes \"formulaTrue formula valuation\" and \"formulaFalse formula valuation\"\n  shows \"inconsistent valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inconsistent valuation", "from \\<open>formulaFalse formula valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse formula valuation", "obtain clause :: Clause \n    where \"clause el formula\" and \"clauseFalse clause valuation\""], ["proof (prove)\nusing this:\n  formulaFalse formula valuation\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>clause el formula; clauseFalse clause valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: formulaFalseIffContainsFalseClause)"], ["proof (state)\nthis:\n  clause el formula\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "with \\<open>formulaTrue formula valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue formula valuation\n  clause el formula\n  clauseFalse clause valuation", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  formulaTrue formula valuation\n  clause el formula\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "from \\<open>clauseTrue clause valuation\\<close> \\<open>clauseFalse clause valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseTrue clause valuation\n  clauseFalse clause valuation", "show ?thesis"], ["proof (prove)\nusing this:\n  clauseTrue clause valuation\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "by (auto simp add: clauseTrueAndClauseFalseImpliesInconsistent)"], ["proof (state)\nthis:\n  inconsistent valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inconsistentAppend:\n  fixes valuation1 :: Valuation and valuation2 :: Valuation\n  assumes \"inconsistent (valuation1 @ valuation2)\"\n  shows \"inconsistent valuation1 \\<or> inconsistent valuation2 \\<or> (\\<exists> literal. literalTrue literal valuation1 \\<and> literalFalse literal valuation2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent valuation1 \\<or>\n    inconsistent valuation2 \\<or>\n    (\\<exists>literal.\n        literalTrue literal valuation1 \\<and>\n        literalFalse literal valuation2)", "using assms"], ["proof (prove)\nusing this:\n  inconsistent (valuation1 @ valuation2)\n\ngoal (1 subgoal):\n 1. inconsistent valuation1 \\<or>\n    inconsistent valuation2 \\<or>\n    (\\<exists>literal.\n        literalTrue literal valuation1 \\<and>\n        literalFalse literal valuation2)", "proof (cases \"inconsistent valuation1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>inconsistent (valuation1 @ valuation2);\n     inconsistent valuation1\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)\n 2. \\<lbrakk>inconsistent (valuation1 @ valuation2);\n     \\<not> inconsistent valuation1\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "case True"], ["proof (state)\nthis:\n  inconsistent valuation1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inconsistent (valuation1 @ valuation2);\n     inconsistent valuation1\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)\n 2. \\<lbrakk>inconsistent (valuation1 @ valuation2);\n     \\<not> inconsistent valuation1\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inconsistent valuation1\n\ngoal (1 subgoal):\n 1. inconsistent valuation1 \\<or>\n    inconsistent valuation2 \\<or>\n    (\\<exists>literal.\n        literalTrue literal valuation1 \\<and>\n        literalFalse literal valuation2)", "by simp"], ["proof (state)\nthis:\n  inconsistent valuation1 \\<or>\n  inconsistent valuation2 \\<or>\n  (\\<exists>literal.\n      literalTrue literal valuation1 \\<and> literalFalse literal valuation2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inconsistent (valuation1 @ valuation2);\n     \\<not> inconsistent valuation1\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inconsistent (valuation1 @ valuation2);\n     \\<not> inconsistent valuation1\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "case False"], ["proof (state)\nthis:\n  \\<not> inconsistent valuation1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inconsistent (valuation1 @ valuation2);\n     \\<not> inconsistent valuation1\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> inconsistent valuation1\n\ngoal (1 subgoal):\n 1. inconsistent valuation1 \\<or>\n    inconsistent valuation2 \\<or>\n    (\\<exists>literal.\n        literalTrue literal valuation1 \\<and>\n        literalFalse literal valuation2)", "proof (cases \"inconsistent valuation2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> inconsistent valuation1;\n     inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)\n 2. \\<lbrakk>\\<not> inconsistent valuation1;\n     \\<not> inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "case True"], ["proof (state)\nthis:\n  inconsistent valuation2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> inconsistent valuation1;\n     inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)\n 2. \\<lbrakk>\\<not> inconsistent valuation1;\n     \\<not> inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inconsistent valuation2\n\ngoal (1 subgoal):\n 1. inconsistent valuation1 \\<or>\n    inconsistent valuation2 \\<or>\n    (\\<exists>literal.\n        literalTrue literal valuation1 \\<and>\n        literalFalse literal valuation2)", "by simp"], ["proof (state)\nthis:\n  inconsistent valuation1 \\<or>\n  inconsistent valuation2 \\<or>\n  (\\<exists>literal.\n      literalTrue literal valuation1 \\<and> literalFalse literal valuation2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> inconsistent valuation1;\n     \\<not> inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> inconsistent valuation1;\n     \\<not> inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "case False"], ["proof (state)\nthis:\n  \\<not> inconsistent valuation2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> inconsistent valuation1;\n     \\<not> inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "from \\<open>inconsistent (valuation1 @ valuation2)\\<close>"], ["proof (chain)\npicking this:\n  inconsistent (valuation1 @ valuation2)", "obtain literal :: Literal \n      where \"literalTrue literal (valuation1 @ valuation2)\" and \"literalFalse literal (valuation1 @ valuation2)\""], ["proof (prove)\nusing this:\n  inconsistent (valuation1 @ valuation2)\n\ngoal (1 subgoal):\n 1. (\\<And>literal.\n        \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n         literalFalse literal (valuation1 @ valuation2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  literalTrue literal (valuation1 @ valuation2)\n  literalFalse literal (valuation1 @ valuation2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> inconsistent valuation1;\n     \\<not> inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "hence \"(\\<exists> literal. literalTrue literal valuation1 \\<and> literalFalse literal valuation2)\""], ["proof (prove)\nusing this:\n  literalTrue literal (valuation1 @ valuation2)\n  literalFalse literal (valuation1 @ valuation2)\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literalTrue literal valuation1 \\<and> literalFalse literal valuation2", "proof (cases \"literalTrue literal valuation1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2\n 2. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "case True"], ["proof (state)\nthis:\n  literalTrue literal valuation1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2\n 2. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "with \\<open>\\<not> inconsistent valuation1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> inconsistent valuation1\n  literalTrue literal valuation1", "have \"\\<not> literalFalse literal valuation1\""], ["proof (prove)\nusing this:\n  \\<not> inconsistent valuation1\n  literalTrue literal valuation1\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse literal valuation1", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> literalFalse literal valuation1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2\n 2. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "with \\<open>literalFalse literal (valuation1 @ valuation2)\\<close>"], ["proof (chain)\npicking this:\n  literalFalse literal (valuation1 @ valuation2)\n  \\<not> literalFalse literal valuation1", "have \"literalFalse literal valuation2\""], ["proof (prove)\nusing this:\n  literalFalse literal (valuation1 @ valuation2)\n  \\<not> literalFalse literal valuation1\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation2", "by auto"], ["proof (state)\nthis:\n  literalFalse literal valuation2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2\n 2. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "with True"], ["proof (chain)\npicking this:\n  literalTrue literal valuation1\n  literalFalse literal valuation2", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue literal valuation1\n  literalFalse literal valuation2\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literalTrue literal valuation1 \\<and> literalFalse literal valuation2", "by auto"], ["proof (state)\nthis:\n  \\<exists>literal.\n     literalTrue literal valuation1 \\<and> literalFalse literal valuation2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "case False"], ["proof (state)\nthis:\n  \\<not> literalTrue literal valuation1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "with \\<open>literalTrue literal (valuation1 @ valuation2)\\<close>"], ["proof (chain)\npicking this:\n  literalTrue literal (valuation1 @ valuation2)\n  \\<not> literalTrue literal valuation1", "have \"literalTrue literal valuation2\""], ["proof (prove)\nusing this:\n  literalTrue literal (valuation1 @ valuation2)\n  \\<not> literalTrue literal valuation1\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation2", "by auto"], ["proof (state)\nthis:\n  literalTrue literal valuation2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "with \\<open>\\<not> inconsistent valuation2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> inconsistent valuation2\n  literalTrue literal valuation2", "have \"\\<not> literalFalse literal valuation2\""], ["proof (prove)\nusing this:\n  \\<not> inconsistent valuation2\n  literalTrue literal valuation2\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse literal valuation2", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  \\<not> literalFalse literal valuation2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "with \\<open>literalFalse literal (valuation1 @ valuation2)\\<close>"], ["proof (chain)\npicking this:\n  literalFalse literal (valuation1 @ valuation2)\n  \\<not> literalFalse literal valuation2", "have \"literalFalse literal valuation1\""], ["proof (prove)\nusing this:\n  literalFalse literal (valuation1 @ valuation2)\n  \\<not> literalFalse literal valuation2\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation1", "by auto"], ["proof (state)\nthis:\n  literalFalse literal valuation1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>literalTrue literal (valuation1 @ valuation2);\n     literalFalse literal (valuation1 @ valuation2);\n     \\<not> literalTrue literal valuation1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>literal.\n                         literalTrue literal valuation1 \\<and>\n                         literalFalse literal valuation2", "with \\<open>literalTrue literal valuation2\\<close>"], ["proof (chain)\npicking this:\n  literalTrue literal valuation2\n  literalFalse literal valuation1", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue literal valuation2\n  literalFalse literal valuation1\n\ngoal (1 subgoal):\n 1. \\<exists>literal.\n       literalTrue literal valuation1 \\<and> literalFalse literal valuation2", "by auto"], ["proof (state)\nthis:\n  \\<exists>literal.\n     literalTrue literal valuation1 \\<and> literalFalse literal valuation2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>literal.\n     literalTrue literal valuation1 \\<and> literalFalse literal valuation2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> inconsistent valuation1;\n     \\<not> inconsistent valuation2\\<rbrakk>\n    \\<Longrightarrow> inconsistent valuation1 \\<or>\n                      inconsistent valuation2 \\<or>\n                      (\\<exists>literal.\n                          literalTrue literal valuation1 \\<and>\n                          literalFalse literal valuation2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>literal.\n     literalTrue literal valuation1 \\<and> literalFalse literal valuation2\n\ngoal (1 subgoal):\n 1. inconsistent valuation1 \\<or>\n    inconsistent valuation2 \\<or>\n    (\\<exists>literal.\n        literalTrue literal valuation1 \\<and>\n        literalFalse literal valuation2)", "by simp"], ["proof (state)\nthis:\n  inconsistent valuation1 \\<or>\n  inconsistent valuation2 \\<or>\n  (\\<exists>literal.\n      literalTrue literal valuation1 \\<and> literalFalse literal valuation2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inconsistent valuation1 \\<or>\n  inconsistent valuation2 \\<or>\n  (\\<exists>literal.\n      literalTrue literal valuation1 \\<and> literalFalse literal valuation2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consistentAppendElement:\nassumes \"consistent v\" and \"\\<not> literalFalse l v\"\nshows \"consistent (v @ [l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> consistent (v @ [l])\n\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "with \\<open>consistent v\\<close>"], ["proof (chain)\npicking this:\n  consistent v\n  \\<not> consistent (v @ [l])", "have \"(opposite l) el v\""], ["proof (prove)\nusing this:\n  consistent v\n  \\<not> consistent (v @ [l])\n\ngoal (1 subgoal):\n 1. opposite l el v", "using inconsistentAppend[of \"v\" \"[l]\"]"], ["proof (prove)\nusing this:\n  consistent v\n  \\<not> consistent (v @ [l])\n  inconsistent (v @ [l]) \\<Longrightarrow>\n  inconsistent v \\<or>\n  inconsistent [l] \\<or>\n  (\\<exists>literal. literalTrue literal v \\<and> literalFalse literal [l])\n\ngoal (1 subgoal):\n 1. opposite l el v", "by auto"], ["proof (state)\nthis:\n  opposite l el v\n\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "with \\<open>\\<not> literalFalse l v\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalFalse l v\n  opposite l el v", "have False"], ["proof (prove)\nusing this:\n  \\<not> literalFalse l v\n  opposite l el v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "}"], ["proof (state)\nthis:\n  \\<not> consistent (v @ [l]) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> consistent (v @ [l]) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. consistent (v @ [l])", "by auto"], ["proof (state)\nthis:\n  consistent (v @ [l])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inconsistentRemoveAll:\n  fixes literal :: Literal and valuation :: Valuation\n  assumes \"inconsistent (removeAll literal valuation)\" \n  shows \"inconsistent valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent valuation", "using assms"], ["proof (prove)\nusing this:\n  inconsistent (removeAll literal valuation)\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inconsistent (removeAll literal valuation) \\<Longrightarrow>\n    inconsistent valuation", "from \\<open>inconsistent (removeAll literal valuation)\\<close>"], ["proof (chain)\npicking this:\n  inconsistent (removeAll literal valuation)", "obtain literal' :: Literal \n    where l'True: \"literalTrue literal' (removeAll literal valuation)\" and l'False: \"literalFalse literal' (removeAll literal valuation)\""], ["proof (prove)\nusing this:\n  inconsistent (removeAll literal valuation)\n\ngoal (1 subgoal):\n 1. (\\<And>literal'.\n        \\<lbrakk>literalTrue literal' (removeAll literal valuation);\n         literalFalse literal' (removeAll literal valuation)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  literalTrue literal' (removeAll literal valuation)\n  literalFalse literal' (removeAll literal valuation)\n\ngoal (1 subgoal):\n 1. inconsistent (removeAll literal valuation) \\<Longrightarrow>\n    inconsistent valuation", "from l'True"], ["proof (chain)\npicking this:\n  literalTrue literal' (removeAll literal valuation)", "have \"literalTrue literal' valuation\""], ["proof (prove)\nusing this:\n  literalTrue literal' (removeAll literal valuation)\n\ngoal (1 subgoal):\n 1. literalTrue literal' valuation", "by simp"], ["proof (state)\nthis:\n  literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. inconsistent (removeAll literal valuation) \\<Longrightarrow>\n    inconsistent valuation", "moreover"], ["proof (state)\nthis:\n  literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. inconsistent (removeAll literal valuation) \\<Longrightarrow>\n    inconsistent valuation", "from l'False"], ["proof (chain)\npicking this:\n  literalFalse literal' (removeAll literal valuation)", "have \"literalFalse literal' valuation\""], ["proof (prove)\nusing this:\n  literalFalse literal' (removeAll literal valuation)\n\ngoal (1 subgoal):\n 1. literalFalse literal' valuation", "by simp"], ["proof (state)\nthis:\n  literalFalse literal' valuation\n\ngoal (1 subgoal):\n 1. inconsistent (removeAll literal valuation) \\<Longrightarrow>\n    inconsistent valuation", "ultimately"], ["proof (chain)\npicking this:\n  literalTrue literal' valuation\n  literalFalse literal' valuation", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue literal' valuation\n  literalFalse literal' valuation\n\ngoal (1 subgoal):\n 1. inconsistent valuation", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  inconsistent valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inconsistentPrefix: \n  assumes \"isPrefix valuation1 valuation2\" and \"inconsistent valuation1\"\n  shows \"inconsistent valuation2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent valuation2", "using assms"], ["proof (prove)\nusing this:\n  isPrefix valuation1 valuation2\n  inconsistent valuation1\n\ngoal (1 subgoal):\n 1. inconsistent valuation2", "by (auto simp add:inconsistentCharacterization isPrefix_def)"], ["", "lemma consistentPrefix:\n  assumes \"isPrefix valuation1 valuation2\" and \"consistent valuation2\"\n  shows \"consistent valuation1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent valuation1", "using assms"], ["proof (prove)\nusing this:\n  isPrefix valuation1 valuation2\n  consistent valuation2\n\ngoal (1 subgoal):\n 1. consistent valuation1", "by (auto simp add:inconsistentCharacterization isPrefix_def)"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Totality of valuations\\<close>"], ["", "text\\<open>Checks if the valuation contains all the variables from the given set of variables\\<close>"], ["", "definition total where\n[simp]: \"total valuation variables == variables \\<subseteq> vars valuation\""], ["", "lemma totalSubset: \n  fixes A :: \"Variable set\" and B :: \"Variable set\" and valuation :: \"Valuation\"\n  assumes \"A \\<subseteq> B\" and \"total valuation B\"\n  shows \"total valuation A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNF.total valuation A", "using assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  CNF.total valuation B\n\ngoal (1 subgoal):\n 1. CNF.total valuation A", "by auto"], ["", "lemma totalFormulaImpliesTotalClause:\n  fixes clause :: Clause and formula :: Formula and valuation :: Valuation\n  assumes clauseEl: \"clause el formula\" and totalFormula: \"total valuation (vars formula)\"\n  shows totalClause: \"total valuation (vars clause)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNF.total valuation (vars clause)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CNF.total valuation (vars clause)", "from clauseEl"], ["proof (chain)\npicking this:\n  clause el formula", "have \"vars clause \\<subseteq> vars formula\""], ["proof (prove)\nusing this:\n  clause el formula\n\ngoal (1 subgoal):\n 1. vars clause \\<subseteq> vars formula", "using formulaContainsItsClausesVariables [of \"clause\" \"formula\"]"], ["proof (prove)\nusing this:\n  clause el formula\n  clause el formula \\<Longrightarrow> vars clause \\<subseteq> vars formula\n\ngoal (1 subgoal):\n 1. vars clause \\<subseteq> vars formula", "by simp"], ["proof (state)\nthis:\n  vars clause \\<subseteq> vars formula\n\ngoal (1 subgoal):\n 1. CNF.total valuation (vars clause)", "with totalFormula"], ["proof (chain)\npicking this:\n  CNF.total valuation (vars formula)\n  vars clause \\<subseteq> vars formula", "show ?thesis"], ["proof (prove)\nusing this:\n  CNF.total valuation (vars formula)\n  vars clause \\<subseteq> vars formula\n\ngoal (1 subgoal):\n 1. CNF.total valuation (vars clause)", "by (simp add: totalSubset)"], ["proof (state)\nthis:\n  CNF.total valuation (vars clause)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totalValuationForClauseDefinesAllItsLiterals:\n  fixes clause :: Clause and valuation :: Valuation and literal :: Literal\n  assumes \n  totalClause: \"total valuation (vars clause)\" and\n  literalEl: \"literal el clause\"\n  shows trueOrFalse: \"literalTrue literal valuation \\<or> literalFalse literal valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "from literalEl"], ["proof (chain)\npicking this:\n  literal el clause", "have \"var literal \\<in> vars clause\""], ["proof (prove)\nusing this:\n  literal el clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "using clauseContainsItsLiteralsVariable"], ["proof (prove)\nusing this:\n  literal el clause\n  ?literal el ?clause \\<Longrightarrow> var ?literal \\<in> vars ?clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "by auto"], ["proof (state)\nthis:\n  var literal \\<in> vars clause\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "with totalClause"], ["proof (chain)\npicking this:\n  CNF.total valuation (vars clause)\n  var literal \\<in> vars clause", "have \"var literal \\<in> vars valuation\""], ["proof (prove)\nusing this:\n  CNF.total valuation (vars clause)\n  var literal \\<in> vars clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "by auto"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "using  variableDefinedImpliesLiteralDefined [of \"literal\" \"valuation\"]"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  (var literal \\<in> vars valuation) =\n  (literalTrue literal valuation \\<or> literalFalse literal valuation)\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "by simp"], ["proof (state)\nthis:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totalValuationForClauseDefinesItsValue:\n  fixes clause :: Clause and valuation :: Valuation\n  assumes totalClause: \"total valuation (vars clause)\"\n  shows \"clauseTrue clause valuation \\<or> clauseFalse clause valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue clause valuation \\<or> clauseFalse clause valuation", "proof (cases \"clauseFalse clause valuation\")"], ["proof (state)\ngoal (2 subgoals):\n 1. clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation\n 2. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "case True"], ["proof (state)\nthis:\n  clauseFalse clause valuation\n\ngoal (2 subgoals):\n 1. clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation\n 2. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation \\<or> clauseFalse clause valuation", "by (rule disjI2)"], ["proof (state)\nthis:\n  clauseTrue clause valuation \\<or> clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "case False"], ["proof (state)\nthis:\n  \\<not> clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "hence \"\\<not> (\\<forall> l. l el clause \\<longrightarrow> literalFalse l valuation)\""], ["proof (prove)\nusing this:\n  \\<not> clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>l.\n               l el clause \\<longrightarrow> literalFalse l valuation)", "by (auto simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>l.\n             l el clause \\<longrightarrow> literalFalse l valuation)\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>l.\n             l el clause \\<longrightarrow> literalFalse l valuation)", "obtain l :: Literal \n    where \"l el clause\" and \"\\<not> literalFalse l valuation\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>l.\n             l el clause \\<longrightarrow> literalFalse l valuation)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el clause; \\<not> literalFalse l valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l el clause\n  \\<not> literalFalse l valuation\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "with totalClause"], ["proof (chain)\npicking this:\n  CNF.total valuation (vars clause)\n  l el clause\n  \\<not> literalFalse l valuation", "have \"literalTrue l valuation \\<or> literalFalse l valuation\""], ["proof (prove)\nusing this:\n  CNF.total valuation (vars clause)\n  l el clause\n  \\<not> literalFalse l valuation\n\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<or> literalFalse l valuation", "using totalValuationForClauseDefinesAllItsLiterals [of \"valuation\" \"clause\" \"l\"]"], ["proof (prove)\nusing this:\n  CNF.total valuation (vars clause)\n  l el clause\n  \\<not> literalFalse l valuation\n  \\<lbrakk>CNF.total valuation (vars clause); l el clause\\<rbrakk>\n  \\<Longrightarrow> literalTrue l valuation \\<or> literalFalse l valuation\n\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<or> literalFalse l valuation", "by auto"], ["proof (state)\nthis:\n  literalTrue l valuation \\<or> literalFalse l valuation\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "with \\<open>\\<not> literalFalse l valuation\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalFalse l valuation\n  literalTrue l valuation \\<or> literalFalse l valuation", "have \"literalTrue l valuation\""], ["proof (prove)\nusing this:\n  \\<not> literalFalse l valuation\n  literalTrue l valuation \\<or> literalFalse l valuation\n\ngoal (1 subgoal):\n 1. literalTrue l valuation", "by simp"], ["proof (state)\nthis:\n  literalTrue l valuation\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "with \\<open>l el clause\\<close>"], ["proof (chain)\npicking this:\n  l el clause\n  literalTrue l valuation", "have \"(clauseTrue clause valuation)\""], ["proof (prove)\nusing this:\n  l el clause\n  literalTrue l valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (auto simp add:clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation \\<Longrightarrow>\n    clauseTrue clause valuation \\<or> clauseFalse clause valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation \\<or> clauseFalse clause valuation", "by (rule disjI1)"], ["proof (state)\nthis:\n  clauseTrue clause valuation \\<or> clauseFalse clause valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totalValuationForFormulaDefinesAllItsLiterals: \n  fixes formula::Formula and valuation::Valuation\n  assumes totalFormula: \"total valuation (vars formula)\" and\n  literalElFormula: \"literal el formula\"\n  shows \"literalTrue literal valuation \\<or> literalFalse literal valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "from literalElFormula"], ["proof (chain)\npicking this:\n  literal el formula", "have \"var literal \\<in> vars formula\""], ["proof (prove)\nusing this:\n  literal el formula\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars formula", "by (rule formulaContainsItsLiteralsVariable)"], ["proof (state)\nthis:\n  var literal \\<in> vars formula\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "with totalFormula"], ["proof (chain)\npicking this:\n  CNF.total valuation (vars formula)\n  var literal \\<in> vars formula", "have \"var literal \\<in> vars valuation\""], ["proof (prove)\nusing this:\n  CNF.total valuation (vars formula)\n  var literal \\<in> vars formula\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "by auto"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "using variableDefinedImpliesLiteralDefined [of \"literal\" \"valuation\"]"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  (var literal \\<in> vars valuation) =\n  (literalTrue literal valuation \\<or> literalFalse literal valuation)\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "by simp"], ["proof (state)\nthis:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totalValuationForFormulaDefinesAllItsClauses:\n  fixes formula :: Formula and valuation :: Valuation and clause :: Clause\n  assumes totalFormula: \"total valuation (vars formula)\" and \n  clauseElFormula: \"clause el formula\" \n  shows \"clauseTrue clause valuation \\<or> clauseFalse clause valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue clause valuation \\<or> clauseFalse clause valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseTrue clause valuation \\<or> clauseFalse clause valuation", "from clauseElFormula totalFormula"], ["proof (chain)\npicking this:\n  clause el formula\n  CNF.total valuation (vars formula)", "have \"total valuation (vars clause)\""], ["proof (prove)\nusing this:\n  clause el formula\n  CNF.total valuation (vars formula)\n\ngoal (1 subgoal):\n 1. CNF.total valuation (vars clause)", "by (rule totalFormulaImpliesTotalClause)"], ["proof (state)\nthis:\n  CNF.total valuation (vars clause)\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation \\<or> clauseFalse clause valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  CNF.total valuation (vars clause)\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation \\<or> clauseFalse clause valuation", "by (rule totalValuationForClauseDefinesItsValue)"], ["proof (state)\nthis:\n  clauseTrue clause valuation \\<or> clauseFalse clause valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totalValuationForFormulaDefinesItsValue:\n  assumes totalFormula: \"total valuation (vars formula)\"\n  shows \"formulaTrue formula valuation \\<or> formulaFalse formula valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue formula valuation \\<or> formulaFalse formula valuation", "proof (cases \"formulaTrue formula valuation\")"], ["proof (state)\ngoal (2 subgoals):\n 1. formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation\n 2. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "case True"], ["proof (state)\nthis:\n  formulaTrue formula valuation\n\ngoal (2 subgoals):\n 1. formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation\n 2. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula valuation \\<or> formulaFalse formula valuation", "by simp"], ["proof (state)\nthis:\n  formulaTrue formula valuation \\<or> formulaFalse formula valuation\n\ngoal (1 subgoal):\n 1. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "case False"], ["proof (state)\nthis:\n  \\<not> formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "then"], ["proof (chain)\npicking this:\n  \\<not> formulaTrue formula valuation", "obtain clause :: Clause \n    where clauseElFormula: \"clause el formula\" and notClauseTrue: \"\\<not> clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  \\<not> formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>clause el formula;\n         \\<not> clauseTrue clause valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  clause el formula\n  \\<not> clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "from clauseElFormula totalFormula"], ["proof (chain)\npicking this:\n  clause el formula\n  CNF.total valuation (vars formula)", "have \"total valuation (vars clause)\""], ["proof (prove)\nusing this:\n  clause el formula\n  CNF.total valuation (vars formula)\n\ngoal (1 subgoal):\n 1. CNF.total valuation (vars clause)", "using totalFormulaImpliesTotalClause [of \"clause\" \"formula\" \"valuation\"]"], ["proof (prove)\nusing this:\n  clause el formula\n  CNF.total valuation (vars formula)\n  \\<lbrakk>clause el formula; CNF.total valuation (vars formula)\\<rbrakk>\n  \\<Longrightarrow> CNF.total valuation (vars clause)\n\ngoal (1 subgoal):\n 1. CNF.total valuation (vars clause)", "by simp"], ["proof (state)\nthis:\n  CNF.total valuation (vars clause)\n\ngoal (1 subgoal):\n 1. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "with notClauseTrue"], ["proof (chain)\npicking this:\n  \\<not> clauseTrue clause valuation\n  CNF.total valuation (vars clause)", "have \"clauseFalse clause valuation\""], ["proof (prove)\nusing this:\n  \\<not> clauseTrue clause valuation\n  CNF.total valuation (vars clause)\n\ngoal (1 subgoal):\n 1. clauseFalse clause valuation", "using totalValuationForClauseDefinesItsValue [of \"valuation\" \"clause\"]"], ["proof (prove)\nusing this:\n  \\<not> clauseTrue clause valuation\n  CNF.total valuation (vars clause)\n  CNF.total valuation (vars clause) \\<Longrightarrow>\n  clauseTrue clause valuation \\<or> clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. clauseFalse clause valuation", "by simp"], ["proof (state)\nthis:\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> formulaTrue formula valuation \\<Longrightarrow>\n    formulaTrue formula valuation \\<or> formulaFalse formula valuation", "with clauseElFormula"], ["proof (chain)\npicking this:\n  clause el formula\n  clauseFalse clause valuation", "show ?thesis"], ["proof (prove)\nusing this:\n  clause el formula\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula valuation \\<or> formulaFalse formula valuation", "by (auto simp add:formulaFalseIffContainsFalseClause)"], ["proof (state)\nthis:\n  formulaTrue formula valuation \\<or> formulaFalse formula valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma totalRemoveAllSingleLiteralClause:\n  fixes literal :: Literal and valuation :: Valuation and formula :: Formula\n  assumes varLiteral: \"var literal \\<in> vars valuation\" and totalRemoveAll: \"total valuation (vars (removeAll [literal] formula))\"\n  shows \"total valuation (vars formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNF.total valuation (vars formula)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CNF.total valuation (vars formula)", "have \"vars formula - vars [literal] \\<subseteq> vars (removeAll [literal] formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars formula - vars [literal]\n    \\<subseteq> vars (removeAll [literal] formula)", "by (rule varsRemoveAllClauseSuperset)"], ["proof (state)\nthis:\n  vars formula - vars [literal]\n  \\<subseteq> vars (removeAll [literal] formula)\n\ngoal (1 subgoal):\n 1. CNF.total valuation (vars formula)", "with assms"], ["proof (chain)\npicking this:\n  var literal \\<in> vars valuation\n  CNF.total valuation (vars (removeAll [literal] formula))\n  vars formula - vars [literal]\n  \\<subseteq> vars (removeAll [literal] formula)", "show ?thesis"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  CNF.total valuation (vars (removeAll [literal] formula))\n  vars formula - vars [literal]\n  \\<subseteq> vars (removeAll [literal] formula)\n\ngoal (1 subgoal):\n 1. CNF.total valuation (vars formula)", "by auto"], ["proof (state)\nthis:\n  CNF.total valuation (vars formula)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Models and satisfiability\\<close>"], ["", "text\\<open>Model of a formula is a consistent valuation under which formula/clause is true\\<close>"], ["", "consts model :: \"Valuation \\<Rightarrow> 'a \\<Rightarrow> bool\""], ["", "overloading modelFormula \\<equiv> \"model :: Valuation \\<Rightarrow> Formula \\<Rightarrow> bool\"\nbegin"], ["", "definition [simp]: \"model valuation (formula::Formula) ==\n    consistent valuation \\<and> (formulaTrue formula valuation)\""], ["", "end"], ["", "overloading modelClause \\<equiv> \"model :: Valuation \\<Rightarrow> Clause \\<Rightarrow> bool\"\nbegin"], ["", "definition [simp]: \"model valuation (clause::Clause) ==\n    consistent valuation \\<and> (clauseTrue clause valuation)\""], ["", "end"], ["", "text\\<open>Checks if a formula has a model\\<close>"], ["", "definition satisfiable :: \"Formula \\<Rightarrow> bool\"\nwhere\n\"satisfiable formula == \\<exists> valuation. model valuation formula\""], ["", "lemma formulaWithEmptyClauseIsUnsatisfiable:\n  fixes formula :: Formula\n  assumes \"([]::Clause) el formula\"\n  shows \"\\<not> satisfiable formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "using assms"], ["proof (prove)\nusing this:\n  [] el formula\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "by (auto simp add: satisfiable_def formulaTrueIffAllClausesAreTrue)"], ["", "lemma satisfiableSubset: \n  fixes formula0 :: Formula and formula :: Formula\n  assumes subset: \"\\<forall> (clause::Clause). clause el formula0 \\<longrightarrow> clause el formula\"\n  shows  \"satisfiable formula \\<longrightarrow> satisfiable formula0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable formula \\<longrightarrow> satisfiable formula0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable formula \\<Longrightarrow> satisfiable formula0", "assume \"satisfiable formula\""], ["proof (state)\nthis:\n  satisfiable formula\n\ngoal (1 subgoal):\n 1. satisfiable formula \\<Longrightarrow> satisfiable formula0", "show \"satisfiable formula0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable formula0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable formula0", "from \\<open>satisfiable formula\\<close>"], ["proof (chain)\npicking this:\n  satisfiable formula", "obtain valuation :: Valuation\n      where \"model valuation formula\""], ["proof (prove)\nusing this:\n  satisfiable formula\n\ngoal (1 subgoal):\n 1. (\\<And>valuation.\n        model valuation formula \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: satisfiable_def)"], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "{"], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "fix clause :: Clause"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable formula0", "assume \"clause el formula0\""], ["proof (state)\nthis:\n  clause el formula0\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "with subset"], ["proof (chain)\npicking this:\n  \\<forall>clause. clause el formula0 \\<longrightarrow> clause el formula\n  clause el formula0", "have \"clause el formula\""], ["proof (prove)\nusing this:\n  \\<forall>clause. clause el formula0 \\<longrightarrow> clause el formula\n  clause el formula0\n\ngoal (1 subgoal):\n 1. clause el formula", "by simp"], ["proof (state)\nthis:\n  clause el formula\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "with \\<open>model valuation formula\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula\n  clause el formula", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n  clause el formula\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "}"], ["proof (state)\nthis:\n  ?clause2 el formula0 \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "hence \"formulaTrue formula0 valuation\""], ["proof (prove)\nusing this:\n  ?clause2 el formula0 \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation", "by (simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  formulaTrue formula0 valuation\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "with \\<open>model valuation formula\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula\n  formulaTrue formula0 valuation", "have \"model valuation formula0\""], ["proof (prove)\nusing this:\n  model valuation formula\n  formulaTrue formula0 valuation\n\ngoal (1 subgoal):\n 1. model valuation formula0", "by simp"], ["proof (state)\nthis:\n  model valuation formula0\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "thus ?thesis"], ["proof (prove)\nusing this:\n  model valuation formula0\n\ngoal (1 subgoal):\n 1. satisfiable formula0", "by (auto simp add: satisfiable_def)"], ["proof (state)\nthis:\n  satisfiable formula0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  satisfiable formula0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satisfiableAppend: \n  fixes formula1 :: Formula and formula2 :: Formula\n  assumes \"satisfiable (formula1 @ formula2)\" \n  shows \"satisfiable formula1\" \"satisfiable formula2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable formula1 &&& satisfiable formula2", "using assms"], ["proof (prove)\nusing this:\n  satisfiable (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. satisfiable formula1 &&& satisfiable formula2", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>valuation. model valuation (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation formula1 &&&\n    \\<exists>valuation. model valuation formula2", "by (auto simp add:formulaTrueAppend)"], ["", "lemma modelExpand: \n  fixes formula :: Formula and literal :: Literal and valuation :: Valuation\n  assumes \"model valuation formula\" and \"var literal \\<notin> vars valuation\"\n  shows \"model (valuation @ [literal]) formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "from \\<open>model valuation formula\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula", "have \"formulaTrue formula (valuation @ [literal])\""], ["proof (prove)\nusing this:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "by (simp add:formulaTrueAppendValuation)"], ["proof (state)\nthis:\n  formulaTrue formula (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "moreover"], ["proof (state)\nthis:\n  formulaTrue formula (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "from \\<open>model valuation formula\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula", "have \"consistent valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. consistent valuation", "by simp"], ["proof (state)\nthis:\n  consistent valuation\n\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "with \\<open>var literal \\<notin> vars valuation\\<close>"], ["proof (chain)\npicking this:\n  var literal \\<notin> vars valuation\n  consistent valuation", "have \"consistent (valuation @ [literal])\""], ["proof (prove)\nusing this:\n  var literal \\<notin> vars valuation\n  consistent valuation\n\ngoal (1 subgoal):\n 1. consistent (valuation @ [literal])", "proof (cases \"inconsistent (valuation @ [literal])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])\n 2. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "case True"], ["proof (state)\nthis:\n  inconsistent (valuation @ [literal])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])\n 2. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "hence \"inconsistent valuation \\<or> inconsistent [literal] \\<or> (\\<exists> l. literalTrue l valuation \\<and> literalFalse l [literal])\""], ["proof (prove)\nusing this:\n  inconsistent (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. inconsistent valuation \\<or>\n    inconsistent [literal] \\<or>\n    (\\<exists>l. literalTrue l valuation \\<and> literalFalse l [literal])", "by (rule inconsistentAppend)"], ["proof (state)\nthis:\n  inconsistent valuation \\<or>\n  inconsistent [literal] \\<or>\n  (\\<exists>l. literalTrue l valuation \\<and> literalFalse l [literal])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])\n 2. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "with \\<open>consistent valuation\\<close>"], ["proof (chain)\npicking this:\n  consistent valuation\n  inconsistent valuation \\<or>\n  inconsistent [literal] \\<or>\n  (\\<exists>l. literalTrue l valuation \\<and> literalFalse l [literal])", "have \"\\<exists> l. literalTrue l valuation \\<and> literalFalse l [literal]\""], ["proof (prove)\nusing this:\n  consistent valuation\n  inconsistent valuation \\<or>\n  inconsistent [literal] \\<or>\n  (\\<exists>l. literalTrue l valuation \\<and> literalFalse l [literal])\n\ngoal (1 subgoal):\n 1. \\<exists>l. literalTrue l valuation \\<and> literalFalse l [literal]", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. literalTrue l valuation \\<and> literalFalse l [literal]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])\n 2. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "hence \"literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  \\<exists>l. literalTrue l valuation \\<and> literalFalse l [literal]\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "by auto"], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])\n 2. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "hence \"var (opposite literal) \\<in> (vars valuation)\""], ["proof (prove)\nusing this:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. var (opposite literal) \\<in> vars valuation", "using valuationContainsItsLiteralsVariable [of \"opposite literal\" \"valuation\"]"], ["proof (prove)\nusing this:\n  literalFalse literal valuation\n  opposite literal el valuation \\<Longrightarrow>\n  var (opposite literal) \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. var (opposite literal) \\<in> vars valuation", "by simp"], ["proof (state)\nthis:\n  var (opposite literal) \\<in> vars valuation\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])\n 2. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "with \\<open>var literal \\<notin> vars valuation\\<close>"], ["proof (chain)\npicking this:\n  var literal \\<notin> vars valuation\n  var (opposite literal) \\<in> vars valuation", "have \"False\""], ["proof (prove)\nusing this:\n  var literal \\<notin> vars valuation\n  var (opposite literal) \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])\n 2. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. consistent (valuation @ [literal])", ".."], ["proof (state)\nthis:\n  consistent (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var literal \\<notin> vars valuation; consistent valuation;\n     \\<not> inconsistent (valuation @ [literal])\\<rbrakk>\n    \\<Longrightarrow> consistent (valuation @ [literal])", "qed simp"], ["proof (state)\nthis:\n  consistent (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "ultimately"], ["proof (chain)\npicking this:\n  formulaTrue formula (valuation @ [literal])\n  consistent (valuation @ [literal])", "show ?thesis"], ["proof (prove)\nusing this:\n  formulaTrue formula (valuation @ [literal])\n  consistent (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "by auto"], ["proof (state)\nthis:\n  model (valuation @ [literal]) formula\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Tautological clauses\\<close>"], ["", "lemma tautologyNotFalse:\n  fixes clause :: Clause and valuation :: Valuation\n  assumes \"clauseTautology clause\" \"consistent valuation\"\n  shows \"\\<not> clauseFalse clause valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation", "using assms\n  clauseTautologyCharacterization[of \"clause\"]\n  clauseFalseIffAllLiteralsAreFalse[of \"clause\" \"valuation\"]\n  inconsistentCharacterization"], ["proof (prove)\nusing this:\n  clauseTautology clause\n  consistent valuation\n  clauseTautology clause =\n  (\\<exists>literal. literal el clause \\<and> opposite literal el clause)\n  clauseFalse clause valuation =\n  (\\<forall>literal.\n      literal el clause \\<longrightarrow> literalFalse literal valuation)\n  inconsistent ?valuation =\n  (\\<exists>literal.\n      literalTrue literal ?valuation \\<and> literalFalse literal ?valuation)\n\ngoal (1 subgoal):\n 1. \\<not> clauseFalse clause valuation", "by auto"], ["", "lemma tautologyInTotalValuation:\nassumes \n  \"clauseTautology clause\"\n  \"vars clause \\<subseteq> vars valuation\"\nshows\n  \"clauseTrue clause valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "from \\<open>clauseTautology clause\\<close>"], ["proof (chain)\npicking this:\n  clauseTautology clause", "obtain literal\n    where \"literal el clause\" \"opposite literal el clause\""], ["proof (prove)\nusing this:\n  clauseTautology clause\n\ngoal (1 subgoal):\n 1. (\\<And>literal.\n        \\<lbrakk>literal el clause; opposite literal el clause\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: clauseTautologyCharacterization)"], ["proof (state)\nthis:\n  literal el clause\n  opposite literal el clause\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "hence \"var literal \\<in> vars clause\""], ["proof (prove)\nusing this:\n  literal el clause\n  opposite literal el clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "using clauseContainsItsLiteralsVariable[of \"literal\" \"clause\"]"], ["proof (prove)\nusing this:\n  literal el clause\n  opposite literal el clause\n  literal el clause \\<Longrightarrow> var literal \\<in> vars clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "using clauseContainsItsLiteralsVariable[of \"opposite literal\" \"clause\"]"], ["proof (prove)\nusing this:\n  literal el clause\n  opposite literal el clause\n  literal el clause \\<Longrightarrow> var literal \\<in> vars clause\n  opposite literal el clause \\<Longrightarrow>\n  var (opposite literal) \\<in> vars clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars clause", "by simp"], ["proof (state)\nthis:\n  var literal \\<in> vars clause\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "hence \"var literal \\<in> vars valuation\""], ["proof (prove)\nusing this:\n  var literal \\<in> vars clause\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "using \\<open>vars clause \\<subseteq> vars valuation\\<close>"], ["proof (prove)\nusing this:\n  var literal \\<in> vars clause\n  vars clause \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. var literal \\<in> vars valuation", "by auto"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "hence \"literalTrue literal valuation \\<or> literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "using varInClauseVars[of \"var literal\" \"valuation\"]"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  (var literal \\<in> vars valuation) =\n  (\\<exists>literala.\n      literala el valuation \\<and> var literala = var literal)\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "using varInClauseVars[of \"var (opposite literal)\" \"valuation\"]"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  (var literal \\<in> vars valuation) =\n  (\\<exists>literala.\n      literala el valuation \\<and> var literala = var literal)\n  (var (opposite literal) \\<in> vars valuation) =\n  (\\<exists>literala.\n      literala el valuation \\<and> var literala = var (opposite literal))\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "using literalsWithSameVariableAreEqualOrOpposite"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  (var literal \\<in> vars valuation) =\n  (\\<exists>literala.\n      literala el valuation \\<and> var literala = var literal)\n  (var (opposite literal) \\<in> vars valuation) =\n  (\\<exists>literala.\n      literala el valuation \\<and> var literala = var (opposite literal))\n  (var ?literal1.0 = var ?literal2.0) =\n  (?literal1.0 = ?literal2.0 \\<or> opposite ?literal1.0 = ?literal2.0)\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation \\<or> literalFalse literal valuation", "by auto"], ["proof (state)\nthis:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "using \\<open>literal el clause\\<close> \\<open>opposite literal el clause\\<close>"], ["proof (prove)\nusing this:\n  literalTrue literal valuation \\<or> literalFalse literal valuation\n  literal el clause\n  opposite literal el clause\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modelAppendTautology:\nassumes\n  \"model valuation F\" \"clauseTautology c\"\n  \"vars valuation \\<supseteq> vars F \\<union> vars c\"\nshows\n  \"model valuation (F @ [c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model valuation (F @ [c])", "using assms"], ["proof (prove)\nusing this:\n  model valuation F\n  clauseTautology c\n  vars F \\<union> vars c \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation (F @ [c])", "using tautologyInTotalValuation[of \"c\" \"valuation\"]"], ["proof (prove)\nusing this:\n  model valuation F\n  clauseTautology c\n  vars F \\<union> vars c \\<subseteq> vars valuation\n  \\<lbrakk>clauseTautology c; vars c \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> clauseTrue c valuation\n\ngoal (1 subgoal):\n 1. model valuation (F @ [c])", "by (auto simp add: formulaTrueAppend)"], ["", "lemma satisfiableAppendTautology:\nassumes \n  \"satisfiable F\" \"clauseTautology c\"\nshows\n  \"satisfiable (F @ [c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "from \\<open>clauseTautology c\\<close>"], ["proof (chain)\npicking this:\n  clauseTautology c", "obtain l \n    where \"l el c\" \"opposite l el c\""], ["proof (prove)\nusing this:\n  clauseTautology c\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el c; opposite l el c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: clauseTautologyCharacterization)"], ["proof (state)\nthis:\n  l el c\n  opposite l el c\n\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "from \\<open>satisfiable F\\<close>"], ["proof (chain)\npicking this:\n  satisfiable F", "obtain valuation\n    where \"consistent valuation\" \"formulaTrue F valuation\""], ["proof (prove)\nusing this:\n  satisfiable F\n\ngoal (1 subgoal):\n 1. (\\<And>valuation.\n        \\<lbrakk>consistent valuation; formulaTrue F valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>valuation. model valuation F\n\ngoal (1 subgoal):\n 1. (\\<And>valuation.\n        \\<lbrakk>consistent valuation; formulaTrue F valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  consistent valuation\n  formulaTrue F valuation\n\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "proof (cases \"var l \\<in> vars valuation\")"], ["proof (state)\ngoal (2 subgoals):\n 1. var l \\<in> vars valuation \\<Longrightarrow> satisfiable (F @ [c])\n 2. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "case True"], ["proof (state)\nthis:\n  var l \\<in> vars valuation\n\ngoal (2 subgoals):\n 1. var l \\<in> vars valuation \\<Longrightarrow> satisfiable (F @ [c])\n 2. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "hence \"literalTrue l valuation \\<or> literalFalse l valuation\""], ["proof (prove)\nusing this:\n  var l \\<in> vars valuation\n\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<or> literalFalse l valuation", "using varInClauseVars[of \"var l\" \"valuation\"]"], ["proof (prove)\nusing this:\n  var l \\<in> vars valuation\n  (var l \\<in> vars valuation) =\n  (\\<exists>literal. literal el valuation \\<and> var literal = var l)\n\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<or> literalFalse l valuation", "by (auto simp add: literalsWithSameVariableAreEqualOrOpposite)"], ["proof (state)\nthis:\n  literalTrue l valuation \\<or> literalFalse l valuation\n\ngoal (2 subgoals):\n 1. var l \\<in> vars valuation \\<Longrightarrow> satisfiable (F @ [c])\n 2. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "hence \"clauseTrue c valuation\""], ["proof (prove)\nusing this:\n  literalTrue l valuation \\<or> literalFalse l valuation\n\ngoal (1 subgoal):\n 1. clauseTrue c valuation", "using \\<open>l el c\\<close> \\<open>opposite l el c\\<close>"], ["proof (prove)\nusing this:\n  literalTrue l valuation \\<or> literalFalse l valuation\n  l el c\n  opposite l el c\n\ngoal (1 subgoal):\n 1. clauseTrue c valuation", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue c valuation\n\ngoal (2 subgoals):\n 1. var l \\<in> vars valuation \\<Longrightarrow> satisfiable (F @ [c])\n 2. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "thus ?thesis"], ["proof (prove)\nusing this:\n  clauseTrue c valuation\n\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "using \\<open>consistent valuation\\<close> \\<open>formulaTrue F valuation\\<close>"], ["proof (prove)\nusing this:\n  clauseTrue c valuation\n  consistent valuation\n  formulaTrue F valuation\n\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  clauseTrue c valuation\n  consistent valuation\n  formulaTrue F valuation\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation (F @ [c])", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  satisfiable (F @ [c])\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "case False"], ["proof (state)\nthis:\n  var l \\<notin> vars valuation\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "let ?valuation' = \"valuation @ [l]\""], ["proof (state)\ngoal (1 subgoal):\n 1. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "have \"model ?valuation' F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model (valuation @ [l]) F", "using \\<open>var l \\<notin> vars valuation\\<close>"], ["proof (prove)\nusing this:\n  var l \\<notin> vars valuation\n\ngoal (1 subgoal):\n 1. model (valuation @ [l]) F", "using \\<open>formulaTrue F valuation\\<close> \\<open>consistent valuation\\<close>"], ["proof (prove)\nusing this:\n  var l \\<notin> vars valuation\n  formulaTrue F valuation\n  consistent valuation\n\ngoal (1 subgoal):\n 1. model (valuation @ [l]) F", "using modelExpand[of \"valuation\" \"F\" \"l\"]"], ["proof (prove)\nusing this:\n  var l \\<notin> vars valuation\n  formulaTrue F valuation\n  consistent valuation\n  \\<lbrakk>model valuation F; var l \\<notin> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model (valuation @ [l]) F\n\ngoal (1 subgoal):\n 1. model (valuation @ [l]) F", "by simp"], ["proof (state)\nthis:\n  model (valuation @ [l]) F\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "moreover"], ["proof (state)\nthis:\n  model (valuation @ [l]) F\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "have \"formulaTrue [c] ?valuation'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue [c] (valuation @ [l])", "using \\<open>l el c\\<close>"], ["proof (prove)\nusing this:\n  l el c\n\ngoal (1 subgoal):\n 1. formulaTrue [c] (valuation @ [l])", "using clauseTrueIffContainsTrueLiteral[of \"c\" \"?valuation'\"]"], ["proof (prove)\nusing this:\n  l el c\n  clauseTrue c (valuation @ [l]) =\n  (\\<exists>literal.\n      literal el c \\<and> literalTrue literal (valuation @ [l]))\n\ngoal (1 subgoal):\n 1. formulaTrue [c] (valuation @ [l])", "using formulaTrueIffAllClausesAreTrue[of \"[c]\" \"?valuation'\"]"], ["proof (prove)\nusing this:\n  l el c\n  clauseTrue c (valuation @ [l]) =\n  (\\<exists>literal.\n      literal el c \\<and> literalTrue literal (valuation @ [l]))\n  formulaTrue [c] (valuation @ [l]) =\n  (\\<forall>clause.\n      clause el [c] \\<longrightarrow> clauseTrue clause (valuation @ [l]))\n\ngoal (1 subgoal):\n 1. formulaTrue [c] (valuation @ [l])", "by auto"], ["proof (state)\nthis:\n  formulaTrue [c] (valuation @ [l])\n\ngoal (1 subgoal):\n 1. var l \\<notin> vars valuation \\<Longrightarrow> satisfiable (F @ [c])", "ultimately"], ["proof (chain)\npicking this:\n  model (valuation @ [l]) F\n  formulaTrue [c] (valuation @ [l])", "show ?thesis"], ["proof (prove)\nusing this:\n  model (valuation @ [l]) F\n  formulaTrue [c] (valuation @ [l])\n\ngoal (1 subgoal):\n 1. satisfiable (F @ [c])", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  model (valuation @ [l]) F\n  formulaTrue [c] (valuation @ [l])\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation (F @ [c])", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  satisfiable (F @ [c])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  satisfiable (F @ [c])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modelAppendTautologicalFormula:\nfixes\n  F :: Formula and F' :: Formula\nassumes\n  \"model valuation F\" \"\\<forall> c. c el F' \\<longrightarrow> clauseTautology c\"\n  \"vars valuation \\<supseteq> vars F \\<union> vars F'\"\nshows\n  \"model valuation (F @ F')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model valuation (F @ F')", "using assms"], ["proof (prove)\nusing this:\n  model valuation F\n  \\<forall>c. c el F' \\<longrightarrow> clauseTautology c\n  vars F \\<union> vars F' \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation (F @ F')", "proof (induct F')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation F;\n     \\<forall>c. c el [] \\<longrightarrow> clauseTautology c;\n     vars F \\<union> vars [] \\<subseteq> vars valuation\\<rbrakk>\n    \\<Longrightarrow> model valuation (F @ [])\n 2. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>model valuation F;\n                 \\<forall>c. c el F' \\<longrightarrow> clauseTautology c;\n                 vars F \\<union> vars F' \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation (F @ F');\n        model valuation F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c;\n        vars F \\<union> vars (a # F') \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (F @ a # F')", "case Nil"], ["proof (state)\nthis:\n  model valuation F\n  \\<forall>c. c el [] \\<longrightarrow> clauseTautology c\n  vars F \\<union> vars [] \\<subseteq> vars valuation\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation F;\n     \\<forall>c. c el [] \\<longrightarrow> clauseTautology c;\n     vars F \\<union> vars [] \\<subseteq> vars valuation\\<rbrakk>\n    \\<Longrightarrow> model valuation (F @ [])\n 2. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>model valuation F;\n                 \\<forall>c. c el F' \\<longrightarrow> clauseTautology c;\n                 vars F \\<union> vars F' \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation (F @ F');\n        model valuation F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c;\n        vars F \\<union> vars (a # F') \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (F @ a # F')", "thus ?case"], ["proof (prove)\nusing this:\n  model valuation F\n  \\<forall>c. c el [] \\<longrightarrow> clauseTautology c\n  vars F \\<union> vars [] \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation (F @ [])", "by simp"], ["proof (state)\nthis:\n  model valuation (F @ [])\n\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>model valuation F;\n                 \\<forall>c. c el F' \\<longrightarrow> clauseTautology c;\n                 vars F \\<union> vars F' \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation (F @ F');\n        model valuation F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c;\n        vars F \\<union> vars (a # F') \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (F @ a # F')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>model valuation F;\n                 \\<forall>c. c el F' \\<longrightarrow> clauseTautology c;\n                 vars F \\<union> vars F' \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation (F @ F');\n        model valuation F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c;\n        vars F \\<union> vars (a # F') \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (F @ a # F')", "case (Cons c F'')"], ["proof (state)\nthis:\n  \\<lbrakk>model valuation F;\n   \\<forall>c. c el F'' \\<longrightarrow> clauseTautology c;\n   vars F \\<union> vars F'' \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation (F @ F'')\n  model valuation F\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n  vars F \\<union> vars (c # F'') \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>model valuation F;\n                 \\<forall>c. c el F' \\<longrightarrow> clauseTautology c;\n                 vars F \\<union> vars F' \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation (F @ F');\n        model valuation F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c;\n        vars F \\<union> vars (a # F') \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (F @ a # F')", "hence \"model valuation (F @ F'')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>model valuation F;\n   \\<forall>c. c el F'' \\<longrightarrow> clauseTautology c;\n   vars F \\<union> vars F'' \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation (F @ F'')\n  model valuation F\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n  vars F \\<union> vars (c # F'') \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation (F @ F'')", "by simp"], ["proof (state)\nthis:\n  model valuation (F @ F'')\n\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>model valuation F;\n                 \\<forall>c. c el F' \\<longrightarrow> clauseTautology c;\n                 vars F \\<union> vars F' \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation (F @ F');\n        model valuation F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c;\n        vars F \\<union> vars (a # F') \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (F @ a # F')", "hence \"model valuation ((F @ F'') @ [c])\""], ["proof (prove)\nusing this:\n  model valuation (F @ F'')\n\ngoal (1 subgoal):\n 1. model valuation ((F @ F'') @ [c])", "using Cons(3)"], ["proof (prove)\nusing this:\n  model valuation (F @ F'')\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n\ngoal (1 subgoal):\n 1. model valuation ((F @ F'') @ [c])", "using Cons(4)"], ["proof (prove)\nusing this:\n  model valuation (F @ F'')\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n  vars F \\<union> vars (c # F'') \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation ((F @ F'') @ [c])", "using modelAppendTautology[of \"valuation\" \"F @ F''\" \"c\"]"], ["proof (prove)\nusing this:\n  model valuation (F @ F'')\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n  vars F \\<union> vars (c # F'') \\<subseteq> vars valuation\n  \\<lbrakk>model valuation (F @ F''); clauseTautology c;\n   vars (F @ F'') \\<union> vars c \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation ((F @ F'') @ [c])\n\ngoal (1 subgoal):\n 1. model valuation ((F @ F'') @ [c])", "using varsAppendFormulae[of \"F\" \"F''\"]"], ["proof (prove)\nusing this:\n  model valuation (F @ F'')\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n  vars F \\<union> vars (c # F'') \\<subseteq> vars valuation\n  \\<lbrakk>model valuation (F @ F''); clauseTautology c;\n   vars (F @ F'') \\<union> vars c \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation ((F @ F'') @ [c])\n  vars (F @ F'') = vars F \\<union> vars F''\n\ngoal (1 subgoal):\n 1. model valuation ((F @ F'') @ [c])", "by simp"], ["proof (state)\nthis:\n  model valuation ((F @ F'') @ [c])\n\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>model valuation F;\n                 \\<forall>c. c el F' \\<longrightarrow> clauseTautology c;\n                 vars F \\<union> vars F' \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation (F @ F');\n        model valuation F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c;\n        vars F \\<union> vars (a # F') \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (F @ a # F')", "thus ?case"], ["proof (prove)\nusing this:\n  model valuation ((F @ F'') @ [c])\n\ngoal (1 subgoal):\n 1. model valuation (F @ c # F'')", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model valuation (F @ c # F'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satisfiableAppendTautologicalFormula:\nassumes \n  \"satisfiable F\" \"\\<forall> c. c el F' \\<longrightarrow> clauseTautology c\"\nshows\n  \"satisfiable (F @ F')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (F @ F')", "using assms"], ["proof (prove)\nusing this:\n  satisfiable F\n  \\<forall>c. c el F' \\<longrightarrow> clauseTautology c\n\ngoal (1 subgoal):\n 1. satisfiable (F @ F')", "proof (induct F')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>satisfiable F;\n     \\<forall>c. c el [] \\<longrightarrow> clauseTautology c\\<rbrakk>\n    \\<Longrightarrow> satisfiable (F @ [])\n 2. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>satisfiable F;\n                 \\<forall>c.\n                    c el F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n                \\<Longrightarrow> satisfiable (F @ F');\n        satisfiable F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n       \\<Longrightarrow> satisfiable (F @ a # F')", "case Nil"], ["proof (state)\nthis:\n  satisfiable F\n  \\<forall>c. c el [] \\<longrightarrow> clauseTautology c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>satisfiable F;\n     \\<forall>c. c el [] \\<longrightarrow> clauseTautology c\\<rbrakk>\n    \\<Longrightarrow> satisfiable (F @ [])\n 2. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>satisfiable F;\n                 \\<forall>c.\n                    c el F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n                \\<Longrightarrow> satisfiable (F @ F');\n        satisfiable F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n       \\<Longrightarrow> satisfiable (F @ a # F')", "thus ?case"], ["proof (prove)\nusing this:\n  satisfiable F\n  \\<forall>c. c el [] \\<longrightarrow> clauseTautology c\n\ngoal (1 subgoal):\n 1. satisfiable (F @ [])", "by simp"], ["proof (state)\nthis:\n  satisfiable (F @ [])\n\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>satisfiable F;\n                 \\<forall>c.\n                    c el F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n                \\<Longrightarrow> satisfiable (F @ F');\n        satisfiable F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n       \\<Longrightarrow> satisfiable (F @ a # F')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>satisfiable F;\n                 \\<forall>c.\n                    c el F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n                \\<Longrightarrow> satisfiable (F @ F');\n        satisfiable F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n       \\<Longrightarrow> satisfiable (F @ a # F')", "case (Cons c F'')"], ["proof (state)\nthis:\n  \\<lbrakk>satisfiable F;\n   \\<forall>c. c el F'' \\<longrightarrow> clauseTautology c\\<rbrakk>\n  \\<Longrightarrow> satisfiable (F @ F'')\n  satisfiable F\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>satisfiable F;\n                 \\<forall>c.\n                    c el F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n                \\<Longrightarrow> satisfiable (F @ F');\n        satisfiable F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n       \\<Longrightarrow> satisfiable (F @ a # F')", "hence \"satisfiable (F @ F'')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>satisfiable F;\n   \\<forall>c. c el F'' \\<longrightarrow> clauseTautology c\\<rbrakk>\n  \\<Longrightarrow> satisfiable (F @ F'')\n  satisfiable F\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n\ngoal (1 subgoal):\n 1. satisfiable (F @ F'')", "by simp"], ["proof (state)\nthis:\n  satisfiable (F @ F'')\n\ngoal (1 subgoal):\n 1. \\<And>a F'.\n       \\<lbrakk>\\<lbrakk>satisfiable F;\n                 \\<forall>c.\n                    c el F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n                \\<Longrightarrow> satisfiable (F @ F');\n        satisfiable F;\n        \\<forall>c. c el a # F' \\<longrightarrow> clauseTautology c\\<rbrakk>\n       \\<Longrightarrow> satisfiable (F @ a # F')", "thus ?case"], ["proof (prove)\nusing this:\n  satisfiable (F @ F'')\n\ngoal (1 subgoal):\n 1. satisfiable (F @ c # F'')", "using Cons(3)"], ["proof (prove)\nusing this:\n  satisfiable (F @ F'')\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n\ngoal (1 subgoal):\n 1. satisfiable (F @ c # F'')", "using satisfiableAppendTautology[of \"F @ F''\" \"c\"]"], ["proof (prove)\nusing this:\n  satisfiable (F @ F'')\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n  \\<lbrakk>satisfiable (F @ F''); clauseTautology c\\<rbrakk>\n  \\<Longrightarrow> satisfiable ((F @ F'') @ [c])\n\ngoal (1 subgoal):\n 1. satisfiable (F @ c # F'')", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>valuation. model valuation (F @ F'')\n  \\<forall>ca. ca el c # F'' \\<longrightarrow> clauseTautology ca\n  \\<lbrakk>\\<exists>valuation. model valuation (F @ F'');\n   clauseTautology c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>valuation. model valuation ((F @ F'') @ [c])\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation (F @ c # F'')", "by (simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  satisfiable (F @ c # F'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satisfiableFilterTautologies:\nshows \"satisfiable F = satisfiable (filter (% c. \\<not> clauseTautology c) F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable F =\n    satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F)", "proof (induct F)"], ["proof (state)\ngoal (2 subgoals):\n 1. satisfiable [] =\n    satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) [])\n 2. \\<And>a F.\n       satisfiable F =\n       satisfiable\n        (filter (\\<lambda>c. \\<not> clauseTautology c) F) \\<Longrightarrow>\n       satisfiable (a # F) =\n       satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. satisfiable [] =\n    satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) [])\n 2. \\<And>a F.\n       satisfiable F =\n       satisfiable\n        (filter (\\<lambda>c. \\<not> clauseTautology c) F) \\<Longrightarrow>\n       satisfiable (a # F) =\n       satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable [] =\n    satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) [])", "by simp"], ["proof (state)\nthis:\n  satisfiable [] =\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) [])\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       satisfiable F =\n       satisfiable\n        (filter (\\<lambda>c. \\<not> clauseTautology c) F) \\<Longrightarrow>\n       satisfiable (a # F) =\n       satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       satisfiable F =\n       satisfiable\n        (filter (\\<lambda>c. \\<not> clauseTautology c) F) \\<Longrightarrow>\n       satisfiable (a # F) =\n       satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F))", "case (Cons c' F')"], ["proof (state)\nthis:\n  satisfiable F' =\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       satisfiable F =\n       satisfiable\n        (filter (\\<lambda>c. \\<not> clauseTautology c) F) \\<Longrightarrow>\n       satisfiable (a # F) =\n       satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F))", "let ?filt  = \"\\<lambda> F. filter (% c. \\<not> clauseTautology c) F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       satisfiable F =\n       satisfiable\n        (filter (\\<lambda>c. \\<not> clauseTautology c) F) \\<Longrightarrow>\n       satisfiable (a # F) =\n       satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F))", "let ?filt'  = \"\\<lambda> F. filter (% c. clauseTautology c) F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       satisfiable F =\n       satisfiable\n        (filter (\\<lambda>c. \\<not> clauseTautology c) F) \\<Longrightarrow>\n       satisfiable (a # F) =\n       satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (c' # F') =\n    satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. satisfiable (c' # F') \\<Longrightarrow>\n    satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n 2. satisfiable\n     (filter (\\<lambda>c. \\<not> clauseTautology c)\n       (c' # F')) \\<Longrightarrow>\n    satisfiable (c' # F')", "assume \"satisfiable (c' # F')\""], ["proof (state)\nthis:\n  satisfiable (c' # F')\n\ngoal (2 subgoals):\n 1. satisfiable (c' # F') \\<Longrightarrow>\n    satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n 2. satisfiable\n     (filter (\\<lambda>c. \\<not> clauseTautology c)\n       (c' # F')) \\<Longrightarrow>\n    satisfiable (c' # F')", "thus \"satisfiable (?filt (c' # F'))\""], ["proof (prove)\nusing this:\n  satisfiable (c' # F')\n\ngoal (1 subgoal):\n 1. satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>valuation. model valuation (c' # F')\n\ngoal (1 subgoal):\n 1. \\<exists>valuation.\n       model valuation\n        (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n\ngoal (1 subgoal):\n 1. satisfiable\n     (filter (\\<lambda>c. \\<not> clauseTautology c)\n       (c' # F')) \\<Longrightarrow>\n    satisfiable (c' # F')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable\n     (filter (\\<lambda>c. \\<not> clauseTautology c)\n       (c' # F')) \\<Longrightarrow>\n    satisfiable (c' # F')", "assume \"satisfiable (?filt (c' # F'))\""], ["proof (state)\nthis:\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n\ngoal (1 subgoal):\n 1. satisfiable\n     (filter (\\<lambda>c. \\<not> clauseTautology c)\n       (c' # F')) \\<Longrightarrow>\n    satisfiable (c' # F')", "thus \"satisfiable (c' # F')\""], ["proof (prove)\nusing this:\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n\ngoal (1 subgoal):\n 1. satisfiable (c' # F')", "proof (cases \"clauseTautology c'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')\n 2. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "case True"], ["proof (state)\nthis:\n  clauseTautology c'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')\n 2. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "hence \"?filt (c' # F') = ?filt F'\""], ["proof (prove)\nusing this:\n  clauseTautology c'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n    filter (\\<lambda>c. \\<not> clauseTautology c) F'", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  filter (\\<lambda>c. \\<not> clauseTautology c) F'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')\n 2. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "hence \"satisfiable (?filt F')\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  filter (\\<lambda>c. \\<not> clauseTautology c) F'\n\ngoal (1 subgoal):\n 1. satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F')", "using \\<open>satisfiable (?filt (c' # F'))\\<close>"], ["proof (prove)\nusing this:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  filter (\\<lambda>c. \\<not> clauseTautology c) F'\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n\ngoal (1 subgoal):\n 1. satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F')", "by simp"], ["proof (state)\nthis:\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')\n 2. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "hence \"satisfiable F'\""], ["proof (prove)\nusing this:\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. satisfiable F'", "using Cons"], ["proof (prove)\nusing this:\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  satisfiable F' =\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. satisfiable F'", "by simp"], ["proof (state)\nthis:\n  satisfiable F'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')\n 2. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "thus ?thesis"], ["proof (prove)\nusing this:\n  satisfiable F'\n\ngoal (1 subgoal):\n 1. satisfiable (c' # F')", "using satisfiableAppendTautology[of \"F'\" \"c'\"]"], ["proof (prove)\nusing this:\n  satisfiable F'\n  \\<lbrakk>satisfiable F'; clauseTautology c'\\<rbrakk>\n  \\<Longrightarrow> satisfiable (F' @ [c'])\n\ngoal (1 subgoal):\n 1. satisfiable (c' # F')", "using \\<open>clauseTautology c'\\<close>"], ["proof (prove)\nusing this:\n  satisfiable F'\n  \\<lbrakk>satisfiable F'; clauseTautology c'\\<rbrakk>\n  \\<Longrightarrow> satisfiable (F' @ [c'])\n  clauseTautology c'\n\ngoal (1 subgoal):\n 1. satisfiable (c' # F')", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>valuation. model valuation F'\n  \\<lbrakk>\\<exists>valuation. model valuation F';\n   clauseTautology c'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>valuation. model valuation (F' @ [c'])\n  clauseTautology c'\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation (c' # F')", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  satisfiable (c' # F')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "case False"], ["proof (state)\nthis:\n  \\<not> clauseTautology c'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "hence \"?filt (c' # F') = c' # ?filt F'\""], ["proof (prove)\nusing this:\n  \\<not> clauseTautology c'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n    c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "hence \"satisfiable (c' # ?filt F')\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'\n\ngoal (1 subgoal):\n 1. satisfiable (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')", "using \\<open>satisfiable (?filt (c' # F'))\\<close>"], ["proof (prove)\nusing this:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n\ngoal (1 subgoal):\n 1. satisfiable (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')", "by simp"], ["proof (state)\nthis:\n  satisfiable (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "moreover"], ["proof (state)\nthis:\n  satisfiable (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "have \"\\<forall> c. c el ?filt' F' \\<longrightarrow> clauseTautology c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       c el filter clauseTautology F' \\<longrightarrow> clauseTautology c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "ultimately"], ["proof (chain)\npicking this:\n  satisfiable (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c", "have \"satisfiable ((c' # ?filt F') @ ?filt' F')\""], ["proof (prove)\nusing this:\n  satisfiable (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n\ngoal (1 subgoal):\n 1. satisfiable\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')", "using satisfiableAppendTautologicalFormula[of \"c' # ?filt F'\" \"?filt' F'\"]"], ["proof (prove)\nusing this:\n  satisfiable (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n  \\<lbrakk>satisfiable\n            (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F');\n   \\<forall>c.\n      c el filter clauseTautology F' \\<longrightarrow>\n      clauseTautology c\\<rbrakk>\n  \\<Longrightarrow> satisfiable\n                     ((c' #\n                       filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n                      filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. satisfiable\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')", "by (simp (no_asm_use))"], ["proof (state)\nthis:\n  satisfiable\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>satisfiable\n              (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'));\n     \\<not> clauseTautology c'\\<rbrakk>\n    \\<Longrightarrow> satisfiable (c' # F')", "thus ?thesis"], ["proof (prove)\nusing this:\n  satisfiable\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. satisfiable (c' # F')", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>valuation.\n     model valuation\n      ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n       filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation (c' # F')", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  satisfiable (c' # F')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  satisfiable (c' # F')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  satisfiable (c' # F') =\n  satisfiable (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modelFilterTautologies:\nassumes \n  \"model valuation (filter (% c. \\<not> clauseTautology c) F)\" \n  \"vars F \\<subseteq> vars valuation\"\nshows \"model valuation F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model valuation F", "using assms"], ["proof (prove)\nusing this:\n  model valuation (filter (\\<lambda>c. \\<not> clauseTautology c) F)\n  vars F \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation F", "proof (induct F)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation\n              (filter (\\<lambda>c. \\<not> clauseTautology c) []);\n     vars [] \\<subseteq> vars valuation\\<rbrakk>\n    \\<Longrightarrow> model valuation []\n 2. \\<And>a F.\n       \\<lbrakk>\\<lbrakk>model valuation\n                          (filter (\\<lambda>c. \\<not> clauseTautology c) F);\n                 vars F \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation F;\n        model valuation\n         (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F));\n        vars (a # F) \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (a # F)", "case Nil"], ["proof (state)\nthis:\n  model valuation (filter (\\<lambda>c. \\<not> clauseTautology c) [])\n  vars [] \\<subseteq> vars valuation\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation\n              (filter (\\<lambda>c. \\<not> clauseTautology c) []);\n     vars [] \\<subseteq> vars valuation\\<rbrakk>\n    \\<Longrightarrow> model valuation []\n 2. \\<And>a F.\n       \\<lbrakk>\\<lbrakk>model valuation\n                          (filter (\\<lambda>c. \\<not> clauseTautology c) F);\n                 vars F \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation F;\n        model valuation\n         (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F));\n        vars (a # F) \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (a # F)", "thus ?case"], ["proof (prove)\nusing this:\n  model valuation (filter (\\<lambda>c. \\<not> clauseTautology c) [])\n  vars [] \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation []", "by simp"], ["proof (state)\nthis:\n  model valuation []\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<lbrakk>model valuation\n                          (filter (\\<lambda>c. \\<not> clauseTautology c) F);\n                 vars F \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation F;\n        model valuation\n         (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F));\n        vars (a # F) \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (a # F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<lbrakk>model valuation\n                          (filter (\\<lambda>c. \\<not> clauseTautology c) F);\n                 vars F \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation F;\n        model valuation\n         (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F));\n        vars (a # F) \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (a # F)", "case (Cons c' F')"], ["proof (state)\nthis:\n  \\<lbrakk>model valuation\n            (filter (\\<lambda>c. \\<not> clauseTautology c) F');\n   vars F' \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation F'\n  model valuation (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n  vars (c' # F') \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<lbrakk>model valuation\n                          (filter (\\<lambda>c. \\<not> clauseTautology c) F);\n                 vars F \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation F;\n        model valuation\n         (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F));\n        vars (a # F) \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (a # F)", "let ?filt  = \"\\<lambda> F. filter (% c. \\<not> clauseTautology c) F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<lbrakk>model valuation\n                          (filter (\\<lambda>c. \\<not> clauseTautology c) F);\n                 vars F \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation F;\n        model valuation\n         (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F));\n        vars (a # F) \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (a # F)", "let ?filt'  = \"\\<lambda> F. filter (% c. clauseTautology c) F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>\\<lbrakk>model valuation\n                          (filter (\\<lambda>c. \\<not> clauseTautology c) F);\n                 vars F \\<subseteq> vars valuation\\<rbrakk>\n                \\<Longrightarrow> model valuation F;\n        model valuation\n         (filter (\\<lambda>c. \\<not> clauseTautology c) (a # F));\n        vars (a # F) \\<subseteq> vars valuation\\<rbrakk>\n       \\<Longrightarrow> model valuation (a # F)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "proof (cases \"clauseTautology c'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. clauseTautology c' \\<Longrightarrow> model valuation (c' # F')\n 2. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "case True"], ["proof (state)\nthis:\n  clauseTautology c'\n\ngoal (2 subgoals):\n 1. clauseTautology c' \\<Longrightarrow> model valuation (c' # F')\n 2. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "thus ?thesis"], ["proof (prove)\nusing this:\n  clauseTautology c'\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "using Cons"], ["proof (prove)\nusing this:\n  clauseTautology c'\n  \\<lbrakk>model valuation\n            (filter (\\<lambda>c. \\<not> clauseTautology c) F');\n   vars F' \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation F'\n  model valuation (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n  vars (c' # F') \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "using tautologyInTotalValuation[of \"c'\" \"valuation\"]"], ["proof (prove)\nusing this:\n  clauseTautology c'\n  \\<lbrakk>model valuation\n            (filter (\\<lambda>c. \\<not> clauseTautology c) F');\n   vars F' \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation F'\n  model valuation (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n  vars (c' # F') \\<subseteq> vars valuation\n  \\<lbrakk>clauseTautology c'; vars c' \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> clauseTrue c' valuation\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "by auto"], ["proof (state)\nthis:\n  model valuation (c' # F')\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "case False"], ["proof (state)\nthis:\n  \\<not> clauseTautology c'\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "hence \"?filt (c' # F') = c' # ?filt F'\""], ["proof (prove)\nusing this:\n  \\<not> clauseTautology c'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n    c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "hence \"model valuation (c' # ?filt F')\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'\n\ngoal (1 subgoal):\n 1. model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')", "using \\<open>model valuation (?filt (c' # F'))\\<close>"], ["proof (prove)\nusing this:\n  filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F') =\n  c' # filter (\\<lambda>c. \\<not> clauseTautology c) F'\n  model valuation (filter (\\<lambda>c. \\<not> clauseTautology c) (c' # F'))\n\ngoal (1 subgoal):\n 1. model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')", "by simp"], ["proof (state)\nthis:\n  model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "moreover"], ["proof (state)\nthis:\n  model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "have \"\\<forall> c. c el ?filt' F' \\<longrightarrow> clauseTautology c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       c el filter clauseTautology F' \\<longrightarrow> clauseTautology c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "moreover"], ["proof (state)\nthis:\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "have \"vars ((c' # ?filt F') @ ?filt' F') \\<subseteq> vars valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')\n    \\<subseteq> vars valuation", "using varsSubsetFormula[of \"?filt F'\" \"F'\"]"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c el filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<subseteq> vars F'\n\ngoal (1 subgoal):\n 1. vars\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')\n    \\<subseteq> vars valuation", "using varsSubsetFormula[of \"?filt' F'\" \"F'\"]"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c el filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<subseteq> vars F'\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter clauseTautology F') \\<subseteq> vars F'\n\ngoal (1 subgoal):\n 1. vars\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')\n    \\<subseteq> vars valuation", "using varsAppendFormulae[of \"c' # ?filt F'\" \"?filt' F'\"]"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c el filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<subseteq> vars F'\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter clauseTautology F') \\<subseteq> vars F'\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F') =\n  vars (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') \\<union>\n  vars (filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. vars\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')\n    \\<subseteq> vars valuation", "using Cons(3)"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c el filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<subseteq> vars F'\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter clauseTautology F') \\<subseteq> vars F'\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F') =\n  vars (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') \\<union>\n  vars (filter clauseTautology F')\n  vars (c' # F') \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. vars\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')\n    \\<subseteq> vars valuation", "using formulaContainsItsClausesVariables[of _ \"?filt F'\"]"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c el filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<subseteq> vars F'\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow>\n     c el F' \\<Longrightarrow>\n  vars (filter clauseTautology F') \\<subseteq> vars F'\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F') =\n  vars (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') \\<union>\n  vars (filter clauseTautology F')\n  vars (c' # F') \\<subseteq> vars valuation\n  ?clause el\n  filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<Longrightarrow>\n  vars ?clause\n  \\<subseteq> vars (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n\ngoal (1 subgoal):\n 1. vars\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')\n    \\<subseteq> vars valuation", "by auto"], ["proof (state)\nthis:\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "ultimately"], ["proof (chain)\npicking this:\n  model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  \\<subseteq> vars valuation", "have \"model valuation ((c' # ?filt F') @ ?filt' F')\""], ["proof (prove)\nusing this:\n  model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  \\<subseteq> vars valuation\n\ngoal (1 subgoal):\n 1. model valuation\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')", "using modelAppendTautologicalFormula[of \"valuation\" \"c' # ?filt F'\" \"?filt' F'\"]"], ["proof (prove)\nusing this:\n  model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  \\<subseteq> vars valuation\n  \\<lbrakk>model valuation\n            (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F');\n   \\<forall>c.\n      c el filter clauseTautology F' \\<longrightarrow> clauseTautology c;\n   vars (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') \\<union>\n   vars (filter clauseTautology F')\n   \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation\n                     ((c' #\n                       filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n                      filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. model valuation\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')", "using varsAppendFormulae[of \"c' # ?filt F'\" \"?filt' F'\"]"], ["proof (prove)\nusing this:\n  model valuation (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F')\n  \\<forall>c.\n     c el filter clauseTautology F' \\<longrightarrow> clauseTautology c\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  \\<subseteq> vars valuation\n  \\<lbrakk>model valuation\n            (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F');\n   \\<forall>c.\n      c el filter clauseTautology F' \\<longrightarrow> clauseTautology c;\n   vars (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') \\<union>\n   vars (filter clauseTautology F')\n   \\<subseteq> vars valuation\\<rbrakk>\n  \\<Longrightarrow> model valuation\n                     ((c' #\n                       filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n                      filter clauseTautology F')\n  vars\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F') =\n  vars (c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') \\<union>\n  vars (filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. model valuation\n     ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n      filter clauseTautology F')", "by (simp (no_asm_use)) (blast)"], ["proof (state)\nthis:\n  model valuation\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. \\<not> clauseTautology c' \\<Longrightarrow> model valuation (c' # F')", "thus ?thesis"], ["proof (prove)\nusing this:\n  model valuation\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "using formulaTrueAppend[of \"?filt F'\" \"?filt' F'\" \"valuation\"]"], ["proof (prove)\nusing this:\n  model valuation\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  formulaTrue\n   (filter (\\<lambda>c. \\<not> clauseTautology c) F' @\n    filter clauseTautology F')\n   valuation =\n  (formulaTrue (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n    valuation \\<and>\n   formulaTrue (filter clauseTautology F') valuation)\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "using formulaTrueIffAllClausesAreTrue[of \"?filt F'\" \"valuation\"]"], ["proof (prove)\nusing this:\n  model valuation\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  formulaTrue\n   (filter (\\<lambda>c. \\<not> clauseTautology c) F' @\n    filter clauseTautology F')\n   valuation =\n  (formulaTrue (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n    valuation \\<and>\n   formulaTrue (filter clauseTautology F') valuation)\n  formulaTrue (filter (\\<lambda>c. \\<not> clauseTautology c) F') valuation =\n  (\\<forall>clause.\n      clause el\n      filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n      clauseTrue clause valuation)\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "using formulaTrueIffAllClausesAreTrue[of \"?filt' F'\" \"valuation\"]"], ["proof (prove)\nusing this:\n  model valuation\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  formulaTrue\n   (filter (\\<lambda>c. \\<not> clauseTautology c) F' @\n    filter clauseTautology F')\n   valuation =\n  (formulaTrue (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n    valuation \\<and>\n   formulaTrue (filter clauseTautology F') valuation)\n  formulaTrue (filter (\\<lambda>c. \\<not> clauseTautology c) F') valuation =\n  (\\<forall>clause.\n      clause el\n      filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n      clauseTrue clause valuation)\n  formulaTrue (filter clauseTautology F') valuation =\n  (\\<forall>clause.\n      clause el filter clauseTautology F' \\<longrightarrow>\n      clauseTrue clause valuation)\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "using formulaTrueIffAllClausesAreTrue[of \"F'\" \"valuation\"]"], ["proof (prove)\nusing this:\n  model valuation\n   ((c' # filter (\\<lambda>c. \\<not> clauseTautology c) F') @\n    filter clauseTautology F')\n  formulaTrue\n   (filter (\\<lambda>c. \\<not> clauseTautology c) F' @\n    filter clauseTautology F')\n   valuation =\n  (formulaTrue (filter (\\<lambda>c. \\<not> clauseTautology c) F')\n    valuation \\<and>\n   formulaTrue (filter clauseTautology F') valuation)\n  formulaTrue (filter (\\<lambda>c. \\<not> clauseTautology c) F') valuation =\n  (\\<forall>clause.\n      clause el\n      filter (\\<lambda>c. \\<not> clauseTautology c) F' \\<longrightarrow>\n      clauseTrue clause valuation)\n  formulaTrue (filter clauseTautology F') valuation =\n  (\\<forall>clause.\n      clause el filter clauseTautology F' \\<longrightarrow>\n      clauseTrue clause valuation)\n  formulaTrue F' valuation =\n  (\\<forall>clause.\n      clause el F' \\<longrightarrow> clauseTrue clause valuation)\n\ngoal (1 subgoal):\n 1. model valuation (c' # F')", "by auto"], ["proof (state)\nthis:\n  model valuation (c' # F')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  model valuation (c' # F')\n\ngoal:\nNo subgoals!", "qed"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Entailment\\<close>"], ["", "text\\<open>Formula entails literal if it is true in all its models\\<close>"], ["", "definition formulaEntailsLiteral :: \"Formula \\<Rightarrow> Literal \\<Rightarrow> bool\"\nwhere\n\"formulaEntailsLiteral formula literal == \n  \\<forall> (valuation::Valuation). model valuation formula \\<longrightarrow> literalTrue literal valuation\""], ["", "text\\<open>Clause implies literal if it is true in all its models\\<close>"], ["", "definition clauseEntailsLiteral  :: \"Clause \\<Rightarrow> Literal \\<Rightarrow> bool\"\nwhere\n\"clauseEntailsLiteral clause literal == \n  \\<forall> (valuation::Valuation). model valuation clause \\<longrightarrow> literalTrue literal valuation\""], ["", "text\\<open>Formula entails clause if it is true in all its models\\<close>"], ["", "definition formulaEntailsClause  :: \"Formula \\<Rightarrow> Clause \\<Rightarrow> bool\"\nwhere\n\"formulaEntailsClause formula clause == \n  \\<forall> (valuation::Valuation). model valuation formula \\<longrightarrow> model valuation clause\""], ["", "text\\<open>Formula entails valuation if it entails its every literal\\<close>"], ["", "definition formulaEntailsValuation :: \"Formula \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n\"formulaEntailsValuation formula valuation ==\n    \\<forall> literal. literal el valuation \\<longrightarrow> formulaEntailsLiteral formula literal\""], ["", "text\\<open>Formula entails formula if it is true in all its models\\<close>"], ["", "definition formulaEntailsFormula  :: \"Formula \\<Rightarrow> Formula \\<Rightarrow> bool\"\nwhere\nformulaEntailsFormula_def: \"formulaEntailsFormula formula formula' == \n  \\<forall> (valuation::Valuation). model valuation formula \\<longrightarrow> model valuation formula'\""], ["", "lemma singleLiteralClausesEntailItsLiteral: \n  fixes clause :: Clause and literal :: Literal\n  assumes \"length clause = 1\" and \"literal el clause\"\n  shows \"clauseEntailsLiteral clause literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "from assms"], ["proof (chain)\npicking this:\n  length clause = 1\n  literal el clause", "have onlyLiteral: \"\\<forall> l. l el clause \\<longrightarrow> l = literal\""], ["proof (prove)\nusing this:\n  length clause = 1\n  literal el clause\n\ngoal (1 subgoal):\n 1. \\<forall>l. l el clause \\<longrightarrow> l = literal", "using lengthOneImpliesOnlyElement[of \"clause\" \"literal\"]"], ["proof (prove)\nusing this:\n  length clause = 1\n  literal el clause\n  \\<lbrakk>length clause = 1; literal \\<in> set clause\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a'.\n                       a' \\<in> set clause \\<longrightarrow> a' = literal\n\ngoal (1 subgoal):\n 1. \\<forall>l. l el clause \\<longrightarrow> l = literal", "by simp"], ["proof (state)\nthis:\n  \\<forall>l. l el clause \\<longrightarrow> l = literal\n\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "{"], ["proof (state)\nthis:\n  \\<forall>l. l el clause \\<longrightarrow> l = literal\n\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "assume \"clauseTrue clause valuation\""], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "with onlyLiteral"], ["proof (chain)\npicking this:\n  \\<forall>l. l el clause \\<longrightarrow> l = literal\n  clauseTrue clause valuation", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  \\<forall>l. l el clause \\<longrightarrow> l = literal\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (auto simp add:clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "}"], ["proof (state)\nthis:\n  clauseTrue clause ?valuation2 \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  clauseTrue clause ?valuation2 \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. clauseEntailsLiteral clause literal", "by (simp add:clauseEntailsLiteral_def)"], ["proof (state)\nthis:\n  clauseEntailsLiteral clause literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clauseEntailsLiteralThenFormulaEntailsLiteral:\n  fixes clause :: Clause and formula :: Formula and literal :: Literal\n  assumes \"clause el formula\" and \"clauseEntailsLiteral clause literal\"\n  shows \"formulaEntailsLiteral formula literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "assume modelFormula: \"model valuation formula\""], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "with \\<open>clause el formula\\<close>"], ["proof (chain)\npicking this:\n  clause el formula\n  model valuation formula", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  clause el formula\n  model valuation formula\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (simp add:formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "with modelFormula \\<open>clauseEntailsLiteral clause literal\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula\n  clauseEntailsLiteral clause literal\n  clauseTrue clause valuation", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n  clauseEntailsLiteral clause literal\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (auto simp add: clauseEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "}"], ["proof (state)\nthis:\n  model ?valuation2 formula \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 formula \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "by (simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsLiteralAppend: \n  fixes formula :: Formula and formula' :: Formula and literal :: Literal\n  assumes \"formulaEntailsLiteral formula literal\"\n  shows  \"formulaEntailsLiteral (formula @ formula') literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "assume modelFF': \"model valuation (formula @ formula')\""], ["proof (state)\nthis:\n  model valuation (formula @ formula')\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "hence \"formulaTrue formula valuation\""], ["proof (prove)\nusing this:\n  model valuation (formula @ formula')\n\ngoal (1 subgoal):\n 1. formulaTrue formula valuation", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "with modelFF' and \\<open>formulaEntailsLiteral formula literal\\<close>"], ["proof (chain)\npicking this:\n  model valuation (formula @ formula')\n  formulaEntailsLiteral formula literal\n  formulaTrue formula valuation", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  model valuation (formula @ formula')\n  formulaEntailsLiteral formula literal\n  formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (simp add: formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "}"], ["proof (state)\nthis:\n  model ?valuation2 (formula @ formula') \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 (formula @ formula') \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ formula') literal", "by (simp add: formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (formula @ formula') literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsLiteralSubset: \n  fixes formula :: Formula and formula' :: Formula and literal :: Literal\n  assumes \"formulaEntailsLiteral formula literal\" and \"\\<forall> (c::Clause) . c el formula \\<longrightarrow> c el formula'\"\n  shows \"formulaEntailsLiteral formula' literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "assume modelF': \"model valuation formula'\""], ["proof (state)\nthis:\n  model valuation formula'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "with \\<open>\\<forall> (c::Clause) . c el formula \\<longrightarrow> c el formula'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c. c el formula \\<longrightarrow> c el formula'\n  model valuation formula'", "have \"formulaTrue formula valuation\""], ["proof (prove)\nusing this:\n  \\<forall>c. c el formula \\<longrightarrow> c el formula'\n  model valuation formula'\n\ngoal (1 subgoal):\n 1. formulaTrue formula valuation", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "with modelF' \\<open>formulaEntailsLiteral formula literal\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula'\n  formulaEntailsLiteral formula literal\n  formulaTrue formula valuation", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  model valuation formula'\n  formulaEntailsLiteral formula literal\n  formulaTrue formula valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (simp add: formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "}"], ["proof (state)\nthis:\n  model ?valuation2 formula' \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 formula' \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula' literal", "by (simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula' literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsLiteralRemoveAll:\n  fixes formula :: Formula and clause :: Clause and literal :: Literal\n  assumes \"formulaEntailsLiteral (removeAll clause formula) literal\"\n  shows \"formulaEntailsLiteral formula literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "assume modelF: \"model valuation formula\""], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "hence \"formulaTrue (removeAll clause formula) valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. formulaTrue (removeAll clause formula) valuation", "by (auto simp add:formulaTrueRemoveAll)"], ["proof (state)\nthis:\n  formulaTrue (removeAll clause formula) valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "with modelF \\<open>formulaEntailsLiteral (removeAll clause formula) literal\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula\n  formulaEntailsLiteral (removeAll clause formula) literal\n  formulaTrue (removeAll clause formula) valuation", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n  formulaEntailsLiteral (removeAll clause formula) literal\n  formulaTrue (removeAll clause formula) valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (auto simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "}"], ["proof (state)\nthis:\n  model ?valuation2 formula \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 formula \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula literal", "by (simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsLiteralRemoveAllAppend:\n  fixes formula1 :: Formula and formula2 :: Formula and clause :: Clause and valuation :: Valuation\n  assumes \"formulaEntailsLiteral ((removeAll clause formula1) @ formula2) literal\" \n  shows \"formulaEntailsLiteral (formula1 @ formula2) literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "assume modelF: \"model valuation (formula1 @ formula2)\""], ["proof (state)\nthis:\n  model valuation (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "hence \"formulaTrue ((removeAll clause formula1) @ formula2) valuation\""], ["proof (prove)\nusing this:\n  model valuation (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. formulaTrue (removeAll clause formula1 @ formula2) valuation", "by (auto simp add:formulaTrueRemoveAll formulaTrueAppend)"], ["proof (state)\nthis:\n  formulaTrue (removeAll clause formula1 @ formula2) valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "with modelF \\<open>formulaEntailsLiteral ((removeAll clause formula1) @ formula2) literal\\<close>"], ["proof (chain)\npicking this:\n  model valuation (formula1 @ formula2)\n  formulaEntailsLiteral (removeAll clause formula1 @ formula2) literal\n  formulaTrue (removeAll clause formula1 @ formula2) valuation", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  model valuation (formula1 @ formula2)\n  formulaEntailsLiteral (removeAll clause formula1 @ formula2) literal\n  formulaTrue (removeAll clause formula1 @ formula2) valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (auto simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "}"], ["proof (state)\nthis:\n  model ?valuationa2 (formula1 @ formula2) \\<Longrightarrow>\n  literalTrue literal ?valuationa2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuationa2 (formula1 @ formula2) \\<Longrightarrow>\n  literalTrue literal ?valuationa2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1 @ formula2) literal", "by (simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (formula1 @ formula2) literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsItsClauses: \n  fixes clause :: Clause and formula :: Formula\n  assumes \"clause el formula\"\n  shows \"formulaEntailsClause formula clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "using assms"], ["proof (prove)\nusing this:\n  clause el formula\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "by (simp add: formulaEntailsClause_def formulaTrueIffAllClausesAreTrue)"], ["", "lemma formulaEntailsClauseAppend: \n  fixes clause :: Clause and formula :: Formula and formula' :: Formula\n  assumes \"formulaEntailsClause formula clause\"\n  shows \"formulaEntailsClause (formula @ formula') clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "assume \"model valuation (formula @ formula')\""], ["proof (state)\nthis:\n  model valuation (formula @ formula')\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "hence \"model valuation formula\""], ["proof (prove)\nusing this:\n  model valuation (formula @ formula')\n\ngoal (1 subgoal):\n 1. model valuation formula", "by (simp add:formulaTrueAppend)"], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "with \\<open>formulaEntailsClause formula clause\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsClause formula clause\n  model valuation formula", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  formulaEntailsClause formula clause\n  model valuation formula\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (simp add:formulaEntailsClause_def)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "}"], ["proof (state)\nthis:\n  model ?valuation2 (formula @ formula') \\<Longrightarrow>\n  clauseTrue clause ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 (formula @ formula') \\<Longrightarrow>\n  clauseTrue clause ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause (formula @ formula') clause", "by (simp add: formulaEntailsClause_def)"], ["proof (state)\nthis:\n  formulaEntailsClause (formula @ formula') clause\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaUnsatIffImpliesEmptyClause: \n  fixes formula :: Formula\n  shows \"formulaEntailsClause formula [] = (\\<not> satisfiable formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula [] = (\\<not> satisfiable formula)", "by (auto simp add: formulaEntailsClause_def satisfiable_def)"], ["", "lemma formulaTrueExtendWithEntailedClauses:\n  fixes formula :: Formula and formula0 :: Formula and valuation :: Valuation\n  assumes formulaEntailed: \"\\<forall> (clause::Clause). clause el formula \\<longrightarrow> formulaEntailsClause formula0 clause\" and \"consistent valuation\"\n  shows \"formulaTrue formula0 valuation \\<longrightarrow> formulaTrue formula valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<longrightarrow>\n    formulaTrue formula valuation", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "assume \"formulaTrue formula0 valuation\""], ["proof (state)\nthis:\n  formulaTrue formula0 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "{"], ["proof (state)\nthis:\n  formulaTrue formula0 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "fix clause :: Clause"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "assume \"clause el formula\""], ["proof (state)\nthis:\n  clause el formula\n\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "with formulaEntailed"], ["proof (chain)\npicking this:\n  \\<forall>clause.\n     clause el formula \\<longrightarrow>\n     formulaEntailsClause formula0 clause\n  clause el formula", "have \"formulaEntailsClause formula0 clause\""], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     clause el formula \\<longrightarrow>\n     formulaEntailsClause formula0 clause\n  clause el formula\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula0 clause", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause formula0 clause\n\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "with \\<open>formulaTrue formula0 valuation\\<close> \\<open>consistent valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue formula0 valuation\n  consistent valuation\n  formulaEntailsClause formula0 clause", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  formulaTrue formula0 valuation\n  consistent valuation\n  formulaEntailsClause formula0 clause\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (simp add:formulaEntailsClause_def)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "}"], ["proof (state)\nthis:\n  ?clause2 el formula \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula0 valuation \\<Longrightarrow>\n    formulaTrue formula valuation", "thus \"formulaTrue formula valuation\""], ["proof (prove)\nusing this:\n  ?clause2 el formula \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula valuation", "by (simp add:formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  formulaTrue formula valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsFormulaIffEntailsAllItsClauses: \n  fixes formula :: Formula and formula' :: Formula\n  shows \"formulaEntailsFormula formula formula' = (\\<forall> clause::Clause. clause el formula' \\<longrightarrow> formulaEntailsClause formula clause)\"\n     (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsFormula formula formula' =\n    (\\<forall>clause.\n        clause el formula' \\<longrightarrow>\n        formulaEntailsClause formula clause)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. formulaEntailsFormula formula formula' \\<Longrightarrow>\n    \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause\n 2. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "assume ?lhs"], ["proof (state)\nthis:\n  formulaEntailsFormula formula formula'\n\ngoal (2 subgoals):\n 1. formulaEntailsFormula formula formula' \\<Longrightarrow>\n    \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause\n 2. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause", "fix clause :: Clause"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause", "show \"clause el formula' \\<longrightarrow> formulaEntailsClause formula clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause el formula' \\<longrightarrow> formulaEntailsClause formula clause", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. clause el formula' \\<Longrightarrow> formulaEntailsClause formula clause", "assume \"clause el formula'\""], ["proof (state)\nthis:\n  clause el formula'\n\ngoal (1 subgoal):\n 1. clause el formula' \\<Longrightarrow> formulaEntailsClause formula clause", "show \"formulaEntailsClause formula clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "assume \"model valuation formula\""], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "with \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsFormula formula formula'\n  model valuation formula", "have \"model valuation formula'\""], ["proof (prove)\nusing this:\n  formulaEntailsFormula formula formula'\n  model valuation formula\n\ngoal (1 subgoal):\n 1. model valuation formula'", "by (simp add:formulaEntailsFormula_def)"], ["proof (state)\nthis:\n  model valuation formula'\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "with \\<open>clause el formula'\\<close>"], ["proof (chain)\npicking this:\n  clause el formula'\n  model valuation formula'", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  clause el formula'\n  model valuation formula'\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (simp add:formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "}"], ["proof (state)\nthis:\n  model ?valuation2 formula \\<Longrightarrow> clauseTrue clause ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 formula \\<Longrightarrow> clauseTrue clause ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "by (simp add:formulaEntailsClause_def)"], ["proof (state)\nthis:\n  formulaEntailsClause formula clause\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsClause formula clause\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause el formula' \\<longrightarrow> formulaEntailsClause formula clause\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>clause.\n     clause el formula' \\<longrightarrow>\n     formulaEntailsClause formula clause\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "assume ?rhs"], ["proof (state)\nthis:\n  \\<forall>clause.\n     clause el formula' \\<longrightarrow>\n     formulaEntailsClause formula clause\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "thus ?lhs"], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     clause el formula' \\<longrightarrow>\n     formulaEntailsClause formula clause\n\ngoal (1 subgoal):\n 1. formulaEntailsFormula formula formula'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "assume \"model valuation formula\""], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "{"], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "fix clause :: Clause"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "assume \"clause el formula'\""], ["proof (state)\nthis:\n  clause el formula'\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "with \\<open>?rhs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>clause.\n     clause el formula' \\<longrightarrow>\n     formulaEntailsClause formula clause\n  clause el formula'", "have \"formulaEntailsClause formula clause\""], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     clause el formula' \\<longrightarrow>\n     formulaEntailsClause formula clause\n  clause el formula'\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula clause", "by auto"], ["proof (state)\nthis:\n  formulaEntailsClause formula clause\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "with \\<open>model valuation formula\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula\n  formulaEntailsClause formula clause", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n  formulaEntailsClause formula clause\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by (simp add:formulaEntailsClause_def)"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "}"], ["proof (state)\nthis:\n  ?clause2 el formula' \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "hence \"(formulaTrue formula' valuation)\""], ["proof (prove)\nusing this:\n  ?clause2 el formula' \\<Longrightarrow> clauseTrue ?clause2 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula' valuation", "by (simp add:formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  formulaTrue formula' valuation\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "}"], ["proof (state)\nthis:\n  model ?valuation2 formula \\<Longrightarrow>\n  formulaTrue formula' ?valuation2\n\ngoal (1 subgoal):\n 1. \\<forall>clause.\n       clause el formula' \\<longrightarrow>\n       formulaEntailsClause formula clause \\<Longrightarrow>\n    formulaEntailsFormula formula formula'", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 formula \\<Longrightarrow>\n  formulaTrue formula' ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsFormula formula formula'", "by (simp add:formulaEntailsFormula_def)"], ["proof (state)\nthis:\n  formulaEntailsFormula formula formula'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsFormula formula formula'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsFormulaThatEntailsClause: \n  fixes formula1 :: Formula and formula2 :: Formula and clause :: Clause\n  assumes \"formulaEntailsFormula formula1 formula2\" and \"formulaEntailsClause formula2 clause\"\n  shows \"formulaEntailsClause formula1 clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula1 clause", "using assms"], ["proof (prove)\nusing this:\n  formulaEntailsFormula formula1 formula2\n  formulaEntailsClause formula2 clause\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula1 clause", "by (simp add: formulaEntailsClause_def formulaEntailsFormula_def)"], ["", "lemma \n  fixes formula1 :: Formula and formula2 :: Formula and formula1' :: Formula and literal :: Literal\n  assumes \"formulaEntailsLiteral (formula1 @ formula2) literal\" and \"formulaEntailsFormula formula1' formula1\"\n  shows \"formulaEntailsLiteral (formula1' @ formula2) literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "assume \"model valuation (formula1' @ formula2)\""], ["proof (state)\nthis:\n  model valuation (formula1' @ formula2)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "hence \"consistent valuation\" and \"formulaTrue formula1' valuation\"  \"formulaTrue formula2 valuation\""], ["proof (prove)\nusing this:\n  model valuation (formula1' @ formula2)\n\ngoal (1 subgoal):\n 1. consistent valuation &&&\n    formulaTrue formula1' valuation &&& formulaTrue formula2 valuation", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  consistent valuation\n  formulaTrue formula1' valuation\n  formulaTrue formula2 valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "with \\<open>formulaEntailsFormula formula1' formula1\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsFormula formula1' formula1\n  consistent valuation\n  formulaTrue formula1' valuation\n  formulaTrue formula2 valuation", "have \"model valuation formula1\""], ["proof (prove)\nusing this:\n  formulaEntailsFormula formula1' formula1\n  consistent valuation\n  formulaTrue formula1' valuation\n  formulaTrue formula2 valuation\n\ngoal (1 subgoal):\n 1. model valuation formula1", "by (simp add:formulaEntailsFormula_def)"], ["proof (state)\nthis:\n  model valuation formula1\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "with \\<open>formulaTrue formula2 valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue formula2 valuation\n  model valuation formula1", "have \"model valuation (formula1 @ formula2)\""], ["proof (prove)\nusing this:\n  formulaTrue formula2 valuation\n  model valuation formula1\n\ngoal (1 subgoal):\n 1. model valuation (formula1 @ formula2)", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model valuation (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "with \\<open>formulaEntailsLiteral (formula1 @ formula2) literal\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral (formula1 @ formula2) literal\n  model valuation (formula1 @ formula2)", "have \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (formula1 @ formula2) literal\n  model valuation (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by (simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "}"], ["proof (state)\nthis:\n  model ?valuation2 (formula1' @ formula2) \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 (formula1' @ formula2) \\<Longrightarrow>\n  literalTrue literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula1' @ formula2) literal", "by (simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (formula1' @ formula2) literal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaFalseInEntailedValuationIsUnsatisfiable: \n  fixes formula :: Formula and valuation :: Valuation\n  assumes \"formulaFalse formula valuation\" and \n          \"formulaEntailsValuation formula valuation\"\n  shows \"\\<not> satisfiable formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "from \\<open>formulaFalse formula valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse formula valuation", "obtain clause :: Clause\n    where \"clause el formula\" and \"clauseFalse clause valuation\""], ["proof (prove)\nusing this:\n  formulaFalse formula valuation\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>clause el formula; clauseFalse clause valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:formulaFalseIffContainsFalseClause)"], ["proof (state)\nthis:\n  clause el formula\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "{"], ["proof (state)\nthis:\n  clause el formula\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "fix valuation' :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "assume modelV': \"model valuation' formula\""], ["proof (state)\nthis:\n  model valuation' formula\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with \\<open>clause el formula\\<close>"], ["proof (chain)\npicking this:\n  clause el formula\n  model valuation' formula", "obtain literal :: Literal \n      where \"literal el clause\" and \"literalTrue literal valuation'\""], ["proof (prove)\nusing this:\n  clause el formula\n  model valuation' formula\n\ngoal (1 subgoal):\n 1. (\\<And>literal.\n        \\<lbrakk>literal el clause; literalTrue literal valuation'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: formulaTrueIffAllClausesAreTrue clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  literal el clause\n  literalTrue literal valuation'\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with \\<open>clauseFalse clause valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse clause valuation\n  literal el clause\n  literalTrue literal valuation'", "have \"literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  clauseFalse clause valuation\n  literal el clause\n  literalTrue literal valuation'\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "by (auto simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with \\<open>formulaEntailsValuation formula valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsValuation formula valuation\n  literalFalse literal valuation", "have \"formulaEntailsLiteral formula (opposite literal)\""], ["proof (prove)\nusing this:\n  formulaEntailsValuation formula valuation\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula (opposite literal)", "unfolding formulaEntailsValuation_def"], ["proof (prove)\nusing this:\n  \\<forall>literal.\n     literal el valuation \\<longrightarrow>\n     formulaEntailsLiteral formula literal\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula (opposite literal)", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with modelV'"], ["proof (chain)\npicking this:\n  model valuation' formula\n  formulaEntailsLiteral formula (opposite literal)", "have \"literalFalse literal valuation'\""], ["proof (prove)\nusing this:\n  model valuation' formula\n  formulaEntailsLiteral formula (opposite literal)\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation'", "by (auto simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalFalse literal valuation'\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "from \\<open>literalTrue literal valuation'\\<close> \\<open>literalFalse literal valuation'\\<close> modelV'"], ["proof (chain)\npicking this:\n  literalTrue literal valuation'\n  literalFalse literal valuation'\n  model valuation' formula", "have \"False\""], ["proof (prove)\nusing this:\n  literalTrue literal valuation'\n  literalFalse literal valuation'\n  model valuation' formula\n\ngoal (1 subgoal):\n 1. False", "by (simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "}"], ["proof (state)\nthis:\n  model ?valuation'2 formula \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation'2 formula \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "by (auto simp add:satisfiable_def)"], ["proof (state)\nthis:\n  \\<not> satisfiable formula\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaFalseInEntailedOrPureValuationIsUnsatisfiable: \n  fixes formula :: Formula and valuation :: Valuation\n  assumes \"formulaFalse formula valuation\" and \n  \"\\<forall> literal'. literal' el valuation \\<longrightarrow> formulaEntailsLiteral formula literal' \\<or>  \\<not> opposite literal' el formula\"\n  shows \"\\<not> satisfiable formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "from \\<open>formulaFalse formula valuation\\<close>"], ["proof (chain)\npicking this:\n  formulaFalse formula valuation", "obtain clause :: Clause\n    where \"clause el formula\" and \"clauseFalse clause valuation\""], ["proof (prove)\nusing this:\n  formulaFalse formula valuation\n\ngoal (1 subgoal):\n 1. (\\<And>clause.\n        \\<lbrakk>clause el formula; clauseFalse clause valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:formulaFalseIffContainsFalseClause)"], ["proof (state)\nthis:\n  clause el formula\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "{"], ["proof (state)\nthis:\n  clause el formula\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "fix valuation' :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "assume modelV': \"model valuation' formula\""], ["proof (state)\nthis:\n  model valuation' formula\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with \\<open>clause el formula\\<close>"], ["proof (chain)\npicking this:\n  clause el formula\n  model valuation' formula", "obtain literal :: Literal \n      where \"literal el clause\" and \"literalTrue literal valuation'\""], ["proof (prove)\nusing this:\n  clause el formula\n  model valuation' formula\n\ngoal (1 subgoal):\n 1. (\\<And>literal.\n        \\<lbrakk>literal el clause; literalTrue literal valuation'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: formulaTrueIffAllClausesAreTrue clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  literal el clause\n  literalTrue literal valuation'\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with \\<open>clauseFalse clause valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse clause valuation\n  literal el clause\n  literalTrue literal valuation'", "have \"literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  clauseFalse clause valuation\n  literal el clause\n  literalTrue literal valuation'\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "by (auto simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with \\<open>\\<forall> literal'. literal' el valuation \\<longrightarrow> formulaEntailsLiteral formula literal' \\<or>  \\<not> opposite literal' el formula\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>literal'.\n     literal' el valuation \\<longrightarrow>\n     formulaEntailsLiteral formula literal' \\<or>\n     \\<not> opposite literal' el formula\n  literalFalse literal valuation", "have \"formulaEntailsLiteral formula (opposite literal) \\<or> \\<not> literal el formula\""], ["proof (prove)\nusing this:\n  \\<forall>literal'.\n     literal' el valuation \\<longrightarrow>\n     formulaEntailsLiteral formula literal' \\<or>\n     \\<not> opposite literal' el formula\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral formula (opposite literal) \\<or>\n    \\<not> literal el formula", "by auto"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal) \\<or>\n  \\<not> literal el formula\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "moreover"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal) \\<or>\n  \\<not> literal el formula\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "{"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal) \\<or>\n  \\<not> literal el formula\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "assume \"formulaEntailsLiteral formula (opposite literal)\""], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with modelV'"], ["proof (chain)\npicking this:\n  model valuation' formula\n  formulaEntailsLiteral formula (opposite literal)", "have \"literalFalse literal valuation'\""], ["proof (prove)\nusing this:\n  model valuation' formula\n  formulaEntailsLiteral formula (opposite literal)\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation'", "by (auto simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  literalFalse literal valuation'\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "from \\<open>literalTrue literal valuation'\\<close> \\<open>literalFalse literal valuation'\\<close> modelV'"], ["proof (chain)\npicking this:\n  literalTrue literal valuation'\n  literalFalse literal valuation'\n  model valuation' formula", "have \"False\""], ["proof (prove)\nusing this:\n  literalTrue literal valuation'\n  literalFalse literal valuation'\n  model valuation' formula\n\ngoal (1 subgoal):\n 1. False", "by (simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "}"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "moreover"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "{"], ["proof (state)\nthis:\n  formulaEntailsLiteral formula (opposite literal) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "assume \"\\<not> literal el formula\""], ["proof (state)\nthis:\n  \\<not> literal el formula\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "with \\<open>clause el formula\\<close> \\<open>literal el clause\\<close>"], ["proof (chain)\npicking this:\n  clause el formula\n  literal el clause\n  \\<not> literal el formula", "have \"False\""], ["proof (prove)\nusing this:\n  clause el formula\n  literal el clause\n  \\<not> literal el formula\n\ngoal (1 subgoal):\n 1. False", "by (simp add:literalElFormulaCharacterization)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "}"], ["proof (state)\nthis:\n  \\<not> literal el formula \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "ultimately"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral formula (opposite literal) \\<or>\n  \\<not> literal el formula\n  formulaEntailsLiteral formula (opposite literal) \\<Longrightarrow> False\n  \\<not> literal el formula \\<Longrightarrow> False", "have \"False\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral formula (opposite literal) \\<or>\n  \\<not> literal el formula\n  formulaEntailsLiteral formula (opposite literal) \\<Longrightarrow> False\n  \\<not> literal el formula \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "}"], ["proof (state)\nthis:\n  model ?valuation'2 formula \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation'2 formula \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable formula", "by (auto simp add:satisfiable_def)"], ["proof (state)\nthis:\n  \\<not> satisfiable formula\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unsatisfiableFormulaWithSingleLiteralClause:\n  fixes formula :: Formula and literal :: Literal\n  assumes \"\\<not> satisfiable formula\" and \"[literal] el formula\"\n  shows \"formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "assume \"model valuation (removeAll [literal] formula)\""], ["proof (state)\nthis:\n  model valuation (removeAll [literal] formula)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "hence \"literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  model valuation (removeAll [literal] formula)\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "proof (cases \"var literal \\<in> vars valuation\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<in> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation\n 2. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "case True"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<in> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation\n 2. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "{"], ["proof (state)\nthis:\n  var literal \\<in> vars valuation\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<in> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation\n 2. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "assume \"literalTrue literal valuation\""], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<in> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation\n 2. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "with \\<open>model valuation (removeAll [literal] formula)\\<close>"], ["proof (chain)\npicking this:\n  model valuation (removeAll [literal] formula)\n  literalTrue literal valuation", "have \"model valuation formula\""], ["proof (prove)\nusing this:\n  model valuation (removeAll [literal] formula)\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. model valuation formula", "by (auto simp add:formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<in> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation\n 2. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "with \\<open>\\<not> satisfiable formula\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable formula\n  model valuation formula", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable formula\n  model valuation formula\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:satisfiable_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<in> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation\n 2. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "}"], ["proof (state)\nthis:\n  literalTrue literal valuation \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<in> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation\n 2. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "with True"], ["proof (chain)\npicking this:\n  var literal \\<in> vars valuation\n  literalTrue literal valuation \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  literalTrue literal valuation \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "using variableDefinedImpliesLiteralDefined [of \"literal\" \"valuation\"]"], ["proof (prove)\nusing this:\n  var literal \\<in> vars valuation\n  literalTrue literal valuation \\<Longrightarrow> False\n  (var literal \\<in> vars valuation) =\n  (literalTrue literal valuation \\<or> literalFalse literal valuation)\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "by auto"], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "case False"], ["proof (state)\nthis:\n  var literal \\<notin> vars valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "with \\<open>model valuation (removeAll [literal] formula)\\<close>"], ["proof (chain)\npicking this:\n  model valuation (removeAll [literal] formula)\n  var literal \\<notin> vars valuation", "have \"model (valuation @ [literal]) (removeAll [literal] formula)\""], ["proof (prove)\nusing this:\n  model valuation (removeAll [literal] formula)\n  var literal \\<notin> vars valuation\n\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) (removeAll [literal] formula)", "by (rule modelExpand)"], ["proof (state)\nthis:\n  model (valuation @ [literal]) (removeAll [literal] formula)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "hence \n        \"formulaTrue (removeAll [literal] formula) (valuation @ [literal])\" and \"consistent (valuation @ [literal])\""], ["proof (prove)\nusing this:\n  model (valuation @ [literal]) (removeAll [literal] formula)\n\ngoal (1 subgoal):\n 1. formulaTrue (removeAll [literal] formula) (valuation @ [literal]) &&&\n    consistent (valuation @ [literal])", "by auto"], ["proof (state)\nthis:\n  formulaTrue (removeAll [literal] formula) (valuation @ [literal])\n  consistent (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "from \\<open>formulaTrue (removeAll [literal] formula) (valuation @ [literal])\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue (removeAll [literal] formula) (valuation @ [literal])", "have \"formulaTrue formula (valuation @ [literal])\""], ["proof (prove)\nusing this:\n  formulaTrue (removeAll [literal] formula) (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. formulaTrue formula (valuation @ [literal])", "by (rule trueFormulaWithSingleLiteralClause)"], ["proof (state)\nthis:\n  formulaTrue formula (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "with \\<open>consistent (valuation @ [literal])\\<close>"], ["proof (chain)\npicking this:\n  consistent (valuation @ [literal])\n  formulaTrue formula (valuation @ [literal])", "have \"model (valuation @ [literal]) formula\""], ["proof (prove)\nusing this:\n  consistent (valuation @ [literal])\n  formulaTrue formula (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. model (valuation @ [literal]) formula", "by simp"], ["proof (state)\nthis:\n  model (valuation @ [literal]) formula\n\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "with \\<open>\\<not> satisfiable formula\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable formula\n  model (valuation @ [literal]) formula", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable formula\n  model (valuation @ [literal]) formula\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:satisfiable_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>model valuation (removeAll [literal] formula);\n     var literal \\<notin> vars valuation\\<rbrakk>\n    \\<Longrightarrow> literalFalse literal valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", ".."], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "}"], ["proof (state)\nthis:\n  model ?valuation2 (removeAll [literal] formula) \\<Longrightarrow>\n  literalFalse literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 (removeAll [literal] formula) \\<Longrightarrow>\n  literalFalse literal ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)", "by (simp add:formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (removeAll [literal] formula) (opposite literal)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unsatisfiableFormulaWithSingleLiteralClauses:\n  fixes F::Formula and c::Clause\n  assumes \"\\<not> satisfiable (F @ val2form (oppositeLiteralList c))\" \"\\<not> clauseTautology c\"\n  shows \"formulaEntailsClause F c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "fix v::Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "assume \"model v F\""], ["proof (state)\nthis:\n  model v F\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "with \\<open>\\<not> satisfiable (F @ val2form (oppositeLiteralList c))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable (F @ val2form (oppositeLiteralList c))\n  model v F", "have \"\\<not> formulaTrue (val2form (oppositeLiteralList c)) v\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable (F @ val2form (oppositeLiteralList c))\n  model v F\n\ngoal (1 subgoal):\n 1. \\<not> formulaTrue (val2form (oppositeLiteralList c)) v", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<nexists>valuation.\n     model valuation (F @ val2form (oppositeLiteralList c))\n  model v F\n\ngoal (1 subgoal):\n 1. \\<not> formulaTrue (val2form (oppositeLiteralList c)) v", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  \\<not> formulaTrue (val2form (oppositeLiteralList c)) v\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "have \"clauseTrue c v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue c v", "proof (cases \"\\<exists> l. l el c \\<and> (literalTrue l v)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v\n 2. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "case True"], ["proof (state)\nthis:\n  \\<exists>l. l el c \\<and> literalTrue l v\n\ngoal (2 subgoals):\n 1. \\<exists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v\n 2. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>l. l el c \\<and> literalTrue l v\n\ngoal (1 subgoal):\n 1. clauseTrue c v", "using clauseTrueIffContainsTrueLiteral"], ["proof (prove)\nusing this:\n  \\<exists>l. l el c \\<and> literalTrue l v\n  clauseTrue ?clause ?valuation =\n  (\\<exists>literal.\n      literal el ?clause \\<and> literalTrue literal ?valuation)\n\ngoal (1 subgoal):\n 1. clauseTrue c v", "by simp"], ["proof (state)\nthis:\n  clauseTrue c v\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "case False"], ["proof (state)\nthis:\n  \\<nexists>l. l el c \\<and> literalTrue l v\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "let ?v' = \"v @ (oppositeLiteralList c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "have \"\\<not> inconsistent (oppositeLiteralList c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> \\<not> inconsistent (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> inconsistent (oppositeLiteralList c)", "obtain l::Literal\n            where \"l el (oppositeLiteralList c)\" \"opposite l el (oppositeLiteralList c)\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> inconsistent (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el oppositeLiteralList c;\n         opposite l el oppositeLiteralList c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inconsistentCharacterization [of \"oppositeLiteralList c\"]"], ["proof (prove)\nusing this:\n  \\<not> \\<not> inconsistent (oppositeLiteralList c)\n  inconsistent (oppositeLiteralList c) =\n  (\\<exists>literal.\n      literalTrue literal (oppositeLiteralList c) \\<and>\n      literalFalse literal (oppositeLiteralList c))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el oppositeLiteralList c;\n         opposite l el oppositeLiteralList c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l el oppositeLiteralList c\n  opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "hence \"(opposite l) el c\" \"l el c\""], ["proof (prove)\nusing this:\n  l el oppositeLiteralList c\n  opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. opposite l el c &&& l el c", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"c\"]"], ["proof (prove)\nusing this:\n  l el oppositeLiteralList c\n  opposite l el oppositeLiteralList c\n  l el c = opposite l el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. opposite l el c &&& l el c", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"opposite l\" \"c\"]"], ["proof (prove)\nusing this:\n  l el oppositeLiteralList c\n  opposite l el oppositeLiteralList c\n  l el c = opposite l el oppositeLiteralList c\n  opposite l el c = opposite (opposite l) el oppositeLiteralList c\n\ngoal (1 subgoal):\n 1. opposite l el c &&& l el c", "by auto"], ["proof (state)\nthis:\n  opposite l el c\n  l el c\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "hence \"clauseTautology c\""], ["proof (prove)\nusing this:\n  opposite l el c\n  l el c\n\ngoal (1 subgoal):\n 1. clauseTautology c", "using clauseTautologyCharacterization[of \"c\"]"], ["proof (prove)\nusing this:\n  opposite l el c\n  l el c\n  clauseTautology c =\n  (\\<exists>literal. literal el c \\<and> opposite literal el c)\n\ngoal (1 subgoal):\n 1. clauseTautology c", "by auto"], ["proof (state)\nthis:\n  clauseTautology c\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "with \\<open>\\<not> clauseTautology c\\<close>"], ["proof (chain)\npicking this:\n  \\<not> clauseTautology c\n  clauseTautology c", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> clauseTautology c\n  clauseTautology c\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "}"], ["proof (state)\nthis:\n  \\<not> \\<not> inconsistent (oppositeLiteralList c) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<not> inconsistent (oppositeLiteralList c) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (oppositeLiteralList c)", "by auto"], ["proof (state)\nthis:\n  \\<not> inconsistent (oppositeLiteralList c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> inconsistent (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "with False \\<open>model v F\\<close>"], ["proof (chain)\npicking this:\n  \\<nexists>l. l el c \\<and> literalTrue l v\n  model v F\n  \\<not> inconsistent (oppositeLiteralList c)", "have \"consistent ?v'\""], ["proof (prove)\nusing this:\n  \\<nexists>l. l el c \\<and> literalTrue l v\n  model v F\n  \\<not> inconsistent (oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. consistent (v @ oppositeLiteralList c)", "using inconsistentAppend[of \"v\" \"oppositeLiteralList c\"]"], ["proof (prove)\nusing this:\n  \\<nexists>l. l el c \\<and> literalTrue l v\n  model v F\n  \\<not> inconsistent (oppositeLiteralList c)\n  inconsistent (v @ oppositeLiteralList c) \\<Longrightarrow>\n  inconsistent v \\<or>\n  inconsistent (oppositeLiteralList c) \\<or>\n  (\\<exists>literal.\n      literalTrue literal v \\<and>\n      literalFalse literal (oppositeLiteralList c))\n\ngoal (1 subgoal):\n 1. consistent (v @ oppositeLiteralList c)", "unfolding consistent_def"], ["proof (prove)\nusing this:\n  \\<nexists>l. l el c \\<and> literalTrue l v\n  model v F\n  \\<not> inconsistent (oppositeLiteralList c)\n  inconsistent (v @ oppositeLiteralList c) \\<Longrightarrow>\n  inconsistent v \\<or>\n  inconsistent (oppositeLiteralList c) \\<or>\n  (\\<exists>literal.\n      literalTrue literal v \\<and>\n      literalFalse literal (oppositeLiteralList c))\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (v @ oppositeLiteralList c)", "using literalElListIffOppositeLiteralElOppositeLiteralList"], ["proof (prove)\nusing this:\n  \\<nexists>l. l el c \\<and> literalTrue l v\n  model v F\n  \\<not> inconsistent (oppositeLiteralList c)\n  inconsistent (v @ oppositeLiteralList c) \\<Longrightarrow>\n  inconsistent v \\<or>\n  inconsistent (oppositeLiteralList c) \\<or>\n  (\\<exists>literal.\n      literalTrue literal v \\<and>\n      literalFalse literal (oppositeLiteralList c))\n  ?literal el ?literalList =\n  opposite ?literal el oppositeLiteralList ?literalList\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent (v @ oppositeLiteralList c)", "by auto"], ["proof (state)\nthis:\n  consistent (v @ oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "moreover"], ["proof (state)\nthis:\n  consistent (v @ oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "from \\<open>model v F\\<close>"], ["proof (chain)\npicking this:\n  model v F", "have \"formulaTrue F ?v'\""], ["proof (prove)\nusing this:\n  model v F\n\ngoal (1 subgoal):\n 1. formulaTrue F (v @ oppositeLiteralList c)", "using formulaTrueAppendValuation"], ["proof (prove)\nusing this:\n  model v F\n  formulaTrue ?formula ?valuation \\<Longrightarrow>\n  formulaTrue ?formula (?valuation @ ?valuation')\n\ngoal (1 subgoal):\n 1. formulaTrue F (v @ oppositeLiteralList c)", "by simp"], ["proof (state)\nthis:\n  formulaTrue F (v @ oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "moreover"], ["proof (state)\nthis:\n  formulaTrue F (v @ oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "have \"formulaTrue (val2form (oppositeLiteralList c)) ?v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaTrue (val2form (oppositeLiteralList c))\n     (v @ oppositeLiteralList c)", "using val2formFormulaTrue[of \"oppositeLiteralList c\" \"v @ oppositeLiteralList c\"]"], ["proof (prove)\nusing this:\n  formulaTrue (val2form (oppositeLiteralList c))\n   (v @ oppositeLiteralList c) =\n  (\\<forall>literal.\n      literal el oppositeLiteralList c \\<longrightarrow>\n      literal el v @ oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. formulaTrue (val2form (oppositeLiteralList c))\n     (v @ oppositeLiteralList c)", "by simp"], ["proof (state)\nthis:\n  formulaTrue (val2form (oppositeLiteralList c)) (v @ oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "ultimately"], ["proof (chain)\npicking this:\n  consistent (v @ oppositeLiteralList c)\n  formulaTrue F (v @ oppositeLiteralList c)\n  formulaTrue (val2form (oppositeLiteralList c)) (v @ oppositeLiteralList c)", "have \"model ?v' (F @ val2form (oppositeLiteralList c))\""], ["proof (prove)\nusing this:\n  consistent (v @ oppositeLiteralList c)\n  formulaTrue F (v @ oppositeLiteralList c)\n  formulaTrue (val2form (oppositeLiteralList c)) (v @ oppositeLiteralList c)\n\ngoal (1 subgoal):\n 1. model (v @ oppositeLiteralList c) (F @ val2form (oppositeLiteralList c))", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model (v @ oppositeLiteralList c) (F @ val2form (oppositeLiteralList c))\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "with \\<open>\\<not> satisfiable (F @ val2form (oppositeLiteralList c))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable (F @ val2form (oppositeLiteralList c))\n  model (v @ oppositeLiteralList c) (F @ val2form (oppositeLiteralList c))", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable (F @ val2form (oppositeLiteralList c))\n  model (v @ oppositeLiteralList c) (F @ val2form (oppositeLiteralList c))\n\ngoal (1 subgoal):\n 1. False", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<nexists>valuation.\n     model valuation (F @ val2form (oppositeLiteralList c))\n  model (v @ oppositeLiteralList c) (F @ val2form (oppositeLiteralList c))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>l. l el c \\<and> literalTrue l v \\<Longrightarrow>\n    clauseTrue c v", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. clauseTrue c v", "by simp"], ["proof (state)\nthis:\n  clauseTrue c v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseTrue c v\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "}"], ["proof (state)\nthis:\n  model ?v2 F \\<Longrightarrow> clauseTrue c ?v2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?v2 F \\<Longrightarrow> clauseTrue c ?v2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F c", "unfolding formulaEntailsClause_def"], ["proof (prove)\nusing this:\n  model ?v2 F \\<Longrightarrow> clauseTrue c ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation F \\<longrightarrow> model valuation c", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause F c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satisfiableEntailedFormula:\n  fixes formula0 :: Formula and formula :: Formula\n  assumes \"formulaEntailsFormula formula0 formula\"\n  shows \"satisfiable formula0 \\<longrightarrow> satisfiable formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable formula0 \\<longrightarrow> satisfiable formula", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable formula0 \\<Longrightarrow> satisfiable formula", "assume \"satisfiable formula0\""], ["proof (state)\nthis:\n  satisfiable formula0\n\ngoal (1 subgoal):\n 1. satisfiable formula0 \\<Longrightarrow> satisfiable formula", "show \"satisfiable formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable formula", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable formula", "from \\<open>satisfiable formula0\\<close>"], ["proof (chain)\npicking this:\n  satisfiable formula0", "obtain valuation :: Valuation\n      where \"model valuation formula0\""], ["proof (prove)\nusing this:\n  satisfiable formula0\n\ngoal (1 subgoal):\n 1. (\\<And>valuation.\n        model valuation formula0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: satisfiable_def)"], ["proof (state)\nthis:\n  model valuation formula0\n\ngoal (1 subgoal):\n 1. satisfiable formula", "with \\<open>formulaEntailsFormula formula0 formula\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsFormula formula0 formula\n  model valuation formula0", "have \"model valuation formula\""], ["proof (prove)\nusing this:\n  formulaEntailsFormula formula0 formula\n  model valuation formula0\n\ngoal (1 subgoal):\n 1. model valuation formula", "by (simp add: formulaEntailsFormula_def)"], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. satisfiable formula", "thus ?thesis"], ["proof (prove)\nusing this:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. satisfiable formula", "by (auto simp add: satisfiable_def)"], ["proof (state)\nthis:\n  satisfiable formula\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  satisfiable formula\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma val2formIsEntailed:\nshows \"formulaEntailsValuation (F' @ val2form valuation @ F'') valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "fix l::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "assume \"l el valuation\""], ["proof (state)\nthis:\n  l el valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "hence \"[l] el val2form valuation\""], ["proof (prove)\nusing this:\n  l el valuation\n\ngoal (1 subgoal):\n 1. [l] el val2form valuation", "by (induct valuation) (auto)"], ["proof (state)\nthis:\n  [l] el val2form valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "have \"formulaEntailsLiteral (F' @ val2form valuation @ F'') l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "fix valuation'::Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "assume \"formulaTrue (F' @ val2form valuation @ F'') valuation'\""], ["proof (state)\nthis:\n  formulaTrue (F' @ val2form valuation @ F'') valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "hence \"literalTrue l valuation'\""], ["proof (prove)\nusing this:\n  formulaTrue (F' @ val2form valuation @ F'') valuation'\n\ngoal (1 subgoal):\n 1. literalTrue l valuation'", "using \\<open>[l] el val2form valuation\\<close>"], ["proof (prove)\nusing this:\n  formulaTrue (F' @ val2form valuation @ F'') valuation'\n  [l] el val2form valuation\n\ngoal (1 subgoal):\n 1. literalTrue l valuation'", "using formulaTrueIffAllClausesAreTrue[of \"F' @ val2form valuation @ F''\" \"valuation'\"]"], ["proof (prove)\nusing this:\n  formulaTrue (F' @ val2form valuation @ F'') valuation'\n  [l] el val2form valuation\n  formulaTrue (F' @ val2form valuation @ F'') valuation' =\n  (\\<forall>clause.\n      clause el F' @ val2form valuation @ F'' \\<longrightarrow>\n      clauseTrue clause valuation')\n\ngoal (1 subgoal):\n 1. literalTrue l valuation'", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  literalTrue l valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "}"], ["proof (state)\nthis:\n  formulaTrue (F' @ val2form valuation @ F'') ?valuation'2 \\<Longrightarrow>\n  literalTrue l ?valuation'2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "thus ?thesis"], ["proof (prove)\nusing this:\n  formulaTrue (F' @ val2form valuation @ F'') ?valuation'2 \\<Longrightarrow>\n  literalTrue l ?valuation'2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F' @ val2form valuation @ F'') l", "unfolding formulaEntailsLiteral_def"], ["proof (prove)\nusing this:\n  formulaTrue (F' @ val2form valuation @ F'') ?valuation'2 \\<Longrightarrow>\n  literalTrue l ?valuation'2\n\ngoal (1 subgoal):\n 1. \\<forall>valuationa.\n       model valuationa (F' @ val2form valuation @ F'') \\<longrightarrow>\n       literalTrue l valuationa", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F' @ val2form valuation @ F'') l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F' @ val2form valuation @ F'') l\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "}"], ["proof (state)\nthis:\n  ?l2 el valuation \\<Longrightarrow>\n  formulaEntailsLiteral (F' @ val2form valuation @ F'') ?l2\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el valuation \\<Longrightarrow>\n  formulaEntailsLiteral (F' @ val2form valuation @ F'') ?l2\n\ngoal (1 subgoal):\n 1. formulaEntailsValuation (F' @ val2form valuation @ F'') valuation", "unfolding formulaEntailsValuation_def"], ["proof (prove)\nusing this:\n  ?l2 el valuation \\<Longrightarrow>\n  formulaEntailsLiteral (F' @ val2form valuation @ F'') ?l2\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el valuation \\<longrightarrow>\n       formulaEntailsLiteral (F' @ val2form valuation @ F'') literal", "by simp"], ["proof (state)\nthis:\n  formulaEntailsValuation (F' @ val2form valuation @ F'') valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "(*------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Equivalency\\<close>"], ["", "text\\<open>Formulas are equivalent if they have same models.\\<close>"], ["", "definition equivalentFormulae :: \"Formula \\<Rightarrow> Formula \\<Rightarrow> bool\"\nwhere\n\"equivalentFormulae formula1 formula2 ==\n  \\<forall> (valuation::Valuation). model valuation formula1 = model valuation formula2\""], ["", "lemma equivalentFormulaeIffEntailEachOther:\n  fixes formula1 :: Formula and formula2 :: Formula\n  shows \"equivalentFormulae formula1 formula2 = (formulaEntailsFormula formula1 formula2 \\<and> formulaEntailsFormula formula2 formula1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae formula1 formula2 =\n    (formulaEntailsFormula formula1 formula2 \\<and>\n     formulaEntailsFormula formula2 formula1)", "by (auto simp add:formulaEntailsFormula_def equivalentFormulae_def)"], ["", "lemma equivalentFormulaeReflexivity: \n  fixes formula :: Formula\n  shows \"equivalentFormulae formula formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae formula formula", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valuation. model valuation formula = model valuation formula", "by auto"], ["", "lemma equivalentFormulaeSymmetry: \n  fixes formula1 :: Formula and formula2 :: Formula\n  shows \"equivalentFormulae formula1 formula2 = equivalentFormulae formula2 formula1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae formula1 formula2 =\n    equivalentFormulae formula2 formula1", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>valuation.\n        model valuation formula1 = model valuation formula2) =\n    (\\<forall>valuation.\n        model valuation formula2 = model valuation formula1)", "by auto"], ["", "lemma equivalentFormulaeTransitivity: \n  fixes formula1 :: Formula and formula2 :: Formula and formula3 :: Formula\n  assumes \"equivalentFormulae formula1 formula2\" and \"equivalentFormulae formula2 formula3\"\n  shows \"equivalentFormulae formula1 formula3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae formula1 formula3", "using assms"], ["proof (prove)\nusing this:\n  equivalentFormulae formula1 formula2\n  equivalentFormulae formula2 formula3\n\ngoal (1 subgoal):\n 1. equivalentFormulae formula1 formula3", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation formula1 = model valuation formula2\n  \\<forall>valuation. model valuation formula2 = model valuation formula3\n\ngoal (1 subgoal):\n 1. \\<forall>valuation. model valuation formula1 = model valuation formula3", "by auto"], ["", "lemma equivalentFormulaeAppend: \n  fixes formula1 :: Formula and formula1' :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula1 formula1'\"\n  shows \"equivalentFormulae (formula1 @ formula2) (formula1' @ formula2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae (formula1 @ formula2) (formula1' @ formula2)", "using assms"], ["proof (prove)\nusing this:\n  equivalentFormulae formula1 formula1'\n\ngoal (1 subgoal):\n 1. equivalentFormulae (formula1 @ formula2) (formula1' @ formula2)", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation formula1 = model valuation formula1'\n\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation (formula1 @ formula2) =\n       model valuation (formula1' @ formula2)", "by (auto simp add: formulaTrueAppend)"], ["", "lemma satisfiableEquivalent: \n  fixes formula1 :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula1 formula2\"\n  shows \"satisfiable formula1 = satisfiable formula2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable formula1 = satisfiable formula2", "using assms"], ["proof (prove)\nusing this:\n  equivalentFormulae formula1 formula2\n\ngoal (1 subgoal):\n 1. satisfiable formula1 = satisfiable formula2", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation formula1 = model valuation formula2\n\ngoal (1 subgoal):\n 1. satisfiable formula1 = satisfiable formula2", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation formula1 = model valuation formula2\n\ngoal (1 subgoal):\n 1. (\\<exists>valuation. model valuation formula1) =\n    (\\<exists>valuation. model valuation formula2)", "by auto"], ["", "lemma satisfiableEquivalentAppend: \n  fixes formula1 :: Formula and formula1' :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula1 formula1'\" and \"satisfiable (formula1 @ formula2)\"\n  shows \"satisfiable (formula1' @ formula2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (formula1' @ formula2)", "using assms"], ["proof (prove)\nusing this:\n  equivalentFormulae formula1 formula1'\n  satisfiable (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. satisfiable (formula1' @ formula2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>equivalentFormulae formula1 formula1';\n     satisfiable (formula1 @ formula2)\\<rbrakk>\n    \\<Longrightarrow> satisfiable (formula1' @ formula2)", "from \\<open>satisfiable (formula1 @ formula2)\\<close>"], ["proof (chain)\npicking this:\n  satisfiable (formula1 @ formula2)", "obtain valuation::Valuation\n    where \"consistent valuation\" \"formulaTrue formula1 valuation\" \"formulaTrue formula2 valuation\""], ["proof (prove)\nusing this:\n  satisfiable (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. (\\<And>valuation.\n        \\<lbrakk>consistent valuation; formulaTrue formula1 valuation;\n         formulaTrue formula2 valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>valuation. model valuation (formula1 @ formula2)\n\ngoal (1 subgoal):\n 1. (\\<And>valuation.\n        \\<lbrakk>consistent valuation; formulaTrue formula1 valuation;\n         formulaTrue formula2 valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  consistent valuation\n  formulaTrue formula1 valuation\n  formulaTrue formula2 valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>equivalentFormulae formula1 formula1';\n     satisfiable (formula1 @ formula2)\\<rbrakk>\n    \\<Longrightarrow> satisfiable (formula1' @ formula2)", "from \\<open>equivalentFormulae formula1 formula1'\\<close> \\<open>consistent valuation\\<close> \\<open>formulaTrue formula1 valuation\\<close>"], ["proof (chain)\npicking this:\n  equivalentFormulae formula1 formula1'\n  consistent valuation\n  formulaTrue formula1 valuation", "have \"formulaTrue formula1' valuation\""], ["proof (prove)\nusing this:\n  equivalentFormulae formula1 formula1'\n  consistent valuation\n  formulaTrue formula1 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula1' valuation", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation formula1 = model valuation formula1'\n  consistent valuation\n  formulaTrue formula1 valuation\n\ngoal (1 subgoal):\n 1. formulaTrue formula1' valuation", "by auto"], ["proof (state)\nthis:\n  formulaTrue formula1' valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>equivalentFormulae formula1 formula1';\n     satisfiable (formula1 @ formula2)\\<rbrakk>\n    \\<Longrightarrow> satisfiable (formula1' @ formula2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable (formula1' @ formula2)", "using \\<open>consistent valuation\\<close> \\<open>formulaTrue formula1' valuation\\<close> \\<open>formulaTrue formula2 valuation\\<close>"], ["proof (prove)\nusing this:\n  consistent valuation\n  formulaTrue formula1' valuation\n  formulaTrue formula2 valuation\n\ngoal (1 subgoal):\n 1. satisfiable (formula1' @ formula2)", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  consistent valuation\n  formulaTrue formula1' valuation\n  formulaTrue formula2 valuation\n\ngoal (1 subgoal):\n 1. \\<exists>valuation. model valuation (formula1' @ formula2)", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  satisfiable (formula1' @ formula2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replaceEquivalentByEquivalent:\n  fixes formula :: Formula and formula' :: Formula and formula1 :: Formula and formula2 :: Formula\n  assumes \"equivalentFormulae formula formula'\" \n  shows \"equivalentFormulae (formula1 @ formula @ formula2) (formula1 @ formula' @ formula2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae (formula1 @ formula @ formula2)\n     (formula1 @ formula' @ formula2)", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation (formula1 @ formula @ formula2) =\n       model valuation (formula1 @ formula' @ formula2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation (formula1 @ formula @ formula2) =\n       model valuation (formula1 @ formula' @ formula2)", "fix v :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation (formula1 @ formula @ formula2) =\n       model valuation (formula1 @ formula' @ formula2)", "show \"model v (formula1 @ formula @ formula2) = model v (formula1 @ formula' @ formula2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model v (formula1 @ formula @ formula2) =\n    model v (formula1 @ formula' @ formula2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. model v (formula1 @ formula @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula' @ formula2)\n 2. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "assume \"model v (formula1 @ formula @ formula2)\""], ["proof (state)\nthis:\n  model v (formula1 @ formula @ formula2)\n\ngoal (2 subgoals):\n 1. model v (formula1 @ formula @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula' @ formula2)\n 2. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "hence *: \"consistent v\" \"formulaTrue formula1 v\" \"formulaTrue formula v\" \"formulaTrue formula2 v\""], ["proof (prove)\nusing this:\n  model v (formula1 @ formula @ formula2)\n\ngoal (1 subgoal):\n 1. (consistent v &&& formulaTrue formula1 v) &&&\n    formulaTrue formula v &&& formulaTrue formula2 v", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  consistent v\n  formulaTrue formula1 v\n  formulaTrue formula v\n  formulaTrue formula2 v\n\ngoal (2 subgoals):\n 1. model v (formula1 @ formula @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula' @ formula2)\n 2. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "from \\<open>consistent v\\<close> \\<open>formulaTrue formula v\\<close> \\<open>equivalentFormulae formula formula'\\<close>"], ["proof (chain)\npicking this:\n  consistent v\n  formulaTrue formula v\n  equivalentFormulae formula formula'", "have \"formulaTrue formula' v\""], ["proof (prove)\nusing this:\n  consistent v\n  formulaTrue formula v\n  equivalentFormulae formula formula'\n\ngoal (1 subgoal):\n 1. formulaTrue formula' v", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  consistent v\n  formulaTrue formula v\n  \\<forall>valuation. model valuation formula = model valuation formula'\n\ngoal (1 subgoal):\n 1. formulaTrue formula' v", "by auto"], ["proof (state)\nthis:\n  formulaTrue formula' v\n\ngoal (2 subgoals):\n 1. model v (formula1 @ formula @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula' @ formula2)\n 2. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "thus \"model v (formula1 @ formula' @ formula2)\""], ["proof (prove)\nusing this:\n  formulaTrue formula' v\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula' @ formula2)", "using *"], ["proof (prove)\nusing this:\n  formulaTrue formula' v\n  consistent v\n  formulaTrue formula1 v\n  formulaTrue formula v\n  formulaTrue formula2 v\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula' @ formula2)", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model v (formula1 @ formula' @ formula2)\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "assume \"model v (formula1 @ formula' @ formula2)\""], ["proof (state)\nthis:\n  model v (formula1 @ formula' @ formula2)\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "hence *: \"consistent v\" \"formulaTrue formula1 v\" \"formulaTrue formula' v\" \"formulaTrue formula2 v\""], ["proof (prove)\nusing this:\n  model v (formula1 @ formula' @ formula2)\n\ngoal (1 subgoal):\n 1. (consistent v &&& formulaTrue formula1 v) &&&\n    formulaTrue formula' v &&& formulaTrue formula2 v", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  consistent v\n  formulaTrue formula1 v\n  formulaTrue formula' v\n  formulaTrue formula2 v\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "from \\<open>consistent v\\<close> \\<open>formulaTrue formula' v\\<close> \\<open>equivalentFormulae formula formula'\\<close>"], ["proof (chain)\npicking this:\n  consistent v\n  formulaTrue formula' v\n  equivalentFormulae formula formula'", "have \"formulaTrue formula v\""], ["proof (prove)\nusing this:\n  consistent v\n  formulaTrue formula' v\n  equivalentFormulae formula formula'\n\ngoal (1 subgoal):\n 1. formulaTrue formula v", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  consistent v\n  formulaTrue formula' v\n  \\<forall>valuation. model valuation formula = model valuation formula'\n\ngoal (1 subgoal):\n 1. formulaTrue formula v", "by auto"], ["proof (state)\nthis:\n  formulaTrue formula v\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula' @ formula2) \\<Longrightarrow>\n    model v (formula1 @ formula @ formula2)", "thus \"model v (formula1 @ formula @ formula2)\""], ["proof (prove)\nusing this:\n  formulaTrue formula v\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula @ formula2)", "using *"], ["proof (prove)\nusing this:\n  formulaTrue formula v\n  consistent v\n  formulaTrue formula1 v\n  formulaTrue formula' v\n  formulaTrue formula2 v\n\ngoal (1 subgoal):\n 1. model v (formula1 @ formula @ formula2)", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model v (formula1 @ formula @ formula2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  model v (formula1 @ formula @ formula2) =\n  model v (formula1 @ formula' @ formula2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clauseOrderIrrelevant:\n  shows \"equivalentFormulae (F1 @ F @ F' @ F2) (F1 @ F' @ F @ F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae (F1 @ F @ F' @ F2) (F1 @ F' @ F @ F2)", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation (F1 @ F @ F' @ F2) =\n       model valuation (F1 @ F' @ F @ F2)", "by (auto simp add: formulaTrueIffAllClausesAreTrue)"], ["", "lemma extendEquivalentFormulaWithEntailedClause:\n  fixes formula1 :: Formula and formula2 :: Formula and clause :: Clause\n  assumes \"equivalentFormulae formula1 formula2\" and \"formulaEntailsClause formula2 clause\"\n  shows \"equivalentFormulae formula1 (formula2 @ [clause])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae formula1 (formula2 @ [clause])", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation formula1 = model valuation (formula2 @ [clause])", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation formula1 = model valuation (formula2 @ [clause])", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation formula1 = model valuation (formula2 @ [clause])", "show \"model valuation formula1 = model valuation (formula2 @ [clause])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model valuation formula1 = model valuation (formula2 @ [clause])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. model valuation formula1 \\<Longrightarrow>\n    model valuation (formula2 @ [clause])\n 2. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "assume \"model valuation formula1\""], ["proof (state)\nthis:\n  model valuation formula1\n\ngoal (2 subgoals):\n 1. model valuation formula1 \\<Longrightarrow>\n    model valuation (formula2 @ [clause])\n 2. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "hence \"consistent valuation\""], ["proof (prove)\nusing this:\n  model valuation formula1\n\ngoal (1 subgoal):\n 1. consistent valuation", "by simp"], ["proof (state)\nthis:\n  consistent valuation\n\ngoal (2 subgoals):\n 1. model valuation formula1 \\<Longrightarrow>\n    model valuation (formula2 @ [clause])\n 2. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "from \\<open>model valuation formula1\\<close> \\<open>equivalentFormulae formula1 formula2\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula1\n  equivalentFormulae formula1 formula2", "have \"model valuation formula2\""], ["proof (prove)\nusing this:\n  model valuation formula1\n  equivalentFormulae formula1 formula2\n\ngoal (1 subgoal):\n 1. model valuation formula2", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  model valuation formula1\n  \\<forall>valuation. model valuation formula1 = model valuation formula2\n\ngoal (1 subgoal):\n 1. model valuation formula2", "by simp"], ["proof (state)\nthis:\n  model valuation formula2\n\ngoal (2 subgoals):\n 1. model valuation formula1 \\<Longrightarrow>\n    model valuation (formula2 @ [clause])\n 2. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "moreover"], ["proof (state)\nthis:\n  model valuation formula2\n\ngoal (2 subgoals):\n 1. model valuation formula1 \\<Longrightarrow>\n    model valuation (formula2 @ [clause])\n 2. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "from \\<open>model valuation formula2\\<close> \\<open>formulaEntailsClause formula2 clause\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula2\n  formulaEntailsClause formula2 clause", "have \"clauseTrue clause valuation\""], ["proof (prove)\nusing this:\n  model valuation formula2\n  formulaEntailsClause formula2 clause\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "unfolding formulaEntailsClause_def"], ["proof (prove)\nusing this:\n  model valuation formula2\n  \\<forall>valuation.\n     model valuation formula2 \\<longrightarrow> model valuation clause\n\ngoal (1 subgoal):\n 1. clauseTrue clause valuation", "by simp"], ["proof (state)\nthis:\n  clauseTrue clause valuation\n\ngoal (2 subgoals):\n 1. model valuation formula1 \\<Longrightarrow>\n    model valuation (formula2 @ [clause])\n 2. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "ultimately"], ["proof (chain)\npicking this:\n  model valuation formula2\n  clauseTrue clause valuation", "show\n      \"model valuation (formula2 @ [clause])\""], ["proof (prove)\nusing this:\n  model valuation formula2\n  clauseTrue clause valuation\n\ngoal (1 subgoal):\n 1. model valuation (formula2 @ [clause])", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model valuation (formula2 @ [clause])\n\ngoal (1 subgoal):\n 1. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "assume \"model valuation (formula2 @ [clause])\""], ["proof (state)\nthis:\n  model valuation (formula2 @ [clause])\n\ngoal (1 subgoal):\n 1. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "hence \"consistent valuation\""], ["proof (prove)\nusing this:\n  model valuation (formula2 @ [clause])\n\ngoal (1 subgoal):\n 1. consistent valuation", "by simp"], ["proof (state)\nthis:\n  consistent valuation\n\ngoal (1 subgoal):\n 1. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "from \\<open>model valuation (formula2 @ [clause])\\<close>"], ["proof (chain)\npicking this:\n  model valuation (formula2 @ [clause])", "have \"model valuation formula2\""], ["proof (prove)\nusing this:\n  model valuation (formula2 @ [clause])\n\ngoal (1 subgoal):\n 1. model valuation formula2", "by (simp add:formulaTrueAppend)"], ["proof (state)\nthis:\n  model valuation formula2\n\ngoal (1 subgoal):\n 1. model valuation (formula2 @ [clause]) \\<Longrightarrow>\n    model valuation formula1", "with \\<open>equivalentFormulae formula1 formula2\\<close>"], ["proof (chain)\npicking this:\n  equivalentFormulae formula1 formula2\n  model valuation formula2", "show \"model valuation formula1\""], ["proof (prove)\nusing this:\n  equivalentFormulae formula1 formula2\n  model valuation formula2\n\ngoal (1 subgoal):\n 1. model valuation formula1", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation formula1 = model valuation formula2\n  model valuation formula2\n\ngoal (1 subgoal):\n 1. model valuation formula1", "by auto"], ["proof (state)\nthis:\n  model valuation formula1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  model valuation formula1 = model valuation (formula2 @ [clause])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma entailsLiteralRelpacePartWithEquivalent:\n  assumes \"equivalentFormulae F F'\" and \"formulaEntailsLiteral (F1 @ F @ F2) l\"\n  shows \"formulaEntailsLiteral (F1 @ F' @ F2) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "fix v::Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "assume \"model v (F1 @ F' @ F2)\""], ["proof (state)\nthis:\n  model v (F1 @ F' @ F2)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "hence \"consistent v\" and \"formulaTrue F1 v\" and \"formulaTrue F' v\" and \"formulaTrue F2 v\""], ["proof (prove)\nusing this:\n  model v (F1 @ F' @ F2)\n\ngoal (1 subgoal):\n 1. (consistent v &&& formulaTrue F1 v) &&&\n    formulaTrue F' v &&& formulaTrue F2 v", "by (auto simp add:formulaTrueAppend)"], ["proof (state)\nthis:\n  consistent v\n  formulaTrue F1 v\n  formulaTrue F' v\n  formulaTrue F2 v\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "with \\<open>equivalentFormulae F F'\\<close>"], ["proof (chain)\npicking this:\n  equivalentFormulae F F'\n  consistent v\n  formulaTrue F1 v\n  formulaTrue F' v\n  formulaTrue F2 v", "have \"formulaTrue F v\""], ["proof (prove)\nusing this:\n  equivalentFormulae F F'\n  consistent v\n  formulaTrue F1 v\n  formulaTrue F' v\n  formulaTrue F2 v\n\ngoal (1 subgoal):\n 1. formulaTrue F v", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation. model valuation F = model valuation F'\n  consistent v\n  formulaTrue F1 v\n  formulaTrue F' v\n  formulaTrue F2 v\n\ngoal (1 subgoal):\n 1. formulaTrue F v", "by auto"], ["proof (state)\nthis:\n  formulaTrue F v\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "with \\<open>consistent v\\<close> \\<open>formulaTrue F1 v\\<close> \\<open>formulaTrue F2 v\\<close>"], ["proof (chain)\npicking this:\n  consistent v\n  formulaTrue F1 v\n  formulaTrue F2 v\n  formulaTrue F v", "have \"model v (F1 @ F @ F2)\""], ["proof (prove)\nusing this:\n  consistent v\n  formulaTrue F1 v\n  formulaTrue F2 v\n  formulaTrue F v\n\ngoal (1 subgoal):\n 1. model v (F1 @ F @ F2)", "by (auto simp add:formulaTrueAppend)"], ["proof (state)\nthis:\n  model v (F1 @ F @ F2)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "with \\<open>formulaEntailsLiteral (F1 @ F @ F2) l\\<close>"], ["proof (chain)\npicking this:\n  formulaEntailsLiteral (F1 @ F @ F2) l\n  model v (F1 @ F @ F2)", "have \"literalTrue l v\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral (F1 @ F @ F2) l\n  model v (F1 @ F @ F2)\n\ngoal (1 subgoal):\n 1. literalTrue l v", "unfolding formulaEntailsLiteral_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation.\n     model valuation (F1 @ F @ F2) \\<longrightarrow> literalTrue l valuation\n  model v (F1 @ F @ F2)\n\ngoal (1 subgoal):\n 1. literalTrue l v", "by auto"], ["proof (state)\nthis:\n  literalTrue l v\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "}"], ["proof (state)\nthis:\n  model ?v2 (F1 @ F' @ F2) \\<Longrightarrow> literalTrue l ?v2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?v2 (F1 @ F' @ F2) \\<Longrightarrow> literalTrue l ?v2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (F1 @ F' @ F2) l", "unfolding formulaEntailsLiteral_def"], ["proof (prove)\nusing this:\n  model ?v2 (F1 @ F' @ F2) \\<Longrightarrow> literalTrue l ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation (F1 @ F' @ F2) \\<longrightarrow>\n       literalTrue l valuation", "by auto"], ["proof (state)\nthis:\n  formulaEntailsLiteral (F1 @ F' @ F2) l\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Remove false and duplicate literals of a clause\\<close>"], ["", "definition\nremoveFalseLiterals :: \"Clause \\<Rightarrow> Valuation \\<Rightarrow> Clause\"\nwhere\n\"removeFalseLiterals clause valuation = filter (\\<lambda> l. \\<not> literalFalse l valuation) clause\""], ["", "lemma clauseTrueRemoveFalseLiterals:\n  assumes \"consistent v\"\n  shows \"clauseTrue c v = clauseTrue (removeFalseLiterals c v) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue c v = clauseTrue (removeFalseLiterals c v) v", "using assms"], ["proof (prove)\nusing this:\n  consistent v\n\ngoal (1 subgoal):\n 1. clauseTrue c v = clauseTrue (removeFalseLiterals c v) v", "unfolding removeFalseLiterals_def"], ["proof (prove)\nusing this:\n  consistent v\n\ngoal (1 subgoal):\n 1. clauseTrue c v =\n    clauseTrue (filter (\\<lambda>l. \\<not> literalFalse l v) c) v", "by (auto simp add: clauseTrueIffContainsTrueLiteral inconsistentCharacterization)"], ["", "lemma clauseTrueRemoveDuplicateLiterals:\n  shows \"clauseTrue c v = clauseTrue (remdups c) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue c v = clauseTrue (remdups c) v", "by (induct c) (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["", "lemma removeDuplicateLiteralsEquivalentClause:\n  shows \"equivalentFormulae [remdups clause] [clause]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae [remdups clause] [clause]", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation [remdups clause] = model valuation [clause]", "by (auto simp add: formulaTrueIffAllClausesAreTrue clauseTrueIffContainsTrueLiteral)"], ["", "lemma falseLiteralsCanBeRemoved:\n(* val2form v - some single literal clauses *)\nfixes F::Formula and F'::Formula and v::Valuation\nassumes \"equivalentFormulae (F1 @ val2form v @ F2) F'\"\nshows \"equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) (F' @ [c])\" \n            (is \"equivalentFormulae ?lhs ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n     (F' @ [c])", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) =\n       model valuation (F' @ [c])", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) =\n       model valuation (F' @ [c])", "fix v' :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) =\n       model valuation (F' @ [c])", "show \"model v' ?lhs = model v' ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) =\n    model v' (F' @ [c])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. model v'\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) \\<Longrightarrow>\n    model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "assume \"model v' ?lhs\""], ["proof (state)\nthis:\n  model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n\ngoal (2 subgoals):\n 1. model v'\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) \\<Longrightarrow>\n    model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "hence \"consistent v'\" and  \n      \"formulaTrue (F1 @ val2form v @ F2) v'\" and \n      \"clauseTrue (removeFalseLiterals c v) v'\""], ["proof (prove)\nusing this:\n  model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n\ngoal (1 subgoal):\n 1. consistent v' &&&\n    formulaTrue (F1 @ val2form v @ F2) v' &&&\n    clauseTrue (removeFalseLiterals c v) v'", "by (auto simp add: formulaTrueAppend formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  consistent v'\n  formulaTrue (F1 @ val2form v @ F2) v'\n  clauseTrue (removeFalseLiterals c v) v'\n\ngoal (2 subgoals):\n 1. model v'\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) \\<Longrightarrow>\n    model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "from \\<open>consistent v'\\<close> \\<open>formulaTrue (F1 @ val2form v @ F2) v'\\<close> \\<open>equivalentFormulae (F1 @ val2form v @ F2) F'\\<close>"], ["proof (chain)\npicking this:\n  consistent v'\n  formulaTrue (F1 @ val2form v @ F2) v'\n  equivalentFormulae (F1 @ val2form v @ F2) F'", "have \"model v' F'\""], ["proof (prove)\nusing this:\n  consistent v'\n  formulaTrue (F1 @ val2form v @ F2) v'\n  equivalentFormulae (F1 @ val2form v @ F2) F'\n\ngoal (1 subgoal):\n 1. model v' F'", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  consistent v'\n  formulaTrue (F1 @ val2form v @ F2) v'\n  \\<forall>valuation.\n     model valuation (F1 @ val2form v @ F2) = model valuation F'\n\ngoal (1 subgoal):\n 1. model v' F'", "by auto"], ["proof (state)\nthis:\n  model v' F'\n\ngoal (2 subgoals):\n 1. model v'\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) \\<Longrightarrow>\n    model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "moreover"], ["proof (state)\nthis:\n  model v' F'\n\ngoal (2 subgoals):\n 1. model v'\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) \\<Longrightarrow>\n    model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "from \\<open>clauseTrue (removeFalseLiterals c v) v'\\<close>"], ["proof (chain)\npicking this:\n  clauseTrue (removeFalseLiterals c v) v'", "have \"clauseTrue c v'\""], ["proof (prove)\nusing this:\n  clauseTrue (removeFalseLiterals c v) v'\n\ngoal (1 subgoal):\n 1. clauseTrue c v'", "unfolding removeFalseLiterals_def"], ["proof (prove)\nusing this:\n  clauseTrue (filter (\\<lambda>l. \\<not> literalFalse l v) c) v'\n\ngoal (1 subgoal):\n 1. clauseTrue c v'", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue c v'\n\ngoal (2 subgoals):\n 1. model v'\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) \\<Longrightarrow>\n    model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "ultimately"], ["proof (chain)\npicking this:\n  model v' F'\n  clauseTrue c v'", "show \"model v' ?rhs\""], ["proof (prove)\nusing this:\n  model v' F'\n  clauseTrue c v'\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c])", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model v' (F' @ [c])\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "assume \"model v' ?rhs\""], ["proof (state)\nthis:\n  model v' (F' @ [c])\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "hence \"consistent v'\" and \"formulaTrue F' v'\" and \"clauseTrue c v'\""], ["proof (prove)\nusing this:\n  model v' (F' @ [c])\n\ngoal (1 subgoal):\n 1. consistent v' &&& formulaTrue F' v' &&& clauseTrue c v'", "by (auto simp add: formulaTrueAppend formulaTrueIffAllClausesAreTrue)"], ["proof (state)\nthis:\n  consistent v'\n  formulaTrue F' v'\n  clauseTrue c v'\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "from \\<open>consistent v'\\<close> \\<open>formulaTrue F' v'\\<close> \\<open>equivalentFormulae (F1 @ val2form v @ F2) F'\\<close>"], ["proof (chain)\npicking this:\n  consistent v'\n  formulaTrue F' v'\n  equivalentFormulae (F1 @ val2form v @ F2) F'", "have \"model v' (F1 @ val2form v @ F2)\""], ["proof (prove)\nusing this:\n  consistent v'\n  formulaTrue F' v'\n  equivalentFormulae (F1 @ val2form v @ F2) F'\n\ngoal (1 subgoal):\n 1. model v' (F1 @ val2form v @ F2)", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  consistent v'\n  formulaTrue F' v'\n  \\<forall>valuation.\n     model valuation (F1 @ val2form v @ F2) = model valuation F'\n\ngoal (1 subgoal):\n 1. model v' (F1 @ val2form v @ F2)", "by auto"], ["proof (state)\nthis:\n  model v' (F1 @ val2form v @ F2)\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "moreover"], ["proof (state)\nthis:\n  model v' (F1 @ val2form v @ F2)\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "have \"clauseTrue (removeFalseLiterals c v) v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue (removeFalseLiterals c v) v'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseTrue (removeFalseLiterals c v) v'", "from \\<open>clauseTrue c v'\\<close>"], ["proof (chain)\npicking this:\n  clauseTrue c v'", "obtain l :: Literal\n        where \"l el c\" and \"literalTrue l v'\""], ["proof (prove)\nusing this:\n  clauseTrue c v'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el c; literalTrue l v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  l el c\n  literalTrue l v'\n\ngoal (1 subgoal):\n 1. clauseTrue (removeFalseLiterals c v) v'", "have \"\\<not> literalFalse l v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> \\<not> literalFalse l v\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "hence \"opposite l el v\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> literalFalse l v\n\ngoal (1 subgoal):\n 1. opposite l el v", "by simp"], ["proof (state)\nthis:\n  opposite l el v\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "with \\<open>model v' (F1 @ val2form v @ F2)\\<close>"], ["proof (chain)\npicking this:\n  model v' (F1 @ val2form v @ F2)\n  opposite l el v", "have \"opposite l el v'\""], ["proof (prove)\nusing this:\n  model v' (F1 @ val2form v @ F2)\n  opposite l el v\n\ngoal (1 subgoal):\n 1. opposite l el v'", "using val2formFormulaTrue[of \"v\" \"v'\"]"], ["proof (prove)\nusing this:\n  model v' (F1 @ val2form v @ F2)\n  opposite l el v\n  formulaTrue (val2form v) v' =\n  (\\<forall>literal. literal el v \\<longrightarrow> literal el v')\n\ngoal (1 subgoal):\n 1. opposite l el v'", "by auto (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  opposite l el v'\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "with \\<open>literalTrue l v'\\<close> \\<open>consistent v'\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l v'\n  consistent v'\n  opposite l el v'", "have \"False\""], ["proof (prove)\nusing this:\n  literalTrue l v'\n  consistent v'\n  opposite l el v'\n\ngoal (1 subgoal):\n 1. False", "by (simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "}"], ["proof (state)\nthis:\n  \\<not> \\<not> literalFalse l v \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<not> literalFalse l v \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> literalFalse l v", "by auto"], ["proof (state)\nthis:\n  \\<not> literalFalse l v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> literalFalse l v\n\ngoal (1 subgoal):\n 1. clauseTrue (removeFalseLiterals c v) v'", "with \\<open>l el c\\<close>"], ["proof (chain)\npicking this:\n  l el c\n  \\<not> literalFalse l v", "have  \"l el (removeFalseLiterals c v)\""], ["proof (prove)\nusing this:\n  l el c\n  \\<not> literalFalse l v\n\ngoal (1 subgoal):\n 1. l el removeFalseLiterals c v", "unfolding removeFalseLiterals_def"], ["proof (prove)\nusing this:\n  l el c\n  \\<not> literalFalse l v\n\ngoal (1 subgoal):\n 1. l el filter (\\<lambda>l. \\<not> literalFalse l v) c", "by simp"], ["proof (state)\nthis:\n  l el removeFalseLiterals c v\n\ngoal (1 subgoal):\n 1. clauseTrue (removeFalseLiterals c v) v'", "with \\<open>literalTrue l v'\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l v'\n  l el removeFalseLiterals c v", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue l v'\n  l el removeFalseLiterals c v\n\ngoal (1 subgoal):\n 1. clauseTrue (removeFalseLiterals c v) v'", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue (removeFalseLiterals c v) v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseTrue (removeFalseLiterals c v) v'\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow>\n    model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "ultimately"], ["proof (chain)\npicking this:\n  model v' (F1 @ val2form v @ F2)\n  clauseTrue (removeFalseLiterals c v) v'", "show \"model v' ?lhs\""], ["proof (prove)\nusing this:\n  model v' (F1 @ val2form v @ F2)\n  clauseTrue (removeFalseLiterals c v) v'\n\ngoal (1 subgoal):\n 1. model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  model v' (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) =\n  model v' (F' @ [c])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma falseAndDuplicateLiteralsCanBeRemoved:\n(* val2form v - some single literal clauses *)\nassumes \"equivalentFormulae (F1 @ val2form v @ F2) F'\"\nshows \"equivalentFormulae (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])\" \n  (is \"equivalentFormulae ?lhs ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "from \\<open>equivalentFormulae (F1 @ val2form v @ F2) F'\\<close>"], ["proof (chain)\npicking this:\n  equivalentFormulae (F1 @ val2form v @ F2) F'", "have \"equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) (F' @ [c])\""], ["proof (prove)\nusing this:\n  equivalentFormulae (F1 @ val2form v @ F2) F'\n\ngoal (1 subgoal):\n 1. equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n     (F' @ [c])", "using falseLiteralsCanBeRemoved"], ["proof (prove)\nusing this:\n  equivalentFormulae (F1 @ val2form v @ F2) F'\n  equivalentFormulae (?F1.0 @ val2form ?v @ ?F2.0) ?F' \\<Longrightarrow>\n  equivalentFormulae\n   (?F1.0 @ val2form ?v @ [removeFalseLiterals ?c ?v] @ ?F2.0) (?F' @ [?c])\n\ngoal (1 subgoal):\n 1. equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n     (F' @ [c])", "by simp"], ["proof (state)\nthis:\n  equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n   (F' @ [c])\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "have \"equivalentFormulae [remdups (removeFalseLiterals c v)] [removeFalseLiterals c v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae [remdups (removeFalseLiterals c v)]\n     [removeFalseLiterals c v]", "using removeDuplicateLiteralsEquivalentClause"], ["proof (prove)\nusing this:\n  equivalentFormulae [remdups ?clause] [?clause]\n\ngoal (1 subgoal):\n 1. equivalentFormulae [remdups (removeFalseLiterals c v)]\n     [removeFalseLiterals c v]", "by simp"], ["proof (state)\nthis:\n  equivalentFormulae [remdups (removeFalseLiterals c v)]\n   [removeFalseLiterals c v]\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "hence \"equivalentFormulae (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n    (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\""], ["proof (prove)\nusing this:\n  equivalentFormulae [remdups (removeFalseLiterals c v)]\n   [removeFalseLiterals c v]\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "using replaceEquivalentByEquivalent\n    [of \"[remdups (removeFalseLiterals c v)]\" \"[removeFalseLiterals c v]\" \"F1 @ val2form v\" \"F2\"]"], ["proof (prove)\nusing this:\n  equivalentFormulae [remdups (removeFalseLiterals c v)]\n   [removeFalseLiterals c v]\n  equivalentFormulae [remdups (removeFalseLiterals c v)]\n   [removeFalseLiterals c v] \\<Longrightarrow>\n  equivalentFormulae\n   ((F1 @ val2form v) @ [remdups (removeFalseLiterals c v)] @ F2)\n   ((F1 @ val2form v) @ [removeFalseLiterals c v] @ F2)\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n     (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)", "by auto"], ["proof (state)\nthis:\n  equivalentFormulae\n   (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n   (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "thus ?thesis"], ["proof (prove)\nusing this:\n  equivalentFormulae\n   (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n   (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "using \\<open>equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2) (F' @ [c])\\<close>"], ["proof (prove)\nusing this:\n  equivalentFormulae\n   (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n   (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n  equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n   (F' @ [c])\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "using equivalentFormulaeTransitivity[of \n              \"(F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\"\n              \"(F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\" \n              \"F' @ [c]\"]"], ["proof (prove)\nusing this:\n  equivalentFormulae\n   (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n   (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n  equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n   (F' @ [c])\n  \\<lbrakk>equivalentFormulae\n            (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n            (F1 @ val2form v @ [removeFalseLiterals c v] @ F2);\n   equivalentFormulae (F1 @ val2form v @ [removeFalseLiterals c v] @ F2)\n    (F' @ [c])\\<rbrakk>\n  \\<Longrightarrow> equivalentFormulae\n                     (F1 @\n                      val2form v @ [remdups (removeFalseLiterals c v)] @ F2)\n                     (F' @ [c])\n\ngoal (1 subgoal):\n 1. equivalentFormulae\n     (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])", "by simp"], ["proof (state)\nthis:\n  equivalentFormulae\n   (F1 @ val2form v @ [remdups (removeFalseLiterals c v)] @ F2) (F' @ [c])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satisfiedClauseCanBeRemoved:\nassumes\n  \"equivalentFormulae (F @ val2form v) F'\"\n  \"clauseTrue c v\"\nshows \"equivalentFormulae (F @ val2form v) (F' @ [c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalentFormulae (F @ val2form v) (F' @ [c])", "unfolding equivalentFormulae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation (F @ val2form v) = model valuation (F' @ [c])", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation (F @ val2form v) = model valuation (F' @ [c])", "fix v' :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>valuation.\n       model valuation (F @ val2form v) = model valuation (F' @ [c])", "show \"model v' (F @ val2form v) = model v' (F' @ [c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model v' (F @ val2form v) = model v' (F' @ [c])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. model v' (F @ val2form v) \\<Longrightarrow> model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "assume \"model v' (F @ val2form v)\""], ["proof (state)\nthis:\n  model v' (F @ val2form v)\n\ngoal (2 subgoals):\n 1. model v' (F @ val2form v) \\<Longrightarrow> model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "hence \"consistent v'\" and \"formulaTrue (F @ val2form v) v'\""], ["proof (prove)\nusing this:\n  model v' (F @ val2form v)\n\ngoal (1 subgoal):\n 1. consistent v' &&& formulaTrue (F @ val2form v) v'", "by auto"], ["proof (state)\nthis:\n  consistent v'\n  formulaTrue (F @ val2form v) v'\n\ngoal (2 subgoals):\n 1. model v' (F @ val2form v) \\<Longrightarrow> model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "from \\<open>model v' (F @ val2form v)\\<close> \\<open>equivalentFormulae (F @ val2form v) F'\\<close>"], ["proof (chain)\npicking this:\n  model v' (F @ val2form v)\n  equivalentFormulae (F @ val2form v) F'", "have \"model v' F'\""], ["proof (prove)\nusing this:\n  model v' (F @ val2form v)\n  equivalentFormulae (F @ val2form v) F'\n\ngoal (1 subgoal):\n 1. model v' F'", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  model v' (F @ val2form v)\n  \\<forall>valuation. model valuation (F @ val2form v) = model valuation F'\n\ngoal (1 subgoal):\n 1. model v' F'", "by auto"], ["proof (state)\nthis:\n  model v' F'\n\ngoal (2 subgoals):\n 1. model v' (F @ val2form v) \\<Longrightarrow> model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "moreover"], ["proof (state)\nthis:\n  model v' F'\n\ngoal (2 subgoals):\n 1. model v' (F @ val2form v) \\<Longrightarrow> model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "have \"clauseTrue c v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue c v'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseTrue c v'", "from \\<open>clauseTrue c v\\<close>"], ["proof (chain)\npicking this:\n  clauseTrue c v", "obtain l :: Literal\n        where \"literalTrue l v\" and \"l el c\""], ["proof (prove)\nusing this:\n  clauseTrue c v\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>literalTrue l v; l el c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  literalTrue l v\n  l el c\n\ngoal (1 subgoal):\n 1. clauseTrue c v'", "with \\<open>formulaTrue (F @ val2form v) v'\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue (F @ val2form v) v'\n  literalTrue l v\n  l el c", "have \"literalTrue l v'\""], ["proof (prove)\nusing this:\n  formulaTrue (F @ val2form v) v'\n  literalTrue l v\n  l el c\n\ngoal (1 subgoal):\n 1. literalTrue l v'", "using val2formFormulaTrue[of \"v\" \"v'\"]"], ["proof (prove)\nusing this:\n  formulaTrue (F @ val2form v) v'\n  literalTrue l v\n  l el c\n  formulaTrue (val2form v) v' =\n  (\\<forall>literal. literal el v \\<longrightarrow> literal el v')\n\ngoal (1 subgoal):\n 1. literalTrue l v'", "using formulaTrueAppend[of \"F\" \"val2form v\"]"], ["proof (prove)\nusing this:\n  formulaTrue (F @ val2form v) v'\n  literalTrue l v\n  l el c\n  formulaTrue (val2form v) v' =\n  (\\<forall>literal. literal el v \\<longrightarrow> literal el v')\n  formulaTrue (F @ val2form v) ?valuation =\n  (formulaTrue F ?valuation \\<and> formulaTrue (val2form v) ?valuation)\n\ngoal (1 subgoal):\n 1. literalTrue l v'", "by simp"], ["proof (state)\nthis:\n  literalTrue l v'\n\ngoal (1 subgoal):\n 1. clauseTrue c v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  literalTrue l v'\n\ngoal (1 subgoal):\n 1. clauseTrue c v'", "using \\<open>l el c\\<close>"], ["proof (prove)\nusing this:\n  literalTrue l v'\n  l el c\n\ngoal (1 subgoal):\n 1. clauseTrue c v'", "by (auto simp add:clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue c v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseTrue c v'\n\ngoal (2 subgoals):\n 1. model v' (F @ val2form v) \\<Longrightarrow> model v' (F' @ [c])\n 2. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "ultimately"], ["proof (chain)\npicking this:\n  model v' F'\n  clauseTrue c v'", "show \"model v' (F' @ [c])\""], ["proof (prove)\nusing this:\n  model v' F'\n  clauseTrue c v'\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c])", "by (simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  model v' (F' @ [c])\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "assume \"model v' (F' @ [c])\""], ["proof (state)\nthis:\n  model v' (F' @ [c])\n\ngoal (1 subgoal):\n 1. model v' (F' @ [c]) \\<Longrightarrow> model v' (F @ val2form v)", "thus \"model v' (F @ val2form v)\""], ["proof (prove)\nusing this:\n  model v' (F' @ [c])\n\ngoal (1 subgoal):\n 1. model v' (F @ val2form v)", "using \\<open>equivalentFormulae (F @ val2form v) F'\\<close>"], ["proof (prove)\nusing this:\n  model v' (F' @ [c])\n  equivalentFormulae (F @ val2form v) F'\n\ngoal (1 subgoal):\n 1. model v' (F @ val2form v)", "unfolding equivalentFormulae_def"], ["proof (prove)\nusing this:\n  model v' (F' @ [c])\n  \\<forall>valuation. model valuation (F @ val2form v) = model valuation F'\n\ngoal (1 subgoal):\n 1. model v' (F @ val2form v)", "using formulaTrueAppend[of \"F'\" \"[c]\" \"v'\"]"], ["proof (prove)\nusing this:\n  model v' (F' @ [c])\n  \\<forall>valuation. model valuation (F @ val2form v) = model valuation F'\n  formulaTrue (F' @ [c]) v' = (formulaTrue F' v' \\<and> formulaTrue [c] v')\n\ngoal (1 subgoal):\n 1. model v' (F @ val2form v)", "by auto"], ["proof (state)\nthis:\n  model v' (F @ val2form v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  model v' (F @ val2form v) = model v' (F' @ [c])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsClauseRemoveEntailedLiteralOpposites:\nassumes\n  \"formulaEntailsClause F clause\"\n  \"formulaEntailsValuation F valuation\"\nshows\n  \"formulaEntailsClause F (list_diff clause (oppositeLiteralList valuation))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "fix valuation'"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "assume \"model valuation' F\""], ["proof (state)\nthis:\n  model valuation' F\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "hence \"consistent valuation'\" \"formulaTrue F valuation'\""], ["proof (prove)\nusing this:\n  model valuation' F\n\ngoal (1 subgoal):\n 1. consistent valuation' &&& formulaTrue F valuation'", "by (auto simp add: formulaTrueAppend)"], ["proof (state)\nthis:\n  consistent valuation'\n  formulaTrue F valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "have \"model valuation' clause\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model valuation' clause", "using \\<open>consistent valuation'\\<close>"], ["proof (prove)\nusing this:\n  consistent valuation'\n\ngoal (1 subgoal):\n 1. model valuation' clause", "using \\<open>formulaTrue F valuation'\\<close>"], ["proof (prove)\nusing this:\n  consistent valuation'\n  formulaTrue F valuation'\n\ngoal (1 subgoal):\n 1. model valuation' clause", "using \\<open>formulaEntailsClause F clause\\<close>"], ["proof (prove)\nusing this:\n  consistent valuation'\n  formulaTrue F valuation'\n  formulaEntailsClause F clause\n\ngoal (1 subgoal):\n 1. model valuation' clause", "unfolding formulaEntailsClause_def"], ["proof (prove)\nusing this:\n  consistent valuation'\n  formulaTrue F valuation'\n  \\<forall>valuation.\n     model valuation F \\<longrightarrow> model valuation clause\n\ngoal (1 subgoal):\n 1. model valuation' clause", "by simp"], ["proof (state)\nthis:\n  model valuation' clause\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "then"], ["proof (chain)\npicking this:\n  model valuation' clause", "obtain l::Literal\n      where \"l el clause\" \"literalTrue l valuation'\""], ["proof (prove)\nusing this:\n  model valuation' clause\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  l el clause\n  literalTrue l valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "moreover"], ["proof (state)\nthis:\n  l el clause\n  literalTrue l valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "hence \"\\<not> l el (oppositeLiteralList valuation)\""], ["proof (prove)\nusing this:\n  l el clause\n  literalTrue l valuation'\n\ngoal (1 subgoal):\n 1. \\<not> l el oppositeLiteralList valuation", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "assume \"l el (oppositeLiteralList valuation)\""], ["proof (state)\nthis:\n  l el oppositeLiteralList valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "hence \"(opposite l) el valuation\""], ["proof (prove)\nusing this:\n  l el oppositeLiteralList valuation\n\ngoal (1 subgoal):\n 1. opposite l el valuation", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"oppositeLiteralList valuation\"]"], ["proof (prove)\nusing this:\n  l el oppositeLiteralList valuation\n  l el oppositeLiteralList valuation =\n  opposite l el oppositeLiteralList (oppositeLiteralList valuation)\n\ngoal (1 subgoal):\n 1. opposite l el valuation", "by simp"], ["proof (state)\nthis:\n  opposite l el valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "hence \"formulaEntailsLiteral F (opposite l)\""], ["proof (prove)\nusing this:\n  opposite l el valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral F (opposite l)", "using \\<open>formulaEntailsValuation F valuation\\<close>"], ["proof (prove)\nusing this:\n  opposite l el valuation\n  formulaEntailsValuation F valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral F (opposite l)", "unfolding formulaEntailsValuation_def"], ["proof (prove)\nusing this:\n  opposite l el valuation\n  \\<forall>literal.\n     literal el valuation \\<longrightarrow> formulaEntailsLiteral F literal\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral F (opposite l)", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral F (opposite l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "hence \"literalFalse l valuation'\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral F (opposite l)\n\ngoal (1 subgoal):\n 1. literalFalse l valuation'", "using \\<open>consistent valuation'\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsLiteral F (opposite l)\n  consistent valuation'\n\ngoal (1 subgoal):\n 1. literalFalse l valuation'", "using \\<open>formulaTrue F valuation'\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsLiteral F (opposite l)\n  consistent valuation'\n  formulaTrue F valuation'\n\ngoal (1 subgoal):\n 1. literalFalse l valuation'", "unfolding formulaEntailsLiteral_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation.\n     model valuation F \\<longrightarrow> literalTrue (opposite l) valuation\n  consistent valuation'\n  formulaTrue F valuation'\n\ngoal (1 subgoal):\n 1. literalFalse l valuation'", "by simp"], ["proof (state)\nthis:\n  literalFalse l valuation'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "with \\<open>literalTrue l valuation'\\<close>\n          \\<open>consistent valuation'\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l valuation'\n  consistent valuation'\n  literalFalse l valuation'", "have False"], ["proof (prove)\nusing this:\n  literalTrue l valuation'\n  consistent valuation'\n  literalFalse l valuation'\n\ngoal (1 subgoal):\n 1. False", "by (simp add: inconsistentCharacterization)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "}"], ["proof (state)\nthis:\n  l el oppositeLiteralList valuation \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el clause; literalTrue l valuation'\\<rbrakk>\n    \\<Longrightarrow> \\<not> l el oppositeLiteralList valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  l el oppositeLiteralList valuation \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> l el oppositeLiteralList valuation", "by auto"], ["proof (state)\nthis:\n  \\<not> l el oppositeLiteralList valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> l el oppositeLiteralList valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "ultimately"], ["proof (chain)\npicking this:\n  l el clause\n  literalTrue l valuation'\n  \\<not> l el oppositeLiteralList valuation", "have \"model valuation' (list_diff clause (oppositeLiteralList valuation))\""], ["proof (prove)\nusing this:\n  l el clause\n  literalTrue l valuation'\n  \\<not> l el oppositeLiteralList valuation\n\ngoal (1 subgoal):\n 1. model valuation' (list_diff clause (oppositeLiteralList valuation))", "using \\<open>consistent valuation'\\<close>"], ["proof (prove)\nusing this:\n  l el clause\n  literalTrue l valuation'\n  \\<not> l el oppositeLiteralList valuation\n  consistent valuation'\n\ngoal (1 subgoal):\n 1. model valuation' (list_diff clause (oppositeLiteralList valuation))", "using listDiffIff[of \"l\" \"clause\" \"oppositeLiteralList valuation\"]"], ["proof (prove)\nusing this:\n  l el clause\n  literalTrue l valuation'\n  \\<not> l el oppositeLiteralList valuation\n  consistent valuation'\n  (l \\<in> set clause \\<and>\n   l \\<notin> set (oppositeLiteralList valuation)) =\n  (l \\<in> set (list_diff clause (oppositeLiteralList valuation)))\n\ngoal (1 subgoal):\n 1. model valuation' (list_diff clause (oppositeLiteralList valuation))", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  model valuation' (list_diff clause (oppositeLiteralList valuation))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "}"], ["proof (state)\nthis:\n  model ?valuation'2 F \\<Longrightarrow>\n  model ?valuation'2 (list_diff clause (oppositeLiteralList valuation))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation'2 F \\<Longrightarrow>\n  model ?valuation'2 (list_diff clause (oppositeLiteralList valuation))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause F\n     (list_diff clause (oppositeLiteralList valuation))", "unfolding formulaEntailsClause_def"], ["proof (prove)\nusing this:\n  model ?valuation'2 F \\<Longrightarrow>\n  model ?valuation'2 (list_diff clause (oppositeLiteralList valuation))\n\ngoal (1 subgoal):\n 1. \\<forall>valuationa.\n       model valuationa F \\<longrightarrow>\n       model valuationa (list_diff clause (oppositeLiteralList valuation))", "by simp"], ["proof (state)\nthis:\n  formulaEntailsClause F (list_diff clause (oppositeLiteralList valuation))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Resolution\\<close>"], ["", "definition\n\"resolve clause1 clause2 literal == removeAll literal clause1 @ removeAll (opposite literal) clause2\""], ["", "lemma resolventIsEntailed: \n  fixes clause1 :: Clause and clause2 :: Clause and literal :: Literal\n  shows \"formulaEntailsClause [clause1, clause2] (resolve clause1 clause2 literal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "assume \"model valuation [clause1, clause2]\""], ["proof (state)\nthis:\n  model valuation [clause1, clause2]\n\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "from \\<open>model valuation [clause1, clause2]\\<close>"], ["proof (chain)\npicking this:\n  model valuation [clause1, clause2]", "obtain l1 :: Literal\n      where \"l1 el clause1\" and \"literalTrue l1 valuation\""], ["proof (prove)\nusing this:\n  model valuation [clause1, clause2]\n\ngoal (1 subgoal):\n 1. (\\<And>l1.\n        \\<lbrakk>l1 el clause1; literalTrue l1 valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: formulaTrueIffAllClausesAreTrue clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  l1 el clause1\n  literalTrue l1 valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "from \\<open>model valuation [clause1, clause2]\\<close>"], ["proof (chain)\npicking this:\n  model valuation [clause1, clause2]", "obtain l2 :: Literal\n      where \"l2 el clause2\" and \"literalTrue l2 valuation\""], ["proof (prove)\nusing this:\n  model valuation [clause1, clause2]\n\ngoal (1 subgoal):\n 1. (\\<And>l2.\n        \\<lbrakk>l2 el clause2; literalTrue l2 valuation\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: formulaTrueIffAllClausesAreTrue clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  l2 el clause2\n  literalTrue l2 valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "have \"clauseTrue (resolve clause1 clause2 literal) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseTrue (resolve clause1 clause2 literal) valuation", "proof (cases \"literal = l1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation\n 2. literal \\<noteq> l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "case False"], ["proof (state)\nthis:\n  literal \\<noteq> l1\n\ngoal (2 subgoals):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation\n 2. literal \\<noteq> l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "with \\<open>l1 el clause1\\<close>"], ["proof (chain)\npicking this:\n  l1 el clause1\n  literal \\<noteq> l1", "have \"l1 el (resolve clause1 clause2 literal)\""], ["proof (prove)\nusing this:\n  l1 el clause1\n  literal \\<noteq> l1\n\ngoal (1 subgoal):\n 1. l1 el resolve clause1 clause2 literal", "by (auto simp add:resolve_def)"], ["proof (state)\nthis:\n  l1 el resolve clause1 clause2 literal\n\ngoal (2 subgoals):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation\n 2. literal \\<noteq> l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "with \\<open>literalTrue l1 valuation\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l1 valuation\n  l1 el resolve clause1 clause2 literal", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue l1 valuation\n  l1 el resolve clause1 clause2 literal\n\ngoal (1 subgoal):\n 1. clauseTrue (resolve clause1 clause2 literal) valuation", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue (resolve clause1 clause2 literal) valuation\n\ngoal (1 subgoal):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "case True"], ["proof (state)\nthis:\n  literal = l1\n\ngoal (1 subgoal):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "from \\<open>model valuation [clause1, clause2]\\<close>"], ["proof (chain)\npicking this:\n  model valuation [clause1, clause2]", "have \"consistent valuation\""], ["proof (prove)\nusing this:\n  model valuation [clause1, clause2]\n\ngoal (1 subgoal):\n 1. consistent valuation", "by simp"], ["proof (state)\nthis:\n  consistent valuation\n\ngoal (1 subgoal):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "from True \\<open>literalTrue l1 valuation\\<close> \\<open>literalTrue l2 valuation\\<close> \\<open>consistent valuation\\<close>"], ["proof (chain)\npicking this:\n  literal = l1\n  literalTrue l1 valuation\n  literalTrue l2 valuation\n  consistent valuation", "have \"literal \\<noteq> opposite l2\""], ["proof (prove)\nusing this:\n  literal = l1\n  literalTrue l1 valuation\n  literalTrue l2 valuation\n  consistent valuation\n\ngoal (1 subgoal):\n 1. literal \\<noteq> opposite l2", "by (auto simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  literal \\<noteq> opposite l2\n\ngoal (1 subgoal):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "with \\<open>l2 el clause2\\<close>"], ["proof (chain)\npicking this:\n  l2 el clause2\n  literal \\<noteq> opposite l2", "have \"l2 el (resolve clause1 clause2 literal)\""], ["proof (prove)\nusing this:\n  l2 el clause2\n  literal \\<noteq> opposite l2\n\ngoal (1 subgoal):\n 1. l2 el resolve clause1 clause2 literal", "by (auto simp add:resolve_def)"], ["proof (state)\nthis:\n  l2 el resolve clause1 clause2 literal\n\ngoal (1 subgoal):\n 1. literal = l1 \\<Longrightarrow>\n    clauseTrue (resolve clause1 clause2 literal) valuation", "with \\<open>literalTrue l2 valuation\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l2 valuation\n  l2 el resolve clause1 clause2 literal", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue l2 valuation\n  l2 el resolve clause1 clause2 literal\n\ngoal (1 subgoal):\n 1. clauseTrue (resolve clause1 clause2 literal) valuation", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  clauseTrue (resolve clause1 clause2 literal) valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseTrue (resolve clause1 clause2 literal) valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "}"], ["proof (state)\nthis:\n  model ?valuation2 [clause1, clause2] \\<Longrightarrow>\n  clauseTrue (resolve clause1 clause2 literal) ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 [clause1, clause2] \\<Longrightarrow>\n  clauseTrue (resolve clause1 clause2 literal) ?valuation2\n\ngoal (1 subgoal):\n 1. formulaEntailsClause [clause1, clause2]\n     (resolve clause1 clause2 literal)", "by (simp add: formulaEntailsClause_def)"], ["proof (state)\nthis:\n  formulaEntailsClause [clause1, clause2] (resolve clause1 clause2 literal)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formulaEntailsResolvent:\n  fixes formula :: Formula and clause1 :: Clause and clause2 :: Clause\n  assumes \"formulaEntailsClause formula clause1\" and \"formulaEntailsClause formula clause2\"\n  shows \"formulaEntailsClause formula (resolve clause1 clause2 literal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "fix valuation :: Valuation"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "assume \"model valuation formula\""], ["proof (state)\nthis:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "hence \"consistent valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n\ngoal (1 subgoal):\n 1. consistent valuation", "by simp"], ["proof (state)\nthis:\n  consistent valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "from \\<open>model valuation formula\\<close> \\<open>formulaEntailsClause formula clause1\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula\n  formulaEntailsClause formula clause1", "have \"clauseTrue clause1 valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n  formulaEntailsClause formula clause1\n\ngoal (1 subgoal):\n 1. clauseTrue clause1 valuation", "by (simp add:formulaEntailsClause_def)"], ["proof (state)\nthis:\n  clauseTrue clause1 valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "from \\<open>model valuation formula\\<close> \\<open>formulaEntailsClause formula clause2\\<close>"], ["proof (chain)\npicking this:\n  model valuation formula\n  formulaEntailsClause formula clause2", "have \"clauseTrue clause2 valuation\""], ["proof (prove)\nusing this:\n  model valuation formula\n  formulaEntailsClause formula clause2\n\ngoal (1 subgoal):\n 1. clauseTrue clause2 valuation", "by (simp add:formulaEntailsClause_def)"], ["proof (state)\nthis:\n  clauseTrue clause2 valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "from \\<open>clauseTrue clause1 valuation\\<close> \\<open>clauseTrue clause2 valuation\\<close> \\<open>consistent valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseTrue clause1 valuation\n  clauseTrue clause2 valuation\n  consistent valuation", "have \"clauseTrue (resolve clause1 clause2 literal) valuation\""], ["proof (prove)\nusing this:\n  clauseTrue clause1 valuation\n  clauseTrue clause2 valuation\n  consistent valuation\n\ngoal (1 subgoal):\n 1. clauseTrue (resolve clause1 clause2 literal) valuation", "using resolventIsEntailed"], ["proof (prove)\nusing this:\n  clauseTrue clause1 valuation\n  clauseTrue clause2 valuation\n  consistent valuation\n  formulaEntailsClause [?clause1.0, ?clause2.0]\n   (resolve ?clause1.0 ?clause2.0 ?literal)\n\ngoal (1 subgoal):\n 1. clauseTrue (resolve clause1 clause2 literal) valuation", "by (auto simp add: formulaEntailsClause_def)"], ["proof (state)\nthis:\n  clauseTrue (resolve clause1 clause2 literal) valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "with \\<open>consistent valuation\\<close>"], ["proof (chain)\npicking this:\n  consistent valuation\n  clauseTrue (resolve clause1 clause2 literal) valuation", "have \"model valuation (resolve clause1 clause2 literal)\""], ["proof (prove)\nusing this:\n  consistent valuation\n  clauseTrue (resolve clause1 clause2 literal) valuation\n\ngoal (1 subgoal):\n 1. model valuation (resolve clause1 clause2 literal)", "by simp"], ["proof (state)\nthis:\n  model valuation (resolve clause1 clause2 literal)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "}"], ["proof (state)\nthis:\n  model ?valuation2 formula \\<Longrightarrow>\n  model ?valuation2 (resolve clause1 clause2 literal)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation2 formula \\<Longrightarrow>\n  model ?valuation2 (resolve clause1 clause2 literal)\n\ngoal (1 subgoal):\n 1. formulaEntailsClause formula (resolve clause1 clause2 literal)", "by (simp add: formulaEntailsClause_def)"], ["proof (state)\nthis:\n  formulaEntailsClause formula (resolve clause1 clause2 literal)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resolveFalseClauses:\n  fixes literal :: Literal and clause1 :: Clause and clause2 :: Clause and valuation :: Valuation\n  assumes \n  \"clauseFalse (removeAll literal clause1) valuation\" and\n  \"clauseFalse (removeAll (opposite literal) clause2) valuation\"\n  shows \"clauseFalse (resolve clause1 clause2 literal) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "fix l :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "assume \"l el (resolve clause1 clause2 literal)\""], ["proof (state)\nthis:\n  l el resolve clause1 clause2 literal\n\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "have \"literalFalse l valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literalFalse l valuation", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. literalFalse l valuation", "from \\<open>l el (resolve clause1 clause2 literal)\\<close>"], ["proof (chain)\npicking this:\n  l el resolve clause1 clause2 literal", "have \"l el (removeAll literal clause1) \\<or> l el (removeAll (opposite literal) clause2)\""], ["proof (prove)\nusing this:\n  l el resolve clause1 clause2 literal\n\ngoal (1 subgoal):\n 1. l el removeAll literal clause1 \\<or>\n    l el removeAll (opposite literal) clause2", "unfolding resolve_def"], ["proof (prove)\nusing this:\n  l el removeAll literal clause1 @ removeAll (opposite literal) clause2\n\ngoal (1 subgoal):\n 1. l el removeAll literal clause1 \\<or>\n    l el removeAll (opposite literal) clause2", "by simp"], ["proof (state)\nthis:\n  l el removeAll literal clause1 \\<or>\n  l el removeAll (opposite literal) clause2\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  l el removeAll literal clause1 \\<or>\n  l el removeAll (opposite literal) clause2\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. l el removeAll literal clause1 \\<Longrightarrow>\n    literalFalse l valuation\n 2. l el removeAll (opposite literal) clause2 \\<Longrightarrow>\n    literalFalse l valuation", "assume \"l el (removeAll literal clause1)\""], ["proof (state)\nthis:\n  l el removeAll literal clause1\n\ngoal (2 subgoals):\n 1. l el removeAll literal clause1 \\<Longrightarrow>\n    literalFalse l valuation\n 2. l el removeAll (opposite literal) clause2 \\<Longrightarrow>\n    literalFalse l valuation", "thus \"literalFalse l valuation\""], ["proof (prove)\nusing this:\n  l el removeAll literal clause1\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "using \\<open>clauseFalse (removeAll literal clause1) valuation\\<close>"], ["proof (prove)\nusing this:\n  l el removeAll literal clause1\n  clauseFalse (removeAll literal clause1) valuation\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse l valuation\n\ngoal (1 subgoal):\n 1. l el removeAll (opposite literal) clause2 \\<Longrightarrow>\n    literalFalse l valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l el removeAll (opposite literal) clause2 \\<Longrightarrow>\n    literalFalse l valuation", "assume \"l el (removeAll (opposite literal) clause2)\""], ["proof (state)\nthis:\n  l el removeAll (opposite literal) clause2\n\ngoal (1 subgoal):\n 1. l el removeAll (opposite literal) clause2 \\<Longrightarrow>\n    literalFalse l valuation", "thus \"literalFalse l valuation\""], ["proof (prove)\nusing this:\n  l el removeAll (opposite literal) clause2\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "using \\<open>clauseFalse (removeAll (opposite literal) clause2) valuation\\<close>"], ["proof (prove)\nusing this:\n  l el removeAll (opposite literal) clause2\n  clauseFalse (removeAll (opposite literal) clause2) valuation\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse l valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literalFalse l valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literalFalse l valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "}"], ["proof (state)\nthis:\n  ?l2 el resolve clause1 clause2 literal \\<Longrightarrow>\n  literalFalse ?l2 valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el resolve clause1 clause2 literal \\<Longrightarrow>\n  literalFalse ?l2 valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (resolve clause1 clause2 literal) valuation", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  clauseFalse (resolve clause1 clause2 literal) valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Unit clauses\\<close>"], ["", "text\\<open>Clause is unit in a valuation if all its literals but one are false, and that one is undefined.\\<close>"], ["", "definition isUnitClause :: \"Clause \\<Rightarrow> Literal \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n\"isUnitClause uClause uLiteral valuation == \n   uLiteral el uClause \\<and> \n   \\<not> (literalTrue uLiteral valuation) \\<and> \n   \\<not> (literalFalse uLiteral valuation) \\<and> \n   (\\<forall> literal. literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow> literalFalse literal valuation)\""], ["", "lemma unitLiteralIsEntailed:\n  fixes uClause :: Clause and uLiteral :: Literal and formula :: Formula and valuation :: Valuation\n  assumes \"isUnitClause uClause uLiteral valuation\" and \"formulaEntailsClause formula uClause\"\n  shows \"formulaEntailsLiteral (formula @ val2form valuation) uLiteral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "fix valuation'"], ["proof (state)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "assume \"model valuation' (formula @ val2form valuation)\""], ["proof (state)\nthis:\n  model valuation' (formula @ val2form valuation)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "hence \"consistent valuation'\""], ["proof (prove)\nusing this:\n  model valuation' (formula @ val2form valuation)\n\ngoal (1 subgoal):\n 1. consistent valuation'", "by simp"], ["proof (state)\nthis:\n  consistent valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "from \\<open>model valuation' (formula @ val2form valuation)\\<close>"], ["proof (chain)\npicking this:\n  model valuation' (formula @ val2form valuation)", "have \"formulaTrue formula valuation'\" and \"formulaTrue (val2form valuation) valuation'\""], ["proof (prove)\nusing this:\n  model valuation' (formula @ val2form valuation)\n\ngoal (1 subgoal):\n 1. formulaTrue formula valuation' &&&\n    formulaTrue (val2form valuation) valuation'", "by (auto simp add:formulaTrueAppend)"], ["proof (state)\nthis:\n  formulaTrue formula valuation'\n  formulaTrue (val2form valuation) valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "from \\<open>formulaTrue formula valuation'\\<close> \\<open>consistent valuation'\\<close> \\<open>formulaEntailsClause formula uClause\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue formula valuation'\n  consistent valuation'\n  formulaEntailsClause formula uClause", "have \"clauseTrue uClause valuation'\""], ["proof (prove)\nusing this:\n  formulaTrue formula valuation'\n  consistent valuation'\n  formulaEntailsClause formula uClause\n\ngoal (1 subgoal):\n 1. clauseTrue uClause valuation'", "by (simp add:formulaEntailsClause_def)"], ["proof (state)\nthis:\n  clauseTrue uClause valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "then"], ["proof (chain)\npicking this:\n  clauseTrue uClause valuation'", "obtain l :: Literal\n      where \"l el uClause\" \"literalTrue l valuation'\""], ["proof (prove)\nusing this:\n  clauseTrue uClause valuation'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l el uClause; literalTrue l valuation'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  l el uClause\n  literalTrue l valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "hence \"literalTrue uLiteral valuation'\""], ["proof (prove)\nusing this:\n  l el uClause\n  literalTrue l valuation'\n\ngoal (1 subgoal):\n 1. literalTrue uLiteral valuation'", "proof (cases \"l = uLiteral\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation'; l = uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'\n 2. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "case True"], ["proof (state)\nthis:\n  l = uLiteral\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation'; l = uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'\n 2. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "with \\<open>literalTrue l valuation'\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l valuation'\n  l = uLiteral", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue l valuation'\n  l = uLiteral\n\ngoal (1 subgoal):\n 1. literalTrue uLiteral valuation'", "by simp"], ["proof (state)\nthis:\n  literalTrue uLiteral valuation'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "case False"], ["proof (state)\nthis:\n  l \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "with \\<open>l el uClause\\<close> \\<open>isUnitClause uClause uLiteral valuation\\<close>"], ["proof (chain)\npicking this:\n  l el uClause\n  isUnitClause uClause uLiteral valuation\n  l \\<noteq> uLiteral", "have \"literalFalse l valuation\""], ["proof (prove)\nusing this:\n  l el uClause\n  isUnitClause uClause uLiteral valuation\n  l \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. literalFalse l valuation", "by (simp add: isUnitClause_def)"], ["proof (state)\nthis:\n  literalFalse l valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "from \\<open>formulaTrue (val2form valuation) valuation'\\<close>"], ["proof (chain)\npicking this:\n  formulaTrue (val2form valuation) valuation'", "have \"\\<forall> literal :: Literal. literal el valuation \\<longrightarrow> literal el valuation'\""], ["proof (prove)\nusing this:\n  formulaTrue (val2form valuation) valuation'\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el valuation \\<longrightarrow> literal el valuation'", "using val2formFormulaTrue [of \"valuation\" \"valuation'\"]"], ["proof (prove)\nusing this:\n  formulaTrue (val2form valuation) valuation'\n  formulaTrue (val2form valuation) valuation' =\n  (\\<forall>literal.\n      literal el valuation \\<longrightarrow> literal el valuation')\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       literal el valuation \\<longrightarrow> literal el valuation'", "by simp"], ["proof (state)\nthis:\n  \\<forall>literal.\n     literal el valuation \\<longrightarrow> literal el valuation'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "with \\<open>literalFalse l valuation\\<close>"], ["proof (chain)\npicking this:\n  literalFalse l valuation\n  \\<forall>literal.\n     literal el valuation \\<longrightarrow> literal el valuation'", "have \"literalFalse l valuation'\""], ["proof (prove)\nusing this:\n  literalFalse l valuation\n  \\<forall>literal.\n     literal el valuation \\<longrightarrow> literal el valuation'\n\ngoal (1 subgoal):\n 1. literalFalse l valuation'", "by auto"], ["proof (state)\nthis:\n  literalFalse l valuation'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "with \\<open>literalTrue l valuation'\\<close> \\<open>consistent valuation'\\<close>"], ["proof (chain)\npicking this:\n  literalTrue l valuation'\n  consistent valuation'\n  literalFalse l valuation'", "have \"False\""], ["proof (prove)\nusing this:\n  literalTrue l valuation'\n  consistent valuation'\n  literalFalse l valuation'\n\ngoal (1 subgoal):\n 1. False", "by (simp add:inconsistentCharacterization)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el uClause; literalTrue l valuation';\n     l \\<noteq> uLiteral\\<rbrakk>\n    \\<Longrightarrow> literalTrue uLiteral valuation'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. literalTrue uLiteral valuation'", ".."], ["proof (state)\nthis:\n  literalTrue uLiteral valuation'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literalTrue uLiteral valuation'\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "}"], ["proof (state)\nthis:\n  model ?valuation'2 (formula @ val2form valuation) \\<Longrightarrow>\n  literalTrue uLiteral ?valuation'2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "thus ?thesis"], ["proof (prove)\nusing this:\n  model ?valuation'2 (formula @ val2form valuation) \\<Longrightarrow>\n  literalTrue uLiteral ?valuation'2\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral (formula @ val2form valuation) uLiteral", "by (simp add: formulaEntailsLiteral_def)"], ["proof (state)\nthis:\n  formulaEntailsLiteral (formula @ val2form valuation) uLiteral\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isUnitClauseRemoveAllUnitLiteralIsFalse: \n  fixes uClause :: Clause and uLiteral :: Literal and valuation :: Valuation\n  assumes \"isUnitClause uClause uLiteral valuation\"\n  shows \"clauseFalse (removeAll uLiteral uClause) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "fix literal :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "assume \"literal el (removeAll uLiteral uClause)\""], ["proof (state)\nthis:\n  literal el removeAll uLiteral uClause\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "hence \"literal el uClause\" and \"literal \\<noteq> uLiteral\""], ["proof (prove)\nusing this:\n  literal el removeAll uLiteral uClause\n\ngoal (1 subgoal):\n 1. literal el uClause &&& literal \\<noteq> uLiteral", "by auto"], ["proof (state)\nthis:\n  literal el uClause\n  literal \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "with \\<open>isUnitClause uClause uLiteral valuation\\<close>"], ["proof (chain)\npicking this:\n  isUnitClause uClause uLiteral valuation\n  literal el uClause\n  literal \\<noteq> uLiteral", "have \"literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral valuation\n  literal el uClause\n  literal \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. literalFalse literal valuation", "by (simp add: isUnitClause_def)"], ["proof (state)\nthis:\n  literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "}"], ["proof (state)\nthis:\n  ?literal2 el removeAll uLiteral uClause \\<Longrightarrow>\n  literalFalse ?literal2 valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?literal2 el removeAll uLiteral uClause \\<Longrightarrow>\n  literalFalse ?literal2 valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  clauseFalse (removeAll uLiteral uClause) valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isUnitClauseAppendValuation:\n  assumes \"isUnitClause uClause uLiteral valuation\" \"l \\<noteq> uLiteral\" \"l \\<noteq> opposite uLiteral\"\n  shows \"isUnitClause uClause uLiteral (valuation @ [l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isUnitClause uClause uLiteral (valuation @ [l])", "using assms"], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral valuation\n  l \\<noteq> uLiteral\n  l \\<noteq> opposite uLiteral\n\ngoal (1 subgoal):\n 1. isUnitClause uClause uLiteral (valuation @ [l])", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  uLiteral el uClause \\<and>\n  \\<not> literalTrue uLiteral valuation \\<and>\n  \\<not> literalFalse uLiteral valuation \\<and>\n  (\\<forall>literal.\n      literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n      literalFalse literal valuation)\n  l \\<noteq> uLiteral\n  l \\<noteq> opposite uLiteral\n\ngoal (1 subgoal):\n 1. uLiteral el uClause \\<and>\n    \\<not> literalTrue uLiteral (valuation @ [l]) \\<and>\n    \\<not> literalFalse uLiteral (valuation @ [l]) \\<and>\n    (\\<forall>literal.\n        literal el uClause \\<and>\n        literal \\<noteq> uLiteral \\<longrightarrow>\n        literalFalse literal (valuation @ [l]))", "by auto"], ["", "lemma containsTrueNotUnit:\nassumes\n  \"l el c\" and \"literalTrue l v\" and \"consistent v\"\nshows\n  \"\\<not> (\\<exists> ul. isUnitClause c ul v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>ul. isUnitClause c ul v", "using assms"], ["proof (prove)\nusing this:\n  l el c\n  literalTrue l v\n  consistent v\n\ngoal (1 subgoal):\n 1. \\<nexists>ul. isUnitClause c ul v", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  l el c\n  literalTrue l v\n  consistent v\n\ngoal (1 subgoal):\n 1. \\<nexists>ul.\n       ul el c \\<and>\n       \\<not> literalTrue ul v \\<and>\n       \\<not> literalFalse ul v \\<and>\n       (\\<forall>literal.\n           literal el c \\<and> literal \\<noteq> ul \\<longrightarrow>\n           literalFalse literal v)", "by (auto simp add: inconsistentCharacterization)"], ["", "lemma unitBecomesFalse:\nassumes\n  \"isUnitClause uClause uLiteral valuation\" \nshows\n  \"clauseFalse uClause (valuation @ [opposite uLiteral])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse uClause (valuation @ [opposite uLiteral])", "using assms"], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral valuation\n\ngoal (1 subgoal):\n 1. clauseFalse uClause (valuation @ [opposite uLiteral])", "using isUnitClauseRemoveAllUnitLiteralIsFalse[of \"uClause\" \"uLiteral\" \"valuation\"]"], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral valuation\n  isUnitClause uClause uLiteral valuation \\<Longrightarrow>\n  clauseFalse (removeAll uLiteral uClause) valuation\n\ngoal (1 subgoal):\n 1. clauseFalse uClause (valuation @ [opposite uLiteral])", "by (auto simp add: clauseFalseIffAllLiteralsAreFalse)"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Reason clauses\\<close>"], ["", "text\\<open>A clause is @{term reason} for unit propagation of a given literal if it was a unit clause before it \n  is asserted, and became true when it is asserted.\\<close>"], ["", "definition\nisReason::\"Clause \\<Rightarrow> Literal \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n\"(isReason clause literal valuation) ==\n  (literal el clause) \\<and> \n  (clauseFalse (removeAll literal clause) valuation) \\<and>\n  (\\<forall> literal'. literal' el (removeAll literal clause) \n       \\<longrightarrow> precedes (opposite literal') literal valuation \\<and> opposite literal' \\<noteq> literal)\""], ["", "lemma isReasonAppend: \n  fixes clause :: Clause and literal :: Literal and valuation :: Valuation and valuation' :: Valuation\n  assumes \"isReason clause literal valuation\" \n  shows \"isReason clause literal (valuation @ valuation')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "from assms"], ["proof (chain)\npicking this:\n  isReason clause literal valuation", "have \"literal el clause\" and \n    \"clauseFalse (removeAll literal clause) valuation\" (is \"?false valuation\") and\n    \"\\<forall> literal'. literal' el (removeAll literal clause) \\<longrightarrow> \n          precedes (opposite literal') literal valuation \\<and> opposite literal' \\<noteq> literal\" (is \"?precedes valuation\")"], ["proof (prove)\nusing this:\n  isReason clause literal valuation\n\ngoal (1 subgoal):\n 1. literal el clause &&&\n    clauseFalse (removeAll literal clause) valuation &&&\n    \\<forall>literal'.\n       literal' el removeAll literal clause \\<longrightarrow>\n       precedes (opposite literal') literal valuation \\<and>\n       opposite literal' \\<noteq> literal", "unfolding isReason_def"], ["proof (prove)\nusing this:\n  literal el clause \\<and>\n  clauseFalse (removeAll literal clause) valuation \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll literal clause \\<longrightarrow>\n      precedes (opposite literal') literal valuation \\<and>\n      opposite literal' \\<noteq> literal)\n\ngoal (1 subgoal):\n 1. literal el clause &&&\n    clauseFalse (removeAll literal clause) valuation &&&\n    \\<forall>literal'.\n       literal' el removeAll literal clause \\<longrightarrow>\n       precedes (opposite literal') literal valuation \\<and>\n       opposite literal' \\<noteq> literal", "by auto"], ["proof (state)\nthis:\n  literal el clause\n  clauseFalse (removeAll literal clause) valuation\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "moreover"], ["proof (state)\nthis:\n  literal el clause\n  clauseFalse (removeAll literal clause) valuation\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "from  \\<open>?false valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse (removeAll literal clause) valuation", "have \"?false (valuation @ valuation')\""], ["proof (prove)\nusing this:\n  clauseFalse (removeAll literal clause) valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) (valuation @ valuation')", "by (rule clauseFalseAppendValuation)"], ["proof (state)\nthis:\n  clauseFalse (removeAll literal clause) (valuation @ valuation')\n\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "moreover"], ["proof (state)\nthis:\n  clauseFalse (removeAll literal clause) (valuation @ valuation')\n\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "from  \\<open>?precedes valuation\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal", "have \"?precedes (valuation @ valuation')\""], ["proof (prove)\nusing this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll literal clause \\<longrightarrow>\n       precedes (opposite literal') literal (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> literal", "by (simp add:precedesAppend)"], ["proof (state)\nthis:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "ultimately"], ["proof (chain)\npicking this:\n  literal el clause\n  clauseFalse (removeAll literal clause) valuation\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n  clauseFalse (removeAll literal clause) (valuation @ valuation')\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> literal", "show ?thesis"], ["proof (prove)\nusing this:\n  literal el clause\n  clauseFalse (removeAll literal clause) valuation\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n  clauseFalse (removeAll literal clause) (valuation @ valuation')\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal (valuation @ valuation')", "unfolding isReason_def"], ["proof (prove)\nusing this:\n  literal el clause\n  clauseFalse (removeAll literal clause) valuation\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n  clauseFalse (removeAll literal clause) (valuation @ valuation')\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. literal el clause \\<and>\n    clauseFalse (removeAll literal clause) (valuation @ valuation') \\<and>\n    (\\<forall>literal'.\n        literal' el removeAll literal clause \\<longrightarrow>\n        precedes (opposite literal') literal (valuation @ valuation') \\<and>\n        opposite literal' \\<noteq> literal)", "by auto"], ["proof (state)\nthis:\n  isReason clause literal (valuation @ valuation')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isUnitClauseIsReason: \n  fixes uClause :: Clause and uLiteral :: Literal and valuation :: Valuation\n  assumes \"isUnitClause uClause uLiteral valuation\" \"uLiteral el valuation'\"\n  shows \"isReason uClause uLiteral (valuation @ valuation')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "from assms"], ["proof (chain)\npicking this:\n  isUnitClause uClause uLiteral valuation\n  uLiteral el valuation'", "have \"uLiteral el uClause\" and \"\\<not> literalTrue uLiteral valuation\" and \"\\<not> literalFalse uLiteral valuation\"\n    and \"\\<forall> literal. literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow> literalFalse literal valuation\""], ["proof (prove)\nusing this:\n  isUnitClause uClause uLiteral valuation\n  uLiteral el valuation'\n\ngoal (1 subgoal):\n 1. (uLiteral el uClause &&& \\<not> literalTrue uLiteral valuation) &&&\n    \\<not> literalFalse uLiteral valuation &&&\n    \\<forall>literal.\n       literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n       literalFalse literal valuation", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  uLiteral el uClause \\<and>\n  \\<not> literalTrue uLiteral valuation \\<and>\n  \\<not> literalFalse uLiteral valuation \\<and>\n  (\\<forall>literal.\n      literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n      literalFalse literal valuation)\n  uLiteral el valuation'\n\ngoal (1 subgoal):\n 1. (uLiteral el uClause &&& \\<not> literalTrue uLiteral valuation) &&&\n    \\<not> literalFalse uLiteral valuation &&&\n    \\<forall>literal.\n       literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n       literalFalse literal valuation", "by auto"], ["proof (state)\nthis:\n  uLiteral el uClause\n  \\<not> literalTrue uLiteral valuation\n  \\<not> literalFalse uLiteral valuation\n  \\<forall>literal.\n     literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n     literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "hence \"clauseFalse (removeAll uLiteral uClause) valuation\""], ["proof (prove)\nusing this:\n  uLiteral el uClause\n  \\<not> literalTrue uLiteral valuation\n  \\<not> literalFalse uLiteral valuation\n  \\<forall>literal.\n     literal el uClause \\<and> literal \\<noteq> uLiteral \\<longrightarrow>\n     literalFalse literal valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) valuation", "by (simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  clauseFalse (removeAll uLiteral uClause) valuation\n\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "hence \"clauseFalse (removeAll uLiteral uClause) (valuation @ valuation')\""], ["proof (prove)\nusing this:\n  clauseFalse (removeAll uLiteral uClause) valuation\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll uLiteral uClause) (valuation @ valuation')", "by (simp add: clauseFalseAppendValuation)"], ["proof (state)\nthis:\n  clauseFalse (removeAll uLiteral uClause) (valuation @ valuation')\n\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "moreover"], ["proof (state)\nthis:\n  clauseFalse (removeAll uLiteral uClause) (valuation @ valuation')\n\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "have \"\\<forall> literal'. literal' el (removeAll uLiteral uClause) \\<longrightarrow> \n    precedes (opposite literal') uLiteral (valuation @ valuation') \\<and> (opposite literal') \\<noteq> uLiteral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "fix literal' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "assume \"literal' el (removeAll uLiteral uClause)\""], ["proof (state)\nthis:\n  literal' el removeAll uLiteral uClause\n\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "with \\<open>clauseFalse (removeAll uLiteral uClause) valuation\\<close>"], ["proof (chain)\npicking this:\n  clauseFalse (removeAll uLiteral uClause) valuation\n  literal' el removeAll uLiteral uClause", "have \"literalFalse literal' valuation\""], ["proof (prove)\nusing this:\n  clauseFalse (removeAll uLiteral uClause) valuation\n  literal' el removeAll uLiteral uClause\n\ngoal (1 subgoal):\n 1. literalFalse literal' valuation", "by (simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  literalFalse literal' valuation\n\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "with \\<open>\\<not> literalTrue uLiteral valuation\\<close> \\<open>\\<not> literalFalse uLiteral valuation\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalTrue uLiteral valuation\n  \\<not> literalFalse uLiteral valuation\n  literalFalse literal' valuation", "have \"precedes (opposite literal') uLiteral (valuation @ valuation') \\<and> (opposite literal') \\<noteq> uLiteral\""], ["proof (prove)\nusing this:\n  \\<not> literalTrue uLiteral valuation\n  \\<not> literalFalse uLiteral valuation\n  literalFalse literal' valuation\n\ngoal (1 subgoal):\n 1. precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n    opposite literal' \\<noteq> uLiteral", "using \\<open>uLiteral el valuation'\\<close>"], ["proof (prove)\nusing this:\n  \\<not> literalTrue uLiteral valuation\n  \\<not> literalFalse uLiteral valuation\n  literalFalse literal' valuation\n  uLiteral el valuation'\n\ngoal (1 subgoal):\n 1. precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n    opposite literal' \\<noteq> uLiteral", "using precedesMemberHeadMemberTail [of \"opposite literal'\" \"valuation\" \"uLiteral\" \"valuation'\"]"], ["proof (prove)\nusing this:\n  \\<not> literalTrue uLiteral valuation\n  \\<not> literalFalse uLiteral valuation\n  literalFalse literal' valuation\n  uLiteral el valuation'\n  \\<lbrakk>opposite literal' \\<in> set valuation;\n   uLiteral \\<notin> set valuation; uLiteral \\<in> set valuation'\\<rbrakk>\n  \\<Longrightarrow> precedes (opposite literal') uLiteral\n                     (valuation @ valuation')\n\ngoal (1 subgoal):\n 1. precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n    opposite literal' \\<noteq> uLiteral", "by auto"], ["proof (state)\nthis:\n  precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n  opposite literal' \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "}"], ["proof (state)\nthis:\n  ?literal'2 el removeAll uLiteral uClause \\<Longrightarrow>\n  precedes (opposite ?literal'2) uLiteral (valuation @ valuation') \\<and>\n  opposite ?literal'2 \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?literal'2 el removeAll uLiteral uClause \\<Longrightarrow>\n  precedes (opposite ?literal'2) uLiteral (valuation @ valuation') \\<and>\n  opposite ?literal'2 \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll uLiteral uClause \\<longrightarrow>\n       precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n       opposite literal' \\<noteq> uLiteral", "by simp"], ["proof (state)\nthis:\n  \\<forall>literal'.\n     literal' el removeAll uLiteral uClause \\<longrightarrow>\n     precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> uLiteral\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>literal'.\n     literal' el removeAll uLiteral uClause \\<longrightarrow>\n     precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "ultimately"], ["proof (chain)\npicking this:\n  clauseFalse (removeAll uLiteral uClause) (valuation @ valuation')\n  \\<forall>literal'.\n     literal' el removeAll uLiteral uClause \\<longrightarrow>\n     precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> uLiteral", "show ?thesis"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll uLiteral uClause) (valuation @ valuation')\n  \\<forall>literal'.\n     literal' el removeAll uLiteral uClause \\<longrightarrow>\n     precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> uLiteral\n\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "using \\<open>uLiteral el uClause\\<close>"], ["proof (prove)\nusing this:\n  clauseFalse (removeAll uLiteral uClause) (valuation @ valuation')\n  \\<forall>literal'.\n     literal' el removeAll uLiteral uClause \\<longrightarrow>\n     precedes (opposite literal') uLiteral (valuation @ valuation') \\<and>\n     opposite literal' \\<noteq> uLiteral\n  uLiteral el uClause\n\ngoal (1 subgoal):\n 1. isReason uClause uLiteral (valuation @ valuation')", "by (auto simp add: isReason_def)"], ["proof (state)\nthis:\n  isReason uClause uLiteral (valuation @ valuation')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isReasonHoldsInPrefix: \n  fixes prefix :: Valuation and valuation :: Valuation and clause :: Clause and literal :: Literal\n  assumes \n  \"literal el prefix\" and \n  \"isPrefix prefix valuation\" and \n  \"isReason clause literal valuation\"\n  shows \n  \"isReason clause literal prefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "from \\<open>isReason clause literal valuation\\<close>"], ["proof (chain)\npicking this:\n  isReason clause literal valuation", "have\n    \"literal el clause\" and \n    \"clauseFalse (removeAll literal clause) valuation\" (is \"?false valuation\") and\n    \"\\<forall> literal'. literal' el (removeAll literal clause) \\<longrightarrow> \n         precedes (opposite literal') literal valuation \\<and> opposite literal' \\<noteq> literal\" (is \"?precedes valuation\")"], ["proof (prove)\nusing this:\n  isReason clause literal valuation\n\ngoal (1 subgoal):\n 1. literal el clause &&&\n    clauseFalse (removeAll literal clause) valuation &&&\n    \\<forall>literal'.\n       literal' el removeAll literal clause \\<longrightarrow>\n       precedes (opposite literal') literal valuation \\<and>\n       opposite literal' \\<noteq> literal", "unfolding isReason_def"], ["proof (prove)\nusing this:\n  literal el clause \\<and>\n  clauseFalse (removeAll literal clause) valuation \\<and>\n  (\\<forall>literal'.\n      literal' el removeAll literal clause \\<longrightarrow>\n      precedes (opposite literal') literal valuation \\<and>\n      opposite literal' \\<noteq> literal)\n\ngoal (1 subgoal):\n 1. literal el clause &&&\n    clauseFalse (removeAll literal clause) valuation &&&\n    \\<forall>literal'.\n       literal' el removeAll literal clause \\<longrightarrow>\n       precedes (opposite literal') literal valuation \\<and>\n       opposite literal' \\<noteq> literal", "by auto"], ["proof (state)\nthis:\n  literal el clause\n  clauseFalse (removeAll literal clause) valuation\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "{"], ["proof (state)\nthis:\n  literal el clause\n  clauseFalse (removeAll literal clause) valuation\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "fix literal' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "assume \"literal' el (removeAll literal clause)\""], ["proof (state)\nthis:\n  literal' el removeAll literal clause\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "with \\<open>?precedes valuation\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n  literal' el removeAll literal clause", "have \"precedes (opposite literal') literal valuation\" \"(opposite literal') \\<noteq> literal\""], ["proof (prove)\nusing this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal valuation \\<and>\n     opposite literal' \\<noteq> literal\n  literal' el removeAll literal clause\n\ngoal (1 subgoal):\n 1. precedes (opposite literal') literal valuation &&&\n    opposite literal' \\<noteq> literal", "by auto"], ["proof (state)\nthis:\n  precedes (opposite literal') literal valuation\n  opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "with \\<open>literal el prefix\\<close> \\<open>isPrefix prefix valuation\\<close>"], ["proof (chain)\npicking this:\n  literal el prefix\n  isPrefix prefix valuation\n  precedes (opposite literal') literal valuation\n  opposite literal' \\<noteq> literal", "have \"precedes (opposite literal') literal prefix \\<and> (opposite literal') \\<noteq> literal\""], ["proof (prove)\nusing this:\n  literal el prefix\n  isPrefix prefix valuation\n  precedes (opposite literal') literal valuation\n  opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. precedes (opposite literal') literal prefix \\<and>\n    opposite literal' \\<noteq> literal", "using laterInPrefixRetainsPrecedes [of \"prefix\" \"valuation\" \"opposite literal'\" \"literal\"]"], ["proof (prove)\nusing this:\n  literal el prefix\n  isPrefix prefix valuation\n  precedes (opposite literal') literal valuation\n  opposite literal' \\<noteq> literal\n  \\<lbrakk>isPrefix prefix valuation;\n   precedes (opposite literal') literal valuation;\n   literal \\<in> set prefix\\<rbrakk>\n  \\<Longrightarrow> precedes (opposite literal') literal prefix\n\ngoal (1 subgoal):\n 1. precedes (opposite literal') literal prefix \\<and>\n    opposite literal' \\<noteq> literal", "by auto"], ["proof (state)\nthis:\n  precedes (opposite literal') literal prefix \\<and>\n  opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "}"], ["proof (state)\nthis:\n  ?literal'2 el removeAll literal clause \\<Longrightarrow>\n  precedes (opposite ?literal'2) literal prefix \\<and>\n  opposite ?literal'2 \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "note * = this"], ["proof (state)\nthis:\n  ?literal'2 el removeAll literal clause \\<Longrightarrow>\n  precedes (opposite ?literal'2) literal prefix \\<and>\n  opposite ?literal'2 \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "hence \"?precedes prefix\""], ["proof (prove)\nusing this:\n  ?literal'2 el removeAll literal clause \\<Longrightarrow>\n  precedes (opposite ?literal'2) literal prefix \\<and>\n  opposite ?literal'2 \\<noteq> literal\n\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el removeAll literal clause \\<longrightarrow>\n       precedes (opposite literal') literal prefix \\<and>\n       opposite literal' \\<noteq> literal", "by auto"], ["proof (state)\nthis:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal prefix \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "moreover"], ["proof (state)\nthis:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal prefix \\<and>\n     opposite literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "have \"?false prefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "fix literal' :: Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "assume \"literal' el (removeAll literal clause)\""], ["proof (state)\nthis:\n  literal' el removeAll literal clause\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "from \\<open>literal' el (removeAll literal clause)\\<close> *"], ["proof (chain)\npicking this:\n  literal' el removeAll literal clause\n  ?literal'2 el removeAll literal clause \\<Longrightarrow>\n  precedes (opposite ?literal'2) literal prefix \\<and>\n  opposite ?literal'2 \\<noteq> literal", "have \"precedes (opposite literal') literal prefix\""], ["proof (prove)\nusing this:\n  literal' el removeAll literal clause\n  ?literal'2 el removeAll literal clause \\<Longrightarrow>\n  precedes (opposite ?literal'2) literal prefix \\<and>\n  opposite ?literal'2 \\<noteq> literal\n\ngoal (1 subgoal):\n 1. precedes (opposite literal') literal prefix", "by simp"], ["proof (state)\nthis:\n  precedes (opposite literal') literal prefix\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "with \\<open>literal el prefix\\<close>"], ["proof (chain)\npicking this:\n  literal el prefix\n  precedes (opposite literal') literal prefix", "have \"literalFalse literal' prefix\""], ["proof (prove)\nusing this:\n  literal el prefix\n  precedes (opposite literal') literal prefix\n\ngoal (1 subgoal):\n 1. literalFalse literal' prefix", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  literal el prefix\n  opposite literal' \\<in> set prefix \\<and>\n  literal \\<in> set prefix \\<and>\n  firstPos (opposite literal') prefix \\<le> firstPos literal prefix\n\ngoal (1 subgoal):\n 1. literalFalse literal' prefix", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  literalFalse literal' prefix\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "}"], ["proof (state)\nthis:\n  ?literal'2 el removeAll literal clause \\<Longrightarrow>\n  literalFalse ?literal'2 prefix\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?literal'2 el removeAll literal clause \\<Longrightarrow>\n  literalFalse ?literal'2 prefix\n\ngoal (1 subgoal):\n 1. clauseFalse (removeAll literal clause) prefix", "by (auto simp add:clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  clauseFalse (removeAll literal clause) prefix\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clauseFalse (removeAll literal clause) prefix\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal prefix \\<and>\n     opposite literal' \\<noteq> literal\n  clauseFalse (removeAll literal clause) prefix", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal prefix \\<and>\n     opposite literal' \\<noteq> literal\n  clauseFalse (removeAll literal clause) prefix\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "using \\<open>literal el clause\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal prefix \\<and>\n     opposite literal' \\<noteq> literal\n  clauseFalse (removeAll literal clause) prefix\n  literal el clause\n\ngoal (1 subgoal):\n 1. isReason clause literal prefix", "unfolding isReason_def"], ["proof (prove)\nusing this:\n  \\<forall>literal'.\n     literal' el removeAll literal clause \\<longrightarrow>\n     precedes (opposite literal') literal prefix \\<and>\n     opposite literal' \\<noteq> literal\n  clauseFalse (removeAll literal clause) prefix\n  literal el clause\n\ngoal (1 subgoal):\n 1. literal el clause \\<and>\n    clauseFalse (removeAll literal clause) prefix \\<and>\n    (\\<forall>literal'.\n        literal' el removeAll literal clause \\<longrightarrow>\n        precedes (opposite literal') literal prefix \\<and>\n        opposite literal' \\<noteq> literal)", "by auto"], ["proof (state)\nthis:\n  isReason clause literal prefix\n\ngoal:\nNo subgoals!", "qed"], ["", "(*--------------------------------------------------------------------------------*)"], ["", "subsubsection\\<open>Last asserted literal of a list\\<close>"], ["", "text\\<open>@{term lastAssertedLiteral} from a list is the last literal from a clause that is asserted in \n  a valuation.\\<close>"], ["", "definition \nisLastAssertedLiteral::\"Literal \\<Rightarrow> Literal list \\<Rightarrow> Valuation \\<Rightarrow> bool\"\nwhere\n\"isLastAssertedLiteral literal clause valuation ==\n  literal el clause \\<and> \n  literalTrue literal valuation \\<and> \n  (\\<forall> literal'. literal' el clause \\<and> literal' \\<noteq> literal \\<longrightarrow> \\<not> precedes literal literal' valuation)\""], ["", "text\\<open>Function that gets the last asserted literal of a list - specified only by its postcondition.\\<close>"], ["", "definition\ngetLastAssertedLiteral :: \"Literal list \\<Rightarrow> Valuation \\<Rightarrow> Literal\"\nwhere\n\"getLastAssertedLiteral clause valuation == \n   last (filter (\\<lambda> l::Literal. l el clause) valuation)\""], ["", "lemma getLastAssertedLiteralCharacterization:\nassumes\n  \"clauseFalse clause valuation\"\n  \"clause \\<noteq> []\"\n  \"uniq valuation\"\nshows\n  \"isLastAssertedLiteral (getLastAssertedLiteral (oppositeLiteralList clause) valuation) (oppositeLiteralList clause) valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "let ?oppc = \"oppositeLiteralList clause\""], ["proof (state)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "let ?l = \"getLastAssertedLiteral ?oppc valuation\""], ["proof (state)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "let ?f = \"filter (\\<lambda> l. l el ?oppc) valuation\""], ["proof (state)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "have \"?oppc \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oppositeLiteralList clause \\<noteq> []", "using \\<open>clause \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  clause \\<noteq> []\n\ngoal (1 subgoal):\n 1. oppositeLiteralList clause \\<noteq> []", "using oppositeLiteralListNonempty[of \"clause\"]"], ["proof (prove)\nusing this:\n  clause \\<noteq> []\n  (clause \\<noteq> []) = (oppositeLiteralList clause \\<noteq> [])\n\ngoal (1 subgoal):\n 1. oppositeLiteralList clause \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  oppositeLiteralList clause \\<noteq> []\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "then"], ["proof (chain)\npicking this:\n  oppositeLiteralList clause \\<noteq> []", "obtain l'::Literal\n    where \"l' el ?oppc\""], ["proof (prove)\nusing this:\n  oppositeLiteralList clause \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        l' el oppositeLiteralList clause \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  l' el oppositeLiteralList clause\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "have \"\\<forall> l::Literal. l el ?oppc \\<longrightarrow> l el valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el oppositeLiteralList clause \\<longrightarrow> l el valuation", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       l el oppositeLiteralList clause \\<longrightarrow> l el valuation", "fix l::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       l el oppositeLiteralList clause \\<longrightarrow> l el valuation", "show \"l el ?oppc \\<longrightarrow> l el valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l el oppositeLiteralList clause \\<longrightarrow> l el valuation", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. l el oppositeLiteralList clause \\<Longrightarrow> l el valuation", "assume \"l el ?oppc\""], ["proof (state)\nthis:\n  l el oppositeLiteralList clause\n\ngoal (1 subgoal):\n 1. l el oppositeLiteralList clause \\<Longrightarrow> l el valuation", "hence \"opposite l el clause\""], ["proof (prove)\nusing this:\n  l el oppositeLiteralList clause\n\ngoal (1 subgoal):\n 1. opposite l el clause", "using literalElListIffOppositeLiteralElOppositeLiteralList[of \"l\" \"?oppc\"]"], ["proof (prove)\nusing this:\n  l el oppositeLiteralList clause\n  l el oppositeLiteralList clause =\n  opposite l el oppositeLiteralList (oppositeLiteralList clause)\n\ngoal (1 subgoal):\n 1. opposite l el clause", "by simp"], ["proof (state)\nthis:\n  opposite l el clause\n\ngoal (1 subgoal):\n 1. l el oppositeLiteralList clause \\<Longrightarrow> l el valuation", "thus \"l el valuation\""], ["proof (prove)\nusing this:\n  opposite l el clause\n\ngoal (1 subgoal):\n 1. l el valuation", "using \\<open>clauseFalse clause valuation\\<close>"], ["proof (prove)\nusing this:\n  opposite l el clause\n  clauseFalse clause valuation\n\ngoal (1 subgoal):\n 1. l el valuation", "using clauseFalseIffAllLiteralsAreFalse[of \"clause\" \"valuation\"]"], ["proof (prove)\nusing this:\n  opposite l el clause\n  clauseFalse clause valuation\n  clauseFalse clause valuation =\n  (\\<forall>literal.\n      literal el clause \\<longrightarrow> literalFalse literal valuation)\n\ngoal (1 subgoal):\n 1. l el valuation", "by auto"], ["proof (state)\nthis:\n  l el valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l el oppositeLiteralList clause \\<longrightarrow> l el valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el oppositeLiteralList clause \\<longrightarrow> l el valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "hence \"l' el valuation\""], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el oppositeLiteralList clause \\<longrightarrow> l el valuation\n\ngoal (1 subgoal):\n 1. l' el valuation", "using \\<open>l' el ?oppc\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     l el oppositeLiteralList clause \\<longrightarrow> l el valuation\n  l' el oppositeLiteralList clause\n\ngoal (1 subgoal):\n 1. l' el valuation", "by simp"], ["proof (state)\nthis:\n  l' el valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "hence \"l' el ?f\""], ["proof (prove)\nusing this:\n  l' el valuation\n\ngoal (1 subgoal):\n 1. l' el filter (\\<lambda>l. l el oppositeLiteralList clause) valuation", "using \\<open>l' el ?oppc\\<close>"], ["proof (prove)\nusing this:\n  l' el valuation\n  l' el oppositeLiteralList clause\n\ngoal (1 subgoal):\n 1. l' el filter (\\<lambda>l. l el oppositeLiteralList clause) valuation", "by simp"], ["proof (state)\nthis:\n  l' el filter (\\<lambda>l. l el oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "hence \"?f \\<noteq> []\""], ["proof (prove)\nusing this:\n  l' el filter (\\<lambda>l. l el oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>l. l el oppositeLiteralList clause) valuation \\<noteq>\n    []", "using set_empty[of \"?f\"]"], ["proof (prove)\nusing this:\n  l' el filter (\\<lambda>l. l el oppositeLiteralList clause) valuation\n  (set (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation) =\n   {}) =\n  (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation = [])\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>l. l el oppositeLiteralList clause) valuation \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>l. l el oppositeLiteralList clause) valuation \\<noteq> []\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "hence \"last ?f el ?f\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>l. l el oppositeLiteralList clause) valuation \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation) el\n    filter (\\<lambda>l. l el oppositeLiteralList clause) valuation", "using last_in_set[of \"?f\"]"], ["proof (prove)\nusing this:\n  filter (\\<lambda>l. l el oppositeLiteralList clause) valuation \\<noteq> []\n  filter (\\<lambda>l. l el oppositeLiteralList clause) valuation \\<noteq>\n  [] \\<Longrightarrow>\n  last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  \\<in> set (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n\ngoal (1 subgoal):\n 1. last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation) el\n    filter (\\<lambda>l. l el oppositeLiteralList clause) valuation", "by simp"], ["proof (state)\nthis:\n  last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation) el\n  filter (\\<lambda>l. l el oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "hence \"?l el ?oppc\" \"literalTrue ?l valuation\""], ["proof (prove)\nusing this:\n  last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation) el\n  filter (\\<lambda>l. l el oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n    oppositeLiteralList clause &&&\n    literalTrue\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     valuation", "unfolding getLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation) el\n  filter (\\<lambda>l. l el oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation) el\n    oppositeLiteralList clause &&&\n    literalTrue\n     (last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation))\n     valuation", "by auto"], ["proof (state)\nthis:\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n  oppositeLiteralList clause\n  literalTrue\n   (getLastAssertedLiteral (oppositeLiteralList clause) valuation) valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "moreover"], ["proof (state)\nthis:\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n  oppositeLiteralList clause\n  literalTrue\n   (getLastAssertedLiteral (oppositeLiteralList clause) valuation) valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "have \"\\<forall>literal'. literal' el ?oppc \\<and> literal' \\<noteq> ?l \\<longrightarrow>\n                    \\<not> precedes ?l literal' valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>literal'.\n       literal' el oppositeLiteralList clause \\<and>\n       literal' \\<noteq>\n       getLastAssertedLiteral (oppositeLiteralList clause)\n        valuation \\<longrightarrow>\n       \\<not> precedes\n               (getLastAssertedLiteral (oppositeLiteralList clause)\n                 valuation)\n               literal' valuation", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>literal'.\n       literal' el oppositeLiteralList clause \\<and>\n       literal' \\<noteq>\n       getLastAssertedLiteral (oppositeLiteralList clause)\n        valuation \\<longrightarrow>\n       \\<not> precedes\n               (getLastAssertedLiteral (oppositeLiteralList clause)\n                 valuation)\n               literal' valuation", "fix literal'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>literal'.\n       literal' el oppositeLiteralList clause \\<and>\n       literal' \\<noteq>\n       getLastAssertedLiteral (oppositeLiteralList clause)\n        valuation \\<longrightarrow>\n       \\<not> precedes\n               (getLastAssertedLiteral (oppositeLiteralList clause)\n                 valuation)\n               literal' valuation", "show \"literal' el ?oppc \\<and> literal' \\<noteq> ?l \\<longrightarrow> \\<not> precedes ?l literal' valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal' el oppositeLiteralList clause \\<and>\n    literal' \\<noteq>\n    getLastAssertedLiteral (oppositeLiteralList clause)\n     valuation \\<longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. literal' el oppositeLiteralList clause \\<and>\n    literal' \\<noteq>\n    getLastAssertedLiteral (oppositeLiteralList clause)\n     valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "assume \"literal' el ?oppc \\<and> literal' \\<noteq> ?l\""], ["proof (state)\nthis:\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. literal' el oppositeLiteralList clause \\<and>\n    literal' \\<noteq>\n    getLastAssertedLiteral (oppositeLiteralList clause)\n     valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "show \"\\<not> precedes ?l literal' valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "proof (cases \"literalTrue literal' valuation\")"], ["proof (state)\ngoal (2 subgoals):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation\n 2. \\<not> literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "case False"], ["proof (state)\nthis:\n  \\<not> literalTrue literal' valuation\n\ngoal (2 subgoals):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation\n 2. \\<not> literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  \\<not> literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. \\<not> (getLastAssertedLiteral (oppositeLiteralList clause) valuation\n            \\<in> set valuation \\<and>\n            literal' \\<in> set valuation \\<and>\n            firstPos\n             (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n             valuation\n            \\<le> firstPos literal' valuation)", "by simp"], ["proof (state)\nthis:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal' valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "case True"], ["proof (state)\nthis:\n  literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "with \\<open>literal' el ?oppc \\<and> literal' \\<noteq> ?l\\<close>"], ["proof (chain)\npicking this:\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation\n  literalTrue literal' valuation", "have \"literal' el ?f\""], ["proof (prove)\nusing this:\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation\n  literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. literal' el\n    filter (\\<lambda>l. l el oppositeLiteralList clause) valuation", "by simp"], ["proof (state)\nthis:\n  literal' el filter (\\<lambda>l. l el oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "have \"uniq ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uniq (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)", "using \\<open>uniq valuation\\<close>"], ["proof (prove)\nusing this:\n  uniq valuation\n\ngoal (1 subgoal):\n 1. uniq (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)", "by (simp add: uniqDistinct)"], ["proof (state)\nthis:\n  uniq (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n\ngoal (1 subgoal):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "hence \"\\<not> precedes ?l literal' ?f\""], ["proof (prove)\nusing this:\n  uniq (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal'\n            (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)", "using lastPrecedesNoElement[of \"?f\"]"], ["proof (prove)\nusing this:\n  uniq (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  uniq\n   (filter (\\<lambda>l. l el oppositeLiteralList clause)\n     valuation) \\<Longrightarrow>\n  \\<nexists>a.\n     a \\<noteq>\n     last\n      (filter (\\<lambda>l. l el oppositeLiteralList clause)\n        valuation) \\<and>\n     precedes\n      (last\n        (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation))\n      a (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal'\n            (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)", "using \\<open>literal' el ?oppc \\<and> literal' \\<noteq> ?l\\<close>"], ["proof (prove)\nusing this:\n  uniq (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  uniq\n   (filter (\\<lambda>l. l el oppositeLiteralList clause)\n     valuation) \\<Longrightarrow>\n  \\<nexists>a.\n     a \\<noteq>\n     last\n      (filter (\\<lambda>l. l el oppositeLiteralList clause)\n        valuation) \\<and>\n     precedes\n      (last\n        (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation))\n      a (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal'\n            (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)", "unfolding getLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  uniq (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  uniq\n   (filter (\\<lambda>l. l el oppositeLiteralList clause)\n     valuation) \\<Longrightarrow>\n  \\<nexists>a.\n     a \\<noteq>\n     last\n      (filter (\\<lambda>l. l el oppositeLiteralList clause)\n        valuation) \\<and>\n     precedes\n      (last\n        (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation))\n      a (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  last (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (last\n              (filter (\\<lambda>l. l el oppositeLiteralList clause)\n                valuation))\n            literal'\n            (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)", "by auto"], ["proof (state)\nthis:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal'\n          (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n\ngoal (1 subgoal):\n 1. literalTrue literal' valuation \\<Longrightarrow>\n    \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal'\n          (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "using precedesFilter[of \"?l\" \"literal'\" \"valuation\" \"\\<lambda> l. l el ?oppc\"]"], ["proof (prove)\nusing this:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal'\n          (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  \\<lbrakk>precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation;\n   getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n   oppositeLiteralList clause;\n   literal' el oppositeLiteralList clause\\<rbrakk>\n  \\<Longrightarrow> precedes\n                     (getLastAssertedLiteral (oppositeLiteralList clause)\n                       valuation)\n                     literal'\n                     (filter (\\<lambda>l. l el oppositeLiteralList clause)\n                       valuation)\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "using \\<open>literal' el ?oppc \\<and> literal' \\<noteq> ?l\\<close>"], ["proof (prove)\nusing this:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal'\n          (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  \\<lbrakk>precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation;\n   getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n   oppositeLiteralList clause;\n   literal' el oppositeLiteralList clause\\<rbrakk>\n  \\<Longrightarrow> precedes\n                     (getLastAssertedLiteral (oppositeLiteralList clause)\n                       valuation)\n                     literal'\n                     (filter (\\<lambda>l. l el oppositeLiteralList clause)\n                       valuation)\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "using \\<open>?l el ?oppc\\<close>"], ["proof (prove)\nusing this:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal'\n          (filter (\\<lambda>l. l el oppositeLiteralList clause) valuation)\n  \\<lbrakk>precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation;\n   getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n   oppositeLiteralList clause;\n   literal' el oppositeLiteralList clause\\<rbrakk>\n  \\<Longrightarrow> precedes\n                     (getLastAssertedLiteral (oppositeLiteralList clause)\n                       valuation)\n                     literal'\n                     (filter (\\<lambda>l. l el oppositeLiteralList clause)\n                       valuation)\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n  oppositeLiteralList clause\n\ngoal (1 subgoal):\n 1. \\<not> precedes\n            (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n            literal' valuation", "by auto"], ["proof (state)\nthis:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal' valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal' valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  literal' el oppositeLiteralList clause \\<and>\n  literal' \\<noteq>\n  getLastAssertedLiteral (oppositeLiteralList clause)\n   valuation \\<longrightarrow>\n  \\<not> precedes\n          (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n          literal' valuation\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>literal'.\n     literal' el oppositeLiteralList clause \\<and>\n     literal' \\<noteq>\n     getLastAssertedLiteral (oppositeLiteralList clause)\n      valuation \\<longrightarrow>\n     \\<not> precedes\n             (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n             literal' valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "ultimately"], ["proof (chain)\npicking this:\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n  oppositeLiteralList clause\n  literalTrue\n   (getLastAssertedLiteral (oppositeLiteralList clause) valuation) valuation\n  \\<forall>literal'.\n     literal' el oppositeLiteralList clause \\<and>\n     literal' \\<noteq>\n     getLastAssertedLiteral (oppositeLiteralList clause)\n      valuation \\<longrightarrow>\n     \\<not> precedes\n             (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n             literal' valuation", "show ?thesis"], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n  oppositeLiteralList clause\n  literalTrue\n   (getLastAssertedLiteral (oppositeLiteralList clause) valuation) valuation\n  \\<forall>literal'.\n     literal' el oppositeLiteralList clause \\<and>\n     literal' \\<noteq>\n     getLastAssertedLiteral (oppositeLiteralList clause)\n      valuation \\<longrightarrow>\n     \\<not> precedes\n             (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n             literal' valuation\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     (oppositeLiteralList clause) valuation", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n  oppositeLiteralList clause\n  literalTrue\n   (getLastAssertedLiteral (oppositeLiteralList clause) valuation) valuation\n  \\<forall>literal'.\n     literal' el oppositeLiteralList clause \\<and>\n     literal' \\<noteq>\n     getLastAssertedLiteral (oppositeLiteralList clause)\n      valuation \\<longrightarrow>\n     \\<not> precedes\n             (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n             literal' valuation\n\ngoal (1 subgoal):\n 1. getLastAssertedLiteral (oppositeLiteralList clause) valuation el\n    oppositeLiteralList clause \\<and>\n    literalTrue\n     (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n     valuation \\<and>\n    (\\<forall>literal'.\n        literal' el oppositeLiteralList clause \\<and>\n        literal' \\<noteq>\n        getLastAssertedLiteral (oppositeLiteralList clause)\n         valuation \\<longrightarrow>\n        \\<not> precedes\n                (getLastAssertedLiteral (oppositeLiteralList clause)\n                  valuation)\n                literal' valuation)", "by simp"], ["proof (state)\nthis:\n  isLastAssertedLiteral\n   (getLastAssertedLiteral (oppositeLiteralList clause) valuation)\n   (oppositeLiteralList clause) valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lastAssertedLiteralIsUniq: \n  fixes literal :: Literal and literal' :: Literal and literalList :: \"Literal list\" and valuation :: Valuation\n  assumes \n  lastL: \"isLastAssertedLiteral literal  literalList valuation\" and\n  lastL': \"isLastAssertedLiteral literal' literalList valuation\"\n  shows \"literal = literal'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal = literal'", "using assms"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral literal literalList valuation\n  isLastAssertedLiteral literal' literalList valuation\n\ngoal (1 subgoal):\n 1. literal = literal'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "from lastL"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral literal literalList valuation", "have *: \n    \"literal el literalList\"  \n    \"\\<forall> l. l el literalList \\<and> l \\<noteq> literal \\<longrightarrow> \\<not>  precedes literal l valuation\" \n    and\n    \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral literal literalList valuation\n\ngoal (1 subgoal):\n 1. (literal el literalList &&&\n     \\<forall>l.\n        l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n        \\<not> precedes literal l valuation) &&&\n    literalTrue literal valuation", "by (auto simp add: isLastAssertedLiteral_def)"], ["proof (state)\nthis:\n  literal el literalList\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l valuation\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "from lastL'"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral literal' literalList valuation", "have **: \n    \"literal' el literalList\"\n    \"\\<forall> l. l el literalList \\<and> l \\<noteq> literal' \\<longrightarrow> \\<not>  precedes literal' l valuation\"\n    and\n    \"literalTrue literal' valuation\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral literal' literalList valuation\n\ngoal (1 subgoal):\n 1. (literal' el literalList &&&\n     \\<forall>l.\n        l el literalList \\<and> l \\<noteq> literal' \\<longrightarrow>\n        \\<not> precedes literal' l valuation) &&&\n    literalTrue literal' valuation", "by (auto simp add: isLastAssertedLiteral_def)"], ["proof (state)\nthis:\n  literal' el literalList\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal' \\<longrightarrow>\n     \\<not> precedes literal' l valuation\n  literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "{"], ["proof (state)\nthis:\n  literal' el literalList\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal' \\<longrightarrow>\n     \\<not> precedes literal' l valuation\n  literalTrue literal' valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "assume \"literal' \\<noteq> literal\""], ["proof (state)\nthis:\n  literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "with * **"], ["proof (chain)\npicking this:\n  literal el literalList\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l valuation\n  literal' el literalList\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal' \\<longrightarrow>\n     \\<not> precedes literal' l valuation\n  literal' \\<noteq> literal", "have \"\\<not> precedes literal literal' valuation\" and \"\\<not> precedes literal' literal valuation\""], ["proof (prove)\nusing this:\n  literal el literalList\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l valuation\n  literal' el literalList\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal' \\<longrightarrow>\n     \\<not> precedes literal' l valuation\n  literal' \\<noteq> literal\n\ngoal (1 subgoal):\n 1. \\<not> precedes literal literal' valuation &&&\n    \\<not> precedes literal' literal valuation", "by auto"], ["proof (state)\nthis:\n  \\<not> precedes literal literal' valuation\n  \\<not> precedes literal' literal valuation\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "with \\<open>literalTrue literal valuation\\<close> \\<open>literalTrue literal' valuation\\<close>"], ["proof (chain)\npicking this:\n  literalTrue literal valuation\n  literalTrue literal' valuation\n  \\<not> precedes literal literal' valuation\n  \\<not> precedes literal' literal valuation", "have \"False\""], ["proof (prove)\nusing this:\n  literalTrue literal valuation\n  literalTrue literal' valuation\n  \\<not> precedes literal literal' valuation\n  \\<not> precedes literal' literal valuation\n\ngoal (1 subgoal):\n 1. False", "using precedesTotalOrder[of \"literal\" \"valuation\" \"literal'\"]"], ["proof (prove)\nusing this:\n  literalTrue literal valuation\n  literalTrue literal' valuation\n  \\<not> precedes literal literal' valuation\n  \\<not> precedes literal' literal valuation\n  \\<lbrakk>literal \\<in> set valuation;\n   literal' \\<in> set valuation\\<rbrakk>\n  \\<Longrightarrow> literal = literal' \\<or>\n                    precedes literal literal' valuation \\<or>\n                    precedes literal' literal valuation\n\ngoal (1 subgoal):\n 1. False", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  literalTrue literal valuation\n  literalTrue literal' valuation\n  \\<not> (literal \\<in> set valuation \\<and>\n          literal' \\<in> set valuation \\<and>\n          firstPos literal valuation \\<le> firstPos literal' valuation)\n  \\<not> (literal' \\<in> set valuation \\<and>\n          literal \\<in> set valuation \\<and>\n          firstPos literal' valuation \\<le> firstPos literal valuation)\n  \\<lbrakk>literal \\<in> set valuation;\n   literal' \\<in> set valuation\\<rbrakk>\n  \\<Longrightarrow> literal = literal' \\<or>\n                    literal \\<in> set valuation \\<and>\n                    literal' \\<in> set valuation \\<and>\n                    firstPos literal valuation\n                    \\<le> firstPos literal' valuation \\<or>\n                    literal' \\<in> set valuation \\<and>\n                    literal \\<in> set valuation \\<and>\n                    firstPos literal' valuation\n                    \\<le> firstPos literal valuation\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "}"], ["proof (state)\nthis:\n  literal' \\<noteq> literal \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isLastAssertedLiteral literal literalList valuation;\n     isLastAssertedLiteral literal' literalList valuation\\<rbrakk>\n    \\<Longrightarrow> literal = literal'", "thus ?thesis"], ["proof (prove)\nusing this:\n  literal' \\<noteq> literal \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. literal = literal'", "by auto"], ["proof (state)\nthis:\n  literal = literal'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isLastAssertedCharacterization: \n  fixes literal :: Literal and literalList :: \"Literal list\" and v :: Valuation\n  assumes \"isLastAssertedLiteral literal (oppositeLiteralList literalList) valuation\"\n  shows \"opposite literal el literalList\" and \"literalTrue literal valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opposite literal el literalList &&& literalTrue literal valuation", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. opposite literal el literalList\n 2. literalTrue literal valuation", "from assms"], ["proof (chain)\npicking this:\n  isLastAssertedLiteral literal (oppositeLiteralList literalList) valuation", "have\n    *: \"literal el (oppositeLiteralList literalList)\" and **: \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  isLastAssertedLiteral literal (oppositeLiteralList literalList) valuation\n\ngoal (1 subgoal):\n 1. literal el oppositeLiteralList literalList &&&\n    literalTrue literal valuation", "by (auto simp add: isLastAssertedLiteral_def)"], ["proof (state)\nthis:\n  literal el oppositeLiteralList literalList\n  literalTrue literal valuation\n\ngoal (2 subgoals):\n 1. opposite literal el literalList\n 2. literalTrue literal valuation", "from *"], ["proof (chain)\npicking this:\n  literal el oppositeLiteralList literalList", "show \"opposite literal el literalList\""], ["proof (prove)\nusing this:\n  literal el oppositeLiteralList literalList\n\ngoal (1 subgoal):\n 1. opposite literal el literalList", "using literalElListIffOppositeLiteralElOppositeLiteralList [of \"literal\" \"oppositeLiteralList literalList\"]"], ["proof (prove)\nusing this:\n  literal el oppositeLiteralList literalList\n  literal el oppositeLiteralList literalList =\n  opposite literal el oppositeLiteralList (oppositeLiteralList literalList)\n\ngoal (1 subgoal):\n 1. opposite literal el literalList", "by simp"], ["proof (state)\nthis:\n  opposite literal el literalList\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "from **"], ["proof (chain)\npicking this:\n  literalTrue literal valuation", "show \"literalTrue literal valuation\""], ["proof (prove)\nusing this:\n  literalTrue literal valuation\n\ngoal (1 subgoal):\n 1. literalTrue literal valuation", "by simp"], ["proof (state)\nthis:\n  literalTrue literal valuation\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isLastAssertedLiteralSubset:\nassumes\n  \"isLastAssertedLiteral l c M\"\n  \"set c' \\<subseteq> set c\"\n  \"l el c'\"\nshows\n  \"isLastAssertedLiteral l c' M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral l c' M", "using assms"], ["proof (prove)\nusing this:\n  isLastAssertedLiteral l c M\n  set c' \\<subseteq> set c\n  l el c'\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral l c' M", "unfolding isLastAssertedLiteral_def"], ["proof (prove)\nusing this:\n  l el c \\<and>\n  literalTrue l M \\<and>\n  (\\<forall>literal'.\n      literal' el c \\<and> literal' \\<noteq> l \\<longrightarrow>\n      \\<not> precedes l literal' M)\n  set c' \\<subseteq> set c\n  l el c'\n\ngoal (1 subgoal):\n 1. l el c' \\<and>\n    literalTrue l M \\<and>\n    (\\<forall>literal'.\n        literal' el c' \\<and> literal' \\<noteq> l \\<longrightarrow>\n        \\<not> precedes l literal' M)", "by auto"], ["", "lemma lastAssertedLastInValuation: \n  fixes literal :: Literal and literalList :: \"Literal list\" and valuation :: Valuation\n  assumes \"literal el literalList\" and \"\\<not> literalTrue literal valuation\" \n  shows \"isLastAssertedLiteral literal literalList (valuation @ [literal])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "have \"literalTrue literal [literal]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literalTrue literal [literal]", "by simp"], ["proof (state)\nthis:\n  literalTrue literal [literal]\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "hence \"literalTrue literal (valuation @ [literal])\""], ["proof (prove)\nusing this:\n  literalTrue literal [literal]\n\ngoal (1 subgoal):\n 1. literalTrue literal (valuation @ [literal])", "by simp"], ["proof (state)\nthis:\n  literalTrue literal (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "moreover"], ["proof (state)\nthis:\n  literalTrue literal (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "have \"\\<forall> l. l el literalList \\<and> l \\<noteq> literal \\<longrightarrow> \\<not>  precedes literal l (valuation @ [literal])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "assume \"l el literalList\" \"l \\<noteq> literal\""], ["proof (state)\nthis:\n  l el literalList\n  l \\<noteq> literal\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "have \"\\<not> precedes literal l (valuation @ [literal])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> precedes literal l (valuation @ [literal])", "proof (cases \"literalTrue l valuation\")"], ["proof (state)\ngoal (2 subgoals):\n 1. literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])\n 2. \\<not> literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])", "case False"], ["proof (state)\nthis:\n  \\<not> literalTrue l valuation\n\ngoal (2 subgoals):\n 1. literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])\n 2. \\<not> literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])", "with \\<open>l \\<noteq> literal\\<close>"], ["proof (chain)\npicking this:\n  l \\<noteq> literal\n  \\<not> literalTrue l valuation", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> literal\n  \\<not> literalTrue l valuation\n\ngoal (1 subgoal):\n 1. \\<not> precedes literal l (valuation @ [literal])", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  l \\<noteq> literal\n  \\<not> literalTrue l valuation\n\ngoal (1 subgoal):\n 1. \\<not> (literal \\<in> set (valuation @ [literal]) \\<and>\n            l \\<in> set (valuation @ [literal]) \\<and>\n            firstPos literal (valuation @ [literal])\n            \\<le> firstPos l (valuation @ [literal]))", "by simp"], ["proof (state)\nthis:\n  \\<not> precedes literal l (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])", "case True"], ["proof (state)\nthis:\n  literalTrue l valuation\n\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])", "from \\<open>\\<not> literalTrue literal valuation\\<close> \\<open>literalTrue literal [literal]\\<close> \\<open>literalTrue l valuation\\<close>"], ["proof (chain)\npicking this:\n  \\<not> literalTrue literal valuation\n  literalTrue literal [literal]\n  literalTrue l valuation", "have \"precedes l literal (valuation @ [literal])\""], ["proof (prove)\nusing this:\n  \\<not> literalTrue literal valuation\n  literalTrue literal [literal]\n  literalTrue l valuation\n\ngoal (1 subgoal):\n 1. precedes l literal (valuation @ [literal])", "using precedesMemberHeadMemberTail[of \"l\" \"valuation\" \"literal\" \"[literal]\"]"], ["proof (prove)\nusing this:\n  \\<not> literalTrue literal valuation\n  literalTrue literal [literal]\n  literalTrue l valuation\n  \\<lbrakk>l \\<in> set valuation; literal \\<notin> set valuation;\n   literal \\<in> set [literal]\\<rbrakk>\n  \\<Longrightarrow> precedes l literal (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. precedes l literal (valuation @ [literal])", "by auto"], ["proof (state)\nthis:\n  precedes l literal (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. literalTrue l valuation \\<Longrightarrow>\n    \\<not> precedes literal l (valuation @ [literal])", "with \\<open>l \\<noteq> literal\\<close> \\<open>literalTrue l valuation\\<close> \\<open>literalTrue literal [literal]\\<close>"], ["proof (chain)\npicking this:\n  l \\<noteq> literal\n  literalTrue l valuation\n  literalTrue literal [literal]\n  precedes l literal (valuation @ [literal])", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> literal\n  literalTrue l valuation\n  literalTrue literal [literal]\n  precedes l literal (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<not> precedes literal l (valuation @ [literal])", "using precedesAntisymmetry[of \"l\" \"valuation @ [literal]\" \"literal\"]"], ["proof (prove)\nusing this:\n  l \\<noteq> literal\n  literalTrue l valuation\n  literalTrue literal [literal]\n  precedes l literal (valuation @ [literal])\n  \\<lbrakk>l \\<in> set (valuation @ [literal]);\n   literal \\<in> set (valuation @ [literal]);\n   precedes l literal (valuation @ [literal]);\n   precedes literal l (valuation @ [literal])\\<rbrakk>\n  \\<Longrightarrow> l = literal\n\ngoal (1 subgoal):\n 1. \\<not> precedes literal l (valuation @ [literal])", "unfolding precedes_def"], ["proof (prove)\nusing this:\n  l \\<noteq> literal\n  literalTrue l valuation\n  literalTrue literal [literal]\n  l \\<in> set (valuation @ [literal]) \\<and>\n  literal \\<in> set (valuation @ [literal]) \\<and>\n  firstPos l (valuation @ [literal])\n  \\<le> firstPos literal (valuation @ [literal])\n  \\<lbrakk>l \\<in> set (valuation @ [literal]);\n   literal \\<in> set (valuation @ [literal]);\n   l \\<in> set (valuation @ [literal]) \\<and>\n   literal \\<in> set (valuation @ [literal]) \\<and>\n   firstPos l (valuation @ [literal])\n   \\<le> firstPos literal (valuation @ [literal]);\n   literal \\<in> set (valuation @ [literal]) \\<and>\n   l \\<in> set (valuation @ [literal]) \\<and>\n   firstPos literal (valuation @ [literal])\n   \\<le> firstPos l (valuation @ [literal])\\<rbrakk>\n  \\<Longrightarrow> l = literal\n\ngoal (1 subgoal):\n 1. \\<not> (literal \\<in> set (valuation @ [literal]) \\<and>\n            l \\<in> set (valuation @ [literal]) \\<and>\n            firstPos literal (valuation @ [literal])\n            \\<le> firstPos l (valuation @ [literal]))", "by auto"], ["proof (state)\nthis:\n  \\<not> precedes literal l (valuation @ [literal])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> precedes literal l (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l2 el literalList; ?l2 \\<noteq> literal\\<rbrakk>\n  \\<Longrightarrow> \\<not> precedes literal ?l2 (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l2 el literalList; ?l2 \\<noteq> literal\\<rbrakk>\n  \\<Longrightarrow> \\<not> precedes literal ?l2 (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n       \\<not> precedes literal l (valuation @ [literal])", "by simp"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (valuation @ [literal])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "ultimately"], ["proof (chain)\npicking this:\n  literalTrue literal (valuation @ [literal])\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (valuation @ [literal])", "show ?thesis"], ["proof (prove)\nusing this:\n  literalTrue literal (valuation @ [literal])\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (valuation @ [literal])\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "using \\<open>literal el literalList\\<close>"], ["proof (prove)\nusing this:\n  literalTrue literal (valuation @ [literal])\n  \\<forall>l.\n     l el literalList \\<and> l \\<noteq> literal \\<longrightarrow>\n     \\<not> precedes literal l (valuation @ [literal])\n  literal el literalList\n\ngoal (1 subgoal):\n 1. isLastAssertedLiteral literal literalList (valuation @ [literal])", "by (simp add:isLastAssertedLiteral_def)"], ["proof (state)\nthis:\n  isLastAssertedLiteral literal literalList (valuation @ [literal])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}