{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/UnitPropagate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma applyUnitPropagateEffect:\nassumes\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n\n  \"\\<not> (getConflictFlag state)\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let uLiteral = hd (getQ state) in\n   let state' = applyUnitPropagate state in\n      \\<exists> uClause. formulaEntailsClause (getF state) uClause \\<and> \n                 isUnitClause uClause uLiteral (elements (getM state)) \\<and> \n                 (getM state') = (getM state) @ [(uLiteral, False)]\"", "lemma InvariantConsistentAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"getQ state \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantConsistent (getM state')\n  \"", "lemma InvariantUniqAfterApplyUnitPropagate:\nassumes\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"getQ state \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantUniq (getM state')\n  \"", "lemma InvariantWatchCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"(getQ state) \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state' = applyUnitPropagate state in\n        InvariantWatchCharacterization (getF state') (getWatch1 state') (getWatch2 state') (getM state')\"", "lemma InvariantConflictFlagCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"\\<not> getConflictFlag state\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let state' = (applyUnitPropagate state) in\n      InvariantConflictFlagCharacterization (getConflictFlag state') (getF state') (getM state')\"", "lemma InvariantConflictClauseCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"\\<not> getConflictFlag state\"\nshows\n   \"let state' = applyUnitPropagate state in\n    InvariantConflictClauseCharacterization (getConflictFlag state') (getConflictClause state') (getF state') (getM state')\"", "lemma InvariantQCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"(getQ state) \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state'' = applyUnitPropagate state in\n     InvariantQCharacterization (getConflictFlag state'') (getQ state'') (getF state'') (getM state'')\"", "lemma InvariantUniqQAfterApplyUnitPropagate:\nassumes\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let state'' = applyUnitPropagate state in\n      InvariantUniqQ (getQ state'')\"", "lemma InvariantNoDecisionsWhenConflictNorUnitAfterUnitPropagate:\nassumes \n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantNoDecisionsWhenConflict (getF state) (getM state) (currentLevel (getM state))\"\n  \"InvariantNoDecisionsWhenUnit (getF state) (getM state) (currentLevel (getM state))\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantNoDecisionsWhenConflict (getF state') (getM state') (currentLevel (getM state')) \\<and> \n     InvariantNoDecisionsWhenUnit (getF state') (getM state') (currentLevel (getM state'))\"", "lemma InvariantGetReasonIsReasonAfterApplyUnitPropagate:\nassumes\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\" and\n  \"InvariantUniqQ (getQ state)\" and\n  \"InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\" and\n  \"getQ state \\<noteq> []\" and\n  \"\\<not> getConflictFlag state\" \nshows\n  \"let state' = applyUnitPropagate state in \n     InvariantGetReasonIsReason (getReason state') (getF state') (getM state') (set (getQ state'))\"", "lemma InvariantEquivalentZLAfterApplyUnitPropagate:\nassumes \n  \"InvariantEquivalentZL (getF state) (getM state) Phi\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n\n  \"\\<not> (getConflictFlag state)\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let state' = applyUnitPropagate state in\n      InvariantEquivalentZL (getF state') (getM state') Phi\n  \"", "lemma InvariantVarsQTl:\nassumes\n  \"InvariantVarsQ Q F0 Vbl\"\n  \"Q \\<noteq> []\"\nshows\n  \"InvariantVarsQ (tl Q) F0 Vbl\"", "lemma InvariantsVarsAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\" and\n  \"InvariantQCharacterization False (getQ state) (getF state) (getM state)\" and\n  \"getQ state \\<noteq> []\"\n  \"\\<not> getConflictFlag state\"\n  \"InvariantVarsM (getM state) F0 Vbl\" and\n  \"InvariantVarsQ (getQ state) F0 Vbl\" and\n  \"InvariantVarsF (getF state) F0 Vbl\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantVarsM (getM state') F0 Vbl \\<and> \n     InvariantVarsQ (getQ state') F0 Vbl\"", "lemma exhaustiveUnitPropagateTermination:\nfixes\n  state::State and Vbl::\"Variable set\"\nassumes \n  \"InvariantUniq (getM state)\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"InvariantVarsM (getM state) F0 Vbl\"\n  \"InvariantVarsQ (getQ state) F0 Vbl\"\n  \"InvariantVarsF (getF state) F0 Vbl\"\n  \"finite Vbl\"\nshows\n  \"exhaustiveUnitPropagate_dom state\"", "lemma exhaustiveUnitPropagatePreservedVariables:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       (getSATFlag state') = (getSATFlag state)\"", "lemma exhaustiveUnitPropagatePreservesCurrentLevel:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       currentLevel (getM state') = currentLevel (getM state)\"", "lemma InvariantsAfterExhaustiveUnitPropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"InvariantVarsQ (getQ state) F0 Vbl\"\n  \"InvariantVarsM (getM state) F0 Vbl\"\n  \"InvariantVarsF (getF state) F0 Vbl\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       InvariantConsistent (getM state') \\<and> \n       InvariantUniq (getM state') \\<and> \n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state') (getF state') \\<and> \n       InvariantWatchListsUniq (getWatchList state') \\<and> \n       InvariantWatchListsCharacterization (getWatchList state') (getWatch1 state') (getWatch2 state') \\<and> \n       InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state') \\<and> \n       InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state') \\<and> \n       InvariantWatchCharacterization (getF state') (getWatch1 state') (getWatch2 state') (getM state') \\<and> \n       InvariantConflictFlagCharacterization (getConflictFlag state') (getF state') (getM state') \\<and> \n       InvariantQCharacterization (getConflictFlag state') (getQ state') (getF state') (getM state') \\<and> \n       InvariantUniqQ (getQ state') \\<and> \n       InvariantVarsQ (getQ state') F0 Vbl \\<and> \n       InvariantVarsM (getM state') F0 Vbl \\<and> \n       InvariantVarsF (getF state') F0 Vbl\n\"", "lemma InvariantConflictClauseCharacterizationAfterExhaustivePropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantConflictClauseCharacterization (getConflictFlag state) (getConflictClause state) (getF state) (getM state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in\n   InvariantConflictClauseCharacterization (getConflictFlag state') (getConflictClause state') (getF state') (getM state')\"", "lemma InvariantsNoDecisionsWhenConflictNorUnitAfterExhaustivePropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"InvariantNoDecisionsWhenConflict (getF state) (getM state) (currentLevel (getM state))\"\n  \"InvariantNoDecisionsWhenUnit (getF state) (getM state) (currentLevel (getM state))\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in\n       InvariantNoDecisionsWhenConflict (getF state') (getM state') (currentLevel (getM state')) \\<and> \n       InvariantNoDecisionsWhenUnit (getF state') (getM state') (currentLevel (getM state'))\"", "lemma InvariantGetReasonIsReasonAfterExhaustiveUnitPropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\" and\n  \"InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       InvariantGetReasonIsReason (getReason state') (getF state') (getM state') (set (getQ state'))\"", "lemma InvariantEquivalentZLAfterExhaustiveUnitPropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantEquivalentZL (getF state) (getM state) Phi\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n      InvariantEquivalentZL (getF state') (getM state') Phi\n  \"", "lemma conflictFlagOrQEmptyAfterExhaustiveUnitPropagate:\nassumes\n\"exhaustiveUnitPropagate_dom state\"\nshows\n\"let state' = exhaustiveUnitPropagate state in\n    (getConflictFlag state') \\<or> (getQ state' = [])\""], "translations": [["", "lemma applyUnitPropagateEffect:\nassumes\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n\n  \"\\<not> (getConflictFlag state)\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let uLiteral = hd (getQ state) in\n   let state' = applyUnitPropagate state in\n      \\<exists> uClause. formulaEntailsClause (getF state) uClause \\<and> \n                 isUnitClause uClause uLiteral (elements (getM state)) \\<and> \n                 (getM state') = (getM state) @ [(uLiteral, False)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "obtain uClause\n    where \"uClause el (getF state)\" \"isUnitClause uClause ?uLiteral (elements (getM state))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>uClause el getF state;\n         isUnitClause uClause (hd (getQ state))\n          (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>uClause el getF state;\n         isUnitClause uClause (hd (getQ state))\n          (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding InvariantQCharacterization_def"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  \\<not> getConflictFlag state \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state =\n      (\\<exists>c.\n          c el getF state \\<and> isUnitClause c l (elements (getM state))))\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>uClause el getF state;\n         isUnitClause uClause (hd (getQ state))\n          (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  uClause el getF state\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "thus ?thesis"], ["proof (prove)\nusing this:\n  uClause el getF state\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "using assms"], ["proof (prove)\nusing this:\n  uClause el getF state\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "using assertLiteralEffect[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  uClause el getF state\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  uClause el getF state\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state);\n        state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "using formulaEntailsItsClauses[of \"uClause\" \"getF state\"]"], ["proof (prove)\nusing this:\n  uClause el getF state\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n  uClause el getF state \\<Longrightarrow>\n  formulaEntailsClause (getF state) uClause\n\ngoal (1 subgoal):\n 1. let uLiteral = hd (getQ state);\n        state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in \\<exists>uClause.\n          formulaEntailsClause (getF state) uClause \\<and>\n          isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n          getM state' = getM state @ [(uLiteral, False)]", "by (auto simp add: Let_def )"], ["proof (state)\nthis:\n  let uLiteral = hd (getQ state); state' = applyUnitPropagate state\n  in \\<exists>uClause.\n        formulaEntailsClause (getF state) uClause \\<and>\n        isUnitClause uClause uLiteral (elements (getM state)) \\<and>\n        getM state' = getM state @ [(uLiteral, False)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConsistentAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"getQ state \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantConsistent (getM state')\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "let ?state' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "obtain uClause \n    where \"isUnitClause uClause ?uLiteral (elements (getM state))\" and\n    \"(getM ?state') = (getM state) @ [(?uLiteral, False)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>isUnitClause uClause (hd (getQ state))\n                  (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>isUnitClause uClause (hd (getQ state))\n                  (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using applyUnitPropagateEffect[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl (getF state) (getWatch1 state)\n            (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<not> getConflictFlag state; getQ state \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let uLiteral = hd (getQ state);\n                        state' = applyUnitPropagate state\n                    in \\<exists>uClause.\n                          formulaEntailsClause (getF state) uClause \\<and>\n                          isUnitClause uClause uLiteral\n                           (elements (getM state)) \\<and>\n                          getM state' = getM state @ [(uLiteral, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>isUnitClause uClause (hd (getQ state))\n                  (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "thus ?thesis"], ["proof (prove)\nusing this:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "using assms"], ["proof (prove)\nusing this:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  InvariantConsistent (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "using InvariantConsistentAfterUnitPropagate[of \"getM state\" \"uClause\" \"?uLiteral\" \"getM ?state'\"]"], ["proof (prove)\nusing this:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  InvariantConsistent (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state);\n   isUnitClause uClause (hd (getQ state)) (elements (getM state));\n   getM (applyUnitPropagate state) =\n   getM state @ [(hd (getQ state), False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantConsistent (getM (applyUnitPropagate state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConsistent (getM state')", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state in InvariantConsistent (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantUniqAfterApplyUnitPropagate:\nassumes\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"getQ state \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantUniq (getM state')\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "let ?state' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "obtain uClause \n    where \"isUnitClause uClause ?uLiteral (elements (getM state))\" and\n    \"(getM ?state') = (getM state) @ [(?uLiteral, False)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>isUnitClause uClause (hd (getQ state))\n                  (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>isUnitClause uClause (hd (getQ state))\n                  (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using applyUnitPropagateEffect[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl (getF state) (getWatch1 state)\n            (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<not> getConflictFlag state; getQ state \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let uLiteral = hd (getQ state);\n                        state' = applyUnitPropagate state\n                    in \\<exists>uClause.\n                          formulaEntailsClause (getF state) uClause \\<and>\n                          isUnitClause uClause uLiteral\n                           (elements (getM state)) \\<and>\n                          getM state' = getM state @ [(uLiteral, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>isUnitClause uClause (hd (getQ state))\n                  (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "thus ?thesis"], ["proof (prove)\nusing this:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "using assms"], ["proof (prove)\nusing this:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "using InvariantUniqAfterUnitPropagate[of \"getM state\" \"uClause\" \"?uLiteral\" \"getM ?state'\"]"], ["proof (prove)\nusing this:\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantUniq (getM state);\n   isUnitClause uClause (hd (getQ state)) (elements (getM state));\n   getM (applyUnitPropagate state) =\n   getM state @ [(hd (getQ state), False)]\\<rbrakk>\n  \\<Longrightarrow> InvariantUniq (getM (applyUnitPropagate state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state in InvariantUniq (getM state')", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state in InvariantUniq (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantWatchCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"(getQ state) \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state' = applyUnitPropagate state in\n        InvariantWatchCharacterization (getF state') (getWatch1 state') (getWatch2 state') (getM state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "let ?state' = \"assertLiteral ?uLiteral False state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "let ?state'' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "have \"InvariantConsistent (getM ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "have \"InvariantUniq (getM ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "using InvariantUniqAfterApplyUnitPropagate[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "ultimately"], ["proof (chain)\npicking this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "using InvariantWatchCharacterizationAfterAssertLiteral[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantUniq (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "using assertLiteralEffect"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantUniq (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral ?l ?d ?state) =\n                    getM ?state @ [(?l, ?d)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral ?l ?d ?state) = getF ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag (assertLiteral ?l ?d ?state) =\n                    getSATFlag ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ ?state)\n                     (getQ (assertLiteral ?l ?d ?state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantUniq (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral ?l ?d ?state) =\n                    getM ?state @ [(?l, ?d)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral ?l ?d ?state) = getF ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag (assertLiteral ?l ?d ?state) =\n                    getSATFlag ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ ?state)\n                     (getQ (assertLiteral ?l ?d ?state))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state')", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state\n  in InvariantWatchCharacterization (getF state') (getWatch1 state')\n      (getWatch2 state') (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConflictFlagCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"\\<not> getConflictFlag state\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let state' = (applyUnitPropagate state) in\n      InvariantConflictFlagCharacterization (getConflictFlag state') (getF state') (getM state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "let ?state' = \"assertLiteral ?uLiteral False state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "let ?state'' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "have \"InvariantConsistent (getM ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "have \"InvariantUniq (getM ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "using InvariantUniqAfterApplyUnitPropagate[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "ultimately"], ["proof (chain)\npicking this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "using InvariantConflictFlagCharacterizationAfterAssertLiteral[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "using assertLiteralEffect"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral ?l ?d ?state) =\n                    getM ?state @ [(?l, ?d)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral ?l ?d ?state) = getF ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag (assertLiteral ?l ?d ?state) =\n                    getSATFlag ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ ?state)\n                     (getQ (assertLiteral ?l ?d ?state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantUniq (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral ?l ?d ?state) =\n                    getM ?state @ [(?l, ?d)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral ?l ?d ?state) = getF ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag (assertLiteral ?l ?d ?state) =\n                    getSATFlag ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ ?state)\n                     (getQ (assertLiteral ?l ?d ?state))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state')", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state\n  in InvariantConflictFlagCharacterization (getConflictFlag state')\n      (getF state') (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConflictClauseCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\"\n  \"\\<not> getConflictFlag state\"\nshows\n   \"let state' = applyUnitPropagate state in\n    InvariantConflictClauseCharacterization (getConflictFlag state') (getConflictClause state') (getF state') (getM state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "using assms"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "using InvariantConflictClauseCharacterizationAfterAssertLiteral[of \"state\" \"hd (getQ state)\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl (getF state) (getWatch1 state)\n            (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantConflictClauseCharacterization (getConflictFlag state)\n    (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl (getF state) (getWatch1 state)\n            (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantConflictClauseCharacterization (getConflictFlag state)\n    (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "unfolding InvariantWatchesEl_def"], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     0 \\<le> clause \\<and> clause < length (getF state) \\<longrightarrow>\n     (\\<exists>w1 w2.\n         getWatch1 state clause = Some w1 \\<and>\n         getWatch2 state clause = Some w2 \\<and>\n         w1 el getF state ! clause \\<and> w2 el getF state ! clause)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  \\<not> getConflictFlag state\n  \\<lbrakk>\\<forall>clause.\n              0 \\<le> clause \\<and>\n              clause < length (getF state) \\<longrightarrow>\n              (\\<exists>w1 w2.\n                  getWatch1 state clause = Some w1 \\<and>\n                  getWatch2 state clause = Some w2 \\<and>\n                  w1 el getF state ! clause \\<and>\n                  w2 el getF state ! clause);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantConflictClauseCharacterization (getConflictFlag state)\n    (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "unfolding InvariantWatchListsContainOnlyClausesFromF_def"], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     0 \\<le> clause \\<and> clause < length (getF state) \\<longrightarrow>\n     (\\<exists>w1 w2.\n         getWatch1 state clause = Some w1 \\<and>\n         getWatch2 state clause = Some w2 \\<and>\n         w1 el getF state ! clause \\<and> w2 el getF state ! clause)\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  \\<not> getConflictFlag state\n  \\<lbrakk>\\<forall>clause.\n              0 \\<le> clause \\<and>\n              clause < length (getF state) \\<longrightarrow>\n              (\\<exists>w1 w2.\n                  getWatch1 state clause = Some w1 \\<and>\n                  getWatch2 state clause = Some w2 \\<and>\n                  w1 el getF state ! clause \\<and>\n                  w2 el getF state ! clause);\n   \\<forall>l c.\n      c \\<in> set (getWatchList state l) \\<longrightarrow>\n      0 \\<le> c \\<and> c < length (getF state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantConflictClauseCharacterization (getConflictFlag state)\n    (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "unfolding InvariantWatchListsCharacterization_def"], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     0 \\<le> clause \\<and> clause < length (getF state) \\<longrightarrow>\n     (\\<exists>w1 w2.\n         getWatch1 state clause = Some w1 \\<and>\n         getWatch2 state clause = Some w2 \\<and>\n         w1 el getF state ! clause \\<and> w2 el getF state ! clause)\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  InvariantWatchListsUniq (getWatchList state)\n  \\<not> getConflictFlag state\n  \\<lbrakk>\\<forall>clause.\n              0 \\<le> clause \\<and>\n              clause < length (getF state) \\<longrightarrow>\n              (\\<exists>w1 w2.\n                  getWatch1 state clause = Some w1 \\<and>\n                  getWatch2 state clause = Some w2 \\<and>\n                  w1 el getF state ! clause \\<and>\n                  w2 el getF state ! clause);\n   \\<forall>l c.\n      c \\<in> set (getWatchList state l) \\<longrightarrow>\n      0 \\<le> c \\<and> c < length (getF state);\n   \\<forall>c l.\n      (c \\<in> set (getWatchList state l)) =\n      (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantConflictClauseCharacterization (getConflictFlag state)\n    (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "unfolding InvariantWatchListsUniq_def"], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     0 \\<le> clause \\<and> clause < length (getF state) \\<longrightarrow>\n     (\\<exists>w1 w2.\n         getWatch1 state clause = Some w1 \\<and>\n         getWatch2 state clause = Some w2 \\<and>\n         w1 el getF state ! clause \\<and> w2 el getF state ! clause)\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  \\<forall>l. uniq (getWatchList state l)\n  \\<not> getConflictFlag state\n  \\<lbrakk>\\<forall>clause.\n              0 \\<le> clause \\<and>\n              clause < length (getF state) \\<longrightarrow>\n              (\\<exists>w1 w2.\n                  getWatch1 state clause = Some w1 \\<and>\n                  getWatch2 state clause = Some w2 \\<and>\n                  w1 el getF state ! clause \\<and>\n                  w2 el getF state ! clause);\n   \\<forall>l c.\n      c \\<in> set (getWatchList state l) \\<longrightarrow>\n      0 \\<le> c \\<and> c < length (getF state);\n   \\<forall>c l.\n      (c \\<in> set (getWatchList state l)) =\n      (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c);\n   \\<forall>l. uniq (getWatchList state l);\n   InvariantConflictClauseCharacterization (getConflictFlag state)\n    (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "unfolding InvariantConflictClauseCharacterization_def"], ["proof (prove)\nusing this:\n  \\<forall>clause.\n     0 \\<le> clause \\<and> clause < length (getF state) \\<longrightarrow>\n     (\\<exists>w1 w2.\n         getWatch1 state clause = Some w1 \\<and>\n         getWatch2 state clause = Some w2 \\<and>\n         w1 el getF state ! clause \\<and> w2 el getF state ! clause)\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  \\<forall>l. uniq (getWatchList state l)\n  \\<not> getConflictFlag state\n  \\<lbrakk>\\<forall>clause.\n              0 \\<le> clause \\<and>\n              clause < length (getF state) \\<longrightarrow>\n              (\\<exists>w1 w2.\n                  getWatch1 state clause = Some w1 \\<and>\n                  getWatch2 state clause = Some w2 \\<and>\n                  w1 el getF state ! clause \\<and>\n                  w2 el getF state ! clause);\n   \\<forall>l c.\n      c \\<in> set (getWatchList state l) \\<longrightarrow>\n      0 \\<le> c \\<and> c < length (getF state);\n   \\<forall>c l.\n      (c \\<in> set (getWatchList state l)) =\n      (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c);\n   \\<forall>l. uniq (getWatchList state l);\n   getConflictFlag state \\<longrightarrow>\n   getConflictClause state < length (getF state) \\<and>\n   clauseFalse (getF state ! getConflictClause state)\n    (elements (getM state))\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in getConflictFlag state' \\<longrightarrow>\n                       getConflictClause state'\n                       < length (getF state') \\<and>\n                       clauseFalse (getF state' ! getConflictClause state')\n                        (elements (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in getConflictFlag state' \\<longrightarrow>\n       getConflictClause state' < length (getF state') \\<and>\n       clauseFalse (getF state' ! getConflictClause state')\n        (elements (getM state'))", "by (simp add: Let_def)"], ["", "lemma InvariantQCharacterizationAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"(getQ state) \\<noteq> []\"\n  \"\\<not> (getConflictFlag state)\"\nshows\n  \"let state'' = applyUnitPropagate state in\n     InvariantQCharacterization (getConflictFlag state'') (getQ state'') (getF state'') (getM state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "let ?state' = \"assertLiteral ?uLiteral False state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "let ?state'' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "have \"InvariantConsistent (getM ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "hence \"InvariantQCharacterization (getConflictFlag ?state') (removeAll ?uLiteral (getQ ?state')) (getF ?state') (getM ?state')\""], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization\n     (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n     (removeAll (hd (getQ state))\n       (getQ (assertLiteral (hd (getQ state)) False state)))\n     (getF (assertLiteral (hd (getQ state)) False state))\n     (getM (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization\n     (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n     (removeAll (hd (getQ state))\n       (getQ (assertLiteral (hd (getQ state)) False state)))\n     (getF (assertLiteral (hd (getQ state)) False state))\n     (getM (assertLiteral (hd (getQ state)) False state))", "using InvariantQCharacterizationAfterAssertLiteral[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantQCharacterization (getConflictFlag state')\n                        (removeAll (hd (getQ state)) (getQ state'))\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization\n     (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n     (removeAll (hd (getQ state))\n       (getQ (assertLiteral (hd (getQ state)) False state)))\n     (getF (assertLiteral (hd (getQ state)) False state))\n     (getM (assertLiteral (hd (getQ state)) False state))", "using assertLiteralEffect[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantQCharacterization (getConflictFlag state')\n                        (removeAll (hd (getQ state)) (getQ state'))\n                        (getF state') (getM state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization\n     (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n     (removeAll (hd (getQ state))\n       (getQ (assertLiteral (hd (getQ state)) False state)))\n     (getF (assertLiteral (hd (getQ state)) False state))\n     (getM (assertLiteral (hd (getQ state)) False state))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantQCharacterization\n   (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n   (removeAll (hd (getQ state))\n     (getQ (assertLiteral (hd (getQ state)) False state)))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "moreover"], ["proof (state)\nthis:\n  InvariantQCharacterization\n   (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n   (removeAll (hd (getQ state))\n     (getQ (assertLiteral (hd (getQ state)) False state)))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "have \"InvariantUniqQ (getQ ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))", "using InvariantUniqQAfterAssertLiteral[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantUniqQ (getQ state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "have \"?uLiteral = (hd (getQ ?state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (getQ state) =\n    hd (getQ (assertLiteral (hd (getQ state)) False state))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (getQ state) =\n    hd (getQ (assertLiteral (hd (getQ state)) False state))", "obtain s \n      where \"(getQ state) @ s = getQ ?state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assertLiteralEffect[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s.\n                       getQ state @ s =\n                       getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getQ state @ s = getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. hd (getQ state) =\n    hd (getQ (assertLiteral (hd (getQ state)) False state))", "hence \"getQ ?state' = (getQ state) @ s\""], ["proof (prove)\nusing this:\n  getQ state @ s = getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s", "by (rule sym)"], ["proof (state)\nthis:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n\ngoal (1 subgoal):\n 1. hd (getQ state) =\n    hd (getQ (assertLiteral (hd (getQ state)) False state))", "thus ?thesis"], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n\ngoal (1 subgoal):\n 1. hd (getQ state) =\n    hd (getQ (assertLiteral (hd (getQ state)) False state))", "using \\<open>getQ state \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (getQ state) =\n    hd (getQ (assertLiteral (hd (getQ state)) False state))", "using hd_append[of \"getQ state\" \"s\"]"], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n  getQ state \\<noteq> []\n  hd (getQ state @ s) = (if getQ state = [] then hd s else hd (getQ state))\n\ngoal (1 subgoal):\n 1. hd (getQ state) =\n    hd (getQ (assertLiteral (hd (getQ state)) False state))", "by auto"], ["proof (state)\nthis:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "hence \"set (getQ ?state'') = set (removeAll ?uLiteral (getQ ?state'))\""], ["proof (prove)\nusing this:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using assms"], ["proof (prove)\nusing this:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using \\<open>InvariantUniqQ (getQ ?state')\\<close>"], ["proof (prove)\nusing this:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "unfolding InvariantUniqQ_def"], ["proof (prove)\nusing this:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  uniq (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using uniqHeadTailSet[of \"getQ ?state'\"]"], ["proof (prove)\nusing this:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  uniq (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  uniq\n   (getQ (assertLiteral (hd (getQ state)) False state)) \\<Longrightarrow>\n  set (tl (getQ (assertLiteral (hd (getQ state)) False state))) =\n  set (getQ (assertLiteral (hd (getQ state)) False state)) -\n  {hd (getQ (assertLiteral (hd (getQ state)) False state))}\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  hd (getQ state) = hd (getQ (assertLiteral (hd (getQ state)) False state))\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  uniq (getQ state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  uniq\n   (getQ (assertLiteral (hd (getQ state)) False state)) \\<Longrightarrow>\n  set (tl (getQ (assertLiteral (hd (getQ state)) False state))) =\n  set (getQ (assertLiteral (hd (getQ state)) False state)) -\n  {hd (getQ (assertLiteral (hd (getQ state)) False state))}\n\ngoal (1 subgoal):\n 1. set (getQ\n          (let state' = assertLiteral (hd (getQ state)) False state\n           in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "ultimately"], ["proof (chain)\npicking this:\n  InvariantQCharacterization\n   (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n   (removeAll (hd (getQ state))\n     (getQ (assertLiteral (hd (getQ state)) False state)))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantQCharacterization\n   (getConflictFlag (assertLiteral (hd (getQ state)) False state))\n   (removeAll (hd (getQ state))\n     (getQ (assertLiteral (hd (getQ state)) False state)))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n        (getF state'') (getM state'')", "unfolding InvariantQCharacterization_def"], ["proof (prove)\nusing this:\n  \\<not> getConflictFlag\n          (assertLiteral (hd (getQ state)) False state) \\<longrightarrow>\n  (\\<forall>l.\n      l el\n      removeAll (hd (getQ state))\n       (getQ (assertLiteral (hd (getQ state)) False state)) =\n      (\\<exists>c.\n          c el getF (assertLiteral (hd (getQ state)) False state) \\<and>\n          isUnitClause c l\n           (elements (getM (assertLiteral (hd (getQ state)) False state)))))\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state\n    in \\<not> getConflictFlag state'' \\<longrightarrow>\n       (\\<forall>l.\n           l el getQ state'' =\n           (\\<exists>c.\n               c el getF state'' \\<and>\n               isUnitClause c l (elements (getM state''))))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<not> getConflictFlag\n          (assertLiteral (hd (getQ state)) False state) \\<longrightarrow>\n  (\\<forall>l.\n      l el\n      removeAll (hd (getQ state))\n       (getQ (assertLiteral (hd (getQ state)) False state)) =\n      (\\<exists>c.\n          c el getF (assertLiteral (hd (getQ state)) False state) \\<and>\n          isUnitClause c l\n           (elements (getM (assertLiteral (hd (getQ state)) False state)))))\n  set (getQ\n        (let state' = assertLiteral (hd (getQ state)) False state\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state'' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in \\<not> getConflictFlag state'' \\<longrightarrow>\n       (\\<forall>l.\n           l el getQ state'' =\n           (\\<exists>c.\n               c el getF state'' \\<and>\n               isUnitClause c l (elements (getM state''))))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state'' = applyUnitPropagate state\n  in InvariantQCharacterization (getConflictFlag state'') (getQ state'')\n      (getF state'') (getM state'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantUniqQAfterApplyUnitPropagate:\nassumes\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let state'' = applyUnitPropagate state in\n      InvariantUniqQ (getQ state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "let ?state' = \"assertLiteral ?uLiteral False state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "let ?state'' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "have \"InvariantUniqQ (getQ ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))", "using InvariantUniqQAfterAssertLiteral[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantUniqQ (getQ state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "moreover"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "obtain s \n    where \"getQ state @ s = getQ ?state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assertLiteralEffect[of \"state\" \"?uLiteral\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantUniqQ (getQ state)\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s.\n                       getQ state @ s =\n                       getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getQ state @ s = getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "hence \"getQ ?state' = getQ state @ s\""], ["proof (prove)\nusing this:\n  getQ state @ s = getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s", "by (rule sym)"], ["proof (state)\nthis:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "with \\<open>getQ state \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  getQ state \\<noteq> []\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s", "have \"getQ ?state' \\<noteq> []\""], ["proof (prove)\nusing this:\n  getQ state \\<noteq> []\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "ultimately"], ["proof (chain)\npicking this:\n  InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "using \\<open>getQ state \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  InvariantUniqQ (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')", "unfolding InvariantUniqQ_def"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. let state'' = applyUnitPropagate state in uniq (getQ state'')", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. let state'' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in uniq (getQ state'')", "using hd_Cons_tl[of \"getQ ?state'\"]"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n  getQ state \\<noteq> []\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq>\n  [] \\<Longrightarrow>\n  hd (getQ (assertLiteral (hd (getQ state)) False state)) #\n  tl (getQ (assertLiteral (hd (getQ state)) False state)) =\n  getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. let state'' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in uniq (getQ state'')", "using uniqAppendIff[of \"[hd (getQ ?state')]\" \"tl (getQ ?state')\"]"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n  getQ state \\<noteq> []\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq>\n  [] \\<Longrightarrow>\n  hd (getQ (assertLiteral (hd (getQ state)) False state)) #\n  tl (getQ (assertLiteral (hd (getQ state)) False state)) =\n  getQ (assertLiteral (hd (getQ state)) False state)\n  uniq\n   ([hd (getQ (assertLiteral (hd (getQ state)) False state))] @\n    tl (getQ (assertLiteral (hd (getQ state)) False state))) =\n  (uniq [hd (getQ (assertLiteral (hd (getQ state)) False state))] \\<and>\n   uniq (tl (getQ (assertLiteral (hd (getQ state)) False state))) \\<and>\n   set [hd (getQ (assertLiteral (hd (getQ state)) False state))] \\<inter>\n   set (tl (getQ (assertLiteral (hd (getQ state)) False state))) =\n   {})\n\ngoal (1 subgoal):\n 1. let state'' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in uniq (getQ state'')", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state'' = applyUnitPropagate state in InvariantUniqQ (getQ state'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantNoDecisionsWhenConflictNorUnitAfterUnitPropagate:\nassumes \n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantNoDecisionsWhenConflict (getF state) (getM state) (currentLevel (getM state))\"\n  \"InvariantNoDecisionsWhenUnit (getF state) (getM state) (currentLevel (getM state))\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantNoDecisionsWhenConflict (getF state') (getM state') (currentLevel (getM state')) \\<and> \n     InvariantNoDecisionsWhenUnit (getF state') (getM state') (currentLevel (getM state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "using assms"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantNoDecisionsWhenConflict (getF state) (getM state)\n   (currentLevel (getM state))\n  InvariantNoDecisionsWhenUnit (getF state) (getM state)\n   (currentLevel (getM state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantNoDecisionsWhenConflict (getF state) (getM state)\n   (currentLevel (getM state))\n  InvariantNoDecisionsWhenUnit (getF state) (getM state)\n   (currentLevel (getM state))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "using InvariantsNoDecisionsWhenConflictNorUnitAfterAssertLiteral[of \"state\" \"False\" \"hd (getQ state)\"]"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantNoDecisionsWhenConflict (getF state) (getM state)\n   (currentLevel (getM state))\n  InvariantNoDecisionsWhenUnit (getF state) (getM state)\n   (currentLevel (getM state))\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   InvariantNoDecisionsWhenConflict (getF state) (getM state)\n    (currentLevel (getM state));\n   InvariantNoDecisionsWhenUnit (getF state) (getM state)\n    (currentLevel (getM state));\n   False \\<longrightarrow>\n   \\<not> getConflictFlag state \\<and> getQ state = []\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "unfolding InvariantNoDecisionsWhenConflict_def"], ["proof (prove)\nusing this:\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<forall>level'<currentLevel (getM state).\n     \\<not> formulaFalse (getF state)\n             (elements (prefixToLevel level' (getM state)))\n  InvariantNoDecisionsWhenUnit (getF state) (getM state)\n   (currentLevel (getM state))\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantConflictFlagCharacterization (getConflictFlag state)\n    (getF state) (getM state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<forall>level'<currentLevel (getM state).\n      \\<not> formulaFalse (getF state)\n              (elements (prefixToLevel level' (getM state)));\n   InvariantNoDecisionsWhenUnit (getF state) (getM state)\n    (currentLevel (getM state));\n   False \\<longrightarrow>\n   \\<not> getConflictFlag state \\<and> getQ state = []\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in (\\<forall>level'<currentLevel (getM state').\n                           \\<not> formulaFalse (getF state')\n                                   (elements\n                                     (prefixToLevel level'\n (getM state')))) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in (\\<forall>level'<currentLevel (getM state').\n           \\<not> formulaFalse (getF state')\n                   (elements (prefixToLevel level' (getM state')))) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "by (simp add: Let_def)"], ["", "lemma InvariantGetReasonIsReasonAfterApplyUnitPropagate:\nassumes\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\" and\n  \"InvariantUniqQ (getQ state)\" and\n  \"InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\" and\n  \"getQ state \\<noteq> []\" and\n  \"\\<not> getConflictFlag state\" \nshows\n  \"let state' = applyUnitPropagate state in \n     InvariantGetReasonIsReason (getReason state') (getF state') (getM state') (set (getQ state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "let ?state0 = \"state \\<lparr> getM := getM state @ [(hd (getQ state), False)]\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "let ?state' = \"assertLiteral (hd (getQ state)) False state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "let ?state'' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantGetReasonIsReason (getReason ?state0) (getF ?state0) (getM ?state0) (set (removeAll (hd (getQ ?state0)) (getQ ?state0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "fix l::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "assume *: \"l el (elements (getM ?state0)) \\<and> \\<not> l el (decisions (getM ?state0)) \\<and> elementLevel l (getM ?state0) > 0\""], ["proof (state)\nthis:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "hence \"\\<exists> reason. getReason ?state0 l = Some reason \\<and> 0 \\<le> reason \\<and> reason < length (getF ?state0) \\<and> \n               isReason (nth (getF ?state0) reason) l (elements (getM ?state0))\""], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "proof (cases \"l el (elements (getM state))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n 2. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "case True"], ["proof (state)\nthis:\n  l el elements (getM state)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n 2. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "from *"], ["proof (chain)\npicking this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))", "have \"\\<not> l el (decisions (getM state))\""], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<not> l el decisions (getM state)", "by (auto simp add: markedElementsAppend)"], ["proof (state)\nthis:\n  \\<not> l el decisions (getM state)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n 2. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "from *"], ["proof (chain)\npicking this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))", "have \"elementLevel l (getM state) > 0\""], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "using elementLevelAppend[of \"l\" \"getM state\" \"[(hd (getQ state), False)]\"]"], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n  l \\<in> set (elements (getM state)) \\<Longrightarrow>\n  elementLevel l (getM state) =\n  elementLevel l (getM state @ [(hd (getQ state), False)])\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "using \\<open>l el (elements (getM state))\\<close>"], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n  l \\<in> set (elements (getM state)) \\<Longrightarrow>\n  elementLevel l (getM state) =\n  elementLevel l (getM state @ [(hd (getQ state), False)])\n  l el elements (getM state)\n\ngoal (1 subgoal):\n 1. 0 < elementLevel l (getM state)", "by simp"], ["proof (state)\nthis:\n  0 < elementLevel l (getM state)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n 2. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "using \\<open>InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\\<close>"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "using \\<open>l el (elements (getM state))\\<close>"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  l el elements (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "using \\<open>\\<not> l el (decisions (getM state))\\<close>"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  l el elements (getM state)\n  \\<not> l el decisions (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "using \\<open>elementLevel l (getM state) > 0\\<close>"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  l el elements (getM state)\n  \\<not> l el decisions (getM state)\n  0 < elementLevel l (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "unfolding InvariantGetReasonIsReason_def"], ["proof (prove)\nusing this:\n  \\<forall>literal.\n     (literal el elements (getM state) \\<and>\n      \\<not> literal el decisions (getM state) \\<and>\n      0 < elementLevel literal (getM state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          isReason (getF state ! reason) literal\n           (elements (getM state)))) \\<and>\n     (0 < currentLevel (getM state) \\<and>\n      literal \\<in> set (getQ state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          (isUnitClause (getF state ! reason) literal\n            (elements (getM state)) \\<or>\n           clauseFalse (getF state ! reason) (elements (getM state)))))\n  l el elements (getM state)\n  \\<not> l el decisions (getM state)\n  0 < elementLevel l (getM state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "by (auto simp add: isReasonAppend)"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      l =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      l (elements\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "case False"], ["proof (state)\nthis:\n  \\<not> l el elements (getM state)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "with *"], ["proof (chain)\npicking this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n  \\<not> l el elements (getM state)", "have \"l = hd (getQ state)\""], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n  \\<not> l el elements (getM state)\n\ngoal (1 subgoal):\n 1. l = hd (getQ state)", "by simp"], ["proof (state)\nthis:\n  l = hd (getQ state)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "have \"currentLevel (getM ?state0) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < currentLevel\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))", "using *"], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. 0 < currentLevel\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))", "using elementLevelLeqCurrentLevel[of \"l\" \"getM ?state0\"]"], ["proof (prove)\nusing this:\n  l el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> l el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel l\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n  elementLevel l\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n  \\<le> currentLevel\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. 0 < currentLevel\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))", "by auto"], ["proof (state)\nthis:\n  0 < currentLevel\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "hence \"currentLevel (getM state) > 0\""], ["proof (prove)\nusing this:\n  0 < currentLevel\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. 0 < currentLevel (getM state)", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  0 < length\n       (decisions\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. 0 < length (decisions (getM state))", "by (simp add: markedElementsAppend)"], ["proof (state)\nthis:\n  0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "moreover"], ["proof (state)\nthis:\n  0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "have \"hd (getQ ?state0) el (getQ state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (getQ\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(hd (getQ state), False)]\\<rparr>)) el\n    getQ state", "using \\<open>getQ state \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (getQ\n         (state\n          \\<lparr>getM :=\n                    getM state @ [(hd (getQ state), False)]\\<rparr>)) el\n    getQ state", "by simp"], ["proof (state)\nthis:\n  hd (getQ\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)) el\n  getQ state\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "ultimately"], ["proof (chain)\npicking this:\n  0 < currentLevel (getM state)\n  hd (getQ\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)) el\n  getQ state", "obtain reason\n          where \"getReason state (hd (getQ state)) = Some reason\" \"0 \\<le> reason \\<and> reason < length (getF state)\"\n          \"isUnitClause (nth (getF state) reason) (hd (getQ state)) (elements (getM state)) \\<or> \n           clauseFalse (nth (getF state) reason) (elements (getM state))\""], ["proof (prove)\nusing this:\n  0 < currentLevel (getM state)\n  hd (getQ\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)) el\n  getQ state\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        \\<lbrakk>getReason state (hd (getQ state)) = Some reason;\n         0 \\<le> reason \\<and> reason < length (getF state);\n         isUnitClause (getF state ! reason) (hd (getQ state))\n          (elements (getM state)) \\<or>\n         clauseFalse (getF state ! reason) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\\<close>"], ["proof (prove)\nusing this:\n  0 < currentLevel (getM state)\n  hd (getQ\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)) el\n  getQ state\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        \\<lbrakk>getReason state (hd (getQ state)) = Some reason;\n         0 \\<le> reason \\<and> reason < length (getF state);\n         isUnitClause (getF state ! reason) (hd (getQ state))\n          (elements (getM state)) \\<or>\n         clauseFalse (getF state ! reason) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding InvariantGetReasonIsReason_def"], ["proof (prove)\nusing this:\n  0 < currentLevel (getM state)\n  hd (getQ\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)) el\n  getQ state\n  \\<forall>literal.\n     (literal el elements (getM state) \\<and>\n      \\<not> literal el decisions (getM state) \\<and>\n      0 < elementLevel literal (getM state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          isReason (getF state ! reason) literal\n           (elements (getM state)))) \\<and>\n     (0 < currentLevel (getM state) \\<and>\n      literal \\<in> set (getQ state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          (isUnitClause (getF state ! reason) literal\n            (elements (getM state)) \\<or>\n           clauseFalse (getF state ! reason) (elements (getM state)))))\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        \\<lbrakk>getReason state (hd (getQ state)) = Some reason;\n         0 \\<le> reason \\<and> reason < length (getF state);\n         isUnitClause (getF state ! reason) (hd (getQ state))\n          (elements (getM state)) \\<or>\n         clauseFalse (getF state ! reason) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "hence \"isUnitClause (nth (getF state) reason) (hd (getQ state)) (elements (getM state))\""], ["proof (prove)\nusing this:\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n\ngoal (1 subgoal):\n 1. isUnitClause (getF state ! reason) (hd (getQ state))\n     (elements (getM state))", "using \\<open>\\<not> getConflictFlag state\\<close>"], ["proof (prove)\nusing this:\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. isUnitClause (getF state ! reason) (hd (getQ state))\n     (elements (getM state))", "using \\<open>InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\\<close>"], ["proof (prove)\nusing this:\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n  \\<not> getConflictFlag state\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n\ngoal (1 subgoal):\n 1. isUnitClause (getF state ! reason) (hd (getQ state))\n     (elements (getM state))", "unfolding InvariantConflictFlagCharacterization_def"], ["proof (prove)\nusing this:\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n  \\<not> getConflictFlag state\n  getConflictFlag state = formulaFalse (getF state) (elements (getM state))\n\ngoal (1 subgoal):\n 1. isUnitClause (getF state ! reason) (hd (getQ state))\n     (elements (getM state))", "using nth_mem[of \"reason\" \"getF state\"]"], ["proof (prove)\nusing this:\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n  \\<not> getConflictFlag state\n  getConflictFlag state = formulaFalse (getF state) (elements (getM state))\n  reason < length (getF state) \\<Longrightarrow>\n  getF state ! reason \\<in> set (getF state)\n\ngoal (1 subgoal):\n 1. isUnitClause (getF state ! reason) (hd (getQ state))\n     (elements (getM state))", "using formulaFalseIffContainsFalseClause[of \"getF state\" \"elements (getM state)\"]"], ["proof (prove)\nusing this:\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n  \\<not> getConflictFlag state\n  getConflictFlag state = formulaFalse (getF state) (elements (getM state))\n  reason < length (getF state) \\<Longrightarrow>\n  getF state ! reason \\<in> set (getF state)\n  formulaFalse (getF state) (elements (getM state)) =\n  (\\<exists>clause.\n      clause el getF state \\<and>\n      clauseFalse clause (elements (getM state)))\n\ngoal (1 subgoal):\n 1. isUnitClause (getF state ! reason) (hd (getQ state))\n     (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l el\n             elements\n              (getM\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)) \\<and>\n             \\<not> l el\n                    decisions\n                     (getM\n                       (state\n                        \\<lparr>getM :=\n                                  getM state @\n                                  [(hd (getQ state),\n                                    False)]\\<rparr>)) \\<and>\n             0 < elementLevel l\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>));\n     \\<not> l el elements (getM state)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          l =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         isReason\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                           reason)\n                          l (elements\n                              (getM\n                                (state\n                                 \\<lparr>getM :=\n     getM state @ [(hd (getQ state), False)]\\<rparr>)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "using \\<open>getReason state (hd (getQ state)) = Some reason\\<close> \\<open>0 \\<le> reason \\<and> reason < length (getF state)\\<close>"], ["proof (prove)\nusing this:\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state))\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "using isUnitClauseIsReason[of \"nth (getF state) reason\" \"hd (getQ state)\" \"elements (getM state)\" \"[hd (getQ state)]\"]"], ["proof (prove)\nusing this:\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state))\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  \\<lbrakk>isUnitClause (getF state ! reason) (hd (getQ state))\n            (elements (getM state));\n   hd (getQ state) el [hd (getQ state)]\\<rbrakk>\n  \\<Longrightarrow> isReason (getF state ! reason) (hd (getQ state))\n                     (elements (getM state) @ [hd (getQ state)])\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "using \\<open>l = hd (getQ state)\\<close>"], ["proof (prove)\nusing this:\n  isUnitClause (getF state ! reason) (hd (getQ state))\n   (elements (getM state))\n  getReason state (hd (getQ state)) = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  \\<lbrakk>isUnitClause (getF state ! reason) (hd (getQ state))\n            (elements (getM state));\n   hd (getQ state) el [hd (getQ state)]\\<rbrakk>\n  \\<Longrightarrow> isReason (getF state ! reason) (hd (getQ state))\n                     (elements (getM state) @ [hd (getQ state)])\n  l = hd (getQ state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        l =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       isReason\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>) !\n         reason)\n        l (elements\n            (getM\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>)))", "by simp"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      l =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      l (elements\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      l =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      l (elements\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "}"], ["proof (state)\nthis:\n  ?l2 el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> ?l2 el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel ?l2\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @\n                    [(hd (getQ state), False)]\\<rparr>)) \\<Longrightarrow>\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      ?l2 =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      ?l2\n      (elements\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "moreover"], ["proof (state)\nthis:\n  ?l2 el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> ?l2 el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel ?l2\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @\n                    [(hd (getQ state), False)]\\<rparr>)) \\<Longrightarrow>\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      ?l2 =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      ?l2\n      (elements\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "{"], ["proof (state)\nthis:\n  ?l2 el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> ?l2 el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel ?l2\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @\n                    [(hd (getQ state), False)]\\<rparr>)) \\<Longrightarrow>\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      ?l2 =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      ?l2\n      (elements\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "fix literal::Literal"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "assume \"currentLevel (getM ?state0) > 0\""], ["proof (state)\nthis:\n  0 < currentLevel\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "hence \"currentLevel (getM state) > 0\""], ["proof (prove)\nusing this:\n  0 < currentLevel\n       (getM\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. 0 < currentLevel (getM state)", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  0 < length\n       (decisions\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>)))\n\ngoal (1 subgoal):\n 1. 0 < length (decisions (getM state))", "by (simp add: markedElementsAppend)"], ["proof (state)\nthis:\n  0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "assume\"literal el removeAll (hd (getQ ?state0)) (getQ ?state0)\""], ["proof (state)\nthis:\n  literal el\n  removeAll\n   (hd (getQ\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)))\n   (getQ\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "hence \"literal \\<noteq> hd (getQ state)\" \"literal el getQ state\""], ["proof (prove)\nusing this:\n  literal el\n  removeAll\n   (hd (getQ\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)))\n   (getQ\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n\ngoal (1 subgoal):\n 1. literal \\<noteq> hd (getQ state) &&& literal el getQ state", "by auto"], ["proof (state)\nthis:\n  literal \\<noteq> hd (getQ state)\n  literal el getQ state\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "then"], ["proof (chain)\npicking this:\n  literal \\<noteq> hd (getQ state)\n  literal el getQ state", "obtain reason\n        where \"getReason state literal = Some reason\" \"0 \\<le> reason \\<and> reason < length (getF state)\" and\n        *: \"isUnitClause (nth (getF state) reason) literal (elements (getM state)) \\<or> \n            clauseFalse (nth (getF state) reason) (elements (getM state))\""], ["proof (prove)\nusing this:\n  literal \\<noteq> hd (getQ state)\n  literal el getQ state\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        \\<lbrakk>getReason state literal = Some reason;\n         0 \\<le> reason \\<and> reason < length (getF state);\n         isUnitClause (getF state ! reason) literal\n          (elements (getM state)) \\<or>\n         clauseFalse (getF state ! reason) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>currentLevel (getM state) > 0\\<close>"], ["proof (prove)\nusing this:\n  literal \\<noteq> hd (getQ state)\n  literal el getQ state\n  0 < currentLevel (getM state)\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        \\<lbrakk>getReason state literal = Some reason;\n         0 \\<le> reason \\<and> reason < length (getF state);\n         isUnitClause (getF state ! reason) literal\n          (elements (getM state)) \\<or>\n         clauseFalse (getF state ! reason) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\\<close>"], ["proof (prove)\nusing this:\n  literal \\<noteq> hd (getQ state)\n  literal el getQ state\n  0 < currentLevel (getM state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        \\<lbrakk>getReason state literal = Some reason;\n         0 \\<le> reason \\<and> reason < length (getF state);\n         isUnitClause (getF state ! reason) literal\n          (elements (getM state)) \\<or>\n         clauseFalse (getF state ! reason) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding InvariantGetReasonIsReason_def"], ["proof (prove)\nusing this:\n  literal \\<noteq> hd (getQ state)\n  literal el getQ state\n  0 < currentLevel (getM state)\n  \\<forall>literal.\n     (literal el elements (getM state) \\<and>\n      \\<not> literal el decisions (getM state) \\<and>\n      0 < elementLevel literal (getM state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          isReason (getF state ! reason) literal\n           (elements (getM state)))) \\<and>\n     (0 < currentLevel (getM state) \\<and>\n      literal \\<in> set (getQ state) \\<longrightarrow>\n      (\\<exists>reason.\n          getReason state literal = Some reason \\<and>\n          0 \\<le> reason \\<and>\n          reason < length (getF state) \\<and>\n          (isUnitClause (getF state ! reason) literal\n            (elements (getM state)) \\<or>\n           clauseFalse (getF state ! reason) (elements (getM state)))))\n\ngoal (1 subgoal):\n 1. (\\<And>reason.\n        \\<lbrakk>getReason state literal = Some reason;\n         0 \\<le> reason \\<and> reason < length (getF state);\n         isUnitClause (getF state ! reason) literal\n          (elements (getM state)) \\<or>\n         clauseFalse (getF state ! reason) (elements (getM state))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getReason state literal = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) literal (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "hence \"\\<exists> reason. getReason ?state0 literal = Some reason \\<and> 0 \\<le> reason \\<and> reason < length (getF ?state0) \\<and> \n              (isUnitClause (nth (getF ?state0) reason) literal (elements (getM ?state0)) \\<or> \n               clauseFalse (nth (getF ?state0) reason) (elements (getM ?state0)))\""], ["proof (prove)\nusing this:\n  getReason state literal = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  isUnitClause (getF state ! reason) literal (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "proof (cases \"isUnitClause (nth (getF state) reason) literal (elements (getM state))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))\n 2. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     \\<not> isUnitClause (getF state ! reason) literal\n             (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))", "case True"], ["proof (state)\nthis:\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))\n 2. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     \\<not> isUnitClause (getF state ! reason) literal\n             (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "proof (cases \"opposite literal = hd (getQ state)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. opposite literal = hd (getQ state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))\n 2. opposite literal \\<noteq> hd (getQ state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "case True"], ["proof (state)\nthis:\n  opposite literal = hd (getQ state)\n\ngoal (2 subgoals):\n 1. opposite literal = hd (getQ state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))\n 2. opposite literal \\<noteq> hd (getQ state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  opposite literal = hd (getQ state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>isUnitClause (nth (getF state) reason) literal (elements (getM state))\\<close>"], ["proof (prove)\nusing this:\n  opposite literal = hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>getReason state literal = Some reason\\<close>"], ["proof (prove)\nusing this:\n  opposite literal = hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n  getReason state literal = Some reason\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>literal \\<noteq> hd (getQ state)\\<close>"], ["proof (prove)\nusing this:\n  opposite literal = hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n  getReason state literal = Some reason\n  literal \\<noteq> hd (getQ state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>0 \\<le> reason \\<and> reason < length (getF state)\\<close>"], ["proof (prove)\nusing this:\n  opposite literal = hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n  getReason state literal = Some reason\n  literal \\<noteq> hd (getQ state)\n  0 \\<le> reason \\<and> reason < length (getF state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  opposite literal = hd (getQ state)\n  literal el getF state ! reason \\<and>\n  \\<not> literalTrue literal (elements (getM state)) \\<and>\n  \\<not> literalFalse literal (elements (getM state)) \\<and>\n  (\\<forall>literala.\n      literala el getF state ! reason \\<and>\n      literala \\<noteq> literal \\<longrightarrow>\n      literalFalse literala (elements (getM state)))\n  getReason state literal = Some reason\n  literal \\<noteq> hd (getQ state)\n  0 \\<le> reason \\<and> reason < length (getF state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (literal el\n        getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason \\<and>\n        \\<not> literalTrue literal\n                (elements\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>))) \\<and>\n        \\<not> literalFalse literal\n                (elements\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>))) \\<and>\n        (\\<forall>literala.\n            literala el\n            getF\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>) !\n            reason \\<and>\n            literala \\<noteq> literal \\<longrightarrow>\n            literalFalse literala\n             (elements\n               (getM\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "by (auto simp add: clauseFalseIffAllLiteralsAreFalse)"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      literal =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     (isUnitClause\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       literal\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @\n                      [(hd (getQ state), False)]\\<rparr>))) \\<or>\n      clauseFalse\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. opposite literal \\<noteq> hd (getQ state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. opposite literal \\<noteq> hd (getQ state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "case False"], ["proof (state)\nthis:\n  opposite literal \\<noteq> hd (getQ state)\n\ngoal (1 subgoal):\n 1. opposite literal \\<noteq> hd (getQ state) \\<Longrightarrow>\n    \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  opposite literal \\<noteq> hd (getQ state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>isUnitClause (nth (getF state) reason) literal (elements (getM state))\\<close>"], ["proof (prove)\nusing this:\n  opposite literal \\<noteq> hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>getReason state literal = Some reason\\<close>"], ["proof (prove)\nusing this:\n  opposite literal \\<noteq> hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n  getReason state literal = Some reason\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>literal \\<noteq> hd (getQ state)\\<close>"], ["proof (prove)\nusing this:\n  opposite literal \\<noteq> hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n  getReason state literal = Some reason\n  literal \\<noteq> hd (getQ state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>0 \\<le> reason \\<and> reason < length (getF state)\\<close>"], ["proof (prove)\nusing this:\n  opposite literal \\<noteq> hd (getQ state)\n  isUnitClause (getF state ! reason) literal (elements (getM state))\n  getReason state literal = Some reason\n  literal \\<noteq> hd (getQ state)\n  0 \\<le> reason \\<and> reason < length (getF state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "unfolding isUnitClause_def"], ["proof (prove)\nusing this:\n  opposite literal \\<noteq> hd (getQ state)\n  literal el getF state ! reason \\<and>\n  \\<not> literalTrue literal (elements (getM state)) \\<and>\n  \\<not> literalFalse literal (elements (getM state)) \\<and>\n  (\\<forall>literala.\n      literala el getF state ! reason \\<and>\n      literala \\<noteq> literal \\<longrightarrow>\n      literalFalse literala (elements (getM state)))\n  getReason state literal = Some reason\n  literal \\<noteq> hd (getQ state)\n  0 \\<le> reason \\<and> reason < length (getF state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (literal el\n        getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason \\<and>\n        \\<not> literalTrue literal\n                (elements\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>))) \\<and>\n        \\<not> literalFalse literal\n                (elements\n                  (getM\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>))) \\<and>\n        (\\<forall>literala.\n            literala el\n            getF\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>) !\n            reason \\<and>\n            literala \\<noteq> literal \\<longrightarrow>\n            literalFalse literala\n             (elements\n               (getM\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "by auto"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      literal =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     (isUnitClause\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       literal\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @\n                      [(hd (getQ state), False)]\\<rparr>))) \\<or>\n      clauseFalse\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      literal =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     (isUnitClause\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       literal\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @\n                      [(hd (getQ state), False)]\\<rparr>))) \\<or>\n      clauseFalse\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     \\<not> isUnitClause (getF state ! reason) literal\n             (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     \\<not> isUnitClause (getF state ! reason) literal\n             (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))", "case False"], ["proof (state)\nthis:\n  \\<not> isUnitClause (getF state ! reason) literal (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     \\<not> isUnitClause (getF state ! reason) literal\n             (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))", "with *"], ["proof (chain)\npicking this:\n  isUnitClause (getF state ! reason) literal (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n  \\<not> isUnitClause (getF state ! reason) literal (elements (getM state))", "have \"clauseFalse (nth (getF state) reason) (elements (getM state))\""], ["proof (prove)\nusing this:\n  isUnitClause (getF state ! reason) literal (elements (getM state)) \\<or>\n  clauseFalse (getF state ! reason) (elements (getM state))\n  \\<not> isUnitClause (getF state ! reason) literal (elements (getM state))\n\ngoal (1 subgoal):\n 1. clauseFalse (getF state ! reason) (elements (getM state))", "by simp"], ["proof (state)\nthis:\n  clauseFalse (getF state ! reason) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getReason state literal = Some reason;\n     0 \\<le> reason \\<and> reason < length (getF state);\n     isUnitClause (getF state ! reason) literal\n      (elements (getM state)) \\<or>\n     clauseFalse (getF state ! reason) (elements (getM state));\n     \\<not> isUnitClause (getF state ! reason) literal\n             (elements (getM state))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>reason.\n                         getReason\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)\n                          literal =\n                         Some reason \\<and>\n                         0 \\<le> reason \\<and>\n                         reason\n                         < length\n                            (getF\n                              (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                         (isUnitClause\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           literal\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                          clauseFalse\n                           (getF\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>) !\n                            reason)\n                           (elements\n                             (getM\n                               (state\n                                \\<lparr>getM :=\n    getM state @ [(hd (getQ state), False)]\\<rparr>))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  clauseFalse (getF state ! reason) (elements (getM state))\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>getReason state literal = Some reason\\<close>"], ["proof (prove)\nusing this:\n  clauseFalse (getF state ! reason) (elements (getM state))\n  getReason state literal = Some reason\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using \\<open>0 \\<le> reason \\<and> reason < length (getF state)\\<close>"], ["proof (prove)\nusing this:\n  clauseFalse (getF state ! reason) (elements (getM state))\n  getReason state literal = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "using clauseFalseAppendValuation[of \"nth (getF state) reason\" \"elements (getM state)\" \"[hd (getQ state)]\"]"], ["proof (prove)\nusing this:\n  clauseFalse (getF state ! reason) (elements (getM state))\n  getReason state literal = Some reason\n  0 \\<le> reason \\<and> reason < length (getF state)\n  clauseFalse (getF state ! reason)\n   (elements (getM state)) \\<Longrightarrow>\n  clauseFalse (getF state ! reason)\n   (elements (getM state) @ [hd (getQ state)])\n\ngoal (1 subgoal):\n 1. \\<exists>reason.\n       getReason\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n        literal =\n       Some reason \\<and>\n       0 \\<le> reason \\<and>\n       reason\n       < length\n          (getF\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n       (isUnitClause\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         literal\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))) \\<or>\n        clauseFalse\n         (getF\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>) !\n          reason)\n         (elements\n           (getM\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>))))", "by auto"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      literal =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     (isUnitClause\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       literal\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @\n                      [(hd (getQ state), False)]\\<rparr>))) \\<or>\n      clauseFalse\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      literal =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     (isUnitClause\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       literal\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @\n                      [(hd (getQ state), False)]\\<rparr>))) \\<or>\n      clauseFalse\n       (getF\n         (state\n          \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n        reason)\n       (elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < currentLevel\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>));\n   ?literal2 el\n   removeAll\n    (hd (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n    (getQ\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(hd (getQ state), False)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(hd (getQ state), False)]\\<rparr>)\n                        ?literal2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                       (isUnitClause\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         ?literal2\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                        clauseFalse\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "ultimately"], ["proof (chain)\npicking this:\n  ?l2 el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> ?l2 el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel ?l2\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @\n                    [(hd (getQ state), False)]\\<rparr>)) \\<Longrightarrow>\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      ?l2 =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      ?l2\n      (elements\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n  \\<lbrakk>0 < currentLevel\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>));\n   ?literal2 el\n   removeAll\n    (hd (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n    (getQ\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(hd (getQ state), False)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(hd (getQ state), False)]\\<rparr>)\n                        ?literal2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                       (isUnitClause\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         ?literal2\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                        clauseFalse\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?l2 el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> ?l2 el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel ?l2\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @\n                    [(hd (getQ state), False)]\\<rparr>)) \\<Longrightarrow>\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      ?l2 =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      ?l2\n      (elements\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n  \\<lbrakk>0 < currentLevel\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>));\n   ?literal2 el\n   removeAll\n    (hd (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n    (getQ\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(hd (getQ state), False)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(hd (getQ state), False)]\\<rparr>)\n                        ?literal2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                       (isUnitClause\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         ?literal2\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                        clauseFalse\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getF\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (getM\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n     (set (removeAll\n            (hd (getQ\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)))\n            (getQ\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))))", "unfolding InvariantGetReasonIsReason_def"], ["proof (prove)\nusing this:\n  ?l2 el\n  elements\n   (getM\n     (state\n      \\<lparr>getM :=\n                getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  \\<not> ?l2 el\n         decisions\n          (getM\n            (state\n             \\<lparr>getM :=\n                       getM state @\n                       [(hd (getQ state), False)]\\<rparr>)) \\<and>\n  0 < elementLevel ?l2\n       (getM\n         (state\n          \\<lparr>getM :=\n                    getM state @\n                    [(hd (getQ state), False)]\\<rparr>)) \\<Longrightarrow>\n  \\<exists>reason.\n     getReason\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      ?l2 =\n     Some reason \\<and>\n     0 \\<le> reason \\<and>\n     reason\n     < length\n        (getF\n          (state\n           \\<lparr>getM :=\n                     getM state @\n                     [(hd (getQ state), False)]\\<rparr>)) \\<and>\n     isReason\n      (getF\n        (state\n         \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) !\n       reason)\n      ?l2\n      (elements\n        (getM\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n  \\<lbrakk>0 < currentLevel\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>));\n   ?literal2 el\n   removeAll\n    (hd (getQ\n          (state\n           \\<lparr>getM :=\n                     getM state @ [(hd (getQ state), False)]\\<rparr>)))\n    (getQ\n      (state\n       \\<lparr>getM :=\n                 getM state @ [(hd (getQ state), False)]\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>reason.\n                       getReason\n                        (state\n                         \\<lparr>getM :=\n                                   getM state @\n                                   [(hd (getQ state), False)]\\<rparr>)\n                        ?literal2 =\n                       Some reason \\<and>\n                       0 \\<le> reason \\<and>\n                       reason\n                       < length\n                          (getF\n                            (state\n                             \\<lparr>getM :=\n getM state @ [(hd (getQ state), False)]\\<rparr>)) \\<and>\n                       (isUnitClause\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         ?literal2\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<or>\n                        clauseFalse\n                         (getF\n                           (state\n                            \\<lparr>getM :=\ngetM state @ [(hd (getQ state), False)]\\<rparr>) !\n                          reason)\n                         (elements\n                           (getM\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. \\<forall>literal.\n       (literal el\n        elements\n         (getM\n           (state\n            \\<lparr>getM :=\n                      getM state @\n                      [(hd (getQ state), False)]\\<rparr>)) \\<and>\n        \\<not> literal el\n               decisions\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)) \\<and>\n        0 < elementLevel literal\n             (getM\n               (state\n                \\<lparr>getM :=\n                          getM state @\n                          [(hd (getQ state),\n                            False)]\\<rparr>)) \\<longrightarrow>\n        (\\<exists>reason.\n            getReason\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>)\n             literal =\n            Some reason \\<and>\n            0 \\<le> reason \\<and>\n            reason\n            < length\n               (getF\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)) \\<and>\n            isReason\n             (getF\n               (state\n                \\<lparr>getM :=\n                          getM state @ [(hd (getQ state), False)]\\<rparr>) !\n              reason)\n             literal\n             (elements\n               (getM\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>))))) \\<and>\n       (0 < currentLevel\n             (getM\n               (state\n                \\<lparr>getM :=\n                          getM state @\n                          [(hd (getQ state), False)]\\<rparr>)) \\<and>\n        literal\n        \\<in> set (removeAll\n                    (hd (getQ\n                          (state\n                           \\<lparr>getM :=\n                                     getM state @\n                                     [(hd (getQ state), False)]\\<rparr>)))\n                    (getQ\n                      (state\n                       \\<lparr>getM :=\n                                 getM state @\n                                 [(hd (getQ state),\n                                   False)]\\<rparr>))) \\<longrightarrow>\n        (\\<exists>reason.\n            getReason\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>)\n             literal =\n            Some reason \\<and>\n            0 \\<le> reason \\<and>\n            reason\n            < length\n               (getF\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)) \\<and>\n            (isUnitClause\n              (getF\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>) !\n               reason)\n              literal\n              (elements\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>))) \\<or>\n             clauseFalse\n              (getF\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>) !\n               reason)\n              (elements\n                (getM\n                  (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>))))))", "by auto"], ["proof (state)\nthis:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "hence \"InvariantGetReasonIsReason (getReason ?state') (getF ?state') (getM ?state') (set (removeAll (hd (getQ state)) (getQ state)) \\<union> (set (getQ ?state') - set (getQ state)))\""], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason (assertLiteral (hd (getQ state)) False state))\n     (getF (assertLiteral (hd (getQ state)) False state))\n     (getM (assertLiteral (hd (getQ state)) False state))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n       set (getQ state)))", "using assms"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason (assertLiteral (hd (getQ state)) False state))\n     (getF (assertLiteral (hd (getQ state)) False state))\n     (getM (assertLiteral (hd (getQ state)) False state))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n       set (getQ state)))", "unfolding assertLiteral_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (Let (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>)\n         (notifyWatches (opposite (hd (getQ state))))))\n     (getF\n       (Let (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>)\n         (notifyWatches (opposite (hd (getQ state))))))\n     (getM\n       (Let (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>)\n         (notifyWatches (opposite (hd (getQ state))))))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ\n             (Let (state\n                   \\<lparr>getM :=\n                             getM state @\n                             [(hd (getQ state), False)]\\<rparr>)\n               (notifyWatches (opposite (hd (getQ state)))))) -\n       set (getQ state)))", "unfolding notifyWatches_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getF\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getM\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ\n             (let state' = state\n                    \\<lparr>getM :=\n                              getM state @\n                              [(hd (getQ state), False)]\\<rparr>\n              in notifyWatches_loop (opposite (hd (getQ state)))\n                  (getWatchList state' (opposite (hd (getQ state)))) []\n                  state')) -\n       set (getQ state)))", "using InvariantGetReasonIsReasonAfterNotifyWatches[of  \n      \"?state0\" \"getWatchList ?state0 (opposite (hd (getQ state)))\"  \"opposite (hd (getQ state))\" \"getM state\" \"False\"\n      \"set (removeAll (hd (getQ ?state0)) (getQ ?state0))\" \"[]\"]"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      Some (opposite (hd (getQ state))) =\n      getWatch1\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c \\<or>\n      Some (opposite (hd (getQ state))) =\n      getWatch2\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      (opposite (hd (getQ state))));\n   getM\n    (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) =\n   getM state @ [(opposite (opposite (hd (getQ state))), False)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (set (removeAll\n           (hd (getQ\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)))\n           (getQ\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop (opposite (hd (getQ state)))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>)\n                             (opposite (hd (getQ state))))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)\n                    in Let (set (removeAll\n                                  (hd (getQ\n  (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)))\n                                  (getQ\n                                    (state\n                                     \\<lparr>getM :=\n         getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(hd (getQ state), False)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getF\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getM\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ\n             (let state' = state\n                    \\<lparr>getM :=\n                              getM state @\n                              [(hd (getQ state), False)]\\<rparr>\n              in notifyWatches_loop (opposite (hd (getQ state)))\n                  (getWatchList state' (opposite (hd (getQ state)))) []\n                  state')) -\n       set (getQ state)))", "unfolding InvariantWatchListsContainOnlyClausesFromF_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      Some (opposite (hd (getQ state))) =\n      getWatch1\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c \\<or>\n      Some (opposite (hd (getQ state))) =\n      getWatch2\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      (opposite (hd (getQ state))));\n   getM\n    (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) =\n   getM state @ [(opposite (opposite (hd (getQ state))), False)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (set (removeAll\n           (hd (getQ\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)))\n           (getQ\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop (opposite (hd (getQ state)))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>)\n                             (opposite (hd (getQ state))))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)\n                    in Let (set (removeAll\n                                  (hd (getQ\n  (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)))\n                                  (getQ\n                                    (state\n                                     \\<lparr>getM :=\n         getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(hd (getQ state), False)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getF\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getM\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ\n             (let state' = state\n                    \\<lparr>getM :=\n                              getM state @\n                              [(hd (getQ state), False)]\\<rparr>\n              in notifyWatches_loop (opposite (hd (getQ state)))\n                  (getWatchList state' (opposite (hd (getQ state)))) []\n                  state')) -\n       set (getQ state)))", "unfolding InvariantWatchListsCharacterization_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      Some (opposite (hd (getQ state))) =\n      getWatch1\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c \\<or>\n      Some (opposite (hd (getQ state))) =\n      getWatch2\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      (opposite (hd (getQ state))));\n   getM\n    (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) =\n   getM state @ [(opposite (opposite (hd (getQ state))), False)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (set (removeAll\n           (hd (getQ\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)))\n           (getQ\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop (opposite (hd (getQ state)))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>)\n                             (opposite (hd (getQ state))))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)\n                    in Let (set (removeAll\n                                  (hd (getQ\n  (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)))\n                                  (getQ\n                                    (state\n                                     \\<lparr>getM :=\n         getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(hd (getQ state), False)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getF\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getM\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ\n             (let state' = state\n                    \\<lparr>getM :=\n                              getM state @\n                              [(hd (getQ state), False)]\\<rparr>\n              in notifyWatches_loop (opposite (hd (getQ state)))\n                  (getWatchList state' (opposite (hd (getQ state)))) []\n                  state')) -\n       set (getQ state)))", "unfolding InvariantWatchListsUniq_def"], ["proof (prove)\nusing this:\n  InvariantGetReasonIsReason\n   (getReason\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getF\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (getM\n     (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n   (set (removeAll\n          (hd (getQ\n                (state\n                 \\<lparr>getM :=\n                           getM state @\n                           [(hd (getQ state), False)]\\<rparr>)))\n          (getQ\n            (state\n             \\<lparr>getM :=\n                       getM state @ [(hd (getQ state), False)]\\<rparr>))))\n  \\<forall>l c.\n     c \\<in> set (getWatchList state l) \\<longrightarrow>\n     0 \\<le> c \\<and> c < length (getF state)\n  \\<forall>l. uniq (getWatchList state l)\n  \\<forall>c l.\n     (c \\<in> set (getWatchList state l)) =\n     (Some l = getWatch1 state c \\<or> Some l = getWatch2 state c)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchesEl\n            (getF\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch1\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>))\n            (getWatch2\n              (state\n               \\<lparr>getM :=\n                         getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      0 \\<le> c \\<and>\n      c < length\n           (getF\n             (state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>));\n   \\<forall>c.\n      c \\<in> set (getWatchList\n                    (state\n                     \\<lparr>getM :=\n                               getM state @\n                               [(hd (getQ state), False)]\\<rparr>)\n                    (opposite (hd (getQ state)))) \\<longrightarrow>\n      Some (opposite (hd (getQ state))) =\n      getWatch1\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c \\<or>\n      Some (opposite (hd (getQ state))) =\n      getWatch2\n       (state\n        \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n       c;\n   uniq\n    (getWatchList\n      (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)\n      (opposite (hd (getQ state))));\n   getM\n    (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>) =\n   getM state @ [(opposite (opposite (hd (getQ state))), False)];\n   InvariantGetReasonIsReason\n    (getReason\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getF\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (getM\n      (state\n       \\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>))\n    (set (removeAll\n           (hd (getQ\n                 (state\n                  \\<lparr>getM :=\n                            getM state @\n                            [(hd (getQ state), False)]\\<rparr>)))\n           (getQ\n             (state\n              \\<lparr>getM :=\n                        getM state @\n                        [(hd (getQ state), False)]\\<rparr>))))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          notifyWatches_loop (opposite (hd (getQ state)))\n                           (getWatchList\n                             (state\n                              \\<lparr>getM :=\n  getM state @ [(hd (getQ state), False)]\\<rparr>)\n                             (opposite (hd (getQ state))))\n                           [] (state\n                               \\<lparr>getM :=\n   getM state @ [(hd (getQ state), False)]\\<rparr>)\n                    in Let (set (removeAll\n                                  (hd (getQ\n  (state\\<lparr>getM := getM state @ [(hd (getQ state), False)]\\<rparr>)))\n                                  (getQ\n                                    (state\n                                     \\<lparr>getM :=\n         getM state @ [(hd (getQ state), False)]\\<rparr>))) \\<union>\n                            (set (getQ state') -\n                             set (getQ\n                                   (state\n                                    \\<lparr>getM :=\n        getM state @ [(hd (getQ state), False)]\\<rparr>))))\n                        (InvariantGetReasonIsReason (getReason state')\n                          (getF state') (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason\n     (getReason\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getF\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (getM\n       (let state' = state\n              \\<lparr>getM :=\n                        getM state @ [(hd (getQ state), False)]\\<rparr>\n        in notifyWatches_loop (opposite (hd (getQ state)))\n            (getWatchList state' (opposite (hd (getQ state)))) [] state'))\n     (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n      (set (getQ\n             (let state' = state\n                    \\<lparr>getM :=\n                              getM state @\n                              [(hd (getQ state), False)]\\<rparr>\n              in notifyWatches_loop (opposite (hd (getQ state)))\n                  (getWatchList state' (opposite (hd (getQ state)))) []\n                  state')) -\n       set (getQ state)))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantGetReasonIsReason\n   (getReason (assertLiteral (hd (getQ state)) False state))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n   (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "obtain s \n    where \"getQ state @ s = getQ ?state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assertLiteralEffect[of \"state\" \"hd (getQ state)\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s.\n                       getQ state @ s =\n                       getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        getQ state @ s =\n        getQ (assertLiteral (hd (getQ state)) False state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  getQ state @ s = getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "hence \"getQ ?state' = getQ state @ s\""], ["proof (prove)\nusing this:\n  getQ state @ s = getQ (assertLiteral (hd (getQ state)) False state)\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s", "by simp"], ["proof (state)\nthis:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "hence \"hd (getQ ?state') = hd (getQ state)\""], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n\ngoal (1 subgoal):\n 1. hd (getQ (assertLiteral (hd (getQ state)) False state)) =\n    hd (getQ state)", "using hd_append2[of \"getQ state\" \"s\"]"], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n  getQ state \\<noteq> [] \\<Longrightarrow>\n  hd (getQ state @ s) = hd (getQ state)\n\ngoal (1 subgoal):\n 1. hd (getQ (assertLiteral (hd (getQ state)) False state)) =\n    hd (getQ state)", "using \\<open>getQ state \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n  getQ state \\<noteq> [] \\<Longrightarrow>\n  hd (getQ state @ s) = hd (getQ state)\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (getQ (assertLiteral (hd (getQ state)) False state)) =\n    hd (getQ state)", "by simp"], ["proof (state)\nthis:\n  hd (getQ (assertLiteral (hd (getQ state)) False state)) = hd (getQ state)\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \" set (removeAll (hd (getQ state)) (getQ state)) \\<union> (set (getQ ?state') - set (getQ state)) = \n         set (removeAll (hd (getQ state)) (getQ ?state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using \\<open>getQ ?state' = getQ state @ s\\<close>"], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n\ngoal (1 subgoal):\n 1. set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using \\<open>getQ state \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  getQ (assertLiteral (hd (getQ state)) False state) = getQ state @ s\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "by auto"], ["proof (state)\nthis:\n  set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n  (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n   set (getQ state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"uniq (getQ ?state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uniq (getQ (assertLiteral (hd (getQ state)) False state))", "using assms"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n\ngoal (1 subgoal):\n 1. uniq (getQ (assertLiteral (hd (getQ state)) False state))", "using InvariantUniqQAfterAssertLiteral[of \"state\" \"hd (getQ state)\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantUniqQ (getQ state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. uniq (getQ (assertLiteral (hd (getQ state)) False state))", "unfolding InvariantUniqQ_def"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  uniq (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   uniq (getQ state)\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in uniq (getQ state')\n\ngoal (1 subgoal):\n 1. uniq (getQ (assertLiteral (hd (getQ state)) False state))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"set (getQ ?state'') = set (removeAll (hd (getQ state)) (getQ ?state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using \\<open>uniq (getQ ?state')\\<close>"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using \\<open>hd (getQ ?state') = hd (getQ state)\\<close>"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  hd (getQ (assertLiteral (hd (getQ state)) False state)) = hd (getQ state)\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "using uniqHeadTailSet[of \"getQ ?state'\"]"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  hd (getQ (assertLiteral (hd (getQ state)) False state)) = hd (getQ state)\n  uniq\n   (getQ (assertLiteral (hd (getQ state)) False state)) \\<Longrightarrow>\n  set (tl (getQ (assertLiteral (hd (getQ state)) False state))) =\n  set (getQ (assertLiteral (hd (getQ state)) False state)) -\n  {hd (getQ (assertLiteral (hd (getQ state)) False state))}\n\ngoal (1 subgoal):\n 1. set (getQ (applyUnitPropagate state)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  uniq (getQ (assertLiteral (hd (getQ state)) False state))\n  hd (getQ (assertLiteral (hd (getQ state)) False state)) = hd (getQ state)\n  uniq\n   (getQ (assertLiteral (hd (getQ state)) False state)) \\<Longrightarrow>\n  set (tl (getQ (assertLiteral (hd (getQ state)) False state))) =\n  set (getQ (assertLiteral (hd (getQ state)) False state)) -\n  {hd (getQ (assertLiteral (hd (getQ state)) False state))}\n\ngoal (1 subgoal):\n 1. set (getQ\n          (let state' = assertLiteral (hd (getQ state)) False state\n           in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) =\n    set (removeAll (hd (getQ state))\n          (getQ (assertLiteral (hd (getQ state)) False state)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using \\<open>InvariantGetReasonIsReason (getReason ?state') (getF ?state') (getM ?state') (set (removeAll (hd (getQ state)) (getQ state)) \\<union> (set (getQ ?state') - set (getQ state)))\\<close>"], ["proof (prove)\nusing this:\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n  InvariantGetReasonIsReason\n   (getReason (assertLiteral (hd (getQ state)) False state))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n   (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using \\<open>set (getQ ?state'') = set (removeAll (hd (getQ state)) (getQ ?state'))\\<close>"], ["proof (prove)\nusing this:\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n  InvariantGetReasonIsReason\n   (getReason (assertLiteral (hd (getQ state)) False state))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n   (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)))\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using \\<open>set (removeAll (hd (getQ state)) (getQ state)) \\<union> (set (getQ ?state') - set (getQ state)) = \n         set (removeAll (hd (getQ state)) (getQ ?state'))\\<close>"], ["proof (prove)\nusing this:\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n  InvariantGetReasonIsReason\n   (getReason (assertLiteral (hd (getQ state)) False state))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n   (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)))\n  set (getQ (applyUnitPropagate state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n  set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n  (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n   set (getQ state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  set (getQ\n        (let state' = assertLiteral (hd (getQ state)) False state\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n  InvariantGetReasonIsReason\n   (getReason (assertLiteral (hd (getQ state)) False state))\n   (getF (assertLiteral (hd (getQ state)) False state))\n   (getM (assertLiteral (hd (getQ state)) False state))\n   (set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n    (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n     set (getQ state)))\n  set (getQ\n        (let state' = assertLiteral (hd (getQ state)) False state\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n  set (removeAll (hd (getQ state)) (getQ state)) \\<union>\n  (set (getQ (assertLiteral (hd (getQ state)) False state)) -\n   set (getQ state)) =\n  set (removeAll (hd (getQ state))\n        (getQ (assertLiteral (hd (getQ state)) False state)))\n\ngoal (1 subgoal):\n 1. let state' =\n          let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state\n  in InvariantGetReasonIsReason (getReason state') (getF state')\n      (getM state') (set (getQ state'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantEquivalentZLAfterApplyUnitPropagate:\nassumes \n  \"InvariantEquivalentZL (getF state) (getM state) Phi\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n\n  \"\\<not> (getConflictFlag state)\"\n  \"getQ state \\<noteq> []\"\nshows\n  \"let state' = applyUnitPropagate state in\n      InvariantEquivalentZL (getF state') (getM state') Phi\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "let ?uLiteral = \"hd (getQ state)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "let ?state' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "let ?FM = \"getF state @ val2form (elements (prefixToLevel 0 (getM state)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "let ?FM' = \"getF ?state' @ val2form (elements (prefixToLevel 0 (getM ?state')))\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "obtain uClause \n    where \"formulaEntailsClause (getF state) uClause\" and \n    \"isUnitClause uClause ?uLiteral (elements (getM state))\" and\n    \"(getM ?state') = (getM state) @ [(?uLiteral, False)]\"\n    \"(getF ?state') = (getF state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>formulaEntailsClause (getF state) uClause;\n         isUnitClause uClause (hd (getQ state)) (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)];\n         getF (applyUnitPropagate state) = getF state\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>formulaEntailsClause (getF state) uClause;\n         isUnitClause uClause (hd (getQ state)) (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)];\n         getF (applyUnitPropagate state) = getF state\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using applyUnitPropagateEffect[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchesEl (getF state) (getWatch1 state)\n            (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<not> getConflictFlag state; getQ state \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let uLiteral = hd (getQ state);\n                        state' = applyUnitPropagate state\n                    in \\<exists>uClause.\n                          formulaEntailsClause (getF state) uClause \\<and>\n                          isUnitClause uClause uLiteral\n                           (elements (getM state)) \\<and>\n                          getM state' = getM state @ [(uLiteral, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>formulaEntailsClause (getF state) uClause;\n         isUnitClause uClause (hd (getQ state)) (elements (getM state));\n         getM (applyUnitPropagate state) =\n         getM state @ [(hd (getQ state), False)];\n         getF (applyUnitPropagate state) = getF state\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchesEl (getF state) (getWatch1 state)\n            (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<not> getConflictFlag state; getQ state \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let uLiteral = hd (getQ state);\n                        state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in \\<exists>uClause.\n                          formulaEntailsClause (getF state) uClause \\<and>\n                          isUnitClause uClause uLiteral\n                           (elements (getM state)) \\<and>\n                          getM state' = getM state @ [(uLiteral, False)]\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>formulaEntailsClause (getF state) uClause;\n         isUnitClause uClause (hd (getQ state)) (elements (getM state));\n         getM\n          (let state' = assertLiteral (hd (getQ state)) False state\n           in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n         getM state @ [(hd (getQ state), False)];\n         getF\n          (let state' = assertLiteral (hd (getQ state)) False state\n           in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n         getF state\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assertLiteralEffect"], ["proof (prove)\nusing this:\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  \\<not> getConflictFlag state\n  getQ state \\<noteq> []\n  \\<lbrakk>InvariantWatchesEl (getF state) (getWatch1 state)\n            (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   \\<not> getConflictFlag state; getQ state \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let uLiteral = hd (getQ state);\n                        state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in \\<exists>uClause.\n                          formulaEntailsClause (getF state) uClause \\<and>\n                          isUnitClause uClause uLiteral\n                           (elements (getM state)) \\<and>\n                          getM state' = getM state @ [(uLiteral, False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral ?l ?d ?state) =\n                    getM ?state @ [(?l, ?d)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral ?l ?d ?state) = getF ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag (assertLiteral ?l ?d ?state) =\n                    getSATFlag ?state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state)\n            (getF ?state);\n   InvariantWatchesEl (getF ?state) (getWatch1 ?state)\n    (getWatch2 ?state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ ?state)\n                     (getQ (assertLiteral ?l ?d ?state))\n\ngoal (1 subgoal):\n 1. (\\<And>uClause.\n        \\<lbrakk>formulaEntailsClause (getF state) uClause;\n         isUnitClause uClause (hd (getQ state)) (elements (getM state));\n         getM\n          (let state' = assertLiteral (hd (getQ state)) False state\n           in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n         getM state @ [(hd (getQ state), False)];\n         getF\n          (let state' = assertLiteral (hd (getQ state)) False state\n           in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n         getF state\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "note * = this"], ["proof (state)\nthis:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "proof (cases \"currentLevel (getM state) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. currentLevel (getM state) = 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "case True"], ["proof (state)\nthis:\n  currentLevel (getM state) = 0\n\ngoal (2 subgoals):\n 1. currentLevel (getM state) = 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "hence \"getM state = prefixToLevel 0 (getM state)\""], ["proof (prove)\nusing this:\n  currentLevel (getM state) = 0\n\ngoal (1 subgoal):\n 1. getM state = prefixToLevel 0 (getM state)", "by (rule currentLevelZeroTrailEqualsItsPrefixToLevelZero)"], ["proof (state)\nthis:\n  getM state = prefixToLevel 0 (getM state)\n\ngoal (2 subgoals):\n 1. currentLevel (getM state) = 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"?FM' = ?FM @ [[?uLiteral]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getF (applyUnitPropagate state) @\n    val2form\n     (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n    (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n    [[hd (getQ state)]]", "using *"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n\ngoal (1 subgoal):\n 1. getF (applyUnitPropagate state) @\n    val2form\n     (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n    (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n    [[hd (getQ state)]]", "using \\<open>(getM ?state') = (getM state) @ [(?uLiteral, False)]\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n\ngoal (1 subgoal):\n 1. getF (applyUnitPropagate state) @\n    val2form\n     (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n    (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n    [[hd (getQ state)]]", "using prefixToLevelAppend[of \"0\" \"getM state\" \"[(?uLiteral, False)]\"]"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  prefixToLevel 0 (getM state @ [(hd (getQ state), False)]) =\n  (if 0 < currentLevel (getM state) then prefixToLevel 0 (getM state)\n   else getM state @\n        prefixToLevel_aux [(hd (getQ state), False)] 0\n         (currentLevel (getM state)))\n\ngoal (1 subgoal):\n 1. getF (applyUnitPropagate state) @\n    val2form\n     (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n    (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n    [[hd (getQ state)]]", "using \\<open>currentLevel (getM state) = 0\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  prefixToLevel 0 (getM state @ [(hd (getQ state), False)]) =\n  (if 0 < currentLevel (getM state) then prefixToLevel 0 (getM state)\n   else getM state @\n        prefixToLevel_aux [(hd (getQ state), False)] 0\n         (currentLevel (getM state)))\n  currentLevel (getM state) = 0\n\ngoal (1 subgoal):\n 1. getF (applyUnitPropagate state) @\n    val2form\n     (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n    (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n    [[hd (getQ state)]]", "using \\<open>getM state = prefixToLevel 0 (getM state)\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  prefixToLevel 0 (getM state @ [(hd (getQ state), False)]) =\n  (if 0 < currentLevel (getM state) then prefixToLevel 0 (getM state)\n   else getM state @\n        prefixToLevel_aux [(hd (getQ state), False)] 0\n         (currentLevel (getM state)))\n  currentLevel (getM state) = 0\n  getM state = prefixToLevel 0 (getM state)\n\ngoal (1 subgoal):\n 1. getF (applyUnitPropagate state) @\n    val2form\n     (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n    (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n    [[hd (getQ state)]]", "by (auto simp add: val2formAppend)"], ["proof (state)\nthis:\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n  (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n  [[hd (getQ state)]]\n\ngoal (2 subgoals):\n 1. currentLevel (getM state) = 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"formulaEntailsLiteral ?FM ?uLiteral\""], ["proof (prove)\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     (hd (getQ state))", "using *"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     (hd (getQ state))", "using unitLiteralIsEntailed [of \"uClause\" \"?uLiteral\" \"elements (getM state)\" \"(getF state)\"]"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  \\<lbrakk>isUnitClause uClause (hd (getQ state)) (elements (getM state));\n   formulaEntailsClause (getF state) uClause\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral\n                     (getF state @ val2form (elements (getM state)))\n                     (hd (getQ state))\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     (hd (getQ state))", "using \\<open>InvariantEquivalentZL (getF state) (getM state) Phi\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  \\<lbrakk>isUnitClause uClause (hd (getQ state)) (elements (getM state));\n   formulaEntailsClause (getF state) uClause\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral\n                     (getF state @ val2form (elements (getM state)))\n                     (hd (getQ state))\n  InvariantEquivalentZL (getF state) (getM state) Phi\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     (hd (getQ state))", "using \\<open>getM state = prefixToLevel 0 (getM state)\\<close>"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  \\<lbrakk>isUnitClause uClause (hd (getQ state)) (elements (getM state));\n   formulaEntailsClause (getF state) uClause\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral\n                     (getF state @ val2form (elements (getM state)))\n                     (hd (getQ state))\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  getM state = prefixToLevel 0 (getM state)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     (hd (getQ state))", "unfolding InvariantEquivalentZL_def"], ["proof (prove)\nusing this:\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  \\<lbrakk>isUnitClause uClause (hd (getQ state)) (elements (getM state));\n   formulaEntailsClause (getF state) uClause\\<rbrakk>\n  \\<Longrightarrow> formulaEntailsLiteral\n                     (getF state @ val2form (elements (getM state)))\n                     (hd (getQ state))\n  equivalentFormulae\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) Phi\n  getM state = prefixToLevel 0 (getM state)\n\ngoal (1 subgoal):\n 1. formulaEntailsLiteral\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     (hd (getQ state))", "by simp"], ["proof (state)\nthis:\n  formulaEntailsLiteral\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n   (hd (getQ state))\n\ngoal (2 subgoals):\n 1. currentLevel (getM state) = 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "hence \"formulaEntailsClause ?FM [?uLiteral]\""], ["proof (prove)\nusing this:\n  formulaEntailsLiteral\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n   (hd (getQ state))\n\ngoal (1 subgoal):\n 1. formulaEntailsClause\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     [hd (getQ state)]", "unfolding formulaEntailsLiteral_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation.\n     model valuation\n      (getF state @\n       val2form (elements (prefixToLevel 0 (getM state)))) \\<longrightarrow>\n     literalTrue (hd (getQ state)) valuation\n\ngoal (1 subgoal):\n 1. formulaEntailsClause\n     (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n     [hd (getQ state)]", "unfolding formulaEntailsClause_def"], ["proof (prove)\nusing this:\n  \\<forall>valuation.\n     model valuation\n      (getF state @\n       val2form (elements (prefixToLevel 0 (getM state)))) \\<longrightarrow>\n     literalTrue (hd (getQ state)) valuation\n\ngoal (1 subgoal):\n 1. \\<forall>valuation.\n       model valuation\n        (getF state @\n         val2form\n          (elements (prefixToLevel 0 (getM state)))) \\<longrightarrow>\n       model valuation [hd (getQ state)]", "by (auto simp add: clauseTrueIffContainsTrueLiteral)"], ["proof (state)\nthis:\n  formulaEntailsClause\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n   [hd (getQ state)]\n\ngoal (2 subgoals):\n 1. currentLevel (getM state) = 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using \\<open>InvariantEquivalentZL (getF state) (getM state) Phi\\<close>"], ["proof (prove)\nusing this:\n  InvariantEquivalentZL (getF state) (getM state) Phi\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using \\<open>?FM' = ?FM @ [[?uLiteral]]\\<close>"], ["proof (prove)\nusing this:\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n  (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n  [[hd (getQ state)]]\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using \\<open>formulaEntailsClause ?FM [?uLiteral]\\<close>"], ["proof (prove)\nusing this:\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n  (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n  [[hd (getQ state)]]\n  formulaEntailsClause\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n   [hd (getQ state)]\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "unfolding InvariantEquivalentZL_def"], ["proof (prove)\nusing this:\n  equivalentFormulae\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) Phi\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n  (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n  [[hd (getQ state)]]\n  formulaEntailsClause\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n   [hd (getQ state)]\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in equivalentFormulae\n        (getF state' @ val2form (elements (prefixToLevel 0 (getM state'))))\n        Phi", "using extendEquivalentFormulaWithEntailedClause[of \"Phi\" \"?FM\" \"[?uLiteral]\"]"], ["proof (prove)\nusing this:\n  equivalentFormulae\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) Phi\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state)))) =\n  (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) @\n  [[hd (getQ state)]]\n  formulaEntailsClause\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n   [hd (getQ state)]\n  \\<lbrakk>equivalentFormulae Phi\n            (getF state @\n             val2form (elements (prefixToLevel 0 (getM state))));\n   formulaEntailsClause\n    (getF state @ val2form (elements (prefixToLevel 0 (getM state))))\n    [hd (getQ state)]\\<rbrakk>\n  \\<Longrightarrow> equivalentFormulae Phi\n                     ((getF state @\n                       val2form (elements (prefixToLevel 0 (getM state)))) @\n                      [[hd (getQ state)]])\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in equivalentFormulae\n        (getF state' @ val2form (elements (prefixToLevel 0 (getM state'))))\n        Phi", "by (simp add: equivalentFormulaeSymmetry)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state\n  in InvariantEquivalentZL (getF state') (getM state') Phi\n\ngoal (1 subgoal):\n 1. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "case False"], ["proof (state)\nthis:\n  currentLevel (getM state) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "hence \"?FM = ?FM'\""], ["proof (prove)\nusing this:\n  currentLevel (getM state) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. getF state @ val2form (elements (prefixToLevel 0 (getM state))) =\n    getF (applyUnitPropagate state) @\n    val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state))))", "using *"], ["proof (prove)\nusing this:\n  currentLevel (getM state) \\<noteq> 0\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n\ngoal (1 subgoal):\n 1. getF state @ val2form (elements (prefixToLevel 0 (getM state))) =\n    getF (applyUnitPropagate state) @\n    val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state))))", "using prefixToLevelAppend[of \"0\" \"getM state\" \"[(?uLiteral, False)]\"]"], ["proof (prove)\nusing this:\n  currentLevel (getM state) \\<noteq> 0\n  formulaEntailsClause (getF state) uClause\n  isUnitClause uClause (hd (getQ state)) (elements (getM state))\n  getM (applyUnitPropagate state) = getM state @ [(hd (getQ state), False)]\n  getF (applyUnitPropagate state) = getF state\n  prefixToLevel 0 (getM state @ [(hd (getQ state), False)]) =\n  (if 0 < currentLevel (getM state) then prefixToLevel 0 (getM state)\n   else getM state @\n        prefixToLevel_aux [(hd (getQ state), False)] 0\n         (currentLevel (getM state)))\n\ngoal (1 subgoal):\n 1. getF state @ val2form (elements (prefixToLevel 0 (getM state))) =\n    getF (applyUnitPropagate state) @\n    val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state))))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  getF state @ val2form (elements (prefixToLevel 0 (getM state))) =\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state))))\n\ngoal (1 subgoal):\n 1. currentLevel (getM state) \\<noteq> 0 \\<Longrightarrow>\n    let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "thus ?thesis"], ["proof (prove)\nusing this:\n  getF state @ val2form (elements (prefixToLevel 0 (getM state))) =\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state))))\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using \\<open>InvariantEquivalentZL (getF state) (getM state) Phi\\<close>"], ["proof (prove)\nusing this:\n  getF state @ val2form (elements (prefixToLevel 0 (getM state))) =\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state))))\n  InvariantEquivalentZL (getF state) (getM state) Phi\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "unfolding InvariantEquivalentZL_def"], ["proof (prove)\nusing this:\n  getF state @ val2form (elements (prefixToLevel 0 (getM state))) =\n  getF (applyUnitPropagate state) @\n  val2form (elements (prefixToLevel 0 (getM (applyUnitPropagate state))))\n  equivalentFormulae\n   (getF state @ val2form (elements (prefixToLevel 0 (getM state)))) Phi\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in equivalentFormulae\n        (getF state' @ val2form (elements (prefixToLevel 0 (getM state'))))\n        Phi", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state\n  in InvariantEquivalentZL (getF state') (getM state') Phi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state\n  in InvariantEquivalentZL (getF state') (getM state') Phi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantVarsQTl:\nassumes\n  \"InvariantVarsQ Q F0 Vbl\"\n  \"Q \\<noteq> []\"\nshows\n  \"InvariantVarsQ (tl Q) F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsQ (tl Q) F0 Vbl", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. InvariantVarsQ (tl Q) F0 Vbl", "have \"InvariantVarsQ ((hd Q) # (tl Q)) F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsQ (hd Q # tl Q) F0 Vbl", "using assms"], ["proof (prove)\nusing this:\n  InvariantVarsQ Q F0 Vbl\n  Q \\<noteq> []\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (hd Q # tl Q) F0 Vbl", "by simp"], ["proof (state)\nthis:\n  InvariantVarsQ (hd Q # tl Q) F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (tl Q) F0 Vbl", "hence \"{var (hd Q)} \\<union> vars (tl Q) \\<subseteq> vars F0 \\<union> Vbl\""], ["proof (prove)\nusing this:\n  InvariantVarsQ (hd Q # tl Q) F0 Vbl\n\ngoal (1 subgoal):\n 1. {var (hd Q)} \\<union> vars (tl Q) \\<subseteq> vars F0 \\<union> Vbl", "unfolding InvariantVarsQ_def"], ["proof (prove)\nusing this:\n  vars (hd Q # tl Q) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. {var (hd Q)} \\<union> vars (tl Q) \\<subseteq> vars F0 \\<union> Vbl", "by simp"], ["proof (state)\nthis:\n  {var (hd Q)} \\<union> vars (tl Q) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (tl Q) F0 Vbl", "thus ?thesis"], ["proof (prove)\nusing this:\n  {var (hd Q)} \\<union> vars (tl Q) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (tl Q) F0 Vbl", "unfolding InvariantVarsQ_def"], ["proof (prove)\nusing this:\n  {var (hd Q)} \\<union> vars (tl Q) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. vars (tl Q) \\<subseteq> vars F0 \\<union> Vbl", "by simp"], ["proof (state)\nthis:\n  InvariantVarsQ (tl Q) F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantsVarsAfterApplyUnitPropagate:\nassumes\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and \n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\" and\n  \"InvariantQCharacterization False (getQ state) (getF state) (getM state)\" and\n  \"getQ state \\<noteq> []\"\n  \"\\<not> getConflictFlag state\"\n  \"InvariantVarsM (getM state) F0 Vbl\" and\n  \"InvariantVarsQ (getQ state) F0 Vbl\" and\n  \"InvariantVarsF (getF state) F0 Vbl\"\nshows\n  \"let state' = applyUnitPropagate state in\n     InvariantVarsM (getM state') F0 Vbl \\<and> \n     InvariantVarsQ (getQ state') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "let ?state' = \"assertLiteral (hd (getQ state)) False state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "let ?state'' = \"applyUnitPropagate state\""], ["proof (state)\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "have \"InvariantVarsQ (getQ ?state') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0\n     Vbl", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0\n     Vbl", "using InvariantConsistentAfterApplyUnitPropagate[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0\n     Vbl", "using InvariantUniqAfterApplyUnitPropagate[of \"state\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0\n     Vbl", "using InvariantVarsQAfterAssertLiteral[of \"state\" \"hd (getQ state)\" \"False\" \"F0\" \"Vbl\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantUniq (getM state')\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantUniq (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0\n     Vbl", "using assertLiteralEffect[of \"state\" \"hd (getQ state)\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state\n                    in InvariantUniq (getM state')\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantUniq (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0\n     Vbl", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in InvariantConsistent (getM state')\n  \\<lbrakk>InvariantUniq (getM state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantQCharacterization (getConflictFlag state) (getQ state)\n    (getF state) (getM state);\n   getQ state \\<noteq> []; \\<not> getConflictFlag state\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          let state' =\n                                assertLiteral (hd (getQ state)) False state\n                          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>\n                    in InvariantUniq (getM state')\n  \\<lbrakk>InvariantConsistent (getM state @ [(hd (getQ state), False)]);\n   InvariantUniq (getM state @ [(hd (getQ state), False)]);\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n    (getF state);\n   InvariantWatchListsUniq (getWatchList state);\n   InvariantWatchListsCharacterization (getWatchList state)\n    (getWatch1 state) (getWatch2 state);\n   InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state);\n   InvariantWatchCharacterization (getF state) (getWatch1 state)\n    (getWatch2 state) (getM state);\n   InvariantVarsQ (getQ state) F0 Vbl;\n   InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' = assertLiteral (hd (getQ state)) False state\n                    in InvariantVarsQ (getQ state') F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0\n     Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "have \"(getQ ?state') \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "using assertLiteralEffect[of \"state\" \"hd (getQ state)\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "using \\<open>getQ state \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "unfolding isPrefix_def"], ["proof (prove)\nusing this:\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s.\n                       getQ state @ s =\n                       getQ (assertLiteral (hd (getQ state)) False state)\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0 Vbl\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []", "have \"InvariantVarsQ (getQ ?state'') F0 Vbl\""], ["proof (prove)\nusing this:\n  InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0 Vbl\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n\ngoal (1 subgoal):\n 1. InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0 Vbl\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n\ngoal (1 subgoal):\n 1. InvariantVarsQ\n     (getQ\n       (let state' = assertLiteral (hd (getQ state)) False state\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "using InvariantVarsQTl[of \"getQ ?state'\" F0 Vbl]"], ["proof (prove)\nusing this:\n  InvariantVarsQ (getQ (assertLiteral (hd (getQ state)) False state)) F0 Vbl\n  getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\n  \\<lbrakk>InvariantVarsQ\n            (getQ (assertLiteral (hd (getQ state)) False state)) F0 Vbl;\n   getQ (assertLiteral (hd (getQ state)) False state) \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> InvariantVarsQ\n                     (tl (getQ\n                           (assertLiteral (hd (getQ state)) False state)))\n                     F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsQ\n     (getQ\n       (let state' = assertLiteral (hd (getQ state)) False state\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "have \"var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl", "using \\<open>getQ state \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  getQ state \\<noteq> []\n\ngoal (1 subgoal):\n 1. var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl", "using \\<open>InvariantVarsQ (getQ state) F0 Vbl\\<close>"], ["proof (prove)\nusing this:\n  getQ state \\<noteq> []\n  InvariantVarsQ (getQ state) F0 Vbl\n\ngoal (1 subgoal):\n 1. var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl", "using hd_in_set[of \"getQ state\"]"], ["proof (prove)\nusing this:\n  getQ state \\<noteq> []\n  InvariantVarsQ (getQ state) F0 Vbl\n  getQ state \\<noteq> [] \\<Longrightarrow>\n  hd (getQ state) \\<in> set (getQ state)\n\ngoal (1 subgoal):\n 1. var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl", "using clauseContainsItsLiteralsVariable[of \"hd (getQ state)\" \"getQ state\"]"], ["proof (prove)\nusing this:\n  getQ state \\<noteq> []\n  InvariantVarsQ (getQ state) F0 Vbl\n  getQ state \\<noteq> [] \\<Longrightarrow>\n  hd (getQ state) \\<in> set (getQ state)\n  hd (getQ state) el getQ state \\<Longrightarrow>\n  var (hd (getQ state)) \\<in> vars (getQ state)\n\ngoal (1 subgoal):\n 1. var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl", "unfolding InvariantVarsQ_def"], ["proof (prove)\nusing this:\n  getQ state \\<noteq> []\n  vars (getQ state) \\<subseteq> vars F0 \\<union> Vbl\n  getQ state \\<noteq> [] \\<Longrightarrow>\n  hd (getQ state) \\<in> set (getQ state)\n  hd (getQ state) el getQ state \\<Longrightarrow>\n  var (hd (getQ state)) \\<in> vars (getQ state)\n\ngoal (1 subgoal):\n 1. var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl", "by auto"], ["proof (state)\nthis:\n  var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "hence \"InvariantVarsM (getM ?state'') F0 Vbl\""], ["proof (prove)\nusing this:\n  var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl", "using assms"], ["proof (prove)\nusing this:\n  var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl", "using assertLiteralEffect[of \"state\" \"hd (getQ state)\" \"False\"]"], ["proof (prove)\nusing this:\n  var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl", "using varsAppendValuation[of \"elements (getM state)\" \"[hd (getQ state)]\"]"], ["proof (prove)\nusing this:\n  var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n  vars (elements (getM state) @ [hd (getQ state)]) =\n  vars (elements (getM state)) \\<union> vars [hd (getQ state)]\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n  vars (elements (getM state) @ [hd (getQ state)]) =\n  vars (elements (getM state)) \\<union> vars [hd (getQ state)]\n\ngoal (1 subgoal):\n 1. InvariantVarsM\n     (getM\n       (let state' = assertLiteral (hd (getQ state)) False state\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  var (hd (getQ state)) \\<in> vars F0 \\<union> Vbl\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantQCharacterization False (getQ state) (getF state) (getM state)\n  getQ state \\<noteq> []\n  \\<not> getConflictFlag state\n  vars (elements (getM state)) \\<subseteq> vars F0 \\<union> Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state)) False state) =\n                    getM state @ [(hd (getQ state), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state)) False state) =\n                    getF state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state)) False state) =\n                    getSATFlag state\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n            (getF state);\n   InvariantWatchesEl (getF state) (getWatch1 state)\n    (getWatch2 state)\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state)\n                     (getQ (assertLiteral (hd (getQ state)) False state))\n  vars (elements (getM state) @ [hd (getQ state)]) =\n  vars (elements (getM state)) \\<union> vars [hd (getQ state)]\n\ngoal (1 subgoal):\n 1. vars\n     (elements\n       (getM\n         (let state' = assertLiteral (hd (getQ state)) False state\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)))\n    \\<subseteq> vars F0 \\<union> Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "ultimately"], ["proof (chain)\npicking this:\n  InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl\n  InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl", "show ?thesis"], ["proof (prove)\nusing this:\n  InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl\n  InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = applyUnitPropagate state\n    in InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = applyUnitPropagate state\n  in InvariantVarsM (getM state') F0 Vbl \\<and>\n     InvariantVarsQ (getQ state') F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "(*********************************************************************************)\n(*   E X H A U S T I V E   U N I T   P R O P A G A T E                           *)\n(*********************************************************************************)"], ["", "definition \"lexLessState (Vbl::Variable set) == {(state1, state2). \n  (getM state1, getM state2) \\<in> lexLessRestricted Vbl}\""], ["", "lemma exhaustiveUnitPropagateTermination:\nfixes\n  state::State and Vbl::\"Variable set\"\nassumes \n  \"InvariantUniq (getM state)\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"InvariantVarsM (getM state) F0 Vbl\"\n  \"InvariantVarsQ (getQ state) F0 Vbl\"\n  \"InvariantVarsF (getF state) F0 Vbl\"\n  \"finite Vbl\"\nshows\n  \"exhaustiveUnitPropagate_dom state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom state", "using assms"], ["proof (prove)\nusing this:\n  InvariantUniq (getM state)\n  InvariantConsistent (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom state", "proof (induct rule: wf_induct[of \"lexLessState (vars F0 \\<union> Vbl)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (lexLessState (vars F0 \\<union> Vbl))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> lexLessState\n                          (vars F0 \\<union> Vbl) \\<longrightarrow>\n                   InvariantUniq (getM y) \\<longrightarrow>\n                   InvariantConsistent (getM y) \\<longrightarrow>\n                   InvariantWatchListsContainOnlyClausesFromF\n                    (getWatchList y) (getF y) \\<longrightarrow>\n                   InvariantWatchListsUniq\n                    (getWatchList y) \\<longrightarrow>\n                   InvariantWatchListsCharacterization (getWatchList y)\n                    (getWatch1 y) (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesEl (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesDiffer (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchCharacterization (getF y) (getWatch1 y)\n                    (getWatch2 y) (getM y) \\<longrightarrow>\n                   InvariantConflictFlagCharacterization (getConflictFlag y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantQCharacterization (getConflictFlag y) (getQ y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantUniqQ (getQ y) \\<longrightarrow>\n                   InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n                   finite Vbl \\<longrightarrow>\n                   exhaustiveUnitPropagate_dom y;\n        InvariantUniq (getM x); InvariantConsistent (getM x);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList x)\n         (getF x);\n        InvariantWatchListsUniq (getWatchList x);\n        InvariantWatchListsCharacterization (getWatchList x) (getWatch1 x)\n         (getWatch2 x);\n        InvariantWatchesEl (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchesDiffer (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchCharacterization (getF x) (getWatch1 x) (getWatch2 x)\n         (getM x);\n        InvariantConflictFlagCharacterization (getConflictFlag x) (getF x)\n         (getM x);\n        InvariantQCharacterization (getConflictFlag x) (getQ x) (getF x)\n         (getM x);\n        InvariantUniqQ (getQ x); InvariantVarsM (getM x) F0 Vbl;\n        InvariantVarsQ (getQ x) F0 Vbl; InvariantVarsF (getF x) F0 Vbl;\n        finite Vbl\\<rbrakk>\n       \\<Longrightarrow> exhaustiveUnitPropagate_dom x", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. wf (lexLessState (vars F0 \\<union> Vbl))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> lexLessState\n                          (vars F0 \\<union> Vbl) \\<longrightarrow>\n                   InvariantUniq (getM y) \\<longrightarrow>\n                   InvariantConsistent (getM y) \\<longrightarrow>\n                   InvariantWatchListsContainOnlyClausesFromF\n                    (getWatchList y) (getF y) \\<longrightarrow>\n                   InvariantWatchListsUniq\n                    (getWatchList y) \\<longrightarrow>\n                   InvariantWatchListsCharacterization (getWatchList y)\n                    (getWatch1 y) (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesEl (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesDiffer (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchCharacterization (getF y) (getWatch1 y)\n                    (getWatch2 y) (getM y) \\<longrightarrow>\n                   InvariantConflictFlagCharacterization (getConflictFlag y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantQCharacterization (getConflictFlag y) (getQ y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantUniqQ (getQ y) \\<longrightarrow>\n                   InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n                   finite Vbl \\<longrightarrow>\n                   exhaustiveUnitPropagate_dom y;\n        InvariantUniq (getM x); InvariantConsistent (getM x);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList x)\n         (getF x);\n        InvariantWatchListsUniq (getWatchList x);\n        InvariantWatchListsCharacterization (getWatchList x) (getWatch1 x)\n         (getWatch2 x);\n        InvariantWatchesEl (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchesDiffer (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchCharacterization (getF x) (getWatch1 x) (getWatch2 x)\n         (getM x);\n        InvariantConflictFlagCharacterization (getConflictFlag x) (getF x)\n         (getM x);\n        InvariantQCharacterization (getConflictFlag x) (getQ x) (getF x)\n         (getM x);\n        InvariantUniqQ (getQ x); InvariantVarsM (getM x) F0 Vbl;\n        InvariantVarsQ (getQ x) F0 Vbl; InvariantVarsF (getF x) F0 Vbl;\n        finite Vbl\\<rbrakk>\n       \\<Longrightarrow> exhaustiveUnitPropagate_dom x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (lexLessState (vars F0 \\<union> Vbl))", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              y \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              y \\<notin> Q)", "show \"\\<forall>Q (state::State). state \\<in> Q \\<longrightarrow> (\\<exists>stateMin\\<in>Q. \\<forall>state'. (state', stateMin) \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "fix Q :: \"State set\" and state :: State"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "assume \"state \\<in> Q\""], ["proof (state)\nthis:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "let ?Q1 = \"{M::LiteralTrail. \\<exists> state. state \\<in> Q \\<and> (getM state) = M}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>state \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  state \\<in> Q", "have \"getM state \\<in> ?Q1\""], ["proof (prove)\nusing this:\n  state \\<in> Q\n\ngoal (1 subgoal):\n 1. getM state\n    \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by auto"], ["proof (state)\nthis:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "have \"wf (lexLessRestricted (vars F0 \\<union> Vbl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> Vbl))", "using \\<open>finite Vbl\\<close>"], ["proof (prove)\nusing this:\n  finite Vbl\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> Vbl))", "using finiteVarsFormula[of \"F0\"]"], ["proof (prove)\nusing this:\n  finite Vbl\n  finite (vars F0)\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> Vbl))", "using  wfLexLessRestricted[of \"vars F0 \\<union> Vbl\"]"], ["proof (prove)\nusing this:\n  finite Vbl\n  finite (vars F0)\n  finite (vars F0 \\<union> Vbl) \\<Longrightarrow>\n  wf (lexLessRestricted (vars F0 \\<union> Vbl))\n\ngoal (1 subgoal):\n 1. wf (lexLessRestricted (vars F0 \\<union> Vbl))", "by simp"], ["proof (state)\nthis:\n  wf (lexLessRestricted (vars F0 \\<union> Vbl))\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>getM state \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> Vbl))", "obtain Mmin where \"Mmin \\<in> ?Q1\" \"\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow> M' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  wf (lexLessRestricted (vars F0 \\<union> Vbl))\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  getM state \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>Mmin.\n        \\<lbrakk>Mmin\n                 \\<in> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M};\n         \\<forall>M'.\n            (M', Mmin)\n            \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow>\n            M' \\<notin> {M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (erule_tac x=\"?Q1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> Vbl) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     \\<forall>x.\n        x \\<in> {M. \\<exists>state.\n                       state \\<in> Q \\<and>\n                       getM state = M} \\<longrightarrow>\n        (\\<exists>z\\<in>{M. \\<exists>state.\n                               state \\<in> Q \\<and> getM state = M}.\n            \\<forall>y.\n               (y, z)\n               \\<in> lexLessRestricted\n                      (vars F0 \\<union> Vbl) \\<longrightarrow>\n               y \\<notin> {M. \\<exists>state.\n                                 state \\<in> Q \\<and>\n                                 getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"getM state\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Mmin.\n                \\<lbrakk>Mmin\n                         \\<in> {M. \\<exists>state.\nstate \\<in> Q \\<and> getM state = M};\n                 \\<forall>M'.\n                    (M', Mmin)\n                    \\<in> lexLessRestricted\n                           (vars F0 \\<union> Vbl) \\<longrightarrow>\n                    M' \\<notin> {M. \\<exists>state.\n state \\<in> Q \\<and> getM state = M}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     getM state\n     \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M};\n     getM state\n     \\<in> {M. \\<exists>state.\n                  state \\<in> Q \\<and> getM state = M} \\<longrightarrow>\n     (\\<exists>z\\<in>{M. \\<exists>state.\n                            state \\<in> Q \\<and> getM state = M}.\n         \\<forall>y.\n            (y, z)\n            \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow>\n            y \\<notin> {M. \\<exists>state.\n                              state \\<in> Q \\<and> getM state = M})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "from \\<open>Mmin \\<in> ?Q1\\<close>"], ["proof (chain)\npicking this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "obtain stateMin\n          where \"stateMin \\<in> Q\" \"(getM stateMin) = Mmin\""], ["proof (prove)\nusing this:\n  Mmin \\<in> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (\\<And>stateMin.\n        \\<lbrakk>stateMin \\<in> Q; getM stateMin = Mmin\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stateMin \\<in> Q\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "have \"\\<forall>state'. (state', stateMin) \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>state'.\n       (state', stateMin)\n       \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n       state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n       state' \\<notin> Q", "fix state'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state'.\n       (state', stateMin)\n       \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n       state' \\<notin> Q", "show \"(state', stateMin) \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow> state' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n    state' \\<notin> Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> lexLessState (vars F0 \\<union> Vbl) \\<Longrightarrow>\n    state' \\<notin> Q", "assume \"(state', stateMin) \\<in> lexLessState (vars F0 \\<union> Vbl)\""], ["proof (state)\nthis:\n  (state', stateMin) \\<in> lexLessState (vars F0 \\<union> Vbl)\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> lexLessState (vars F0 \\<union> Vbl) \\<Longrightarrow>\n    state' \\<notin> Q", "hence \"(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> Vbl)\""], ["proof (prove)\nusing this:\n  (state', stateMin) \\<in> lexLessState (vars F0 \\<union> Vbl)\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> Vbl)", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  (state', stateMin)\n  \\<in> {(state1, state2).\n         (getM state1, getM state2)\n         \\<in> lexLessRestricted (vars F0 \\<union> Vbl)}\n\ngoal (1 subgoal):\n 1. (getM state', getM stateMin)\n    \\<in> lexLessRestricted (vars F0 \\<union> Vbl)", "by auto"], ["proof (state)\nthis:\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> Vbl)\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> lexLessState (vars F0 \\<union> Vbl) \\<Longrightarrow>\n    state' \\<notin> Q", "from \\<open>\\<forall>M'. (M', Mmin) \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow> M' \\<notin> ?Q1\\<close>\n              \\<open>(getM state', getM stateMin) \\<in> lexLessRestricted (vars F0 \\<union> Vbl)\\<close> \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> Vbl)\n  getM stateMin = Mmin", "have \"getM state' \\<notin> ?Q1\""], ["proof (prove)\nusing this:\n  \\<forall>M'.\n     (M', Mmin)\n     \\<in> lexLessRestricted (vars F0 \\<union> Vbl) \\<longrightarrow>\n     M' \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n  (getM state', getM stateMin)\n  \\<in> lexLessRestricted (vars F0 \\<union> Vbl)\n  getM stateMin = Mmin\n\ngoal (1 subgoal):\n 1. getM state'\n    \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "by simp"], ["proof (state)\nthis:\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. (state', stateMin)\n    \\<in> lexLessState (vars F0 \\<union> Vbl) \\<Longrightarrow>\n    state' \\<notin> Q", "with \\<open>getM stateMin = Mmin\\<close>"], ["proof (chain)\npicking this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}", "show \"state' \\<notin> Q\""], ["proof (prove)\nusing this:\n  getM stateMin = Mmin\n  getM state'\n  \\<notin> {M. \\<exists>state. state \\<in> Q \\<and> getM state = M}\n\ngoal (1 subgoal):\n 1. state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state', stateMin)\n  \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n  state' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>state'.\n     (state', stateMin)\n     \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "with \\<open>stateMin \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin)\n     \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     state' \\<notin> Q", "have \"\\<exists> stateMin \\<in> Q. (\\<forall>state'. (state', stateMin) \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow> state' \\<notin> Q)\""], ["proof (prove)\nusing this:\n  stateMin \\<in> Q\n  \\<forall>state'.\n     (state', stateMin)\n     \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>stateMin\\<in>Q.\n       \\<forall>state'.\n          (state', stateMin)\n          \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n          state' \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  \\<exists>stateMin\\<in>Q.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n        state' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "}"], ["proof (state)\nthis:\n  ?statea2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?statea2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>stateMin\\<in>?Q2.\n     \\<forall>state'.\n        (state', stateMin)\n        \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n        state' \\<notin> ?Q2\n\ngoal (1 subgoal):\n 1. \\<forall>Q state.\n       state \\<in> Q \\<longrightarrow>\n       (\\<exists>stateMin\\<in>Q.\n           \\<forall>state'.\n              (state', stateMin)\n              \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n              state' \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Q state.\n     state \\<in> Q \\<longrightarrow>\n     (\\<exists>stateMin\\<in>Q.\n         \\<forall>state'.\n            (state', stateMin)\n            \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n            state' \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf (lexLessState (vars F0 \\<union> Vbl))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> lexLessState\n                          (vars F0 \\<union> Vbl) \\<longrightarrow>\n                   InvariantUniq (getM y) \\<longrightarrow>\n                   InvariantConsistent (getM y) \\<longrightarrow>\n                   InvariantWatchListsContainOnlyClausesFromF\n                    (getWatchList y) (getF y) \\<longrightarrow>\n                   InvariantWatchListsUniq\n                    (getWatchList y) \\<longrightarrow>\n                   InvariantWatchListsCharacterization (getWatchList y)\n                    (getWatch1 y) (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesEl (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesDiffer (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchCharacterization (getF y) (getWatch1 y)\n                    (getWatch2 y) (getM y) \\<longrightarrow>\n                   InvariantConflictFlagCharacterization (getConflictFlag y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantQCharacterization (getConflictFlag y) (getQ y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantUniqQ (getQ y) \\<longrightarrow>\n                   InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n                   finite Vbl \\<longrightarrow>\n                   exhaustiveUnitPropagate_dom y;\n        InvariantUniq (getM x); InvariantConsistent (getM x);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList x)\n         (getF x);\n        InvariantWatchListsUniq (getWatchList x);\n        InvariantWatchListsCharacterization (getWatchList x) (getWatch1 x)\n         (getWatch2 x);\n        InvariantWatchesEl (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchesDiffer (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchCharacterization (getF x) (getWatch1 x) (getWatch2 x)\n         (getM x);\n        InvariantConflictFlagCharacterization (getConflictFlag x) (getF x)\n         (getM x);\n        InvariantQCharacterization (getConflictFlag x) (getQ x) (getF x)\n         (getM x);\n        InvariantUniqQ (getQ x); InvariantVarsM (getM x) F0 Vbl;\n        InvariantVarsQ (getQ x) F0 Vbl; InvariantVarsF (getF x) F0 Vbl;\n        finite Vbl\\<rbrakk>\n       \\<Longrightarrow> exhaustiveUnitPropagate_dom x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> lexLessState\n                          (vars F0 \\<union> Vbl) \\<longrightarrow>\n                   InvariantUniq (getM y) \\<longrightarrow>\n                   InvariantConsistent (getM y) \\<longrightarrow>\n                   InvariantWatchListsContainOnlyClausesFromF\n                    (getWatchList y) (getF y) \\<longrightarrow>\n                   InvariantWatchListsUniq\n                    (getWatchList y) \\<longrightarrow>\n                   InvariantWatchListsCharacterization (getWatchList y)\n                    (getWatch1 y) (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesEl (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesDiffer (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchCharacterization (getF y) (getWatch1 y)\n                    (getWatch2 y) (getM y) \\<longrightarrow>\n                   InvariantConflictFlagCharacterization (getConflictFlag y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantQCharacterization (getConflictFlag y) (getQ y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantUniqQ (getQ y) \\<longrightarrow>\n                   InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n                   finite Vbl \\<longrightarrow>\n                   exhaustiveUnitPropagate_dom y;\n        InvariantUniq (getM x); InvariantConsistent (getM x);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList x)\n         (getF x);\n        InvariantWatchListsUniq (getWatchList x);\n        InvariantWatchListsCharacterization (getWatchList x) (getWatch1 x)\n         (getWatch2 x);\n        InvariantWatchesEl (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchesDiffer (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchCharacterization (getF x) (getWatch1 x) (getWatch2 x)\n         (getM x);\n        InvariantConflictFlagCharacterization (getConflictFlag x) (getF x)\n         (getM x);\n        InvariantQCharacterization (getConflictFlag x) (getQ x) (getF x)\n         (getM x);\n        InvariantUniqQ (getQ x); InvariantVarsM (getM x) F0 Vbl;\n        InvariantVarsQ (getQ x) F0 Vbl; InvariantVarsF (getF x) F0 Vbl;\n        finite Vbl\\<rbrakk>\n       \\<Longrightarrow> exhaustiveUnitPropagate_dom x", "case (2 state')"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> lexLessState\n                          (vars F0 \\<union> Vbl) \\<longrightarrow>\n                   InvariantUniq (getM y) \\<longrightarrow>\n                   InvariantConsistent (getM y) \\<longrightarrow>\n                   InvariantWatchListsContainOnlyClausesFromF\n                    (getWatchList y) (getF y) \\<longrightarrow>\n                   InvariantWatchListsUniq\n                    (getWatchList y) \\<longrightarrow>\n                   InvariantWatchListsCharacterization (getWatchList y)\n                    (getWatch1 y) (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesEl (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesDiffer (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchCharacterization (getF y) (getWatch1 y)\n                    (getWatch2 y) (getM y) \\<longrightarrow>\n                   InvariantConflictFlagCharacterization (getConflictFlag y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantQCharacterization (getConflictFlag y) (getQ y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantUniqQ (getQ y) \\<longrightarrow>\n                   InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n                   finite Vbl \\<longrightarrow>\n                   exhaustiveUnitPropagate_dom y;\n        InvariantUniq (getM x); InvariantConsistent (getM x);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList x)\n         (getF x);\n        InvariantWatchListsUniq (getWatchList x);\n        InvariantWatchListsCharacterization (getWatchList x) (getWatch1 x)\n         (getWatch2 x);\n        InvariantWatchesEl (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchesDiffer (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchCharacterization (getF x) (getWatch1 x) (getWatch2 x)\n         (getM x);\n        InvariantConflictFlagCharacterization (getConflictFlag x) (getF x)\n         (getM x);\n        InvariantQCharacterization (getConflictFlag x) (getQ x) (getF x)\n         (getM x);\n        InvariantUniqQ (getQ x); InvariantVarsM (getM x) F0 Vbl;\n        InvariantVarsQ (getQ x) F0 Vbl; InvariantVarsF (getF x) F0 Vbl;\n        finite Vbl\\<rbrakk>\n       \\<Longrightarrow> exhaustiveUnitPropagate_dom x", "note ih = this"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> lexLessState\n                          (vars F0 \\<union> Vbl) \\<longrightarrow>\n                   InvariantUniq (getM y) \\<longrightarrow>\n                   InvariantConsistent (getM y) \\<longrightarrow>\n                   InvariantWatchListsContainOnlyClausesFromF\n                    (getWatchList y) (getF y) \\<longrightarrow>\n                   InvariantWatchListsUniq\n                    (getWatchList y) \\<longrightarrow>\n                   InvariantWatchListsCharacterization (getWatchList y)\n                    (getWatch1 y) (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesEl (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchesDiffer (getF y) (getWatch1 y)\n                    (getWatch2 y) \\<longrightarrow>\n                   InvariantWatchCharacterization (getF y) (getWatch1 y)\n                    (getWatch2 y) (getM y) \\<longrightarrow>\n                   InvariantConflictFlagCharacterization (getConflictFlag y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantQCharacterization (getConflictFlag y) (getQ y)\n                    (getF y) (getM y) \\<longrightarrow>\n                   InvariantUniqQ (getQ y) \\<longrightarrow>\n                   InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n                   InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n                   finite Vbl \\<longrightarrow>\n                   exhaustiveUnitPropagate_dom y;\n        InvariantUniq (getM x); InvariantConsistent (getM x);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList x)\n         (getF x);\n        InvariantWatchListsUniq (getWatchList x);\n        InvariantWatchListsCharacterization (getWatchList x) (getWatch1 x)\n         (getWatch2 x);\n        InvariantWatchesEl (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchesDiffer (getF x) (getWatch1 x) (getWatch2 x);\n        InvariantWatchCharacterization (getF x) (getWatch1 x) (getWatch2 x)\n         (getM x);\n        InvariantConflictFlagCharacterization (getConflictFlag x) (getF x)\n         (getM x);\n        InvariantQCharacterization (getConflictFlag x) (getQ x) (getF x)\n         (getM x);\n        InvariantUniqQ (getQ x); InvariantVarsM (getM x) F0 Vbl;\n        InvariantVarsQ (getQ x) F0 Vbl; InvariantVarsF (getF x) F0 Vbl;\n        finite Vbl\\<rbrakk>\n       \\<Longrightarrow> exhaustiveUnitPropagate_dom x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom state'", "proof (cases \"getQ state' = [] \\<or> getConflictFlag state'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "case False"], ["proof (state)\nthis:\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantWatchCharacterization (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantWatchCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "unfolding InvariantQCharacterization_def"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     (\\<not> getConflictFlag y \\<longrightarrow>\n      (\\<forall>l.\n          l el getQ y =\n          (\\<exists>c.\n              c el getF y \\<and>\n              isUnitClause c l (elements (getM y))))) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     (\\<not> getConflictFlag y \\<longrightarrow>\n      (\\<forall>l.\n          l el getQ y =\n          (\\<exists>c.\n              c el getF y \\<and>\n              isUnitClause c l (elements (getM y))))) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantQCharacterization (getConflictFlag ?state'') (getQ ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantQCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantConflictFlagCharacterization (getConflictFlag ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using InvariantConflictFlagCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantUniqQ (getQ ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using InvariantUniqQAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantConsistent (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantUniq (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using InvariantUniqAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantVarsM (getM ?state'') F0 Vbl\" \"InvariantVarsQ (getQ ?state'') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "using \\<open>\\<not> (getQ state' = [] \\<or> getConflictFlag state')\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "using InvariantsVarsAfterApplyUnitPropagate[of \"state'\" \"F0\" \"Vbl\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization False (getQ state') (getF state')\n    (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state';\n   InvariantVarsM (getM state') F0 Vbl; InvariantVarsQ (getQ state') F0 Vbl;\n   InvariantVarsF (getF state') F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"InvariantVarsF (getF ?state'') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl", "unfolding applyUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "using assertLiteralEffect[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n\ngoal (1 subgoal):\n 1. InvariantVarsF\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsF\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "moreover"], ["proof (state)\nthis:\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "have \"(?state'', state') \\<in> lexLessState (vars F0 \\<union> Vbl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> lexLessState (vars F0 \\<union> Vbl)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> lexLessState (vars F0 \\<union> Vbl)", "have \"getM ?state'' = getM state' @ [(hd (getQ state'), False)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getM (applyUnitPropagate state') =\n    getM state' @ [(hd (getQ state'), False)]", "unfolding applyUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. getM\n     (let state' = assertLiteral (hd (getQ state')) False state'\n      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n    getM state' @ [(hd (getQ state'), False)]", "using ih"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. getM\n     (let state' = assertLiteral (hd (getQ state')) False state'\n      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n    getM state' @ [(hd (getQ state'), False)]", "using assertLiteralEffect[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n\ngoal (1 subgoal):\n 1. getM\n     (let state' = assertLiteral (hd (getQ state')) False state'\n      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n    getM state' @ [(hd (getQ state'), False)]", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> lexLessState (vars F0 \\<union> Vbl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> lexLessState (vars F0 \\<union> Vbl)", "unfolding lexLessState_def"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> lexLessRestricted (vars F0 \\<union> Vbl)}", "unfolding lexLessRestricted_def"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "using lexLessAppend[of \"[(hd (getQ state'), False)]\" \"getM state'\"]"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "using \\<open>InvariantConsistent (getM ?state'')\\<close>"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "using \\<open>InvariantConsistent (getM state')\\<close>"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "unfolding InvariantConsistent_def"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "using \\<open>InvariantUniq (getM ?state'')\\<close>"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n  uniq (elements (getM (applyUnitPropagate state')))\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "using \\<open>InvariantUniq (getM state')\\<close>"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n  uniq (elements (getM (applyUnitPropagate state')))\n  InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "unfolding InvariantUniq_def"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n  uniq (elements (getM (applyUnitPropagate state')))\n  uniq (elements (getM state'))\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "using \\<open>InvariantVarsM (getM ?state'') F0 Vbl\\<close>"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n  uniq (elements (getM (applyUnitPropagate state')))\n  uniq (elements (getM state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "using \\<open>InvariantVarsM (getM state') F0 Vbl\\<close>"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n  uniq (elements (getM (applyUnitPropagate state')))\n  uniq (elements (getM state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "unfolding InvariantVarsM_def"], ["proof (prove)\nusing this:\n  getM (applyUnitPropagate state') =\n  getM state' @ [(hd (getQ state'), False)]\n  [(hd (getQ state'), False)] \\<noteq> [] \\<Longrightarrow>\n  (getM state' @ [(hd (getQ state'), False)], getM state') \\<in> lexLess\n  consistent (elements (getM (applyUnitPropagate state')))\n  consistent (elements (getM state'))\n  uniq (elements (getM (applyUnitPropagate state')))\n  uniq (elements (getM state'))\n  vars (elements (getM (applyUnitPropagate state')))\n  \\<subseteq> vars F0 \\<union> Vbl\n  vars (elements (getM state')) \\<subseteq> vars F0 \\<union> Vbl\n\ngoal (1 subgoal):\n 1. (applyUnitPropagate state', state')\n    \\<in> {(state1, state2).\n           (getM state1, getM state2)\n           \\<in> {(M1, M2).\n                  vars (elements M1) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M1) \\<and>\n                  uniq (elements M1) \\<and>\n                  vars (elements M2) \\<subseteq> vars F0 \\<union> Vbl \\<and>\n                  consistent (elements M2) \\<and>\n                  uniq (elements M2) \\<and> (M1, M2) \\<in> lexLess}}", "by simp"], ["proof (state)\nthis:\n  (applyUnitPropagate state', state')\n  \\<in> lexLessState (vars F0 \\<union> Vbl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (applyUnitPropagate state', state')\n  \\<in> lexLessState (vars F0 \\<union> Vbl)\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "ultimately"], ["proof (chain)\npicking this:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n  (applyUnitPropagate state', state')\n  \\<in> lexLessState (vars F0 \\<union> Vbl)", "have \"exhaustiveUnitPropagate_dom ?state''\""], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n  (applyUnitPropagate state', state')\n  \\<in> lexLessState (vars F0 \\<union> Vbl)\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom (applyUnitPropagate state')", "using ih"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n  (applyUnitPropagate state', state')\n  \\<in> lexLessState (vars F0 \\<union> Vbl)\n  \\<forall>y.\n     (y, state') \\<in> lexLessState (vars F0 \\<union> Vbl) \\<longrightarrow>\n     InvariantUniq (getM y) \\<longrightarrow>\n     InvariantConsistent (getM y) \\<longrightarrow>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList y)\n      (getF y) \\<longrightarrow>\n     InvariantWatchListsUniq (getWatchList y) \\<longrightarrow>\n     InvariantWatchListsCharacterization (getWatchList y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesEl (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchesDiffer (getF y) (getWatch1 y)\n      (getWatch2 y) \\<longrightarrow>\n     InvariantWatchCharacterization (getF y) (getWatch1 y) (getWatch2 y)\n      (getM y) \\<longrightarrow>\n     InvariantConflictFlagCharacterization (getConflictFlag y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantQCharacterization (getConflictFlag y) (getQ y) (getF y)\n      (getM y) \\<longrightarrow>\n     InvariantUniqQ (getQ y) \\<longrightarrow>\n     InvariantVarsM (getM y) F0 Vbl \\<longrightarrow>\n     InvariantVarsQ (getQ y) F0 Vbl \\<longrightarrow>\n     InvariantVarsF (getF y) F0 Vbl \\<longrightarrow>\n     finite Vbl \\<longrightarrow> exhaustiveUnitPropagate_dom y\n  InvariantUniq (getM state')\n  InvariantConsistent (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  finite Vbl\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom (applyUnitPropagate state')", "by auto"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n\ngoal (2 subgoals):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'\n 2. \\<not> (getQ state' = [] \\<or> getConflictFlag state') \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom state'", "using exhaustiveUnitPropagate_dom.intros[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  (\\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n   \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                      (applyUnitPropagate state')) \\<Longrightarrow>\n  exhaustiveUnitPropagate_dom state'\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom state'", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  (\\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n   \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                      (applyUnitPropagate state')) \\<Longrightarrow>\n  exhaustiveUnitPropagate_dom state'\n  \\<not> (getQ state' = [] \\<or> getConflictFlag state')\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate_dom state'\n\ngoal (1 subgoal):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "case True"], ["proof (state)\nthis:\n  getQ state' = [] \\<or> getConflictFlag state'\n\ngoal (1 subgoal):\n 1. getQ state' = [] \\<or> getConflictFlag state' \\<Longrightarrow>\n    exhaustiveUnitPropagate_dom state'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate_dom state'", "apply (rule exhaustiveUnitPropagate_dom.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                       (applyUnitPropagate state')", "using True"], ["proof (prove)\nusing this:\n  getQ state' = [] \\<or> getConflictFlag state'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                       (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate_dom state'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate_dom state'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exhaustiveUnitPropagatePreservedVariables:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       (getSATFlag state') = (getSATFlag state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in getSATFlag state' = getSATFlag state", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in getSATFlag state' = getSATFlag state", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in getSATFlag state' =\n                             getSATFlag (applyUnitPropagate state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in getSATFlag state' = getSATFlag state", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getSATFlag state'a =\n                       getSATFlag (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in getSATFlag state' =\n                             getSATFlag (applyUnitPropagate state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in getSATFlag state' = getSATFlag state", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getSATFlag state'a =\n                       getSATFlag (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in getSATFlag state' =\n                             getSATFlag (applyUnitPropagate state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in getSATFlag state' = getSATFlag state", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "by (simp only: Let_def)"], ["proof (state)\nthis:\n  let state'a = exhaustiveUnitPropagate state'\n  in getSATFlag state'a = getSATFlag state'\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "moreover"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getSATFlag state'a =\n                       getSATFlag (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getSATFlag state'a =\n                       getSATFlag (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                     (let state' =\n                            assertLiteral (hd (getQ state')) False state'\n                      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsUniq\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsCharacterization\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesEl\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesDiffer\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (let state' =\n                                  assertLiteral (hd (getQ state')) False\n                                   state'\n                            in state'\n                               \\<lparr>getQ := tl (getQ state')\\<rparr>)\n                    in getSATFlag state'a =\n                       getSATFlag\n                        (let state' =\n                               assertLiteral (hd (getQ state')) False state'\n                         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "have \"getSATFlag ?state'' = getSATFlag state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getSATFlag (applyUnitPropagate state') = getSATFlag state'", "unfolding applyUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. getSATFlag\n     (let state' = assertLiteral (hd (getQ state')) False state'\n      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n    getSATFlag state'", "using assertLiteralEffect[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n\ngoal (1 subgoal):\n 1. getSATFlag\n     (let state' = assertLiteral (hd (getQ state')) False state'\n      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n    getSATFlag state'", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getSATFlag state'a =\n                       getSATFlag (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. getSATFlag\n     (let state' = assertLiteral (hd (getQ state')) False state'\n      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>) =\n    getSATFlag state'", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  getSATFlag (applyUnitPropagate state') = getSATFlag state'\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "ultimately"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  getSATFlag (applyUnitPropagate state') = getSATFlag state'", "show ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  getSATFlag (applyUnitPropagate state') = getSATFlag state'\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  getSATFlag (applyUnitPropagate state') = getSATFlag state'\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getSATFlag state'a =\n                       getSATFlag (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  getSATFlag (applyUnitPropagate state') = getSATFlag state'\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getSATFlag state'a =\n                       getSATFlag (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in getSATFlag state'a = getSATFlag state'", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state'a = exhaustiveUnitPropagate state'\n  in getSATFlag state'a = getSATFlag state'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state'a = exhaustiveUnitPropagate state'\n  in getSATFlag state'a = getSATFlag state'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exhaustiveUnitPropagatePreservesCurrentLevel:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       currentLevel (getM state') = currentLevel (getM state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in currentLevel (getM state') = currentLevel (getM state)", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in currentLevel (getM state') = currentLevel (getM state)", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in currentLevel (getM state') =\n                             currentLevel (getM (applyUnitPropagate state));\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in currentLevel (getM state') =\n                            currentLevel (getM state)", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in currentLevel (getM state'a) =\n                       currentLevel (getM (applyUnitPropagate state'))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in currentLevel (getM state') =\n                             currentLevel (getM (applyUnitPropagate state));\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in currentLevel (getM state') =\n                            currentLevel (getM state)", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in currentLevel (getM state'a) =\n                       currentLevel (getM (applyUnitPropagate state'))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in currentLevel (getM state') =\n                             currentLevel (getM (applyUnitPropagate state));\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in currentLevel (getM state') =\n                            currentLevel (getM state)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "by (simp only: Let_def)"], ["proof (state)\nthis:\n  let state'a = exhaustiveUnitPropagate state'\n  in currentLevel (getM state'a) = currentLevel (getM state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "moreover"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in currentLevel (getM state'a) =\n                       currentLevel (getM (applyUnitPropagate state'))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in currentLevel (getM state'a) =\n                       currentLevel (getM (applyUnitPropagate state'))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                     (let state' =\n                            assertLiteral (hd (getQ state')) False state'\n                      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsUniq\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsCharacterization\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesEl\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesDiffer\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (let state' =\n                                  assertLiteral (hd (getQ state')) False\n                                   state'\n                            in state'\n                               \\<lparr>getQ := tl (getQ state')\\<rparr>)\n                    in currentLevel (getM state'a) =\n                       currentLevel\n                        (getM\n                          (let state' =\n                                 assertLiteral (hd (getQ state')) False\n                                  state'\n                           in state'\n                              \\<lparr>getQ := tl (getQ state')\\<rparr>))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "have \"currentLevel (getM state') = currentLevel (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel (getM (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel\n     (getM\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "using assertLiteralEffect[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel\n     (getM\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in currentLevel (getM state'a) =\n                       currentLevel (getM (applyUnitPropagate state'))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel\n     (getM\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in length (decisions (getM state'a)) =\n                       length (decisions (getM (applyUnitPropagate state')))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. length (decisions (getM state')) =\n    length\n     (decisions\n       (getM\n         (let state' = assertLiteral (hd (getQ state')) False state'\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)))", "by (simp add: Let_def markedElementsAppend)"], ["proof (state)\nthis:\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "ultimately"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))", "show ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in currentLevel (getM state'a) =\n                       currentLevel (getM (applyUnitPropagate state'))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state'a =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in currentLevel (getM state'a) =\n                       currentLevel (getM (applyUnitPropagate state'))\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state'a = exhaustiveUnitPropagate state'\n    in currentLevel (getM state'a) = currentLevel (getM state')", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state'a = exhaustiveUnitPropagate state'\n  in currentLevel (getM state'a) = currentLevel (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state'a = exhaustiveUnitPropagate state'\n  in currentLevel (getM state'a) = currentLevel (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantsAfterExhaustiveUnitPropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"InvariantVarsQ (getQ state) F0 Vbl\"\n  \"InvariantVarsM (getM state) F0 Vbl\"\n  \"InvariantVarsF (getF state) F0 Vbl\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       InvariantConsistent (getM state') \\<and> \n       InvariantUniq (getM state') \\<and> \n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state') (getF state') \\<and> \n       InvariantWatchListsUniq (getWatchList state') \\<and> \n       InvariantWatchListsCharacterization (getWatchList state') (getWatch1 state') (getWatch2 state') \\<and> \n       InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state') \\<and> \n       InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state') \\<and> \n       InvariantWatchCharacterization (getF state') (getWatch1 state') (getWatch2 state') (getM state') \\<and> \n       InvariantConflictFlagCharacterization (getConflictFlag state') (getF state') (getM state') \\<and> \n       InvariantQCharacterization (getConflictFlag state') (getQ state') (getF state') (getM state') \\<and> \n       InvariantUniqQ (getQ state') \\<and> \n       InvariantVarsQ (getQ state') F0 Vbl \\<and> \n       InvariantVarsM (getM state') F0 Vbl \\<and> \n       InvariantVarsF (getF state') F0 Vbl\n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantVarsQ (getQ state) F0 Vbl\n  InvariantVarsM (getM state) F0 Vbl\n  InvariantVarsF (getF state) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl;\n         InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl;\n         InvariantVarsF (getF (applyUnitPropagate state)) F0 Vbl\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantConsistent (getM state') \\<and>\n                             InvariantUniq (getM state') \\<and>\n                             InvariantWatchListsContainOnlyClausesFromF\n                              (getWatchList state') (getF state') \\<and>\n                             InvariantWatchListsUniq\n                              (getWatchList state') \\<and>\n                             InvariantWatchListsCharacterization\n                              (getWatchList state') (getWatch1 state')\n                              (getWatch2 state') \\<and>\n                             InvariantWatchesEl (getF state')\n                              (getWatch1 state') (getWatch2 state') \\<and>\n                             InvariantWatchesDiffer (getF state')\n                              (getWatch1 state') (getWatch2 state') \\<and>\n                             InvariantWatchCharacterization (getF state')\n                              (getWatch1 state') (getWatch2 state')\n                              (getM state') \\<and>\n                             InvariantConflictFlagCharacterization\n                              (getConflictFlag state') (getF state')\n                              (getM state') \\<and>\n                             InvariantQCharacterization\n                              (getConflictFlag state') (getQ state')\n                              (getF state') (getM state') \\<and>\n                             InvariantUniqQ (getQ state') \\<and>\n                             InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                             InvariantVarsM (getM state') F0 Vbl \\<and>\n                             InvariantVarsF (getF state') F0 Vbl;\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state); InvariantVarsQ (getQ state) F0 Vbl;\n        InvariantVarsM (getM state) F0 Vbl;\n        InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantConsistent (getM state') \\<and>\n                            InvariantUniq (getM state') \\<and>\n                            InvariantWatchListsContainOnlyClausesFromF\n                             (getWatchList state') (getF state') \\<and>\n                            InvariantWatchListsUniq\n                             (getWatchList state') \\<and>\n                            InvariantWatchListsCharacterization\n                             (getWatchList state') (getWatch1 state')\n                             (getWatch2 state') \\<and>\n                            InvariantWatchesEl (getF state')\n                             (getWatch1 state') (getWatch2 state') \\<and>\n                            InvariantWatchesDiffer (getF state')\n                             (getWatch1 state') (getWatch2 state') \\<and>\n                            InvariantWatchCharacterization (getF state')\n                             (getWatch1 state') (getWatch2 state')\n                             (getM state') \\<and>\n                            InvariantConflictFlagCharacterization\n                             (getConflictFlag state') (getF state')\n                             (getM state') \\<and>\n                            InvariantQCharacterization\n                             (getConflictFlag state') (getQ state')\n                             (getF state') (getM state') \\<and>\n                            InvariantUniqQ (getQ state') \\<and>\n                            InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                            InvariantVarsM (getM state') F0 Vbl \\<and>\n                            InvariantVarsF (getF state') F0 Vbl", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl;\n         InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl;\n         InvariantVarsF (getF (applyUnitPropagate state)) F0 Vbl\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantConsistent (getM state') \\<and>\n                             InvariantUniq (getM state') \\<and>\n                             InvariantWatchListsContainOnlyClausesFromF\n                              (getWatchList state') (getF state') \\<and>\n                             InvariantWatchListsUniq\n                              (getWatchList state') \\<and>\n                             InvariantWatchListsCharacterization\n                              (getWatchList state') (getWatch1 state')\n                              (getWatch2 state') \\<and>\n                             InvariantWatchesEl (getF state')\n                              (getWatch1 state') (getWatch2 state') \\<and>\n                             InvariantWatchesDiffer (getF state')\n                              (getWatch1 state') (getWatch2 state') \\<and>\n                             InvariantWatchCharacterization (getF state')\n                              (getWatch1 state') (getWatch2 state')\n                              (getM state') \\<and>\n                             InvariantConflictFlagCharacterization\n                              (getConflictFlag state') (getF state')\n                              (getM state') \\<and>\n                             InvariantQCharacterization\n                              (getConflictFlag state') (getQ state')\n                              (getF state') (getM state') \\<and>\n                             InvariantUniqQ (getQ state') \\<and>\n                             InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                             InvariantVarsM (getM state') F0 Vbl \\<and>\n                             InvariantVarsF (getF state') F0 Vbl;\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state); InvariantVarsQ (getQ state) F0 Vbl;\n        InvariantVarsM (getM state) F0 Vbl;\n        InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantConsistent (getM state') \\<and>\n                            InvariantUniq (getM state') \\<and>\n                            InvariantWatchListsContainOnlyClausesFromF\n                             (getWatchList state') (getF state') \\<and>\n                            InvariantWatchListsUniq\n                             (getWatchList state') \\<and>\n                            InvariantWatchListsCharacterization\n                             (getWatchList state') (getWatch1 state')\n                             (getWatch2 state') \\<and>\n                            InvariantWatchesEl (getF state')\n                             (getWatch1 state') (getWatch2 state') \\<and>\n                            InvariantWatchesDiffer (getF state')\n                             (getWatch1 state') (getWatch2 state') \\<and>\n                            InvariantWatchCharacterization (getF state')\n                             (getWatch1 state') (getWatch2 state')\n                             (getM state') \\<and>\n                            InvariantConflictFlagCharacterization\n                             (getConflictFlag state') (getF state')\n                             (getM state') \\<and>\n                            InvariantQCharacterization\n                             (getConflictFlag state') (getQ state')\n                             (getF state') (getM state') \\<and>\n                            InvariantUniqQ (getQ state') \\<and>\n                            InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                            InvariantVarsM (getM state') F0 Vbl \\<and>\n                            InvariantVarsF (getF state') F0 Vbl", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantVarsQ (getQ (applyUnitPropagate state)) F0 Vbl;\n         InvariantVarsM (getM (applyUnitPropagate state)) F0 Vbl;\n         InvariantVarsF (getF (applyUnitPropagate state)) F0 Vbl\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantConsistent (getM state') \\<and>\n                             InvariantUniq (getM state') \\<and>\n                             InvariantWatchListsContainOnlyClausesFromF\n                              (getWatchList state') (getF state') \\<and>\n                             InvariantWatchListsUniq\n                              (getWatchList state') \\<and>\n                             InvariantWatchListsCharacterization\n                              (getWatchList state') (getWatch1 state')\n                              (getWatch2 state') \\<and>\n                             InvariantWatchesEl (getF state')\n                              (getWatch1 state') (getWatch2 state') \\<and>\n                             InvariantWatchesDiffer (getF state')\n                              (getWatch1 state') (getWatch2 state') \\<and>\n                             InvariantWatchCharacterization (getF state')\n                              (getWatch1 state') (getWatch2 state')\n                              (getM state') \\<and>\n                             InvariantConflictFlagCharacterization\n                              (getConflictFlag state') (getF state')\n                              (getM state') \\<and>\n                             InvariantQCharacterization\n                              (getConflictFlag state') (getQ state')\n                              (getF state') (getM state') \\<and>\n                             InvariantUniqQ (getQ state') \\<and>\n                             InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                             InvariantVarsM (getM state') F0 Vbl \\<and>\n                             InvariantVarsF (getF state') F0 Vbl;\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state); InvariantVarsQ (getQ state) F0 Vbl;\n        InvariantVarsM (getM state) F0 Vbl;\n        InvariantVarsF (getF state) F0 Vbl\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantConsistent (getM state') \\<and>\n                            InvariantUniq (getM state') \\<and>\n                            InvariantWatchListsContainOnlyClausesFromF\n                             (getWatchList state') (getF state') \\<and>\n                            InvariantWatchListsUniq\n                             (getWatchList state') \\<and>\n                            InvariantWatchListsCharacterization\n                             (getWatchList state') (getWatch1 state')\n                             (getWatch2 state') \\<and>\n                            InvariantWatchesEl (getF state')\n                             (getWatch1 state') (getWatch2 state') \\<and>\n                            InvariantWatchesDiffer (getF state')\n                             (getWatch1 state') (getWatch2 state') \\<and>\n                            InvariantWatchCharacterization (getF state')\n                             (getWatch1 state') (getWatch2 state')\n                             (getM state') \\<and>\n                            InvariantConflictFlagCharacterization\n                             (getConflictFlag state') (getF state')\n                             (getM state') \\<and>\n                            InvariantQCharacterization\n                             (getConflictFlag state') (getQ state')\n                             (getF state') (getM state') \\<and>\n                            InvariantUniqQ (getQ state') \\<and>\n                            InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                            InvariantVarsM (getM state') F0 Vbl \\<and>\n                            InvariantVarsF (getF state') F0 Vbl", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "by (auto simp only: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantConsistent (getM state') \\<and>\n     InvariantUniq (getM state') \\<and>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n      (getF state') \\<and>\n     InvariantWatchListsUniq (getWatchList state') \\<and>\n     InvariantWatchListsCharacterization (getWatchList state')\n      (getWatch1 state') (getWatch2 state') \\<and>\n     InvariantWatchesEl (getF state') (getWatch1 state')\n      (getWatch2 state') \\<and>\n     InvariantWatchesDiffer (getF state') (getWatch1 state')\n      (getWatch2 state') \\<and>\n     InvariantWatchCharacterization (getF state') (getWatch1 state')\n      (getWatch2 state') (getM state') \\<and>\n     InvariantConflictFlagCharacterization (getConflictFlag state')\n      (getF state') (getM state') \\<and>\n     InvariantQCharacterization (getConflictFlag state') (getQ state')\n      (getF state') (getM state') \\<and>\n     InvariantUniqQ (getQ state') \\<and>\n     InvariantVarsQ (getQ state') F0 Vbl \\<and>\n     InvariantVarsM (getM state') F0 Vbl \\<and>\n     InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                     (let state' =\n                            assertLiteral (hd (getQ state')) False state'\n                      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantUniq\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsUniq\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsCharacterization\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesEl\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesDiffer\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchCharacterization\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantQCharacterization\n    (getConflictFlag\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getQ\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantUniqQ\n    (getQ\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantVarsQ\n    (getQ\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    F0 Vbl;\n   InvariantVarsM\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    F0 Vbl;\n   InvariantVarsF\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (let state' =\n                                  assertLiteral (hd (getQ state')) False\n                                   state'\n                            in state'\n                               \\<lparr>getQ := tl (getQ state')\\<rparr>)\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantWatchCharacterization (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantWatchCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "unfolding InvariantQCharacterization_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       (\\<not> getConflictFlag state' \\<longrightarrow>\n                        (\\<forall>l.\n                            l el getQ state' =\n                            (\\<exists>c.\n                                c el getF state' \\<and>\n                                isUnitClause c l\n                                 (elements (getM state'))))) \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       (\\<not> getConflictFlag state' \\<longrightarrow>\n                        (\\<forall>l.\n                            l el getQ state' =\n                            (\\<exists>c.\n                                c el getF state' \\<and>\n                                isUnitClause c l\n                                 (elements (getM state'))))) \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantQCharacterization (getConflictFlag ?state'') (getQ ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantQCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantConflictFlagCharacterization (getConflictFlag ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using InvariantConflictFlagCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantUniqQ (getQ ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using InvariantUniqQAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantConsistent (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantUniq (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using InvariantUniqAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantVarsM (getM ?state'') F0 Vbl\" \"InvariantVarsQ (getQ ?state'') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "using \\<open>\\<not> (getConflictFlag state' \\<or> getQ state' = [])\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "using InvariantsVarsAfterApplyUnitPropagate[of \"state'\" \"F0\" \"Vbl\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization False (getQ state') (getF state')\n    (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state';\n   InvariantVarsM (getM state') F0 Vbl; InvariantVarsQ (getQ state') F0 Vbl;\n   InvariantVarsF (getF state') F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl &&&\n    InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "moreover"], ["proof (state)\nthis:\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "have \"InvariantVarsF (getF ?state'') F0 Vbl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl", "unfolding applyUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantVarsF\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "using assertLiteralEffect[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n\ngoal (1 subgoal):\n 1. InvariantVarsF\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. InvariantVarsF\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     F0 Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "ultimately"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl", "show ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl\n  InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantVarsQ (getQ (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsM (getM (applyUnitPropagate state')) F0 Vbl;\n   InvariantVarsF (getF (applyUnitPropagate state')) F0 Vbl\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConsistent (getM state') \\<and>\n                       InvariantUniq (getM state') \\<and>\n                       InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state') \\<and>\n                       InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state')\n                        (getM state') \\<and>\n                       InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state')\n                        (getM state') \\<and>\n                       InvariantQCharacterization (getConflictFlag state')\n                        (getQ state') (getF state') (getM state') \\<and>\n                       InvariantUniqQ (getQ state') \\<and>\n                       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n                       InvariantVarsM (getM state') F0 Vbl \\<and>\n                       InvariantVarsF (getF state') F0 Vbl\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantVarsQ (getQ state') F0 Vbl\n  InvariantVarsM (getM state') F0 Vbl\n  InvariantVarsF (getF state') F0 Vbl\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConsistent (getM state') \\<and>\n       InvariantUniq (getM state') \\<and>\n       InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n        (getF state') \\<and>\n       InvariantWatchListsUniq (getWatchList state') \\<and>\n       InvariantWatchListsCharacterization (getWatchList state')\n        (getWatch1 state') (getWatch2 state') \\<and>\n       InvariantWatchesEl (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchesDiffer (getF state') (getWatch1 state')\n        (getWatch2 state') \\<and>\n       InvariantWatchCharacterization (getF state') (getWatch1 state')\n        (getWatch2 state') (getM state') \\<and>\n       InvariantConflictFlagCharacterization (getConflictFlag state')\n        (getF state') (getM state') \\<and>\n       InvariantQCharacterization (getConflictFlag state') (getQ state')\n        (getF state') (getM state') \\<and>\n       InvariantUniqQ (getQ state') \\<and>\n       InvariantVarsQ (getQ state') F0 Vbl \\<and>\n       InvariantVarsM (getM state') F0 Vbl \\<and>\n       InvariantVarsF (getF state') F0 Vbl", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantConsistent (getM state') \\<and>\n     InvariantUniq (getM state') \\<and>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n      (getF state') \\<and>\n     InvariantWatchListsUniq (getWatchList state') \\<and>\n     InvariantWatchListsCharacterization (getWatchList state')\n      (getWatch1 state') (getWatch2 state') \\<and>\n     InvariantWatchesEl (getF state') (getWatch1 state')\n      (getWatch2 state') \\<and>\n     InvariantWatchesDiffer (getF state') (getWatch1 state')\n      (getWatch2 state') \\<and>\n     InvariantWatchCharacterization (getF state') (getWatch1 state')\n      (getWatch2 state') (getM state') \\<and>\n     InvariantConflictFlagCharacterization (getConflictFlag state')\n      (getF state') (getM state') \\<and>\n     InvariantQCharacterization (getConflictFlag state') (getQ state')\n      (getF state') (getM state') \\<and>\n     InvariantUniqQ (getQ state') \\<and>\n     InvariantVarsQ (getQ state') F0 Vbl \\<and>\n     InvariantVarsM (getM state') F0 Vbl \\<and>\n     InvariantVarsF (getF state') F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantConsistent (getM state') \\<and>\n     InvariantUniq (getM state') \\<and>\n     InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n      (getF state') \\<and>\n     InvariantWatchListsUniq (getWatchList state') \\<and>\n     InvariantWatchListsCharacterization (getWatchList state')\n      (getWatch1 state') (getWatch2 state') \\<and>\n     InvariantWatchesEl (getF state') (getWatch1 state')\n      (getWatch2 state') \\<and>\n     InvariantWatchesDiffer (getF state') (getWatch1 state')\n      (getWatch2 state') \\<and>\n     InvariantWatchCharacterization (getF state') (getWatch1 state')\n      (getWatch2 state') (getM state') \\<and>\n     InvariantConflictFlagCharacterization (getConflictFlag state')\n      (getF state') (getM state') \\<and>\n     InvariantQCharacterization (getConflictFlag state') (getQ state')\n      (getF state') (getM state') \\<and>\n     InvariantUniqQ (getQ state') \\<and>\n     InvariantVarsQ (getQ state') F0 Vbl \\<and>\n     InvariantVarsM (getM state') F0 Vbl \\<and>\n     InvariantVarsF (getF state') F0 Vbl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantConflictClauseCharacterizationAfterExhaustivePropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantConflictClauseCharacterization (getConflictFlag state) (getConflictClause state) (getF state) (getM state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in\n   InvariantConflictClauseCharacterization (getConflictFlag state') (getConflictClause state') (getF state') (getM state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantConflictClauseCharacterization (getConflictFlag state)\n   (getConflictClause state) (getF state) (getM state)\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantConflictClauseCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getConflictClause (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantConflictClauseCharacterization\n                              (getConflictFlag state')\n                              (getConflictClause state') (getF state')\n                              (getM state');\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantConflictClauseCharacterization (getConflictFlag state)\n         (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantConflictClauseCharacterization\n                             (getConflictFlag state')\n                             (getConflictClause state') (getF state')\n                             (getM state')", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantConflictClauseCharacterization (getConflictFlag state')\n   (getConflictClause state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantConflictClauseCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getConflictClause (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantConflictClauseCharacterization\n                              (getConflictFlag state')\n                              (getConflictClause state') (getF state')\n                              (getM state');\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantConflictClauseCharacterization (getConflictFlag state)\n         (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantConflictClauseCharacterization\n                             (getConflictFlag state')\n                             (getConflictClause state') (getF state')\n                             (getM state')", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantConflictClauseCharacterization (getConflictFlag state')\n   (getConflictClause state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantConflictClauseCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getConflictClause (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantConflictClauseCharacterization\n                              (getConflictFlag state')\n                              (getConflictClause state') (getF state')\n                              (getM state');\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantConflictClauseCharacterization (getConflictFlag state)\n         (getConflictClause state) (getF state) (getM state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantConflictClauseCharacterization\n                             (getConflictFlag state')\n                             (getConflictClause state') (getF state')\n                             (getM state')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantConflictClauseCharacterization (getConflictFlag state')\n   (getConflictClause state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "by (auto simp only: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantConflictClauseCharacterization (getConflictFlag state')\n      (getConflictClause state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "moreover"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih(2) ih(3) ih(4) ih(5) ih(6) ih(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsUniq\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsCharacterization\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesEl\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesDiffer\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getConflictClause\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (let state' =\n                                  assertLiteral (hd (getQ state')) False\n                                   state'\n                            in state'\n                               \\<lparr>getQ := tl (getQ state')\\<rparr>)\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "have \"InvariantConflictClauseCharacterization (getConflictFlag ?state'') (getConflictClause ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConflictClauseCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getConflictClause (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using ih(2) ih(3) ih(4) ih(5) ih(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. InvariantConflictClauseCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getConflictClause (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using \\<open>\\<not> (getConflictFlag state' \\<or> getQ state' = [])\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConflictClauseCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getConflictClause (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using InvariantConflictClauseCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsUniq (getWatchList state');\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConflictClauseCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getConflictClause (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConflictClauseCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getConflictClause (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "ultimately"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantConflictClauseCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getConflictClause (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "show ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantConflictClauseCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getConflictClause (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "using ih(1) ih(2)"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantConflictClauseCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getConflictClause (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantConflictClauseCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getConflictClause (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantConflictClauseCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getConflictClause (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantConflictClauseCharacterization\n                        (getConflictFlag state') (getConflictClause state')\n                        (getF state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantConflictClauseCharacterization (getConflictFlag state')\n        (getConflictClause state') (getF state') (getM state')", "by (simp only: Let_def) (blast)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantConflictClauseCharacterization (getConflictFlag state')\n      (getConflictClause state') (getF state') (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantConflictClauseCharacterization (getConflictFlag state')\n      (getConflictClause state') (getF state') (getM state')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantsNoDecisionsWhenConflictNorUnitAfterExhaustivePropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\n  \"InvariantNoDecisionsWhenConflict (getF state) (getM state) (currentLevel (getM state))\"\n  \"InvariantNoDecisionsWhenUnit (getF state) (getM state) (currentLevel (getM state))\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in\n       InvariantNoDecisionsWhenConflict (getF state') (getM state') (currentLevel (getM state')) \\<and> \n       InvariantNoDecisionsWhenUnit (getF state') (getM state') (currentLevel (getM state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantNoDecisionsWhenConflict (getF state) (getM state)\n   (currentLevel (getM state))\n  InvariantNoDecisionsWhenUnit (getF state) (getM state)\n   (currentLevel (getM state))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (currentLevel (getM (applyUnitPropagate state)));\n         InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (currentLevel (getM (applyUnitPropagate state)))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantNoDecisionsWhenConflict (getF state')\n                              (getM state')\n                              (currentLevel (getM state')) \\<and>\n                             InvariantNoDecisionsWhenUnit (getF state')\n                              (getM state') (currentLevel (getM state'));\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state);\n        InvariantNoDecisionsWhenConflict (getF state) (getM state)\n         (currentLevel (getM state));\n        InvariantNoDecisionsWhenUnit (getF state) (getM state)\n         (currentLevel (getM state))\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantNoDecisionsWhenConflict (getF state')\n                             (getM state')\n                             (currentLevel (getM state')) \\<and>\n                            InvariantNoDecisionsWhenUnit (getF state')\n                             (getM state') (currentLevel (getM state'))", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (currentLevel (getM (applyUnitPropagate state)));\n         InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (currentLevel (getM (applyUnitPropagate state)))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantNoDecisionsWhenConflict (getF state')\n                              (getM state')\n                              (currentLevel (getM state')) \\<and>\n                             InvariantNoDecisionsWhenUnit (getF state')\n                              (getM state') (currentLevel (getM state'));\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state);\n        InvariantNoDecisionsWhenConflict (getF state) (getM state)\n         (currentLevel (getM state));\n        InvariantNoDecisionsWhenUnit (getF state) (getM state)\n         (currentLevel (getM state))\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantNoDecisionsWhenConflict (getF state')\n                             (getM state')\n                             (currentLevel (getM state')) \\<and>\n                            InvariantNoDecisionsWhenUnit (getF state')\n                             (getM state') (currentLevel (getM state'))", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (currentLevel (getM (applyUnitPropagate state)));\n         InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (currentLevel (getM (applyUnitPropagate state)))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantNoDecisionsWhenConflict (getF state')\n                              (getM state')\n                              (currentLevel (getM state')) \\<and>\n                             InvariantNoDecisionsWhenUnit (getF state')\n                              (getM state') (currentLevel (getM state'));\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state);\n        InvariantNoDecisionsWhenConflict (getF state) (getM state)\n         (currentLevel (getM state));\n        InvariantNoDecisionsWhenUnit (getF state) (getM state)\n         (currentLevel (getM state))\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantNoDecisionsWhenConflict (getF state')\n                             (getM state')\n                             (currentLevel (getM state')) \\<and>\n                            InvariantNoDecisionsWhenUnit (getF state')\n                             (getM state') (currentLevel (getM state'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "by (auto simp only: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n      (currentLevel (getM state')) \\<and>\n     InvariantNoDecisionsWhenUnit (getF state') (getM state')\n      (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih(5) ih(6) ih(7) ih(8) ih(9)"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantWatchCharacterization (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantWatchCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "unfolding InvariantQCharacterization_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantQCharacterization (getConflictFlag ?state'') (getQ ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantQCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantConflictFlagCharacterization (getConflictFlag ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using InvariantConflictFlagCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantUniqQ (getQ ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using InvariantUniqQAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantConsistent (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantUniq (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using InvariantUniqAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "have \"InvariantNoDecisionsWhenUnit (getF ?state'') (getM ?state'') (currentLevel (getM ?state''))\"\n         \"InvariantNoDecisionsWhenConflict (getF ?state'') (getM ?state'') (currentLevel (getM ?state''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))\n     (currentLevel (getM (applyUnitPropagate state'))) &&&\n    InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))\n     (currentLevel (getM (applyUnitPropagate state')))", "using ih(5) ih(8) ih(11) ih(12) ih(14) ih(15)"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))\n     (currentLevel (getM (applyUnitPropagate state'))) &&&\n    InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))\n     (currentLevel (getM (applyUnitPropagate state')))", "using InvariantNoDecisionsWhenConflictNorUnitAfterUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantNoDecisionsWhenConflict (getF state') (getM state')\n   (currentLevel (getM state'))\n  InvariantNoDecisionsWhenUnit (getF state') (getM state')\n   (currentLevel (getM state'))\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantNoDecisionsWhenConflict (getF state') (getM state')\n    (currentLevel (getM state'));\n   InvariantNoDecisionsWhenUnit (getF state') (getM state')\n    (currentLevel (getM state'))\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))\n     (currentLevel (getM (applyUnitPropagate state'))) &&&\n    InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))\n     (currentLevel (getM (applyUnitPropagate state')))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n  InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "ultimately"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n  InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))", "show ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n  InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "using ih(1) ih(2)"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n  InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n  InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n   (currentLevel (getM (applyUnitPropagate state')))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantNoDecisionsWhenConflict (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')));\n   InvariantNoDecisionsWhenUnit (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'))\n    (currentLevel (getM (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantNoDecisionsWhenConflict (getF state')\n                        (getM state') (currentLevel (getM state')) \\<and>\n                       InvariantNoDecisionsWhenUnit (getF state')\n                        (getM state') (currentLevel (getM state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n        (currentLevel (getM state')) \\<and>\n       InvariantNoDecisionsWhenUnit (getF state') (getM state')\n        (currentLevel (getM state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n      (currentLevel (getM state')) \\<and>\n     InvariantNoDecisionsWhenUnit (getF state') (getM state')\n      (currentLevel (getM state'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantNoDecisionsWhenConflict (getF state') (getM state')\n      (currentLevel (getM state')) \\<and>\n     InvariantNoDecisionsWhenUnit (getF state') (getM state')\n      (currentLevel (getM state'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantGetReasonIsReasonAfterExhaustiveUnitPropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\" and\n  \"InvariantGetReasonIsReason (getReason state) (getF state) (getM state) (set (getQ state))\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n       InvariantGetReasonIsReason (getReason state') (getF state') (getM state') (set (getQ state'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n  InvariantGetReasonIsReason (getReason state) (getF state) (getM state)\n   (set (getQ state))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantGetReasonIsReason (getReason (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (set (getQ (applyUnitPropagate state)))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantGetReasonIsReason (getReason state')\n                              (getF state') (getM state')\n                              (set (getQ state'));\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state);\n        InvariantGetReasonIsReason (getReason state) (getF state)\n         (getM state) (set (getQ state))\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantGetReasonIsReason (getReason state')\n                             (getF state') (getM state') (set (getQ state'))", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantGetReasonIsReason (getReason (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (set (getQ (applyUnitPropagate state)))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantGetReasonIsReason (getReason state')\n                              (getF state') (getM state')\n                              (set (getQ state'));\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state);\n        InvariantGetReasonIsReason (getReason state) (getF state)\n         (getM state) (set (getQ state))\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantGetReasonIsReason (getReason state')\n                             (getF state') (getM state') (set (getQ state'))", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state));\n         InvariantGetReasonIsReason (getReason (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state))\n          (set (getQ (applyUnitPropagate state)))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantGetReasonIsReason (getReason state')\n                              (getF state') (getM state')\n                              (set (getQ state'));\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state);\n        InvariantGetReasonIsReason (getReason state) (getF state)\n         (getM state) (set (getQ state))\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantGetReasonIsReason (getReason state')\n                             (getF state') (getM state') (set (getQ state'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "by (auto simp only: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantGetReasonIsReason (getReason state') (getF state')\n      (getM state') (set (getQ state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                     (let state' =\n                            assertLiteral (hd (getQ state')) False state'\n                      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantUniq\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsUniq\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsCharacterization\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesEl\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesDiffer\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchCharacterization\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantQCharacterization\n    (getConflictFlag\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getQ\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantUniqQ\n    (getQ\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantGetReasonIsReason\n    (getReason\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (set (getQ\n           (let state' = assertLiteral (hd (getQ state')) False state'\n            in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (let state' =\n                                  assertLiteral (hd (getQ state')) False\n                                   state'\n                            in state'\n                               \\<lparr>getQ := tl (getQ state')\\<rparr>)\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantWatchCharacterization (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantWatchCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "unfolding InvariantQCharacterization_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantQCharacterization (getConflictFlag ?state'') (getQ ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantQCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantConflictFlagCharacterization (getConflictFlag ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using InvariantConflictFlagCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantUniqQ (getQ ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using InvariantUniqQAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantConsistent (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantUniq (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using InvariantUniqAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "have \"InvariantGetReasonIsReason (getReason ?state'') (getF ?state'') (getM ?state'') (set (getQ ?state''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n     (set (getQ (applyUnitPropagate state')))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n     (set (getQ (applyUnitPropagate state')))", "using InvariantGetReasonIsReasonAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state');\n   InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n    (set (getQ state'));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n     (set (getQ (applyUnitPropagate state')))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state');\n   InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n    (set (getQ state'));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n     (set (getQ (applyUnitPropagate state')))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n   (set (getQ (applyUnitPropagate state')))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "ultimately"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n   (set (getQ (applyUnitPropagate state')))", "show ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n   (set (getQ (applyUnitPropagate state')))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n   (set (getQ (applyUnitPropagate state')))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n   (set (getQ (applyUnitPropagate state')))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'));\n   InvariantGetReasonIsReason (getReason (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n    (set (getQ (applyUnitPropagate state')))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantGetReasonIsReason (getReason state')\n                        (getF state') (getM state') (set (getQ state'))\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  InvariantGetReasonIsReason (getReason state') (getF state') (getM state')\n   (set (getQ state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantGetReasonIsReason (getReason state') (getF state')\n        (getM state') (set (getQ state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantGetReasonIsReason (getReason state') (getF state')\n      (getM state') (set (getQ state'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantGetReasonIsReason (getReason state') (getF state')\n      (getM state') (set (getQ state'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InvariantEquivalentZLAfterExhaustiveUnitPropagate:\nassumes\n  \"exhaustiveUnitPropagate_dom state\"\n  \"InvariantConsistent (getM state)\"\n  \"InvariantUniq (getM state)\"\n  \"InvariantEquivalentZL (getF state) (getM state) Phi\"\n  \"InvariantWatchListsContainOnlyClausesFromF (getWatchList state) (getF state)\" and\n  \"InvariantWatchListsUniq (getWatchList state)\" and\n  \"InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\" and\n  \"InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\"\n  \"InvariantWatchCharacterization (getF state) (getWatch1 state) (getWatch2 state) (getM state)\"\n  \"InvariantConflictFlagCharacterization (getConflictFlag state) (getF state) (getM state)\"\n  \"InvariantQCharacterization (getConflictFlag state) (getQ state) (getF state) (getM state)\"\n  \"InvariantUniqQ (getQ state)\"\nshows\n  \"let state' = exhaustiveUnitPropagate state in \n      InvariantEquivalentZL (getF state') (getM state') Phi\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n  InvariantConsistent (getM state)\n  InvariantUniq (getM state)\n  InvariantEquivalentZL (getF state) (getM state) Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n   (getF state)\n  InvariantWatchListsUniq (getWatchList state)\n  InvariantWatchListsCharacterization (getWatchList state) (getWatch1 state)\n   (getWatch2 state)\n  InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchesDiffer (getF state) (getWatch1 state) (getWatch2 state)\n  InvariantWatchCharacterization (getF state) (getWatch1 state)\n   (getWatch2 state) (getM state)\n  InvariantConflictFlagCharacterization (getConflictFlag state) (getF state)\n   (getM state)\n  InvariantQCharacterization (getConflictFlag state) (getQ state)\n   (getF state) (getM state)\n  InvariantUniqQ (getQ state)\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantEquivalentZL (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state)) Phi;\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantEquivalentZL (getF state')\n                              (getM state') Phi;\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantEquivalentZL (getF state) (getM state) Phi;\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantEquivalentZL (getF state')\n                             (getM state') Phi", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantEquivalentZL (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state)) Phi;\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantEquivalentZL (getF state')\n                              (getM state') Phi;\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantEquivalentZL (getF state) (getM state) Phi;\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantEquivalentZL (getF state')\n                             (getM state') Phi", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state; getQ state \\<noteq> [];\n         InvariantConsistent (getM (applyUnitPropagate state));\n         InvariantUniq (getM (applyUnitPropagate state));\n         InvariantEquivalentZL (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state)) Phi;\n         InvariantWatchListsContainOnlyClausesFromF\n          (getWatchList (applyUnitPropagate state))\n          (getF (applyUnitPropagate state));\n         InvariantWatchListsUniq (getWatchList (applyUnitPropagate state));\n         InvariantWatchListsCharacterization\n          (getWatchList (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesEl (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchesDiffer (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state));\n         InvariantWatchCharacterization (getF (applyUnitPropagate state))\n          (getWatch1 (applyUnitPropagate state))\n          (getWatch2 (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantConflictFlagCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantQCharacterization\n          (getConflictFlag (applyUnitPropagate state))\n          (getQ (applyUnitPropagate state))\n          (getF (applyUnitPropagate state))\n          (getM (applyUnitPropagate state));\n         InvariantUniqQ (getQ (applyUnitPropagate state))\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in InvariantEquivalentZL (getF state')\n                              (getM state') Phi;\n        InvariantConsistent (getM state); InvariantUniq (getM state);\n        InvariantEquivalentZL (getF state) (getM state) Phi;\n        InvariantWatchListsContainOnlyClausesFromF (getWatchList state)\n         (getF state);\n        InvariantWatchListsUniq (getWatchList state);\n        InvariantWatchListsCharacterization (getWatchList state)\n         (getWatch1 state) (getWatch2 state);\n        InvariantWatchesEl (getF state) (getWatch1 state) (getWatch2 state);\n        InvariantWatchesDiffer (getF state) (getWatch1 state)\n         (getWatch2 state);\n        InvariantWatchCharacterization (getF state) (getWatch1 state)\n         (getWatch2 state) (getM state);\n        InvariantConflictFlagCharacterization (getConflictFlag state)\n         (getF state) (getM state);\n        InvariantQCharacterization (getConflictFlag state) (getQ state)\n         (getF state) (getM state);\n        InvariantUniqQ (getQ state)\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in InvariantEquivalentZL (getF state')\n                             (getM state') Phi", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "by (simp only: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantEquivalentZL (getF state') (getM state') Phi\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantWatchListsContainOnlyClausesFromF (getWatchList ?state'') (getF ?state'')\" and\n      \"InvariantWatchListsUniq (getWatchList ?state'')\" and\n      \"InvariantWatchListsCharacterization (getWatchList ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\"\n      \"InvariantWatchesEl (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\" and\n      \"InvariantWatchesDiffer (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "using WatchInvariantsAfterAssertLiteral[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList (applyUnitPropagate state'))\n      (getF (applyUnitPropagate state')) &&&\n     InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state')) &&&\n     InvariantWatchesEl (getF (applyUnitPropagate state'))\n      (getWatch1 (applyUnitPropagate state'))\n      (getWatch2 (applyUnitPropagate state'))) &&&\n    InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                     (let state' =\n                            assertLiteral (hd (getQ state')) False state'\n                      in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantUniq\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantEquivalentZL\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsUniq\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchListsCharacterization\n    (getWatchList\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesEl\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchesDiffer\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantWatchCharacterization\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch1\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getWatch2\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantQCharacterization\n    (getConflictFlag\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getQ\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getF\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n    (getM\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>));\n   InvariantUniqQ\n    (getQ\n      (let state' = assertLiteral (hd (getQ state')) False state'\n       in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (let state' =\n                                  assertLiteral (hd (getQ state')) False\n                                   state'\n                            in state'\n                               \\<lparr>getQ := tl (getQ state')\\<rparr>)\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          assertLiteral (hd (getQ state')) False state'\n                    in InvariantWatchListsContainOnlyClausesFromF\n                        (getWatchList state') (getF state') \\<and>\n                       InvariantWatchListsUniq (getWatchList state') \\<and>\n                       InvariantWatchListsCharacterization\n                        (getWatchList state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesEl (getF state') (getWatch1 state')\n                        (getWatch2 state') \\<and>\n                       InvariantWatchesDiffer (getF state')\n                        (getWatch1 state') (getWatch2 state')\n\ngoal (1 subgoal):\n 1. (InvariantWatchListsContainOnlyClausesFromF\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchListsUniq\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    (InvariantWatchListsCharacterization\n      (getWatchList\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)) &&&\n     InvariantWatchesEl\n      (getF\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch1\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n      (getWatch2\n        (let state' = assertLiteral (hd (getQ state')) False state'\n         in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))) &&&\n    InvariantWatchesDiffer\n     (getF\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch1\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))\n     (getWatch2\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantWatchCharacterization (getF ?state'') (getWatch1 ?state'') (getWatch2 ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantWatchCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "unfolding InvariantQCharacterization_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   \\<not> getConflictFlag (applyUnitPropagate state') \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ (applyUnitPropagate state') =\n       (\\<exists>c.\n           c el getF (applyUnitPropagate state') \\<and>\n           isUnitClause c l (elements (getM (applyUnitPropagate state')))));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  \\<not> getConflictFlag state' \\<longrightarrow>\n  (\\<forall>l.\n      l el getQ state' =\n      (\\<exists>c.\n          c el getF state' \\<and>\n          isUnitClause c l (elements (getM state'))))\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   \\<not> getConflictFlag state' \\<longrightarrow>\n   (\\<forall>l.\n       l el getQ state' =\n       (\\<exists>c.\n           c el getF state' \\<and>\n           isUnitClause c l (elements (getM state'))));\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantWatchCharacterization (getF state')\n                        (getWatch1 state') (getWatch2 state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n     (getWatch1 (applyUnitPropagate state'))\n     (getWatch2 (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantQCharacterization (getConflictFlag ?state'') (getQ ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using InvariantQCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> [];\n   \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantQCharacterization (getConflictFlag state'')\n                        (getQ state'') (getF state'') (getM state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n     (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantConflictFlagCharacterization (getConflictFlag ?state'') (getF ?state'') (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using InvariantConflictFlagCharacterizationAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state'); InvariantUniq (getM state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantWatchListsUniq (getWatchList state');\n   InvariantWatchListsCharacterization (getWatchList state')\n    (getWatch1 state') (getWatch2 state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchesDiffer (getF state') (getWatch1 state')\n    (getWatch2 state');\n   InvariantWatchCharacterization (getF state') (getWatch1 state')\n    (getWatch2 state') (getM state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   InvariantConflictFlagCharacterization (getConflictFlag state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConflictFlagCharacterization\n                        (getConflictFlag state') (getF state') (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConflictFlagCharacterization\n     (getConflictFlag (applyUnitPropagate state'))\n     (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantUniqQ (getQ ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using InvariantUniqQAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantWatchesEl (getF state') (getWatch1 state')\n            (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantUniqQ (getQ state'); getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state'' = applyUnitPropagate state'\n                    in InvariantUniqQ (getQ state'')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniqQ (getQ (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantConsistent (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using InvariantConsistentAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantConsistent (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantConsistent (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantConsistent (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantConsistent (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantUniq (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using InvariantUniqAfterApplyUnitPropagate[of \"state'\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantUniq (getM state');\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   getQ state' \\<noteq> []; \\<not> getConflictFlag state'\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantUniq (getM state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantUniq (getM (applyUnitPropagate state'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantUniq (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"InvariantEquivalentZL (getF ?state'') (getM ?state'') Phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvariantEquivalentZL (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state')) Phi", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. InvariantEquivalentZL (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state')) Phi", "using InvariantEquivalentZLAfterApplyUnitPropagate[of \"state'\" \"Phi\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantEquivalentZL (getF state') (getM state') Phi;\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n\ngoal (1 subgoal):\n 1. InvariantEquivalentZL (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state')) Phi", "using False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<lbrakk>InvariantEquivalentZL (getF state') (getM state') Phi;\n   InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state');\n   InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n    (getF state');\n   InvariantQCharacterization (getConflictFlag state') (getQ state')\n    (getF state') (getM state');\n   \\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' = applyUnitPropagate state'\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. InvariantEquivalentZL (getF (applyUnitPropagate state'))\n     (getM (applyUnitPropagate state')) Phi", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  InvariantEquivalentZL (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state')) Phi\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "moreover"], ["proof (state)\nthis:\n  InvariantEquivalentZL (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state')) Phi\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "have \"currentLevel (getM state') = currentLevel (getM ?state'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel (getM (applyUnitPropagate state'))", "unfolding applyUnitPropagate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel\n     (getM\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "using assertLiteralEffect[of \"state'\" \"hd (getQ state')\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel\n     (getM\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. currentLevel (getM state') =\n    currentLevel\n     (getM\n       (let state' = assertLiteral (hd (getQ state')) False state'\n        in state'\\<lparr>getQ := tl (getQ state')\\<rparr>))", "unfolding currentLevel_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getM (assertLiteral (hd (getQ state')) False state') =\n                    getM state' @ [(hd (getQ state'), False)]\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getF (assertLiteral (hd (getQ state')) False state') =\n                    getF state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> getSATFlag\n                     (assertLiteral (hd (getQ state')) False state') =\n                    getSATFlag state'\n  \\<lbrakk>InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n            (getF state');\n   InvariantWatchesEl (getF state') (getWatch1 state')\n    (getWatch2 state')\\<rbrakk>\n  \\<Longrightarrow> isPrefix (getQ state')\n                     (getQ (assertLiteral (hd (getQ state')) False state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. length (decisions (getM state')) =\n    length\n     (decisions\n       (getM\n         (let state' = assertLiteral (hd (getQ state')) False state'\n          in state'\\<lparr>getQ := tl (getQ state')\\<rparr>)))", "by (simp add: Let_def markedElementsAppend)"], ["proof (state)\nthis:\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "ultimately"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantEquivalentZL (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state')) Phi\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))", "show ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantEquivalentZL (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state')) Phi\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantEquivalentZL (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state')) Phi\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  InvariantWatchListsContainOnlyClausesFromF\n   (getWatchList (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state'))\n  InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'))\n  InvariantWatchListsCharacterization\n   (getWatchList (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesEl (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n  InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n   (getWatch1 (applyUnitPropagate state'))\n   (getWatch2 (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n   (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state'))\n  InvariantConflictFlagCharacterization\n   (getConflictFlag (applyUnitPropagate state'))\n   (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'))\n  InvariantUniqQ (getQ (applyUnitPropagate state'))\n  InvariantConsistent (getM (applyUnitPropagate state'))\n  InvariantUniq (getM (applyUnitPropagate state'))\n  InvariantEquivalentZL (getF (applyUnitPropagate state'))\n   (getM (applyUnitPropagate state')) Phi\n  currentLevel (getM state') =\n  currentLevel (getM (applyUnitPropagate state'))\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> [];\n   InvariantConsistent (getM (applyUnitPropagate state'));\n   InvariantUniq (getM (applyUnitPropagate state'));\n   InvariantEquivalentZL (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state')) Phi;\n   InvariantWatchListsContainOnlyClausesFromF\n    (getWatchList (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state'));\n   InvariantWatchListsUniq (getWatchList (applyUnitPropagate state'));\n   InvariantWatchListsCharacterization\n    (getWatchList (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesEl (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchesDiffer (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'));\n   InvariantWatchCharacterization (getF (applyUnitPropagate state'))\n    (getWatch1 (applyUnitPropagate state'))\n    (getWatch2 (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantConflictFlagCharacterization\n    (getConflictFlag (applyUnitPropagate state'))\n    (getF (applyUnitPropagate state')) (getM (applyUnitPropagate state'));\n   InvariantQCharacterization (getConflictFlag (applyUnitPropagate state'))\n    (getQ (applyUnitPropagate state')) (getF (applyUnitPropagate state'))\n    (getM (applyUnitPropagate state'));\n   InvariantUniqQ (getQ (applyUnitPropagate state'))\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantConsistent (getM state')\n  InvariantUniq (getM state')\n  InvariantEquivalentZL (getF state') (getM state') Phi\n  InvariantWatchListsContainOnlyClausesFromF (getWatchList state')\n   (getF state')\n  InvariantWatchListsUniq (getWatchList state')\n  InvariantWatchListsCharacterization (getWatchList state')\n   (getWatch1 state') (getWatch2 state')\n  InvariantWatchesEl (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchesDiffer (getF state') (getWatch1 state') (getWatch2 state')\n  InvariantWatchCharacterization (getF state') (getWatch1 state')\n   (getWatch2 state') (getM state')\n  InvariantConflictFlagCharacterization (getConflictFlag state')\n   (getF state') (getM state')\n  InvariantQCharacterization (getConflictFlag state') (getQ state')\n   (getF state') (getM state')\n  InvariantUniqQ (getQ state')\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in InvariantEquivalentZL (getF state') (getM state') Phi", "by (auto simp only: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantEquivalentZL (getF state') (getM state') Phi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in InvariantEquivalentZL (getF state') (getM state') Phi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conflictFlagOrQEmptyAfterExhaustiveUnitPropagate:\nassumes\n\"exhaustiveUnitPropagate_dom state\"\nshows\n\"let state' = exhaustiveUnitPropagate state in\n    (getConflictFlag state') \\<or> (getQ state' = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in getConflictFlag state' \\<or> getQ state' = []", "using assms"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate_dom state\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state\n    in getConflictFlag state' \\<or> getQ state' = []", "proof (induct state rule: exhaustiveUnitPropagate_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state;\n         getQ state \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in getConflictFlag state' \\<or>\n                             getQ state' = []\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in getConflictFlag state' \\<or> getQ state' = []", "case (step state')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state;\n         getQ state \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in getConflictFlag state' \\<or>\n                             getQ state' = []\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in getConflictFlag state' \\<or> getQ state' = []", "note ih = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. \\<And>state.\n       \\<lbrakk>\\<lbrakk>\\<not> getConflictFlag state;\n                 getQ state \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> exhaustiveUnitPropagate_dom\n                                   (applyUnitPropagate state);\n        \\<lbrakk>\\<not> getConflictFlag state;\n         getQ state \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> let state' =\n                                exhaustiveUnitPropagate\n                                 (applyUnitPropagate state)\n                          in getConflictFlag state' \\<or>\n                             getQ state' = []\\<rbrakk>\n       \\<Longrightarrow> let state' = exhaustiveUnitPropagate state\n                         in getConflictFlag state' \\<or> getQ state' = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "proof (cases \"(getConflictFlag state') \\<or> (getQ state') = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "case True"], ["proof (state)\nthis:\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "with exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (chain)\npicking this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = state'\""], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' = state'", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (2 subgoals):\n 1. getConflictFlag state' \\<or> getQ state' = [] \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []\n 2. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "using True"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' = state'\n  getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "by (simp only: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "case False"], ["proof (state)\nthis:\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "let ?state'' = \"applyUnitPropagate state'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "have \"exhaustiveUnitPropagate state' = exhaustiveUnitPropagate ?state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using exhaustiveUnitPropagate.simps[of \"state'\"]"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  (if getConflictFlag state' \\<or> getQ state' = [] then state'\n   else exhaustiveUnitPropagate (applyUnitPropagate state'))\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. exhaustiveUnitPropagate state' =\n    exhaustiveUnitPropagate (applyUnitPropagate state')", "by simp"], ["proof (state)\nthis:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. \\<not> (getConflictFlag state' \\<or> getQ state' = []) \\<Longrightarrow>\n    let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "using ih"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getConflictFlag state' \\<or> getQ state' = []\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "using False"], ["proof (prove)\nusing this:\n  exhaustiveUnitPropagate state' =\n  exhaustiveUnitPropagate (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state')\n  \\<lbrakk>\\<not> getConflictFlag state'; getQ state' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> let state' =\n                          exhaustiveUnitPropagate\n                           (applyUnitPropagate state')\n                    in getConflictFlag state' \\<or> getQ state' = []\n  \\<not> (getConflictFlag state' \\<or> getQ state' = [])\n\ngoal (1 subgoal):\n 1. let state' = exhaustiveUnitPropagate state'\n    in getConflictFlag state' \\<or> getQ state' = []", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in getConflictFlag state' \\<or> getQ state' = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let state' = exhaustiveUnitPropagate state'\n  in getConflictFlag state' \\<or> getQ state' = []\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}