{"file_name": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification/SatSolverCode.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SATSolverVerification", "problem_names": ["lemma [code_unfold]:\n  fixes literal :: Literal and clause :: Clause\n  shows \"literal el clause = List.member clause literal\""], "translations": [["", "lemma [code_unfold]:\n  fixes literal :: Literal and clause :: Clause\n  shows \"literal el clause = List.member clause literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal el clause = List.member clause literal", "by (auto simp add: member_def)"], ["", "datatype ExtendedBool = TRUE | FALSE | UNDEF"], ["", "record State = \n  \\<comment> \\<open>Satisfiability flag: UNDEF, TRUE or FALSE\\<close>\n\"getSATFlag\" :: ExtendedBool\n  \\<comment> \\<open>Formula\\<close> \n\"getF\"       :: Formula      \n  \\<comment> \\<open>Assertion Trail\\<close>\n\"getM\"       :: LiteralTrail \n  \\<comment> \\<open>Conflict flag\\<close>\n\"getConflictFlag\"   :: bool   \\<comment> \\<open>raised iff M falsifies F\\<close>\n  \\<comment> \\<open>Conflict clause index\\<close> \n\"getConflictClause\" :: nat    \\<comment> \\<open>corresponding clause from F is false in M\\<close>\n  \\<comment> \\<open>Unit propagation queue\\<close>\n\"getQ\" :: \"Literal list\"      \n  \\<comment> \\<open>Unit propagation graph\\<close>\n\"getReason\" :: \"Literal \\<Rightarrow> nat option\" \\<comment> \\<open>index of a clause that is a reason for propagation of a literal\\<close>\n  \\<comment> \\<open>Two-watch literal scheme\\<close>\n  \\<comment> \\<open>clause indices instead of clauses are used\\<close>\n\"getWatch1\" :: \"nat \\<Rightarrow> Literal option\"  \\<comment> \\<open>First watch of a clause\\<close>\n\"getWatch2\" :: \"nat \\<Rightarrow> Literal option\"  \\<comment> \\<open>Second watch of a clause\\<close>\n\"getWatchList\" :: \"Literal \\<Rightarrow> nat list\" \\<comment> \\<open>Watch list of a given literal\\<close>\n  \\<comment> \\<open>Conflict analysis data structures\\<close>\n\"getC\"   :: Clause             \\<comment> \\<open>Conflict analysis clause - always false in M\\<close>\n\"getCl\"  :: Literal            \\<comment> \\<open>Last asserted literal in (opposite getC)\\<close>\n\"getCll\" :: Literal            \\<comment> \\<open>Second last asserted literal in (opposite getC)\\<close>\n\"getCn\"  :: nat                \\<comment> \\<open>Number of literals of (opposite getC) on the (currentLevel M)\\<close>"], ["", "definition\nsetWatch1 :: \"nat \\<Rightarrow> Literal \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"setWatch1 clause literal state =\n    state\\<lparr> getWatch1 := (getWatch1 state)(clause := Some literal), \n           getWatchList := (getWatchList state)(literal := clause # (getWatchList state literal)) \n         \\<rparr>\n\""], ["", "declare setWatch1_def[code_unfold]"], ["", "definition\nsetWatch2 :: \"nat \\<Rightarrow> Literal \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"setWatch2 clause literal state =\n    state\\<lparr> getWatch2 := (getWatch2 state)(clause := Some literal),\n           getWatchList := (getWatchList state)(literal := clause # (getWatchList state literal)) \n         \\<rparr>\n\""], ["", "declare setWatch2_def[code_unfold]"], ["", "definition\nswapWatches :: \"nat \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"swapWatches clause state ==\n    state\\<lparr> getWatch1 := (getWatch1 state)(clause := (getWatch2 state clause)),\n           getWatch2 := (getWatch2 state)(clause := (getWatch1 state clause))\n         \\<rparr>\n\""], ["", "declare swapWatches_def[code_unfold]"], ["", "primrec getNonWatchedUnfalsifiedLiteral :: \"Clause \\<Rightarrow> Literal \\<Rightarrow> Literal \\<Rightarrow> LiteralTrail \\<Rightarrow> Literal option\"\nwhere\n\"getNonWatchedUnfalsifiedLiteral [] w1 w2 M = None\" |\n\"getNonWatchedUnfalsifiedLiteral (literal # clause) w1 w2 M = \n    (if literal \\<noteq> w1 \\<and> \n        literal \\<noteq> w2 \\<and> \n        \\<not> (literalFalse literal (elements M)) then\n            Some literal\n     else\n            getNonWatchedUnfalsifiedLiteral clause w1 w2 M\n    )\n\""], ["", "definition\nsetReason :: \"Literal \\<Rightarrow> nat \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"setReason literal clause state = \n    state\\<lparr> getReason := (getReason state)(literal := Some clause) \\<rparr>\n\""], ["", "declare setReason_def[code_unfold]"], ["", "primrec notifyWatches_loop::\"Literal \\<Rightarrow> nat list \\<Rightarrow> nat list \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"notifyWatches_loop literal [] newWl state = state\\<lparr> getWatchList := (getWatchList state)(literal := newWl) \\<rparr>\" |\n\"notifyWatches_loop literal (clause # list') newWl state = \n    (let state' = (if Some literal = (getWatch1 state clause) then \n                       (swapWatches clause state) \n                   else \n                       state) in\n    case (getWatch1 state' clause) of \n        None \\<Rightarrow> state\n    |   Some w1 \\<Rightarrow> (\n    case (getWatch2 state' clause) of \n        None \\<Rightarrow> state\n    |   Some w2 \\<Rightarrow> \n    (if (literalTrue w1 (elements (getM state'))) then\n        notifyWatches_loop literal list' (clause # newWl) state'\n     else\n        (case (getNonWatchedUnfalsifiedLiteral (nth (getF state') clause) w1 w2 (getM state')) of \n            Some l' \\<Rightarrow> \n                notifyWatches_loop literal list' newWl (setWatch2 clause l' state')\n          | None \\<Rightarrow> \n                (if (literalFalse w1 (elements (getM state'))) then\n                    let state'' = (state'\\<lparr> getConflictFlag := True, getConflictClause := clause \\<rparr>) in\n                    notifyWatches_loop literal list' (clause # newWl) state''\n                else\n                    let state'' = state'\\<lparr> getQ := (if w1 el (getQ state') then \n                                                      (getQ state') \n                                                  else \n                                                      (getQ state') @ [w1] \n                                                  )\n                                        \\<rparr> in\n                   let state''' = (setReason w1 clause state'') in\n                   notifyWatches_loop literal list' (clause # newWl) state'''\n                )\n        )\n    )\n    )\n    )\n\""], ["", "definition\nnotifyWatches :: \"Literal \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"notifyWatches literal state ==\n    notifyWatches_loop literal (getWatchList state literal) [] state\n\""], ["", "declare notifyWatches_def[code_unfold]"], ["", "definition\nassertLiteral :: \"Literal \\<Rightarrow> bool \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"assertLiteral literal decision state ==\n    let state' = (state\\<lparr> getM := (getM state) @ [(literal, decision)] \\<rparr>) in\n    notifyWatches (opposite literal) state'\n\""], ["", "definition\napplyUnitPropagate :: \"State \\<Rightarrow> State\"\nwhere\n\"applyUnitPropagate state =\n    (let state' = (assertLiteral (hd (getQ state)) False state) in\n    state'\\<lparr> getQ := tl (getQ state')\\<rparr>)\n\""], ["", "partial_function (tailrec)\nexhaustiveUnitPropagate :: \"State \\<Rightarrow> State\"\nwhere\nexhaustiveUnitPropagate_unfold[code]:\n\"exhaustiveUnitPropagate state =\n    (if (getConflictFlag state) \\<or> (getQ state) = [] then \n        state \n    else \n        exhaustiveUnitPropagate (applyUnitPropagate state)\n    )\n\""], ["", "inductive\nexhaustiveUnitPropagate_dom :: \"State \\<Rightarrow> bool\"\nwhere\nstep: \"(\\<not> getConflictFlag state \\<Longrightarrow> getQ state \\<noteq> []\n   \\<Longrightarrow> exhaustiveUnitPropagate_dom (applyUnitPropagate state))\n   \\<Longrightarrow> exhaustiveUnitPropagate_dom state\""], ["", "definition\naddClause :: \"Clause \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"addClause clause state =\n    (let clause' = (remdups (removeFalseLiterals clause (elements (getM state)))) in \n    (if (clauseTrue clause' (elements (getM state))) then \n        state\n    else (if clause'=[] then \n        state\\<lparr> getSATFlag := FALSE \\<rparr>\n    else (if (length clause' = 1) then \n        let state' = (assertLiteral (hd clause') False state) in\n        exhaustiveUnitPropagate state'\n    else (if (clauseTautology clause') then \n        state\n    else\n        let clauseIndex = length (getF state) in\n        let state'   = state\\<lparr> getF := (getF state) @ [clause']\\<rparr> in\n        let state''  = setWatch1 clauseIndex (nth clause' 0) state' in\n        let state''' = setWatch2 clauseIndex (nth clause' 1) state'' in\n        state'''\n   )))\n ))\""], ["", "definition\ninitialState :: \"State\"\nwhere\n\"initialState =\n    \\<lparr> getSATFlag = UNDEF,\n      getF = [], \n      getM = [], \n      getConflictFlag = False,\n      getConflictClause = 0, \n      getQ = [],\n      getReason = \\<lambda> l. None,\n      getWatch1 = \\<lambda> c. None, \n      getWatch2 = \\<lambda> c. None,\n      getWatchList = \\<lambda> l. [],\n      getC = [],\n      getCl = (Pos 0), \n      getCll = (Pos 0), \n      getCn = 0\n    \\<rparr>\n\""], ["", "primrec initialize :: \"Formula \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"initialize [] state = state\" |\n\"initialize (clause # formula) state = initialize formula (addClause clause state)\""], ["", "definition \nfindLastAssertedLiteral :: \"State \\<Rightarrow> State\"\nwhere\n\"findLastAssertedLiteral state = \n   state \\<lparr> getCl := getLastAssertedLiteral (oppositeLiteralList (getC state)) (elements (getM state)) \\<rparr>\""], ["", "definition\ncountCurrentLevelLiterals :: \"State \\<Rightarrow> State\"\nwhere\n\"countCurrentLevelLiterals state = \n   (let cl = currentLevel (getM state) in \n        state \\<lparr> getCn := length (filter (\\<lambda> l. elementLevel (opposite l) (getM state) = cl) (getC state)) \\<rparr>)\""], ["", "definition setConflictAnalysisClause :: \"Clause \\<Rightarrow> State \\<Rightarrow> State\" \nwhere \n\"setConflictAnalysisClause clause state = \n  (let oppM0 = oppositeLiteralList (elements (prefixToLevel 0 (getM state))) in \n   let state' = state (| getC := remdups (list_diff clause oppM0) |) in \n     countCurrentLevelLiterals (findLastAssertedLiteral state')\n  )\""], ["", "definition\napplyConflict :: \"State \\<Rightarrow> State\"\nwhere\n\"applyConflict state = \n   (let conflictClause = (nth (getF state) (getConflictClause state)) in\n    setConflictAnalysisClause conflictClause state)\""], ["", "definition\napplyExplain :: \"Literal \\<Rightarrow> State \\<Rightarrow> State\"\nwhere\n\"applyExplain literal state =\n    (case (getReason state literal) of\n        None \\<Rightarrow> \n            state\n    |   Some reason \\<Rightarrow> \n            let res = resolve (getC state) (nth (getF state) reason) (opposite literal) in \n            setConflictAnalysisClause res state\n        \n    )\n\""], ["", "partial_function (tailrec)\napplyExplainUIP :: \"State \\<Rightarrow> State\"\nwhere\napplyExplainUIP_unfold:\n\"applyExplainUIP state = \n    (if (getCn state = 1) then \n         state\n     else\n         applyExplainUIP (applyExplain (getCl state) state)\n    )\n\""], ["", "inductive\napplyExplainUIP_dom :: \"State \\<Rightarrow> bool\"\nwhere\nstep:\n\"(getCn state \\<noteq> 1\n    \\<Longrightarrow> applyExplainUIP_dom (applyExplain (getCl state) state))\n  \\<Longrightarrow> applyExplainUIP_dom state\n\""], ["", "definition\napplyLearn :: \"State \\<Rightarrow> State\"\nwhere\n\"applyLearn state =\n        (if getC state = [opposite (getCl state)] then\n            state\n         else\n            let state' = state\\<lparr> getF := (getF state) @ [getC state] \\<rparr> in\n            let l  = (getCl state) in\n            let ll = (getLastAssertedLiteral (removeAll l (oppositeLiteralList (getC state))) (elements (getM state))) in\n            let clauseIndex = length (getF state) in\n            let state''  = setWatch1 clauseIndex (opposite l) state' in\n            let state''' = setWatch2 clauseIndex (opposite ll) state'' in\n            state'''\\<lparr> getCll := ll \\<rparr>\n        )\n\""], ["", "definition\ngetBackjumpLevel :: \"State \\<Rightarrow> nat\"\nwhere\n\"getBackjumpLevel state ==\n    (if getC state = [opposite (getCl state)] then \n        0 \n     else\n        elementLevel (getCll state) (getM state)\n     )\n\""], ["", "definition\napplyBackjump :: \"State \\<Rightarrow> State\"\nwhere\n\"applyBackjump state =\n    (let l = (getCl state) in\n     let level = getBackjumpLevel state in\n     let state' = state\\<lparr> getConflictFlag := False, getQ := [], getM := (prefixToLevel level (getM state))\\<rparr> in\n     let state'' = (if level > 0 then setReason (opposite l) (length (getF state) - 1) state' else state') in\n     assertLiteral (opposite l) False state''\n    )\n\""], ["", "axiomatization selectLiteral :: \"State \\<Rightarrow> Variable set \\<Rightarrow> Literal\"\nwhere\nselectLiteral_def:\n\"Vbl - vars (elements (getM state)) \\<noteq> {} \\<longrightarrow> \n    var (selectLiteral state Vbl) \\<in> (Vbl - vars (elements (getM state)))\""], ["", "definition\napplyDecide :: \"State \\<Rightarrow> Variable set \\<Rightarrow> State\"\nwhere\n\"applyDecide state Vbl =\n    assertLiteral (selectLiteral state Vbl) True state\n\""], ["", "definition\nsolve_loop_body :: \"State \\<Rightarrow> Variable set \\<Rightarrow> State\"\nwhere\n\"solve_loop_body state Vbl = \n    (let state' = exhaustiveUnitPropagate state in\n    (if (getConflictFlag state') then\n        (if (currentLevel (getM state')) = 0 then\n            state'\\<lparr> getSATFlag := FALSE \\<rparr>\n         else\n            (applyBackjump\n            (applyLearn\n            (applyExplainUIP \n            (applyConflict\n                state'\n            )\n            )\n            )\n            )\n         )\n     else\n        (if (vars (elements (getM state')) \\<supseteq> Vbl) then\n            state'\\<lparr> getSATFlag := TRUE \\<rparr>\n         else\n            applyDecide state' Vbl\n        )\n    )\n    )\n\""], ["", "partial_function (tailrec) \nsolve_loop :: \"State \\<Rightarrow> Variable set \\<Rightarrow> State\"\nwhere\nsolve_loop_unfold: \n\"solve_loop state Vbl = \n    (if (getSATFlag state) \\<noteq> UNDEF then\n        state\n     else \n        let state' = solve_loop_body state Vbl in\n        solve_loop state' Vbl\n    )\n\""], ["", "inductive\nsolve_loop_dom :: \"State \\<Rightarrow> Variable set \\<Rightarrow> bool\"\nwhere\nstep:\n\"(getSATFlag state = UNDEF\n    \\<Longrightarrow> solve_loop_dom (solve_loop_body state Vbl) Vbl)\n  \\<Longrightarrow> solve_loop_dom state Vbl\""], ["", "definition solve::\"Formula \\<Rightarrow> ExtendedBool\"\nwhere\n\"solve F0 = \n    (getSATFlag \n        (solve_loop \n            (initialize F0 initialState) (vars F0)\n        )\n    )\n\""], ["", "(* \ncode_modulename SML\n  Nat Numbers\n  Int Numbers\n  Ring_and_Field Numbers\n\ncode_modulename OCaml\n  Nat Numbers\n  Int Numbers\n  Ring_and_Field Numbers\n\nexport_code solve in OCaml file \"code/solve.ML\"\n                  in SML file \"code/solve.ocaml\n                  in Haskell file \"code/\"\n*)\n\n(******************************************************************************)\n(*      I N V A R I A N T S                                                   *)\n(******************************************************************************)"], ["", "definition\nInvariantWatchListsContainOnlyClausesFromF :: \"(Literal \\<Rightarrow> nat list) \\<Rightarrow> Formula \\<Rightarrow> bool\"\nwhere\n\"InvariantWatchListsContainOnlyClausesFromF Wl F = \n    (\\<forall> (l::Literal) (c::nat). c \\<in>  set (Wl l) \\<longrightarrow> 0 \\<le> c \\<and> c < length F)\n\""], ["", "definition\nInvariantWatchListsUniq :: \"(Literal \\<Rightarrow> nat list) \\<Rightarrow> bool\"\nwhere\n\"InvariantWatchListsUniq Wl =\n    (\\<forall> l. uniq (Wl l))\n\""], ["", "definition\nInvariantWatchListsCharacterization :: \"(Literal \\<Rightarrow> nat list) \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> bool\"\nwhere\n\"InvariantWatchListsCharacterization Wl w1 w2 = \n    (\\<forall> (c::nat) (l::Literal). c \\<in> set (Wl l) = (Some l = (w1 c) \\<or> Some l = (w2 c)))\n\""], ["", "definition\nInvariantWatchesEl :: \"Formula \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> bool\"\nwhere\n\"InvariantWatchesEl formula watch1 watch2 == \n    \\<forall> (clause::nat). 0 \\<le> clause \\<and> clause < length formula \\<longrightarrow> \n        (\\<exists> (w1::Literal) (w2::Literal). watch1 clause = Some w1 \\<and> watch2 clause = Some w2 \\<and> \n             w1 el (nth formula clause) \\<and> w2 el (nth formula clause))\n\""], ["", "definition\nInvariantWatchesDiffer :: \"Formula \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> bool\"\nwhere\n\"InvariantWatchesDiffer formula watch1 watch2 == \n    \\<forall> (clause::nat). 0 \\<le> clause \\<and> clause < length formula \\<longrightarrow> watch1 clause \\<noteq> watch2 clause\n\""], ["", "definition\nwatchCharacterizationCondition::\"Literal \\<Rightarrow> Literal \\<Rightarrow> LiteralTrail \\<Rightarrow> Clause \\<Rightarrow> bool\"\nwhere\n\"watchCharacterizationCondition w1 w2 M clause = \n    (literalFalse w1 (elements M) \\<longrightarrow> \n        ( (\\<exists> l. l el clause \\<and> literalTrue l (elements M) \\<and> elementLevel l M \\<le> elementLevel (opposite w1) M) \\<or>\n          (\\<forall> l. l el clause \\<and> l \\<noteq> w1 \\<and> l \\<noteq> w2 \\<longrightarrow> \n                literalFalse l (elements M) \\<and> elementLevel (opposite l) M \\<le> elementLevel (opposite w1) M)\n          )\n    )\n\""], ["", "definition\nInvariantWatchCharacterization::\"Formula \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> (nat \\<Rightarrow> Literal option) \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\"\nwhere\n\"InvariantWatchCharacterization F watch1 watch2 M =\n    (\\<forall> c w1 w2. (0 \\<le> c \\<and> c < length F \\<and> Some w1 = watch1 c \\<and> Some w2 = watch2 c) \\<longrightarrow> \n          watchCharacterizationCondition w1 w2 M (nth F c) \\<and> \n          watchCharacterizationCondition w2 w1 M (nth F c)\n    )\n\""], ["", "definition\nInvariantQCharacterization :: \"bool \\<Rightarrow> Literal list \\<Rightarrow> Formula \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\"\nwhere\n\"InvariantQCharacterization conflictFlag Q F M ==\n   \\<not> conflictFlag \\<longrightarrow> (\\<forall> (l::Literal). l el Q = (\\<exists> (c::Clause). c el F \\<and> isUnitClause c l (elements M)))\n\""], ["", "definition\nInvariantUniqQ :: \"Literal list \\<Rightarrow> bool\"\nwhere\n\"InvariantUniqQ Q = \n    uniq Q\n\""], ["", "definition\nInvariantConflictFlagCharacterization :: \"bool \\<Rightarrow> Formula \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\"\nwhere\n\"InvariantConflictFlagCharacterization conflictFlag F M ==\n    conflictFlag = formulaFalse F (elements M)\n\""], ["", "definition\nInvariantNoDecisionsWhenConflict :: \"Formula \\<Rightarrow> LiteralTrail \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere\n\"InvariantNoDecisionsWhenConflict F M level= \n    (\\<forall> level'. level' < level \\<longrightarrow> \n              \\<not> formulaFalse F (elements (prefixToLevel level' M))\n    )\n\""], ["", "definition\nInvariantNoDecisionsWhenUnit :: \"Formula \\<Rightarrow> LiteralTrail \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere\n\"InvariantNoDecisionsWhenUnit F M level = \n    (\\<forall> level'. level' < level \\<longrightarrow> \n              \\<not> (\\<exists> clause literal. clause el F \\<and>\n                                   isUnitClause clause literal (elements (prefixToLevel level' M)))\n    )\n\""], ["", "definition InvariantEquivalentZL :: \"Formula \\<Rightarrow> LiteralTrail \\<Rightarrow> Formula \\<Rightarrow> bool\"\nwhere\n\"InvariantEquivalentZL F M F0 = \n    equivalentFormulae (F @ val2form (elements (prefixToLevel 0 M))) F0\n\""], ["", "definition\nInvariantGetReasonIsReason :: \"(Literal \\<Rightarrow> nat option) \\<Rightarrow> Formula \\<Rightarrow> LiteralTrail \\<Rightarrow> Literal set \\<Rightarrow> bool\"\nwhere\n\"InvariantGetReasonIsReason GetReason F M Q == \n     \\<forall> literal. (literal el (elements M) \\<and> \\<not> literal el (decisions M) \\<and> elementLevel literal M > 0 \\<longrightarrow> \n                   (\\<exists> (reason::nat). (GetReason literal) = Some reason \\<and> 0 \\<le> reason \\<and> reason < length F \\<and> \n                         isReason (nth F reason) literal (elements M)\n                   )\n                 ) \\<and> \n                (currentLevel M > 0 \\<and> literal \\<in> Q \\<longrightarrow> \n                   (\\<exists> (reason::nat). (GetReason literal) = Some reason \\<and> 0 \\<le> reason \\<and> reason < length F \\<and> \n                         (isUnitClause (nth F reason) literal (elements M) \\<or> clauseFalse (nth F reason) (elements M))\n                   )\n                 )\n\""], ["", "definition\nInvariantConflictClauseCharacterization :: \"bool \\<Rightarrow> nat \\<Rightarrow> Formula \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\"\nwhere\n\"InvariantConflictClauseCharacterization conflictFlag conflictClause F M  ==\n         conflictFlag \\<longrightarrow> (conflictClause < length F \\<and> \n                           clauseFalse (nth F conflictClause) (elements M))\""], ["", "definition\nInvariantClCharacterization :: \"Literal \\<Rightarrow> Clause \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\" \nwhere\n\"InvariantClCharacterization Cl C M == \n  isLastAssertedLiteral Cl (oppositeLiteralList C) (elements M)\""], ["", "definition\nInvariantCllCharacterization :: \"Literal \\<Rightarrow> Literal \\<Rightarrow> Clause \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\" \nwhere\n\"InvariantCllCharacterization Cl Cll C M == \n  set C \\<noteq> {opposite Cl} \\<longrightarrow> \n      isLastAssertedLiteral Cll (removeAll Cl (oppositeLiteralList C)) (elements M)\""], ["", "definition\nInvariantClCurrentLevel :: \"Literal \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\"\nwhere\n\"InvariantClCurrentLevel Cl M == \n  elementLevel Cl M = currentLevel M\""], ["", "definition\nInvariantCnCharacterization :: \"nat \\<Rightarrow> Clause \\<Rightarrow> LiteralTrail \\<Rightarrow> bool\"\nwhere\n\"InvariantCnCharacterization Cn C M == \n  Cn = length (filter (\\<lambda> l. elementLevel (opposite l) M = currentLevel M) (remdups C))\n\""], ["", "definition\nInvariantUniqC :: \"Clause \\<Rightarrow> bool\"\nwhere\n\"InvariantUniqC clause = uniq clause\""], ["", "definition\nInvariantVarsQ :: \"Literal list \\<Rightarrow> Formula \\<Rightarrow> Variable set \\<Rightarrow> bool\"\nwhere\n\"InvariantVarsQ Q F0 Vbl ==\n  vars Q \\<subseteq> vars F0 \\<union> Vbl\""], ["", "(******************************************************************************)"], ["", "end"]]}