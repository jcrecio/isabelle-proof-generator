{"file_name": "/home/qj213/afp-2021-10-22/thys/DiscretePricing/Option_Price_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DiscretePricing", "problem_names": ["lemma gener_bool_list_elem_length:\n  shows \"\\<And>x. x\\<in> gener_bool_list n \\<Longrightarrow> length x = n\"", "lemma (in infinite_coin_toss_space) stake_gener_bool_list:\n  shows \"stake n`streams (UNIV::bool set) = gener_bool_list n\"", "lemma (in infinite_coin_toss_space) pseudo_range_stake:\n  assumes \"\\<And>w. f w = g (stake n w)\"\n  shows \"(\\<Sum> w\\<in> range (pseudo_proj_True n). f w) = (\\<Sum> y\\<in> (gener_bool_list n). g y)\"", "lemma lprob_comp_last:\n  shows \"lprob_comp p (xs @ [x]) = (lprob_comp p xs) * (if x then p else (1 - p))\"", "lemma (in infinite_coin_toss_space) lprob_comp_stake:\n  shows \"(prod (prob_component pr w) {0..<matur}) = lprob_comp pr (stake matur w)\"", "lemma (in infinite_coin_toss_space) geom_lgeom:\n  shows \"geom_rand_walk u d v n w = lgeom_proc u d v (stake n w)\"", "lemma lgeom_proc_take:\n  assumes \"i \\<le> n\"\n  shows \"lgeom_proc u d init (stake i w) = lgeom_proc u d init (take i (stake n w))\"", "lemma det_discounted:\n  shows \"discounted_value r X n w = (det_discount r n) * (X n w)\"", "lemma (in CRR_market) call_borel:\n  shows \"call_option T K \\<in> borel_measurable (G T)\"", "lemma (in CRR_market_viable) call_option_lgeom:\n  shows \"call_option T K w = max ((lgeom_proc u d init (stake T w)) - K) 0\"", "lemma (in CRR_market_viable) disc_call_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (call_option T K)) T w) = \n    (det_discount r T) * (max ((lgeom_proc u d init (stake T w)) - K) 0)\"", "lemma (in CRR_market_viable) call_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (call_option matur K)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (max ((lgeom_proc u d init (take matur y)) - K) 0))\"", "lemma (in CRR_market_viable) call_price:\n  shows \"fair_price Mkt \n    (call_price u d init r matur K) \n    (call_option matur K) matur\"", "lemma (in CRR_market) put_borel:\n  shows \"put_option T K \\<in> borel_measurable (G T)\"", "lemma (in CRR_market_viable) put_option_lgeom:\n  shows \"put_option T K w = max (K - (lgeom_proc u d init (stake T w))) 0\"", "lemma (in CRR_market_viable) disc_put_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (put_option T K)) T w) = \n    (det_discount r T) * (max (K - (lgeom_proc u d init (stake T w))) 0)\"", "lemma (in CRR_market_viable) put_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (put_option matur K)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (max (K - (lgeom_proc u d init (take matur y))) 0))\"", "lemma (in CRR_market_viable) put_price:\n  shows \"fair_price Mkt \n    (put_price u d init r matur K) \n    (put_option matur K) matur\"", "lemma borel_measurable_Max_finite:\n  fixes f::\"'a \\<Rightarrow> 'b \\<Rightarrow> 'c::{second_countable_topology, linorder_topology}\"\n  assumes \"0 < (n::nat)\"\nshows \"\\<And>A. card A = n \\<Longrightarrow> \\<forall>a \\<in> A. f a \\<in> borel_measurable M \\<Longrightarrow> (\\<lambda>w. Max ((\\<lambda>a. f a w)`A)) \\<in> borel_measurable M\"", "lemma (in CRR_market) lbk_borel:\n  shows \"lbk_option T \\<in> borel_measurable (G T)\"", "lemma (in CRR_market_viable) lbk_option_lgeom:\n  shows \"lbk_option T w = Max ((\\<lambda>i. (lgeom_proc u d init (stake i w)))`{0 .. T}) - (lgeom_proc u d init (stake T w))\"", "lemma (in CRR_market_viable) disc_lbk_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (lbk_option T)) T w) = \n    (det_discount r T) * (Max ((\\<lambda>i. (lgeom_proc u d init (take i (stake T w))))`{0 .. T}) - (lgeom_proc u d init (stake T w)))\"", "lemma (in CRR_market_viable) lbk_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (lbk_option matur)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (Max ((\\<lambda>i. (lgeom_proc u d init (take i y)))`{0 .. matur}) - (lgeom_proc u d init y)))\"", "lemma (in CRR_market_viable) lbk_price:\n  shows \"fair_price Mkt \n    (lbk_price u d init r matur) \n    (lbk_option matur) matur\"", "lemma (in CRR_market) asian_borel:\n  shows \"asian_option T \\<in> borel_measurable (G T)\"", "lemma (in CRR_market_viable) asian_option_lgeom:\n  shows \"asian_option T w = (\\<Sum> i\\<in> {1.. T}. lgeom_proc u d init (stake i w))/ T\"", "lemma (in CRR_market_viable) disc_asian_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (asian_option T)) T w) = \n    (det_discount r T) * (\\<Sum> i\\<in> {1.. T}. lgeom_proc u d init (take i (stake T w)))/ T\"", "lemma (in CRR_market_viable) asian_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (asian_option matur)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (\\<Sum> i\\<in> {1.. matur}. lgeom_proc u d init (take i y))/ matur)\"", "lemma (in CRR_market_viable) asian_price:\n  shows \"fair_price Mkt \n    (asian_price u d init r matur) \n    (asian_option matur) matur\""], "translations": [["", "lemma gener_bool_list_elem_length:\n  shows \"\\<And>x. x\\<in> gener_bool_list n \\<Longrightarrow> length x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> gener_bool_list n \\<Longrightarrow> length x = n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> gener_bool_list 0 \\<Longrightarrow> length x = 0\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "case 0"], ["proof (state)\nthis:\n  x \\<in> gener_bool_list 0\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> gener_bool_list 0 \\<Longrightarrow> length x = 0\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> gener_bool_list 0 \\<Longrightarrow> length x = 0\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "assume \"x\\<in> gener_bool_list 0\""], ["proof (state)\nthis:\n  x \\<in> gener_bool_list 0\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> gener_bool_list 0 \\<Longrightarrow> length x = 0\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "hence \"x = []\""], ["proof (prove)\nusing this:\n  x \\<in> gener_bool_list 0\n\ngoal (1 subgoal):\n 1. x = []", "by simp"], ["proof (state)\nthis:\n  x = []\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> gener_bool_list 0 \\<Longrightarrow> length x = 0\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "thus \"length x = 0\""], ["proof (prove)\nusing this:\n  x = []\n\ngoal (1 subgoal):\n 1. length x = 0", "by simp"], ["proof (state)\nthis:\n  length x = 0\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  ?x \\<in> gener_bool_list n \\<Longrightarrow> length ?x = n\n  x \\<in> gener_bool_list (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "assume \"x\\<in> gener_bool_list (Suc n)\""], ["proof (state)\nthis:\n  x \\<in> gener_bool_list (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "hence mem: \"x\\<in> {True # w| w. w\\<in> gener_bool_list n} \\<union> {False # w| w. w\\<in> gener_bool_list n}\""], ["proof (prove)\nusing this:\n  x \\<in> gener_bool_list (Suc n)\n\ngoal (1 subgoal):\n 1. x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<union>\n            {False # w |w. w \\<in> gener_bool_list n}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<union>\n          {False # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> gener_bool_list n \\<Longrightarrow> length x = n;\n        x \\<in> gener_bool_list (Suc n)\\<rbrakk>\n       \\<Longrightarrow> length x = Suc n", "show \"length x = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x = Suc n", "proof (cases \"x\\<in> {True # w| w. w\\<in> gener_bool_list n}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n\n 2. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "case True"], ["proof (state)\nthis:\n  x \\<in> {True # w |w. w \\<in> gener_bool_list n}\n\ngoal (2 subgoals):\n 1. x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n\n 2. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "hence \"\\<exists>w \\<in> gener_bool_list n. x = True # w\""], ["proof (prove)\nusing this:\n  x \\<in> {True # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>gener_bool_list n. x = True # w", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>gener_bool_list n. x = True # w\n\ngoal (2 subgoals):\n 1. x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n\n 2. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "from this"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>gener_bool_list n. x = True # w", "obtain w where \"w\\<in> gener_bool_list n\" and \"x = True # w\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>gener_bool_list n. x = True # w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> gener_bool_list n; x = True # w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> gener_bool_list n\n  x = True # w\n\ngoal (2 subgoals):\n 1. x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n\n 2. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "hence \"length w = n\""], ["proof (prove)\nusing this:\n  w \\<in> gener_bool_list n\n  x = True # w\n\ngoal (1 subgoal):\n 1. length w = n", "using Suc"], ["proof (prove)\nusing this:\n  w \\<in> gener_bool_list n\n  x = True # w\n  ?x \\<in> gener_bool_list n \\<Longrightarrow> length ?x = n\n  x__ \\<in> gener_bool_list (Suc n)\n\ngoal (1 subgoal):\n 1. length w = n", "by simp"], ["proof (state)\nthis:\n  length w = n\n\ngoal (2 subgoals):\n 1. x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n\n 2. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "thus \"length x = Suc n\""], ["proof (prove)\nusing this:\n  length w = n\n\ngoal (1 subgoal):\n 1. length x = Suc n", "using \\<open>x = True # w\\<close>"], ["proof (prove)\nusing this:\n  length w = n\n  x = True # w\n\ngoal (1 subgoal):\n 1. length x = Suc n", "by simp"], ["proof (state)\nthis:\n  length x = Suc n\n\ngoal (1 subgoal):\n 1. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "case False"], ["proof (state)\nthis:\n  x \\<notin> {True # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "hence \"x\\<in> {False # w| w. w\\<in> gener_bool_list n}\""], ["proof (prove)\nusing this:\n  x \\<notin> {True # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. x \\<in> {False # w |w. w \\<in> gener_bool_list n}", "using mem"], ["proof (prove)\nusing this:\n  x \\<notin> {True # w |w. w \\<in> gener_bool_list n}\n  x \\<in> {True # w |w. w \\<in> gener_bool_list n} \\<union>\n          {False # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. x \\<in> {False # w |w. w \\<in> gener_bool_list n}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {False # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "hence \"\\<exists>w \\<in> gener_bool_list n. x = False # w\""], ["proof (prove)\nusing this:\n  x \\<in> {False # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>gener_bool_list n. x = False # w", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>gener_bool_list n. x = False # w\n\ngoal (1 subgoal):\n 1. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "from this"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>gener_bool_list n. x = False # w", "obtain w where \"w\\<in> gener_bool_list n\" and \"x = False # w\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>gener_bool_list n. x = False # w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> gener_bool_list n; x = False # w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> gener_bool_list n\n  x = False # w\n\ngoal (1 subgoal):\n 1. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "hence \"length w = n\""], ["proof (prove)\nusing this:\n  w \\<in> gener_bool_list n\n  x = False # w\n\ngoal (1 subgoal):\n 1. length w = n", "using Suc"], ["proof (prove)\nusing this:\n  w \\<in> gener_bool_list n\n  x = False # w\n  ?x \\<in> gener_bool_list n \\<Longrightarrow> length ?x = n\n  x__ \\<in> gener_bool_list (Suc n)\n\ngoal (1 subgoal):\n 1. length w = n", "by simp"], ["proof (state)\nthis:\n  length w = n\n\ngoal (1 subgoal):\n 1. x \\<notin> {True # w |w. w \\<in> gener_bool_list n} \\<Longrightarrow>\n    length x = Suc n", "thus \"length x = Suc n\""], ["proof (prove)\nusing this:\n  length w = n\n\ngoal (1 subgoal):\n 1. length x = Suc n", "using \\<open>x = False # w\\<close>"], ["proof (prove)\nusing this:\n  length w = n\n  x = False # w\n\ngoal (1 subgoal):\n 1. length x = Suc n", "by simp"], ["proof (state)\nthis:\n  length x = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length x = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in infinite_coin_toss_space) stake_gener_bool_list:\n  shows \"stake n`streams (UNIV::bool set) = gener_bool_list n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake n ` streams UNIV = gener_bool_list n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. stake 0 ` streams UNIV = gener_bool_list 0\n 2. \\<And>n.\n       stake n ` streams UNIV = gener_bool_list n \\<Longrightarrow>\n       stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. stake 0 ` streams UNIV = gener_bool_list 0\n 2. \\<And>n.\n       stake n ` streams UNIV = gener_bool_list n \\<Longrightarrow>\n       stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "thus \"stake 0 ` streams UNIV = gener_bool_list 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake 0 ` streams UNIV = gener_bool_list 0", "by auto"], ["proof (state)\nthis:\n  stake 0 ` streams UNIV = gener_bool_list 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       stake n ` streams UNIV = gener_bool_list n \\<Longrightarrow>\n       stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       stake n ` streams UNIV = gener_bool_list n \\<Longrightarrow>\n       stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  stake n ` streams UNIV = gener_bool_list n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       stake n ` streams UNIV = gener_bool_list n \\<Longrightarrow>\n       stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "show \"stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "have \"stake (Suc n)`streams (UNIV::bool set) = {s#w| s w. s\\<in> UNIV \\<and> w\\<in> (stake n `(streams UNIV))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV =\n    {s # w |s w. s \\<in> UNIV \\<and> w \\<in> stake n ` streams UNIV}", "by (metis (no_types) UNIV_bool UNIV_not_empty stake_finite_universe_induct[of UNIV n] finite.emptyI finite_insert)"], ["proof (state)\nthis:\n  stake (Suc n) ` streams UNIV =\n  {s # w |s w. s \\<in> UNIV \\<and> w \\<in> stake n ` streams UNIV}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "also"], ["proof (state)\nthis:\n  stake (Suc n) ` streams UNIV =\n  {s # w |s w. s \\<in> UNIV \\<and> w \\<in> stake n ` streams UNIV}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "have \"... = {s#w| s w. s\\<in> {True, False} \\<and> w\\<in> (stake n `(streams UNIV))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s # w |s w. s \\<in> UNIV \\<and> w \\<in> stake n ` streams UNIV} =\n    {s # w |s w.\n     s \\<in> {True, False} \\<and> w \\<in> stake n ` streams UNIV}", "by simp"], ["proof (state)\nthis:\n  {s # w |s w. s \\<in> UNIV \\<and> w \\<in> stake n ` streams UNIV} =\n  {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> stake n ` streams UNIV}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "also"], ["proof (state)\nthis:\n  {s # w |s w. s \\<in> UNIV \\<and> w \\<in> stake n ` streams UNIV} =\n  {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> stake n ` streams UNIV}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "have \"... = {s#w| s w. s\\<in> {True, False} \\<and> w\\<in> gener_bool_list n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s # w |s w.\n     s \\<in> {True, False} \\<and> w \\<in> stake n ` streams UNIV} =\n    {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> gener_bool_list n}", "using Suc"], ["proof (prove)\nusing this:\n  stake n ` streams UNIV = gener_bool_list n\n\ngoal (1 subgoal):\n 1. {s # w |s w.\n     s \\<in> {True, False} \\<and> w \\<in> stake n ` streams UNIV} =\n    {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> gener_bool_list n}", "by simp"], ["proof (state)\nthis:\n  {s # w |s w.\n   s \\<in> {True, False} \\<and> w \\<in> stake n ` streams UNIV} =\n  {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "also"], ["proof (state)\nthis:\n  {s # w |s w.\n   s \\<in> {True, False} \\<and> w \\<in> stake n ` streams UNIV} =\n  {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "have \"... = {s#w| s w. s\\<in> {True} \\<and> w\\<in> gener_bool_list n} \\<union> {s#w| s w. s\\<in> { False} \\<and> w\\<in> gener_bool_list n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> gener_bool_list n} =\n    {s # w |s w. s \\<in> {True} \\<and> w \\<in> gener_bool_list n} \\<union>\n    {s # w |s w. s \\<in> {False} \\<and> w \\<in> gener_bool_list n}", "by auto"], ["proof (state)\nthis:\n  {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> gener_bool_list n} =\n  {s # w |s w. s \\<in> {True} \\<and> w \\<in> gener_bool_list n} \\<union>\n  {s # w |s w. s \\<in> {False} \\<and> w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "also"], ["proof (state)\nthis:\n  {s # w |s w. s \\<in> {True, False} \\<and> w \\<in> gener_bool_list n} =\n  {s # w |s w. s \\<in> {True} \\<and> w \\<in> gener_bool_list n} \\<union>\n  {s # w |s w. s \\<in> {False} \\<and> w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "have \"... = {True # w | w. w\\<in> gener_bool_list n} \\<union> {False#w | w. w\\<in> gener_bool_list n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s # w |s w. s \\<in> {True} \\<and> w \\<in> gener_bool_list n} \\<union>\n    {s # w |s w. s \\<in> {False} \\<and> w \\<in> gener_bool_list n} =\n    {True # w |w. w \\<in> gener_bool_list n} \\<union>\n    {False # w |w. w \\<in> gener_bool_list n}", "by auto"], ["proof (state)\nthis:\n  {s # w |s w. s \\<in> {True} \\<and> w \\<in> gener_bool_list n} \\<union>\n  {s # w |s w. s \\<in> {False} \\<and> w \\<in> gener_bool_list n} =\n  {True # w |w. w \\<in> gener_bool_list n} \\<union>\n  {False # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "also"], ["proof (state)\nthis:\n  {s # w |s w. s \\<in> {True} \\<and> w \\<in> gener_bool_list n} \\<union>\n  {s # w |s w. s \\<in> {False} \\<and> w \\<in> gener_bool_list n} =\n  {True # w |w. w \\<in> gener_bool_list n} \\<union>\n  {False # w |w. w \\<in> gener_bool_list n}\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "have \"... = gener_bool_list (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {True # w |w. w \\<in> gener_bool_list n} \\<union>\n    {False # w |w. w \\<in> gener_bool_list n} =\n    gener_bool_list (Suc n)", "by simp"], ["proof (state)\nthis:\n  {True # w |w. w \\<in> gener_bool_list n} \\<union>\n  {False # w |w. w \\<in> gener_bool_list n} =\n  gener_bool_list (Suc n)\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "finally"], ["proof (chain)\npicking this:\n  stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)\n\ngoal (1 subgoal):\n 1. stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)", "."], ["proof (state)\nthis:\n  stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  stake (Suc n) ` streams UNIV = gener_bool_list (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in infinite_coin_toss_space) pseudo_range_stake:\n  assumes \"\\<And>w. f w = g (stake n w)\"\n  shows \"(\\<Sum> w\\<in> range (pseudo_proj_True n). f w) = (\\<Sum> y\\<in> (gener_bool_list n). g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (range (pseudo_proj_True n)) = sum g (gener_bool_list n)", "proof (rule sum.reindex_cong)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?l (gener_bool_list n)\n 2. range (pseudo_proj_True n) = ?l ` gener_bool_list n\n 3. \\<And>x. x \\<in> gener_bool_list n \\<Longrightarrow> f (?l x) = g x", "show \"inj_on (\\<lambda> l. shift l (sconst True)) (gener_bool_list n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>l. l @- sconst True) (gener_bool_list n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gener_bool_list n; y \\<in> gener_bool_list n;\n        x @- sconst True = y @- sconst True\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gener_bool_list n; y \\<in> gener_bool_list n;\n        x @- sconst True = y @- sconst True\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x\\<in> gener_bool_list n\"\n    and \"y\\<in> gener_bool_list n\"\n    and \"x @- sconst True = y @- sconst True\""], ["proof (state)\nthis:\n  x \\<in> gener_bool_list n\n  y \\<in> gener_bool_list n\n  x @- sconst True = y @- sconst True\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gener_bool_list n; y \\<in> gener_bool_list n;\n        x @- sconst True = y @- sconst True\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"length x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x = n", "using gener_bool_list_elem_length \\<open>x\\<in> gener_bool_list n\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> gener_bool_list ?n \\<Longrightarrow> length ?x = ?n\n  x \\<in> gener_bool_list n\n\ngoal (1 subgoal):\n 1. length x = n", "by simp"], ["proof (state)\nthis:\n  length x = n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gener_bool_list n; y \\<in> gener_bool_list n;\n        x @- sconst True = y @- sconst True\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"length y = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length y = n", "using gener_bool_list_elem_length \\<open>y\\<in> gener_bool_list n\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> gener_bool_list ?n \\<Longrightarrow> length ?x = ?n\n  y \\<in> gener_bool_list n\n\ngoal (1 subgoal):\n 1. length y = n", "by simp"], ["proof (state)\nthis:\n  length y = n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gener_bool_list n; y \\<in> gener_bool_list n;\n        x @- sconst True = y @- sconst True\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"\\<forall> i < n. nth x i = nth y i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. x ! i = y ! i", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x ! i = y ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x ! i = y ! i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x ! i = y ! i", "have xi: \"snth (x @- sconst True) i = nth x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x @- sconst True) !! i = x ! i", "using \\<open>i < n\\<close> \\<open>length x = n\\<close>"], ["proof (prove)\nusing this:\n  i < n\n  length x = n\n\ngoal (1 subgoal):\n 1. (x @- sconst True) !! i = x ! i", "by simp"], ["proof (state)\nthis:\n  (x @- sconst True) !! i = x ! i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x ! i = y ! i", "have yi: \"snth (y @- sconst True) i = nth y i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y @- sconst True) !! i = y ! i", "using \\<open>i < n\\<close> \\<open>length y = n\\<close>"], ["proof (prove)\nusing this:\n  i < n\n  length y = n\n\ngoal (1 subgoal):\n 1. (y @- sconst True) !! i = y ! i", "by simp"], ["proof (state)\nthis:\n  (y @- sconst True) !! i = y ! i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x ! i = y ! i", "have \"snth (x @- sconst True) i = snth (y @- sconst True) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x @- sconst True) !! i = (y @- sconst True) !! i", "using \\<open>x @- sconst True = y @- sconst True\\<close>"], ["proof (prove)\nusing this:\n  x @- sconst True = y @- sconst True\n\ngoal (1 subgoal):\n 1. (x @- sconst True) !! i = (y @- sconst True) !! i", "by simp"], ["proof (state)\nthis:\n  (x @- sconst True) !! i = (y @- sconst True) !! i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x ! i = y ! i", "thus \"nth x i = nth y i\""], ["proof (prove)\nusing this:\n  (x @- sconst True) !! i = (y @- sconst True) !! i\n\ngoal (1 subgoal):\n 1. x ! i = y ! i", "using xi yi"], ["proof (prove)\nusing this:\n  (x @- sconst True) !! i = (y @- sconst True) !! i\n  (x @- sconst True) !! i = x ! i\n  (y @- sconst True) !! i = y ! i\n\ngoal (1 subgoal):\n 1. x ! i = y ! i", "by simp"], ["proof (state)\nthis:\n  x ! i = y ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<n. x ! i = y ! i\n\ngoal (1 subgoal):\n 1. x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<n. x ! i = y ! i\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>length x = n\\<close> \\<open>length y = n\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i<n. x ! i = y ! i\n  length x = n\n  length y = n\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: list_eq_iff_nth_eq)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>l. l @- sconst True) (gener_bool_list n)\n\ngoal (2 subgoals):\n 1. range (pseudo_proj_True n) =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n 2. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "have  \"range (pseudo_proj_True n) = {shift l (sconst True)|l. l\\<in>(stake n `streams (UNIV::bool set))} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (pseudo_proj_True n) =\n    {l @- sconst True |l. l \\<in> stake n ` streams UNIV}", "unfolding pseudo_proj_True_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>w. stake n w @- sconst True) =\n    {l @- sconst True |l. l \\<in> stake n ` streams UNIV}", "by auto"], ["proof (state)\nthis:\n  range (pseudo_proj_True n) =\n  {l @- sconst True |l. l \\<in> stake n ` streams UNIV}\n\ngoal (2 subgoals):\n 1. range (pseudo_proj_True n) =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n 2. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "also"], ["proof (state)\nthis:\n  range (pseudo_proj_True n) =\n  {l @- sconst True |l. l \\<in> stake n ` streams UNIV}\n\ngoal (2 subgoals):\n 1. range (pseudo_proj_True n) =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n 2. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "have \"... = {shift l (sconst True)|l. l\\<in>(gener_bool_list n)} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l @- sconst True |l. l \\<in> stake n ` streams UNIV} =\n    {l @- sconst True |l. l \\<in> gener_bool_list n}", "using stake_gener_bool_list"], ["proof (prove)\nusing this:\n  stake ?n ` streams UNIV = gener_bool_list ?n\n\ngoal (1 subgoal):\n 1. {l @- sconst True |l. l \\<in> stake n ` streams UNIV} =\n    {l @- sconst True |l. l \\<in> gener_bool_list n}", "by simp"], ["proof (state)\nthis:\n  {l @- sconst True |l. l \\<in> stake n ` streams UNIV} =\n  {l @- sconst True |l. l \\<in> gener_bool_list n}\n\ngoal (2 subgoals):\n 1. range (pseudo_proj_True n) =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n 2. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "also"], ["proof (state)\nthis:\n  {l @- sconst True |l. l \\<in> stake n ` streams UNIV} =\n  {l @- sconst True |l. l \\<in> gener_bool_list n}\n\ngoal (2 subgoals):\n 1. range (pseudo_proj_True n) =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n 2. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "have \"... = (\\<lambda>l. l @- sconst True) ` gener_bool_list n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l @- sconst True |l. l \\<in> gener_bool_list n} =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n", "by auto"], ["proof (state)\nthis:\n  {l @- sconst True |l. l \\<in> gener_bool_list n} =\n  (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n\ngoal (2 subgoals):\n 1. range (pseudo_proj_True n) =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n 2. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "finally"], ["proof (chain)\npicking this:\n  range (pseudo_proj_True n) =\n  (\\<lambda>l. l @- sconst True) ` gener_bool_list n", "show \"range (pseudo_proj_True n) = (\\<lambda>l. l @- sconst True) ` gener_bool_list n\""], ["proof (prove)\nusing this:\n  range (pseudo_proj_True n) =\n  (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n\ngoal (1 subgoal):\n 1. range (pseudo_proj_True n) =\n    (\\<lambda>l. l @- sconst True) ` gener_bool_list n", "."], ["proof (state)\nthis:\n  range (pseudo_proj_True n) =\n  (\\<lambda>l. l @- sconst True) ` gener_bool_list n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "assume \"x\\<in> gener_bool_list n\""], ["proof (state)\nthis:\n  x \\<in> gener_bool_list n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "have \"length x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x = n", "using gener_bool_list_elem_length \\<open>x\\<in> gener_bool_list n\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> gener_bool_list ?n \\<Longrightarrow> length ?x = ?n\n  x \\<in> gener_bool_list n\n\ngoal (1 subgoal):\n 1. length x = n", "by simp"], ["proof (state)\nthis:\n  length x = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "have \"f (x @- sconst True) = g (stake n (x @- sconst True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x @- sconst True) = g (stake n (x @- sconst True))", "using assms"], ["proof (prove)\nusing this:\n  f ?w1 = g (stake n ?w1)\n\ngoal (1 subgoal):\n 1. f (x @- sconst True) = g (stake n (x @- sconst True))", "by simp"], ["proof (state)\nthis:\n  f (x @- sconst True) = g (stake n (x @- sconst True))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "also"], ["proof (state)\nthis:\n  f (x @- sconst True) = g (stake n (x @- sconst True))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "have \"... = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (stake n (x @- sconst True)) = g x", "using \\<open>length x = n\\<close>"], ["proof (prove)\nusing this:\n  length x = n\n\ngoal (1 subgoal):\n 1. g (stake n (x @- sconst True)) = g x", "by (simp add: stake_shift)"], ["proof (state)\nthis:\n  g (stake n (x @- sconst True)) = g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gener_bool_list n \\<Longrightarrow>\n       f (x @- sconst True) = g x", "finally"], ["proof (chain)\npicking this:\n  f (x @- sconst True) = g x", "show \"f (x @- sconst True) = g x\""], ["proof (prove)\nusing this:\n  f (x @- sconst True) = g x\n\ngoal (1 subgoal):\n 1. f (x @- sconst True) = g x", "."], ["proof (state)\nthis:\n  f (x @- sconst True) = g x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Probability components for lists \\<close>"], ["", "fun lprob_comp where\n\"lprob_comp (p::real) [] = 1\"\n| \"lprob_comp p (x # xs) = (if x then p else (1-p)) * lprob_comp p xs\""], ["", "lemma lprob_comp_last:\n  shows \"lprob_comp p (xs @ [x]) = (lprob_comp p xs) * (if x then p else (1 - p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp p (xs @ [x]) = lprob_comp p xs * (if x then p else 1 - p)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n 2. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n 2. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "have \"lprob_comp p (Nil @ [x]) = lprob_comp p [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [x]", "by simp"], ["proof (state)\nthis:\n  lprob_comp p ([] @ [x]) = lprob_comp p [x]\n\ngoal (2 subgoals):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n 2. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "also"], ["proof (state)\nthis:\n  lprob_comp p ([] @ [x]) = lprob_comp p [x]\n\ngoal (2 subgoals):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n 2. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "have \"... = (if x then p else (1 - p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp p [x] = (if x then p else 1 - p)", "by simp"], ["proof (state)\nthis:\n  lprob_comp p [x] = (if x then p else 1 - p)\n\ngoal (2 subgoals):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n 2. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "also"], ["proof (state)\nthis:\n  lprob_comp p [x] = (if x then p else 1 - p)\n\ngoal (2 subgoals):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n 2. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "have \"... = (lprob_comp p Nil) * (if x then p else (1 - p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x then p else 1 - p) = lprob_comp p [] * (if x then p else 1 - p)", "by simp"], ["proof (state)\nthis:\n  (if x then p else 1 - p) = lprob_comp p [] * (if x then p else 1 - p)\n\ngoal (2 subgoals):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n 2. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "finally"], ["proof (chain)\npicking this:\n  lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)", "show \"lprob_comp p (Nil @ [x]) = (lprob_comp p Nil) * (if x then p else (1 - p))\""], ["proof (prove)\nusing this:\n  lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)", "."], ["proof (state)\nthis:\n  lprob_comp p ([] @ [x]) = lprob_comp p [] * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "case (Cons a xs)"], ["proof (state)\nthis:\n  lprob_comp p (xs @ [x]) = lprob_comp p xs * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "have \"lprob_comp p ((Cons a xs) @ [x]) = (if a then p else (1 - p)) * lprob_comp p (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp p ((a # xs) @ [x]) =\n    (if a then p else 1 - p) * lprob_comp p (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  lprob_comp p ((a # xs) @ [x]) =\n  (if a then p else 1 - p) * lprob_comp p (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "also"], ["proof (state)\nthis:\n  lprob_comp p ((a # xs) @ [x]) =\n  (if a then p else 1 - p) * lprob_comp p (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "have \"... = (if a then p else (1 - p)) * (lprob_comp p xs) * (if x then p else (1-p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a then p else 1 - p) * lprob_comp p (xs @ [x]) =\n    (if a then p else 1 - p) * lprob_comp p xs * (if x then p else 1 - p)", "using Cons"], ["proof (prove)\nusing this:\n  lprob_comp p (xs @ [x]) = lprob_comp p xs * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. (if a then p else 1 - p) * lprob_comp p (xs @ [x]) =\n    (if a then p else 1 - p) * lprob_comp p xs * (if x then p else 1 - p)", "by simp"], ["proof (state)\nthis:\n  (if a then p else 1 - p) * lprob_comp p (xs @ [x]) =\n  (if a then p else 1 - p) * lprob_comp p xs * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "also"], ["proof (state)\nthis:\n  (if a then p else 1 - p) * lprob_comp p (xs @ [x]) =\n  (if a then p else 1 - p) * lprob_comp p xs * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "have \"... = lprob_comp p (Cons a xs) * (if x then p else (1-p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a then p else 1 - p) * lprob_comp p xs * (if x then p else 1 - p) =\n    lprob_comp p (a # xs) * (if x then p else 1 - p)", "by simp"], ["proof (state)\nthis:\n  (if a then p else 1 - p) * lprob_comp p xs * (if x then p else 1 - p) =\n  lprob_comp p (a # xs) * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lprob_comp p (xs @ [x]) =\n       lprob_comp p xs * (if x then p else 1 - p) \\<Longrightarrow>\n       lprob_comp p ((a # xs) @ [x]) =\n       lprob_comp p (a # xs) * (if x then p else 1 - p)", "finally"], ["proof (chain)\npicking this:\n  lprob_comp p ((a # xs) @ [x]) =\n  lprob_comp p (a # xs) * (if x then p else 1 - p)", "show \"lprob_comp p ((Cons a xs) @ [x]) = lprob_comp p (Cons a xs) * (if x then p else (1-p))\""], ["proof (prove)\nusing this:\n  lprob_comp p ((a # xs) @ [x]) =\n  lprob_comp p (a # xs) * (if x then p else 1 - p)\n\ngoal (1 subgoal):\n 1. lprob_comp p ((a # xs) @ [x]) =\n    lprob_comp p (a # xs) * (if x then p else 1 - p)", "."], ["proof (state)\nthis:\n  lprob_comp p ((a # xs) @ [x]) =\n  lprob_comp p (a # xs) * (if x then p else 1 - p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in infinite_coin_toss_space) lprob_comp_stake:\n  shows \"(prod (prob_component pr w) {0..<matur}) = lprob_comp pr (stake matur w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} = lprob_comp pr (stake matur w)", "proof (induction matur)"], ["proof (state)\ngoal (2 subgoals):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n 2. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n 2. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"prod (prob_component pr w) {0..<0} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<0} = 1", "by simp"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<0} = 1\n\ngoal (2 subgoals):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n 2. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "also"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<0} = 1\n\ngoal (2 subgoals):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n 2. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"... = lprob_comp pr []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = lprob_comp pr []", "by simp"], ["proof (state)\nthis:\n  1 = lprob_comp pr []\n\ngoal (2 subgoals):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n 2. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "also"], ["proof (state)\nthis:\n  1 = lprob_comp pr []\n\ngoal (2 subgoals):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n 2. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"... = lprob_comp pr (stake 0 w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr [] = lprob_comp pr (stake 0 w)", "by simp"], ["proof (state)\nthis:\n  lprob_comp pr [] = lprob_comp pr (stake 0 w)\n\ngoal (2 subgoals):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n 2. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "finally"], ["proof (chain)\npicking this:\n  prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)", "show \"prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\""], ["proof (prove)\nusing this:\n  prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)", "."], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<0} = lprob_comp pr (stake 0 w)\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "case (Suc n)"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<n} = lprob_comp pr (stake n w)\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"prod (prob_component pr w) {0..<Suc n} = prod (prob_component pr w) {0..< n} *\n    (prob_component pr w n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<Suc n} =\n    prod (prob_component pr w) {0..<n} * prob_component pr w n", "using prod.atLeast0_lessThan_Suc"], ["proof (prove)\nusing this:\n  prod ?g {0..<Suc ?n} = prod ?g {0..<?n} * ?g ?n\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<Suc n} =\n    prod (prob_component pr w) {0..<n} * prob_component pr w n", "by blast"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<Suc n} =\n  prod (prob_component pr w) {0..<n} * prob_component pr w n\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "also"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<Suc n} =\n  prod (prob_component pr w) {0..<n} * prob_component pr w n\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"... = lprob_comp pr (stake n w) * (prob_component pr w n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<n} * prob_component pr w n =\n    lprob_comp pr (stake n w) * prob_component pr w n", "using Suc"], ["proof (prove)\nusing this:\n  prod (prob_component pr w) {0..<n} = lprob_comp pr (stake n w)\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<n} * prob_component pr w n =\n    lprob_comp pr (stake n w) * prob_component pr w n", "by simp"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<n} * prob_component pr w n =\n  lprob_comp pr (stake n w) * prob_component pr w n\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "also"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<n} * prob_component pr w n =\n  lprob_comp pr (stake n w) * prob_component pr w n\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"... = lprob_comp pr (stake n w) * (if (snth w n) then pr else 1-pr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr (stake n w) * prob_component pr w n =\n    lprob_comp pr (stake n w) * (if w !! n then pr else 1 - pr)", "by (simp add: prob_component_def)"], ["proof (state)\nthis:\n  lprob_comp pr (stake n w) * prob_component pr w n =\n  lprob_comp pr (stake n w) * (if w !! n then pr else 1 - pr)\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "also"], ["proof (state)\nthis:\n  lprob_comp pr (stake n w) * prob_component pr w n =\n  lprob_comp pr (stake n w) * (if w !! n then pr else 1 - pr)\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"... = lprob_comp pr ((stake n w) @ [snth w n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr (stake n w) * (if w !! n then pr else 1 - pr) =\n    lprob_comp pr (stake n w @ [w !! n])", "by (simp add: lprob_comp_last)"], ["proof (state)\nthis:\n  lprob_comp pr (stake n w) * (if w !! n then pr else 1 - pr) =\n  lprob_comp pr (stake n w @ [w !! n])\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "also"], ["proof (state)\nthis:\n  lprob_comp pr (stake n w) * (if w !! n then pr else 1 - pr) =\n  lprob_comp pr (stake n w @ [w !! n])\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "have \"... = lprob_comp pr (stake (Suc n) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr (stake n w @ [w !! n]) = lprob_comp pr (stake (Suc n) w)", "by (metis Stream.stake_Suc)"], ["proof (state)\nthis:\n  lprob_comp pr (stake n w @ [w !! n]) = lprob_comp pr (stake (Suc n) w)\n\ngoal (1 subgoal):\n 1. \\<And>matur.\n       prod (prob_component pr w) {0..<matur} =\n       lprob_comp pr (stake matur w) \\<Longrightarrow>\n       prod (prob_component pr w) {0..<Suc matur} =\n       lprob_comp pr (stake (Suc matur) w)", "finally"], ["proof (chain)\npicking this:\n  prod (prob_component pr w) {0..<Suc n} = lprob_comp pr (stake (Suc n) w)", "show \"prod (prob_component pr w) {0..<Suc n} = lprob_comp pr (stake (Suc n) w)\""], ["proof (prove)\nusing this:\n  prod (prob_component pr w) {0..<Suc n} = lprob_comp pr (stake (Suc n) w)\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<Suc n} = lprob_comp pr (stake (Suc n) w)", "."], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<Suc n} = lprob_comp pr (stake (Suc n) w)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Geometric process applied to lists \\<close>"], ["", "fun lrev_geom where\n\"lrev_geom u d v [] = v\"\n| \"lrev_geom u d v (x#xs) = (if x then u else d) * lrev_geom u d v xs\""], ["", "fun lgeom_proc where \"lgeom_proc u d v l = lrev_geom u d v (rev l)\""], ["", "lemma (in infinite_coin_toss_space) geom_lgeom:\n  shows \"geom_rand_walk u d v n w = lgeom_proc u d v (stake n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geom_rand_walk u d v n w = lgeom_proc u d v (stake n w)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"geom_rand_walk u d v 0 w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geom_rand_walk u d v 0 w = v", "by simp"], ["proof (state)\nthis:\n  geom_rand_walk u d v 0 w = v\n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  geom_rand_walk u d v 0 w = v\n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lrev_geom u d v []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = lrev_geom u d v []", "by simp"], ["proof (state)\nthis:\n  v = lrev_geom u d v []\n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  v = lrev_geom u d v []\n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lrev_geom u d v (rev (stake 0 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_geom u d v [] = lrev_geom u d v (rev (stake 0 w))", "by simp"], ["proof (state)\nthis:\n  lrev_geom u d v [] = lrev_geom u d v (rev (stake 0 w))\n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  lrev_geom u d v [] = lrev_geom u d v (rev (stake 0 w))\n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lgeom_proc u d v (stake 0 w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_geom u d v (rev (stake 0 w)) = lgeom_proc u d v (stake 0 w)", "by simp"], ["proof (state)\nthis:\n  lrev_geom u d v (rev (stake 0 w)) = lgeom_proc u d v (stake 0 w)\n\ngoal (2 subgoals):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n 2. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "finally"], ["proof (chain)\npicking this:\n  geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)", "show \"geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\""], ["proof (prove)\nusing this:\n  geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n\ngoal (1 subgoal):\n 1. geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)", "."], ["proof (state)\nthis:\n  geom_rand_walk u d v 0 w = lgeom_proc u d v (stake 0 w)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "case (Suc n)"], ["proof (state)\nthis:\n  geom_rand_walk u d v n w = lgeom_proc u d v (stake n w)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"snth w n = nth (stake (Suc n) w) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w !! n = stake (Suc n) w ! n", "using stake_nth"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> stake ?n ?s ! ?m = ?s !! ?m\n\ngoal (1 subgoal):\n 1. w !! n = stake (Suc n) w ! n", "by blast"], ["proof (state)\nthis:\n  w !! n = stake (Suc n) w ! n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"(stake n w) @ [nth (stake (Suc n) w) n] = stake (Suc n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake n w @ [stake (Suc n) w ! n] = stake (Suc n) w", "by (metis Stream.stake_Suc lessI stake_nth)"], ["proof (state)\nthis:\n  stake n w @ [stake (Suc n) w ! n] = stake (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"geom_rand_walk u d v (Suc n) w = ((\\<lambda>True \\<Rightarrow> u | False \\<Rightarrow> d) (snth w n)) * geom_rand_walk u d v n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geom_rand_walk u d v (Suc n) w =\n    (case w !! n of True \\<Rightarrow> u | False \\<Rightarrow> d) *\n    geom_rand_walk u d v n w", "by simp"], ["proof (state)\nthis:\n  geom_rand_walk u d v (Suc n) w =\n  (case w !! n of True \\<Rightarrow> u | False \\<Rightarrow> d) *\n  geom_rand_walk u d v n w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  geom_rand_walk u d v (Suc n) w =\n  (case w !! n of True \\<Rightarrow> u | False \\<Rightarrow> d) *\n  geom_rand_walk u d v n w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = (if (snth w n) then u else d) * geom_rand_walk u d v n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case w !! n of True \\<Rightarrow> u | False \\<Rightarrow> d) *\n    geom_rand_walk u d v n w =\n    (if w !! n then u else d) * geom_rand_walk u d v n w", "by simp"], ["proof (state)\nthis:\n  (case w !! n of True \\<Rightarrow> u | False \\<Rightarrow> d) *\n  geom_rand_walk u d v n w =\n  (if w !! n then u else d) * geom_rand_walk u d v n w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  (case w !! n of True \\<Rightarrow> u | False \\<Rightarrow> d) *\n  geom_rand_walk u d v n w =\n  (if w !! n then u else d) * geom_rand_walk u d v n w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = (if (snth w n) then u else d) * lgeom_proc u d v (stake n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if w !! n then u else d) * geom_rand_walk u d v n w =\n    (if w !! n then u else d) * lgeom_proc u d v (stake n w)", "using Suc"], ["proof (prove)\nusing this:\n  geom_rand_walk u d v n w = lgeom_proc u d v (stake n w)\n\ngoal (1 subgoal):\n 1. (if w !! n then u else d) * geom_rand_walk u d v n w =\n    (if w !! n then u else d) * lgeom_proc u d v (stake n w)", "by simp"], ["proof (state)\nthis:\n  (if w !! n then u else d) * geom_rand_walk u d v n w =\n  (if w !! n then u else d) * lgeom_proc u d v (stake n w)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  (if w !! n then u else d) * geom_rand_walk u d v n w =\n  (if w !! n then u else d) * lgeom_proc u d v (stake n w)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = (if (snth w n) then u else d) * lrev_geom u d v (rev (stake n w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if w !! n then u else d) * lgeom_proc u d v (stake n w) =\n    (if w !! n then u else d) * lrev_geom u d v (rev (stake n w))", "by simp"], ["proof (state)\nthis:\n  (if w !! n then u else d) * lgeom_proc u d v (stake n w) =\n  (if w !! n then u else d) * lrev_geom u d v (rev (stake n w))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  (if w !! n then u else d) * lgeom_proc u d v (stake n w) =\n  (if w !! n then u else d) * lrev_geom u d v (rev (stake n w))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lrev_geom u d v ((snth w n) # (rev (stake n w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if w !! n then u else d) * lrev_geom u d v (rev (stake n w)) =\n    lrev_geom u d v (w !! n # rev (stake n w))", "by simp"], ["proof (state)\nthis:\n  (if w !! n then u else d) * lrev_geom u d v (rev (stake n w)) =\n  lrev_geom u d v (w !! n # rev (stake n w))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  (if w !! n then u else d) * lrev_geom u d v (rev (stake n w)) =\n  lrev_geom u d v (w !! n # rev (stake n w))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lrev_geom u d v (rev ((stake n w) @ [snth w n]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_geom u d v (w !! n # rev (stake n w)) =\n    lrev_geom u d v (rev (stake n w @ [w !! n]))", "by simp"], ["proof (state)\nthis:\n  lrev_geom u d v (w !! n # rev (stake n w)) =\n  lrev_geom u d v (rev (stake n w @ [w !! n]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  lrev_geom u d v (w !! n # rev (stake n w)) =\n  lrev_geom u d v (rev (stake n w @ [w !! n]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lrev_geom u d v (rev ((stake n w) @ [nth (stake (Suc n) w) n]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_geom u d v (rev (stake n w @ [w !! n])) =\n    lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n]))", "using \\<open>snth w n = nth (stake (Suc n) w) n\\<close>"], ["proof (prove)\nusing this:\n  w !! n = stake (Suc n) w ! n\n\ngoal (1 subgoal):\n 1. lrev_geom u d v (rev (stake n w @ [w !! n])) =\n    lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n]))", "by simp"], ["proof (state)\nthis:\n  lrev_geom u d v (rev (stake n w @ [w !! n])) =\n  lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  lrev_geom u d v (rev (stake n w @ [w !! n])) =\n  lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lrev_geom u d v (rev (stake (Suc n) w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n])) =\n    lrev_geom u d v (rev (stake (Suc n) w))", "using \\<open>(stake n w) @ [nth (stake (Suc n) w) n] = stake (Suc n) w\\<close>"], ["proof (prove)\nusing this:\n  stake n w @ [stake (Suc n) w ! n] = stake (Suc n) w\n\ngoal (1 subgoal):\n 1. lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n])) =\n    lrev_geom u d v (rev (stake (Suc n) w))", "by simp"], ["proof (state)\nthis:\n  lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n])) =\n  lrev_geom u d v (rev (stake (Suc n) w))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "also"], ["proof (state)\nthis:\n  lrev_geom u d v (rev (stake n w @ [stake (Suc n) w ! n])) =\n  lrev_geom u d v (rev (stake (Suc n) w))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "have \"... = lgeom_proc u d v (stake (Suc n) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lrev_geom u d v (rev (stake (Suc n) w)) =\n    lgeom_proc u d v (stake (Suc n) w)", "by simp"], ["proof (state)\nthis:\n  lrev_geom u d v (rev (stake (Suc n) w)) =\n  lgeom_proc u d v (stake (Suc n) w)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       geom_rand_walk u d v n w =\n       lgeom_proc u d v (stake n w) \\<Longrightarrow>\n       geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "finally"], ["proof (chain)\npicking this:\n  geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "show \"geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)\""], ["proof (prove)\nusing this:\n  geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)\n\ngoal (1 subgoal):\n 1. geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)", "."], ["proof (state)\nthis:\n  geom_rand_walk u d v (Suc n) w = lgeom_proc u d v (stake (Suc n) w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lgeom_proc_take:\n  assumes \"i \\<le> n\"\n  shows \"lgeom_proc u d init (stake i w) = lgeom_proc u d init (take i (stake n w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lgeom_proc u d init (stake i w) =\n    lgeom_proc u d init (take i (stake n w))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lgeom_proc u d init (stake i w) =\n    lgeom_proc u d init (take i (stake n w))", "have \"stake i w = take i (stake n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake i w = take i (stake n w)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. stake i w = take i (stake n w)", "by (simp add: min.absorb1 take_stake)"], ["proof (state)\nthis:\n  stake i w = take i (stake n w)\n\ngoal (1 subgoal):\n 1. lgeom_proc u d init (stake i w) =\n    lgeom_proc u d init (take i (stake n w))", "thus ?thesis"], ["proof (prove)\nusing this:\n  stake i w = take i (stake n w)\n\ngoal (1 subgoal):\n 1. lgeom_proc u d init (stake i w) =\n    lgeom_proc u d init (take i (stake n w))", "by simp"], ["proof (state)\nthis:\n  lgeom_proc u d init (stake i w) = lgeom_proc u d init (take i (stake n w))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Effective computation of discounted values \\<close>"], ["", "fun det_discount where\n\"det_discount (r::real) 0 = 1\"\n| \"det_discount r (Suc n) = (inverse (1+r)) * (det_discount r n)\""], ["", "lemma det_discounted:\n  shows \"discounted_value r X n w = (det_discount r n) * (X n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discounted_value r X n w = det_discount r n * X n w", "unfolding discounted_value_def discount_factor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (disc_rfr_proc r n w) * X n w = det_discount r n * X n w", "proof (induction n arbitrary: X)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w\n 2. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>X.\n       inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w\n 2. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "have \"inverse (disc_rfr_proc r 0 w) * X 0 w =  X 0 w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (disc_rfr_proc r 0 w) * X 0 w = X 0 w", "by simp"], ["proof (state)\nthis:\n  inverse (disc_rfr_proc r 0 w) * X 0 w = X 0 w\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w\n 2. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "also"], ["proof (state)\nthis:\n  inverse (disc_rfr_proc r 0 w) * X 0 w = X 0 w\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w\n 2. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "have \"... = (det_discount r 0) * (X 0 w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X 0 w = det_discount r 0 * X 0 w", "by simp"], ["proof (state)\nthis:\n  X 0 w = det_discount r 0 * X 0 w\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w\n 2. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "finally"], ["proof (chain)\npicking this:\n  inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w", "show \"inverse (disc_rfr_proc r 0 w) * X 0 w = (det_discount r 0) * (X 0 w)\""], ["proof (prove)\nusing this:\n  inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w\n\ngoal (1 subgoal):\n 1. inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w", "."], ["proof (state)\nthis:\n  inverse (disc_rfr_proc r 0 w) * X 0 w = det_discount r 0 * X 0 w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "case (Suc n)"], ["proof (state)\nthis:\n  inverse (disc_rfr_proc r n w) * ?X n w = det_discount r n * ?X n w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "have \"inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w = \n    inverse ((1+r) * (disc_rfr_proc r) n w) * X (Suc n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n    inverse ((1 + r) * disc_rfr_proc r n w) * X (Suc n) w", "by simp"], ["proof (state)\nthis:\n  inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n  inverse ((1 + r) * disc_rfr_proc r n w) * X (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "also"], ["proof (state)\nthis:\n  inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n  inverse ((1 + r) * disc_rfr_proc r n w) * X (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "have \"... = (inverse (1+r)) * inverse ((disc_rfr_proc r) n w) * X (Suc n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse ((1 + r) * disc_rfr_proc r n w) * X (Suc n) w =\n    inverse (1 + r) * inverse (disc_rfr_proc r n w) * X (Suc n) w", "by simp"], ["proof (state)\nthis:\n  inverse ((1 + r) * disc_rfr_proc r n w) * X (Suc n) w =\n  inverse (1 + r) * inverse (disc_rfr_proc r n w) * X (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "also"], ["proof (state)\nthis:\n  inverse ((1 + r) * disc_rfr_proc r n w) * X (Suc n) w =\n  inverse (1 + r) * inverse (disc_rfr_proc r n w) * X (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "have \"... = (inverse (1+r)) * (det_discount r n) * X (Suc n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (1 + r) * inverse (disc_rfr_proc r n w) * X (Suc n) w =\n    inverse (1 + r) * det_discount r n * X (Suc n) w", "using Suc[of \"\\<lambda>n. X (Suc n)\"]"], ["proof (prove)\nusing this:\n  inverse (disc_rfr_proc r n w) * X (Suc n) w =\n  det_discount r n * X (Suc n) w\n\ngoal (1 subgoal):\n 1. inverse (1 + r) * inverse (disc_rfr_proc r n w) * X (Suc n) w =\n    inverse (1 + r) * det_discount r n * X (Suc n) w", "by auto"], ["proof (state)\nthis:\n  inverse (1 + r) * inverse (disc_rfr_proc r n w) * X (Suc n) w =\n  inverse (1 + r) * det_discount r n * X (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "also"], ["proof (state)\nthis:\n  inverse (1 + r) * inverse (disc_rfr_proc r n w) * X (Suc n) w =\n  inverse (1 + r) * det_discount r n * X (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "have \"... = (det_discount r (Suc n)) * X (Suc n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (1 + r) * det_discount r n * X (Suc n) w =\n    det_discount r (Suc n) * X (Suc n) w", "by simp"], ["proof (state)\nthis:\n  inverse (1 + r) * det_discount r n * X (Suc n) w =\n  det_discount r (Suc n) * X (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n X.\n       (\\<And>X.\n           inverse (disc_rfr_proc r n w) * X n w =\n           det_discount r n * X n w) \\<Longrightarrow>\n       inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n       det_discount r (Suc n) * X (Suc n) w", "finally"], ["proof (chain)\npicking this:\n  inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n  det_discount r (Suc n) * X (Suc n) w", "show \"inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w = (det_discount r (Suc n)) * X (Suc n) w\""], ["proof (prove)\nusing this:\n  inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n  det_discount r (Suc n) * X (Suc n) w\n\ngoal (1 subgoal):\n 1. inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n    det_discount r (Suc n) * X (Suc n) w", "."], ["proof (state)\nthis:\n  inverse (disc_rfr_proc r (Suc n) w) * X (Suc n) w =\n  det_discount r (Suc n) * X (Suc n) w\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Pricing results on options \\<close>"], ["", "subsection \\<open> Call option \\<close>"], ["", "text \\<open> A call option is parameterized by a strike K and maturity T. If S denotes the price of the (unique) risky asset at \ntime T, then the option pays max(S - K, 0) at that time.\\<close>"], ["", "definition (in CRR_market) call_option where\n\"call_option (T::nat) (K::real) = (\\<lambda> w. max (prices Mkt stk T w - K) 0)\""], ["", "lemma (in CRR_market) call_borel:\n  shows \"call_option T K \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. call_option T K \\<in> borel_measurable (G T)", "unfolding call_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w. max (prices Mkt stk T w - K) 0)\n    \\<in> borel_measurable (G T)", "proof (rule borel_measurable_max)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. 0) \\<in> borel_measurable (G T)\n 2. (\\<lambda>x. prices Mkt stk T x - K) \\<in> borel_measurable (G T)", "show \"(\\<lambda>x. 0) \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 0::'b) \\<in> borel_measurable (G T)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. 0::?'b2) \\<in> borel_measurable (G T)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. prices Mkt stk T x - K) \\<in> borel_measurable (G T)", "show \"(\\<lambda>x. prices Mkt stk T x - K) \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. prices Mkt stk T x - K) \\<in> borel_measurable (G T)", "proof (rule borel_measurable_diff)"], ["proof (state)\ngoal (2 subgoals):\n 1. prices Mkt stk T \\<in> borel_measurable (G T)\n 2. (\\<lambda>x. K) \\<in> borel_measurable (G T)", "show \"prices Mkt stk T \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prices Mkt stk T \\<in> borel_measurable (G T)", "by (metis  adapt_stoch_proc_def stock_price_borel_measurable)"], ["proof (state)\nthis:\n  prices Mkt stk T \\<in> borel_measurable (G T)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. K) \\<in> borel_measurable (G T)", "qed simp"], ["proof (state)\nthis:\n  (\\<lambda>x. prices Mkt stk T x - K) \\<in> borel_measurable (G T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in CRR_market_viable) call_option_lgeom:\n  shows \"call_option T K w = max ((lgeom_proc u d init (stake T w)) - K) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. call_option T K w = max (lgeom_proc u d init (stake T w) - K) 0", "using geom_lgeom stk_price geometric_process"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. call_option T K w = max (lgeom_proc u d init (stake T w) - K) 0", "unfolding call_option_def"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. max (prices Mkt stk T w - K) 0 =\n    max (lgeom_proc u d init (stake T w) - K) 0", "by simp"], ["", "lemma (in CRR_market_viable) disc_call_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (call_option T K)) T w) = \n    (det_discount r T) * (max ((lgeom_proc u d init (stake T w)) - K) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. call_option T K) T w =\n    det_discount r T * max (lgeom_proc u d init (stake T w) - K) 0", "using det_discounted[of r \"\\<lambda>m. call_option T K\" T w] call_option_lgeom[of T K w]"], ["proof (prove)\nusing this:\n  discounted_value r (\\<lambda>m. call_option T K) T w =\n  det_discount r T * call_option T K w\n  call_option T K w = max (lgeom_proc u d init (stake T w) - K) 0\n\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. call_option T K) T w =\n    det_discount r T * max (lgeom_proc u d init (stake T w) - K) 0", "by simp"], ["", "lemma (in CRR_market_viable) call_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (call_option matur K)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (max ((lgeom_proc u d init (take matur y)) - K) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. call_option matur K) matur w) =\n    (\\<Sum>y\\<in>gener_bool_list matur.\n       lprob_comp pr y * det_discount r matur *\n       max (lgeom_proc u d init (take matur y) - K) 0)", "proof (rule pseudo_range_stake)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. call_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. call_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "have \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. call_option matur K) matur w =\n    lprob_comp pr (stake matur w) * discounted_value r (\\<lambda>m. call_option matur K) matur w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. call_option matur K) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. call_option matur K) matur w", "using lprob_comp_stake"], ["proof (prove)\nusing this:\n  prod (prob_component ?pr ?w) {0..<?matur} =\n  lprob_comp ?pr (stake ?matur ?w)\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. call_option matur K) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. call_option matur K) matur w", "by simp"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. call_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "also"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. call_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "have \"... = lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (max ((lgeom_proc u d init (take matur (stake matur w))) - K) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. call_option matur K) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "using disc_call_option_lgeom[of matur K]"], ["proof (prove)\nusing this:\n  discounted_value r (\\<lambda>m. call_option matur K) matur ?w =\n  det_discount r matur * max (lgeom_proc u d init (stake matur ?w) - K) 0\n\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. call_option matur K) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "by simp"], ["proof (state)\nthis:\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (lgeom_proc u d init (take matur (stake matur w)) - K) 0\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. call_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "finally"], ["proof (chain)\npicking this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "show \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. call_option matur K) matur w =\n    lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (max ((lgeom_proc u d init (take matur (stake matur w))) - K) 0)\""], ["proof (prove)\nusing this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (lgeom_proc u d init (take matur (stake matur w)) - K) 0\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. call_option matur K) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    max (lgeom_proc u d init (take matur (stake matur w)) - K) 0", "."], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. call_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (lgeom_proc u d init (take matur (stake matur w)) - K) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "fun call_price where\n\"call_price u d init r matur K = (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp ((1 + r - d) / (u - d)) y * (det_discount r matur) * \n      (max ((lgeom_proc u d init (take matur (take matur y))) - K) 0))\""], ["", "text \\<open> Evaluating the function above returns the fair price of a call option. \\<close>"], ["", "lemma (in CRR_market_viable) call_price:\n  shows \"fair_price Mkt \n    (call_price u d init r matur K) \n    (call_option matur K) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt (call_price u d init r matur K) (call_option matur K)\n     matur", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fair_price Mkt (call_price u d init r matur K) (call_option matur K)\n     matur", "have \"fair_price Mkt \n    (\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (call_option matur K)) matur w)) \n    (call_option matur K) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt\n     (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n        prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n        discounted_value r (\\<lambda>m. call_option matur K) matur w)\n     (call_option matur K) matur", "by (rule CRR_market_fair_price, rule call_borel)"], ["proof (state)\nthis:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. call_option matur K) matur w)\n   (call_option matur K) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (call_price u d init r matur K) (call_option matur K)\n     matur", "thus ?thesis"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. call_option matur K) matur w)\n   (call_option matur K) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (call_price u d init r matur K) (call_option matur K)\n     matur", "using call_effect_compute"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. call_option matur K) matur w)\n   (call_option matur K) matur\n  (\\<Sum>w\\<in>range (pseudo_proj_True ?matur).\n     prod (prob_component ?pr w) {0..<?matur} *\n     discounted_value r (\\<lambda>m. call_option ?matur ?K) ?matur w) =\n  (\\<Sum>y\\<in>gener_bool_list ?matur.\n     lprob_comp ?pr y * det_discount r ?matur *\n     max (lgeom_proc u d init (take ?matur y) - ?K) 0)\n\ngoal (1 subgoal):\n 1. fair_price Mkt (call_price u d init r matur K) (call_option matur K)\n     matur", "by simp"], ["proof (state)\nthis:\n  fair_price Mkt (call_price u d init r matur K) (call_option matur K) matur\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Put option \\<close>"], ["", "text \\<open> A put option is also parameterized by a strike K and maturity T. If S denotes the price of the (unique) risky asset at \ntime T, then the option pays max(K - S, 0) at that time. \\<close>"], ["", "definition (in CRR_market) put_option where\n\"put_option (T::nat) (K::real) = (\\<lambda> w. max (K - prices Mkt stk T w) 0)\""], ["", "lemma (in CRR_market) put_borel:\n  shows \"put_option T K \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put_option T K \\<in> borel_measurable (G T)", "unfolding put_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w. max (K - prices Mkt stk T w) 0)\n    \\<in> borel_measurable (G T)", "proof (rule borel_measurable_max)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. 0) \\<in> borel_measurable (G T)\n 2. (\\<lambda>x. K - prices Mkt stk T x) \\<in> borel_measurable (G T)", "show \"(\\<lambda>x. 0) \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 0::'b) \\<in> borel_measurable (G T)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. 0::?'b2) \\<in> borel_measurable (G T)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. K - prices Mkt stk T x) \\<in> borel_measurable (G T)", "show \"(\\<lambda>x. K - prices Mkt stk T x) \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. K - prices Mkt stk T x) \\<in> borel_measurable (G T)", "proof (rule borel_measurable_diff)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. K) \\<in> borel_measurable (G T)\n 2. prices Mkt stk T \\<in> borel_measurable (G T)", "show \"prices Mkt stk T \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prices Mkt stk T \\<in> borel_measurable (G T)", "by (metis  adapt_stoch_proc_def stock_price_borel_measurable)"], ["proof (state)\nthis:\n  prices Mkt stk T \\<in> borel_measurable (G T)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. K) \\<in> borel_measurable (G T)", "qed simp"], ["proof (state)\nthis:\n  (\\<lambda>x. K - prices Mkt stk T x) \\<in> borel_measurable (G T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in CRR_market_viable) put_option_lgeom:\n  shows \"put_option T K w = max (K - (lgeom_proc u d init (stake T w))) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put_option T K w = max (K - lgeom_proc u d init (stake T w)) 0", "using geom_lgeom stk_price geometric_process"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. put_option T K w = max (K - lgeom_proc u d init (stake T w)) 0", "unfolding put_option_def"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. max (K - prices Mkt stk T w) 0 =\n    max (K - lgeom_proc u d init (stake T w)) 0", "by simp"], ["", "lemma (in CRR_market_viable) disc_put_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (put_option T K)) T w) = \n    (det_discount r T) * (max (K - (lgeom_proc u d init (stake T w))) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. put_option T K) T w =\n    det_discount r T * max (K - lgeom_proc u d init (stake T w)) 0", "using det_discounted[of r \"\\<lambda>m. put_option T K\" T w] put_option_lgeom[of T K w]"], ["proof (prove)\nusing this:\n  discounted_value r (\\<lambda>m. put_option T K) T w =\n  det_discount r T * put_option T K w\n  put_option T K w = max (K - lgeom_proc u d init (stake T w)) 0\n\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. put_option T K) T w =\n    det_discount r T * max (K - lgeom_proc u d init (stake T w)) 0", "by simp"], ["", "lemma (in CRR_market_viable) put_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (put_option matur K)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (max (K - (lgeom_proc u d init (take matur y))) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. put_option matur K) matur w) =\n    (\\<Sum>y\\<in>gener_bool_list matur.\n       lprob_comp pr y * det_discount r matur *\n       max (K - lgeom_proc u d init (take matur y)) 0)", "proof (rule pseudo_range_stake)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. put_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. put_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "have \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. put_option matur K) matur w =\n    lprob_comp pr (stake matur w) * discounted_value r (\\<lambda>m. put_option matur K) matur w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. put_option matur K) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. put_option matur K) matur w", "using lprob_comp_stake"], ["proof (prove)\nusing this:\n  prod (prob_component ?pr ?w) {0..<?matur} =\n  lprob_comp ?pr (stake ?matur ?w)\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. put_option matur K) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. put_option matur K) matur w", "by simp"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. put_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "also"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. put_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "have \"... = lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (max (K - (lgeom_proc u d init (take matur (stake matur w)))) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. put_option matur K) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "using disc_put_option_lgeom[of matur K]"], ["proof (prove)\nusing this:\n  discounted_value r (\\<lambda>m. put_option matur K) matur ?w =\n  det_discount r matur * max (K - lgeom_proc u d init (stake matur ?w)) 0\n\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. put_option matur K) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "by simp"], ["proof (state)\nthis:\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (K - lgeom_proc u d init (take matur (stake matur w))) 0\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. put_option matur K) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "finally"], ["proof (chain)\npicking this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "show \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. put_option matur K) matur w =\n    lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (max (K - (lgeom_proc u d init (take matur (stake matur w)))) 0)\""], ["proof (prove)\nusing this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (K - lgeom_proc u d init (take matur (stake matur w))) 0\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. put_option matur K) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    max (K - lgeom_proc u d init (take matur (stake matur w))) 0", "."], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. put_option matur K) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  max (K - lgeom_proc u d init (take matur (stake matur w))) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "fun put_price where\n\"put_price u d init r matur K = (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp ((1 + r - d) / (u - d)) y * (det_discount r matur) * \n      (max (K - (lgeom_proc u d init (take matur (take matur y)))) 0))\""], ["", "text \\<open> Evaluating the function above returns the fair price of a put option. \\<close>"], ["", "lemma (in CRR_market_viable) put_price:\n  shows \"fair_price Mkt \n    (put_price u d init r matur K) \n    (put_option matur K) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt (put_price u d init r matur K) (put_option matur K) matur", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fair_price Mkt (put_price u d init r matur K) (put_option matur K) matur", "have \"fair_price Mkt \n    (\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (put_option matur K)) matur w)) \n    (put_option matur K) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt\n     (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n        prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n        discounted_value r (\\<lambda>m. put_option matur K) matur w)\n     (put_option matur K) matur", "by (rule CRR_market_fair_price, rule put_borel)"], ["proof (state)\nthis:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. put_option matur K) matur w)\n   (put_option matur K) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (put_price u d init r matur K) (put_option matur K) matur", "thus ?thesis"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. put_option matur K) matur w)\n   (put_option matur K) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (put_price u d init r matur K) (put_option matur K) matur", "using put_effect_compute"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. put_option matur K) matur w)\n   (put_option matur K) matur\n  (\\<Sum>w\\<in>range (pseudo_proj_True ?matur).\n     prod (prob_component ?pr w) {0..<?matur} *\n     discounted_value r (\\<lambda>m. put_option ?matur ?K) ?matur w) =\n  (\\<Sum>y\\<in>gener_bool_list ?matur.\n     lprob_comp ?pr y * det_discount r ?matur *\n     max (?K - lgeom_proc u d init (take ?matur y)) 0)\n\ngoal (1 subgoal):\n 1. fair_price Mkt (put_price u d init r matur K) (put_option matur K) matur", "by simp"], ["proof (state)\nthis:\n  fair_price Mkt (put_price u d init r matur K) (put_option matur K) matur\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Lookback option \\<close>"], ["", "text \\<open> A lookback option is parameterized by a maturity T. If Sn denotes the price of the (unique) risky asset at \ntime n, then the option pays max(Sn. 0 <= n <= T) - ST at that time. \\<close>"], ["", "definition (in CRR_market) lbk_option where\n\"lbk_option (T::nat) = (\\<lambda> w. Max ((\\<lambda>i. (prices Mkt stk) i w)`{0 .. T}) - (prices Mkt stk T w))\""], ["", "lemma borel_measurable_Max_finite:\n  fixes f::\"'a \\<Rightarrow> 'b \\<Rightarrow> 'c::{second_countable_topology, linorder_topology}\"\n  assumes \"0 < (n::nat)\"\nshows \"\\<And>A. card A = n \\<Longrightarrow> \\<forall>a \\<in> A. f a \\<in> borel_measurable M \\<Longrightarrow> (\\<lambda>w. Max ((\\<lambda>a. f a w)`A)) \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>card A = n;\n        \\<forall>a\\<in>A. f a \\<in> borel_measurable M\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>card A = n;\n        \\<forall>a\\<in>A. f a \\<in> borel_measurable M\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>card A = 0; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "case 0"], ["proof (state)\nthis:\n  card A = 0\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n  0 < 0\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>card A = 0; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "show \"\\<And>A. card A = 0 \\<Longrightarrow> \\<forall>a\\<in>A. f a \\<in> borel_measurable M \\<Longrightarrow> (0::nat) < 0 \\<Longrightarrow> (\\<lambda>w. Max ((\\<lambda>a. f a w) ` A)) \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>card A = 0; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>card A = 0; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "fix A::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>card A = 0; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "assume \"card A = 0\" and  \"\\<forall>a\\<in>A. f a \\<in> borel_measurable M\" and \"(0::nat) < 0\""], ["proof (state)\nthis:\n  card A = 0\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n  0 < 0\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>card A = 0; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "thus \"(\\<lambda>w. Max ((\\<lambda>a. f a w) ` A)) \\<in> borel_measurable M\""], ["proof (prove)\nusing this:\n  card A = 0\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n  0 < 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>card ?A = 0; \\<forall>a\\<in>?A. f a \\<in> borel_measurable M;\n   0 < 0\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>?A. f a w)\n                    \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "case Suc"], ["proof (state)\nthis:\n  \\<lbrakk>card ?A = n_; \\<forall>a\\<in>?A. f a \\<in> borel_measurable M;\n   0 < n_\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>?A. f a w)\n                    \\<in> borel_measurable M\n  card A = Suc n_\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n  0 < Suc n_\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "show \"\\<And>n A. (\\<And>A. card A = n \\<Longrightarrow>\n                 \\<forall>a\\<in>A. f a \\<in> borel_measurable M \\<Longrightarrow> 0 < n \\<Longrightarrow> (\\<lambda>w. Max ((\\<lambda>a. f a w) ` A)) \\<in> borel_measurable M) \\<Longrightarrow>\n           card A = Suc n \\<Longrightarrow>\n           \\<forall>a\\<in>A. f a \\<in> borel_measurable M \\<Longrightarrow> 0 < Suc n \\<Longrightarrow> (\\<lambda>w. Max ((\\<lambda>a. f a w) ` A)) \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "fix A::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "assume ameas: \"(\\<And>A. card A = n \\<Longrightarrow>\n                 \\<forall>a\\<in>A. f a \\<in> borel_measurable M \\<Longrightarrow> 0 < n \\<Longrightarrow> (\\<lambda>w. Max ((\\<lambda>a. f a w) ` A)) \\<in> borel_measurable M)\"\n    and \"card A = Suc n\"\n    and \"\\<forall>a\\<in>A. f a \\<in> borel_measurable M\"\n    and \"0 < Suc n\""], ["proof (state)\nthis:\n  \\<lbrakk>card ?A = n; \\<forall>a\\<in>?A. f a \\<in> borel_measurable M;\n   0 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>?A. f a w)\n                    \\<in> borel_measurable M\n  card A = Suc n\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n  0 < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "from \\<open>card A = Suc n\\<close>"], ["proof (chain)\npicking this:\n  card A = Suc n", "have aprop: \"A\\<noteq> {} \\<and> finite A\""], ["proof (prove)\nusing this:\n  card A = Suc n\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and> finite A", "using card_eq_0_iff[of A]"], ["proof (prove)\nusing this:\n  card A = Suc n\n  (card A = 0) = (A = {} \\<or> infinite A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and> finite A", "by simp"], ["proof (state)\nthis:\n  A \\<noteq> {} \\<and> finite A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "hence \"\\<exists>x. x\\<in> A\""], ["proof (prove)\nusing this:\n  A \\<noteq> {} \\<and> finite A\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "from this"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> A", "obtain a where \"a\\<in> A\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "hence \"Suc (card (A - {a})) = Suc n\""], ["proof (prove)\nusing this:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. Suc (card (A - {a})) = Suc n", "using aprop card_Suc_Diff1[of A] \\<open>card A = Suc n\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> A\n  A \\<noteq> {} \\<and> finite A\n  \\<lbrakk>finite A; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> Suc (card (A - {?x})) = card A\n  card A = Suc n\n\ngoal (1 subgoal):\n 1. Suc (card (A - {a})) = Suc n", "by auto"], ["proof (state)\nthis:\n  Suc (card (A - {a})) = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "hence \"card (A - {a}) = n\""], ["proof (prove)\nusing this:\n  Suc (card (A - {a})) = Suc n\n\ngoal (1 subgoal):\n 1. card (A - {a}) = n", "by simp"], ["proof (state)\nthis:\n  card (A - {a}) = n\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>card A = n;\n                    \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                     \\<in> borel_measurable M;\n        card A = Suc n; \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                         \\<in> borel_measurable M", "show \"(\\<lambda>w. Max ((\\<lambda>a. f a w) ` A)) \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "hence \"0 < n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "moreover"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "have \"\\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M", "using \\<open>\\<forall>a\\<in>A. f a \\<in> borel_measurable M\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "ultimately"], ["proof (chain)\npicking this:\n  0 < n\n  \\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M", "have \"(\\<lambda>w. Max ((\\<lambda>a. f a w) ` (A-{a}))) \\<in> borel_measurable M\""], ["proof (prove)\nusing this:\n  0 < n\n  \\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A - {a}. f a w) \\<in> borel_measurable M", "using \\<open>card (A - {a}) = n\\<close>\n        ameas[of \"A - {a}\"]"], ["proof (prove)\nusing this:\n  0 < n\n  \\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M\n  card (A - {a}) = n\n  \\<lbrakk>card (A - {a}) = n;\n   \\<forall>a\\<in>A - {a}. f a \\<in> borel_measurable M; 0 < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A - {a}. f a w)\n                    \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A - {a}. f a w) \\<in> borel_measurable M", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>w. MAX a\\<in>A - {a}. f a w) \\<in> borel_measurable M\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>w. MAX a\\<in>A - {a}. f a w) \\<in> borel_measurable M\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "have \"f a \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<in> borel_measurable M", "using \\<open>\\<forall>a\\<in>A. f a \\<in> borel_measurable M\\<close> \\<open>a\\<in>A\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. f a \\<in> borel_measurable M", "by simp"], ["proof (state)\nthis:\n  f a \\<in> borel_measurable M\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>w. MAX a\\<in>A - {a}. f a w) \\<in> borel_measurable M\n  f a \\<in> borel_measurable M", "have \"(\\<lambda> w. max (f a w) (Max ((\\<lambda>a. f a w) ` (A-{a})))) \\<in> borel_measurable M\""], ["proof (prove)\nusing this:\n  (\\<lambda>w. MAX a\\<in>A - {a}. f a w) \\<in> borel_measurable M\n  f a \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. max (f a w) (MAX a\\<in>A - {a}. f a w))\n    \\<in> borel_measurable M", "using borel_measurable_max"], ["proof (prove)\nusing this:\n  (\\<lambda>w. MAX a\\<in>A - {a}. f a w) \\<in> borel_measurable M\n  f a \\<in> borel_measurable M\n  \\<lbrakk>?f \\<in> borel_measurable ?M;\n   ?g \\<in> borel_measurable ?M\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. max (?g x) (?f x))\n                    \\<in> borel_measurable ?M\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. max (f a w) (MAX a\\<in>A - {a}. f a w))\n    \\<in> borel_measurable M", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>w. max (f a w) (MAX a\\<in>A - {a}. f a w))\n  \\<in> borel_measurable M\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>w. max (f a w) (MAX a\\<in>A - {a}. f a w))\n  \\<in> borel_measurable M\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "have \"\\<And>w. max (f a w) (Max ((\\<lambda>a. f a w) ` (A-{a}))) = Max ((\\<lambda>a. f a w) `A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "define FA where \"FA = ((\\<lambda>a. f a w) ` (A-{a}))\""], ["proof (state)\nthis:\n  FA = (\\<lambda>a. f a w) ` (A - {a})\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "have \"finite FA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite FA", "unfolding FA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>a. f a w) ` (A - {a}))", "using aprop"], ["proof (prove)\nusing this:\n  A \\<noteq> {} \\<and> finite A\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>a. f a w) ` (A - {a}))", "by simp"], ["proof (state)\nthis:\n  finite FA\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "have \"A - {a} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {a} \\<noteq> {}", "using aprop False \\<open>card (A - {a}) = n\\<close> card_eq_0_iff[of \"A - {a}\"]"], ["proof (prove)\nusing this:\n  A \\<noteq> {} \\<and> finite A\n  n \\<noteq> 0\n  card (A - {a}) = n\n  (card (A - {a}) = 0) = (A - {a} = {} \\<or> infinite (A - {a}))\n\ngoal (1 subgoal):\n 1. A - {a} \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  A - {a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "hence \"FA \\<noteq> {}\""], ["proof (prove)\nusing this:\n  A - {a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. FA \\<noteq> {}", "unfolding FA_def"], ["proof (prove)\nusing this:\n  A - {a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. f a w) ` (A - {a}) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  FA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "have \"max (f a w) (Max FA) = Max (insert (f a w) FA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (f a w) (Max FA) = Max (insert (f a w) FA)", "using \\<open>finite FA\\<close> \\<open>FA \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  finite FA\n  FA \\<noteq> {}\n\ngoal (1 subgoal):\n 1. max (f a w) (Max FA) = Max (insert (f a w) FA)", "by simp"], ["proof (state)\nthis:\n  max (f a w) (Max FA) = Max (insert (f a w) FA)\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "hence  \"max (f a w) (Max ((\\<lambda>a. f a w) ` (A-{a}))) = Max (insert (f a w) ((\\<lambda>a. f a w) `(A-{a})))\""], ["proof (prove)\nusing this:\n  max (f a w) (Max FA) = Max (insert (f a w) FA)\n\ngoal (1 subgoal):\n 1. max (f a w) (MAX a\\<in>A - {a}. f a w) =\n    Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})))", "unfolding FA_def"], ["proof (prove)\nusing this:\n  max (f a w) (MAX a\\<in>A - {a}. f a w) =\n  Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})))\n\ngoal (1 subgoal):\n 1. max (f a w) (MAX a\\<in>A - {a}. f a w) =\n    Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})))", "by simp"], ["proof (state)\nthis:\n  max (f a w) (MAX a\\<in>A - {a}. f a w) =\n  Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})))\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "also"], ["proof (state)\nthis:\n  max (f a w) (MAX a\\<in>A - {a}. f a w) =\n  Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})))\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "have \"... = Max ((\\<lambda>a. f a w) `A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n    (MAX a\\<in>A. f a w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n    (MAX a\\<in>A. f a w)", "have \"insert (f a w) ((\\<lambda>a. f a w) `(A-{a})) = (\\<lambda>a. f a w) `(insert a (A - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) =\n    (\\<lambda>a. f a w) ` insert a (A - {a})", "by auto"], ["proof (state)\nthis:\n  insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) =\n  (\\<lambda>a. f a w) ` insert a (A - {a})\n\ngoal (1 subgoal):\n 1. Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n    (MAX a\\<in>A. f a w)", "also"], ["proof (state)\nthis:\n  insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) =\n  (\\<lambda>a. f a w) ` insert a (A - {a})\n\ngoal (1 subgoal):\n 1. Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n    (MAX a\\<in>A. f a w)", "have \"... = ((\\<lambda>a. f a w) `A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. f a w) ` insert a (A - {a}) = (\\<lambda>a. f a w) ` A", "using \\<open>a \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. f a w) ` insert a (A - {a}) = (\\<lambda>a. f a w) ` A", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>a. f a w) ` insert a (A - {a}) = (\\<lambda>a. f a w) ` A\n\ngoal (1 subgoal):\n 1. Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n    (MAX a\\<in>A. f a w)", "finally"], ["proof (chain)\npicking this:\n  insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) = (\\<lambda>a. f a w) ` A", "have \"insert (f a w) ((\\<lambda>a. f a w) `(A-{a})) = ((\\<lambda>a. f a w) `A)\""], ["proof (prove)\nusing this:\n  insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) = (\\<lambda>a. f a w) ` A\n\ngoal (1 subgoal):\n 1. insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) =\n    (\\<lambda>a. f a w) ` A", "."], ["proof (state)\nthis:\n  insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) = (\\<lambda>a. f a w) ` A\n\ngoal (1 subgoal):\n 1. Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n    (MAX a\\<in>A. f a w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  insert (f a w) ((\\<lambda>a. f a w) ` (A - {a})) = (\\<lambda>a. f a w) ` A\n\ngoal (1 subgoal):\n 1. Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n    (MAX a\\<in>A. f a w)", "by simp"], ["proof (state)\nthis:\n  Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n  (MAX a\\<in>A. f a w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (insert (f a w) ((\\<lambda>a. f a w) ` (A - {a}))) =\n  (MAX a\\<in>A. f a w)\n\ngoal (1 subgoal):\n 1. \\<And>w. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "finally"], ["proof (chain)\npicking this:\n  max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "show \"max (f a w) (Max ((\\<lambda>a. f a w) ` (A-{a}))) = Max ((\\<lambda>a. f a w) `A)\""], ["proof (prove)\nusing this:\n  max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)\n\ngoal (1 subgoal):\n 1. max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)", "."], ["proof (state)\nthis:\n  max (f a w) (MAX a\\<in>A - {a}. f a w) = (MAX a\\<in>A. f a w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max (f a ?w) (MAX a\\<in>A - {a}. f a ?w) = (MAX a\\<in>A. f a ?w)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>w. max (f a w) (MAX a\\<in>A - {a}. f a w))\n  \\<in> borel_measurable M\n  max (f a ?w) (MAX a\\<in>A - {a}. f a ?w) = (MAX a\\<in>A. f a ?w)", "show \"(\\<lambda>w. Max ((\\<lambda>a. f a w) `A)) \\<in> borel_measurable M\""], ["proof (prove)\nusing this:\n  (\\<lambda>w. max (f a w) (MAX a\\<in>A - {a}. f a w))\n  \\<in> borel_measurable M\n  max (f a ?w) (MAX a\\<in>A - {a}. f a ?w) = (MAX a\\<in>A. f a ?w)\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "hence \"A - {a} = {}\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. A - {a} = {}", "using aprop card_eq_0_iff[of \"A - {a}\"] \\<open>card (A - {a}) = n\\<close>"], ["proof (prove)\nusing this:\n  n = 0\n  A \\<noteq> {} \\<and> finite A\n  (card (A - {a}) = 0) = (A - {a} = {} \\<or> infinite (A - {a}))\n  card (A - {a}) = n\n\ngoal (1 subgoal):\n 1. A - {a} = {}", "by simp"], ["proof (state)\nthis:\n  A - {a} = {}\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "hence \"{a} = insert a (A - {a})\""], ["proof (prove)\nusing this:\n  A - {a} = {}\n\ngoal (1 subgoal):\n 1. {a} = insert a (A - {a})", "by simp"], ["proof (state)\nthis:\n  {a} = insert a (A - {a})\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "also"], ["proof (state)\nthis:\n  {a} = insert a (A - {a})\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "have \"... = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert a (A - {a}) = A", "using \\<open>a\\<in> A\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. insert a (A - {a}) = A", "by blast"], ["proof (state)\nthis:\n  insert a (A - {a}) = A\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "finally"], ["proof (chain)\npicking this:\n  {a} = A", "have \"{a} = A\""], ["proof (prove)\nusing this:\n  {a} = A\n\ngoal (1 subgoal):\n 1. {a} = A", "."], ["proof (state)\nthis:\n  {a} = A\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "hence \"\\<And>w. (\\<lambda>a. f a w) `A = {f a w}\""], ["proof (prove)\nusing this:\n  {a} = A\n\ngoal (1 subgoal):\n 1. \\<And>w. (\\<lambda>a. f a w) ` A = {f a w}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>a. f a ?w) ` A = {f a ?w}\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "hence \"\\<And>w. Max ((\\<lambda>a. f a w) `A) = Max {f a w}\""], ["proof (prove)\nusing this:\n  (\\<lambda>a. f a ?w) ` A = {f a ?w}\n\ngoal (1 subgoal):\n 1. \\<And>w. (MAX a\\<in>A. f a w) = Max {f a w}", "by simp"], ["proof (state)\nthis:\n  (MAX a\\<in>A. f a ?w) = Max {f a ?w}\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "hence \"\\<And>w. Max ((\\<lambda>a. f a w) `A) = f a w\""], ["proof (prove)\nusing this:\n  (MAX a\\<in>A. f a ?w) = Max {f a ?w}\n\ngoal (1 subgoal):\n 1. \\<And>w. (MAX a\\<in>A. f a w) = f a w", "by simp"], ["proof (state)\nthis:\n  (MAX a\\<in>A. f a ?w) = f a ?w\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "hence \"(\\<lambda>w. Max ((\\<lambda>a. f a w) `A)) = f a\""], ["proof (prove)\nusing this:\n  (MAX a\\<in>A. f a ?w) = f a ?w\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A. f a w) = f a", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>w. MAX a\\<in>A. f a w) = f a\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "thus \"(\\<lambda>w. Max ((\\<lambda>a. f a w) `A)) \\<in> borel_measurable M\""], ["proof (prove)\nusing this:\n  (\\<lambda>w. MAX a\\<in>A. f a w) = f a\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "using \\<open>\\<forall>a\\<in>A. f a \\<in> borel_measurable M\\<close> \n        \\<open>a\\<in> A\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>w. MAX a\\<in>A. f a w) = f a\n  \\<forall>a\\<in>A. f a \\<in> borel_measurable M\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>w. MAX a\\<in>A. f a w) \\<in> borel_measurable M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>A.\n              \\<lbrakk>card A = ?n;\n               \\<forall>a\\<in>A. f a \\<in> borel_measurable M;\n               0 < ?n\\<rbrakk>\n              \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>A. f a w)\n                                \\<in> borel_measurable M;\n   card ?A = Suc ?n; \\<forall>a\\<in>?A. f a \\<in> borel_measurable M;\n   0 < Suc ?n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>w. MAX a\\<in>?A. f a w)\n                    \\<in> borel_measurable M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in CRR_market) lbk_borel:\n  shows \"lbk_option T \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lbk_option T \\<in> borel_measurable (G T)", "unfolding lbk_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w.\n        (MAX i\\<in>{0..T}. prices Mkt stk i w) - prices Mkt stk T w)\n    \\<in> borel_measurable (G T)", "proof (rule borel_measurable_diff)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. MAX i\\<in>{0..T}. prices Mkt stk i x)\n    \\<in> borel_measurable (G T)\n 2. prices Mkt stk T \\<in> borel_measurable (G T)", "show \"(\\<lambda>x. Max ((\\<lambda>i. prices Mkt stk i x) ` {0..T})) \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. MAX i\\<in>{0..T}. prices Mkt stk i x)\n    \\<in> borel_measurable (G T)", "proof (rule borel_measurable_Max_finite)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < ?n\n 2. card {0..T} = ?n\n 3. \\<forall>i\\<in>{0..T}. prices Mkt stk i \\<in> borel_measurable (G T)", "show \"card {0..T} = Suc T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..T} = Suc T", "by simp"], ["proof (state)\nthis:\n  card {0..T} = Suc T\n\ngoal (2 subgoals):\n 1. 0 < Suc T\n 2. \\<forall>i\\<in>{0..T}. prices Mkt stk i \\<in> borel_measurable (G T)", "show \"0 < Suc T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Suc T", "by simp"], ["proof (state)\nthis:\n  0 < Suc T\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..T}. prices Mkt stk i \\<in> borel_measurable (G T)", "show \"\\<forall>i\\<in>{0..T}. prices Mkt stk i \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..T}. prices Mkt stk i \\<in> borel_measurable (G T)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..T} \\<Longrightarrow>\n       prices Mkt stk i \\<in> borel_measurable (G T)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..T} \\<Longrightarrow>\n       prices Mkt stk i \\<in> borel_measurable (G T)", "assume \"i\\<in> {0..T}\""], ["proof (state)\nthis:\n  i \\<in> {0..T}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..T} \\<Longrightarrow>\n       prices Mkt stk i \\<in> borel_measurable (G T)", "show \"prices Mkt stk i \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prices Mkt stk i \\<in> borel_measurable (G T)", "by (metis \\<open>i \\<in> {0..T}\\<close> adapt_stoch_proc_def atLeastAtMost_iff increasing_measurable_info \n            stock_price_borel_measurable)"], ["proof (state)\nthis:\n  prices Mkt stk i \\<in> borel_measurable (G T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..T}. prices Mkt stk i \\<in> borel_measurable (G T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. MAX i\\<in>{0..T}. prices Mkt stk i x)\n  \\<in> borel_measurable (G T)\n\ngoal (1 subgoal):\n 1. prices Mkt stk T \\<in> borel_measurable (G T)", "show \"prices Mkt stk T \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prices Mkt stk T \\<in> borel_measurable (G T)", "by (metis  adapt_stoch_proc_def stock_price_borel_measurable)"], ["proof (state)\nthis:\n  prices Mkt stk T \\<in> borel_measurable (G T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in CRR_market_viable) lbk_option_lgeom:\n  shows \"lbk_option T w = Max ((\\<lambda>i. (lgeom_proc u d init (stake i w)))`{0 .. T}) - (lgeom_proc u d init (stake T w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lbk_option T w =\n    (MAX i\\<in>{0..T}. lgeom_proc u d init (stake i w)) -\n    lgeom_proc u d init (stake T w)", "using geom_lgeom stk_price geometric_process"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. lbk_option T w =\n    (MAX i\\<in>{0..T}. lgeom_proc u d init (stake i w)) -\n    lgeom_proc u d init (stake T w)", "unfolding lbk_option_def"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. (MAX i\\<in>{0..T}. prices Mkt stk i w) - prices Mkt stk T w =\n    (MAX i\\<in>{0..T}. lgeom_proc u d init (stake i w)) -\n    lgeom_proc u d init (stake T w)", "by simp"], ["", "lemma (in CRR_market_viable) disc_lbk_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (lbk_option T)) T w) = \n    (det_discount r T) * (Max ((\\<lambda>i. (lgeom_proc u d init (take i (stake T w))))`{0 .. T}) - (lgeom_proc u d init (stake T w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. lbk_option T) T w =\n    det_discount r T *\n    ((MAX i\\<in>{0..T}. lgeom_proc u d init (take i (stake T w))) -\n     lgeom_proc u d init (stake T w))", "using det_discounted[of r \"\\<lambda>m. lbk_option T\" T w] lbk_option_lgeom[of T w] lgeom_proc_take"], ["proof (prove)\nusing this:\n  discounted_value r (\\<lambda>m. lbk_option T) T w =\n  det_discount r T * lbk_option T w\n  lbk_option T w =\n  (MAX i\\<in>{0..T}. lgeom_proc u d init (stake i w)) -\n  lgeom_proc u d init (stake T w)\n  ?i \\<le> ?n \\<Longrightarrow>\n  lgeom_proc ?u ?d ?init (stake ?i ?w) =\n  lgeom_proc ?u ?d ?init (take ?i (stake ?n ?w))\n\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. lbk_option T) T w =\n    det_discount r T *\n    ((MAX i\\<in>{0..T}. lgeom_proc u d init (take i (stake T w))) -\n     lgeom_proc u d init (stake T w))", "by (metis (no_types, lifting) atLeastAtMost_iff image_cong)"], ["", "lemma (in CRR_market_viable) lbk_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (lbk_option matur)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (Max ((\\<lambda>i. (lgeom_proc u d init (take i y)))`{0 .. matur}) - (lgeom_proc u d init y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. lbk_option matur) matur w) =\n    (\\<Sum>y\\<in>gener_bool_list matur.\n       lprob_comp pr y * det_discount r matur *\n       ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i y)) -\n        lgeom_proc u d init y))", "proof (rule pseudo_range_stake)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       ((MAX i\\<in>{0..matur}.\n            lgeom_proc u d init (take i (stake matur w))) -\n        lgeom_proc u d init (stake matur w))", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       ((MAX i\\<in>{0..matur}.\n            lgeom_proc u d init (take i (stake matur w))) -\n        lgeom_proc u d init (stake matur w))", "have \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n    lprob_comp pr (stake matur w) * discounted_value r (\\<lambda>m. lbk_option matur) matur w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. lbk_option matur) matur w", "using lprob_comp_stake"], ["proof (prove)\nusing this:\n  prod (prob_component ?pr ?w) {0..<?matur} =\n  lprob_comp ?pr (stake ?matur ?w)\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. lbk_option matur) matur w", "by simp"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       ((MAX i\\<in>{0..matur}.\n            lgeom_proc u d init (take i (stake matur w))) -\n        lgeom_proc u d init (stake matur w))", "also"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       ((MAX i\\<in>{0..matur}.\n            lgeom_proc u d init (take i (stake matur w))) -\n        lgeom_proc u d init (stake matur w))", "have \"... = lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (Max ((\\<lambda>i. (lgeom_proc u d init (take i (stake matur w))))`{0 .. matur}) - \n      (lgeom_proc u d init (stake matur w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i (stake matur w))) -\n     lgeom_proc u d init (stake matur w))", "using disc_lbk_option_lgeom"], ["proof (prove)\nusing this:\n  discounted_value r (\\<lambda>m. lbk_option ?T) ?T ?w =\n  det_discount r ?T *\n  ((MAX i\\<in>{0..?T}. lgeom_proc u d init (take i (stake ?T ?w))) -\n   lgeom_proc u d init (stake ?T ?w))\n\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i (stake matur w))) -\n     lgeom_proc u d init (stake matur w))", "by simp"], ["proof (state)\nthis:\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i (stake matur w))) -\n   lgeom_proc u d init (stake matur w))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       ((MAX i\\<in>{0..matur}.\n            lgeom_proc u d init (take i (stake matur w))) -\n        lgeom_proc u d init (stake matur w))", "finally"], ["proof (chain)\npicking this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i (stake matur w))) -\n   lgeom_proc u d init (stake matur w))", "show \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n    lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (Max ((\\<lambda>i. (lgeom_proc u d init (take i (stake matur w))))`{0 .. matur}) - \n      (lgeom_proc u d init (stake matur w)))\""], ["proof (prove)\nusing this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i (stake matur w))) -\n   lgeom_proc u d init (stake matur w))\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i (stake matur w))) -\n     lgeom_proc u d init (stake matur w))", "."], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. lbk_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  ((MAX i\\<in>{0..matur}. lgeom_proc u d init (take i (stake matur w))) -\n   lgeom_proc u d init (stake matur w))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun lbk_price where\n\"lbk_price u d init r matur = (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp ((1 + r - d) / (u - d)) y * (det_discount r matur) * \n      (Max ((\\<lambda>i. (lgeom_proc u d init (take i y)))`{0 .. matur}) - (lgeom_proc u d init y)))\""], ["", "text \\<open> Evaluating the function above returns the fair price of a lookback option. \\<close>"], ["", "lemma (in CRR_market_viable) lbk_price:\n  shows \"fair_price Mkt \n    (lbk_price u d init r matur) \n    (lbk_option matur) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt (lbk_price u d init r matur) (lbk_option matur) matur", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fair_price Mkt (lbk_price u d init r matur) (lbk_option matur) matur", "have \"fair_price Mkt \n    (\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (lbk_option matur)) matur w)) \n    (lbk_option matur) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt\n     (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n        prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n        discounted_value r (\\<lambda>m. lbk_option matur) matur w)\n     (lbk_option matur) matur", "by (rule CRR_market_fair_price, rule lbk_borel)"], ["proof (state)\nthis:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. lbk_option matur) matur w)\n   (lbk_option matur) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (lbk_price u d init r matur) (lbk_option matur) matur", "thus ?thesis"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. lbk_option matur) matur w)\n   (lbk_option matur) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (lbk_price u d init r matur) (lbk_option matur) matur", "using lbk_effect_compute"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. lbk_option matur) matur w)\n   (lbk_option matur) matur\n  (\\<Sum>w\\<in>range (pseudo_proj_True ?matur).\n     prod (prob_component ?pr w) {0..<?matur} *\n     discounted_value r (\\<lambda>m. lbk_option ?matur) ?matur w) =\n  (\\<Sum>y\\<in>gener_bool_list ?matur.\n     lprob_comp ?pr y * det_discount r ?matur *\n     ((MAX i\\<in>{0..?matur}. lgeom_proc u d init (take i y)) -\n      lgeom_proc u d init y))\n\ngoal (1 subgoal):\n 1. fair_price Mkt (lbk_price u d init r matur) (lbk_option matur) matur", "by simp"], ["proof (state)\nthis:\n  fair_price Mkt (lbk_price u d init r matur) (lbk_option matur) matur\n\ngoal:\nNo subgoals!", "qed"], ["", "value \"lbk_price 1.2 0.8 10 0.03 2\""], ["", "subsection \\<open> Asian option \\<close>"], ["", "text \\<open> An asian option is parameterized by a maturity T. This option pays the average price of the \nrisky asset at time T. \\<close>"], ["", "definition (in CRR_market) asian_option where\n\"asian_option (T::nat) = (\\<lambda> w. (\\<Sum> i\\<in> {1.. T}. prices Mkt stk i w)/T)\""], ["", "lemma (in CRR_market) asian_borel:\n  shows \"asian_option T \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asian_option T \\<in> borel_measurable (G T)", "unfolding asian_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w. (\\<Sum>i = 1..T. prices Mkt stk i w) / real T)\n    \\<in> borel_measurable (G T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>w. (\\<Sum>i = 1..T. prices Mkt stk i w) / real T)\n    \\<in> borel_measurable (G T)", "have \"(\\<lambda> w. (\\<Sum> i\\<in> {1.. T}. prices Mkt stk i w)) \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w. \\<Sum>i = 1..T. prices Mkt stk i w)\n    \\<in> borel_measurable (G T)", "proof (rule borel_measurable_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {1..T} \\<Longrightarrow>\n       prices Mkt stk i \\<in> borel_measurable (G T)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {1..T} \\<Longrightarrow>\n       prices Mkt stk i \\<in> borel_measurable (G T)", "assume \"i\\<in> {1..T}\""], ["proof (state)\nthis:\n  i \\<in> {1..T}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {1..T} \\<Longrightarrow>\n       prices Mkt stk i \\<in> borel_measurable (G T)", "show \"prices Mkt stk i \\<in> borel_measurable (G T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prices Mkt stk i \\<in> borel_measurable (G T)", "by (metis \\<open>i \\<in> {1..T}\\<close> adapt_stoch_proc_def atLeastAtMost_iff increasing_measurable_info \n            stock_price_borel_measurable)"], ["proof (state)\nthis:\n  prices Mkt stk i \\<in> borel_measurable (G T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>w. \\<Sum>i = 1..T. prices Mkt stk i w)\n  \\<in> borel_measurable (G T)\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. (\\<Sum>i = 1..T. prices Mkt stk i w) / real T)\n    \\<in> borel_measurable (G T)", "from this"], ["proof (chain)\npicking this:\n  (\\<lambda>w. \\<Sum>i = 1..T. prices Mkt stk i w)\n  \\<in> borel_measurable (G T)", "show \"(\\<lambda>w. (\\<Sum>i = 1..T. prices Mkt stk i w) / real T) \\<in> borel_measurable (G T)\""], ["proof (prove)\nusing this:\n  (\\<lambda>w. \\<Sum>i = 1..T. prices Mkt stk i w)\n  \\<in> borel_measurable (G T)\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. (\\<Sum>i = 1..T. prices Mkt stk i w) / real T)\n    \\<in> borel_measurable (G T)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>w. (\\<Sum>i = 1..T. prices Mkt stk i w) / real T)\n  \\<in> borel_measurable (G T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in CRR_market_viable) asian_option_lgeom:\n  shows \"asian_option T w = (\\<Sum> i\\<in> {1.. T}. lgeom_proc u d init (stake i w))/ T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asian_option T w =\n    (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) / real T", "using geom_lgeom stk_price geometric_process"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. asian_option T w =\n    (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) / real T", "unfolding asian_option_def"], ["proof (prove)\nusing this:\n  geom_rand_walk ?u ?d ?v ?n ?w = lgeom_proc ?u ?d ?v (stake ?n ?w)\n  prices Mkt stk = geom_proc\n  geom_proc = geom_rand_walk u d init\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..T. prices Mkt stk i w) / real T =\n    (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) / real T", "by simp"], ["", "lemma (in CRR_market_viable) disc_asian_option_lgeom:\n  shows \"(discounted_value r (\\<lambda>m. (asian_option T)) T w) = \n    (det_discount r T) * (\\<Sum> i\\<in> {1.. T}. lgeom_proc u d init (take i (stake T w)))/ T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. asian_option T) T w =\n    det_discount r T *\n    (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w))) /\n    real T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. asian_option T) T w =\n    det_discount r T *\n    (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w))) /\n    real T", "have \"\\<forall> i\\<in> {1..T}. lgeom_proc u d init (stake i w) = lgeom_proc u d init (take i (stake T w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{1..T}.\n       lgeom_proc u d init (stake i w) =\n       lgeom_proc u d init (take i (stake T w))", "using lgeom_proc_take"], ["proof (prove)\nusing this:\n  ?i \\<le> ?n \\<Longrightarrow>\n  lgeom_proc ?u ?d ?init (stake ?i ?w) =\n  lgeom_proc ?u ?d ?init (take ?i (stake ?n ?w))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{1..T}.\n       lgeom_proc u d init (stake i w) =\n       lgeom_proc u d init (take i (stake T w))", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{1..T}.\n     lgeom_proc u d init (stake i w) =\n     lgeom_proc u d init (take i (stake T w))\n\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. asian_option T) T w =\n    det_discount r T *\n    (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w))) /\n    real T", "hence \"(\\<Sum> i\\<in> {1.. T}. lgeom_proc u d init (stake i w)) = \n    (\\<Sum> i\\<in> {1.. T}. lgeom_proc u d init (take i (stake T w)))\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{1..T}.\n     lgeom_proc u d init (stake i w) =\n     lgeom_proc u d init (take i (stake T w))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) =\n    (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) =\n  (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w)))\n\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. asian_option T) T w =\n    det_discount r T *\n    (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w))) /\n    real T", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) =\n  (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w)))\n\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. asian_option T) T w =\n    det_discount r T *\n    (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w))) /\n    real T", "using det_discounted[of r \"\\<lambda>m. asian_option T\" T w] asian_option_lgeom[of T w]"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) =\n  (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w)))\n  discounted_value r (\\<lambda>m. asian_option T) T w =\n  det_discount r T * asian_option T w\n  asian_option T w =\n  (\\<Sum>i = 1..T. lgeom_proc u d init (stake i w)) / real T\n\ngoal (1 subgoal):\n 1. discounted_value r (\\<lambda>m. asian_option T) T w =\n    det_discount r T *\n    (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w))) /\n    real T", "by auto"], ["proof (state)\nthis:\n  discounted_value r (\\<lambda>m. asian_option T) T w =\n  det_discount r T *\n  (\\<Sum>i = 1..T. lgeom_proc u d init (take i (stake T w))) /\n  real T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in CRR_market_viable) asian_effect_compute:\nshows \"(\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component pr w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (asian_option matur)) matur w)) =\n      (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp pr y * (det_discount r matur) * \n      (\\<Sum> i\\<in> {1.. matur}. lgeom_proc u d init (take i y))/ matur)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. asian_option matur) matur w) =\n    (\\<Sum>y\\<in>gener_bool_list matur.\n       lprob_comp pr y * det_discount r matur *\n       (\\<Sum>i = 1..matur. lgeom_proc u d init (take i y)) /\n       real matur)", "proof (rule pseudo_range_stake)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. asian_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n       real matur", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. asian_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n       real matur", "have \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. asian_option matur) matur w =\n    lprob_comp pr (stake matur w) * discounted_value r (\\<lambda>m. asian_option matur) matur w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. asian_option matur) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. asian_option matur) matur w", "using lprob_comp_stake"], ["proof (prove)\nusing this:\n  prod (prob_component ?pr ?w) {0..<?matur} =\n  lprob_comp ?pr (stake ?matur ?w)\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. asian_option matur) matur w =\n    lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. asian_option matur) matur w", "by simp"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. asian_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n       real matur", "also"], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w =\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. asian_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n       real matur", "have \"... = lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (\\<Sum> i\\<in> {1.. matur}. lgeom_proc u d init (take i (stake matur w)))/ matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. asian_option matur) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n    real matur", "using disc_asian_option_lgeom[of matur w]"], ["proof (prove)\nusing this:\n  discounted_value r (\\<lambda>m. asian_option matur) matur w =\n  det_discount r matur *\n  (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n  real matur\n\ngoal (1 subgoal):\n 1. lprob_comp pr (stake matur w) *\n    discounted_value r (\\<lambda>m. asian_option matur) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n    real matur", "by simp"], ["proof (state)\nthis:\n  lprob_comp pr (stake matur w) *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n  real matur\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       prod (prob_component pr w) {0..<matur} *\n       discounted_value r (\\<lambda>m. asian_option matur) matur w =\n       lprob_comp pr (stake matur w) * det_discount r matur *\n       (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n       real matur", "finally"], ["proof (chain)\npicking this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n  real matur", "show \"prod (prob_component pr w) {0..<matur} * discounted_value r (\\<lambda>m. asian_option matur) matur w =\n    lprob_comp pr (stake matur w) *\n    (det_discount r matur) * (\\<Sum> i\\<in> {1.. matur}. lgeom_proc u d init (take i (stake matur w)))/ matur\""], ["proof (prove)\nusing this:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n  real matur\n\ngoal (1 subgoal):\n 1. prod (prob_component pr w) {0..<matur} *\n    discounted_value r (\\<lambda>m. asian_option matur) matur w =\n    lprob_comp pr (stake matur w) * det_discount r matur *\n    (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n    real matur", "."], ["proof (state)\nthis:\n  prod (prob_component pr w) {0..<matur} *\n  discounted_value r (\\<lambda>m. asian_option matur) matur w =\n  lprob_comp pr (stake matur w) * det_discount r matur *\n  (\\<Sum>i = 1..matur. lgeom_proc u d init (take i (stake matur w))) /\n  real matur\n\ngoal:\nNo subgoals!", "qed"], ["", "fun asian_price where\n\"asian_price u d init r matur = (\\<Sum> y\\<in> (gener_bool_list matur). lprob_comp ((1 + r - d) / (u - d)) y * (det_discount r matur) * \n      (\\<Sum> i\\<in> {1.. matur}. lgeom_proc u d init (take i y))/ matur)\""], ["", "text \\<open> Evaluating the function above returns the fair price of an asian option. \\<close>"], ["", "lemma (in CRR_market_viable) asian_price:\n  shows \"fair_price Mkt \n    (asian_price u d init r matur) \n    (asian_option matur) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt (asian_price u d init r matur) (asian_option matur) matur", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fair_price Mkt (asian_price u d init r matur) (asian_option matur) matur", "have \"fair_price Mkt \n    (\\<Sum> w\\<in> range (pseudo_proj_True matur). (prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur}) * \n      (discounted_value r (\\<lambda>m. (asian_option matur)) matur w)) \n    (asian_option matur) matur\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_price Mkt\n     (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n        prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n        discounted_value r (\\<lambda>m. asian_option matur) matur w)\n     (asian_option matur) matur", "by (rule CRR_market_fair_price, rule asian_borel)"], ["proof (state)\nthis:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. asian_option matur) matur w)\n   (asian_option matur) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (asian_price u d init r matur) (asian_option matur) matur", "thus ?thesis"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. asian_option matur) matur w)\n   (asian_option matur) matur\n\ngoal (1 subgoal):\n 1. fair_price Mkt (asian_price u d init r matur) (asian_option matur) matur", "using asian_effect_compute"], ["proof (prove)\nusing this:\n  fair_price Mkt\n   (\\<Sum>w\\<in>range (pseudo_proj_True matur).\n      prod (prob_component ((1 + r - d) / (u - d)) w) {0..<matur} *\n      discounted_value r (\\<lambda>m. asian_option matur) matur w)\n   (asian_option matur) matur\n  (\\<Sum>w\\<in>range (pseudo_proj_True ?matur).\n     prod (prob_component ?pr w) {0..<?matur} *\n     discounted_value r (\\<lambda>m. asian_option ?matur) ?matur w) =\n  (\\<Sum>y\\<in>gener_bool_list ?matur.\n     lprob_comp ?pr y * det_discount r ?matur *\n     (\\<Sum>i = 1..?matur. lgeom_proc u d init (take i y)) /\n     real ?matur)\n\ngoal (1 subgoal):\n 1. fair_price Mkt (asian_price u d init r matur) (asian_option matur) matur", "by simp"], ["proof (state)\nthis:\n  fair_price Mkt (asian_price u d init r matur) (asian_option matur) matur\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}