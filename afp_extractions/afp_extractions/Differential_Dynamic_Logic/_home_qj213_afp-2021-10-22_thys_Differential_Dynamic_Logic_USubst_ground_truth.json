{"file_name": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic/USubst.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic", "problem_names": ["lemma dsem_to_ssem:\"dfree \\<theta> \\<Longrightarrow> dterm_sem I \\<theta> \\<nu> = sterm_sem I \\<theta> (fst \\<nu>)\"", "lemma adjoint_free:\n  assumes sfree:\"(\\<And>i f'. SFunctions \\<sigma> i = Some f' \\<Longrightarrow> dfree f')\"\n  shows \"adjoint I \\<sigma> \\<nu> =\n  \\<lparr>Functions =  (\\<lambda>f. case SFunctions \\<sigma> f of Some f' \\<Rightarrow> (\\<lambda>R. sterm_sem (extendf I R) f' (fst \\<nu>)) | None \\<Rightarrow> Functions I f),\n   Predicates = (\\<lambda>p. case SPredicates \\<sigma> p of Some p' \\<Rightarrow> (\\<lambda>R. \\<nu> \\<in> fml_sem (extendf I R) p') | None \\<Rightarrow> Predicates I p),\n   Contexts =   (\\<lambda>c. case SContexts \\<sigma> c of Some c' \\<Rightarrow> (\\<lambda>R. fml_sem (extendc I R) c') | None \\<Rightarrow> Contexts I c),\n   Programs =   (\\<lambda>a. case SPrograms \\<sigma> a of Some a' \\<Rightarrow> prog_sem I a' | None \\<Rightarrow> Programs I a),\n   ODEs =     (\\<lambda>ode. case SODEs \\<sigma> ode of Some ode' \\<Rightarrow> ODE_sem I ode' | None \\<Rightarrow> ODEs I ode),\n   ODEBV = (\\<lambda>ode. case SODEs \\<sigma> ode of Some ode' \\<Rightarrow> ODE_vars I ode' | None \\<Rightarrow> ODEBV I ode)\\<rparr>\"", "lemma adjointFO_free:\"(\\<And>i. dfree (\\<sigma> i)) \\<Longrightarrow> (adjointFO I \\<sigma> \\<nu> =\n\\<lparr>Functions =   (\\<lambda>f. case f of Inl f' \\<Rightarrow> Functions I f' | Inr f' \\<Rightarrow> (\\<lambda>_. sterm_sem I (\\<sigma> f') (fst \\<nu>))),\n Predicates = Predicates I,\n Contexts = Contexts I,\n Programs = Programs I,\n ODEs = ODEs I,\n ODEBV = ODEBV I\\<rparr>)\""], "translations": [["", "lemma dsem_to_ssem:\"dfree \\<theta> \\<Longrightarrow> dterm_sem I \\<theta> \\<nu> = sterm_sem I \\<theta> (fst \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfree \\<theta> \\<Longrightarrow>\n    dterm_sem I \\<theta> \\<nu> = sterm_sem I \\<theta> (fst \\<nu>)", "by (induct rule: dfree.induct) (auto)"], ["", "definition adjointFO::\"('sf, 'sc, 'sz) interp \\<Rightarrow> ('d::finite \\<Rightarrow> ('sf, 'sz) trm) \\<Rightarrow> 'sz state \\<Rightarrow> ('sf + 'd, 'sc, 'sz) interp\" \nwhere \"adjointFO I \\<sigma> \\<nu> =\n\\<lparr>Functions =   (\\<lambda>f. case f of Inl f' \\<Rightarrow> Functions I f' | Inr f' \\<Rightarrow> (\\<lambda>_. dterm_sem I (\\<sigma> f') \\<nu>)),\n Predicates = Predicates I,\n Contexts = Contexts I,\n Programs = Programs I,\n ODEs = ODEs I,\n ODEBV = ODEBV I\n \\<rparr>\""], ["", "lemma adjoint_free:\n  assumes sfree:\"(\\<And>i f'. SFunctions \\<sigma> i = Some f' \\<Longrightarrow> dfree f')\"\n  shows \"adjoint I \\<sigma> \\<nu> =\n  \\<lparr>Functions =  (\\<lambda>f. case SFunctions \\<sigma> f of Some f' \\<Rightarrow> (\\<lambda>R. sterm_sem (extendf I R) f' (fst \\<nu>)) | None \\<Rightarrow> Functions I f),\n   Predicates = (\\<lambda>p. case SPredicates \\<sigma> p of Some p' \\<Rightarrow> (\\<lambda>R. \\<nu> \\<in> fml_sem (extendf I R) p') | None \\<Rightarrow> Predicates I p),\n   Contexts =   (\\<lambda>c. case SContexts \\<sigma> c of Some c' \\<Rightarrow> (\\<lambda>R. fml_sem (extendc I R) c') | None \\<Rightarrow> Contexts I c),\n   Programs =   (\\<lambda>a. case SPrograms \\<sigma> a of Some a' \\<Rightarrow> prog_sem I a' | None \\<Rightarrow> Programs I a),\n   ODEs =     (\\<lambda>ode. case SODEs \\<sigma> ode of Some ode' \\<Rightarrow> ODE_sem I ode' | None \\<Rightarrow> ODEs I ode),\n   ODEBV = (\\<lambda>ode. case SODEs \\<sigma> ode of Some ode' \\<Rightarrow> ODE_vars I ode' | None \\<Rightarrow> ODEBV I ode)\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adjoint I \\<sigma> \\<nu> =\n    \\<lparr>Functions =\n              \\<lambda>f.\n                 case SFunctions \\<sigma> f of\n                 None \\<Rightarrow> Functions I f\n                 | Some f' \\<Rightarrow>\n                     \\<lambda>R. sterm_sem (extendf I R) f' (fst \\<nu>),\n       Predicates =\n         \\<lambda>p.\n            case SPredicates \\<sigma> p of None \\<Rightarrow> Predicates I p\n            | Some p' \\<Rightarrow>\n                \\<lambda>R. \\<nu> \\<in> fml_sem (extendf I R) p',\n       Contexts =\n         \\<lambda>c.\n            case SContexts \\<sigma> c of None \\<Rightarrow> Contexts I c\n            | Some c' \\<Rightarrow> \\<lambda>R. fml_sem (extendc I R) c',\n       Programs =\n         \\<lambda>a.\n            case SPrograms \\<sigma> a of None \\<Rightarrow> Programs I a\n            | Some a' \\<Rightarrow> prog_sem I a',\n       ODEs =\n         \\<lambda>ode.\n            case SODEs \\<sigma> ode of None \\<Rightarrow> ODEs I ode\n            | Some ode' \\<Rightarrow> ODE_sem I ode',\n       ODEBV =\n         \\<lambda>ode.\n            case SODEs \\<sigma> ode of None \\<Rightarrow> ODEBV I ode\n            | Some ode' \\<Rightarrow> ODE_vars I ode'\\<rparr>", "using dsem_to_ssem[OF sfree]"], ["proof (prove)\nusing this:\n  SFunctions \\<sigma> ?i7 = Some ?\\<theta> \\<Longrightarrow>\n  dterm_sem ?I ?\\<theta> ?\\<nu> = sterm_sem ?I ?\\<theta> (fst ?\\<nu>)\n\ngoal (1 subgoal):\n 1. local.adjoint I \\<sigma> \\<nu> =\n    \\<lparr>Functions =\n              \\<lambda>f.\n                 case SFunctions \\<sigma> f of\n                 None \\<Rightarrow> Functions I f\n                 | Some f' \\<Rightarrow>\n                     \\<lambda>R. sterm_sem (extendf I R) f' (fst \\<nu>),\n       Predicates =\n         \\<lambda>p.\n            case SPredicates \\<sigma> p of None \\<Rightarrow> Predicates I p\n            | Some p' \\<Rightarrow>\n                \\<lambda>R. \\<nu> \\<in> fml_sem (extendf I R) p',\n       Contexts =\n         \\<lambda>c.\n            case SContexts \\<sigma> c of None \\<Rightarrow> Contexts I c\n            | Some c' \\<Rightarrow> \\<lambda>R. fml_sem (extendc I R) c',\n       Programs =\n         \\<lambda>a.\n            case SPrograms \\<sigma> a of None \\<Rightarrow> Programs I a\n            | Some a' \\<Rightarrow> prog_sem I a',\n       ODEs =\n         \\<lambda>ode.\n            case SODEs \\<sigma> ode of None \\<Rightarrow> ODEs I ode\n            | Some ode' \\<Rightarrow> ODE_sem I ode',\n       ODEBV =\n         \\<lambda>ode.\n            case SODEs \\<sigma> ode of None \\<Rightarrow> ODEBV I ode\n            | Some ode' \\<Rightarrow> ODE_vars I ode'\\<rparr>", "by (cases \\<nu>) (auto simp add: adjoint_def fun_eq_iff split: option.split)"], ["", "lemma adjointFO_free:\"(\\<And>i. dfree (\\<sigma> i)) \\<Longrightarrow> (adjointFO I \\<sigma> \\<nu> =\n\\<lparr>Functions =   (\\<lambda>f. case f of Inl f' \\<Rightarrow> Functions I f' | Inr f' \\<Rightarrow> (\\<lambda>_. sterm_sem I (\\<sigma> f') (fst \\<nu>))),\n Predicates = Predicates I,\n Contexts = Contexts I,\n Programs = Programs I,\n ODEs = ODEs I,\n ODEBV = ODEBV I\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. dfree (\\<sigma> i)) \\<Longrightarrow>\n    adjointFO I \\<sigma> \\<nu> =\n    \\<lparr>Functions =\n              \\<lambda>f.\n                 case f of Inl f' \\<Rightarrow> Functions I f'\n                 | Inr f' \\<Rightarrow>\n                     \\<lambda>_. sterm_sem I (\\<sigma> f') (fst \\<nu>),\n       Predicates = Predicates I, Contexts = Contexts I,\n       Programs = Programs I, ODEs = ODEs I, ODEBV = ODEBV I\\<rparr>", "by (auto simp add: dsem_to_ssem adjointFO_def)"], ["", "definition PFadjoint::\"('sf, 'sc, 'sz) interp \\<Rightarrow> ('d::finite \\<Rightarrow> ('sf, 'sc, 'sz) formula) \\<Rightarrow> ('sf, 'sc  + 'd, 'sz) interp\" \nwhere \"PFadjoint I \\<sigma> =\n\\<lparr>Functions =  Functions I,\n Predicates = Predicates I,\n Contexts = (\\<lambda>f. case f of Inl f' \\<Rightarrow> Contexts I f' | Inr f' \\<Rightarrow> (\\<lambda>_. fml_sem I (\\<sigma> f'))),\n Programs = Programs I,\n ODEs = ODEs I,\n ODEBV = ODEBV I\\<rparr>\""], ["", "fun Ssubst::\"('sf, 'sc, 'sz) sequent \\<Rightarrow> ('sf,'sc,'sz) subst \\<Rightarrow> ('sf,'sc,'sz) sequent\"\nwhere \"Ssubst (\\<Gamma>,\\<Delta>) \\<sigma> = (map (\\<lambda> \\<phi>. Fsubst \\<phi> \\<sigma>) \\<Gamma>, map (\\<lambda> \\<phi>. Fsubst \\<phi> \\<sigma>) \\<Delta>)\""], ["", "fun Rsubst::\"('sf, 'sc, 'sz) rule \\<Rightarrow> ('sf,'sc,'sz) subst \\<Rightarrow> ('sf,'sc,'sz) rule\"\nwhere \"Rsubst (SG,C) \\<sigma> = (map (\\<lambda> \\<phi>. Ssubst \\<phi> \\<sigma>) SG, Ssubst C \\<sigma>)\""], ["", "definition Sadmit::\"('sf,'sc,'sz) subst \\<Rightarrow> ('sf,'sc,'sz) sequent \\<Rightarrow> bool\"\nwhere \"Sadmit \\<sigma> S \\<longleftrightarrow> ((\\<forall>i. i \\<ge> 0 \\<longrightarrow> i < length (fst S) \\<longrightarrow> Fadmit \\<sigma> (nth (fst S) i))\n                      \\<and>(\\<forall>i. i \\<ge> 0 \\<longrightarrow> i < length (snd S) \\<longrightarrow> Fadmit \\<sigma> (nth (snd S) i)))\""], ["", "definition Radmit::\"('sf,'sc,'sz) subst \\<Rightarrow> ('sf,'sc,'sz) rule \\<Rightarrow> bool\"\nwhere \"Radmit \\<sigma> R \\<longleftrightarrow> (((\\<forall>i. i \\<ge> 0 \\<longrightarrow> i < length (fst R) \\<longrightarrow> Sadmit \\<sigma> (nth (fst R) i)) \n                   \\<and> Sadmit \\<sigma> (snd R)))\""], ["", "end"], ["", "end"]]}