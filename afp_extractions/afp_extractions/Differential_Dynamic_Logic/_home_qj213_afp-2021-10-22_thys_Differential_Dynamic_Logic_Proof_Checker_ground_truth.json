{"file_name": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic/Proof_Checker.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic", "problem_names": ["lemma sound_weaken_gen:\"\\<And>A B C. sublist A B \\<Longrightarrow> sound (A, C) \\<Longrightarrow> sound (B,C)\"", "lemma sound_weaken:\"\\<And>SG SGS C. sound (SGS, C) \\<Longrightarrow> sound (SG # SGS, C)\"", "lemma member_filter:\"\\<And>P. List.member (filter P L) x \\<Longrightarrow> List.member L x\"", "lemma nth_member:\"n < List.length L \\<Longrightarrow> List.member L (List.nth L n)\"", "lemma mem_appL:\"List.member A x \\<Longrightarrow> List.member (A @ B) x\"", "lemma sound_weaken_appR:\"\\<And>SG SGS C. sound (SG, C) \\<Longrightarrow> sound (SG @ SGS, C)\"", "lemma start_proof_sound:\"sound (start_proof S)\"", "lemma axiom_safe:\"fsafe (get_axiom a)\"", "lemma axiom_valid:\"valid (get_axiom a)\"", "lemma close_sub:\"sublist (close \\<Gamma> \\<phi>) \\<Gamma>\"", "lemma close_app_comm:\"close (A @ B) x  = close A x @ close B x\"", "lemma close_provable_sound:\"sound (SG, C) \\<Longrightarrow> sound (close SG \\<phi>, \\<phi>) \\<Longrightarrow> sound (close SG \\<phi>, C)\"", "lemmas [prover] = axiom_defs Box_def Or_def Implies_def filter_append ssafe_def SDom_def FUadmit_def PFUadmit_def id_simps", "lemma mem_sing[member_intros]:\"\\<And>x. List.member [x] x\"", "lemma mem_appR[member_intros]:\"\\<And>A B x. List.member B x \\<Longrightarrow> List.member (A @ B) x\"", "lemma mem_filter[member_intros]:\"\\<And>A P x. P x \\<Longrightarrow> List.member A x \\<Longrightarrow> List.member (filter P A) x\"", "lemma sound_weaken_appL:\"\\<And>SG SGS C. sound (SGS, C) \\<Longrightarrow> sound (SG @ SGS, C)\"", "lemma fml_seq_valid:\"valid \\<phi> \\<Longrightarrow> seq_valid ([], [\\<phi>])\"", "lemma closeI_provable_sound:\"\\<And>i. sound (SG, C) \\<Longrightarrow> sound (closeI SG i, (nth SG i)) \\<Longrightarrow> sound (closeI SG i, C)\"", "lemma valid_to_sound:\"seq_valid A \\<Longrightarrow> sound (B, A)\"", "lemma closeI_valid_sound:\"\\<And>i. sound (SG, C) \\<Longrightarrow> seq_valid (nth SG i) \\<Longrightarrow> sound (closeI SG i, C)\"", "lemma close_nonmember_eq:\"\\<not>(List.member A a) \\<Longrightarrow> close A a = A\"", "lemma close_noneq_nonempty:\"List.member A x \\<Longrightarrow> x \\<noteq> a \\<Longrightarrow> close A a \\<noteq> []\"", "lemma close_app_neq:\"List.member A x \\<Longrightarrow> x \\<noteq> a \\<Longrightarrow> close (A @ B) a \\<noteq> B\"", "lemma member_singD:\"\\<And>x P. P x \\<Longrightarrow> (\\<And>y. List.member [x] y \\<Longrightarrow> P y)\"", "lemma fst_neq:\"A \\<noteq> B \\<Longrightarrow> (A,C) \\<noteq> (B,D)\"", "lemma lrule_sound: \"lrule_ok SG C i j L \\<Longrightarrow> i < length SG \\<Longrightarrow> j < length (fst (SG ! i)) \\<Longrightarrow> sound (SG,C) \\<Longrightarrow> sound (close (append SG (Lrule_result L j (nth SG i))) (nth SG i), C)\"", "lemma rrule_sound: \"rrule_ok SG C i j L \\<Longrightarrow> i < length SG \\<Longrightarrow> j < length (snd (SG ! i)) \\<Longrightarrow> sound (SG,C) \\<Longrightarrow> sound (close (append SG (Rrule_result L j (nth SG i))) (nth SG i), C)\"", "lemma step_sound:\"step_ok R i S \\<Longrightarrow> i \\<ge> 0 \\<Longrightarrow> i < length (fst R) \\<Longrightarrow> sound R \\<Longrightarrow> sound (step_result R (i,S))\"", "lemma deriv_sound:\"deriv_ok R D \\<Longrightarrow> sound R \\<Longrightarrow> sound (deriv_result R D)\"", "lemma proof_sound:\"proof_ok Pf \\<Longrightarrow> sound (proof_result Pf)\"", "lemma DIAndSound_lemma:\"sound (proof_result (proof_take 61 DIAndProof))\"", "lemma CE_result_correct:\"proof_result CEProof = ([],([],[CEReq]))\"", "lemma diffconst_result_correct:\"proof_result DiffConstProof = ([], ([],[Equals (Differential (Const 0)) (Const 0)]))\"", "lemma diffconst_sound_lemma:\"sound (proof_result DiffConstProof)\"", "lemma valid_of_sound:\"sound ([], ([],[\\<phi>])) \\<Longrightarrow> valid \\<phi>\"", "lemma almost_diff_const_sound:\"sound ([], ([], [Equals (Differential (Const 0)) (Const 0)]))\"", "lemma almost_diff_const:\"valid (Equals (Differential (Const 0)) (Const 0))\"", "lemma almost_diff_var:\"valid (Equals (Differential (trm.Var vid1)) ($' vid1))\"", "lemma CESound_lemma:\"sound (proof_result CEProof)\"", "lemma sound_to_valid:\"sound ([], ([], [\\<phi>])) \\<Longrightarrow> valid \\<phi>\"", "lemma CE1pre:\"sound ([], ([], [CEReq]))\"", "lemma CE1pre_valid:\"valid CEReq\"", "lemma CE1pre_valid2:\"valid (! (! (Geq (Differential (trm.Var vid1)) (Differential (Const 0)) && Geq ($' vid1) (Const 0)) &&\n              ! (! (Geq (Differential (trm.Var vid1)) (Differential (Const 0))) && ! (Geq ($' vid1) (Const 0))))) \"", "lemma systemdesubst_correct:\"\\<exists> ODE.(([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]] ((Geq (Differential (Var vid1)) (Differential (Const 0))))) \\<leftrightarrow>\n ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]]\n    [[DiffAssign vid1 (f0 fid1)]](Geq (Differential (Var vid1)) (Differential (Const 0)))))\n    = Fsubst ((([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE) (p1 vid2 vid1)]] (P pid1)) \\<leftrightarrow>\n          ([[EvolveODE ((OProd  (OSing vid1 (f1 fid1 vid1))) ODE) (p1 vid2 vid1)]]\n               [[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))) SystemDESubst\"", "lemma subst_imp_simp:\"Fsubst (Implies p q) \\<sigma> = (Implies (Fsubst p \\<sigma>) (Fsubst q \\<sigma>))\"", "lemma subst_equiv_simp:\"Fsubst (Equiv p q) \\<sigma> = (Equiv (Fsubst p \\<sigma>) (Fsubst q \\<sigma>))\"", "lemma subst_box_simp:\"Fsubst (Box p q) \\<sigma> = (Box (Psubst p \\<sigma>) (Fsubst q \\<sigma>))\"", "lemma pfsubst_box_simp:\"PFsubst (Box p q) \\<sigma> = (Box (PPsubst p \\<sigma>) (PFsubst q \\<sigma>))\"", "lemma pfsubst_imp_simp:\"PFsubst (Implies p q) \\<sigma> = (Implies (PFsubst p \\<sigma>) (PFsubst q \\<sigma>))\"", "lemma SystemCESubstOK:\n  \"step_ok \n  ([([],[Equiv (Implies(And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0))) ([[DiffAssign vid1 (Function fid1 empty)]]( SystemCEFml1))) \n         (Implies(And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0))) ([[DiffAssign vid1 (Function fid1 empty)]]( (SystemCEFml2))))\n         ])],\n         ([],[]))\n         \n         0 \n         (CE SystemCEFml1 SystemCEFml2 SystemCESubst)\"", "lemma SystemDICutCorrect:\"SystemDICut = Fsubst DIGeqaxiom SystemDISubst\"", "lemma system_result_correct:\"proof_result SystemProof = \n  ([],\n  ([],[Implies (And (Geq (Var vid1) (Const 0)) (Geq (f0 fid1) (Const 0)))\n        ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (TT)]]Geq (Var vid1) (Const 0))]))\"", "lemma SystemSound_lemma:\"sound (proof_result SystemProof)\"", "lemma system_sound:\"sound ([], SystemConcl)\"", "lemma DIAnd_result_correct:\"proof_result (proof_take 61 DIAndProof) = DIAnd\"", "theorem DIAnd_sound: \"sound DIAnd\""], "translations": [["", "lemma sound_weaken_gen:\"\\<And>A B C. sublist A B \\<Longrightarrow> sound (A, C) \\<Longrightarrow> sound (B,C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B C.\n       \\<lbrakk>sublist A B; sound (A, C)\\<rbrakk>\n       \\<Longrightarrow> sound (B, C)", "proof (rule soundI_mem)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B C I.\n       \\<lbrakk>sublist A B; sound (A, C); is_interp I;\n        \\<And>\\<phi>.\n           List.member B \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "fix A B::\"('sf,'sc,'sz) sequent list\" \n    and C::\"('sf,'sc,'sz) sequent\" \n    and I::\"('sf,'sc,'sz) interp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B C I.\n       \\<lbrakk>sublist A B; sound (A, C); is_interp I;\n        \\<And>\\<phi>.\n           List.member B \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume sub:\"sublist A B\""], ["proof (state)\nthis:\n  sublist A B\n\ngoal (1 subgoal):\n 1. \\<And>A B C I.\n       \\<lbrakk>sublist A B; sound (A, C); is_interp I;\n        \\<And>\\<phi>.\n           List.member B \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>A B C I.\n       \\<lbrakk>sublist A B; sound (A, C); is_interp I;\n        \\<And>\\<phi>.\n           List.member B \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume \"sound (A, C)\""], ["proof (state)\nthis:\n  sound (A, C)\n\ngoal (1 subgoal):\n 1. \\<And>A B C I.\n       \\<lbrakk>sublist A B; sound (A, C); is_interp I;\n        \\<And>\\<phi>.\n           List.member B \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "then"], ["proof (chain)\npicking this:\n  sound (A, C)", "have soundC:\"(\\<And>\\<phi>. List.member A \\<phi> \\<Longrightarrow> seq_sem I \\<phi> = UNIV) \\<Longrightarrow> seq_sem I C = UNIV\""], ["proof (prove)\nusing this:\n  sound (A, C)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        List.member A \\<phi> \\<Longrightarrow>\n        seq_sem I \\<phi> = UNIV) \\<Longrightarrow>\n    seq_sem I C = UNIV", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<phi>.\n                List.member A \\<phi> \\<Longrightarrow>\n                fml_sem I (seq2fml \\<phi>) = UNIV;\n     sound (A, C)\\<rbrakk>\n    \\<Longrightarrow> fml_sem I (seq2fml C) = UNIV", "apply(drule soundD_mem)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>\\<phi>.\n        List.member A \\<phi> \\<Longrightarrow>\n        fml_sem I (seq2fml \\<phi>) = UNIV) \\<Longrightarrow>\n    is_interp ?I1\n 2. \\<And>\\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   List.member A \\<phi> \\<Longrightarrow>\n                   fml_sem I (seq2fml \\<phi>) = UNIV;\n        List.member A \\<phi>\\<rbrakk>\n       \\<Longrightarrow> seq_sem ?I1 \\<phi> = UNIV\n 3. \\<lbrakk>\\<And>\\<phi>.\n                List.member A \\<phi> \\<Longrightarrow>\n                fml_sem I (seq2fml \\<phi>) = UNIV;\n     seq_sem ?I1 C = UNIV\\<rbrakk>\n    \\<Longrightarrow> fml_sem I (seq2fml C) = UNIV", "by (auto simp add: good)"], ["proof (state)\nthis:\n  (\\<And>\\<phi>.\n      List.member A \\<phi> \\<Longrightarrow>\n      seq_sem I \\<phi> = UNIV) \\<Longrightarrow>\n  seq_sem I C = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>A B C I.\n       \\<lbrakk>sublist A B; sound (A, C); is_interp I;\n        \\<And>\\<phi>.\n           List.member B \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume SG:\"(\\<And>\\<phi>. List.member B \\<phi> \\<Longrightarrow> seq_sem I \\<phi> = UNIV)\""], ["proof (state)\nthis:\n  List.member B ?\\<phi>7 \\<Longrightarrow> seq_sem I ?\\<phi>7 = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>A B C I.\n       \\<lbrakk>sublist A B; sound (A, C); is_interp I;\n        \\<And>\\<phi>.\n           List.member B \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "show \"seq_sem I C = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_sem I C = UNIV", "using soundC SG sub"], ["proof (prove)\nusing this:\n  (\\<And>\\<phi>.\n      List.member A \\<phi> \\<Longrightarrow>\n      seq_sem I \\<phi> = UNIV) \\<Longrightarrow>\n  seq_sem I C = UNIV\n  List.member B ?\\<phi>7 \\<Longrightarrow> seq_sem I ?\\<phi>7 = UNIV\n  sublist A B\n\ngoal (1 subgoal):\n 1. seq_sem I C = UNIV", "unfolding sublist_def"], ["proof (prove)\nusing this:\n  (\\<And>\\<phi>.\n      List.member A \\<phi> \\<Longrightarrow>\n      seq_sem I \\<phi> = UNIV) \\<Longrightarrow>\n  seq_sem I C = UNIV\n  List.member B ?\\<phi>7 \\<Longrightarrow> seq_sem I ?\\<phi>7 = UNIV\n  \\<forall>x. List.member A x \\<longrightarrow> List.member B x\n\ngoal (1 subgoal):\n 1. seq_sem I C = UNIV", "by auto"], ["proof (state)\nthis:\n  seq_sem I C = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sound_weaken:\"\\<And>SG SGS C. sound (SGS, C) \\<Longrightarrow> sound (SG # SGS, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>SG SGS C. sound (SGS, C) \\<Longrightarrow> sound (SG # SGS, C)", "subgoal for SG SGS C"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SGS, C) \\<Longrightarrow> sound (SG # SGS, C)", "apply(induction SGS)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound ([], C) \\<Longrightarrow> sound ([SG], C)\n 2. \\<And>a SGS.\n       \\<lbrakk>sound (SGS, C) \\<Longrightarrow> sound (SG # SGS, C);\n        sound (a # SGS, C)\\<rbrakk>\n       \\<Longrightarrow> sound (SG # a # SGS, C)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([], C) \\<Longrightarrow> sound ([SG], C)", "unfolding sound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I.\n       is_interp I \\<longrightarrow>\n       (\\<forall>i\\<ge>0.\n           i < length (fst ([], C)) \\<longrightarrow>\n           seq_sem I (fst ([], C) ! i) = UNIV) \\<longrightarrow>\n       seq_sem I (snd ([], C)) = UNIV \\<Longrightarrow>\n    \\<forall>I.\n       is_interp I \\<longrightarrow>\n       (\\<forall>i\\<ge>0.\n           i < length (fst ([SG], C)) \\<longrightarrow>\n           seq_sem I (fst ([SG], C) ! i) = UNIV) \\<longrightarrow>\n       seq_sem I (snd ([SG], C)) = UNIV", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a SGS.\n       \\<lbrakk>sound (SGS, C) \\<Longrightarrow> sound (SG # SGS, C);\n        sound (a # SGS, C)\\<rbrakk>\n       \\<Longrightarrow> sound (SG # a # SGS, C)", "subgoal for SG2 SGS"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound (SGS, C) \\<Longrightarrow> sound (SG # SGS, C);\n     sound (SG2 # SGS, C)\\<rbrakk>\n    \\<Longrightarrow> sound (SG # SG2 # SGS, C)", "unfolding sound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I.\n                is_interp I \\<longrightarrow>\n                (\\<forall>i\\<ge>0.\n                    i < length (fst (SGS, C)) \\<longrightarrow>\n                    seq_sem I (fst (SGS, C) ! i) = UNIV) \\<longrightarrow>\n                seq_sem I (snd (SGS, C)) = UNIV \\<Longrightarrow>\n             \\<forall>I.\n                is_interp I \\<longrightarrow>\n                (\\<forall>i\\<ge>0.\n                    i < length (fst (SG # SGS, C)) \\<longrightarrow>\n                    seq_sem I (fst (SG # SGS, C) ! i) =\n                    UNIV) \\<longrightarrow>\n                seq_sem I (snd (SG # SGS, C)) = UNIV;\n     \\<forall>I.\n        is_interp I \\<longrightarrow>\n        (\\<forall>i\\<ge>0.\n            i < length (fst (SG2 # SGS, C)) \\<longrightarrow>\n            seq_sem I (fst (SG2 # SGS, C) ! i) = UNIV) \\<longrightarrow>\n        seq_sem I (snd (SG2 # SGS, C)) = UNIV\\<rbrakk>\n    \\<Longrightarrow> \\<forall>I.\n                         is_interp I \\<longrightarrow>\n                         (\\<forall>i\\<ge>0.\n                             i < length\n                                  (fst (SG # SG2 # SGS,\n  C)) \\<longrightarrow>\n                             seq_sem I (fst (SG # SG2 # SGS, C) ! i) =\n                             UNIV) \\<longrightarrow>\n                         seq_sem I (snd (SG # SG2 # SGS, C)) = UNIV", "by (metis fst_conv le0 length_Cons not_less_eq nth_Cons_Suc snd_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma member_filter:\"\\<And>P. List.member (filter P L) x \\<Longrightarrow> List.member L x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. List.member (filter P L) x \\<Longrightarrow> List.member L x", "apply(induction L, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L P.\n       \\<lbrakk>\\<And>P.\n                   List.member (filter P L) x \\<Longrightarrow>\n                   List.member L x;\n        List.member (if P a then a # filter P L else filter P L) x\\<rbrakk>\n       \\<Longrightarrow> List.member (a # L) x", "by(metis (full_types) member_rec(1))"], ["", "lemma nth_member:\"n < List.length L \\<Longrightarrow> List.member L (List.nth L n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length L \\<Longrightarrow> List.member L (L ! n)", "apply(induction L, auto simp add: member_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>n < length L \\<Longrightarrow> List.member L (L ! n);\n        n < Suc (length L); \\<not> List.member L ((a # L) ! n)\\<rbrakk>\n       \\<Longrightarrow> a = (a # L) ! n", "by (metis in_set_member length_Cons nth_mem set_ConsD)"], ["", "lemma mem_appL:\"List.member A x \\<Longrightarrow> List.member (A @ B) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member A x \\<Longrightarrow> List.member (A @ B) x", "by(induction A, auto simp add: member_rec)"], ["", "lemma sound_weaken_appR:\"\\<And>SG SGS C. sound (SG, C) \\<Longrightarrow> sound (SG @ SGS, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>SG SGS C. sound (SG, C) \\<Longrightarrow> sound (SG @ SGS, C)", "subgoal for SG SGS C"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow> sound (SG @ SGS, C)", "apply(rule sound_weaken_gen)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C) \\<Longrightarrow> sublist ?A (SG @ SGS)\n 2. sound (SG, C) \\<Longrightarrow> sound (?A, C)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow> sublist SG (SG @ SGS)", "unfolding sublist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow>\n    \\<forall>x. List.member SG x \\<longrightarrow> List.member (SG @ SGS) x", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sound (SG, C) \\<Longrightarrow>\n       List.member SG x \\<longrightarrow> List.member (SG @ SGS) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow>\n    List.member SG x \\<longrightarrow> List.member (SG @ SGS) x", "using mem_appL[of SG x SGS]"], ["proof (prove)\nusing this:\n  List.member SG x \\<Longrightarrow> List.member (SG @ SGS) x\n\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow>\n    List.member SG x \\<longrightarrow> List.member (SG @ SGS) x", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun start_proof::\"('sf,'sc,'sz) sequent \\<Rightarrow> ('sf,'sc,'sz) rule\"\nwhere \"start_proof S = ([S], S)\""], ["", "lemma start_proof_sound:\"sound (start_proof S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (start_proof S)", "unfolding sound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I.\n       is_interp I \\<longrightarrow>\n       (\\<forall>i\\<ge>0.\n           i < length (fst (start_proof S)) \\<longrightarrow>\n           seq_sem I (fst (start_proof S) ! i) = UNIV) \\<longrightarrow>\n       seq_sem I (snd (start_proof S)) = UNIV", "by auto"], ["", "section \\<open>Proof Checker Implementation\\<close>"], ["", "datatype axiom =\n  AloopIter | AI | Atest | Abox | Achoice | AK | AV | Aassign | Adassign\n| AdConst | AdPlus | AdMult\n| ADW | ADE | ADC | ADS | ADIGeq | ADIGr | ADG"], ["", "fun get_axiom:: \"axiom \\<Rightarrow> ('sf,'sc,'sz) formula\"\nwhere \n  \"get_axiom AloopIter = loop_iterate_axiom\"\n| \"get_axiom AI = Iaxiom\"\n| \"get_axiom Atest = test_axiom\"\n| \"get_axiom Abox = box_axiom\"\n| \"get_axiom Achoice = choice_axiom\"\n| \"get_axiom AK = Kaxiom\"\n| \"get_axiom AV = Vaxiom\"\n| \"get_axiom Aassign = assign_axiom\"\n| \"get_axiom Adassign = diff_assign_axiom\" \n| \"get_axiom AdConst = diff_const_axiom\"\n| \"get_axiom AdPlus = diff_plus_axiom\"\n| \"get_axiom AdMult = diff_times_axiom\"\n| \"get_axiom ADW = DWaxiom\"\n| \"get_axiom ADE = DEaxiom\"\n| \"get_axiom ADC = DCaxiom\"\n| \"get_axiom ADS = DSaxiom\"\n| \"get_axiom ADIGeq = DIGeqaxiom\"\n| \"get_axiom ADIGr = DIGraxiom\"\n| \"get_axiom ADG = DGaxiom\""], ["", "lemma axiom_safe:\"fsafe (get_axiom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fsafe (get_axiom a)", "by(cases a, auto simp add: axiom_defs Box_def Or_def Equiv_def Implies_def empty_def Equals_def f1_def p1_def P_def f0_def expand_singleton Forall_def Greater_def id_simps)"], ["", "(*apply(cases a)\n  prefer 9\n  subgoal\n    apply(simp only: get_axiom.simps diff_assign_axiom_def Equiv_def Or_def Box_def)\n    apply(simp only: fsafe_Not_simps fsafe_Diamond_simps fsafe_And_simps)\n    apply(rule conjI)+\n    subgoal apply(simp only: hpsafe_DiffAssign_simps dsafe_Fun_simps empty_def dsafe_Const) by auto\n    \n    *)\n   (*auto simp add: loop_iterate_axiom_def Iaxiom_def diff_assign_axiom_def test_axiom_def choice_axiom_def box_axiom_def empty_def Kaxiom_def Vaxiom_def assign_axiom_def diff_const_axiom_def diff_plus_axiom_def diff_times_axiom_def DWaxiom_def Equals_def state_fun_def DEaxiom_def DCaxiom_def DSaxiom_def DIGeqaxiom_def DIGraxiom_def f1_def p1_def P_def expand_singleton f0_def Forall_def DGaxiom_def Equiv_def Implies_def Or_def Box_def Greater_def vne12*)"], ["", "lemma axiom_valid:\"valid (get_axiom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "proof (cases a)"], ["proof (state)\ngoal (19 subgoals):\n 1. a = AloopIter \\<Longrightarrow> valid (get_axiom a)\n 2. a = AI \\<Longrightarrow> valid (get_axiom a)\n 3. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 4. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 5. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 6. a = AK \\<Longrightarrow> valid (get_axiom a)\n 7. a = AV \\<Longrightarrow> valid (get_axiom a)\n 8. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 9. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdConst \\<Longrightarrow> valid (get_axiom a)\nA total of 19 subgoals...", "case AloopIter"], ["proof (state)\nthis:\n  a = AloopIter\n\ngoal (19 subgoals):\n 1. a = AloopIter \\<Longrightarrow> valid (get_axiom a)\n 2. a = AI \\<Longrightarrow> valid (get_axiom a)\n 3. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 4. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 5. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 6. a = AK \\<Longrightarrow> valid (get_axiom a)\n 7. a = AV \\<Longrightarrow> valid (get_axiom a)\n 8. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 9. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdConst \\<Longrightarrow> valid (get_axiom a)\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = AloopIter", "show ?thesis"], ["proof (prove)\nusing this:\n  a = AloopIter\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: loop_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (18 subgoals):\n 1. a = AI \\<Longrightarrow> valid (get_axiom a)\n 2. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 3. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 4. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 5. a = AK \\<Longrightarrow> valid (get_axiom a)\n 6. a = AV \\<Longrightarrow> valid (get_axiom a)\n 7. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 8. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. a = AI \\<Longrightarrow> valid (get_axiom a)\n 2. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 3. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 4. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 5. a = AK \\<Longrightarrow> valid (get_axiom a)\n 6. a = AV \\<Longrightarrow> valid (get_axiom a)\n 7. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 8. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\nA total of 18 subgoals...", "case AI"], ["proof (state)\nthis:\n  a = AI\n\ngoal (18 subgoals):\n 1. a = AI \\<Longrightarrow> valid (get_axiom a)\n 2. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 3. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 4. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 5. a = AK \\<Longrightarrow> valid (get_axiom a)\n 6. a = AV \\<Longrightarrow> valid (get_axiom a)\n 7. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 8. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = AI", "show ?thesis"], ["proof (prove)\nusing this:\n  a = AI\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: I_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (17 subgoals):\n 1. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 2. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 3. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 4. a = AK \\<Longrightarrow> valid (get_axiom a)\n 5. a = AV \\<Longrightarrow> valid (get_axiom a)\n 6. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 7. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdMult \\<Longrightarrow> valid (get_axiom a)\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 2. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 3. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 4. a = AK \\<Longrightarrow> valid (get_axiom a)\n 5. a = AV \\<Longrightarrow> valid (get_axiom a)\n 6. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 7. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdMult \\<Longrightarrow> valid (get_axiom a)\nA total of 17 subgoals...", "case Atest"], ["proof (state)\nthis:\n  a = Atest\n\ngoal (17 subgoals):\n 1. a = Atest \\<Longrightarrow> valid (get_axiom a)\n 2. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 3. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 4. a = AK \\<Longrightarrow> valid (get_axiom a)\n 5. a = AV \\<Longrightarrow> valid (get_axiom a)\n 6. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 7. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 10. a = AdMult \\<Longrightarrow> valid (get_axiom a)\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = Atest", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Atest\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: test_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (16 subgoals):\n 1. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 2. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 3. a = AK \\<Longrightarrow> valid (get_axiom a)\n 4. a = AV \\<Longrightarrow> valid (get_axiom a)\n 5. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 6. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADW \\<Longrightarrow> valid (get_axiom a)\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 2. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 3. a = AK \\<Longrightarrow> valid (get_axiom a)\n 4. a = AV \\<Longrightarrow> valid (get_axiom a)\n 5. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 6. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADW \\<Longrightarrow> valid (get_axiom a)\nA total of 16 subgoals...", "case Abox"], ["proof (state)\nthis:\n  a = Abox\n\ngoal (16 subgoals):\n 1. a = Abox \\<Longrightarrow> valid (get_axiom a)\n 2. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 3. a = AK \\<Longrightarrow> valid (get_axiom a)\n 4. a = AV \\<Longrightarrow> valid (get_axiom a)\n 5. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 6. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 9. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADW \\<Longrightarrow> valid (get_axiom a)\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = Abox", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Abox\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: box_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (15 subgoals):\n 1. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 2. a = AK \\<Longrightarrow> valid (get_axiom a)\n 3. a = AV \\<Longrightarrow> valid (get_axiom a)\n 4. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 5. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADE \\<Longrightarrow> valid (get_axiom a)\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 2. a = AK \\<Longrightarrow> valid (get_axiom a)\n 3. a = AV \\<Longrightarrow> valid (get_axiom a)\n 4. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 5. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADE \\<Longrightarrow> valid (get_axiom a)\nA total of 15 subgoals...", "case Achoice"], ["proof (state)\nthis:\n  a = Achoice\n\ngoal (15 subgoals):\n 1. a = Achoice \\<Longrightarrow> valid (get_axiom a)\n 2. a = AK \\<Longrightarrow> valid (get_axiom a)\n 3. a = AV \\<Longrightarrow> valid (get_axiom a)\n 4. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 5. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 8. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADE \\<Longrightarrow> valid (get_axiom a)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = Achoice", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Achoice\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: choice_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (14 subgoals):\n 1. a = AK \\<Longrightarrow> valid (get_axiom a)\n 2. a = AV \\<Longrightarrow> valid (get_axiom a)\n 3. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 4. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADC \\<Longrightarrow> valid (get_axiom a)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. a = AK \\<Longrightarrow> valid (get_axiom a)\n 2. a = AV \\<Longrightarrow> valid (get_axiom a)\n 3. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 4. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADC \\<Longrightarrow> valid (get_axiom a)\nA total of 14 subgoals...", "case AK"], ["proof (state)\nthis:\n  a = AK\n\ngoal (14 subgoals):\n 1. a = AK \\<Longrightarrow> valid (get_axiom a)\n 2. a = AV \\<Longrightarrow> valid (get_axiom a)\n 3. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 4. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 7. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADC \\<Longrightarrow> valid (get_axiom a)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = AK", "show ?thesis"], ["proof (prove)\nusing this:\n  a = AK\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: K_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (13 subgoals):\n 1. a = AV \\<Longrightarrow> valid (get_axiom a)\n 2. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 3. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADS \\<Longrightarrow> valid (get_axiom a)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. a = AV \\<Longrightarrow> valid (get_axiom a)\n 2. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 3. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADS \\<Longrightarrow> valid (get_axiom a)\nA total of 13 subgoals...", "case AV"], ["proof (state)\nthis:\n  a = AV\n\ngoal (13 subgoals):\n 1. a = AV \\<Longrightarrow> valid (get_axiom a)\n 2. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 3. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 6. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADS \\<Longrightarrow> valid (get_axiom a)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = AV", "show ?thesis"], ["proof (prove)\nusing this:\n  a = AV\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: V_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (12 subgoals):\n 1. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 2. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 2. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\nA total of 12 subgoals...", "case Aassign"], ["proof (state)\nthis:\n  a = Aassign\n\ngoal (12 subgoals):\n 1. a = Aassign \\<Longrightarrow> valid (get_axiom a)\n 2. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 5. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = Aassign", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Aassign\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: assign_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (11 subgoals):\n 1. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\nA total of 11 subgoals...", "case Adassign"], ["proof (state)\nthis:\n  a = Adassign\n\ngoal (11 subgoals):\n 1. a = Adassign \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 4. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  a = Adassign", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Adassign\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: diff_assign_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (10 subgoals):\n 1. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case AdConst"], ["proof (state)\nthis:\n  a = AdConst\n\ngoal (10 subgoals):\n 1. a = AdConst \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 3. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 10. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = AdConst", "show ?thesis"], ["proof (prove)\nusing this:\n  a = AdConst\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: diff_const_axiom_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (9 subgoals):\n 1. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case AdPlus"], ["proof (state)\nthis:\n  a = AdPlus\n\ngoal (9 subgoals):\n 1. a = AdPlus \\<Longrightarrow> valid (get_axiom a)\n 2. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 9. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = AdPlus", "show ?thesis"], ["proof (prove)\nusing this:\n  a = AdPlus\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: diff_plus_axiom_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (8 subgoals):\n 1. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case AdMult"], ["proof (state)\nthis:\n  a = AdMult\n\ngoal (8 subgoals):\n 1. a = AdMult \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 8. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = AdMult", "show ?thesis"], ["proof (prove)\nusing this:\n  a = AdMult\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: diff_times_axiom_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (7 subgoals):\n 1. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case ADW"], ["proof (state)\nthis:\n  a = ADW\n\ngoal (7 subgoals):\n 1. a = ADW \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 7. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = ADW", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ADW\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: DW_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (6 subgoals):\n 1. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case ADE"], ["proof (state)\nthis:\n  a = ADE\n\ngoal (6 subgoals):\n 1. a = ADE \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 6. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = ADE", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ADE\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: DE_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (5 subgoals):\n 1. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case ADC"], ["proof (state)\nthis:\n  a = ADC\n\ngoal (5 subgoals):\n 1. a = ADC \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 5. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = ADC", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ADC\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: DC_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (4 subgoals):\n 1. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case ADS"], ["proof (state)\nthis:\n  a = ADS\n\ngoal (4 subgoals):\n 1. a = ADS \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 4. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = ADS", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ADS\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: DS_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (3 subgoals):\n 1. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case ADIGeq"], ["proof (state)\nthis:\n  a = ADIGeq\n\ngoal (3 subgoals):\n 1. a = ADIGeq \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 3. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = ADIGeq", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ADIGeq\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: DIGeq_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (2 subgoals):\n 1. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case ADIGr"], ["proof (state)\nthis:\n  a = ADIGr\n\ngoal (2 subgoals):\n 1. a = ADIGr \\<Longrightarrow> valid (get_axiom a)\n 2. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = ADIGr", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ADIGr\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: DIGr_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (1 subgoal):\n 1. a = ADG \\<Longrightarrow> valid (get_axiom a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = ADG \\<Longrightarrow> valid (get_axiom a)", "case ADG"], ["proof (state)\nthis:\n  a = ADG\n\ngoal (1 subgoal):\n 1. a = ADG \\<Longrightarrow> valid (get_axiom a)", "then"], ["proof (chain)\npicking this:\n  a = ADG", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ADG\n\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by (simp add: DG_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal:\nNo subgoals!", "qed"], ["", "datatype rrule = ImplyR | AndR | CohideR | CohideRR | TrueR | EquivR"], ["", "datatype lrule = ImplyL | AndL | EquivForwardL | EquivBackwardL"], ["", "datatype ('a, 'b, 'c) step =\n  Axiom axiom\n| MP\n| G\n| CT\n| CQ  \"('a, 'c) trm\" \"('a, 'c) trm\" \"('a, 'b, 'c) subst\"\n| CE  \"('a, 'b, 'c) formula\" \"('a, 'b, 'c) formula\" \"('a, 'b, 'c) subst\"\n| Skolem\n\\<comment> \\<open>Apply \\<open>Usubst\\<close> to some other (valid) formula\\<close>\n| VSubst \"('a, 'b, 'c) formula\" \"('a, 'b, 'c) subst\"\n| AxSubst axiom \"('a, 'b, 'c) subst\"\n| URename\n| BRename\n| Rrule rrule nat\n| Lrule lrule nat\n| CloseId nat nat\n| Cut \"('a, 'b, 'c) formula\"\n| DEAxiomSchema \"('a,'c) ODE\" \"('a, 'b, 'c) subst\""], ["", "type_synonym ('a, 'b, 'c) derivation = \"(nat * ('a, 'b, 'c) step) list\""], ["", "type_synonym ('a, 'b, 'c) pf = \"('a,'b,'c) sequent * ('a, 'b, 'c) derivation\""], ["", "fun seq_to_string :: \"('sf, 'sc, 'sz) sequent \\<Rightarrow> char list\"\nwhere \"seq_to_string (A,S) = join '', '' (map fml_to_string A) @ '' |- '' @ join '', '' (map fml_to_string S)\""], ["", "fun rule_to_string :: \"('sf, 'sc, 'sz) rule \\<Rightarrow> char list\"\nwhere \"rule_to_string (SG, C) = (join '';;   '' (map seq_to_string SG)) @ ''            '' @  \\<^cancel>\\<open>[char_of_nat 10] @\\<close> seq_to_string C\""], ["", "fun close :: \"'a list \\<Rightarrow> 'a \\<Rightarrow>'a list\"\nwhere \"close L x = filter (\\<lambda>y. y \\<noteq> x) L\""], ["", "fun closeI ::\"'a list \\<Rightarrow> nat \\<Rightarrow>'a list\"\nwhere \"closeI L i = close L (nth L i)\""], ["", "lemma close_sub:\"sublist (close \\<Gamma> \\<phi>) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (close \\<Gamma> \\<phi>) \\<Gamma>", "apply (auto simp add: sublist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member (filter (\\<lambda>y. y \\<noteq> \\<phi>) \\<Gamma>)\n        x \\<Longrightarrow>\n       List.member \\<Gamma> x", "using member_filter"], ["proof (prove)\nusing this:\n  List.member (filter ?P ?L) ?x \\<Longrightarrow> List.member ?L ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member (filter (\\<lambda>y. y \\<noteq> \\<phi>) \\<Gamma>)\n        x \\<Longrightarrow>\n       List.member \\<Gamma> x", "by fastforce"], ["", "lemma close_app_comm:\"close (A @ B) x  = close A x @ close B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close (A @ B) x = close A x @ close B x", "by auto"], ["", "lemma close_provable_sound:\"sound (SG, C) \\<Longrightarrow> sound (close SG \\<phi>, \\<phi>) \\<Longrightarrow> sound (close SG \\<phi>, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>)\\<rbrakk>\n    \\<Longrightarrow> sound (close SG \\<phi>, C)", "proof (rule soundI_mem)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "fix I::\"('sf,'sc,'sz) interp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume S1:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume S2:\"sound (close SG \\<phi>, \\<phi>)\""], ["proof (state)\nthis:\n  sound (close SG \\<phi>, \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "assume SGCs:\"(\\<And>\\<phi>'. List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow> seq_sem I \\<phi>' = UNIV)\""], ["proof (state)\nthis:\n  List.member (close SG \\<phi>) ?\\<phi>'7 \\<Longrightarrow>\n  seq_sem I ?\\<phi>'7 = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "have S\\<phi>:\"seq_sem I \\<phi> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_sem I \\<phi> = UNIV", "using S2"], ["proof (prove)\nusing this:\n  sound (close SG \\<phi>, \\<phi>)\n\ngoal (1 subgoal):\n 1. seq_sem I \\<phi> = UNIV", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (filter (\\<lambda>y. y \\<noteq> \\<phi>) SG, \\<phi>) \\<Longrightarrow>\n    fml_sem I (seq2fml \\<phi>) = UNIV", "apply(drule soundD_mem)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_interp ?I1\n 2. \\<And>\\<phi>'.\n       List.member (filter (\\<lambda>y. y \\<noteq> \\<phi>) SG)\n        \\<phi>' \\<Longrightarrow>\n       seq_sem ?I1 \\<phi>' = UNIV\n 3. seq_sem ?I1 \\<phi> = UNIV \\<Longrightarrow>\n    fml_sem I (seq2fml \\<phi>) = UNIV", "using good"], ["proof (prove)\nusing this:\n  is_interp I\n\ngoal (3 subgoals):\n 1. is_interp ?I1\n 2. \\<And>\\<phi>'.\n       List.member (filter (\\<lambda>y. y \\<noteq> \\<phi>) SG)\n        \\<phi>' \\<Longrightarrow>\n       seq_sem ?I1 \\<phi>' = UNIV\n 3. seq_sem ?I1 \\<phi> = UNIV \\<Longrightarrow>\n    fml_sem I (seq2fml \\<phi>) = UNIV", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member (filter (\\<lambda>y. y \\<noteq> \\<phi>) SG)\n                 (a, b);\n        is_interp I; (aa, ba) \\<in> fml_sem I (foldr (&&) a TT)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "using SGCs UNIV_I"], ["proof (prove)\nusing this:\n  List.member (close SG \\<phi>) ?\\<phi>'7 \\<Longrightarrow>\n  seq_sem I ?\\<phi>'7 = UNIV\n  ?x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member (filter (\\<lambda>y. y \\<noteq> \\<phi>) SG)\n                 (a, b);\n        is_interp I; (aa, ba) \\<in> fml_sem I (foldr (&&) a TT)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "by fastforce"], ["proof (state)\nthis:\n  seq_sem I \\<phi> = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "have mem_close:\"\\<And>P. List.member SG P \\<Longrightarrow> P \\<noteq> \\<phi> \\<Longrightarrow> List.member (close SG \\<phi>) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>List.member SG P; P \\<noteq> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> List.member (close SG \\<phi>) P", "by(induction SG, auto simp add: member_rec)"], ["proof (state)\nthis:\n  \\<lbrakk>List.member SG ?P7; ?P7 \\<noteq> \\<phi>\\<rbrakk>\n  \\<Longrightarrow> List.member (close SG \\<phi>) ?P7\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "have SGs:\"\\<And>P. List.member SG P \\<Longrightarrow> seq_sem I P = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. List.member SG P \\<Longrightarrow> seq_sem I P = UNIV", "subgoal for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member SG P \\<Longrightarrow> seq_sem I P = UNIV", "apply(cases \"P = \\<phi>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List.member SG P; P = \\<phi>\\<rbrakk>\n    \\<Longrightarrow> seq_sem I P = UNIV\n 2. \\<lbrakk>List.member SG P; P \\<noteq> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> seq_sem I P = UNIV", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member SG P; P = \\<phi>\\<rbrakk>\n    \\<Longrightarrow> seq_sem I P = UNIV", "using S\\<phi>"], ["proof (prove)\nusing this:\n  seq_sem I \\<phi> = UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member SG P; P = \\<phi>\\<rbrakk>\n    \\<Longrightarrow> seq_sem I P = UNIV", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member SG P; P \\<noteq> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> seq_sem I P = UNIV", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member SG P; P \\<noteq> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> seq_sem I P = UNIV", "using mem_close[of P] SGCs"], ["proof (prove)\nusing this:\n  \\<lbrakk>List.member SG P; P \\<noteq> \\<phi>\\<rbrakk>\n  \\<Longrightarrow> List.member (close SG \\<phi>) P\n  List.member (close SG \\<phi>) ?\\<phi>'7 \\<Longrightarrow>\n  seq_sem I ?\\<phi>'7 = UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member SG P; P \\<noteq> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> seq_sem I P = UNIV", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  List.member SG ?P7 \\<Longrightarrow> seq_sem I ?P7 = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>sound (SG, C); sound (close SG \\<phi>, \\<phi>); is_interp I;\n        \\<And>\\<phi>'.\n           List.member (close SG \\<phi>) \\<phi>' \\<Longrightarrow>\n           seq_sem I \\<phi>' = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "show \"seq_sem I C = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_sem I C = UNIV", "using S1"], ["proof (prove)\nusing this:\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. seq_sem I C = UNIV", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow> fml_sem I (seq2fml C) = UNIV", "apply(drule soundD_mem)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_interp ?I1\n 2. \\<And>\\<phi>.\n       List.member SG \\<phi> \\<Longrightarrow> seq_sem ?I1 \\<phi> = UNIV\n 3. seq_sem ?I1 C = UNIV \\<Longrightarrow> fml_sem I (seq2fml C) = UNIV", "using good"], ["proof (prove)\nusing this:\n  is_interp I\n\ngoal (3 subgoals):\n 1. is_interp ?I1\n 2. \\<And>\\<phi>.\n       List.member SG \\<phi> \\<Longrightarrow> seq_sem ?I1 \\<phi> = UNIV\n 3. seq_sem ?I1 C = UNIV \\<Longrightarrow> fml_sem I (seq2fml C) = UNIV", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member SG (a, b); is_interp I;\n        (aa, ba) \\<in> fml_sem I (foldr (&&) a TT)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "using SGs"], ["proof (prove)\nusing this:\n  List.member SG ?P7 \\<Longrightarrow> seq_sem I ?P7 = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member SG (a, b); is_interp I;\n        (aa, ba) \\<in> fml_sem I (foldr (&&) a TT)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member SG (a, b); is_interp I;\n        (aa, ba) \\<in> fml_sem I (foldr (&&) a TT);\n        \\<And>a b.\n           List.member SG (a, b) \\<Longrightarrow>\n           fml_sem I (foldr (&&) a TT \\<rightarrow> foldr (||) b FF) =\n           UNIV\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "using impl_sem"], ["proof (prove)\nusing this:\n  (?\\<nu> \\<in> fml_sem ?I (?A \\<rightarrow> ?B)) =\n  (?\\<nu> \\<in> fml_sem ?I ?A \\<longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?B)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member SG (a, b); is_interp I;\n        (aa, ba) \\<in> fml_sem I (foldr (&&) a TT);\n        \\<And>a b.\n           List.member SG (a, b) \\<Longrightarrow>\n           fml_sem I (foldr (&&) a TT \\<rightarrow> foldr (||) b FF) =\n           UNIV\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "by blast"], ["proof (state)\nthis:\n  seq_sem I C = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "fun Lrule_result :: \"lrule \\<Rightarrow> nat \\<Rightarrow> ('sf, 'sc, 'sz) sequent \\<Rightarrow> ('sf, 'sc, 'sz) sequent list\"\nwhere \"Lrule_result AndL j (A,S) = (case (nth A j) of And p q \\<Rightarrow> [(close ([p, q] @ A) (nth A j), S)])\"\n| \"Lrule_result ImplyL j (A,S) = (case (nth A j) of Not (And (Not q) (Not (Not p))) \\<Rightarrow> \n   [(close (q # A) (nth A j), S), (close A (nth A j), p # S)])\"\n| \"Lrule_result EquivForwardL j (A,S) = (case (nth A j) of Not(And (Not (And p q)) (Not (And (Not p') (Not q')))) \\<Rightarrow>\n   [(close (q # A) (nth A j), S), (close A (nth A j), p # S)])\"\n| \"Lrule_result EquivBackwardL j (A,S) = (case (nth A j) of Not(And (Not (And p q)) (Not (And (Not p') (Not q')))) \\<Rightarrow>\n   [(close (p # A) (nth A j), S), (close A (nth A j), q # S)])\"\n\n\\<comment> \\<open>Note: Some of the pattern-matching here is... interesting. The reason for this is that we can only\\<close>\n\\<comment> \\<open>match on things in the base grammar, when we would quite like to check things in the derived grammar.\\<close>\n\\<comment> \\<open>So all the pattern-matches have the definitions expanded, sometimes in a silly way.\\<close>"], ["", "fun Rrule_result :: \"rrule \\<Rightarrow> nat \\<Rightarrow> ('sf, 'sc, 'sz) sequent \\<Rightarrow> ('sf, 'sc, 'sz) sequent list\"\nwhere \n  Rstep_Imply:\"Rrule_result ImplyR j (A,S) = (case (nth S j) of Not (And (Not q) (Not (Not p))) \\<Rightarrow> [(p # A, q # (closeI S j))] | _ \\<Rightarrow> undefined)\"\n| Rstep_And:\"Rrule_result AndR j (A,S) = (case (nth S j) of (And p q) \\<Rightarrow> [(A, p # (closeI S j )), (A, q # (closeI S j))])\"\n| Rstep_EquivR:\"Rrule_result EquivR j (A,S) =\n   (case (nth S j) of Not(And (Not (And p q)) (Not (And (Not p') (Not q')))) \\<Rightarrow> \n                (if (p = p' \\<and> q = q') then [(p # A, q # (closeI S j)), (q # A, p # (closeI S j))]\n                else undefined))\"\n| Rstep_CohideR:\"Rrule_result CohideR j (A,S) = [(A, [nth S j])]\"\n| Rstep_CohideRR:\"Rrule_result CohideRR j (A,S) = [([], [nth S j])]\"\n| Rstep_TrueR:\"Rrule_result TrueR j (A,S) = []\""], ["", "fun step_result :: \"('sf, 'sc, 'sz) rule \\<Rightarrow> (nat * ('sf, 'sc, 'sz) step) \\<Rightarrow>  ('sf, 'sc, 'sz) rule\"\nwhere\n  Step_axiom:\"step_result (SG,C) (i,Axiom a)   = (closeI SG i, C)\"\n| Step_AxSubst:\"step_result (SG,C) (i,AxSubst a \\<sigma>)   = (closeI SG i, C)\"\n| Step_Lrule:\"step_result (SG,C) (i,Lrule L j) = (close (append SG (Lrule_result L j (nth SG i))) (nth SG i), C)\"\n| Step_Rrule:\"step_result (SG,C) (i,Rrule L j) = (close (append SG (Rrule_result L j (nth SG i))) (nth SG i), C)\" \n| Step_Cut:\"step_result (SG,C) (i,Cut \\<phi>) = (let (A,S) = nth SG i in ((\\<phi> # A, S) # ((A, \\<phi> # S) # (closeI SG i)), C))\"\n| Step_Vsubst:\"step_result (SG,C) (i,VSubst \\<phi> \\<sigma>) = (closeI SG i, C)\"\n| Step_CloseId:\"step_result (SG,C) (i,CloseId j k) = (closeI SG i, C)\"\n| Step_G:\"step_result (SG,C) (i,G) = (case nth SG i of (_, (Not (Diamond q (Not p))) # Nil) \\<Rightarrow> (([], [p]) # closeI SG i, C))\"\n| Step_DEAxiomSchema:\"step_result (SG,C) (i,DEAxiomSchema ODE \\<sigma>) = (closeI SG i, C)\"\n| Step_CE:\"step_result (SG,C) (i, CE \\<phi> \\<psi> \\<sigma>) =  (closeI SG i, C)\"\n| Step_CQ:\"step_result (SG,C) (i, CQ \\<theta>\\<^sub>1 \\<theta>\\<^sub>2 \\<sigma>) =  (closeI SG i, C)\"\n| Step_default:\"step_result R (i,S) = R\""], ["", "fun deriv_result :: \"('sf, 'sc, 'sz) rule \\<Rightarrow> ('sf, 'sc, 'sz) derivation \\<Rightarrow> ('sf, 'sc, 'sz) rule\"\nwhere \n  \"deriv_result R [] = R\"\n| \"deriv_result R (s # ss) = deriv_result (step_result R s) (ss)\""], ["", "fun proof_result :: \"('sf, 'sc, 'sz) pf \\<Rightarrow> ('sf, 'sc, 'sz) rule\"\nwhere \"proof_result (D,S) = deriv_result (start_proof D) S\""], ["", "inductive lrule_ok ::\"('sf,'sc,'sz) sequent list \\<Rightarrow> ('sf,'sc,'sz) sequent \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> lrule \\<Rightarrow> bool\"\nwhere\n  Lrule_And:\"\\<And>p q. nth (fst (nth SG i)) j = (p && q) \\<Longrightarrow> lrule_ok SG C i j AndL\"\n| Lrule_Imply:\"\\<And>p q. nth (fst (nth SG i)) j = (p \\<rightarrow> q) \\<Longrightarrow> lrule_ok SG C i j ImplyL\"\n| Lrule_EquivForward:\"\\<And>p q. nth (fst (nth SG i)) j = (p \\<leftrightarrow> q) \\<Longrightarrow> lrule_ok SG C i j EquivForwardL\"\n| Lrule_EquivBackward:\"\\<And>p q. nth (fst (nth SG i)) j = (p \\<leftrightarrow> q) \\<Longrightarrow> lrule_ok SG C i j EquivBackwardL\""], ["", "named_theorems prover \"Simplification rules for checking validity of proof certificates\""], ["", "lemmas [prover] = axiom_defs Box_def Or_def Implies_def filter_append ssafe_def SDom_def FUadmit_def PFUadmit_def id_simps"], ["", "inductive_simps \n    Lrule_And[prover]: \"lrule_ok SG C i j AndL\"\nand Lrule_Imply[prover]: \"lrule_ok SG C i j ImplyL\"\nand Lrule_Forward[prover]: \"lrule_ok SG C i j EquivForwardL\"\nand Lrule_EquivBackward[prover]: \"lrule_ok SG C i j EquivBackwardL\""], ["", "inductive rrule_ok ::\"('sf,'sc,'sz) sequent list \\<Rightarrow> ('sf,'sc,'sz) sequent \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> rrule \\<Rightarrow> bool\"\nwhere\n  Rrule_And:\"\\<And>p q. nth (snd (nth SG i)) j = (p && q) \\<Longrightarrow> rrule_ok SG C i j AndR\"\n| Rrule_Imply:\"\\<And>p q. nth (snd (nth SG i)) j = (p \\<rightarrow> q) \\<Longrightarrow> rrule_ok SG C i j ImplyR\"\n| Rrule_Equiv:\"\\<And>p q. nth (snd (nth SG i)) j = (p \\<leftrightarrow> q) \\<Longrightarrow> rrule_ok SG C i j EquivR\"\n| Rrule_Cohide:\"length (snd (nth SG i)) > j \\<Longrightarrow> (\\<And>\\<Gamma> q. (nth SG i) \\<noteq> (\\<Gamma>, [q])) \\<Longrightarrow> rrule_ok SG C i j CohideR\"\n| Rrule_CohideRR:\"length (snd (nth SG i)) > j  \\<Longrightarrow> (\\<And>q. (nth SG i) \\<noteq> ([], [q])) \\<Longrightarrow> rrule_ok SG C i j CohideRR\"\n| Rrule_True:\"nth (snd (nth SG i)) j = TT \\<Longrightarrow> rrule_ok SG C i j TrueR\""], ["", "inductive_simps \n    Rrule_And_simps[prover]: \"rrule_ok SG C i j AndR\"\nand Rrule_Imply_simps[prover]: \"rrule_ok SG C i j ImplyR\"\nand Rrule_Equiv_simps[prover]: \"rrule_ok SG C i j EquivR\"\nand Rrule_CohideR_simps[prover]: \"rrule_ok SG C i j CohideR\"\nand Rrule_CohideRR_simps[prover]: \"rrule_ok SG C i j CohideRR\"\nand Rrule_TrueR_simps[prover]: \"rrule_ok SG C i j TrueR\""], ["", "inductive step_ok  :: \"('sf, 'sc, 'sz) rule \\<Rightarrow> nat \\<Rightarrow> ('sf, 'sc, 'sz) step \\<Rightarrow> bool\"\nwhere\n  Step_Axiom:\"(nth SG i) = ([], [get_axiom a]) \\<Longrightarrow> step_ok (SG,C) i (Axiom a)\"\n| Step_AxSubst:\"(nth SG i) = ([], [Fsubst (get_axiom a) \\<sigma>]) \\<Longrightarrow> Fadmit \\<sigma> (get_axiom a) \\<Longrightarrow> ssafe \\<sigma> \\<Longrightarrow> step_ok (SG,C) i (AxSubst a \\<sigma>)\"\n| Step_Lrule:\"lrule_ok SG C i j L \\<Longrightarrow> j < length (fst (nth SG i)) \\<Longrightarrow> step_ok (SG,C) i (Lrule L j)\"\n| Step_Rrule:\"rrule_ok SG C i j L \\<Longrightarrow> j < length (snd (nth SG i)) \\<Longrightarrow> step_ok (SG,C) i (Rrule L j)\"\n| Step_Cut:\"fsafe \\<phi> \\<Longrightarrow> i < length SG \\<Longrightarrow> step_ok (SG,C) i (Cut \\<phi>)\"\n| Step_CloseId:\"nth (fst (nth SG i)) j = nth (snd (nth SG i)) k \\<Longrightarrow> j < length (fst (nth SG i)) \\<Longrightarrow> k < length (snd (nth SG i)) \\<Longrightarrow> step_ok (SG,C) i (CloseId j k) \"\n| Step_G:\"\\<And>a p. nth SG i = ([], [([[a]]p)]) \\<Longrightarrow> step_ok (SG,C) i G\"\n| Step_DEAxiom_schema:\n  \" nth SG i = \n  ([], [Fsubst ((([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE) (p1 vid2 vid1)]] (P pid1)) \\<leftrightarrow>\n          ([[EvolveODE ((OProd  (OSing vid1 (f1 fid1 vid1))) ODE) (p1 vid2 vid1)]]\n               [[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))) \\<sigma>])\n    \\<Longrightarrow> ssafe \\<sigma>\n    \\<Longrightarrow> osafe ODE\n    \\<Longrightarrow> {Inl vid1, Inr vid1} \\<inter> BVO ODE = {}\n    \\<Longrightarrow> Fadmit \\<sigma> ((([[EvolveODE (OProd  (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]] (P pid1)) \\<leftrightarrow>\n          ([[EvolveODE ((OProd  (OSing vid1 (f1 fid1 vid1))ODE)) (p1 vid2 vid1)]]\n               [[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))) \n    \\<Longrightarrow> step_ok (SG,C) i (DEAxiomSchema ODE \\<sigma>)\"\n| Step_CE:\"nth SG i = ([], [Fsubst (Equiv (InContext pid1 \\<phi>) (InContext pid1 \\<psi>)) \\<sigma>]) \n    \\<Longrightarrow> valid (Equiv \\<phi> \\<psi>) \n    \\<Longrightarrow> fsafe \\<phi>\n    \\<Longrightarrow> fsafe \\<psi>\n    \\<Longrightarrow> ssafe \\<sigma>\n    \\<Longrightarrow> Fadmit \\<sigma> (Equiv (InContext pid1 \\<phi>) (InContext pid1 \\<psi>))\n    \\<Longrightarrow> step_ok (SG,C) i (CE \\<phi> \\<psi> \\<sigma>)\"\n| Step_CQ:\"nth SG i = ([], [Fsubst (Equiv (Prop p (singleton \\<theta>)) (Prop p (singleton \\<theta>'))) \\<sigma>]) \n    \\<Longrightarrow> valid (Equals \\<theta> \\<theta>') \n    \\<Longrightarrow> dsafe \\<theta>\n    \\<Longrightarrow> dsafe \\<theta>'\n    \\<Longrightarrow> ssafe \\<sigma>\n    \\<Longrightarrow> Fadmit \\<sigma> (Equiv (Prop p (singleton \\<theta>)) (Prop p (singleton \\<theta>')))\n    \\<Longrightarrow> step_ok (SG,C) i (CQ \\<theta> \\<theta>' \\<sigma>)\""], ["", "inductive_simps \n    Step_G_simps[prover]: \"step_ok (SG,C) i G\"\nand Step_CloseId_simps[prover]: \"step_ok (SG,C) i (CloseId j k)\"\nand Step_Cut_simps[prover]: \"step_ok (SG,C) i (Cut \\<phi>)\"\nand Step_Rrule_simps[prover]: \"step_ok (SG,C) i (Rrule j L)\"\nand Step_Lrule_simps[prover]: \"step_ok (SG,C) i (Lrule j L)\"\nand Step_Axiom_simps[prover]: \"step_ok (SG,C) i (Axiom a)\"\nand Step_AxSubst_simps[prover]: \"step_ok (SG,C) i (AxSubst a \\<sigma>)\"\nand Step_DEAxiom_schema_simps[prover]: \"step_ok (SG,C) i (DEAxiomSchema ODE \\<sigma>)\"\nand Step_CE_simps[prover]: \"step_ok (SG,C) i (CE \\<phi> \\<psi> \\<sigma>)\"\nand Step_CQ_simps[prover]: \"step_ok (SG,C) i (CQ \\<theta> \\<theta>' \\<sigma>)\""], ["", "inductive deriv_ok :: \"('sf, 'sc, 'sz) rule \\<Rightarrow> ('sf, 'sc, 'sz) derivation \\<Rightarrow> bool\"\nwhere \n  Deriv_Nil:\"deriv_ok R Nil\"\n| Deriv_Cons:\"step_ok R i S \\<Longrightarrow> i \\<ge> 0 \\<Longrightarrow> i < length (fst R) \\<Longrightarrow> deriv_ok (step_result R (i,S)) SS \\<Longrightarrow> deriv_ok R ((i,S) # SS)\""], ["", "inductive_simps \n    Deriv_nil_simps[prover]: \"deriv_ok R Nil\"\nand Deriv_cons_simps[prover]: \"deriv_ok R ((i,S)#SS)\""], ["", "inductive proof_ok :: \"('sf, 'sc, 'sz) pf \\<Rightarrow> bool\"\nwhere\n  Proof_ok:\"deriv_ok (start_proof D) S \\<Longrightarrow> proof_ok (D,S)\""], ["", "inductive_simps Proof_ok_simps[prover]: \"proof_ok (D,S)\""], ["", "subsection \\<open>Soundness\\<close>"], ["", "named_theorems member_intros \"Prove that stuff is in lists\""], ["", "lemma mem_sing[member_intros]:\"\\<And>x. List.member [x] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. List.member [x] x", "by(auto simp add: member_rec)"], ["", "lemma mem_appR[member_intros]:\"\\<And>A B x. List.member B x \\<Longrightarrow> List.member (A @ B) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B x. List.member B x \\<Longrightarrow> List.member (A @ B) x", "subgoal for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member B_ x_ \\<Longrightarrow> List.member (A @ B_) x_", "by(induction A, auto simp add: member_rec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mem_filter[member_intros]:\"\\<And>A P x. P x \\<Longrightarrow> List.member A x \\<Longrightarrow> List.member (filter P A) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A P x.\n       \\<lbrakk>P x; List.member A x\\<rbrakk>\n       \\<Longrightarrow> List.member (filter P A) x", "subgoal for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P_ x_; List.member A x_\\<rbrakk>\n    \\<Longrightarrow> List.member (filter P_ A) x_", "by(induction A, auto simp add: member_rec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sound_weaken_appL:\"\\<And>SG SGS C. sound (SGS, C) \\<Longrightarrow> sound (SG @ SGS, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>SG SGS C. sound (SGS, C) \\<Longrightarrow> sound (SG @ SGS, C)", "subgoal for SG SGS C"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SGS, C) \\<Longrightarrow> sound (SG @ SGS, C)", "apply(rule sound_weaken_gen)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SGS, C) \\<Longrightarrow> sublist ?A (SG @ SGS)\n 2. sound (SGS, C) \\<Longrightarrow> sound (?A, C)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SGS, C) \\<Longrightarrow> sublist SGS (SG @ SGS)", "unfolding sublist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SGS, C) \\<Longrightarrow>\n    \\<forall>x. List.member SGS x \\<longrightarrow> List.member (SG @ SGS) x", "apply(rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sound (SGS, C) \\<Longrightarrow>\n       List.member SGS x \\<longrightarrow> List.member (SG @ SGS) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SGS, C) \\<Longrightarrow>\n    List.member SGS x \\<longrightarrow> List.member (SG @ SGS) x", "using mem_appR[of SGS x SG]"], ["proof (prove)\nusing this:\n  List.member SGS x \\<Longrightarrow> List.member (SG @ SGS) x\n\ngoal (1 subgoal):\n 1. sound (SGS, C) \\<Longrightarrow>\n    List.member SGS x \\<longrightarrow> List.member (SG @ SGS) x", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fml_seq_valid:\"valid \\<phi> \\<Longrightarrow> seq_valid ([], [\\<phi>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid \\<phi> \\<Longrightarrow> seq_valid ([], [\\<phi>])", "unfolding seq_valid_def valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I \\<nu>.\n       is_interp I \\<longrightarrow>\n       \\<nu> \\<in> fml_sem I \\<phi> \\<Longrightarrow>\n    \\<forall>I.\n       is_interp I \\<longrightarrow> seq_sem I ([], [\\<phi>]) = UNIV", "by auto"], ["", "lemma closeI_provable_sound:\"\\<And>i. sound (SG, C) \\<Longrightarrow> sound (closeI SG i, (nth SG i)) \\<Longrightarrow> sound (closeI SG i, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>sound (SG, C); sound (closeI SG i, SG ! i)\\<rbrakk>\n       \\<Longrightarrow> sound (closeI SG i, C)", "using close_provable_sound"], ["proof (prove)\nusing this:\n  \\<lbrakk>sound (?SG, ?C); sound (close ?SG ?\\<phi>, ?\\<phi>)\\<rbrakk>\n  \\<Longrightarrow> sound (close ?SG ?\\<phi>, ?C)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>sound (SG, C); sound (closeI SG i, SG ! i)\\<rbrakk>\n       \\<Longrightarrow> sound (closeI SG i, C)", "by auto"], ["", "lemma valid_to_sound:\"seq_valid A \\<Longrightarrow> sound (B, A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_valid A \\<Longrightarrow> sound (B, A)", "unfolding seq_valid_def sound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I.\n       is_interp I \\<longrightarrow> seq_sem I A = UNIV \\<Longrightarrow>\n    \\<forall>I.\n       is_interp I \\<longrightarrow>\n       (\\<forall>i\\<ge>0.\n           i < length (fst (B, A)) \\<longrightarrow>\n           seq_sem I (fst (B, A) ! i) = UNIV) \\<longrightarrow>\n       seq_sem I (snd (B, A)) = UNIV", "by auto"], ["", "lemma closeI_valid_sound:\"\\<And>i. sound (SG, C) \\<Longrightarrow> seq_valid (nth SG i) \\<Longrightarrow> sound (closeI SG i, C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>sound (SG, C); seq_valid (SG ! i)\\<rbrakk>\n       \\<Longrightarrow> sound (closeI SG i, C)", "using valid_to_sound closeI_provable_sound"], ["proof (prove)\nusing this:\n  seq_valid ?A \\<Longrightarrow> sound (?B, ?A)\n  \\<lbrakk>sound (?SG, ?C); sound (closeI ?SG ?i, ?SG ! ?i)\\<rbrakk>\n  \\<Longrightarrow> sound (closeI ?SG ?i, ?C)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>sound (SG, C); seq_valid (SG ! i)\\<rbrakk>\n       \\<Longrightarrow> sound (closeI SG i, C)", "by auto"], ["", "lemma close_nonmember_eq:\"\\<not>(List.member A a) \\<Longrightarrow> close A a = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member A a \\<Longrightarrow> close A a = A", "by (induction A, auto simp add: member_rec)"], ["", "lemma close_noneq_nonempty:\"List.member A x \\<Longrightarrow> x \\<noteq> a \\<Longrightarrow> close A a \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member A x; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> close A a \\<noteq> []", "by(induction A, auto simp add: member_rec)"], ["", "lemma close_app_neq:\"List.member A x \\<Longrightarrow> x \\<noteq> a \\<Longrightarrow> close (A @ B) a \\<noteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member A x; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> close (A @ B) a \\<noteq> B", "using append_self_conv2[of \"close A a\" \"close B a\"] append_self_conv2[of \"close A a\" \"B\"] close_app_comm[of A B a] close_noneq_nonempty[of A x a]"], ["proof (prove)\nusing this:\n  (close A a @ close B a = close B a) = (close A a = [])\n  (close A a @ B = B) = (close A a = [])\n  close (A @ B) a = close A a @ close B a\n  \\<lbrakk>List.member A x; x \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> close A a \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member A x; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> close (A @ B) a \\<noteq> B", "apply(cases \"close B a = B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List.member A x; x \\<noteq> a;\n     (close A a @ close B a = close B a) = (close A a = []);\n     (close A a @ B = B) = (close A a = []);\n     close (A @ B) a = close A a @ close B a;\n     \\<lbrakk>List.member A x; x \\<noteq> a\\<rbrakk>\n     \\<Longrightarrow> close A a \\<noteq> [];\n     close B a = B\\<rbrakk>\n    \\<Longrightarrow> close (A @ B) a \\<noteq> B\n 2. \\<lbrakk>List.member A x; x \\<noteq> a;\n     (close A a @ close B a = close B a) = (close A a = []);\n     (close A a @ B = B) = (close A a = []);\n     close (A @ B) a = close A a @ close B a;\n     \\<lbrakk>List.member A x; x \\<noteq> a\\<rbrakk>\n     \\<Longrightarrow> close A a \\<noteq> [];\n     close B a \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> close (A @ B) a \\<noteq> B", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member A x; x \\<noteq> a;\n     filter (\\<lambda>y. y \\<noteq> a) A \\<noteq> [];\n     filter (\\<lambda>y. y \\<noteq> a) B \\<noteq> B;\n     filter (\\<lambda>y. y \\<noteq> a) A @\n     filter (\\<lambda>y. y \\<noteq> a) B =\n     B\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (no_types, lifting) filter_True filter_append mem_Collect_eq set_filter)"], ["", "lemma member_singD:\"\\<And>x P. P x \\<Longrightarrow> (\\<And>y. List.member [x] y \\<Longrightarrow> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x P.\n       P x \\<Longrightarrow>\n       (\\<And>y. List.member [x] y \\<Longrightarrow> P y)", "by (metis member_rec(1) member_rec(2))"], ["", "lemma fst_neq:\"A \\<noteq> B \\<Longrightarrow> (A,C) \\<noteq> (B,D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> (A, C) \\<noteq> (B, D)", "by auto"], ["", "lemma lrule_sound: \"lrule_ok SG C i j L \\<Longrightarrow> i < length SG \\<Longrightarrow> j < length (fst (SG ! i)) \\<Longrightarrow> sound (SG,C) \\<Longrightarrow> sound (close (append SG (Lrule_result L j (nth SG i))) (nth SG i), C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lrule_ok SG C i j L; i < length SG; j < length (fst (SG ! i));\n     sound (SG, C)\\<rbrakk>\n    \\<Longrightarrow> sound\n                       (close (SG @ Lrule_result L j (SG ! i)) (SG ! i), C)", "proof(induction rule: lrule_ok.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Lrule_And SG i j C p q)"], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p && q)\n  i < length SG\n  j < length (fst (SG ! i))\n  sound (SG, C)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume eq:\"fst (SG ! i) ! j = (p && q)\""], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p && q)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain AI and SI where SG_dec:\"(AI,SI) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AI SI.\n        (AI, SI) = SG ! i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (AI, SI) = SG ! i\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have AIjeq:\"AI ! j = (p && q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AI ! j = (p && q)", "using SG_dec eq"], ["proof (prove)\nusing this:\n  (AI, SI) = SG ! i\n  fst (SG ! i) ! j = (p && q)\n\ngoal (1 subgoal):\n 1. AI ! j = (p && q)", "by (metis fst_conv)"], ["proof (state)\nthis:\n  AI ! j = (p && q)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have sub:\"sublist [(close ([p, q] @ AI) (p && q),SI)] ([y\\<leftarrow>SG . y \\<noteq> (AI, SI)] @ [y\\<leftarrow> [(close (p # q # AI) (p && q), SI)] . y \\<noteq> (AI, SI)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist [(close ([p, q] @ AI) (p && q), SI)]\n     (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n      filter (\\<lambda>y. y \\<noteq> (AI, SI))\n       [(close (p # q # AI) (p && q), SI)])", "apply (rule sublistI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member [(close ([p, q] @ AI) (p && q), SI)] x \\<Longrightarrow>\n       List.member\n        (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n         filter (\\<lambda>y. y \\<noteq> (AI, SI))\n          [(close (p # q # AI) (p && q), SI)])\n        x", "using member_singD [of \"\\<lambda>y. List.member ([y\\<leftarrow>SG . y \\<noteq> (AI, SI)] @ [y\\<leftarrow> [(close ([p, q] @ AI) (p && q), SI)] . y \\<noteq> (AI, SI)]) y\" \"(close ([p, q] @ AI) (p && q),SI)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>List.member\n            (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n             filter (\\<lambda>y. y \\<noteq> (AI, SI))\n              [(close ([p, q] @ AI) (p && q), SI)])\n            (close ([p, q] @ AI) (p && q), SI);\n   List.member [(close ([p, q] @ AI) (p && q), SI)] ?y\\<rbrakk>\n  \\<Longrightarrow> List.member\n                     (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n                      filter (\\<lambda>y. y \\<noteq> (AI, SI))\n                       [(close ([p, q] @ AI) (p && q), SI)])\n                     ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member [(close ([p, q] @ AI) (p && q), SI)] x \\<Longrightarrow>\n       List.member\n        (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n         filter (\\<lambda>y. y \\<noteq> (AI, SI))\n          [(close (p # q # AI) (p && q), SI)])\n        x", "using close_app_neq[of \"[p, q]\" p \"p && q\" AI]"], ["proof (prove)\nusing this:\n  \\<lbrakk>List.member\n            (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n             filter (\\<lambda>y. y \\<noteq> (AI, SI))\n              [(close ([p, q] @ AI) (p && q), SI)])\n            (close ([p, q] @ AI) (p && q), SI);\n   List.member [(close ([p, q] @ AI) (p && q), SI)] ?y\\<rbrakk>\n  \\<Longrightarrow> List.member\n                     (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n                      filter (\\<lambda>y. y \\<noteq> (AI, SI))\n                       [(close ([p, q] @ AI) (p && q), SI)])\n                     ?y\n  \\<lbrakk>List.member [p, q] p; p \\<noteq> (p && q)\\<rbrakk>\n  \\<Longrightarrow> close ([p, q] @ AI) (p && q) \\<noteq> AI\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member [(close ([p, q] @ AI) (p && q), SI)] x \\<Longrightarrow>\n       List.member\n        (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n         filter (\\<lambda>y. y \\<noteq> (AI, SI))\n          [(close (p # q # AI) (p && q), SI)])\n        x", "by(auto intro: member_intros fst_neq simp add: member_rec expr_diseq)"], ["proof (state)\nthis:\n  sublist [(close ([p, q] @ AI) (p && q), SI)]\n   (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n    filter (\\<lambda>y. y \\<noteq> (AI, SI))\n     [(close (p # q # AI) (p && q), SI)])\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have cool:\"sound ([y\\<leftarrow>SG . y \\<noteq> (AI, SI)] @ [y\\<leftarrow> [(close (p # q # AI) (p && q), SI)] . y \\<noteq> (AI, SI)], AI, SI)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n      filter (\\<lambda>y. y \\<noteq> (AI, SI))\n       [(close (p # q # AI) (p && q), SI)],\n      AI, SI)", "apply(rule sound_weaken_gen[OF sub] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([(close ([p, q] @ AI) (p && q), SI)], AI, SI)", "apply(auto simp add: member_rec expr_diseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)], AI, SI)", "unfolding seq_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)], AI, SI)", "proof (rule soundI_mem)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "fix I::\"('sf,'sc,'sz) interp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "assume sgs:\"(\\<And>\\<phi>. List.member [(p # q # [y\\<leftarrow>AI . y \\<noteq> (p && q)], SI)] \\<phi> \\<Longrightarrow> seq_sem I \\<phi> = UNIV)\""], ["proof (state)\nthis:\n  List.member [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n   ?\\<phi>7 \\<Longrightarrow>\n  seq_sem I ?\\<phi>7 = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "have theSg:\"seq_sem I (p # q # [y\\<leftarrow>AI . y \\<noteq> (p && q)], SI) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_sem I (p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI) =\n    UNIV", "apply(rule sgs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n     (p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)", "by(auto intro: member_intros)"], ["proof (state)\nthis:\n  seq_sem I (p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "then"], ["proof (chain)\npicking this:\n  seq_sem I (p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI) = UNIV", "have sgIn:\"\\<And>\\<nu>. \\<nu> \\<in> seq_sem I ((p && q) # [y\\<leftarrow>AI . y \\<noteq> (p && q)], SI)\""], ["proof (prove)\nusing this:\n  seq_sem I (p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>\\<nu>.\n       \\<nu>\n       \\<in> seq_sem I\n              ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)", "by auto"], ["proof (state)\nthis:\n  ?\\<nu>7\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "{"], ["proof (state)\nthis:\n  ?\\<nu>7\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "fix \\<nu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "assume sem:\"\\<nu> \\<in> seq_sem I ((p && q) # [y\\<leftarrow>AI . y \\<noteq> (p && q)], SI)\""], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "have mem_eq:\"\\<And>x. List.member ((p && q) # [y\\<leftarrow>AI . y \\<noteq> (p && q)]) x = List.member AI x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI)\n        x =\n       List.member AI x", "by (metis (mono_tags, lifting) Lrule_And.prems(2) SG_dec eq fst_conv local.member_filter mem_filter member_rec(1) nth_member)"], ["proof (state)\nthis:\n  List.member ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI) ?x7 =\n  List.member AI ?x7\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "have myeq:\"\\<nu> \\<in> seq_sem I ((p && q) # [y\\<leftarrow>AI . y \\<noteq> (p && q)], SI) \\<Longrightarrow>  \\<nu> \\<in> seq_sem I (AI, SI)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I\n           ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n            SI) \\<Longrightarrow>\n    \\<nu> \\<in> seq_sem I (AI, SI)", "using and_foldl_sem and_foldl_sem_conv seq_semI Lrule_And.prems(2) SG_dec eq  seq_MP seq_semI' mem_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT);\n   List.member ?\\<Gamma> ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\n  (\\<And>\\<phi>.\n      List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n      ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n  ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\n  \\<lbrakk>List.member ?\\<Delta> ?\\<psi>;\n   (\\<And>\\<phi>.\n       List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n       ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n  j < length (fst (SG ! i))\n  (AI, SI) = SG ! i\n  fst (SG ! i) ! j = (p && q)\n  \\<lbrakk>?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>);\n   ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)\n  (?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)) \\<Longrightarrow>\n  ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n  List.member ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI) ?x7 =\n  List.member AI ?x7\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I\n           ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n            SI) \\<Longrightarrow>\n    \\<nu> \\<in> seq_sem I (AI, SI)", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n          SI) \\<Longrightarrow>\n  \\<nu> \\<in> seq_sem I (AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "have \"\\<nu> \\<in> seq_sem I ((p && q) # [y\\<leftarrow>AI . y \\<noteq> (p && q)], SI)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I\n           ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)", "using sem"], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I\n           ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)", "by auto"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "then"], ["proof (chain)\npicking this:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)", "have \"\\<nu> \\<in> seq_sem I ((p && q) # [y\\<leftarrow>AI . y \\<noteq> (p && q)], SI)\""], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I\n           ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)", "by blast"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "then"], ["proof (chain)\npicking this:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)", "have \"\\<nu> \\<in> seq_sem I (AI, SI)\""], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (AI, SI)", "using myeq"], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n  \\<nu>\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n          SI) \\<Longrightarrow>\n  \\<nu> \\<in> seq_sem I (AI, SI)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (AI, SI)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "}"], ["proof (state)\nthis:\n  ?\\<nu>9\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n          SI) \\<Longrightarrow>\n  ?\\<nu>9 \\<in> seq_sem I (AI, SI)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>.\n           List.member\n            [(p # q # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)]\n            \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I (AI, SI) = UNIV", "then"], ["proof (chain)\npicking this:\n  ?\\<nu>9\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n          SI) \\<Longrightarrow>\n  ?\\<nu>9 \\<in> seq_sem I (AI, SI)", "show \"seq_sem I (AI, SI) = UNIV\""], ["proof (prove)\nusing this:\n  ?\\<nu>9\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n          SI) \\<Longrightarrow>\n  ?\\<nu>9 \\<in> seq_sem I (AI, SI)\n\ngoal (1 subgoal):\n 1. seq_sem I (AI, SI) = UNIV", "using sgIn"], ["proof (prove)\nusing this:\n  ?\\<nu>9\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI,\n          SI) \\<Longrightarrow>\n  ?\\<nu>9 \\<in> seq_sem I (AI, SI)\n  ?\\<nu>7\n  \\<in> seq_sem I\n         ((p && q) # filter (\\<lambda>y. y \\<noteq> (p && q)) AI, SI)\n\ngoal (1 subgoal):\n 1. seq_sem I (AI, SI) = UNIV", "by blast"], ["proof (state)\nthis:\n  seq_sem I (AI, SI) = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n    filter (\\<lambda>y. y \\<noteq> (AI, SI))\n     [(close (p # q # AI) (p && q), SI)],\n    AI, SI)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_sound:\"sound ([y\\<leftarrow>SG . y \\<noteq> (AI,SI)] @ [y\\<leftarrow>Lrule_result AndL j (AI,SI) . y \\<noteq> (AI,SI)],(AI,SI))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n      filter (\\<lambda>y. y \\<noteq> (AI, SI))\n       (Lrule_result AndL j (AI, SI)),\n      AI, SI)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n      filter (\\<lambda>y. y \\<noteq> (AI, SI))\n       (case AI ! j of\n        p && q \\<Rightarrow> [(close ([p, q] @ AI) (AI ! j), SI)]),\n      AI, SI)", "using cool AIjeq"], ["proof (prove)\nusing this:\n  sound\n   (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n    filter (\\<lambda>y. y \\<noteq> (AI, SI))\n     [(close (p # q # AI) (p && q), SI)],\n    AI, SI)\n  AI ! j = (p && q)\n\ngoal (1 subgoal):\n 1. sound\n     (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n      filter (\\<lambda>y. y \\<noteq> (AI, SI))\n       (case AI ! j of\n        p && q \\<Rightarrow> [(close ([p, q] @ AI) (AI ! j), SI)]),\n      AI, SI)", "by auto"], ["proof (state)\nthis:\n  sound\n   (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n    filter (\\<lambda>y. y \\<noteq> (AI, SI)) (Lrule_result AndL j (AI, SI)),\n    AI, SI)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p && q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result AndL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "show \"?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Lrule_result AndL j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Lrule_result AndL j (SG ! i), C)\n 2. sound (close (SG @ Lrule_result AndL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound (close (SG @ Lrule_result AndL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Lrule_result AndL j (SG ! i)) (SG ! i), SG ! i)", "using res_sound SG_dec"], ["proof (prove)\nusing this:\n  sound\n   (filter (\\<lambda>y. y \\<noteq> (AI, SI)) SG @\n    filter (\\<lambda>y. y \\<noteq> (AI, SI)) (Lrule_result AndL j (AI, SI)),\n    AI, SI)\n  (AI, SI) = SG ! i\n\ngoal (1 subgoal):\n 1. sound (close (SG @ Lrule_result AndL j (SG ! i)) (SG ! i), SG ! i)", "by auto"], ["proof (state)\nthis:\n  sound (close (SG @ Lrule_result AndL j (SG ! i)) (SG ! i), C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Lrule_Imply SG i j C p q)"], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p \\<rightarrow> q)\n  i < length SG\n  j < length (fst (SG ! i))\n  sound (SG, C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have implyL_simp:\"\\<And>AI SI SS p q. \n    (nth AI  j) = (Not (And (Not q) (Not (Not p)))) \\<Longrightarrow> \n    (AI,SI) = SS \\<Longrightarrow> \n    Lrule_result ImplyL j SS = [(close (q # AI) (nth AI j), SI), (close AI (nth AI j), p # SI)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AI SI SS p q.\n       \\<lbrakk>AI ! j = ! (! q && ! (! p)); (AI, SI) = SS\\<rbrakk>\n       \\<Longrightarrow> Lrule_result ImplyL j SS =\n                         [(close (q # AI) (AI ! j), SI),\n                          (close AI (AI ! j), p # SI)]", "subgoal for AI SI SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AI ! j = ! (! q && ! (! p)); (AI, SI) = SS\\<rbrakk>\n    \\<Longrightarrow> Lrule_result ImplyL j SS =\n                      [(close (q # AI) (AI ! j), SI),\n                       (close AI (AI ! j), p # SI)]", "apply(cases SS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>AI ! j = ! (! q && ! (! p)); (AI, SI) = SS;\n        SS = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Lrule_result ImplyL j SS =\n                         [(close (q # AI) (AI ! j), SI),\n                          (close AI (AI ! j), p # SI)]", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?AI7 ! j = ! (! ?q7 && ! (! ?p7)); (?AI7, ?SI7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Lrule_result ImplyL j ?SS7 =\n                    [(close (?q7 # ?AI7) (?AI7 ! j), ?SI7),\n                     (close ?AI7 (?AI7 ! j), ?p7 # ?SI7)]\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume eq:\"fst (SG ! i) ! j = (p \\<rightarrow> q)\""], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p \\<rightarrow> q)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume iL:\"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume jL:\"j < length (fst (SG ! i))\""], ["proof (state)\nthis:\n  j < length (fst (SG ! i))\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Lrule_result ImplyL j (SG ! i) = \n    [(close (q # \\<Gamma>) (nth \\<Gamma> j), \\<Delta>), \n     (close \\<Gamma> (nth \\<Gamma> j), p # \\<Delta>)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lrule_result ImplyL j (SG ! i) =\n    [(close (q # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n     (close \\<Gamma> (\\<Gamma> ! j), p # \\<Delta>)]", "apply(rule implyL_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> ! j = ! (! q && ! (! p))\n 2. (\\<Gamma>, \\<Delta>) = SG ! i", "using SG_dec eq Implies_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<rightarrow> q)\n  (?P \\<rightarrow> ?Q) = (?Q || ! ?P)\n  (?P || ?Q) = ! (! ?P && ! ?Q)\n\ngoal (2 subgoals):\n 1. \\<Gamma> ! j = ! (! q && ! (! p))\n 2. (\\<Gamma>, \\<Delta>) = SG ! i", "by (metis fstI)+"], ["proof (state)\nthis:\n  Lrule_result ImplyL j (SG ! i) =\n  [(close (q # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n   (close \\<Gamma> (\\<Gamma> ! j), p # \\<Delta>)]\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have AIjeq:\"\\<Gamma> ! j = (p \\<rightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<rightarrow> q)", "using SG_dec eq"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<rightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<rightarrow> q)", "unfolding Implies_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = ! (! q && ! (! p))\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = ! (! q && ! (! p))", "by (metis fst_conv)"], ["proof (state)\nthis:\n  \\<Gamma> ! j = (p \\<rightarrow> q)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)],\n      \\<Gamma>, \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I::\"('sf,'sc,'sz) interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sgs:\"(\\<And>i. 0 \\<le> i \\<Longrightarrow>\n             i < length [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] \\<Longrightarrow>\n             \\<nu> \\<in> seq_sem I ([(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] ! i))\""], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?i7;\n   ?i7\n   < length\n      [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (q # \\<Gamma>) (p \\<rightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<rightarrow> q),\n                              p # \\<Delta>)] !\n                            ?i7)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg1:\"\\<nu> \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>)", "using sgs[of 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0;\n   0 < length\n        [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n         (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (q # \\<Gamma>) (p \\<rightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<rightarrow> q),\n                              p # \\<Delta>)] !\n                            0)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg2:\"\\<nu> \\<in> seq_sem I (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)", "using sgs[of \"Suc 0\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> Suc 0;\n   Suc 0\n   < length\n      [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (q # \\<Gamma>) (p \\<rightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<rightarrow> q),\n                              p # \\<Delta>)] !\n                            Suc 0)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \\<Gamma>:\"\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT)\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Gamma>_proj:\"\\<And>\\<phi> \\<Gamma>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "apply(induction \\<Gamma>, auto simp add: member_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "using and_foldl_sem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT);\n   List.member ?\\<Gamma> ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>List.member ?\\<Gamma>7 ?\\<phi>7;\n   \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>7 TT)\\<rbrakk>\n  \\<Longrightarrow> \\<nu> \\<in> fml_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have imp:\"\\<nu> \\<in> fml_sem I (p \\<rightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (p \\<rightarrow> q)", "apply(rule \\<Gamma>_proj[of \\<Gamma>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member \\<Gamma> (p \\<rightarrow> q)\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "using AIjeq  jL SG_dec nth_member"], ["proof (prove)\nusing this:\n  \\<Gamma> ! j = (p \\<rightarrow> q)\n  j < length (fst (SG ! i))\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n\ngoal (2 subgoals):\n 1. List.member \\<Gamma> (p \\<rightarrow> q)\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "apply (metis fst_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "by (rule \\<Gamma>)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (p \\<rightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sub:\"sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>", "by (rule close_sub)"], ["proof (state)\nthis:\n  sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Gamma>C:\"\\<nu> \\<in> fml_sem I (foldr And (close \\<Gamma> (p \\<rightarrow> q)) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I (foldr (&&) (close \\<Gamma> (p \\<rightarrow> q)) TT)", "by (rule \\<Gamma>_sub_sem[OF sub \\<Gamma>])"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (close \\<Gamma> (p \\<rightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)", "by(rule seq_MP[OF sg2 \\<Gamma>C])"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)", "have disj:\"\\<nu> \\<in> fml_sem I p \\<or> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I p \\<or>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "{"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume p:\"\\<nu> \\<in> fml_sem I p\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have q:\"\\<nu> \\<in> fml_sem I q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I q", "using p imp"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p\n  \\<nu> \\<in> fml_sem I (p \\<rightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I q", "by simp"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have res: \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using disj \\<Gamma> seq_semI"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<lbrakk>List.member ?\\<Delta> ?\\<psi>;\n   (\\<And>\\<phi>.\n       List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n       ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I p \\<or>\n             \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu>\n                          \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "using \\<Gamma> q"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I p \\<or>\n             \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu>\n                          \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by (meson \\<Gamma>_sub_sem close_sub seq_MP sg1)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have conj:\"\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "using q \\<Gamma>"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I q\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have conj:\"\\<nu> \\<in> fml_sem I (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)", "apply(rule \\<Gamma>_sub_sem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) ?\\<Gamma>2.0\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>2.0 TT)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>2.0 TT)\n 2. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) ?\\<Gamma>2.0", "apply(rule conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) (q # \\<Gamma>)", "by(rule close_sub)"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> fml_sem I (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Delta>1:\"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by(rule seq_MP[OF sg1 conj])"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "}"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<rightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<rightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using disj"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   ([(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)],\n    \\<Gamma>, \\<Delta>)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq1:\"close ([q] @ \\<Gamma>) (p \\<rightarrow> q) \\<noteq> \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close ([q] @ \\<Gamma>) (p \\<rightarrow> q) \\<noteq> \\<Gamma>", "apply(rule close_app_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member [q] ?x\n 2. ?x \\<noteq> (p \\<rightarrow> q)", "apply(rule mem_sing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p \\<rightarrow> q)", "by (auto simp add: expr_diseq)"], ["proof (state)\nthis:\n  close ([q] @ \\<Gamma>) (p \\<rightarrow> q) \\<noteq> \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq2:\"p # \\<Delta> \\<noteq> \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p # \\<Delta> \\<noteq> \\<Delta>", "by(induction p, auto)"], ["proof (state)\nthis:\n  p # \\<Delta> \\<noteq> \\<Delta>\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)] (\\<Gamma>,\\<Delta>) = [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close\n     [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n      (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n     (\\<Gamma>, \\<Delta>) =\n    [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]", "apply(rule close_nonmember_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member\n            [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n             (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n            (\\<Gamma>, \\<Delta>)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>q \\<noteq> (p \\<rightarrow> q);\n     List.member\n      [(q # filter (\\<lambda>y. y \\<noteq> (p \\<rightarrow> q)) \\<Gamma>,\n        \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> (p \\<rightarrow> q)) \\<Gamma>,\n        p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>q = (p \\<rightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "using neq1 neq2"], ["proof (prove)\nusing this:\n  close ([q] @ \\<Gamma>) (p \\<rightarrow> q) \\<noteq> \\<Gamma>\n  p # \\<Delta> \\<noteq> \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>q \\<noteq> (p \\<rightarrow> q);\n     List.member\n      [(q # filter (\\<lambda>y. y \\<noteq> (p \\<rightarrow> q)) \\<Gamma>,\n        \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> (p \\<rightarrow> q)) \\<Gamma>,\n        p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>q = (p \\<rightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: member_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<rightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<rightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "assume a1: \"q = (p \\<rightarrow> q)\""], ["proof (state)\nthis:\n  q = (p \\<rightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<rightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"List.member [([y\\<leftarrow>\\<Gamma> . y \\<noteq> q], \\<Delta>), ([y\\<leftarrow>\\<Gamma> . y \\<noteq> q], p # \\<Delta>)] (\\<Gamma>, \\<Delta>)\""], ["proof (state)\nthis:\n  List.member\n   [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n    (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<rightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List.member\n   [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n    (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>)", "have \"[f\\<leftarrow>\\<Gamma> . f \\<noteq> q] = \\<Gamma>\""], ["proof (prove)\nusing this:\n  List.member\n   [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n    (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>f. f \\<noteq> q) \\<Gamma> = \\<Gamma>", "by (simp add: member_rec)"], ["proof (state)\nthis:\n  filter (\\<lambda>f. f \\<noteq> q) \\<Gamma> = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<rightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>f. f \\<noteq> q) \\<Gamma> = \\<Gamma>", "show False"], ["proof (prove)\nusing this:\n  filter (\\<lambda>f. f \\<noteq> q) \\<Gamma> = \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "using a1 neq1"], ["proof (prove)\nusing this:\n  filter (\\<lambda>f. f \\<noteq> q) \\<Gamma> = \\<Gamma>\n  q = (p \\<rightarrow> q)\n  close ([q] @ \\<Gamma>) (p \\<rightarrow> q) \\<noteq> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  close\n   [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n    (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>) =\n  [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n   (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Lrule_result ImplyL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Lrule_result ImplyL j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Lrule_result ImplyL j (SG ! i), C)\n 2. sound (close (SG @ Lrule_result ImplyL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound (close (SG @ Lrule_result ImplyL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Lrule_result ImplyL j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(close (q # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n         (close \\<Gamma> (\\<Gamma> ! j), p # \\<Delta>)])\n       (SG ! i),\n      SG ! i)", "apply(unfold AIjeq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n         (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)])\n       (SG ! i),\n      SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close SG (SG ! i) @\n      close\n       [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "using close_eq big_sound SG_dec"], ["proof (prove)\nusing this:\n  close\n   [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n    (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>) =\n  [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n   (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n  sound\n   ([(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)],\n    \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(close (q # \\<Gamma>) (p \\<rightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<rightarrow> q), p # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "by simp"], ["proof (state)\nthis:\n  sound (close (SG @ Lrule_result ImplyL j (SG ! i)) (SG ! i), C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Lrule_EquivBackward SG i j C p q)"], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n  i < length SG\n  j < length (fst (SG ! i))\n  sound (SG, C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have equivLBackward_simp:\"\\<And>AI SI SS p q. \n    (nth AI  j) = Not (And (Not (And p q)) (Not (And (Not p) (Not q)))) \\<Longrightarrow> \n    (AI,SI) = SS \\<Longrightarrow> \n    Lrule_result EquivBackwardL j SS = [(close (p # AI) (nth AI j), SI), (close AI (nth AI j), q # SI)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AI SI SS p q.\n       \\<lbrakk>AI ! j = ! (! (p && q) && ! (! p && ! q));\n        (AI, SI) = SS\\<rbrakk>\n       \\<Longrightarrow> Lrule_result EquivBackwardL j SS =\n                         [(close (p # AI) (AI ! j), SI),\n                          (close AI (AI ! j), q # SI)]", "subgoal for AI SI SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AI ! j = ! (! (p && q) && ! (! p && ! q));\n     (AI, SI) = SS\\<rbrakk>\n    \\<Longrightarrow> Lrule_result EquivBackwardL j SS =\n                      [(close (p # AI) (AI ! j), SI),\n                       (close AI (AI ! j), q # SI)]", "apply(cases SS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>AI ! j = ! (! (p && q) && ! (! p && ! q)); (AI, SI) = SS;\n        SS = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Lrule_result EquivBackwardL j SS =\n                         [(close (p # AI) (AI ! j), SI),\n                          (close AI (AI ! j), q # SI)]", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?AI7 ! j = ! (! (?p7 && ?q7) && ! (! ?p7 && ! ?q7));\n   (?AI7, ?SI7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Lrule_result EquivBackwardL j ?SS7 =\n                    [(close (?p7 # ?AI7) (?AI7 ! j), ?SI7),\n                     (close ?AI7 (?AI7 ! j), ?q7 # ?SI7)]\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume eq:\"fst (SG ! i) ! j = (p \\<leftrightarrow> q)\""], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume iL:\"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume jL:\"j < length (fst (SG ! i))\""], ["proof (state)\nthis:\n  j < length (fst (SG ! i))\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Lrule_result EquivBackwardL j (SG ! i) = \n    [(close (p # \\<Gamma>) (nth \\<Gamma> j), \\<Delta>), \n     (close \\<Gamma> (nth \\<Gamma> j), q # \\<Delta>)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lrule_result EquivBackwardL j (SG ! i) =\n    [(close (p # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n     (close \\<Gamma> (\\<Gamma> ! j), q # \\<Delta>)]", "apply(rule equivLBackward_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> ! j = ! (! (p && q) && ! (! p && ! q))\n 2. (\\<Gamma>, \\<Delta>) = SG ! i", "using SG_dec eq Equiv_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n  (?P \\<leftrightarrow> ?Q) = (?P && ?Q || ! ?P && ! ?Q)\n  (?P || ?Q) = ! (! ?P && ! ?Q)\n\ngoal (2 subgoals):\n 1. \\<Gamma> ! j = ! (! (p && q) && ! (! p && ! q))\n 2. (\\<Gamma>, \\<Delta>) = SG ! i", "by (metis fstI)+"], ["proof (state)\nthis:\n  Lrule_result EquivBackwardL j (SG ! i) =\n  [(close (p # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n   (close \\<Gamma> (\\<Gamma> ! j), q # \\<Delta>)]\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have AIjeq:\"\\<Gamma> ! j = (p \\<leftrightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<leftrightarrow> q)", "using SG_dec eq"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<leftrightarrow> q)", "unfolding Implies_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<leftrightarrow> q)", "by (metis fst_conv)"], ["proof (state)\nthis:\n  \\<Gamma> ! j = (p \\<leftrightarrow> q)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)],\n      \\<Gamma>, \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I::\"('sf,'sc,'sz) interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sgs:\"(\\<And>i. 0 \\<le> i \\<Longrightarrow>\n             i < length [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] \\<Longrightarrow>\n             \\<nu> \\<in> seq_sem I ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] ! i))\""], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?i7;\n   ?i7\n   < length\n      [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<leftrightarrow> q),\n                              q # \\<Delta>)] !\n                            ?i7)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg1:\"\\<nu> \\<in> seq_sem I (close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)", "using sgs[of 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0;\n   0 < length\n        [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n         (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<leftrightarrow> q),\n                              q # \\<Delta>)] !\n                            0)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I (close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg2:\"\\<nu> \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)", "using sgs[of \"Suc 0\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> Suc 0;\n   Suc 0\n   < length\n      [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<leftrightarrow> q),\n                              q # \\<Delta>)] !\n                            Suc 0)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \\<Gamma>:\"\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT)\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Gamma>_proj:\"\\<And>\\<phi> \\<Gamma>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "apply(induction \\<Gamma>, auto simp add: member_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "using and_foldl_sem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT);\n   List.member ?\\<Gamma> ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>List.member ?\\<Gamma>7 ?\\<phi>7;\n   \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>7 TT)\\<rbrakk>\n  \\<Longrightarrow> \\<nu> \\<in> fml_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have imp:\"\\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)", "apply(rule \\<Gamma>_proj[of \\<Gamma>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member \\<Gamma> (p \\<leftrightarrow> q)\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "using AIjeq  jL SG_dec nth_member"], ["proof (prove)\nusing this:\n  \\<Gamma> ! j = (p \\<leftrightarrow> q)\n  j < length (fst (SG ! i))\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n\ngoal (2 subgoals):\n 1. List.member \\<Gamma> (p \\<leftrightarrow> q)\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "apply (metis fst_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "by (rule \\<Gamma>)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sub:\"sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>", "by (rule close_sub)"], ["proof (state)\nthis:\n  sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Gamma>C:\"\\<nu> \\<in> fml_sem I (foldr And (close \\<Gamma> (p \\<rightarrow> q)) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I (foldr (&&) (close \\<Gamma> (p \\<rightarrow> q)) TT)", "by (rule \\<Gamma>_sub_sem[OF sub \\<Gamma>])"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (close \\<Gamma> (p \\<rightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)", "by (metis \\<Gamma> \\<Gamma>_sub_sem close_sub iff_sem imp member_rec(1) or_foldl_sem or_foldl_sem_conv seq_MP sg2)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)", "have disj:\"\\<nu> \\<in> fml_sem I p \\<or> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I p \\<or>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "{"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume p:\"\\<nu> \\<in> fml_sem I p\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have q:\"\\<nu> \\<in> fml_sem I q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I q", "using p imp"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p\n  \\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I q", "by simp"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have res: \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using disj \\<Gamma> seq_semI"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<lbrakk>List.member ?\\<Delta> ?\\<psi>;\n   (\\<And>\\<phi>.\n       List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n       ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I p \\<or>\n             \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu>\n                          \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "using \\<Gamma> q"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I p \\<or>\n             \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu>\n                          \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<forall>fs p i. (\\<exists>f. List.member fs (f::('sf, 'sc, 'sz) formula) \\<and> p \\<notin> fml_sem i f) \\<or> p \\<in> fml_sem i (foldr (&&) fs TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fs p i.\n       (\\<exists>f. List.member fs f \\<and> p \\<notin> fml_sem i f) \\<or>\n       p \\<in> fml_sem i (foldr (&&) fs TT)", "using and_foldl_sem_conv"], ["proof (prove)\nusing this:\n  (\\<And>\\<phi>.\n      List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n      ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n  ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<forall>fs p i.\n       (\\<exists>f. List.member fs f \\<and> p \\<notin> fml_sem i f) \\<or>\n       p \\<in> fml_sem i (foldr (&&) fs TT)", "by blast"], ["proof (state)\nthis:\n  \\<forall>fs p i.\n     (\\<exists>f. List.member fs f \\<and> p \\<notin> fml_sem i f) \\<or>\n     p \\<in> fml_sem i (foldr (&&) fs TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<forall>fs p i.\n     (\\<exists>f. List.member fs f \\<and> p \\<notin> fml_sem i f) \\<or>\n     p \\<in> fml_sem i (foldr (&&) fs TT)", "obtain ff :: \"('sf, 'sc, 'sz) formula list \\<Rightarrow> (real, 'sz) vec \\<times> (real, 'sz) vec \\<Rightarrow> ('sf, 'sc, 'sz) interp \\<Rightarrow> ('sf, 'sc, 'sz) formula\" where\n                f1: \"\\<forall>fs p i. List.member fs (ff fs p i) \\<and> p \\<notin> fml_sem i (ff fs p i) \\<or> p \\<in> fml_sem i (foldr (&&) fs TT)\""], ["proof (prove)\nusing this:\n  \\<forall>fs p i.\n     (\\<exists>f. List.member fs f \\<and> p \\<notin> fml_sem i f) \\<or>\n     p \\<in> fml_sem i (foldr (&&) fs TT)\n\ngoal (1 subgoal):\n 1. (\\<And>ff.\n        \\<forall>fs p i.\n           List.member fs (ff fs p i) \\<and>\n           p \\<notin> fml_sem i (ff fs p i) \\<or>\n           p \\<in> fml_sem i (foldr (&&) fs TT) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>fs p i.\n     List.member fs (ff fs p i) \\<and>\n     p \\<notin> fml_sem i (ff fs p i) \\<or>\n     p \\<in> fml_sem i (foldr (&&) fs TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<And>f. \\<nu> \\<in> fml_sem I f \\<or> \\<not> List.member \\<Gamma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. \\<nu> \\<in> fml_sem I f \\<or> \\<not> List.member \\<Gamma> f", "by (meson \\<open>\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\\<close> and_foldl_sem member_rec(1))"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I ?f7 \\<or> \\<not> List.member \\<Gamma> ?f7\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I ?f7 \\<or> \\<not> List.member \\<Gamma> ?f7", "have \"\\<nu> \\<in> fml_sem I (foldr (&&) (close (p # \\<Gamma>) (p \\<leftrightarrow> q)) TT)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I ?f7 \\<or> \\<not> List.member \\<Gamma> ?f7\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (&&) (close (p # \\<Gamma>) (p \\<leftrightarrow> q)) TT)", "using f1"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I ?f7 \\<or> \\<not> List.member \\<Gamma> ?f7\n  \\<forall>fs p i.\n     List.member fs (ff fs p i) \\<and>\n     p \\<notin> fml_sem i (ff fs p i) \\<or>\n     p \\<in> fml_sem i (foldr (&&) fs TT)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (&&) (close (p # \\<Gamma>) (p \\<leftrightarrow> q)) TT)", "by (metis (no_types) close_sub local.sublist_def member_rec(1) p)"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (&&) (close (p # \\<Gamma>) (p \\<leftrightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (&&) (close (p # \\<Gamma>) (p \\<leftrightarrow> q)) TT)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (&&) (close (p # \\<Gamma>) (p \\<leftrightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using seq_MP sg1"], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (&&) (close (p # \\<Gamma>) (p \\<leftrightarrow> q)) TT)\n  \\<lbrakk>?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>);\n   ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)\n  \\<nu>\n  \\<in> seq_sem I (close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by blast"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have conj:\"\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "using q \\<Gamma>"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I q\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have conj:\"\\<nu> \\<in> fml_sem I (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)", "apply(rule \\<Gamma>_sub_sem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) ?\\<Gamma>2.0\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>2.0 TT)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>2.0 TT)\n 2. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) ?\\<Gamma>2.0", "apply(rule conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) (q # \\<Gamma>)", "by(rule close_sub)"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> fml_sem I (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Delta>1:\"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using res"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by blast"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "}"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   q # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (p # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using disj"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)],\n    \\<Gamma>, \\<Delta>)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq1:\"close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>", "apply(rule close_app_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member [q] ?x\n 2. ?x \\<noteq> (p \\<leftrightarrow> q)", "apply(rule mem_sing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p \\<leftrightarrow> q)", "by (auto simp add: expr_diseq)"], ["proof (state)\nthis:\n  close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq2:\"p # \\<Delta> \\<noteq> \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p # \\<Delta> \\<noteq> \\<Delta>", "by(induction p, auto)"], ["proof (state)\nthis:\n  p # \\<Delta> \\<noteq> \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)] (\\<Gamma>,\\<Delta>) = [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close\n     [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n      (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n     (\\<Gamma>, \\<Delta>) =\n    [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]", "apply(rule close_nonmember_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member\n            [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n             (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n            (\\<Gamma>, \\<Delta>)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> (p \\<leftrightarrow> q);\n     List.member\n      [(p #\n        filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>p = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "using neq1 neq2"], ["proof (prove)\nusing this:\n  close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>\n  p # \\<Delta> \\<noteq> \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> (p \\<leftrightarrow> q);\n     List.member\n      [(p #\n        filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>p = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: member_rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> (p \\<leftrightarrow> q);\n     p # filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma> =\n     \\<Gamma>;\n     (if q \\<noteq> (p \\<leftrightarrow> q)\n      then q #\n           filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>\n      else filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q))\n            \\<Gamma>) \\<noteq>\n     \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>p = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis append_Cons append_Nil close.simps close_app_neq member_rec(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "assume a1:\"p = (p \\<leftrightarrow> q)\""], ["proof (state)\nthis:\n  p = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> p) \\<Gamma>, q # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = (p \\<leftrightarrow> q)", "show False"], ["proof (prove)\nusing this:\n  p = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: expr_diseq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  close\n   [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n    (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>) =\n  [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n   (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivBackwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Lrule_result EquivBackwardL j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Lrule_result EquivBackwardL j (SG ! i), C)\n 2. sound\n     (close (SG @ Lrule_result EquivBackwardL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound\n     (close (SG @ Lrule_result EquivBackwardL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close (SG @ Lrule_result EquivBackwardL j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(close (p # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n         (close \\<Gamma> (\\<Gamma> ! j), q # \\<Delta>)])\n       (SG ! i),\n      SG ! i)", "apply(unfold AIjeq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n         (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)])\n       (SG ! i),\n      SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close SG (SG ! i) @\n      close\n       [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "using close_eq big_sound SG_dec"], ["proof (prove)\nusing this:\n  close\n   [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n    (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>) =\n  [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n   (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n  sound\n   ([(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)],\n    \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(close (p # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<leftrightarrow> q), q # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "by simp"], ["proof (state)\nthis:\n  sound (close (SG @ Lrule_result EquivBackwardL j (SG ! i)) (SG ! i), C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Lrule_EquivForward SG i j C p q)"], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n  i < length SG\n  j < length (fst (SG ! i))\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have equivLForward_simp:\"\\<And>AI SI SS p q. \n    (nth AI  j) = Not (And (Not (And p q)) (Not (And (Not p) (Not q)))) \\<Longrightarrow> \n    (AI,SI) = SS \\<Longrightarrow> \n    Lrule_result EquivForwardL j SS = [(close (q # AI) (nth AI j), SI), (close AI (nth AI j), p # SI)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AI SI SS p q.\n       \\<lbrakk>AI ! j = ! (! (p && q) && ! (! p && ! q));\n        (AI, SI) = SS\\<rbrakk>\n       \\<Longrightarrow> Lrule_result EquivForwardL j SS =\n                         [(close (q # AI) (AI ! j), SI),\n                          (close AI (AI ! j), p # SI)]", "subgoal for AI SI SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AI ! j = ! (! (p && q) && ! (! p && ! q));\n     (AI, SI) = SS\\<rbrakk>\n    \\<Longrightarrow> Lrule_result EquivForwardL j SS =\n                      [(close (q # AI) (AI ! j), SI),\n                       (close AI (AI ! j), p # SI)]", "apply(cases SS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>AI ! j = ! (! (p && q) && ! (! p && ! q)); (AI, SI) = SS;\n        SS = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Lrule_result EquivForwardL j SS =\n                         [(close (q # AI) (AI ! j), SI),\n                          (close AI (AI ! j), p # SI)]", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?AI7 ! j = ! (! (?p7 && ?q7) && ! (! ?p7 && ! ?q7));\n   (?AI7, ?SI7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Lrule_result EquivForwardL j ?SS7 =\n                    [(close (?q7 # ?AI7) (?AI7 ! j), ?SI7),\n                     (close ?AI7 (?AI7 ! j), ?p7 # ?SI7)]\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume eq:\"fst (SG ! i) ! j = (p \\<leftrightarrow> q)\""], ["proof (state)\nthis:\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume iL:\"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume jL:\"j < length (fst (SG ! i))\""], ["proof (state)\nthis:\n  j < length (fst (SG ! i))\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Lrule_result EquivForwardL j (SG ! i) = \n    [(close (q # \\<Gamma>) (nth \\<Gamma> j), \\<Delta>), \n     (close \\<Gamma> (nth \\<Gamma> j), p # \\<Delta>)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lrule_result EquivForwardL j (SG ! i) =\n    [(close (q # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n     (close \\<Gamma> (\\<Gamma> ! j), p # \\<Delta>)]", "apply(rule equivLForward_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> ! j = ! (! (p && q) && ! (! p && ! q))\n 2. (\\<Gamma>, \\<Delta>) = SG ! i", "using SG_dec eq Equiv_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n  (?P \\<leftrightarrow> ?Q) = (?P && ?Q || ! ?P && ! ?Q)\n  (?P || ?Q) = ! (! ?P && ! ?Q)\n\ngoal (2 subgoals):\n 1. \\<Gamma> ! j = ! (! (p && q) && ! (! p && ! q))\n 2. (\\<Gamma>, \\<Delta>) = SG ! i", "by (metis fstI)+"], ["proof (state)\nthis:\n  Lrule_result EquivForwardL j (SG ! i) =\n  [(close (q # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n   (close \\<Gamma> (\\<Gamma> ! j), p # \\<Delta>)]\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have AIjeq:\"\\<Gamma> ! j = (p \\<leftrightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<leftrightarrow> q)", "using SG_dec eq"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<leftrightarrow> q)", "unfolding Implies_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  fst (SG ! i) ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = (p \\<leftrightarrow> q)", "by (metis fst_conv)"], ["proof (state)\nthis:\n  \\<Gamma> ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)],\n      \\<Gamma>, \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I::\"('sf,'sc,'sz) interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sgs:\"(\\<And>i. 0 \\<le> i \\<Longrightarrow>\n             i < length [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] \\<Longrightarrow>\n             \\<nu> \\<in> seq_sem I ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] ! i))\""], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?i7;\n   ?i7\n   < length\n      [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<leftrightarrow> q),\n                              p # \\<Delta>)] !\n                            ?i7)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg1:\"\\<nu> \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)", "using sgs[of 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0;\n   0 < length\n        [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n         (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<leftrightarrow> q),\n                              p # \\<Delta>)] !\n                            0)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I (close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg2:\"\\<nu> \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)", "using sgs[of \"Suc 0\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> Suc 0;\n   Suc 0\n   < length\n      [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n       (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q),\n                              \\<Delta>),\n                             (close \\<Gamma> (p \\<leftrightarrow> q),\n                              p # \\<Delta>)] !\n                            Suc 0)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> seq_sem I (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \\<Gamma>:\"\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT)\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Gamma>_proj:\"\\<And>\\<phi> \\<Gamma>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "apply(induction \\<Gamma>, auto simp add: member_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "using and_foldl_sem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT);\n   List.member ?\\<Gamma> ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<Gamma>.\n       \\<lbrakk>List.member \\<Gamma> \\<phi>;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>List.member ?\\<Gamma>7 ?\\<phi>7;\n   \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>7 TT)\\<rbrakk>\n  \\<Longrightarrow> \\<nu> \\<in> fml_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have imp:\"\\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)", "apply(rule \\<Gamma>_proj[of \\<Gamma>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member \\<Gamma> (p \\<leftrightarrow> q)\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "using AIjeq  jL SG_dec nth_member"], ["proof (prove)\nusing this:\n  \\<Gamma> ! j = (p \\<leftrightarrow> q)\n  j < length (fst (SG ! i))\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n\ngoal (2 subgoals):\n 1. List.member \\<Gamma> (p \\<leftrightarrow> q)\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "apply (metis fst_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "by (rule \\<Gamma>)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sub:\"sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>", "by (rule close_sub)"], ["proof (state)\nthis:\n  sublist (close \\<Gamma> (p \\<rightarrow> q)) \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Gamma>C:\"\\<nu> \\<in> fml_sem I (foldr And (close \\<Gamma> (p \\<rightarrow> q)) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I (foldr (&&) (close \\<Gamma> (p \\<rightarrow> q)) TT)", "by (rule \\<Gamma>_sub_sem[OF sub \\<Gamma>])"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (close \\<Gamma> (p \\<rightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)", "by (metis \\<Gamma> \\<Gamma>_sub_sem close_sub iff_sem imp member_rec(1) or_foldl_sem or_foldl_sem_conv seq_MP sg2)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)", "have disj:\"\\<nu> \\<in> fml_sem I p \\<or> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # \\<Delta>) FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I p \\<or>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "{"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume p:\"\\<nu> \\<in> fml_sem I p\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have q:\"\\<nu> \\<in> fml_sem I q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I q", "using p imp"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p\n  \\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I q", "by simp"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have res: \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using disj \\<Gamma> seq_semI"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<lbrakk>List.member ?\\<Delta> ?\\<psi>;\n   (\\<And>\\<phi>.\n       List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n       ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I p \\<or>\n             \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu>\n                          \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "using \\<Gamma> q"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I p \\<or>\n             \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu>\n                          \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by (meson \\<open>\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\\<close> and_foldl_sem and_foldl_sem_conv close_sub local.sublist_def seq_MP sg1)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have conj:\"\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "using q \\<Gamma>"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I q\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have conj:\"\\<nu> \\<in> fml_sem I (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)", "apply(rule \\<Gamma>_sub_sem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) ?\\<Gamma>2.0\n 2. \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>2.0 TT)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) ?\\<Gamma>2.0 TT)\n 2. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) ?\\<Gamma>2.0", "apply(rule conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (close (q # \\<Gamma>) (p \\<rightarrow> q)) (q # \\<Gamma>)", "by(rule close_sub)"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> fml_sem I (foldr (&&) (close (q # \\<Gamma>) (p \\<rightarrow> q)) TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Delta>1:\"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using res"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by blast"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "}"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n                  (close \\<Gamma> (p \\<leftrightarrow> q),\n                   p # \\<Delta>)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(close (q # \\<Gamma>)\n  (p \\<leftrightarrow> q),\n \\<Delta>),\n(close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using disj"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  \\<nu> \\<in> fml_sem I p \\<or>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)],\n    \\<Gamma>, \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq1:\"close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>", "apply(rule close_app_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member [q] ?x\n 2. ?x \\<noteq> (p \\<leftrightarrow> q)", "apply(rule mem_sing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p \\<leftrightarrow> q)", "by (auto simp add: expr_diseq)"], ["proof (state)\nthis:\n  close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq2:\"p # \\<Delta> \\<noteq> \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p # \\<Delta> \\<noteq> \\<Delta>", "by(induction p, auto)"], ["proof (state)\nthis:\n  p # \\<Delta> \\<noteq> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)] (\\<Gamma>,\\<Delta>) = [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>), (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close\n     [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n      (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n     (\\<Gamma>, \\<Delta>) =\n    [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]", "apply(rule close_nonmember_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member\n            [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n             (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n            (\\<Gamma>, \\<Delta>)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>q \\<noteq> (p \\<leftrightarrow> q);\n     List.member\n      [(q #\n        filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>q = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "using neq1 neq2"], ["proof (prove)\nusing this:\n  close ([q] @ \\<Gamma>) (p \\<leftrightarrow> q) \\<noteq> \\<Gamma>\n  p # \\<Delta> \\<noteq> \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>q \\<noteq> (p \\<leftrightarrow> q);\n     List.member\n      [(q #\n        filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> (p \\<leftrightarrow> q)) \\<Gamma>,\n        p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>q = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: member_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "assume a1:\"q = (p \\<leftrightarrow> q)\""], ["proof (state)\nthis:\n  q = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q = (p \\<leftrightarrow> q);\n     List.member\n      [(filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, \\<Delta>),\n       (filter (\\<lambda>y. y \\<noteq> q) \\<Gamma>, p # \\<Delta>)]\n      (\\<Gamma>, \\<Delta>)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q = (p \\<leftrightarrow> q)", "show False"], ["proof (prove)\nusing this:\n  q = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: expr_diseq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  close\n   [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n    (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>) =\n  [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n   (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>fst (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (fst (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close\n                            (SG @ Lrule_result EquivForwardL j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Lrule_result EquivForwardL j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Lrule_result EquivForwardL j (SG ! i), C)\n 2. sound\n     (close (SG @ Lrule_result EquivForwardL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound\n     (close (SG @ Lrule_result EquivForwardL j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close (SG @ Lrule_result EquivForwardL j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(close (q # \\<Gamma>) (\\<Gamma> ! j), \\<Delta>),\n         (close \\<Gamma> (\\<Gamma> ! j), p # \\<Delta>)])\n       (SG ! i),\n      SG ! i)", "apply(unfold AIjeq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n         (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)])\n       (SG ! i),\n      SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close SG (SG ! i) @\n      close\n       [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "using close_eq big_sound SG_dec"], ["proof (prove)\nusing this:\n  close\n   [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n    (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n   (\\<Gamma>, \\<Delta>) =\n  [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n   (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n  sound\n   ([(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n     (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)],\n    \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(close (q # \\<Gamma>) (p \\<leftrightarrow> q), \\<Delta>),\n        (close \\<Gamma> (p \\<leftrightarrow> q), p # \\<Delta>)]\n       (SG ! i),\n      SG ! i)", "by simp"], ["proof (state)\nthis:\n  sound (close (SG @ Lrule_result EquivForwardL j (SG ! i)) (SG ! i), C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rrule_sound: \"rrule_ok SG C i j L \\<Longrightarrow> i < length SG \\<Longrightarrow> j < length (snd (SG ! i)) \\<Longrightarrow> sound (SG,C) \\<Longrightarrow> sound (close (append SG (Rrule_result L j (nth SG i))) (nth SG i), C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rrule_ok SG C i j L; i < length SG; j < length (snd (SG ! i));\n     sound (SG, C)\\<rbrakk>\n    \\<Longrightarrow> sound\n                       (close (SG @ Rrule_result L j (SG ! i)) (SG ! i), C)", "proof(induction rule: rrule_ok.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Rrule_And SG i j C p q)"], ["proof (state)\nthis:\n  snd (SG ! i) ! j = (p && q)\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume eq:\"snd (SG ! i) ! j = (p && q)\""], ["proof (state)\nthis:\n  snd (SG ! i) ! j = (p && q)\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"j < length (snd (SG ! i))\""], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have andR_simp:\"\\<And>\\<Gamma> \\<Delta> SS p q. \n    (nth \\<Delta> j) = And p q \\<Longrightarrow> \n    (\\<Gamma>,\\<Delta>) = SS \\<Longrightarrow> \n    Rrule_result AndR j SS = [(\\<Gamma>, p # (close \\<Delta> (nth \\<Delta> j))), (\\<Gamma>, q # (close \\<Delta> (nth \\<Delta> j)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> \\<Delta> SS p q.\n       \\<lbrakk>\\<Delta> ! j = (p && q); (\\<Gamma>, \\<Delta>) = SS\\<rbrakk>\n       \\<Longrightarrow> Rrule_result AndR j SS =\n                         [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                          (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]", "subgoal for AI SI SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SI ! j = (p && q); (AI, SI) = SS\\<rbrakk>\n    \\<Longrightarrow> Rrule_result AndR j SS =\n                      [(AI, p # close SI (SI ! j)),\n                       (AI, q # close SI (SI ! j))]", "apply(cases SS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>SI ! j = (p && q); (AI, SI) = SS; SS = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Rrule_result AndR j SS =\n                         [(AI, p # close SI (SI ! j)),\n                          (AI, q # close SI (SI ! j))]", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Delta>7 ! j = (?p7 && ?q7);\n   (?\\<Gamma>7, ?\\<Delta>7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Rrule_result AndR j ?SS7 =\n                    [(?\\<Gamma>7, ?p7 # close ?\\<Delta>7 (?\\<Delta>7 ! j)),\n                     (?\\<Gamma>7, ?q7 # close ?\\<Delta>7 (?\\<Delta>7 ! j))]\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Rrule_result AndR j (SG ! i) = \n    [(\\<Gamma>, p # (close \\<Delta> (nth \\<Delta> j))), (\\<Gamma>, q # (close \\<Delta> (nth \\<Delta> j)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rrule_result AndR j (SG ! i) =\n    [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n     (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]", "using SG_dec andR_simp"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  \\<lbrakk>?\\<Delta>7 ! j = (?p7 && ?q7);\n   (?\\<Gamma>7, ?\\<Delta>7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Rrule_result AndR j ?SS7 =\n                    [(?\\<Gamma>7, ?p7 # close ?\\<Delta>7 (?\\<Delta>7 ! j)),\n                     (?\\<Gamma>7, ?q7 # close ?\\<Delta>7 (?\\<Delta>7 ! j))]\n\ngoal (1 subgoal):\n 1. Rrule_result AndR j (SG ! i) =\n    [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n     (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n    Rrule_result AndR j (SG ! i) =\n    [(\\<Gamma>, p # filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j) \\<Delta>),\n     (\\<Gamma>, q # filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j) \\<Delta>)]", "using SG_dec eq Implies_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p && q)\n  (?P \\<rightarrow> ?Q) = (?Q || ! ?P)\n  (?P || ?Q) = ! (! ?P && ! ?Q)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n    Rrule_result AndR j (SG ! i) =\n    [(\\<Gamma>, p # filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j) \\<Delta>),\n     (\\<Gamma>, q # filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j) \\<Delta>)]", "using fstI"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p && q)\n  (?P \\<rightarrow> ?Q) = (?Q || ! ?P)\n  (?P || ?Q) = ! (! ?P && ! ?Q)\n  ?x = (?y, ?z) \\<Longrightarrow> fst ?x = ?y\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n    Rrule_result AndR j (SG ! i) =\n    [(\\<Gamma>, p # filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j) \\<Delta>),\n     (\\<Gamma>, q # filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j) \\<Delta>)]", "by (metis andR_simp close.simps snd_conv)"], ["proof (state)\nthis:\n  Rrule_result AndR j (SG ! i) =\n  [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n   (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have AIjeq:\"\\<Delta> ! j = (p && q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p && q)", "using SG_dec eq snd_conv"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p && q)\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p && q)", "by metis"], ["proof (state)\nthis:\n  \\<Delta> ! j = (p && q)\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([(\\<Gamma>, p # (close \\<Delta> (nth \\<Delta> j))), (\\<Gamma>, q # (close \\<Delta> (nth \\<Delta> j)))], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n       (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))],\n      \\<Gamma>, \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I::\"('sf,'sc,'sz) interp\" and \\<nu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sgs:\"(\\<And>i. 0 \\<le> i \\<Longrightarrow>\n             i < length [(\\<Gamma>, p # close \\<Delta> (nth \\<Delta>  j)), (\\<Gamma>, q # close \\<Delta> (nth \\<Delta>  j))] \\<Longrightarrow>\n             \\<nu> \\<in> seq_sem I (nth [(\\<Gamma>, p # close \\<Delta> (nth \\<Delta>  j)), (\\<Gamma>, q # close \\<Delta> (nth \\<Delta> j))] i))\""], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?i7;\n   ?i7\n   < length\n      [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n       (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                             (\\<Gamma>,\n                              q # close \\<Delta> (\\<Delta> ! j))] !\n                            ?i7)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \\<Gamma>_sem:\"\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg1:\"\\<nu> \\<in> seq_sem I (\\<Gamma>, p # close \\<Delta> (nth \\<Delta> j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j))", "using sgs[of 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0;\n   0 < length\n        [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n         (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                             (\\<Gamma>,\n                              q # close \\<Delta> (\\<Delta> ! j))] !\n                            0)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j))", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j))\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg2:\"\\<nu> \\<in> seq_sem I (\\<Gamma>, q # close \\<Delta> (nth \\<Delta> j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))", "using sgs[of 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1;\n   1 < length\n        [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n         (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                             (\\<Gamma>,\n                              q # close \\<Delta> (\\<Delta> ! j))] !\n                            1)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Delta>1:\"\\<nu> \\<in> fml_sem I (foldr (||) (p # close \\<Delta> (nth \\<Delta> j)) FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I (foldr (||) (p # close \\<Delta> (\\<Delta> ! j)) FF)", "by(rule seq_MP[OF sg1 \\<Gamma>_sem])"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # close \\<Delta> (\\<Delta> ! j)) FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Delta>2:\"\\<nu> \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (nth \\<Delta> j)) FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)", "by(rule seq_MP[OF sg2 \\<Gamma>_sem])"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \\<Delta>':\"\\<nu> \\<in> fml_sem I (foldr (||) ((p && q) # close \\<Delta> (nth \\<Delta> j)) FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j)) FF)", "using \\<Delta>1 \\<Delta>2"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # close \\<Delta> (\\<Delta> ! j)) FF)\n  \\<nu> \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j)) FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> fml_sem I (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j)) FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have mem_eq:\"\\<And>x. List.member ((p && q) # close \\<Delta> (nth \\<Delta> j)) x \\<Longrightarrow> List.member \\<Delta> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member ((p && q) # close \\<Delta> (\\<Delta> ! j))\n        x \\<Longrightarrow>\n       List.member \\<Delta> x", "using Rrule_And.prems SG_dec eq  member_rec(1) nth_member"], ["proof (prove)\nusing this:\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p && q)\n  List.member (?x # ?xs) ?y = (?x = ?y \\<or> List.member ?xs ?y)\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member ((p && q) # close \\<Delta> (\\<Delta> ! j))\n        x \\<Longrightarrow>\n       List.member \\<Delta> x", "by (metis close_sub local.sublist_def snd_conv)"], ["proof (state)\nthis:\n  List.member ((p && q) # close \\<Delta> (\\<Delta> ! j))\n   ?x7 \\<Longrightarrow>\n  List.member \\<Delta> ?x7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have myeq:\"\\<nu> \\<in> fml_sem I (foldr (||) ((p && q) # close \\<Delta> (nth \\<Delta> j)) FF) \\<Longrightarrow>  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j))\n             FF) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using  seq_semI Rrule_And.prems SG_dec eq  seq_MP seq_semI' mem_eq\n        or_foldl_sem or_foldl_sem_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>List.member ?\\<Delta> ?\\<psi>;\n   (\\<And>\\<phi>.\n       List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n       ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p && q)\n  \\<lbrakk>?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>);\n   ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)\n  (?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)) \\<Longrightarrow>\n  ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n  List.member ((p && q) # close \\<Delta> (\\<Delta> ! j))\n   ?x7 \\<Longrightarrow>\n  List.member \\<Delta> ?x7\n  \\<lbrakk>List.member ?\\<Gamma> ?\\<phi>;\n   ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF)\n  ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF) \\<Longrightarrow>\n  \\<exists>\\<phi>.\n     ?\\<nu> \\<in> fml_sem ?I \\<phi> \\<and> List.member ?\\<Gamma> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I\n           (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j))\n             FF) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by metis"], ["proof (state)\nthis:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j))\n           FF) \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n                  (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>,\n p # close \\<Delta> (\\<Delta> ! j)),\n(\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j))\n           FF) \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j))\n           FF) \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using \\<Delta>'"], ["proof (prove)\nusing this:\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j))\n           FF) \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  \\<nu>\n  \\<in> fml_sem I (foldr (||) ((p && q) # close \\<Delta> (\\<Delta> ! j)) FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   ([(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n     (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))],\n    \\<Gamma>, \\<Delta>)\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have list_neqI1:\"\\<And>L1 L2 x. List.member L1 x \\<Longrightarrow> \\<not>(List.member L2 x) \\<Longrightarrow> L1 \\<noteq> L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>L1 L2 x.\n       \\<lbrakk>List.member L1 x; \\<not> List.member L2 x\\<rbrakk>\n       \\<Longrightarrow> L1 \\<noteq> L2", "by(auto)"], ["proof (state)\nthis:\n  \\<lbrakk>List.member ?L1.7 ?x7; \\<not> List.member ?L2.7 ?x7\\<rbrakk>\n  \\<Longrightarrow> ?L1.7 \\<noteq> ?L2.7\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have list_neqI2:\"\\<And>L1 L2 x. \\<not>(List.member L1 x) \\<Longrightarrow> (List.member L2 x) \\<Longrightarrow> L1 \\<noteq> L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>L1 L2 x.\n       \\<lbrakk>\\<not> List.member L1 x; List.member L2 x\\<rbrakk>\n       \\<Longrightarrow> L1 \\<noteq> L2", "by(auto)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> List.member ?L1.8 ?x8; List.member ?L2.8 ?x8\\<rbrakk>\n  \\<Longrightarrow> ?L1.8 \\<noteq> ?L2.8\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have notin_cons:\"\\<And>x y ys. x \\<noteq> y \\<Longrightarrow> \\<not>(List.member ys x) \\<Longrightarrow> \\<not>(List.member (y # ys) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ys.\n       \\<lbrakk>x \\<noteq> y; \\<not> List.member ys x\\<rbrakk>\n       \\<Longrightarrow> \\<not> List.member (y # ys) x", "subgoal for x y ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; \\<not> List.member ys x\\<rbrakk>\n    \\<Longrightarrow> \\<not> List.member (y # ys) x", "by(induction ys, auto simp add: member_rec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?x9 \\<noteq> ?y9; \\<not> List.member ?ys9 ?x9\\<rbrakk>\n  \\<Longrightarrow> \\<not> List.member (?y9 # ?ys9) ?x9\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have notin_close:\"\\<And>L x. \\<not>(List.member (close L x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>L x. \\<not> List.member (close L x) x", "subgoal for L x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member (close L x) x", "by(induction L, auto simp add: member_rec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> List.member (close ?L10 ?x10) ?x10\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq_lemma:\"\\<And>L x y. List.member L x \\<Longrightarrow> y \\<noteq> x \\<Longrightarrow> (y # (close L x)) \\<noteq> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>L x y.\n       \\<lbrakk>List.member L x; y \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> y # close L x \\<noteq> L", "subgoal for L x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> y # close L x \\<noteq> L", "apply(cases \"List.member L y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> y # close L x \\<noteq> L\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> y # close L x \\<noteq> L", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> y # close L x \\<noteq> L", "apply(rule list_neqI2[of \"y # close L x\" x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> \\<not> List.member (y # close L x) x\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x", "apply(rule notin_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> \\<not> List.member (close L x) x\n 3. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> \\<not> List.member (close L x) x\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x\n 3. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y", "apply(rule notin_close)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; List.member L y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y", "by(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> y # close L x \\<noteq> L", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> y # close L x \\<noteq> L", "apply(rule list_neqI2[of \"y # close L x\" x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> \\<not> List.member (y # close L x) x\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x", "apply(rule notin_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> \\<not> List.member (close L x) x\n 3. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> \\<not> List.member (close L x) x\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x\n 3. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y", "apply(rule notin_close)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> List.member L x\n 2. \\<lbrakk>List.member L x; y \\<noteq> x; \\<not> List.member L y\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y", "by(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>List.member ?L11 ?x11; ?y11 \\<noteq> ?x11\\<rbrakk>\n  \\<Longrightarrow> ?y11 # close ?L11 ?x11 \\<noteq> ?L11\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq1:\"p # close \\<Delta> (p && q) \\<noteq> \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p # close \\<Delta> (p && q) \\<noteq> \\<Delta>", "apply(rule neq_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member \\<Delta> (p && q)\n 2. p \\<noteq> (p && q)", "apply (metis Rrule_And.prems(2) SG_dec eq nth_member sndI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> (p && q)", "by(auto simp add: expr_diseq)"], ["proof (state)\nthis:\n  p # close \\<Delta> (p && q) \\<noteq> \\<Delta>\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have neq2:\"q # close \\<Delta> (p && q) \\<noteq> \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q # close \\<Delta> (p && q) \\<noteq> \\<Delta>", "apply(rule neq_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.member \\<Delta> (p && q)\n 2. q \\<noteq> (p && q)", "apply (metis Rrule_And.prems(2) SG_dec eq nth_member sndI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p && q)", "by(auto simp add: expr_diseq)"], ["proof (state)\nthis:\n  q # close \\<Delta> (p && q) \\<noteq> \\<Delta>\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [(\\<Gamma>, p # close \\<Delta> (p && q)), (\\<Gamma>, q # close \\<Delta> (p && q))] (\\<Gamma>,\\<Delta>) = [(\\<Gamma>, p # close \\<Delta> (p && q)), (\\<Gamma>, q # close \\<Delta> (p && q))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close\n     [(\\<Gamma>, p # close \\<Delta> (p && q)),\n      (\\<Gamma>, q # close \\<Delta> (p && q))]\n     (\\<Gamma>, \\<Delta>) =\n    [(\\<Gamma>, p # close \\<Delta> (p && q)),\n     (\\<Gamma>, q # close \\<Delta> (p && q))]", "apply(rule close_nonmember_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member\n            [(\\<Gamma>, p # close \\<Delta> (p && q)),\n             (\\<Gamma>, q # close \\<Delta> (p && q))]\n            (\\<Gamma>, \\<Delta>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member\n     [(\\<Gamma>, p # filter (\\<lambda>y. y \\<noteq> (p && q)) \\<Delta>),\n      (\\<Gamma>, q # filter (\\<lambda>y. y \\<noteq> (p && q)) \\<Delta>)]\n     (\\<Gamma>, \\<Delta>) \\<Longrightarrow>\n    False", "using neq1 neq2"], ["proof (prove)\nusing this:\n  p # close \\<Delta> (p && q) \\<noteq> \\<Delta>\n  q # close \\<Delta> (p && q) \\<noteq> \\<Delta>\n\ngoal (1 subgoal):\n 1. List.member\n     [(\\<Gamma>, p # filter (\\<lambda>y. y \\<noteq> (p && q)) \\<Delta>),\n      (\\<Gamma>, q # filter (\\<lambda>y. y \\<noteq> (p && q)) \\<Delta>)]\n     (\\<Gamma>, \\<Delta>) \\<Longrightarrow>\n    False", "by (simp add: member_rec)"], ["proof (state)\nthis:\n  close\n   [(\\<Gamma>, p # close \\<Delta> (p && q)),\n    (\\<Gamma>, q # close \\<Delta> (p && q))]\n   (\\<Gamma>, \\<Delta>) =\n  [(\\<Gamma>, p # close \\<Delta> (p && q)),\n   (\\<Gamma>, q # close \\<Delta> (p && q))]\n\ngoal (6 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p && q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result AndR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 6. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "show \" sound (close (SG @ Rrule_result AndR j (SG ! i)) (SG ! i), C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result AndR j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Rrule_result AndR j (SG ! i), C)\n 2. sound (close (SG @ Rrule_result AndR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound (close (SG @ Rrule_result AndR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result AndR j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n         (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))])\n       (SG ! i),\n      SG ! i)", "apply(unfold AIjeq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       (SG @\n        [(\\<Gamma>, p # close \\<Delta> (p && q)),\n         (\\<Gamma>, q # close \\<Delta> (p && q))])\n       (SG ! i),\n      SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close SG (SG ! i) @\n      close\n       [(\\<Gamma>, p # close \\<Delta> (p && q)),\n        (\\<Gamma>, q # close \\<Delta> (p && q))]\n       (SG ! i),\n      SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(\\<Gamma>, p # close \\<Delta> (p && q)),\n        (\\<Gamma>, q # close \\<Delta> (p && q))]\n       (SG ! i),\n      SG ! i)", "using close_eq big_sound SG_dec"], ["proof (prove)\nusing this:\n  close\n   [(\\<Gamma>, p # close \\<Delta> (p && q)),\n    (\\<Gamma>, q # close \\<Delta> (p && q))]\n   (\\<Gamma>, \\<Delta>) =\n  [(\\<Gamma>, p # close \\<Delta> (p && q)),\n   (\\<Gamma>, q # close \\<Delta> (p && q))]\n  sound\n   ([(\\<Gamma>, p # close \\<Delta> (\\<Delta> ! j)),\n     (\\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))],\n    \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. sound\n     (close\n       [(\\<Gamma>, p # close \\<Delta> (p && q)),\n        (\\<Gamma>, q # close \\<Delta> (p && q))]\n       (SG ! i),\n      SG ! i)", "by (simp add: AIjeq)"], ["proof (state)\nthis:\n  sound (close (SG @ Rrule_result AndR j (SG ! i)) (SG ! i), C)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Rrule_Imply SG i j C p q)"], ["proof (state)\nthis:\n  snd (SG ! i) ! j = (p \\<rightarrow> q)\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume eq:\"snd (SG ! i) ! j = (p \\<rightarrow> q)\""], ["proof (state)\nthis:\n  snd (SG ! i) ! j = (p \\<rightarrow> q)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"j < length (snd (SG ! i))\""], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have impR_simp:\"\\<And>\\<Gamma> \\<Delta> SS p q. \n    (nth \\<Delta> j) = Implies p q \\<Longrightarrow> \n    (\\<Gamma>,\\<Delta>) = SS \\<Longrightarrow> \n    Rrule_result ImplyR j SS = [(p # \\<Gamma>, q # (close \\<Delta> (nth \\<Delta> j)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> \\<Delta> SS p q.\n       \\<lbrakk>\\<Delta> ! j = (p \\<rightarrow> q);\n        (\\<Gamma>, \\<Delta>) = SS\\<rbrakk>\n       \\<Longrightarrow> Rrule_result ImplyR j SS =\n                         [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]", "subgoal for AI SI SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SI ! j = (p \\<rightarrow> q); (AI, SI) = SS\\<rbrakk>\n    \\<Longrightarrow> Rrule_result ImplyR j SS =\n                      [(p # AI, q # close SI (SI ! j))]", "apply(cases SS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>SI ! j = (p \\<rightarrow> q); (AI, SI) = SS;\n        SS = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Rrule_result ImplyR j SS =\n                         [(p # AI, q # close SI (SI ! j))]", "by (auto simp add: Implies_def Or_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Delta>7 ! j = (?p7 \\<rightarrow> ?q7);\n   (?\\<Gamma>7, ?\\<Delta>7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Rrule_result ImplyR j ?SS7 =\n                    [(?p7 # ?\\<Gamma>7,\n                      ?q7 # close ?\\<Delta>7 (?\\<Delta>7 ! j))]\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Rrule_result ImplyR j (SG ! i) = \n    [(p # \\<Gamma>, q # (close \\<Delta> (nth \\<Delta> j)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rrule_result ImplyR j (SG ! i) =\n    [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]", "using SG_dec impR_simp"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  \\<lbrakk>?\\<Delta>7 ! j = (?p7 \\<rightarrow> ?q7);\n   (?\\<Gamma>7, ?\\<Delta>7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Rrule_result ImplyR j ?SS7 =\n                    [(?p7 # ?\\<Gamma>7,\n                      ?q7 # close ?\\<Delta>7 (?\\<Delta>7 ! j))]\n\ngoal (1 subgoal):\n 1. Rrule_result ImplyR j (SG ! i) =\n    [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Delta> p q \\<Gamma> a.\n        \\<lbrakk>\\<Delta> ! j = (p \\<rightarrow> q); \\<Gamma> = a\\<rbrakk>\n        \\<Longrightarrow> (case p \\<rightarrow> q of\n                           ! (! q && ! (! p)) \\<Rightarrow>\n                             [(p # a, q # closeI \\<Delta> j)]) =\n                          [(p # a,\n                            q #\n                            filter\n                             (\\<lambda>y. y \\<noteq> (p \\<rightarrow> q))\n                             \\<Delta>)]\\<rbrakk>\n    \\<Longrightarrow> Rrule_result ImplyR j (SG ! i) =\n                      [(p # \\<Gamma>,\n                        q #\n                        filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j)\n                         \\<Delta>)]", "using SG_dec eq Implies_def Or_def"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p \\<rightarrow> q)\n  (?P \\<rightarrow> ?Q) = (?Q || ! ?P)\n  (?P || ?Q) = ! (! ?P && ! ?Q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Delta> p q \\<Gamma> a.\n        \\<lbrakk>\\<Delta> ! j = (p \\<rightarrow> q); \\<Gamma> = a\\<rbrakk>\n        \\<Longrightarrow> (case p \\<rightarrow> q of\n                           ! (! q && ! (! p)) \\<Rightarrow>\n                             [(p # a, q # closeI \\<Delta> j)]) =\n                          [(p # a,\n                            q #\n                            filter\n                             (\\<lambda>y. y \\<noteq> (p \\<rightarrow> q))\n                             \\<Delta>)]\\<rbrakk>\n    \\<Longrightarrow> Rrule_result ImplyR j (SG ! i) =\n                      [(p # \\<Gamma>,\n                        q #\n                        filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j)\n                         \\<Delta>)]", "using fstI"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p \\<rightarrow> q)\n  (?P \\<rightarrow> ?Q) = (?Q || ! ?P)\n  (?P || ?Q) = ! (! ?P && ! ?Q)\n  ?x = (?y, ?z) \\<Longrightarrow> fst ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Delta> p q \\<Gamma> a.\n        \\<lbrakk>\\<Delta> ! j = (p \\<rightarrow> q); \\<Gamma> = a\\<rbrakk>\n        \\<Longrightarrow> (case p \\<rightarrow> q of\n                           ! (! q && ! (! p)) \\<Rightarrow>\n                             [(p # a, q # closeI \\<Delta> j)]) =\n                          [(p # a,\n                            q #\n                            filter\n                             (\\<lambda>y. y \\<noteq> (p \\<rightarrow> q))\n                             \\<Delta>)]\\<rbrakk>\n    \\<Longrightarrow> Rrule_result ImplyR j (SG ! i) =\n                      [(p # \\<Gamma>,\n                        q #\n                        filter (\\<lambda>y. y \\<noteq> \\<Delta> ! j)\n                         \\<Delta>)]", "by (metis impR_simp close.simps snd_conv)"], ["proof (state)\nthis:\n  Rrule_result ImplyR j (SG ! i) =\n  [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have AIjeq:\"\\<Delta> ! j = (p \\<rightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p \\<rightarrow> q)", "using SG_dec eq snd_conv"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p \\<rightarrow> q)\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p \\<rightarrow> q)", "by metis"], ["proof (state)\nthis:\n  \\<Delta> ! j = (p \\<rightarrow> q)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [(p # \\<Gamma>, q # (close \\<Delta> (nth \\<Delta> j)))] (\\<Gamma>,\\<Delta>) = [(p # \\<Gamma>, q # (close \\<Delta> (nth \\<Delta> j)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n     (\\<Gamma>, \\<Delta>) =\n    [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]", "apply(rule close_nonmember_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n            (\\<Gamma>, \\<Delta>)", "by (simp add: member_rec)"], ["proof (state)\nthis:\n  close [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n   (\\<Gamma>, \\<Delta>) =\n  [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))], \\<Gamma>,\n      \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I ::\"('sf,'sc,'sz) interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sgs:\"(\\<And>i. 0 \\<le> i \\<Longrightarrow> i < length [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] \\<Longrightarrow> \\<nu> \\<in> seq_sem I ([(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] ! i))\""], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?i7;\n   ?i7 < length [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(p # \\<Gamma>,\n                              q # close \\<Delta> (\\<Delta> ! j))] !\n                            ?i7)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg:\"\\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))", "using sgs[of 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0;\n   0 < length [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(p # \\<Gamma>,\n                              q # close \\<Delta> (\\<Delta> ! j))] !\n                            0)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \\<Gamma>_sem:\"\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>,\n                   q # close \\<Delta> (\\<Delta> ! j))]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>,\n q # close \\<Delta> (\\<Delta> ! j))] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using \\<Gamma>_sem sg \n        AIjeq Rrule_Imply.prems(2) SG_dec and_foldl_sem_conv close_sub impl_sem local.sublist_def member_rec(1) nth_member or_foldl_sem_conv seq_MP seq_semI snd_conv\n        \\<Gamma>_sub_sem and_foldl_sem or_foldl_sem seq_sem.simps sublistI"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))\n  \\<Delta> ! j = (p \\<rightarrow> q)\n  j < length (snd (SG ! i))\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  (\\<And>\\<phi>.\n      List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n      ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n  ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\n  sublist (close ?\\<Gamma> ?\\<phi>) ?\\<Gamma>\n  (?\\<nu> \\<in> fml_sem ?I (?A \\<rightarrow> ?B)) =\n  (?\\<nu> \\<in> fml_sem ?I ?A \\<longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?B)\n  sublist ?A ?B \\<equiv>\n  \\<forall>x. List.member ?A x \\<longrightarrow> List.member ?B x\n  List.member (?x # ?xs) ?y = (?x = ?y \\<or> List.member ?xs ?y)\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n  ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF) \\<Longrightarrow>\n  \\<exists>\\<phi>.\n     ?\\<nu> \\<in> fml_sem ?I \\<phi> \\<and> List.member ?\\<Gamma> \\<phi>\n  \\<lbrakk>?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>);\n   ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)\n  \\<lbrakk>List.member ?\\<Delta> ?\\<psi>;\n   (\\<And>\\<phi>.\n       List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n       ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n   ?\\<nu> \\<in> fml_sem ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n  snd (?x1.0, ?x2.0) = ?x2.0\n  \\<lbrakk>sublist ?\\<Gamma>1.0 ?\\<Gamma>2.0;\n   ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma>2.0 TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma>1.0 TT)\n  \\<lbrakk>?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT);\n   List.member ?\\<Gamma> ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\n  \\<lbrakk>List.member ?\\<Gamma> ?\\<phi>;\n   ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF)\n  seq_sem ?I ?S = fml_sem ?I (seq2fml ?S)\n  (\\<And>x.\n      List.member ?A x \\<Longrightarrow> List.member ?B x) \\<Longrightarrow>\n  sublist ?A ?B\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<nu>\n     \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j));\n     \\<Delta> ! j = (p \\<rightarrow> q); j < length (snd (SG ! i));\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>\\<nu> I A B.\n        (\\<nu> \\<in> fml_sem I (A \\<rightarrow> B)) =\n        (\\<nu> \\<in> fml_sem I A \\<longrightarrow> \\<nu> \\<in> fml_sem I B);\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>x xs y. List.member (x # xs) y = (x = y \\<or> List.member xs y);\n     \\<And>n L. n < length L \\<Longrightarrow> List.member L (L ! n);\n     \\<And>\\<nu> I \\<Gamma>.\n        \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF) \\<Longrightarrow>\n        \\<exists>\\<phi>.\n           \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>;\n     \\<And>\\<nu> I \\<Gamma> \\<Delta>.\n        \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>x1 x2. snd (x1, x2) = x2;\n     \\<And>\\<Gamma>1 \\<Gamma>2 \\<nu> I.\n        \\<lbrakk>sublist \\<Gamma>1 \\<Gamma>2;\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT);\n     \\<And>\\<nu> I \\<Gamma> \\<phi>.\n        \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n         List.member \\<Gamma> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Gamma> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF);\n     \\<And>I S. seq_sem I S = fml_sem I (seq2fml S);\n     \\<And>A B.\n        (\\<And>x.\n            List.member A x \\<Longrightarrow>\n            List.member B x) \\<Longrightarrow>\n        sublist A B\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have f1: \"\\<forall>fs p i. \\<exists>f. (p \\<in> fml_sem i (foldr (&&) fs (TT::('sf, 'sc, 'sz) formula)) \\<or> List.member fs f) \\<and> (p \\<notin> fml_sem i f \\<or> p \\<in> fml_sem i (foldr (&&) fs TT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fs p i.\n       \\<exists>f.\n          (p \\<in> fml_sem i (foldr (&&) fs TT) \\<or>\n           List.member fs f) \\<and>\n          (p \\<notin> fml_sem i f \\<or>\n           p \\<in> fml_sem i (foldr (&&) fs TT))", "using and_foldl_sem_conv"], ["proof (prove)\nusing this:\n  (\\<And>\\<phi>.\n      List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n      ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n  ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<forall>fs p i.\n       \\<exists>f.\n          (p \\<in> fml_sem i (foldr (&&) fs TT) \\<or>\n           List.member fs f) \\<and>\n          (p \\<notin> fml_sem i f \\<or>\n           p \\<in> fml_sem i (foldr (&&) fs TT))", "by blast"], ["proof (state)\nthis:\n  \\<forall>fs p i.\n     \\<exists>f.\n        (p \\<in> fml_sem i (foldr (&&) fs TT) \\<or> List.member fs f) \\<and>\n        (p \\<notin> fml_sem i f \\<or> p \\<in> fml_sem i (foldr (&&) fs TT))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<nu>\n     \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j));\n     \\<Delta> ! j = (p \\<rightarrow> q); j < length (snd (SG ! i));\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>\\<nu> I A B.\n        (\\<nu> \\<in> fml_sem I (A \\<rightarrow> B)) =\n        (\\<nu> \\<in> fml_sem I A \\<longrightarrow> \\<nu> \\<in> fml_sem I B);\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>x xs y. List.member (x # xs) y = (x = y \\<or> List.member xs y);\n     \\<And>n L. n < length L \\<Longrightarrow> List.member L (L ! n);\n     \\<And>\\<nu> I \\<Gamma>.\n        \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF) \\<Longrightarrow>\n        \\<exists>\\<phi>.\n           \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>;\n     \\<And>\\<nu> I \\<Gamma> \\<Delta>.\n        \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>x1 x2. snd (x1, x2) = x2;\n     \\<And>\\<Gamma>1 \\<Gamma>2 \\<nu> I.\n        \\<lbrakk>sublist \\<Gamma>1 \\<Gamma>2;\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT);\n     \\<And>\\<nu> I \\<Gamma> \\<phi>.\n        \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n         List.member \\<Gamma> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Gamma> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF);\n     \\<And>I S. seq_sem I S = fml_sem I (seq2fml S);\n     \\<And>A B.\n        (\\<And>x.\n            List.member A x \\<Longrightarrow>\n            List.member B x) \\<Longrightarrow>\n        sublist A B\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<forall>p i fs. \\<exists>f. \\<forall>pa ia fa fb pb ib fc fd. p \\<in> fml_sem i (f::('sf, 'sc, 'sz) formula) \\<and> (pa \\<in> fml_sem ia (fa::('sf, 'sc, 'sz) formula) \\<or> pa \\<in> fml_sem ia (fa \\<rightarrow> fb)) \\<and> (pb \\<notin> fml_sem ib (fc::('sf, 'sc, 'sz) formula) \\<or> pb \\<in> fml_sem ib (fd \\<rightarrow> fc)) \\<and> (p \\<notin> fml_sem i (foldr (||) fs FF) \\<or> List.member fs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p i fs.\n       \\<exists>f.\n          \\<forall>pa ia fa fb pb ib fc fd.\n             p \\<in> fml_sem i f \\<and>\n             (pa \\<in> fml_sem ia fa \\<or>\n              pa \\<in> fml_sem ia (fa \\<rightarrow> fb)) \\<and>\n             (pb \\<notin> fml_sem ib fc \\<or>\n              pb \\<in> fml_sem ib (fd \\<rightarrow> fc)) \\<and>\n             (p \\<notin> fml_sem i (foldr (||) fs FF) \\<or>\n              List.member fs f)", "by (metis impl_sem or_foldl_sem_conv)"], ["proof (state)\nthis:\n  \\<forall>p i fs.\n     \\<exists>f.\n        \\<forall>pa ia fa fb pb ib fc fd.\n           p \\<in> fml_sem i f \\<and>\n           (pa \\<in> fml_sem ia fa \\<or>\n            pa \\<in> fml_sem ia (fa \\<rightarrow> fb)) \\<and>\n           (pb \\<notin> fml_sem ib fc \\<or>\n            pb \\<in> fml_sem ib (fd \\<rightarrow> fc)) \\<and>\n           (p \\<notin> fml_sem i (foldr (||) fs FF) \\<or> List.member fs f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<nu>\n     \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j));\n     \\<Delta> ! j = (p \\<rightarrow> q); j < length (snd (SG ! i));\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>\\<nu> I A B.\n        (\\<nu> \\<in> fml_sem I (A \\<rightarrow> B)) =\n        (\\<nu> \\<in> fml_sem I A \\<longrightarrow> \\<nu> \\<in> fml_sem I B);\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>x xs y. List.member (x # xs) y = (x = y \\<or> List.member xs y);\n     \\<And>n L. n < length L \\<Longrightarrow> List.member L (L ! n);\n     \\<And>\\<nu> I \\<Gamma>.\n        \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF) \\<Longrightarrow>\n        \\<exists>\\<phi>.\n           \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>;\n     \\<And>\\<nu> I \\<Gamma> \\<Delta>.\n        \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>x1 x2. snd (x1, x2) = x2;\n     \\<And>\\<Gamma>1 \\<Gamma>2 \\<nu> I.\n        \\<lbrakk>sublist \\<Gamma>1 \\<Gamma>2;\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT);\n     \\<And>\\<nu> I \\<Gamma> \\<phi>.\n        \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n         List.member \\<Gamma> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Gamma> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF);\n     \\<And>I S. seq_sem I S = fml_sem I (seq2fml S);\n     \\<And>A B.\n        (\\<And>x.\n            List.member A x \\<Longrightarrow>\n            List.member B x) \\<Longrightarrow>\n        sublist A B\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p i fs.\n     \\<exists>f.\n        \\<forall>pa ia fa fb pb ib fc fd.\n           p \\<in> fml_sem i f \\<and>\n           (pa \\<in> fml_sem ia fa \\<or>\n            pa \\<in> fml_sem ia (fa \\<rightarrow> fb)) \\<and>\n           (pb \\<notin> fml_sem ib fc \\<or>\n            pb \\<in> fml_sem ib (fd \\<rightarrow> fc)) \\<and>\n           (p \\<notin> fml_sem i (foldr (||) fs FF) \\<or> List.member fs f)", "obtain ff :: \"(real, 'sz) vec \\<times> (real, 'sz) vec \\<Rightarrow> ('sf, 'sc, 'sz) interp \\<Rightarrow> ('sf, 'sc, 'sz) formula list \\<Rightarrow> ('sf, 'sc, 'sz) formula\" where\n        f2: \"\\<And>p i fs pa ia f fa pb ib fb fc. p \\<in> fml_sem i (ff p i fs) \\<and> (pa \\<in> fml_sem ia (f::('sf, 'sc, 'sz) formula) \\<or> pa \\<in> fml_sem ia (f \\<rightarrow> fa)) \\<and> (pb \\<notin> fml_sem ib (fb::('sf, 'sc, 'sz) formula) \\<or> pb \\<in> fml_sem ib (fc \\<rightarrow> fb)) \\<and> (p \\<notin> fml_sem i (foldr (||) fs FF) \\<or> List.member fs (ff p i fs))\""], ["proof (prove)\nusing this:\n  \\<forall>p i fs.\n     \\<exists>f.\n        \\<forall>pa ia fa fb pb ib fc fd.\n           p \\<in> fml_sem i f \\<and>\n           (pa \\<in> fml_sem ia fa \\<or>\n            pa \\<in> fml_sem ia (fa \\<rightarrow> fb)) \\<and>\n           (pb \\<notin> fml_sem ib fc \\<or>\n            pb \\<in> fml_sem ib (fd \\<rightarrow> fc)) \\<and>\n           (p \\<notin> fml_sem i (foldr (||) fs FF) \\<or> List.member fs f)\n\ngoal (1 subgoal):\n 1. (\\<And>ff.\n        (\\<And>p i fs pa ia f fa pb ib fb fc.\n            p \\<in> fml_sem i (ff p i fs) \\<and>\n            (pa \\<in> fml_sem ia f \\<or>\n             pa \\<in> fml_sem ia (f \\<rightarrow> fa)) \\<and>\n            (pb \\<notin> fml_sem ib fb \\<or>\n             pb \\<in> fml_sem ib (fc \\<rightarrow> fb)) \\<and>\n            (p \\<notin> fml_sem i (foldr (||) fs FF) \\<or>\n             List.member fs (ff p i fs))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?p7 \\<in> fml_sem ?i7 (ff ?p7 ?i7 ?fs7) \\<and>\n  (?pa7 \\<in> fml_sem ?ia7 ?f7 \\<or>\n   ?pa7 \\<in> fml_sem ?ia7 (?f7 \\<rightarrow> ?fa7)) \\<and>\n  (?pb7 \\<notin> fml_sem ?ib7 ?fb7 \\<or>\n   ?pb7 \\<in> fml_sem ?ib7 (?fc7 \\<rightarrow> ?fb7)) \\<and>\n  (?p7 \\<notin> fml_sem ?i7 (foldr (||) ?fs7 FF) \\<or>\n   List.member ?fs7 (ff ?p7 ?i7 ?fs7))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<nu>\n     \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j));\n     \\<Delta> ! j = (p \\<rightarrow> q); j < length (snd (SG ! i));\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>\\<nu> I A B.\n        (\\<nu> \\<in> fml_sem I (A \\<rightarrow> B)) =\n        (\\<nu> \\<in> fml_sem I A \\<longrightarrow> \\<nu> \\<in> fml_sem I B);\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>x xs y. List.member (x # xs) y = (x = y \\<or> List.member xs y);\n     \\<And>n L. n < length L \\<Longrightarrow> List.member L (L ! n);\n     \\<And>\\<nu> I \\<Gamma>.\n        \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF) \\<Longrightarrow>\n        \\<exists>\\<phi>.\n           \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>;\n     \\<And>\\<nu> I \\<Gamma> \\<Delta>.\n        \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>x1 x2. snd (x1, x2) = x2;\n     \\<And>\\<Gamma>1 \\<Gamma>2 \\<nu> I.\n        \\<lbrakk>sublist \\<Gamma>1 \\<Gamma>2;\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT);\n     \\<And>\\<nu> I \\<Gamma> \\<phi>.\n        \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n         List.member \\<Gamma> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Gamma> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF);\n     \\<And>I S. seq_sem I S = fml_sem I (seq2fml S);\n     \\<And>A B.\n        (\\<And>x.\n            List.member A x \\<Longrightarrow>\n            List.member B x) \\<Longrightarrow>\n        sublist A B\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  ?p7 \\<in> fml_sem ?i7 (ff ?p7 ?i7 ?fs7) \\<and>\n  (?pa7 \\<in> fml_sem ?ia7 ?f7 \\<or>\n   ?pa7 \\<in> fml_sem ?ia7 (?f7 \\<rightarrow> ?fa7)) \\<and>\n  (?pb7 \\<notin> fml_sem ?ib7 ?fb7 \\<or>\n   ?pb7 \\<in> fml_sem ?ib7 (?fc7 \\<rightarrow> ?fb7)) \\<and>\n  (?p7 \\<notin> fml_sem ?i7 (foldr (||) ?fs7 FF) \\<or>\n   List.member ?fs7 (ff ?p7 ?i7 ?fs7))", "have \"\\<And>fs. \\<nu> \\<notin> fml_sem I (foldr (&&) (p # \\<Gamma>) TT) \\<or> \\<not> local.sublist (close \\<Delta> (p \\<rightarrow> q)) fs \\<or> ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)) = q \\<or> List.member fs (ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)))\""], ["proof (prove)\nusing this:\n  ?p7 \\<in> fml_sem ?i7 (ff ?p7 ?i7 ?fs7) \\<and>\n  (?pa7 \\<in> fml_sem ?ia7 ?f7 \\<or>\n   ?pa7 \\<in> fml_sem ?ia7 (?f7 \\<rightarrow> ?fa7)) \\<and>\n  (?pb7 \\<notin> fml_sem ?ib7 ?fb7 \\<or>\n   ?pb7 \\<in> fml_sem ?ib7 (?fc7 \\<rightarrow> ?fb7)) \\<and>\n  (?p7 \\<notin> fml_sem ?i7 (foldr (||) ?fs7 FF) \\<or>\n   List.member ?fs7 (ff ?p7 ?i7 ?fs7))\n\ngoal (1 subgoal):\n 1. \\<And>fs.\n       \\<nu> \\<notin> fml_sem I (foldr (&&) (p # \\<Gamma>) TT) \\<or>\n       \\<not> sublist (close \\<Delta> (p \\<rightarrow> q)) fs \\<or>\n       ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)) = q \\<or>\n       List.member fs (ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)))", "by (metis (no_types) AIjeq local.sublist_def member_rec(1) seq_MP sg)"], ["proof (state)\nthis:\n  \\<nu> \\<notin> fml_sem I (foldr (&&) (p # \\<Gamma>) TT) \\<or>\n  \\<not> sublist (close \\<Delta> (p \\<rightarrow> q)) ?fs7 \\<or>\n  ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)) = q \\<or>\n  List.member ?fs7 (ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<nu>\n     \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j));\n     \\<Delta> ! j = (p \\<rightarrow> q); j < length (snd (SG ! i));\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>\\<nu> I A B.\n        (\\<nu> \\<in> fml_sem I (A \\<rightarrow> B)) =\n        (\\<nu> \\<in> fml_sem I A \\<longrightarrow> \\<nu> \\<in> fml_sem I B);\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>x xs y. List.member (x # xs) y = (x = y \\<or> List.member xs y);\n     \\<And>n L. n < length L \\<Longrightarrow> List.member L (L ! n);\n     \\<And>\\<nu> I \\<Gamma>.\n        \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF) \\<Longrightarrow>\n        \\<exists>\\<phi>.\n           \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>;\n     \\<And>\\<nu> I \\<Gamma> \\<Delta>.\n        \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>x1 x2. snd (x1, x2) = x2;\n     \\<And>\\<Gamma>1 \\<Gamma>2 \\<nu> I.\n        \\<lbrakk>sublist \\<Gamma>1 \\<Gamma>2;\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT);\n     \\<And>\\<nu> I \\<Gamma> \\<phi>.\n        \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n         List.member \\<Gamma> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Gamma> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF);\n     \\<And>I S. seq_sem I S = fml_sem I (seq2fml S);\n     \\<And>A B.\n        (\\<And>x.\n            List.member A x \\<Longrightarrow>\n            List.member B x) \\<Longrightarrow>\n        sublist A B\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<notin> fml_sem I (foldr (&&) (p # \\<Gamma>) TT) \\<or>\n  \\<not> sublist (close \\<Delta> (p \\<rightarrow> q)) ?fs7 \\<or>\n  ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)) = q \\<or>\n  List.member ?fs7 (ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)))", "have \"\\<exists>f. List.member \\<Delta> f \\<and> \\<nu> \\<in> fml_sem I f\""], ["proof (prove)\nusing this:\n  \\<nu> \\<notin> fml_sem I (foldr (&&) (p # \\<Gamma>) TT) \\<or>\n  \\<not> sublist (close \\<Delta> (p \\<rightarrow> q)) ?fs7 \\<or>\n  ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)) = q \\<or>\n  List.member ?fs7 (ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)))\n\ngoal (1 subgoal):\n 1. \\<exists>f. List.member \\<Delta> f \\<and> \\<nu> \\<in> fml_sem I f", "using f2 f1"], ["proof (prove)\nusing this:\n  \\<nu> \\<notin> fml_sem I (foldr (&&) (p # \\<Gamma>) TT) \\<or>\n  \\<not> sublist (close \\<Delta> (p \\<rightarrow> q)) ?fs7 \\<or>\n  ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)) = q \\<or>\n  List.member ?fs7 (ff \\<nu> I (q # close \\<Delta> (p \\<rightarrow> q)))\n  ?p7 \\<in> fml_sem ?i7 (ff ?p7 ?i7 ?fs7) \\<and>\n  (?pa7 \\<in> fml_sem ?ia7 ?f7 \\<or>\n   ?pa7 \\<in> fml_sem ?ia7 (?f7 \\<rightarrow> ?fa7)) \\<and>\n  (?pb7 \\<notin> fml_sem ?ib7 ?fb7 \\<or>\n   ?pb7 \\<in> fml_sem ?ib7 (?fc7 \\<rightarrow> ?fb7)) \\<and>\n  (?p7 \\<notin> fml_sem ?i7 (foldr (||) ?fs7 FF) \\<or>\n   List.member ?fs7 (ff ?p7 ?i7 ?fs7))\n  \\<forall>fs p i.\n     \\<exists>f.\n        (p \\<in> fml_sem i (foldr (&&) fs TT) \\<or> List.member fs f) \\<and>\n        (p \\<notin> fml_sem i f \\<or> p \\<in> fml_sem i (foldr (&&) fs TT))\n\ngoal (1 subgoal):\n 1. \\<exists>f. List.member \\<Delta> f \\<and> \\<nu> \\<in> fml_sem I f", "by (metis (no_types) AIjeq Rrule_Imply.prems(2) SG_dec \\<Gamma>_sem and_foldl_sem close_sub member_rec(1) nth_member snd_conv)"], ["proof (state)\nthis:\n  \\<exists>f. List.member \\<Delta> f \\<and> \\<nu> \\<in> fml_sem I f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<nu>\n     \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j));\n     \\<Delta> ! j = (p \\<rightarrow> q); j < length (snd (SG ! i));\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>\\<nu> I A B.\n        (\\<nu> \\<in> fml_sem I (A \\<rightarrow> B)) =\n        (\\<nu> \\<in> fml_sem I A \\<longrightarrow> \\<nu> \\<in> fml_sem I B);\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>x xs y. List.member (x # xs) y = (x = y \\<or> List.member xs y);\n     \\<And>n L. n < length L \\<Longrightarrow> List.member L (L ! n);\n     \\<And>\\<nu> I \\<Gamma>.\n        \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF) \\<Longrightarrow>\n        \\<exists>\\<phi>.\n           \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>;\n     \\<And>\\<nu> I \\<Gamma> \\<Delta>.\n        \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<Delta> \\<psi> \\<Gamma> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<psi>;\n         (\\<And>\\<phi>.\n             List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n             \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>x1 x2. snd (x1, x2) = x2;\n     \\<And>\\<Gamma>1 \\<Gamma>2 \\<nu> I.\n        \\<lbrakk>sublist \\<Gamma>1 \\<Gamma>2;\n         \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT);\n     \\<And>\\<nu> I \\<Gamma> \\<phi>.\n        \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n         List.member \\<Gamma> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Gamma> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF);\n     \\<And>I S. seq_sem I S = fml_sem I (seq2fml S);\n     \\<And>A B.\n        (\\<And>x.\n            List.member A x \\<Longrightarrow>\n            List.member B x) \\<Longrightarrow>\n        sublist A B\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. List.member \\<Delta> f \\<and> \\<nu> \\<in> fml_sem I f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>f. List.member \\<Delta> f \\<and> \\<nu> \\<in> fml_sem I f\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using or_foldl_sem"], ["proof (prove)\nusing this:\n  \\<exists>f. List.member \\<Delta> f \\<and> \\<nu> \\<in> fml_sem I f\n  \\<lbrakk>List.member ?\\<Gamma> ?\\<phi>;\n   ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by blast"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   ([(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))], \\<Gamma>, \\<Delta>)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<rightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result ImplyR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 5. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result ImplyR j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Rrule_result ImplyR j (SG ! i), C)\n 2. sound (close (SG @ Rrule_result ImplyR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound (close (SG @ Rrule_result ImplyR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result ImplyR j (SG ! i)) (SG ! i), SG ! i)", "using res_eq"], ["proof (prove)\nusing this:\n  Rrule_result ImplyR j (SG ! i) =\n  [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result ImplyR j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] =\n    [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))] \\<Longrightarrow>\n    sound\n     (close (SG @ [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))])\n       (SG ! i),\n      SG ! i)", "apply(unfold AIjeq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))] =\n    [(p # \\<Gamma>,\n      q # close \\<Delta> (p \\<rightarrow> q))] \\<Longrightarrow>\n    sound\n     (close (SG @ [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))])\n       (SG ! i),\n      SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))] =\n    [(p # \\<Gamma>,\n      q # close \\<Delta> (p \\<rightarrow> q))] \\<Longrightarrow>\n    sound\n     (close SG (SG ! i) @\n      close [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))]\n       (SG ! i),\n      SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))] =\n    [(p # \\<Gamma>,\n      q # close \\<Delta> (p \\<rightarrow> q))] \\<Longrightarrow>\n    sound\n     (close [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))]\n       (SG ! i),\n      SG ! i)", "using close_eq big_sound SG_dec AIjeq"], ["proof (prove)\nusing this:\n  close [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n   (\\<Gamma>, \\<Delta>) =\n  [(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))]\n  sound\n   ([(p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))], \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  \\<Delta> ! j = (p \\<rightarrow> q)\n\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))] =\n    [(p # \\<Gamma>,\n      q # close \\<Delta> (p \\<rightarrow> q))] \\<Longrightarrow>\n    sound\n     (close [(p # \\<Gamma>, q # close \\<Delta> (p \\<rightarrow> q))]\n       (SG ! i),\n      SG ! i)", "by (simp add: AIjeq)"], ["proof (state)\nthis:\n  sound (close (SG @ Rrule_result ImplyR j (SG ! i)) (SG ! i), C)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Rrule_Cohide SG i j C)"], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n  SG ! i \\<noteq> (?\\<Gamma>7, [?q7])\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"j < length (snd (SG ! i))\""], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume chg:\"(\\<And>\\<Gamma> q. (nth SG i) \\<noteq> (\\<Gamma>, [q]))\""], ["proof (state)\nthis:\n  SG ! i \\<noteq> (?\\<Gamma>7, [?q7])\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have cohideR_simp:\"\n    (\\<Gamma>,\\<Delta>) = SS \\<Longrightarrow> \n    Rrule_result CohideR j SS = [(\\<Gamma>, [nth \\<Delta> j])]\" for \\<Gamma> \\<Delta> SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, \\<Delta>) = SS \\<Longrightarrow>\n    Rrule_result CohideR j SS = [(\\<Gamma>, [\\<Delta> ! j])]", "by (cases SS, auto)"], ["proof (state)\nthis:\n  (?\\<Gamma>7, ?\\<Delta>7) = ?SS7 \\<Longrightarrow>\n  Rrule_result CohideR j ?SS7 = [(?\\<Gamma>7, [?\\<Delta>7 ! j])]\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Rrule_result CohideR j (SG ! i) =  [(\\<Gamma>, [nth \\<Delta> j])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rrule_result CohideR j (SG ! i) = [(\\<Gamma>, [\\<Delta> ! j])]", "using SG_dec"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. Rrule_result CohideR j (SG ! i) = [(\\<Gamma>, [\\<Delta> ! j])]", "by (rule cohideR_simp)"], ["proof (state)\nthis:\n  Rrule_result CohideR j (SG ! i) = [(\\<Gamma>, [\\<Delta> ! j])]\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [(\\<Gamma>, [nth \\<Delta> j])] (\\<Gamma>,\\<Delta>) = [(\\<Gamma>, [nth \\<Delta> j])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close [(\\<Gamma>, [\\<Delta> ! j])] (\\<Gamma>, \\<Delta>) =\n    [(\\<Gamma>, [\\<Delta> ! j])]", "using chg"], ["proof (prove)\nusing this:\n  SG ! i \\<noteq> (?\\<Gamma>7, [?q7])\n\ngoal (1 subgoal):\n 1. close [(\\<Gamma>, [\\<Delta> ! j])] (\\<Gamma>, \\<Delta>) =\n    [(\\<Gamma>, [\\<Delta> ! j])]", "by (metis SG_dec close_nonmember_eq member_rec(1) member_rec(2))"], ["proof (state)\nthis:\n  close [(\\<Gamma>, [\\<Delta> ! j])] (\\<Gamma>, \\<Delta>) =\n  [(\\<Gamma>, [\\<Delta> ! j])]\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([(\\<Gamma>, [nth \\<Delta> j])], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([(\\<Gamma>, [\\<Delta> ! j])], \\<Gamma>, \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length [(\\<Gamma>, [\\<Delta> ! j])]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>, [\\<Delta> ! j])] !\n                                     i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length [(\\<Gamma>, [\\<Delta> ! j])]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(\\<Gamma>, [\\<Delta> ! j])] ! i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by (metis (no_types, lifting) Rrule_Cohide.prems(2) SG_dec length_greater_0_conv less_or_eq_imp_le list.distinct(1) member_singD nth_Cons_0 nth_member or_foldl_sem or_foldl_sem_conv seq_MP snd_conv)"], ["proof (state)\nthis:\n  sound ([(\\<Gamma>, [\\<Delta> ! j])], \\<Gamma>, \\<Delta>)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>\\<Gamma> q. SG ! i \\<noteq> (\\<Gamma>, [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 4. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result CohideR j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Rrule_result CohideR j (SG ! i), C)\n 2. sound (close (SG @ Rrule_result CohideR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound (close (SG @ Rrule_result CohideR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result CohideR j (SG ! i)) (SG ! i), SG ! i)", "using res_eq"], ["proof (prove)\nusing this:\n  Rrule_result CohideR j (SG ! i) = [(\\<Gamma>, [\\<Delta> ! j])]\n\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result CohideR j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<Gamma>, [\\<Delta> ! j])] =\n    [(\\<Gamma>, [\\<Delta> ! j])] \\<Longrightarrow>\n    sound (close (SG @ [(\\<Gamma>, [\\<Delta> ! j])]) (SG ! i), SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<Gamma>, [\\<Delta> ! j])] =\n    [(\\<Gamma>, [\\<Delta> ! j])] \\<Longrightarrow>\n    sound\n     (close SG (SG ! i) @ close [(\\<Gamma>, [\\<Delta> ! j])] (SG ! i),\n      SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<Gamma>, [\\<Delta> ! j])] =\n    [(\\<Gamma>, [\\<Delta> ! j])] \\<Longrightarrow>\n    sound (close [(\\<Gamma>, [\\<Delta> ! j])] (SG ! i), SG ! i)", "using big_sound SG_dec"], ["proof (prove)\nusing this:\n  sound ([(\\<Gamma>, [\\<Delta> ! j])], \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. [(\\<Gamma>, [\\<Delta> ! j])] =\n    [(\\<Gamma>, [\\<Delta> ! j])] \\<Longrightarrow>\n    sound (close [(\\<Gamma>, [\\<Delta> ! j])] (SG ! i), SG ! i)", "apply(cases \"[nth \\<Delta> j] = \\<Delta>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[(\\<Gamma>, [\\<Delta> ! j])] = [(\\<Gamma>, [\\<Delta> ! j])];\n     sound ([(\\<Gamma>, [\\<Delta> ! j])], \\<Gamma>, \\<Delta>);\n     (\\<Gamma>, \\<Delta>) = SG ! i; [\\<Delta> ! j] = \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> sound\n                       (close [(\\<Gamma>, [\\<Delta> ! j])] (SG ! i), SG ! i)\n 2. \\<lbrakk>[(\\<Gamma>, [\\<Delta> ! j])] = [(\\<Gamma>, [\\<Delta> ! j])];\n     sound ([(\\<Gamma>, [\\<Delta> ! j])], \\<Gamma>, \\<Delta>);\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] \\<noteq> \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> sound\n                       (close [(\\<Gamma>, [\\<Delta> ! j])] (SG ! i), SG ! i)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] = \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)\n 2. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] \\<noteq> \\<Delta>;\n     (\\<Gamma>, [\\<Delta> ! j]) = SG ! i\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)", "using chg"], ["proof (prove)\nusing this:\n  SG ! i \\<noteq> (?\\<Gamma>7, [?q7])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] = \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)\n 2. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] \\<noteq> \\<Delta>;\n     (\\<Gamma>, [\\<Delta> ! j]) = SG ! i\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)", "by (metis)+"], ["proof (state)\nthis:\n  sound (close (SG @ Rrule_result CohideR j (SG ! i)) (SG ! i), C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Rrule_CohideRR SG i j C)"], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n  SG ! i \\<noteq> ([], [?q7])\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume \"j < length (snd (SG ! i))\""], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume chg:\"(\\<And>q. (nth SG i) \\<noteq> ([], [q]))\""], ["proof (state)\nthis:\n  SG ! i \\<noteq> ([], [?q7])\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have cohideRR_simp:\" \n    (\\<Gamma>,\\<Delta>) = SS \\<Longrightarrow> \n    Rrule_result CohideRR j SS = [([], [nth \\<Delta> j])]\" for \\<Gamma> \\<Delta> SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, \\<Delta>) = SS \\<Longrightarrow>\n    Rrule_result CohideRR j SS = [([], [\\<Delta> ! j])]", "by (cases SS, auto)"], ["proof (state)\nthis:\n  (?\\<Gamma>7, ?\\<Delta>7) = ?SS7 \\<Longrightarrow>\n  Rrule_result CohideRR j ?SS7 = [([], [?\\<Delta>7 ! j])]\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Rrule_result CohideRR j (SG ! i) =  [([], [nth \\<Delta> j])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rrule_result CohideRR j (SG ! i) = [([], [\\<Delta> ! j])]", "using SG_dec"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. Rrule_result CohideRR j (SG ! i) = [([], [\\<Delta> ! j])]", "by (rule cohideRR_simp)"], ["proof (state)\nthis:\n  Rrule_result CohideRR j (SG ! i) = [([], [\\<Delta> ! j])]\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [([], [nth \\<Delta> j])] (\\<Gamma>,\\<Delta>) = [([], [nth \\<Delta> j])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close [([], [\\<Delta> ! j])] (\\<Gamma>, \\<Delta>) =\n    [([], [\\<Delta> ! j])]", "using chg"], ["proof (prove)\nusing this:\n  SG ! i \\<noteq> ([], [?q7])\n\ngoal (1 subgoal):\n 1. close [([], [\\<Delta> ! j])] (\\<Gamma>, \\<Delta>) =\n    [([], [\\<Delta> ! j])]", "by (metis SG_dec close_nonmember_eq member_rec(1) member_rec(2))"], ["proof (state)\nthis:\n  close [([], [\\<Delta> ! j])] (\\<Gamma>, \\<Delta>) = [([], [\\<Delta> ! j])]\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([([], [nth \\<Delta> j])], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([([], [\\<Delta> ! j])], \\<Gamma>, \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i; i < length [([], [\\<Delta> ! j])]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([([], [\\<Delta> ! j])] ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i; i < length [([], [\\<Delta> ! j])]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I ([([], [\\<Delta> ! j])] ! i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by (metis (no_types, lifting) Rrule_CohideRR.prems(2) SG_dec and_foldl_sem_conv length_greater_0_conv less_or_eq_imp_le list.distinct(1) member_rec(2) member_singD nth_Cons_0 nth_member or_foldl_sem or_foldl_sem_conv seq_MP snd_conv)"], ["proof (state)\nthis:\n  sound ([([], [\\<Delta> ! j])], \\<Gamma>, \\<Delta>)\n\ngoal (3 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>j < length (snd (SG ! i));\n        \\<And>q. SG ! i \\<noteq> ([], [q]); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result CohideRR j (SG ! i))\n                            (SG ! i),\n                           C)\n 3. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result CohideRR j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Rrule_result CohideRR j (SG ! i), C)\n 2. sound (close (SG @ Rrule_result CohideRR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound (close (SG @ Rrule_result CohideRR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result CohideRR j (SG ! i)) (SG ! i), SG ! i)", "using res_eq"], ["proof (prove)\nusing this:\n  Rrule_result CohideRR j (SG ! i) = [([], [\\<Delta> ! j])]\n\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result CohideRR j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [([], [\\<Delta> ! j])] = [([], [\\<Delta> ! j])] \\<Longrightarrow>\n    sound (close (SG @ [([], [\\<Delta> ! j])]) (SG ! i), SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. [([], [\\<Delta> ! j])] = [([], [\\<Delta> ! j])] \\<Longrightarrow>\n    sound\n     (close SG (SG ! i) @ close [([], [\\<Delta> ! j])] (SG ! i), SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [([], [\\<Delta> ! j])] = [([], [\\<Delta> ! j])] \\<Longrightarrow>\n    sound (close [([], [\\<Delta> ! j])] (SG ! i), SG ! i)", "using big_sound SG_dec"], ["proof (prove)\nusing this:\n  sound ([([], [\\<Delta> ! j])], \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. [([], [\\<Delta> ! j])] = [([], [\\<Delta> ! j])] \\<Longrightarrow>\n    sound (close [([], [\\<Delta> ! j])] (SG ! i), SG ! i)", "apply(cases \"[nth \\<Delta> j] = \\<Delta>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[([], [\\<Delta> ! j])] = [([], [\\<Delta> ! j])];\n     sound ([([], [\\<Delta> ! j])], \\<Gamma>, \\<Delta>);\n     (\\<Gamma>, \\<Delta>) = SG ! i; [\\<Delta> ! j] = \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> sound (close [([], [\\<Delta> ! j])] (SG ! i), SG ! i)\n 2. \\<lbrakk>[([], [\\<Delta> ! j])] = [([], [\\<Delta> ! j])];\n     sound ([([], [\\<Delta> ! j])], \\<Gamma>, \\<Delta>);\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] \\<noteq> \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> sound (close [([], [\\<Delta> ! j])] (SG ! i), SG ! i)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] = \\<Delta>; ([], \\<Delta>) = SG ! i\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)\n 2. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] \\<noteq> \\<Delta>;\n     ([], [\\<Delta> ! j]) = SG ! i\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)", "using chg"], ["proof (prove)\nusing this:\n  SG ! i \\<noteq> ([], [?q7])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] = \\<Delta>; ([], \\<Delta>) = SG ! i\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)\n 2. \\<lbrakk>sound ([SG ! i], SG ! i); (\\<Gamma>, \\<Delta>) = SG ! i;\n     [\\<Delta> ! j] \\<noteq> \\<Delta>;\n     ([], [\\<Delta> ! j]) = SG ! i\\<rbrakk>\n    \\<Longrightarrow> sound ([], SG ! i)", "by (metis)+"], ["proof (state)\nthis:\n  sound (close (SG @ Rrule_result CohideRR j (SG ! i)) (SG ! i), C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Rrule_True SG i j C)"], ["proof (state)\nthis:\n  snd (SG ! i) ! j = TT\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume tt:\"snd (SG ! i) ! j = TT\""], ["proof (state)\nthis:\n  snd (SG ! i) ! j = TT\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume iL:\"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume iJ:\"j < length (snd (SG ! i))\""], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "have \"\\<And>I \\<nu>. is_interp I \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       is_interp I \\<Longrightarrow>\n       \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       is_interp I \\<Longrightarrow>\n       \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I::\"('sf,'sc,'sz)interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       is_interp I \\<Longrightarrow>\n       \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       is_interp I \\<Longrightarrow>\n       \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have mem2:\"List.member \\<Delta> (\\<Delta> ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member \\<Delta> (\\<Delta> ! j)", "using iJ nth_member"], ["proof (prove)\nusing this:\n  j < length (snd (SG ! i))\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n\ngoal (1 subgoal):\n 1. List.member \\<Delta> (\\<Delta> ! j)", "by (metis SG_dec snd_conv)"], ["proof (state)\nthis:\n  List.member \\<Delta> (\\<Delta> ! j)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       is_interp I \\<Longrightarrow>\n       \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  List.member \\<Delta> (\\<Delta> ! j)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  List.member \\<Delta> (\\<Delta> ! j)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using mem2"], ["proof (prove)\nusing this:\n  List.member \\<Delta> (\\<Delta> ! j)\n  List.member \\<Delta> (\\<Delta> ! j)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using or_foldl_sem"], ["proof (prove)\nusing this:\n  List.member \\<Delta> (\\<Delta> ! j)\n  List.member \\<Delta> (\\<Delta> ! j)\n  \\<lbrakk>List.member ?\\<Gamma> ?\\<phi>;\n   ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by (metis SG_dec UNIV_I snd_conv tt tt_sem)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_interp ?I7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "then"], ["proof (chain)\npicking this:\n  is_interp ?I7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)", "have seq_valid:\"seq_valid (SG ! i)\""], ["proof (prove)\nusing this:\n  is_interp ?I7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "unfolding seq_valid_def"], ["proof (prove)\nusing this:\n  is_interp ?I7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<forall>I. is_interp I \\<longrightarrow> seq_sem I (SG ! i) = UNIV", "using SG_dec"], ["proof (prove)\nusing this:\n  is_interp ?I7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. \\<forall>I. is_interp I \\<longrightarrow> seq_sem I (SG ! i) = UNIV", "by (metis UNIV_eq_I seq_semI')"], ["proof (state)\nthis:\n  seq_valid (SG ! i)\n\ngoal (2 subgoals):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)\n 2. \\<And>SG i j C.\n       \\<lbrakk>snd (SG ! i) ! j = TT; i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result TrueR j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result TrueR j (SG ! i)) (SG ! i), C)", "using closeI_valid_sound[OF sound seq_valid]"], ["proof (prove)\nusing this:\n  sound (closeI SG i, C)\n\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result TrueR j (SG ! i)) (SG ! i), C)", "by (simp add: sound_weaken_appR)"], ["proof (state)\nthis:\n  sound (close (SG @ Rrule_result TrueR j (SG ! i)) (SG ! i), C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "case (Rrule_Equiv SG i j C p q)"], ["proof (state)\nthis:\n  snd (SG ! i) ! j = (p \\<leftrightarrow> q)\n  i < length SG\n  j < length (snd (SG ! i))\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume eq:\"snd (SG ! i) ! j = (p \\<leftrightarrow> q)\""], ["proof (state)\nthis:\n  snd (SG ! i) ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume iL:\"i < length SG\""], ["proof (state)\nthis:\n  i < length SG\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume jL:\"j < length (snd (SG ! i))\""], ["proof (state)\nthis:\n  j < length (snd (SG ! i))\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "have equivR_simp:\"\\<And>\\<Gamma> \\<Delta> SS p q. \n    (nth \\<Delta> j) = Equiv p q \\<Longrightarrow> \n    (\\<Gamma>,\\<Delta>) = SS \\<Longrightarrow> \n    Rrule_result EquivR j SS = [(p # \\<Gamma>, q # (closeI \\<Delta> j)), (q # \\<Gamma>, p # (closeI \\<Delta> j))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> \\<Delta> SS p q.\n       \\<lbrakk>\\<Delta> ! j = (p \\<leftrightarrow> q);\n        (\\<Gamma>, \\<Delta>) = SS\\<rbrakk>\n       \\<Longrightarrow> Rrule_result EquivR j SS =\n                         [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                          (q # \\<Gamma>, p # closeI \\<Delta> j)]", "subgoal for AI SI SS p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SI ! j = (p \\<leftrightarrow> q); (AI, SI) = SS\\<rbrakk>\n    \\<Longrightarrow> Rrule_result EquivR j SS =\n                      [(p # AI, q # closeI SI j), (q # AI, p # closeI SI j)]", "apply(cases SS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>SI ! j = (p \\<leftrightarrow> q); (AI, SI) = SS;\n        SS = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Rrule_result EquivR j SS =\n                         [(p # AI, q # closeI SI j),\n                          (q # AI, p # closeI SI j)]", "by (auto simp add: Equiv_def Implies_def Or_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Delta>7 ! j = (?p7 \\<leftrightarrow> ?q7);\n   (?\\<Gamma>7, ?\\<Delta>7) = ?SS7\\<rbrakk>\n  \\<Longrightarrow> Rrule_result EquivR j ?SS7 =\n                    [(?p7 # ?\\<Gamma>7, ?q7 # closeI ?\\<Delta>7 j),\n                     (?q7 # ?\\<Gamma>7, ?p7 # closeI ?\\<Delta>7 j)]\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "have res_eq:\"Rrule_result EquivR j (SG ! i) = \n    [(p # \\<Gamma>, q # (closeI \\<Delta> j)), (q # \\<Gamma>, p # (closeI \\<Delta> j))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rrule_result EquivR j (SG ! i) =\n    [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)]", "apply(rule equivR_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Delta> ! j = (p \\<leftrightarrow> q)\n 2. (\\<Gamma>, \\<Delta>) = SG ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p \\<leftrightarrow> q)", "using eq SG_dec"], ["proof (prove)\nusing this:\n  snd (SG ! i) ! j = (p \\<leftrightarrow> q)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p \\<leftrightarrow> q)", "by (metis snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, \\<Delta>) = SG ! i", "by (rule SG_dec)"], ["proof (state)\nthis:\n  Rrule_result EquivR j (SG ! i) =\n  [(p # \\<Gamma>, q # closeI \\<Delta> j),\n   (q # \\<Gamma>, p # closeI \\<Delta> j)]\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "have AIjeq:\"\\<Delta> ! j = (p \\<leftrightarrow> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p \\<leftrightarrow> q)", "using SG_dec eq snd_conv"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  snd (SG ! i) ! j = (p \\<leftrightarrow> q)\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. \\<Delta> ! j = (p \\<leftrightarrow> q)", "by metis"], ["proof (state)\nthis:\n  \\<Delta> ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "have close_eq:\"close [(p # \\<Gamma>, q # (closeI \\<Delta> j)), (q # \\<Gamma>, p # (closeI \\<Delta> j))] (\\<Gamma>,\\<Delta>) = [(p # \\<Gamma>, q # (closeI \\<Delta> j)), (q # \\<Gamma>, p # (closeI \\<Delta> j))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close\n     [(p # \\<Gamma>, q # closeI \\<Delta> j),\n      (q # \\<Gamma>, p # closeI \\<Delta> j)]\n     (\\<Gamma>, \\<Delta>) =\n    [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)]", "apply(rule close_nonmember_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member\n            [(p # \\<Gamma>, q # closeI \\<Delta> j),\n             (q # \\<Gamma>, p # closeI \\<Delta> j)]\n            (\\<Gamma>, \\<Delta>)", "by (simp add: member_rec)"], ["proof (state)\nthis:\n  close\n   [(p # \\<Gamma>, q # closeI \\<Delta> j),\n    (q # \\<Gamma>, p # closeI \\<Delta> j)]\n   (\\<Gamma>, \\<Delta>) =\n  [(p # \\<Gamma>, q # closeI \\<Delta> j),\n   (q # \\<Gamma>, p # closeI \\<Delta> j)]\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "have big_sound:\"sound ([(p # \\<Gamma>, q # (closeI \\<Delta> j)), (q # \\<Gamma>, p # (closeI \\<Delta> j))], (\\<Gamma>,\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n       (q # \\<Gamma>, p # closeI \\<Delta> j)],\n      \\<Gamma>, \\<Delta>)", "apply(rule soundI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I ::\"('sf,'sc,'sz) interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sgs:\"(\\<And>i. 0 \\<le> i \\<Longrightarrow> i < length [(p # \\<Gamma>, q # (closeI \\<Delta> j)), (q # \\<Gamma>, p # (closeI \\<Delta> j))] \\<Longrightarrow> \\<nu> \\<in> seq_sem I ([(p # \\<Gamma>, q # (closeI \\<Delta> j)), (q # \\<Gamma>, p # (closeI \\<Delta> j))] ! i))\""], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?i7;\n   ?i7\n   < length\n      [(p # \\<Gamma>, q # closeI \\<Delta> j),\n       (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n                             (q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                            ?i7)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg1:\"\\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))", "using sgs[of 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0;\n   0 < length\n        [(p # \\<Gamma>, q # closeI \\<Delta> j),\n         (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n                             (q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                            0)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have sg2:\"\\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # (closeI \\<Delta> j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j)", "using sgs[of 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1;\n   1 < length\n        [(p # \\<Gamma>, q # closeI \\<Delta> j),\n         (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n  \\<Longrightarrow> \\<nu>\n                    \\<in> seq_sem I\n                           ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n                             (q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                            1)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \\<Gamma>_sem:\"\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have case1:\"\\<nu> \\<in> fml_sem I p \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sem:\"\\<nu> \\<in> fml_sem I p\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (foldr (||) (q # (close \\<Delta> (nth \\<Delta> j))) FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)", "using sem \\<Gamma>_sem sg1"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I p\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  \\<nu> \\<in> seq_sem I (p # \\<Gamma>, q # close \\<Delta> (\\<Delta> ! j))\n\ngoal (1 subgoal):\n 1. \\<nu>\n    \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using AIjeq SG_dec close_sub[of \\<Delta> \"nth \\<Delta> j\"] iff_sem[of \"\\<nu>\" I p q] jL local.sublist_def\n        member_rec(1)[of q \"close \\<Delta> (nth \\<Delta> j)\"] sem snd_conv\n        or_foldl_sem_conv[of \\<nu> I \"q # close \\<Delta> (nth \\<Delta> j)\"]\n        or_foldl_sem[of \"\\<Delta>\", where I=I and \\<nu>=\\<nu>]\n        nth_member[of j \"snd (SG ! i)\"]"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (||) (q # close \\<Delta> (\\<Delta> ! j)) FF)\n  \\<Delta> ! j = (p \\<leftrightarrow> q)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  sublist (close \\<Delta> (\\<Delta> ! j)) \\<Delta>\n  (\\<nu> \\<in> fml_sem I (p \\<leftrightarrow> q)) =\n  ((\\<nu> \\<in> fml_sem I p) = (\\<nu> \\<in> fml_sem I q))\n  j < length (snd (SG ! i))\n  sublist ?A ?B \\<equiv>\n  \\<forall>x. List.member ?A x \\<longrightarrow> List.member ?B x\n  List.member (q # close \\<Delta> (\\<Delta> ! j)) ?y =\n  (q = ?y \\<or> List.member (close \\<Delta> (\\<Delta> ! j)) ?y)\n  \\<nu> \\<in> fml_sem I p\n  snd (?x1.0, ?x2.0) = ?x2.0\n  \\<nu>\n  \\<in> fml_sem I\n         (foldr (||) (q # close \\<Delta> (\\<Delta> ! j))\n           FF) \\<Longrightarrow>\n  \\<exists>\\<phi>.\n     \\<nu> \\<in> fml_sem I \\<phi> \\<and>\n     List.member (q # close \\<Delta> (\\<Delta> ! j)) \\<phi>\n  \\<lbrakk>List.member \\<Delta> ?\\<phi>;\n   \\<nu> \\<in> fml_sem I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n  j < length (snd (SG ! i)) \\<Longrightarrow>\n  List.member (snd (SG ! i)) (snd (SG ! i) ! j)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by metis"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have case2:\"\\<nu> \\<notin> fml_sem I p \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<notin> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nu> \\<notin> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume sem:\"\\<nu> \\<notin> fml_sem I p\""], ["proof (state)\nthis:\n  \\<nu> \\<notin> fml_sem I p\n\ngoal (1 subgoal):\n 1. \\<nu> \\<notin> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I q \\<Longrightarrow>  \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I q;\n     \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF)\\<rbrakk>\n    \\<Longrightarrow> False", "using  \n          and_foldl_sem[OF \\<Gamma>_sem]\n          and_foldl_sem_conv\n          closeI.simps\n          close_sub\n          local.sublist_def\n          member_rec(1)[of \"p\" \"closeI \\<Delta> j\"]\n          member_rec(1)[of \"q\" \"\\<Gamma>\"]\n          or_foldl_sem[of \"\\<Delta>\"]\n          or_foldl_sem_conv[of \\<nu>  I \"p # closeI \\<Delta> j\"]\n          sem\n          sg2\n          seq_MP[of \\<nu> I \"q # \\<Gamma>\" \"p # closeI \\<Delta> j\", OF sg2]"], ["proof (prove)\nusing this:\n  List.member \\<Gamma> ?\\<phi> \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I ?\\<phi>\n  (\\<And>\\<phi>.\n      List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n      ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n  ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\n  closeI ?L ?i = close ?L (?L ! ?i)\n  sublist (close ?\\<Gamma> ?\\<phi>) ?\\<Gamma>\n  sublist ?A ?B \\<equiv>\n  \\<forall>x. List.member ?A x \\<longrightarrow> List.member ?B x\n  List.member (p # closeI \\<Delta> j) ?y =\n  (p = ?y \\<or> List.member (closeI \\<Delta> j) ?y)\n  List.member (q # \\<Gamma>) ?y = (q = ?y \\<or> List.member \\<Gamma> ?y)\n  \\<lbrakk>List.member \\<Delta> ?\\<phi>;\n   ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) \\<Delta> FF)\n  \\<nu>\n  \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF) \\<Longrightarrow>\n  \\<exists>\\<phi>.\n     \\<nu> \\<in> fml_sem I \\<phi> \\<and>\n     List.member (p # closeI \\<Delta> j) \\<phi>\n  \\<nu> \\<notin> fml_sem I p\n  \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j)\n  \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I q;\n     \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF)\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I q;\n     \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>L i. closeI L i = close L (L ! i);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>y.\n        List.member (p # closeI \\<Delta> j) y =\n        (p = y \\<or> List.member (closeI \\<Delta> j) y);\n     \\<And>y.\n        List.member (q # \\<Gamma>) y = (q = y \\<or> List.member \\<Gamma> y);\n     \\<And>\\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu>\n     \\<in> fml_sem I\n            (foldr (||) (p # closeI \\<Delta> j) FF) \\<Longrightarrow>\n     \\<exists>\\<phi>.\n        \\<nu> \\<in> fml_sem I \\<phi> \\<and>\n        List.member (p # closeI \\<Delta> j) \\<phi>;\n     \\<nu> \\<notin> fml_sem I p;\n     \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j);\n     \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF)\\<rbrakk>\n    \\<Longrightarrow> False", "assume a1: \"\\<nu> \\<in> fml_sem I q\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I q;\n     \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>L i. closeI L i = close L (L ! i);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>y.\n        List.member (p # closeI \\<Delta> j) y =\n        (p = y \\<or> List.member (closeI \\<Delta> j) y);\n     \\<And>y.\n        List.member (q # \\<Gamma>) y = (q = y \\<or> List.member \\<Gamma> y);\n     \\<And>\\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu>\n     \\<in> fml_sem I\n            (foldr (||) (p # closeI \\<Delta> j) FF) \\<Longrightarrow>\n     \\<exists>\\<phi>.\n        \\<nu> \\<in> fml_sem I \\<phi> \\<and>\n        List.member (p # closeI \\<Delta> j) \\<phi>;\n     \\<nu> \\<notin> fml_sem I p;\n     \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j);\n     \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF)\\<rbrakk>\n    \\<Longrightarrow> False", "assume a2: \"\\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (state)\nthis:\n  \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I q;\n     \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>L i. closeI L i = close L (L ! i);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>y.\n        List.member (p # closeI \\<Delta> j) y =\n        (p = y \\<or> List.member (closeI \\<Delta> j) y);\n     \\<And>y.\n        List.member (q # \\<Gamma>) y = (q = y \\<or> List.member \\<Gamma> y);\n     \\<And>\\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu>\n     \\<in> fml_sem I\n            (foldr (||) (p # closeI \\<Delta> j) FF) \\<Longrightarrow>\n     \\<exists>\\<phi>.\n        \\<nu> \\<in> fml_sem I \\<phi> \\<and>\n        List.member (p # closeI \\<Delta> j) \\<phi>;\n     \\<nu> \\<notin> fml_sem I p;\n     \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j);\n     \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF)\\<rbrakk>\n    \\<Longrightarrow> False", "obtain ff :: \"('sf, 'sc, 'sz) formula\" where\n          \"\\<nu> \\<in> fml_sem I ff \\<and> List.member (p # close \\<Delta> (\\<Delta> ! j)) ff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ff.\n        \\<nu> \\<in> fml_sem I ff \\<and>\n        List.member (p # close \\<Delta> (\\<Delta> ! j)) ff \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using a1"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I q\n\ngoal (1 subgoal):\n 1. (\\<And>ff.\n        \\<nu> \\<in> fml_sem I ff \\<and>\n        List.member (p # close \\<Delta> (\\<Delta> ! j)) ff \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) \\<open>\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>\\<close> \\<open>\\<And>y. List.member (q # \\<Gamma>) y = (q = y \\<or> List.member \\<Gamma> y)\\<close> \\<open>\\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF)\\<close> \\<open>\\<nu> \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF) \\<Longrightarrow> \\<exists>\\<phi>. \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member (p # closeI \\<Delta> j) \\<phi>\\<close> and_foldl_sem_conv closeI.simps)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I ff \\<and>\n  List.member (p # close \\<Delta> (\\<Delta> ! j)) ff\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> fml_sem I q;\n     \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>;\n     \\<And>\\<Gamma> \\<nu> I.\n        (\\<And>\\<phi>.\n            List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n     \\<And>L i. closeI L i = close L (L ! i);\n     \\<And>\\<Gamma> \\<phi>. sublist (close \\<Gamma> \\<phi>) \\<Gamma>;\n     \\<And>A B.\n        sublist A B \\<equiv>\n        \\<forall>x. List.member A x \\<longrightarrow> List.member B x;\n     \\<And>y.\n        List.member (p # closeI \\<Delta> j) y =\n        (p = y \\<or> List.member (closeI \\<Delta> j) y);\n     \\<And>y.\n        List.member (q # \\<Gamma>) y = (q = y \\<or> List.member \\<Gamma> y);\n     \\<And>\\<phi> \\<nu> I.\n        \\<lbrakk>List.member \\<Delta> \\<phi>;\n         \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF);\n     \\<nu>\n     \\<in> fml_sem I\n            (foldr (||) (p # closeI \\<Delta> j) FF) \\<Longrightarrow>\n     \\<exists>\\<phi>.\n        \\<nu> \\<in> fml_sem I \\<phi> \\<and>\n        List.member (p # closeI \\<Delta> j) \\<phi>;\n     \\<nu> \\<notin> fml_sem I p;\n     \\<nu> \\<in> seq_sem I (q # \\<Gamma>, p # closeI \\<Delta> j);\n     \\<nu> \\<in> fml_sem I (foldr (&&) (q # \\<Gamma>) TT) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I (foldr (||) (p # closeI \\<Delta> j) FF)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I ff \\<and>\n  List.member (p # close \\<Delta> (\\<Delta> ! j)) ff", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I ff \\<and>\n  List.member (p # close \\<Delta> (\\<Delta> ! j)) ff\n\ngoal (1 subgoal):\n 1. False", "using a2"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I ff \\<and>\n  List.member (p # close \\<Delta> (\\<Delta> ! j)) ff\n  \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. False", "by (metis (no_types) \\<open>\\<And>\\<phi> \\<nu> I. \\<lbrakk>List.member \\<Delta> \\<phi>; \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk> \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\\<close> \\<open>\\<And>y. List.member (p # closeI \\<Delta> j) y = (p = y \\<or> List.member (closeI \\<Delta> j) y)\\<close> closeI.simps close_sub local.sublist_def sem)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<nu> \\<in> fml_sem I q;\n   \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nu> \\<notin> fml_sem I p \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by (metis AIjeq SG_dec \\<open>\\<lbrakk>\\<nu> \\<in> fml_sem I q; \\<nu> \\<notin> fml_sem I (foldr (||) \\<Delta> FF)\\<rbrakk> \\<Longrightarrow> False\\<close> iff_sem jL nth_member or_foldl_sem sem snd_eqD)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nu> \\<notin> fml_sem I p \\<Longrightarrow>\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>i.\n           \\<lbrakk>0 \\<le> i;\n            i < length\n                 [(p # \\<Gamma>, q # closeI \\<Delta> j),\n                  (q # \\<Gamma>, p # closeI \\<Delta> j)]\\<rbrakk>\n           \\<Longrightarrow> \\<nu>\n                             \\<in> seq_sem I\n                                    ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n(q # \\<Gamma>, p # closeI \\<Delta> j)] !\n                                     i);\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by(cases \"\\<nu> \\<in> fml_sem I p\", (simp add: case1 case2)+)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)],\n    \\<Gamma>, \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>SG i j C p q.\n       \\<lbrakk>snd (SG ! i) ! j = (p \\<leftrightarrow> q); i < length SG;\n        j < length (snd (SG ! i)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (close (SG @ Rrule_result EquivR j (SG ! i))\n                            (SG ! i),\n                           C)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result EquivR j (SG ! i)) (SG ! i), C)", "apply(rule close_provable_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG @ Rrule_result EquivR j (SG ! i), C)\n 2. sound (close (SG @ Rrule_result EquivR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound_weaken_appR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sound (SG, C)\n 2. sound (close (SG @ Rrule_result EquivR j (SG ! i)) (SG ! i), SG ! i)", "apply(rule sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result EquivR j (SG ! i)) (SG ! i), SG ! i)", "using res_eq"], ["proof (prove)\nusing this:\n  Rrule_result EquivR j (SG ! i) =\n  [(p # \\<Gamma>, q # closeI \\<Delta> j),\n   (q # \\<Gamma>, p # closeI \\<Delta> j)]\n\ngoal (1 subgoal):\n 1. sound (close (SG @ Rrule_result EquivR j (SG ! i)) (SG ! i), SG ! i)", "apply(unfold res_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] =\n    [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] \\<Longrightarrow>\n    sound\n     (close\n       (SG @\n        [(p # \\<Gamma>, q # closeI \\<Delta> j),\n         (q # \\<Gamma>, p # closeI \\<Delta> j)])\n       (SG ! i),\n      SG ! i)", "unfolding close_app_comm"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] =\n    [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] \\<Longrightarrow>\n    sound\n     (close SG (SG ! i) @\n      close\n       [(p # \\<Gamma>, q # closeI \\<Delta> j),\n        (q # \\<Gamma>, p # closeI \\<Delta> j)]\n       (SG ! i),\n      SG ! i)", "apply (rule sound_weaken_appL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] =\n    [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] \\<Longrightarrow>\n    sound\n     (close\n       [(p # \\<Gamma>, q # closeI \\<Delta> j),\n        (q # \\<Gamma>, p # closeI \\<Delta> j)]\n       (SG ! i),\n      SG ! i)", "using close_eq big_sound SG_dec AIjeq"], ["proof (prove)\nusing this:\n  close\n   [(p # \\<Gamma>, q # closeI \\<Delta> j),\n    (q # \\<Gamma>, p # closeI \\<Delta> j)]\n   (\\<Gamma>, \\<Delta>) =\n  [(p # \\<Gamma>, q # closeI \\<Delta> j),\n   (q # \\<Gamma>, p # closeI \\<Delta> j)]\n  sound\n   ([(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)],\n    \\<Gamma>, \\<Delta>)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  \\<Delta> ! j = (p \\<leftrightarrow> q)\n\ngoal (1 subgoal):\n 1. [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] =\n    [(p # \\<Gamma>, q # closeI \\<Delta> j),\n     (q # \\<Gamma>, p # closeI \\<Delta> j)] \\<Longrightarrow>\n    sound\n     (close\n       [(p # \\<Gamma>, q # closeI \\<Delta> j),\n        (q # \\<Gamma>, p # closeI \\<Delta> j)]\n       (SG ! i),\n      SG ! i)", "by (simp add: AIjeq)"], ["proof (state)\nthis:\n  sound (close (SG @ Rrule_result EquivR j (SG ! i)) (SG ! i), C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_sound:\"step_ok R i S \\<Longrightarrow> i \\<ge> 0 \\<Longrightarrow> i < length (fst R) \\<Longrightarrow> sound R \\<Longrightarrow> sound (step_result R (i,S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>step_ok R i S; 0 \\<le> i; i < length (fst R); sound R\\<rbrakk>\n    \\<Longrightarrow> sound (step_result R (i, S))", "proof(induction rule: step_ok.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_Axiom SG i a C)"], ["proof (state)\nthis:\n  SG ! i = ([], [get_axiom a])\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume is_axiom:\"SG ! i = ([], [get_axiom a])\""], ["proof (state)\nthis:\n  SG ! i = ([], [get_axiom a])\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume i0:\"0 \\<le> i\""], ["proof (state)\nthis:\n  0 \\<le> i\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  i < length (fst (SG, C))", "have iL:\"i < length (SG)\""], ["proof (prove)\nusing this:\n  i < length (fst (SG, C))\n\ngoal (1 subgoal):\n 1. i < length SG", "by auto"], ["proof (state)\nthis:\n  i < length SG\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"seq_valid ([], [get_axiom a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_valid ([], [get_axiom a])", "apply(rule fml_seq_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by(rule axiom_valid)"], ["proof (state)\nthis:\n  seq_valid ([], [get_axiom a])\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid ([], [get_axiom a])", "have seq_valid:\"seq_valid (SG ! i)\""], ["proof (prove)\nusing this:\n  seq_valid ([], [get_axiom a])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "using is_axiom"], ["proof (prove)\nusing this:\n  seq_valid ([], [get_axiom a])\n  SG ! i = ([], [get_axiom a])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "by auto\n  \\<comment> \\<open>\\<open>i0 iL\\<close>\\<close>"], ["proof (state)\nthis:\n  seq_valid (SG ! i)\n\ngoal (10 subgoals):\n 1. \\<And>SG i a C.\n       \\<lbrakk>SG ! i = ([], [get_axiom a]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Axiom a))\n 2. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 4. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 5. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 6. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 7. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 8. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 9. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 10. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n        \\<lbrakk>SG ! i =\n                 ([],\n                  [Fsubst\n                    ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                     $\\<phi> p (singleton \\<theta>'))\n                    \\<sigma>]);\n         valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n         ssafe \\<sigma>;\n         Fadmit \\<sigma>\n          ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n           $\\<phi> p (singleton \\<theta>'));\n         0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n        \\<Longrightarrow> sound\n                           (step_result (SG, C)\n                             (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid (SG ! i)", "show ?case"], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, Axiom a))", "using closeI_valid_sound[OF sound seq_valid]"], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n  sound (closeI SG i, C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, Axiom a))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, Axiom a))\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_AxSubst SG i a \\<sigma> C)"], ["proof (state)\nthis:\n  SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>])\n  Fadmit \\<sigma> (get_axiom a)\n  ssafe \\<sigma>\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume is_axiom:\"SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>])\""], ["proof (state)\nthis:\n  SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>])\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume ssafe:\"ssafe \\<sigma>\""], ["proof (state)\nthis:\n  ssafe \\<sigma>\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume i0:\"0 \\<le> i\""], ["proof (state)\nthis:\n  0 \\<le> i\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume Fadmit:\"Fadmit \\<sigma> (get_axiom a)\""], ["proof (state)\nthis:\n  Fadmit \\<sigma> (get_axiom a)\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  i < length (fst (SG, C))", "have iL:\"i < length (SG)\""], ["proof (prove)\nusing this:\n  i < length (fst (SG, C))\n\ngoal (1 subgoal):\n 1. i < length SG", "by auto"], ["proof (state)\nthis:\n  i < length SG\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have valid_axiom:\"valid (get_axiom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by(rule axiom_valid)"], ["proof (state)\nthis:\n  valid (get_axiom a)\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have subst_valid:\"valid (Fsubst (get_axiom a) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Fsubst (get_axiom a) \\<sigma>)", "apply(rule subst_fml_valid)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Fadmit \\<sigma> (get_axiom a)\n 2. fsafe (get_axiom a)\n 3. ssafe \\<sigma>\n 4. valid (get_axiom a)", "apply(rule Fadmit)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fsafe (get_axiom a)\n 2. ssafe \\<sigma>\n 3. valid (get_axiom a)", "apply(rule axiom_safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ssafe \\<sigma>\n 2. valid (get_axiom a)", "apply(rule ssafe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (get_axiom a)", "by(rule valid_axiom)"], ["proof (state)\nthis:\n  valid (Fsubst (get_axiom a) \\<sigma>)\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"seq_valid ([], [(Fsubst (get_axiom a) \\<sigma>)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_valid ([], [Fsubst (get_axiom a) \\<sigma>])", "apply(rule fml_seq_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Fsubst (get_axiom a) \\<sigma>)", "by(rule subst_valid)"], ["proof (state)\nthis:\n  seq_valid ([], [Fsubst (get_axiom a) \\<sigma>])\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid ([], [Fsubst (get_axiom a) \\<sigma>])", "have seq_valid:\"seq_valid (SG ! i)\""], ["proof (prove)\nusing this:\n  seq_valid ([], [Fsubst (get_axiom a) \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "using is_axiom"], ["proof (prove)\nusing this:\n  seq_valid ([], [Fsubst (get_axiom a) \\<sigma>])\n  SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "by auto\n  \\<comment> \\<open>\\<open>i0 iL\\<close>\\<close>"], ["proof (state)\nthis:\n  seq_valid (SG ! i)\n\ngoal (9 subgoals):\n 1. \\<And>SG i a \\<sigma> C.\n       \\<lbrakk>SG ! i = ([], [Fsubst (get_axiom a) \\<sigma>]);\n        Fadmit \\<sigma> (get_axiom a); ssafe \\<sigma>; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 3. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 4. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 5. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 6. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 7. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 8. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 9. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid (SG ! i)", "show ?case"], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, AxSubst a \\<sigma>))", "using closeI_valid_sound[OF sound seq_valid]"], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n  sound (closeI SG i, C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, AxSubst a \\<sigma>))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, AxSubst a \\<sigma>))\n\ngoal (8 subgoals):\n 1. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 3. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 4. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 5. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 6. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 7. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 8. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 3. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 4. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 5. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 6. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 7. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 8. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_Lrule R i j L)"], ["proof (state)\nthis:\n  lrule_ok R i j L L_\n  L < length (fst (R ! j))\n  0 \\<le> j\n  j < length (fst (R, i))\n  sound (R, i)\n\ngoal (8 subgoals):\n 1. \\<And>SG C i j L.\n       \\<lbrakk>lrule_ok SG C i j L; j < length (fst (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Lrule L j))\n 2. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 3. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 4. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 5. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 6. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 7. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 8. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  lrule_ok R i j L L_\n  L < length (fst (R ! j))\n  0 \\<le> j\n  j < length (fst (R, i))\n  sound (R, i)", "show ?case"], ["proof (prove)\nusing this:\n  lrule_ok R i j L L_\n  L < length (fst (R ! j))\n  0 \\<le> j\n  j < length (fst (R, i))\n  sound (R, i)\n\ngoal (1 subgoal):\n 1. sound (step_result (R, i) (j, Lrule L_ L))", "using lrule_sound"], ["proof (prove)\nusing this:\n  lrule_ok R i j L L_\n  L < length (fst (R ! j))\n  0 \\<le> j\n  j < length (fst (R, i))\n  sound (R, i)\n  \\<lbrakk>lrule_ok ?SG ?C ?i ?j ?L; ?i < length ?SG;\n   ?j < length (fst (?SG ! ?i)); sound (?SG, ?C)\\<rbrakk>\n  \\<Longrightarrow> sound\n                     (close (?SG @ Lrule_result ?L ?j (?SG ! ?i))\n                       (?SG ! ?i),\n                      ?C)\n\ngoal (1 subgoal):\n 1. sound (step_result (R, i) (j, Lrule L_ L))", "using step_result.simps(2) surj_pair"], ["proof (prove)\nusing this:\n  lrule_ok R i j L L_\n  L < length (fst (R ! j))\n  0 \\<le> j\n  j < length (fst (R, i))\n  sound (R, i)\n  \\<lbrakk>lrule_ok ?SG ?C ?i ?j ?L; ?i < length ?SG;\n   ?j < length (fst (?SG ! ?i)); sound (?SG, ?C)\\<rbrakk>\n  \\<Longrightarrow> sound\n                     (close (?SG @ Lrule_result ?L ?j (?SG ! ?i))\n                       (?SG ! ?i),\n                      ?C)\n  step_result (?SG, ?C) (?i, AxSubst ?a ?\\<sigma>) = (closeI ?SG ?i, ?C)\n  \\<exists>x y. ?p = (x, y)\n\ngoal (1 subgoal):\n 1. sound (step_result (R, i) (j, Lrule L_ L))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (R, i) (j, Lrule L_ L))\n\ngoal (7 subgoals):\n 1. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 2. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 3. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 4. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 5. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 6. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 7. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 2. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 3. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 4. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 5. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 6. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 7. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_Rrule R i SG j L)"], ["proof (state)\nthis:\n  rrule_ok R i SG j L\n  j < length (snd (R ! SG))\n  0 \\<le> SG\n  SG < length (fst (R, i))\n  sound (R, i)\n\ngoal (7 subgoals):\n 1. \\<And>SG C i j L.\n       \\<lbrakk>rrule_ok SG C i j L; j < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Rrule L j))\n 2. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 3. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 4. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 5. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 6. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 7. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  rrule_ok R i SG j L\n  j < length (snd (R ! SG))\n  0 \\<le> SG\n  SG < length (fst (R, i))\n  sound (R, i)", "show ?case"], ["proof (prove)\nusing this:\n  rrule_ok R i SG j L\n  j < length (snd (R ! SG))\n  0 \\<le> SG\n  SG < length (fst (R, i))\n  sound (R, i)\n\ngoal (1 subgoal):\n 1. sound (step_result (R, i) (SG, Rrule L j))", "using rrule_sound"], ["proof (prove)\nusing this:\n  rrule_ok R i SG j L\n  j < length (snd (R ! SG))\n  0 \\<le> SG\n  SG < length (fst (R, i))\n  sound (R, i)\n  \\<lbrakk>rrule_ok ?SG ?C ?i ?j ?L; ?i < length ?SG;\n   ?j < length (snd (?SG ! ?i)); sound (?SG, ?C)\\<rbrakk>\n  \\<Longrightarrow> sound\n                     (close (?SG @ Rrule_result ?L ?j (?SG ! ?i))\n                       (?SG ! ?i),\n                      ?C)\n\ngoal (1 subgoal):\n 1. sound (step_result (R, i) (SG, Rrule L j))", "using step_result.simps(2) surj_pair"], ["proof (prove)\nusing this:\n  rrule_ok R i SG j L\n  j < length (snd (R ! SG))\n  0 \\<le> SG\n  SG < length (fst (R, i))\n  sound (R, i)\n  \\<lbrakk>rrule_ok ?SG ?C ?i ?j ?L; ?i < length ?SG;\n   ?j < length (snd (?SG ! ?i)); sound (?SG, ?C)\\<rbrakk>\n  \\<Longrightarrow> sound\n                     (close (?SG @ Rrule_result ?L ?j (?SG ! ?i))\n                       (?SG ! ?i),\n                      ?C)\n  step_result (?SG, ?C) (?i, AxSubst ?a ?\\<sigma>) = (closeI ?SG ?i, ?C)\n  \\<exists>x y. ?p = (x, y)\n\ngoal (1 subgoal):\n 1. sound (step_result (R, i) (SG, Rrule L j))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (R, i) (SG, Rrule L j))\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_Cut \\<phi> i SG C)"], ["proof (state)\nthis:\n  fsafe \\<phi>\n  i < length SG\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume safe:\"fsafe \\<phi>\""], ["proof (state)\nthis:\n  fsafe \\<phi>\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  i < length (fst (SG, C))", "have iL:\"i < length SG\""], ["proof (prove)\nusing this:\n  i < length (fst (SG, C))\n\ngoal (1 subgoal):\n 1. i < length SG", "by auto"], ["proof (state)\nthis:\n  i < length SG\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "obtain \\<Gamma> and \\<Delta> where SG_dec:\"(\\<Gamma>,\\<Delta>) = (SG ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis seq2fml.cases)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"sound ((\\<phi> # \\<Gamma>, \\<Delta>) # (\\<Gamma>, \\<phi> # \\<Delta>) # [y\\<leftarrow>SG . y \\<noteq> SG ! i], C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     ((\\<phi> # \\<Gamma>, \\<Delta>) #\n      (\\<Gamma>, \\<phi> # \\<Delta>) #\n      filter (\\<lambda>y. y \\<noteq> SG ! i) SG,\n      C)", "apply(rule soundI_memv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "fix I::\"('sf,'sc,'sz) interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "assume sgs:\"(\\<And>\\<phi>' \\<nu>. List.member ((\\<phi> # \\<Gamma>, \\<Delta>) # (\\<Gamma>, \\<phi> # \\<Delta>) # [y\\<leftarrow>SG . y \\<noteq> SG ! i]) \\<phi>' \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>')\""], ["proof (state)\nthis:\n  List.member\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n   ?\\<phi>'7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>'7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have sg1:\"\\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<phi> # \\<Gamma>, \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<phi> # \\<Gamma>, \\<Delta>)", "using sgs"], ["proof (prove)\nusing this:\n  List.member\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n   ?\\<phi>'7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>'7\n\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<phi> # \\<Gamma>, \\<Delta>)", "by (meson member_rec(1))"], ["proof (state)\nthis:\n  ?\\<nu>7 \\<in> seq_sem I (\\<phi> # \\<Gamma>, \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have sg2:\"\\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<phi> # \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<phi> # \\<Delta>)", "using sgs"], ["proof (prove)\nusing this:\n  List.member\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n   ?\\<phi>'7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>'7\n\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<phi> # \\<Delta>)", "by (meson member_rec(1))"], ["proof (state)\nthis:\n  ?\\<nu>7 \\<in> seq_sem I (\\<Gamma>, \\<phi> # \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have sgs:\"\\<And>\\<phi> \\<nu>. (List.member (close SG (nth SG i)) \\<phi>) \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member (close SG (SG ! i)) \\<phi> \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>", "using sgs"], ["proof (prove)\nusing this:\n  List.member\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n   ?\\<phi>'7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>'7\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member (close SG (SG ! i)) \\<phi> \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>", "by (simp add: member_rec(1))"], ["proof (state)\nthis:\n  List.member (close SG (SG ! i)) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "then"], ["proof (chain)\npicking this:\n  List.member (close SG (SG ! i)) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7", "have sgs:\"\\<And>\\<phi> \\<nu>. (List.member (close SG (\\<Gamma>,\\<Delta>)) \\<phi>) \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>\""], ["proof (prove)\nusing this:\n  List.member (close SG (SG ! i)) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member (close SG (\\<Gamma>, \\<Delta>)) \\<phi> \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>", "using SG_dec"], ["proof (prove)\nusing this:\n  List.member (close SG (SG ! i)) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member (close SG (\\<Gamma>, \\<Delta>)) \\<phi> \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>", "by auto"], ["proof (state)\nthis:\n  List.member (close SG (\\<Gamma>, \\<Delta>)) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have sgNew:\"\\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "using sg1 sg2"], ["proof (prove)\nusing this:\n  ?\\<nu>7 \\<in> seq_sem I (\\<phi> # \\<Gamma>, \\<Delta>)\n  ?\\<nu>7 \\<in> seq_sem I (\\<Gamma>, \\<phi> # \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  ?\\<nu>7 \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have same_mem:\"\\<And>x. List.member SG x \\<Longrightarrow> List.member ((\\<Gamma>,\\<Delta>) # close SG (\\<Gamma>,\\<Delta>)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member SG x \\<Longrightarrow>\n       List.member ((\\<Gamma>, \\<Delta>) # close SG (\\<Gamma>, \\<Delta>)) x", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member SG s \\<Longrightarrow>\n    List.member ((\\<Gamma>, \\<Delta>) # close SG (\\<Gamma>, \\<Delta>)) s", "by(induction SG, auto simp add: member_rec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  List.member SG ?x7 \\<Longrightarrow>\n  List.member ((\\<Gamma>, \\<Delta>) # close SG (\\<Gamma>, \\<Delta>)) ?x7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have SGS:\"(\\<And>\\<phi>' \\<nu>. List.member SG \\<phi>' \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<nu>.\n       List.member SG \\<phi>' \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>'", "using sgNew sgs same_mem member_rec(1) seq_MP"], ["proof (prove)\nusing this:\n  ?\\<nu>7 \\<in> seq_sem I (\\<Gamma>, \\<Delta>)\n  List.member (close SG (\\<Gamma>, \\<Delta>)) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n  List.member SG ?x7 \\<Longrightarrow>\n  List.member ((\\<Gamma>, \\<Delta>) # close SG (\\<Gamma>, \\<Delta>)) ?x7\n  List.member (?x # ?xs) ?y = (?x = ?y \\<or> List.member ?xs ?y)\n  \\<lbrakk>?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>);\n   ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<nu>.\n       List.member SG \\<phi>' \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>'", "by metis"], ["proof (state)\nthis:\n  List.member SG ?\\<phi>'7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>'7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi>' \\<nu>.\n           List.member\n            ((\\<phi> # \\<Gamma>, \\<Delta>) #\n             (\\<Gamma>, \\<phi> # \\<Delta>) #\n             filter (\\<lambda>y. y \\<noteq> SG ! i) SG)\n            \\<phi>' \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "show \"\\<nu> \\<in> seq_sem I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I C", "using sound"], ["proof (prove)\nusing this:\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I C", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (seq2fml C)", "apply(drule soundD_memv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_interp ?I1\n 2. \\<And>\\<phi> \\<nu>.\n       List.member SG \\<phi> \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem ?I1 \\<phi>\n 3. ?\\<nu>1 \\<in> seq_sem ?I1 C \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (seq2fml C)", "apply(rule good)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>\n 2. ?\\<nu>1 \\<in> seq_sem I C \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (seq2fml C)", "using SGS"], ["proof (prove)\nusing this:\n  List.member SG ?\\<phi>'7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>'7\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>\n 2. ?\\<nu>1 \\<in> seq_sem I C \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (seq2fml C)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?\\<nu>1 \\<in> seq_sem I C \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (seq2fml C)", "by auto"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG,\n    C)\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi> i SG C.\n       \\<lbrakk>fsafe \\<phi>; i < length SG; 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))\n 2. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 3. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 4. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 5. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 6. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  sound\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG,\n    C)", "show ?case"], ["proof (prove)\nusing this:\n  sound\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG,\n    C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, Cut \\<phi>))", "using SG_dec case_prod_conv"], ["proof (prove)\nusing this:\n  sound\n   ((\\<phi> # \\<Gamma>, \\<Delta>) #\n    (\\<Gamma>, \\<phi> # \\<Delta>) #\n    filter (\\<lambda>y. y \\<noteq> SG ! i) SG,\n    C)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, Cut \\<phi>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound\n              ((\\<phi> # \\<Gamma>, \\<Delta>) #\n               (\\<Gamma>, \\<phi> # \\<Delta>) #\n               filter (\\<lambda>y. y \\<noteq> SG ! i) SG,\n               C);\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>f a b.\n        (case (a, b) of (c, d) \\<Rightarrow> f c d) = f a b\\<rbrakk>\n    \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))", "have \"(\\<And>f. ((case nth SG i of (x, xa) \\<Rightarrow> ((f x xa)::('sf, 'sc, 'sz) rule)) = (f \\<Gamma> \\<Delta>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (case SG ! i of (x, xa) \\<Rightarrow> f x xa) = f \\<Gamma> \\<Delta>", "by (metis (no_types) SG_dec case_prod_conv)"], ["proof (state)\nthis:\n  (case SG ! i of (x, xa) \\<Rightarrow> ?f7 x xa) = ?f7 \\<Gamma> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound\n              ((\\<phi> # \\<Gamma>, \\<Delta>) #\n               (\\<Gamma>, \\<phi> # \\<Delta>) #\n               filter (\\<lambda>y. y \\<noteq> SG ! i) SG,\n               C);\n     (\\<Gamma>, \\<Delta>) = SG ! i;\n     \\<And>f a b.\n        (case (a, b) of (c, d) \\<Rightarrow> f c d) = f a b\\<rbrakk>\n    \\<Longrightarrow> sound (step_result (SG, C) (i, Cut \\<phi>))", "then"], ["proof (chain)\npicking this:\n  (case SG ! i of (x, xa) \\<Rightarrow> ?f7 x xa) = ?f7 \\<Gamma> \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  (case SG ! i of (x, xa) \\<Rightarrow> ?f7 x xa) = ?f7 \\<Gamma> \\<Delta>\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, Cut \\<phi>))", "by (simp add: \\<open>sound ((\\<phi> # \\<Gamma>, \\<Delta>) # (\\<Gamma>, \\<phi> # \\<Delta>) # [y\\<leftarrow>SG . y \\<noteq> SG ! i], C)\\<close>)"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, Cut \\<phi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, Cut \\<phi>))\n\ngoal (5 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 3. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 4. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 5. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 3. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 4. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 5. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_G SG i C a p)"], ["proof (state)\nthis:\n  SG ! i = ([], [[[a]]p])\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 3. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 4. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 5. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume eq:\"SG ! i = ([], [([[a]]p)])\""], ["proof (state)\nthis:\n  SG ! i = ([], [[[a]]p])\n\ngoal (5 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 3. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 4. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 5. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume iL:\"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (5 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 3. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 4. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 5. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 3. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 4. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 5. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"sound (([], [p]) # (close SG ([], [([[ a ]] p)])), C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (([], [p]) # close SG ([], [[[a]]p]), C)", "apply(rule soundI_memv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "fix I::\"('sf,'sc,'sz) interp\" and  \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "assume \"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "assume sgs:\"(\\<And>\\<phi> \\<nu>. List.member (([], [p]) # close SG ([], [([[a]]p)])) \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>)\""], ["proof (state)\nthis:\n  List.member (([], [p]) # close SG ([], [[[a]]p]))\n   ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have sg0:\"(\\<And>\\<nu>. \\<nu> \\<in> seq_sem I ([], [p]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I ([], [p])", "using sgs"], ["proof (prove)\nusing this:\n  List.member (([], [p]) # close SG ([], [[[a]]p]))\n   ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I ([], [p])", "by (meson member_rec(1))"], ["proof (state)\nthis:\n  ?\\<nu>7 \\<in> seq_sem I ([], [p])\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "then"], ["proof (chain)\npicking this:\n  ?\\<nu>7 \\<in> seq_sem I ([], [p])", "have sg0':\"(\\<And>\\<nu>. \\<nu> \\<in> seq_sem I ([], [([[a]]p)]))\""], ["proof (prove)\nusing this:\n  ?\\<nu>7 \\<in> seq_sem I ([], [p])\n\ngoal (1 subgoal):\n 1. \\<And>\\<nu>. \\<nu> \\<in> seq_sem I ([], [[[a]]p])", "by auto"], ["proof (state)\nthis:\n  ?\\<nu>7 \\<in> seq_sem I ([], [[[a]]p])\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have sgTail:\"(\\<And>\\<phi> \\<nu>. List.member (close SG ([], [([[a]]p)])) \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member (close SG ([], [[[a]]p])) \\<phi> \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>", "using sgs"], ["proof (prove)\nusing this:\n  List.member (([], [p]) # close SG ([], [[[a]]p]))\n   ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member (close SG ([], [[[a]]p])) \\<phi> \\<Longrightarrow>\n       \\<nu> \\<in> seq_sem I \\<phi>", "by (simp add: member_rec(1))"], ["proof (state)\nthis:\n  List.member (close SG ([], [[[a]]p])) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have same_mem:\"\\<And>x. List.member SG x \\<Longrightarrow> List.member (([], [([[a]]p)]) # close SG ([], [([[a]]p)])) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member SG x \\<Longrightarrow>\n       List.member (([], [[[a]]p]) # close SG ([], [[[a]]p])) x", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member SG s \\<Longrightarrow>\n    List.member (([], [[[a]]p]) # close SG ([], [[[a]]p])) s", "by(induction SG, auto simp add: member_rec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  List.member SG ?x7 \\<Longrightarrow>\n  List.member (([], [[[a]]p]) # close SG ([], [[[a]]p])) ?x7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "have sgsC:\"(\\<And>\\<phi> \\<nu>. List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<nu>.\n       List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member SG (a, b);\n        (aa, ba) \\<in> fml_sem I (foldr (&&) a TT)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "using sgTail sg0' same_mem member_rec"], ["proof (prove)\nusing this:\n  List.member (close SG ([], [[[a]]p])) ?\\<phi>7 \\<Longrightarrow>\n  ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n  ?\\<nu>7 \\<in> seq_sem I ([], [[[a]]p])\n  List.member SG ?x7 \\<Longrightarrow>\n  List.member (([], [[[a]]p]) # close SG ([], [[[a]]p])) ?x7\n  List.member (?x # ?xs) ?y = (?x = ?y \\<or> List.member ?xs ?y)\n  List.member [] ?y = False\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>List.member SG (a, b);\n        (aa, ba) \\<in> fml_sem I (foldr (&&) a TT)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> fml_sem I (foldr (||) b FF)", "by (metis seq_MP)"], ["proof (state)\nthis:\n  List.member SG ?\\<phi>7 \\<Longrightarrow> ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<And>\\<phi> \\<nu>.\n           List.member (([], [p]) # close SG ([], [[[a]]p]))\n            \\<phi> \\<Longrightarrow>\n           \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> seq_sem I C", "then"], ["proof (chain)\npicking this:\n  List.member SG ?\\<phi>7 \\<Longrightarrow> ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7", "show \"\\<nu> \\<in> seq_sem I C\""], ["proof (prove)\nusing this:\n  List.member SG ?\\<phi>7 \\<Longrightarrow> ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I C", "using sound"], ["proof (prove)\nusing this:\n  List.member SG ?\\<phi>7 \\<Longrightarrow> ?\\<nu>7 \\<in> seq_sem I ?\\<phi>7\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> seq_sem I C", "by (metis UNIV_eq_I \\<open>is_interp I\\<close> iso_tuple_UNIV_I soundD_mem)"], ["proof (state)\nthis:\n  \\<nu> \\<in> seq_sem I C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound (([], [p]) # close SG ([], [[[a]]p]), C)\n\ngoal (5 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i C a p.\n       \\<lbrakk>SG ! i = ([], [[[a]]p]); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, G))\n 3. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 4. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 5. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  sound (([], [p]) # close SG ([], [[[a]]p]), C)", "show ?case"], ["proof (prove)\nusing this:\n  sound (([], [p]) # close SG ([], [[[a]]p]), C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, G))", "by(auto simp add: eq Box_def)"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, G))\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_CloseId SG i j k C)"], ["proof (state)\nthis:\n  fst (SG ! i) ! j = snd (SG ! i) ! k\n  j < length (fst (SG ! i))\n  k < length (snd (SG ! i))\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume match:\"fst (SG ! i) ! j = snd (SG ! i) ! k\""], ["proof (state)\nthis:\n  fst (SG ! i) ! j = snd (SG ! i) ! k\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume jL:\"j < length (fst (SG ! i))\""], ["proof (state)\nthis:\n  j < length (fst (SG ! i))\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume kL:\"k < length (snd (SG ! i))\""], ["proof (state)\nthis:\n  k < length (snd (SG ! i))\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume iL:\"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  i < length (fst (SG, C))", "have iL:\"i < length (SG)\""], ["proof (prove)\nusing this:\n  i < length (fst (SG, C))\n\ngoal (1 subgoal):\n 1. i < length SG", "by auto"], ["proof (state)\nthis:\n  i < length SG\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "obtain \\<Gamma> \\<Delta> where SG_dec:\"(\\<Gamma>, \\<Delta>) = SG ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        (\\<Gamma>, \\<Delta>) = SG ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have j\\<Gamma>:\"j < length \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length \\<Gamma>", "using SG_dec jL"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  j < length (fst (SG ! i))\n\ngoal (1 subgoal):\n 1. j < length \\<Gamma>", "by (metis fst_conv)"], ["proof (state)\nthis:\n  j < length \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have k\\<Delta>:\"k < length \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length \\<Delta>", "using SG_dec kL"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<Delta>) = SG ! i\n  k < length (snd (SG ! i))\n\ngoal (1 subgoal):\n 1. k < length \\<Delta>", "by (metis snd_conv)"], ["proof (state)\nthis:\n  k < length \\<Delta>\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"\\<And>I \\<nu>. is_interp I \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "fix I::\"('sf,'sc,'sz)interp\" and \\<nu>::\"'sz state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume good:\"is_interp I\""], ["proof (state)\nthis:\n  is_interp I\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "assume \\<Gamma>_sem:\"\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\""], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have mem:\"List.member \\<Gamma> (\\<Gamma> ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member \\<Gamma> (\\<Gamma> ! j)", "using j\\<Gamma> nth_member"], ["proof (prove)\nusing this:\n  j < length \\<Gamma>\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n\ngoal (1 subgoal):\n 1. List.member \\<Gamma> (\\<Gamma> ! j)", "by blast"], ["proof (state)\nthis:\n  List.member \\<Gamma> (\\<Gamma> ! j)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have mem2:\"List.member \\<Delta> (\\<Delta> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member \\<Delta> (\\<Delta> ! k)", "using k\\<Delta> nth_member"], ["proof (prove)\nusing this:\n  k < length \\<Delta>\n  ?n < length ?L \\<Longrightarrow> List.member ?L (?L ! ?n)\n\ngoal (1 subgoal):\n 1. List.member \\<Delta> (\\<Delta> ! k)", "by blast"], ["proof (state)\nthis:\n  List.member \\<Delta> (\\<Delta> ! k)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "have \"\\<nu> \\<in> fml_sem I (\\<Gamma> ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (\\<Gamma> ! j)", "using \\<Gamma>_sem mem"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  List.member \\<Gamma> (\\<Gamma> ! j)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (\\<Gamma> ! j)", "using and_foldl_sem"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\n  List.member \\<Gamma> (\\<Gamma> ! j)\n  \\<lbrakk>?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT);\n   List.member ?\\<Gamma> ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (\\<Gamma> ! j)", "by blast"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (\\<Gamma> ! j)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (\\<Gamma> ! j)", "have \"\\<nu> \\<in> fml_sem I (\\<Delta> ! k)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (\\<Gamma> ! j)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (\\<Delta> ! k)", "using match SG_dec"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (\\<Gamma> ! j)\n  fst (SG ! i) ! j = snd (SG ! i) ! k\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (\\<Delta> ! k)", "by (metis fst_conv snd_conv)"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (\\<Delta> ! k)\n\ngoal (1 subgoal):\n 1. \\<And>I \\<nu>.\n       \\<lbrakk>is_interp I;\n        \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n       \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "then"], ["proof (chain)\npicking this:\n  \\<nu> \\<in> fml_sem I (\\<Delta> ! k)", "show \"\\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\""], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (\\<Delta> ! k)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using mem2"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (\\<Delta> ! k)\n  List.member \\<Delta> (\\<Delta> ! k)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using or_foldl_sem"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> fml_sem I (\\<Delta> ! k)\n  List.member \\<Delta> (\\<Delta> ! k)\n  \\<lbrakk>List.member ?\\<Gamma> ?\\<phi>;\n   ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF)\n\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by blast"], ["proof (state)\nthis:\n  \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>is_interp ?I7;\n   ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_interp ?I7;\n   ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)", "have seq_valid:\"seq_valid (SG ! i)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_interp ?I7;\n   ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "unfolding seq_valid_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_interp ?I7;\n   ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n\ngoal (1 subgoal):\n 1. \\<forall>I. is_interp I \\<longrightarrow> seq_sem I (SG ! i) = UNIV", "using SG_dec"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_interp ?I7;\n   ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu>7 \\<in> fml_sem ?I7 (foldr (||) \\<Delta> FF)\n  (\\<Gamma>, \\<Delta>) = SG ! i\n\ngoal (1 subgoal):\n 1. \\<forall>I. is_interp I \\<longrightarrow> seq_sem I (SG ! i) = UNIV", "by (metis UNIV_eq_I seq_semI')"], ["proof (state)\nthis:\n  seq_valid (SG ! i)\n\ngoal (4 subgoals):\n 1. \\<And>SG i j k C.\n       \\<lbrakk>fst (SG ! i) ! j = snd (SG ! i) ! k;\n        j < length (fst (SG ! i)); k < length (snd (SG ! i)); 0 \\<le> i;\n        i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound (step_result (SG, C) (i, CloseId j k))\n 2. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 3. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 4. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid (SG ! i)", "show \"sound (step_result (SG, C) (i, CloseId j k))\""], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, CloseId j k))", "using closeI_valid_sound[OF sound seq_valid]"], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n  sound (closeI SG i, C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, CloseId j k))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, CloseId j k))\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_DEAxiom_schema SG i ODE \\<sigma> C )"], ["proof (state)\nthis:\n  SG ! i =\n  ([],\n   [Fsubst\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n     \\<sigma>])\n  ssafe \\<sigma>\n  osafe ODE\n  {Inl vid1, Inr vid1} \\<inter> BVO ODE = {}\n  Fadmit \\<sigma>\n   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n        (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume isNth:\"nth SG i =\n  ([], [Fsubst (([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]]P pid1) \\<leftrightarrow>\n                ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1)) \\<sigma>])\""], ["proof (state)\nthis:\n  SG ! i =\n  ([],\n   [Fsubst\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n     \\<sigma>])\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume FA:\"Fadmit \\<sigma>\n   (([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]]P pid1) \\<leftrightarrow>\n    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\""], ["proof (state)\nthis:\n  Fadmit \\<sigma>\n   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n        (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume disj:\"{Inl vid1, Inr vid1} \\<inter> BVO ODE = {}\""], ["proof (state)\nthis:\n  {Inl vid1, Inr vid1} \\<inter> BVO ODE = {}\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have schem_valid:\"valid (([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]] (P pid1)) \\<leftrightarrow>\n    ([[EvolveODE ((OProd (OSing vid1 (f1 fid1 vid1))ODE)) (p1 vid2 vid1)]]\n    [[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "using DE_sys_valid[OF disj]"], ["proof (prove)\nusing this:\n  valid\n   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n        (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n\ngoal (1 subgoal):\n 1. valid\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "by auto"], ["proof (state)\nthis:\n  valid\n   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n        (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume ssafe:\"ssafe \\<sigma>\""], ["proof (state)\nthis:\n  ssafe \\<sigma>\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume osafe:\"osafe ODE\""], ["proof (state)\nthis:\n  osafe ODE\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have subst_valid:\"valid (Fsubst (([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]]P pid1) \\<leftrightarrow>\n                ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1)) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Fsubst\n       ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n           (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n        ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n            (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n       \\<sigma>)", "apply(rule subst_fml_valid)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Fadmit \\<sigma>\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n 2. fsafe\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n 3. ssafe \\<sigma>\n 4. valid\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "apply(rule FA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fsafe\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n 2. ssafe \\<sigma>\n 3. valid\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsafe\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "using disj"], ["proof (prove)\nusing this:\n  {Inl vid1, Inr vid1} \\<inter> BVO ODE = {}\n\ngoal (1 subgoal):\n 1. fsafe\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "by(auto simp add: f1_def Box_def p1_def P_def Equiv_def Or_def expand_singleton osafe, induction ODE, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ssafe \\<sigma>\n 2. valid\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ssafe \\<sigma>", "by (rule ssafe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))", "by (rule schem_valid)"], ["proof (state)\nthis:\n  valid\n   (Fsubst\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n     \\<sigma>)\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"0 \\<le> i\""], ["proof (state)\nthis:\n  0 \\<le> i\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"seq_valid ([], [(Fsubst (([[EvolveODE (OProd  (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]]P pid1) \\<leftrightarrow>\n                ([[EvolveODE (OProd  (OSing vid1 (f1 fid1 vid1))ODE) (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1)) \\<sigma>)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_valid\n     ([],\n      [Fsubst\n        ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n            (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n        \\<sigma>])", "apply(rule fml_seq_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Fsubst\n       ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n           (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n        ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n            (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n       \\<sigma>)", "by(rule subst_valid)"], ["proof (state)\nthis:\n  seq_valid\n   ([],\n    [Fsubst\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n       ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n           (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n      \\<sigma>])\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid\n   ([],\n    [Fsubst\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n       ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n           (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n      \\<sigma>])", "have seq_valid:\"seq_valid (SG ! i)\""], ["proof (prove)\nusing this:\n  seq_valid\n   ([],\n    [Fsubst\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n       ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n           (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n      \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "using isNth"], ["proof (prove)\nusing this:\n  seq_valid\n   ([],\n    [Fsubst\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n       ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n           (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n      \\<sigma>])\n  SG ! i =\n  ([],\n   [Fsubst\n     ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n     \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "by auto\n  \\<comment> \\<open>\\<open>i0 iL\\<close>\\<close>"], ["proof (state)\nthis:\n  seq_valid (SG ! i)\n\ngoal (3 subgoals):\n 1. \\<And>SG i ODE \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                       (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n                    ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n                        (p1 vid2\n                          vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n                   \\<sigma>]);\n        ssafe \\<sigma>; osafe ODE;\n        {Inl vid1, Inr vid1} \\<inter> BVO ODE = {};\n        Fadmit \\<sigma>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n          ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n              (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, DEAxiomSchema ODE \\<sigma>))\n 2. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 3. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid (SG ! i)", "show ?case"], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, DEAxiomSchema ODE \\<sigma>))", "using closeI_valid_sound[OF sound seq_valid]"], ["proof (prove)\nusing this:\n  seq_valid (SG ! i)\n  sound (closeI SG i, C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, DEAxiomSchema ODE \\<sigma>))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, DEAxiomSchema ODE \\<sigma>))\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_CE SG i \\<phi> \\<psi> \\<sigma> C)"], ["proof (state)\nthis:\n  SG ! i =\n  ([],\n   [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n     \\<sigma>])\n  valid (\\<phi> \\<leftrightarrow> \\<psi>)\n  fsafe \\<phi>\n  fsafe \\<psi>\n  ssafe \\<sigma>\n  Fadmit \\<sigma>\n   (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume isNth:\"SG ! i = ([], [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>) \\<sigma>])\""], ["proof (state)\nthis:\n  SG ! i =\n  ([],\n   [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n     \\<sigma>])\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume valid:\"valid (\\<phi> \\<leftrightarrow> \\<psi>)\""], ["proof (state)\nthis:\n  valid (\\<phi> \\<leftrightarrow> \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume FA:\"Fadmit \\<sigma> (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\""], ["proof (state)\nthis:\n  Fadmit \\<sigma>\n   (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"0 \\<le> i\""], ["proof (state)\nthis:\n  0 \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume fsafe1:\"fsafe \\<phi>\""], ["proof (state)\nthis:\n  fsafe \\<phi>\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume fsafe2:\"fsafe \\<psi>\""], ["proof (state)\nthis:\n  fsafe \\<psi>\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume ssafe:\"ssafe \\<sigma>\""], ["proof (state)\nthis:\n  ssafe \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have schem_valid:\"valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)", "using valid"], ["proof (prove)\nusing this:\n  valid (\\<phi> \\<leftrightarrow> \\<psi>)\n\ngoal (1 subgoal):\n 1. valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)", "unfolding valid_def"], ["proof (prove)\nusing this:\n  \\<forall>I \\<nu>.\n     is_interp I \\<longrightarrow>\n     \\<nu> \\<in> fml_sem I (\\<phi> \\<leftrightarrow> \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>I \\<nu>.\n       is_interp I \\<longrightarrow>\n       \\<nu>\n       \\<in> fml_sem I\n              (InContext pid1 \\<phi> \\<leftrightarrow>\n               InContext pid1 \\<psi>)", "by (metis CE_holds_def CE_sound fml_sem.simps(7) iff_sem surj_pair valid_def)+"], ["proof (state)\nthis:\n  valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have subst_valid:\"valid (Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n       \\<sigma>)", "apply(rule subst_fml_valid)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Fadmit \\<sigma>\n     (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n 2. fsafe (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n 3. ssafe \\<sigma>\n 4. valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)", "apply(rule FA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fsafe (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n 2. ssafe \\<sigma>\n 3. valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsafe (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)", "by(auto simp add: f1_def Box_def p1_def P_def Equiv_def Or_def expand_singleton fsafe1 fsafe2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ssafe \\<sigma>\n 2. valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ssafe \\<sigma>", "by (rule ssafe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)", "by (rule schem_valid)"], ["proof (state)\nthis:\n  valid\n   (Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n     \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"seq_valid ([], [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>) \\<sigma>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_valid\n     ([],\n      [Fsubst\n        (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n        \\<sigma>])", "apply(rule fml_seq_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n       \\<sigma>)", "by(rule subst_valid)"], ["proof (state)\nthis:\n  seq_valid\n   ([],\n    [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n      \\<sigma>])\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid\n   ([],\n    [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n      \\<sigma>])", "have seq_valid:\"seq_valid (SG ! i)\""], ["proof (prove)\nusing this:\n  seq_valid\n   ([],\n    [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n      \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "using isNth"], ["proof (prove)\nusing this:\n  seq_valid\n   ([],\n    [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n      \\<sigma>])\n  SG ! i =\n  ([],\n   [Fsubst (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>)\n     \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "by auto"], ["proof (state)\nthis:\n  seq_valid (SG ! i)\n\ngoal (2 subgoals):\n 1. \\<And>SG i \\<phi> \\<psi> \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   (InContext pid1 \\<phi> \\<leftrightarrow>\n                    InContext pid1 \\<psi>)\n                   \\<sigma>]);\n        valid (\\<phi> \\<leftrightarrow> \\<psi>); fsafe \\<phi>; fsafe \\<psi>;\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         (InContext pid1 \\<phi> \\<leftrightarrow> InContext pid1 \\<psi>);\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CE \\<phi> \\<psi> \\<sigma>))\n 2. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "show \"sound (step_result (SG, C) (i, CE \\<phi> \\<psi> \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, CE \\<phi> \\<psi> \\<sigma>))", "using closeI_valid_sound[OF sound seq_valid]"], ["proof (prove)\nusing this:\n  sound (closeI SG i, C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, CE \\<phi> \\<psi> \\<sigma>))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, CE \\<phi> \\<psi> \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "case (Step_CQ SG i p \\<theta> \\<theta>' \\<sigma> C)"], ["proof (state)\nthis:\n  SG ! i =\n  ([],\n   [Fsubst\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n     \\<sigma>])\n  valid (Equals \\<theta> \\<theta>')\n  dsafe \\<theta>\n  dsafe \\<theta>'\n  ssafe \\<sigma>\n  Fadmit \\<sigma>\n   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n    $\\<phi> p (singleton \\<theta>'))\n  0 \\<le> i\n  i < length (fst (SG, C))\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume isNth:\"nth SG  i = ([], [Fsubst (Equiv (Prop p (singleton \\<theta>)) (Prop p (singleton \\<theta>'))) \\<sigma>])\""], ["proof (state)\nthis:\n  SG ! i =\n  ([],\n   [Fsubst\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n     \\<sigma>])\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume valid:\"valid (Equals \\<theta> \\<theta>')\""], ["proof (state)\nthis:\n  valid (Equals \\<theta> \\<theta>')\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume FA:\"Fadmit \\<sigma> ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow> $\\<phi> p (singleton \\<theta>'))\""], ["proof (state)\nthis:\n  Fadmit \\<sigma>\n   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n    $\\<phi> p (singleton \\<theta>'))\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"0 \\<le> i\""], ["proof (state)\nthis:\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume \"i < length (fst (SG, C))\""], ["proof (state)\nthis:\n  i < length (fst (SG, C))\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume sound:\"sound (SG, C)\""], ["proof (state)\nthis:\n  sound (SG, C)\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume dsafe1:\"dsafe \\<theta>\""], ["proof (state)\nthis:\n  dsafe \\<theta>\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume dsafe2:\"dsafe \\<theta>'\""], ["proof (state)\nthis:\n  dsafe \\<theta>'\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "assume ssafe:\"ssafe \\<sigma>\""], ["proof (state)\nthis:\n  ssafe \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have schem_valid:\"valid ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow> $\\<phi> p (singleton \\<theta>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))", "using valid"], ["proof (prove)\nusing this:\n  valid (Equals \\<theta> \\<theta>')\n\ngoal (1 subgoal):\n 1. valid\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))", "unfolding valid_def"], ["proof (prove)\nusing this:\n  \\<forall>I \\<nu>.\n     is_interp I \\<longrightarrow>\n     \\<nu> \\<in> fml_sem I (Equals \\<theta> \\<theta>')\n\ngoal (1 subgoal):\n 1. \\<forall>I \\<nu>.\n       is_interp I \\<longrightarrow>\n       \\<nu>\n       \\<in> fml_sem I\n              ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n               $\\<phi> p (singleton \\<theta>'))", "by (metis CQ_holds_def CQ_sound fml_sem.simps(7) iff_sem surj_pair valid_def)+"], ["proof (state)\nthis:\n  valid\n   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n    $\\<phi> p (singleton \\<theta>'))\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have subst_valid:\"valid (Fsubst ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow> $\\<phi> p (singleton \\<theta>')) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Fsubst\n       ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n        $\\<phi> p (singleton \\<theta>'))\n       \\<sigma>)", "apply(rule subst_fml_valid)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Fadmit \\<sigma>\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n 2. fsafe\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n 3. ssafe \\<sigma>\n 4. valid\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))", "apply(rule FA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fsafe\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n 2. ssafe \\<sigma>\n 3. valid\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))", "using schem_valid ssafe"], ["proof (prove)\nusing this:\n  valid\n   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n    $\\<phi> p (singleton \\<theta>'))\n  ssafe \\<sigma>\n\ngoal (3 subgoals):\n 1. fsafe\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n 2. ssafe \\<sigma>\n 3. valid\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))", "by (auto simp add: f1_def Box_def p1_def P_def Equiv_def Or_def expand_singleton dsafe1 dsafe2 expand_singleton)"], ["proof (state)\nthis:\n  valid\n   (Fsubst\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n     \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "have \"seq_valid ([], [Fsubst ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow> $\\<phi> p (singleton \\<theta>')) \\<sigma>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_valid\n     ([],\n      [Fsubst\n        ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n         $\\<phi> p (singleton \\<theta>'))\n        \\<sigma>])", "apply(rule fml_seq_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Fsubst\n       ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n        $\\<phi> p (singleton \\<theta>'))\n       \\<sigma>)", "by(rule subst_valid)"], ["proof (state)\nthis:\n  seq_valid\n   ([],\n    [Fsubst\n      ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n       $\\<phi> p (singleton \\<theta>'))\n      \\<sigma>])\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "then"], ["proof (chain)\npicking this:\n  seq_valid\n   ([],\n    [Fsubst\n      ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n       $\\<phi> p (singleton \\<theta>'))\n      \\<sigma>])", "have seq_valid:\"seq_valid (SG ! i)\""], ["proof (prove)\nusing this:\n  seq_valid\n   ([],\n    [Fsubst\n      ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n       $\\<phi> p (singleton \\<theta>'))\n      \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "using isNth"], ["proof (prove)\nusing this:\n  seq_valid\n   ([],\n    [Fsubst\n      ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n       $\\<phi> p (singleton \\<theta>'))\n      \\<sigma>])\n  SG ! i =\n  ([],\n   [Fsubst\n     ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n      $\\<phi> p (singleton \\<theta>'))\n     \\<sigma>])\n\ngoal (1 subgoal):\n 1. seq_valid (SG ! i)", "by auto"], ["proof (state)\nthis:\n  seq_valid (SG ! i)\n\ngoal (1 subgoal):\n 1. \\<And>SG i p \\<theta> \\<theta>' \\<sigma> C.\n       \\<lbrakk>SG ! i =\n                ([],\n                 [Fsubst\n                   ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n                    $\\<phi> p (singleton \\<theta>'))\n                   \\<sigma>]);\n        valid (Equals \\<theta> \\<theta>'); dsafe \\<theta>; dsafe \\<theta>';\n        ssafe \\<sigma>;\n        Fadmit \\<sigma>\n         ($\\<phi> p (singleton \\<theta>) \\<leftrightarrow>\n          $\\<phi> p (singleton \\<theta>'));\n        0 \\<le> i; i < length (fst (SG, C)); sound (SG, C)\\<rbrakk>\n       \\<Longrightarrow> sound\n                          (step_result (SG, C)\n                            (i, CQ \\<theta> \\<theta>' \\<sigma>))", "show \"sound (step_result (SG, C) (i, CQ \\<theta> \\<theta>' \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, CQ \\<theta> \\<theta>' \\<sigma>))", "using closeI_valid_sound[OF sound seq_valid]"], ["proof (prove)\nusing this:\n  sound (closeI SG i, C)\n\ngoal (1 subgoal):\n 1. sound (step_result (SG, C) (i, CQ \\<theta> \\<theta>' \\<sigma>))", "by simp"], ["proof (state)\nthis:\n  sound (step_result (SG, C) (i, CQ \\<theta> \\<theta>' \\<sigma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deriv_sound:\"deriv_ok R D \\<Longrightarrow> sound R \\<Longrightarrow> sound (deriv_result R D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deriv_ok R D; sound R\\<rbrakk>\n    \\<Longrightarrow> sound (deriv_result R D)", "apply(induction rule: deriv_ok.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R. sound R \\<Longrightarrow> sound (deriv_result R [])\n 2. \\<And>R i S SS.\n       \\<lbrakk>step_ok R i S; 0 \\<le> i; i < length (fst R);\n        deriv_ok (step_result R (i, S)) SS;\n        sound (step_result R (i, S)) \\<Longrightarrow>\n        sound (deriv_result (step_result R (i, S)) SS);\n        sound R\\<rbrakk>\n       \\<Longrightarrow> sound (deriv_result R ((i, S) # SS))", "using step_sound"], ["proof (prove)\nusing this:\n  \\<lbrakk>step_ok ?R ?i ?S; 0 \\<le> ?i; ?i < length (fst ?R);\n   sound ?R\\<rbrakk>\n  \\<Longrightarrow> sound (step_result ?R (?i, ?S))\n\ngoal (2 subgoals):\n 1. \\<And>R. sound R \\<Longrightarrow> sound (deriv_result R [])\n 2. \\<And>R i S SS.\n       \\<lbrakk>step_ok R i S; 0 \\<le> i; i < length (fst R);\n        deriv_ok (step_result R (i, S)) SS;\n        sound (step_result R (i, S)) \\<Longrightarrow>\n        sound (deriv_result (step_result R (i, S)) SS);\n        sound R\\<rbrakk>\n       \\<Longrightarrow> sound (deriv_result R ((i, S) # SS))", "by auto"], ["", "lemma proof_sound:\"proof_ok Pf \\<Longrightarrow> sound (proof_result Pf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok Pf \\<Longrightarrow> sound (proof_result Pf)", "apply(induct rule: proof_ok.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D S.\n       deriv_ok (start_proof D) S \\<Longrightarrow>\n       sound (proof_result (D, S))", "unfolding proof_result.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D S.\n       deriv_ok (start_proof D) S \\<Longrightarrow>\n       sound (deriv_result (start_proof D) S)", "apply(rule deriv_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D S.\n       deriv_ok (start_proof D) S \\<Longrightarrow>\n       deriv_ok (start_proof D) S\n 2. \\<And>D S.\n       deriv_ok (start_proof D) S \\<Longrightarrow> sound (start_proof D)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D S.\n       deriv_ok (start_proof D) S \\<Longrightarrow> sound (start_proof D)", "by(rule start_proof_sound)"], ["", "section \\<open>Example 1: Differential Invariants\\<close>"], ["", "definition DIAndConcl::\"('sf,'sc,'sz) sequent\"\nwhere \"DIAndConcl = ([], [Implies (And (Predicational pid1) (Predicational pid2)) \n       (Implies ([[Pvar vid1]](And (Predicational pid3) (Predicational pid4))) \n                ([[Pvar vid1]](And (Predicational pid1) (Predicational pid2))))])\""], ["", "definition DIAndSG1::\"('sf,'sc,'sz) formula\"\nwhere \"DIAndSG1 = (Implies (Predicational pid1) (Implies ([[Pvar vid1]](Predicational pid3)) ([[Pvar vid1]](Predicational pid1))))\""], ["", "definition DIAndSG2::\"('sf,'sc,'sz) formula\"\nwhere \"DIAndSG2 = (Implies (Predicational pid2) (Implies ([[Pvar vid1]](Predicational pid4)) ([[Pvar vid1]](Predicational pid2))))\""], ["", "definition DIAndCut::\"('sf,'sc,'sz) formula\"\nwhere \"DIAndCut = \n  (([[$\\<alpha> vid1]]((And (Predicational ( pid3)) (Predicational ( pid4)))) \\<rightarrow> (And (Predicational ( pid1)) (Predicational ( pid2))))\n    \\<rightarrow> ([[$\\<alpha> vid1]](And (Predicational ( pid3)) (Predicational ( pid4)))) \\<rightarrow> ([[$\\<alpha> vid1]](And (Predicational (pid1)) (Predicational ( pid2)))))\""], ["", "definition DIAndSubst::\"('sf,'sc,'sz) subst\"\nwhere \"DIAndSubst = \n  \\<lparr> SFunctions = (\\<lambda>_. None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. (if C = pid1 then Some(And (Predicational (Inl pid3)) (Predicational (Inl pid4))) \n                else (if C = pid2 then Some(And (Predicational (Inl pid1)) (Predicational (Inl pid2))) else None))),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\"\n  \n\\<comment> \\<open>\\<open>[a]R&H->R->[a]R&H->[a]R DIAndSubst34\\<close>\\<close>"], ["", "definition DIAndSubst341::\"('sf,'sc,'sz) subst\"\nwhere \"DIAndSubst341 = \n  \\<lparr> SFunctions = (\\<lambda>_. None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. (if C = pid1 then Some(And (Predicational (Inl pid3)) (Predicational (Inl pid4))) \n                else (if C = pid2 then Some(Predicational (Inl pid3)) else None))),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "definition DIAndSubst342::\"('sf,'sc,'sz) subst\"\nwhere \"DIAndSubst342 = \n  \\<lparr> SFunctions = (\\<lambda>_. None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. (if C = pid1 then Some(And (Predicational (Inl pid3)) (Predicational (Inl pid4))) \n                else (if C = pid2 then Some(Predicational (Inl pid4)) else None))),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\"\n  \n\\<comment> \\<open>\\<open>[a]P, [a]R&H, P, Q |- [a]Q->P&Q->[a]Q->[a]P&Q, [a]P&Q;;\\<close>\\<close>"], ["", "definition DIAndSubst12::\"('sf,'sc,'sz) subst\"\nwhere \"DIAndSubst12 = \n  \\<lparr> SFunctions = (\\<lambda>_. None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. (if C = pid1 then Some(Predicational (Inl pid2)) \n                else (if C = pid2 then Some(Predicational (Inl pid1) && Predicational (Inl pid2)) else None))),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\"\n\n\\<comment> \\<open>\\<open>P ->  Q->P&Q\\<close>\\<close>"], ["", "definition DIAndCurry12::\"('sf,'sc,'sz) subst\"\nwhere \"DIAndCurry12 = \n  \\<lparr> SFunctions = (\\<lambda>_. None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. (if C = pid1 then Some(Predicational (Inl pid1)) \n                else (if C = pid2 then Some(Predicational (Inl pid2) \\<rightarrow> (Predicational (Inl pid1) && Predicational (Inl pid2))) else None))),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "definition DIAnd :: \"('sf,'sc,'sz) rule\" \nwhere \"DIAnd = \n  ([([],[DIAndSG1]),([],[DIAndSG2])], \n  DIAndConcl)\""], ["", "definition DIAndCutP1 :: \"('sf,'sc,'sz) formula\"\nwhere \"DIAndCutP1 = ([[Pvar vid1]](Predicational pid1))\""], ["", "definition DIAndCutP2 :: \"('sf,'sc,'sz) formula\"\nwhere \"DIAndCutP2 = ([[Pvar vid1]](Predicational pid2))\""], ["", "definition DIAndCutP12 :: \"('sf,'sc,'sz) formula\"\nwhere \"DIAndCutP12 = (([[Pvar vid1]](Pc pid1) \\<rightarrow> (Pc pid2 \\<rightarrow> (And (Pc pid1) (Pc pid2))))\n  \\<rightarrow> (([[Pvar vid1]]Pc pid1) \\<rightarrow> ([[Pvar vid1]](Pc pid2 \\<rightarrow> (And (Pc pid1) (Pc pid2))))))\""], ["", "definition DIAndCut34Elim1 :: \"('sf,'sc,'sz) formula\"\nwhere \"DIAndCut34Elim1 = (([[Pvar vid1]](Pc pid3 && Pc pid4) \\<rightarrow> (Pc pid3))\n  \\<rightarrow> (([[Pvar vid1]](Pc pid3 && Pc pid4)) \\<rightarrow> ([[Pvar vid1]](Pc pid3))))\""], ["", "definition DIAndCut34Elim2 :: \"('sf,'sc,'sz) formula\"\nwhere \"DIAndCut34Elim2 = (([[Pvar vid1]](Pc pid3 && Pc pid4) \\<rightarrow> (Pc pid4))\n  \\<rightarrow> (([[Pvar vid1]](Pc pid3 && Pc pid4)) \\<rightarrow> ([[Pvar vid1]](Pc pid4))))\""], ["", "definition DIAndCut12Intro :: \"('sf,'sc,'sz) formula\"\nwhere \"DIAndCut12Intro = (([[Pvar vid1]](Pc pid2  \\<rightarrow> (Pc pid1 && Pc pid2)))\n  \\<rightarrow> (([[Pvar vid1]](Pc pid2)) \\<rightarrow> ([[Pvar vid1]](Pc pid1 && Pc pid2))))\""], ["", "definition DIAndProof :: \"('sf, 'sc, 'sz) pf\"\nwhere \"DIAndProof =\n  (DIAndConcl, [\n   (0, Rrule ImplyR 0)  \\<comment> \\<open>1\\<close>\n  ,(0, Lrule AndL 0)\n  ,(0, Rrule ImplyR 0)\n  ,(0, Cut DIAndCutP1)\n  ,(1, Cut DIAndSG1)\n  ,(0, Rrule CohideR 0)\n  ,(Suc (Suc 0), Lrule ImplyL 0)\n  ,(Suc (Suc (Suc 0)), CloseId 1 0)\n  ,(Suc (Suc 0), Lrule ImplyL 0)\n  ,(Suc (Suc 0), CloseId 0 0)\n  ,(Suc (Suc 0), Cut DIAndCut34Elim1) \\<comment> \\<open>11\\<close>\n  ,(0, Lrule ImplyL 0)\n  ,(Suc (Suc (Suc 0)), Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(0, Rrule CohideRR 0)\n  ,(Suc 0, Rrule CohideRR 0)\n  ,(Suc (Suc (Suc (Suc (Suc 0)))), G)  \n  ,(0, Rrule ImplyR 0)\n  ,(Suc (Suc (Suc (Suc (Suc 0)))), Lrule AndL 0)\n  ,(Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0)\n  ,(Suc (Suc (Suc 0)), AxSubst AK DIAndSubst341) \\<comment> \\<open>21\\<close>\n  ,(Suc (Suc 0), CloseId 0 0)\n  ,(Suc 0, CloseId 0 0)\n  ,(0, Cut DIAndCut12Intro)\n  ,(Suc 0, Rrule CohideRR 0)\n  ,(Suc (Suc 0), AxSubst AK DIAndSubst12)\n  ,(0, Lrule ImplyL 0)\n  ,(1, Lrule ImplyL 0)\n  ,(Suc (Suc 0), CloseId 0 0)\n  ,(Suc 0, Cut DIAndCutP12)\n  ,(0, Lrule ImplyL 0) \\<comment> \\<open>31\\<close>\n  ,(0, Rrule CohideRR 0)\n  ,(Suc (Suc (Suc (Suc 0))), AxSubst AK DIAndCurry12)\n  ,(Suc (Suc (Suc 0)), Rrule CohideRR 0)\n  ,(Suc (Suc 0), Lrule ImplyL 0)\n  ,(Suc (Suc 0), G)  \n  ,(0, Rrule ImplyR 0)  \n  ,(Suc (Suc (Suc (Suc 0))), Rrule ImplyR 0)  \n  ,(Suc (Suc (Suc (Suc 0))), Rrule AndR 0)  \n  ,(Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0)\n  ,(Suc (Suc (Suc (Suc 0))), CloseId 1 0) \\<comment> \\<open>41\\<close>\n  ,(Suc (Suc  0), CloseId 0 0)   \n  ,(Suc 0, Cut DIAndCut34Elim2)\n  ,(0, Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(Suc (Suc (Suc (Suc 0))), AxSubst AK DIAndSubst342) \\<comment> \\<open>46\\<close>\n  ,(Suc (Suc (Suc 0)), Rrule CohideRR 0)\n  ,(Suc (Suc (Suc 0)), G) \\<comment> \\<open>48\\<close>\n  ,(0, Rrule ImplyR 0)\n  ,(Suc (Suc (Suc 0)), Lrule AndL 0) \\<comment> \\<open>50\\<close>\n  ,(Suc (Suc (Suc 0)), CloseId 1 0)\n  ,(Suc (Suc 0), Lrule ImplyL 0)\n  ,(Suc 0, CloseId 0 0)\n  ,(1, Cut DIAndSG2)\n  ,(0, Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(Suc (Suc (Suc 0)), CloseId 4 0)\n  ,(Suc (Suc 0), Lrule ImplyL 0)\n  ,(Suc (Suc (Suc 0)), CloseId 0 0)\n  ,(Suc (Suc (Suc 0)), CloseId 0 0)\n  ,(1, CloseId 1 0)\n  ])\n  \""], ["", "fun proof_take :: \"nat \\<Rightarrow> ('sf,'sc,'sz) pf \\<Rightarrow> ('sf,'sc,'sz) pf\"\nwhere \"proof_take n (C,D) = (C,List.take n D)\""], ["", "fun last_step::\"('sf,'sc,'sz) pf \\<Rightarrow> nat \\<Rightarrow> nat * ('sf,'sc,'sz ) step\"\nwhere \"last_step (C,D) n = List.last (take n D)\""], ["", "lemma DIAndSound_lemma:\"sound (proof_result (proof_take 61 DIAndProof))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (proof_result (proof_take 61 DIAndProof))", "apply(rule proof_sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok (proof_take 61 DIAndProof)", "unfolding DIAndProof_def DIAndConcl_def  DIAndCutP1_def DIAndSG1_def DIAndCut34Elim1_def  DIAndSubst341_def DIAndCut12Intro_def DIAndSubst12_def\n    DIAndCutP12_def DIAndCurry12_def DIAndSubst342_def\n    DIAndCut34Elim2_def \\<comment> \\<open>43\\<close>\n    DIAndSG2_def \\<comment> \\<open>54\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok\n     (proof_take 61\n       (([],\n         [(Pc pid1 && Pc pid2) \\<rightarrow>\n          ([[$\\<alpha> vid1]]Pc pid3 && Pc pid4) \\<rightarrow>\n          [[$\\<alpha> vid1]]Pc pid1 && Pc pid2]),\n        [(0, Rrule ImplyR 0), (0, Lrule AndL 0), (0, Rrule ImplyR 0),\n         (0, Cut ([[$\\<alpha> vid1]]Pc pid1)),\n         (1, Cut (Pc pid1 \\<rightarrow>\n                  ([[$\\<alpha> vid1]]Pc pid3) \\<rightarrow>\n                  [[$\\<alpha> vid1]]Pc pid1)),\n         (0, Rrule CohideR 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc (Suc 0),\n          Cut (([[$\\<alpha>\n                   vid1]](Pc pid3 && Pc pid4) \\<rightarrow>\n                         Pc pid3) \\<rightarrow>\n               ([[$\\<alpha> vid1]]Pc pid3 && Pc pid4) \\<rightarrow>\n               [[$\\<alpha> vid1]]Pc pid3)),\n         (0, Lrule ImplyL 0), (Suc (Suc (Suc 0)), Lrule ImplyL 0),\n         (0, Rrule CohideRR 0), (0, Rrule CohideRR 0),\n         (Suc 0, Rrule CohideRR 0), (Suc (Suc (Suc (Suc (Suc 0)))), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc (Suc 0)))), Lrule AndL 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc 0)),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid3) && Pc (Inl pid4))\n                   else if C = pid2 then Some (Pc (Inl pid3)) else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (Suc (Suc 0), CloseId 0 0), (Suc 0, CloseId 0 0),\n         (0, Cut (([[$\\<alpha>\n                      vid1]]Pc pid2 \\<rightarrow>\n                            (Pc pid1 && Pc pid2)) \\<rightarrow>\n                  ([[$\\<alpha> vid1]]Pc pid2) \\<rightarrow>\n                  [[$\\<alpha> vid1]]Pc pid1 && Pc pid2)),\n         (Suc 0, Rrule CohideRR 0),\n         (Suc (Suc 0),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid2))\n                   else if C = pid2\n                        then Some (Pc (Inl pid1) && Pc (Inl pid2))\n                        else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (0, Lrule ImplyL 0), (1, Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (([[$\\<alpha>\n                   vid1]]Pc pid1 \\<rightarrow>\n                         Pc pid2 \\<rightarrow>\n                         (Pc pid1 && Pc pid2)) \\<rightarrow>\n               ([[$\\<alpha> vid1]]Pc pid1) \\<rightarrow>\n               [[$\\<alpha>\n                  vid1]]Pc pid2 \\<rightarrow> (Pc pid1 && Pc pid2))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid1))\n                   else if C = pid2\n                        then Some\n                              (Pc (Inl pid2) \\<rightarrow>\n                               (Pc (Inl pid1) && Pc (Inl pid2)))\n                        else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0),\n         (Suc (Suc 0), Lrule ImplyL 0), (Suc (Suc 0), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc 0))), Rrule ImplyR 0),\n         (Suc (Suc (Suc (Suc 0))), Rrule AndR 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc (Suc 0))), CloseId 1 0), (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (([[$\\<alpha>\n                   vid1]](Pc pid3 && Pc pid4) \\<rightarrow>\n                         Pc pid4) \\<rightarrow>\n               ([[$\\<alpha> vid1]]Pc pid3 && Pc pid4) \\<rightarrow>\n               [[$\\<alpha> vid1]]Pc pid4)),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid3) && Pc (Inl pid4))\n                   else if C = pid2 then Some (Pc (Inl pid4)) else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0), (Suc (Suc (Suc 0)), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc 0)), Lrule AndL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc 0, CloseId 0 0),\n         (1, Cut (Pc pid2 \\<rightarrow>\n                  ([[$\\<alpha> vid1]]Pc pid4) \\<rightarrow>\n                  [[$\\<alpha> vid1]]Pc pid2)),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc 0)), CloseId 4 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 0 0), (Suc (Suc (Suc 0)), CloseId 0 0),\n         (1, CloseId 1 0)]))", "(* slow *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok\n     (proof_take 61\n       (([],\n         [(Pc pid1 && Pc pid2) \\<rightarrow>\n          ([[$\\<alpha> vid1]]Pc pid3 && Pc pid4) \\<rightarrow>\n          [[$\\<alpha> vid1]]Pc pid1 && Pc pid2]),\n        [(0, Rrule ImplyR 0), (0, Lrule AndL 0), (0, Rrule ImplyR 0),\n         (0, Cut ([[$\\<alpha> vid1]]Pc pid1)),\n         (1, Cut (Pc pid1 \\<rightarrow>\n                  ([[$\\<alpha> vid1]]Pc pid3) \\<rightarrow>\n                  [[$\\<alpha> vid1]]Pc pid1)),\n         (0, Rrule CohideR 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc (Suc 0),\n          Cut (([[$\\<alpha>\n                   vid1]](Pc pid3 && Pc pid4) \\<rightarrow>\n                         Pc pid3) \\<rightarrow>\n               ([[$\\<alpha> vid1]]Pc pid3 && Pc pid4) \\<rightarrow>\n               [[$\\<alpha> vid1]]Pc pid3)),\n         (0, Lrule ImplyL 0), (Suc (Suc (Suc 0)), Lrule ImplyL 0),\n         (0, Rrule CohideRR 0), (0, Rrule CohideRR 0),\n         (Suc 0, Rrule CohideRR 0), (Suc (Suc (Suc (Suc (Suc 0)))), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc (Suc 0)))), Lrule AndL 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc 0)),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid3) && Pc (Inl pid4))\n                   else if C = pid2 then Some (Pc (Inl pid3)) else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (Suc (Suc 0), CloseId 0 0), (Suc 0, CloseId 0 0),\n         (0, Cut (([[$\\<alpha>\n                      vid1]]Pc pid2 \\<rightarrow>\n                            (Pc pid1 && Pc pid2)) \\<rightarrow>\n                  ([[$\\<alpha> vid1]]Pc pid2) \\<rightarrow>\n                  [[$\\<alpha> vid1]]Pc pid1 && Pc pid2)),\n         (Suc 0, Rrule CohideRR 0),\n         (Suc (Suc 0),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid2))\n                   else if C = pid2\n                        then Some (Pc (Inl pid1) && Pc (Inl pid2))\n                        else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (0, Lrule ImplyL 0), (1, Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (([[$\\<alpha>\n                   vid1]]Pc pid1 \\<rightarrow>\n                         Pc pid2 \\<rightarrow>\n                         (Pc pid1 && Pc pid2)) \\<rightarrow>\n               ([[$\\<alpha> vid1]]Pc pid1) \\<rightarrow>\n               [[$\\<alpha>\n                  vid1]]Pc pid2 \\<rightarrow> (Pc pid1 && Pc pid2))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid1))\n                   else if C = pid2\n                        then Some\n                              (Pc (Inl pid2) \\<rightarrow>\n                               (Pc (Inl pid1) && Pc (Inl pid2)))\n                        else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0),\n         (Suc (Suc 0), Lrule ImplyL 0), (Suc (Suc 0), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc 0))), Rrule ImplyR 0),\n         (Suc (Suc (Suc (Suc 0))), Rrule AndR 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc (Suc 0))), CloseId 1 0), (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (([[$\\<alpha>\n                   vid1]](Pc pid3 && Pc pid4) \\<rightarrow>\n                         Pc pid4) \\<rightarrow>\n               ([[$\\<alpha> vid1]]Pc pid3 && Pc pid4) \\<rightarrow>\n               [[$\\<alpha> vid1]]Pc pid4)),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))),\n          AxSubst AK\n           \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n              SContexts =\n                \\<lambda>C.\n                   if C = pid1 then Some (Pc (Inl pid3) && Pc (Inl pid4))\n                   else if C = pid2 then Some (Pc (Inl pid4)) else None,\n              SPrograms = Map.empty, SODEs = Map.empty\\<rparr>),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0), (Suc (Suc (Suc 0)), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc 0)), Lrule AndL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc 0, CloseId 0 0),\n         (1, Cut (Pc pid2 \\<rightarrow>\n                  ([[$\\<alpha> vid1]]Pc pid4) \\<rightarrow>\n                  [[$\\<alpha> vid1]]Pc pid2)),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc 0)), CloseId 4 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 0 0), (Suc (Suc (Suc 0)), CloseId 0 0),\n         (1, CloseId 1 0)]))", "apply (auto simp add: prover)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Example 2: Concrete Hybrid System\\<close>\n\n\\<comment> \\<open>\\<open>v \\<ge> 0 \\<and> A() \\<ge> 0 \\<longrightarrow> [v' = A, x' = v]v' \\<ge> 0\\<close>\\<close>"], ["", "definition SystemConcl::\"('sf,'sc,'sz) sequent\"\nwhere \"SystemConcl = \n  ([],[\n  Implies (And (Geq (Var vid1) (Const 0)) (Geq (f0 fid1) (Const 0)))\n  ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (TT)]]Geq (Var vid1) (Const 0))\n  ])\""], ["", "definition SystemDICut :: \"('sf,'sc,'sz) formula\"\nwhere \"SystemDICut =\n  Implies\n  (Implies TT ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]]\n     (Geq (Differential (Var vid1)) (Differential (Const 0)))))\n  (Implies\n     (Implies TT (Geq (Var vid1) (Const 0)))\n     ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]](Geq (Var vid1) (Const 0))))\""], ["", "(*\n    (Implies (Geq (Var vid1) (Const 0)) \n      (Implies (And TT ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]]\n                  (Geq (Differential (Var vid1)) (Differential (Const 0)))\n   )) ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]](Geq (Var vid1) (Const 0)))))\"\n*)"], ["", "definition SystemDCCut::\"('sf,'sc,'sz) formula\"\nwhere \"SystemDCCut =\n(([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]](Geq (f0 fid1) (Const 0))) \\<rightarrow>\n   (([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]]((Geq (Differential (Var vid1)) (Differential (Const 0))))) \n   \\<leftrightarrow>  \n   ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]](Geq (Differential (Var vid1)) (Differential (Const 0))))))\""], ["", "definition SystemVCut::\"('sf,'sc,'sz) formula\"\nwhere \"SystemVCut = \n  Implies (Geq (f0 fid1) (Const 0)) ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]](Geq (f0 fid1) (Const 0)))\""], ["", "definition SystemVCut2::\"('sf,'sc,'sz) formula\"\nwhere \"SystemVCut2 = \n  Implies (Geq (f0 fid1) (Const 0)) ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]](Geq (f0 fid1) (Const 0)))\""], ["", "definition SystemDECut::\"('sf,'sc,'sz) formula\"\nwhere \"SystemDECut = (([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]] ((Geq (Differential (Var vid1)) (Differential (Const 0))))) \\<leftrightarrow>\n ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]]\n    [[DiffAssign vid1 (f0 fid1)]](Geq (Differential (Var vid1)) (Differential (Const 0)))))\""], ["", "definition SystemKCut::\"('sf,'sc,'sz) formula\"\nwhere \"SystemKCut =\n  (Implies ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]]\n                (Implies ((And TT (Geq (f0 fid1) (Const 0)))) ([[DiffAssign vid1 (f0 fid1)]](Geq (Differential (Var vid1)) (Differential (Const 0))))))\n      (Implies ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]] ((And TT (Geq (f0 fid1) (Const 0)))))\n               ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]] ([[DiffAssign vid1 (f0 fid1)]](Geq (Differential (Var vid1)) (Differential (Const 0)))))))\""], ["", "definition SystemEquivCut::\"('sf,'sc,'sz) formula\"\nwhere \"SystemEquivCut =\n  (Equiv (Implies ((And TT (Geq (f0 fid1) (Const 0)))) ([[DiffAssign vid1 (f0 fid1)]](Geq (Differential (Var vid1)) (Differential (Const 0)))))\n         (Implies ((And TT (Geq (f0 fid1) (Const 0)))) ([[DiffAssign vid1 (f0 fid1)]](Geq (DiffVar vid1) (Const 0)))))\""], ["", "definition SystemDiffAssignCut::\"('sf,'sc,'sz) formula\"\nwhere \"SystemDiffAssignCut =\n  (([[DiffAssign vid1  ($f fid1 empty)]] (Geq (DiffVar vid1) (Const 0)))\n\\<leftrightarrow> (Geq ($f fid1 empty) (Const 0)))\""], ["", "definition SystemCEFml1::\"('sf,'sc,'sz) formula\"\nwhere \"SystemCEFml1 = Geq (Differential (Var vid1)) (Differential (Const 0))\""], ["", "definition SystemCEFml2::\"('sf,'sc,'sz) formula\"\nwhere \"SystemCEFml2 = Geq (DiffVar vid1) (Const 0)\""], ["", "(*\ndefinition diff_const_axiom :: \"('sf, 'sc, 'sz) formula\"\n  where [axiom_defs]:\"diff_const_axiom \\<equiv> Equals (Differential ($f fid1 empty)) (Const 0)\"\n\ndefinition diff_var_axiom :: \"('sf, 'sc, 'sz) formula\"\n  where [axiom_defs]:\"diff_var_axiom \\<equiv> Equals (Differential (Var vid1)) (DiffVar vid1)\"*)"], ["", "definition CQ1Concl::\"('sf,'sc,'sz) formula\"\nwhere \"CQ1Concl = (Geq (Differential (Var vid1)) (Differential (Const 0)) \\<leftrightarrow> Geq (DiffVar vid1) (Differential (Const 0)))\""], ["", "definition CQ2Concl::\"('sf,'sc,'sz) formula\"\nwhere \"CQ2Concl = (Geq (DiffVar vid1) (Differential (Const 0)) \\<leftrightarrow> Geq ($' vid1) (Const 0))\""], ["", "definition CEReq::\"('sf,'sc,'sz) formula\"\nwhere \"CEReq = (Geq (Differential (trm.Var vid1)) (Differential (Const 0)) \\<leftrightarrow> Geq ($' vid1) (Const 0))\""], ["", "definition CQRightSubst::\"('sf,'sc,'sz) subst\"\nwhere \"CQRightSubst = \n  \\<lparr> SFunctions = (\\<lambda>_. None),\n    SPredicates = (\\<lambda>p. (if p = vid1 then (Some (Geq (DiffVar vid1) (Function  (Inr vid1)  empty))) else None)),\n    SContexts = (\\<lambda>_. None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "definition CQLeftSubst::\"('sf,'sc,'sz) subst\"\nwhere \"CQLeftSubst = \n  \\<lparr> SFunctions = (\\<lambda>_. None),\n    SPredicates = (\\<lambda>p. (if p = vid1 then (Some (Geq  (Function  (Inr vid1)  empty) (Differential (Const 0)))) else None)),\n    SContexts = (\\<lambda>_. None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "definition CEProof::\"('sf,'sc,'sz) pf\"\nwhere \"CEProof = (([],[CEReq]), [\n  (0, Cut CQ1Concl)\n ,(0, Cut CQ2Concl)\n ,(1, Rrule CohideRR 0)\n ,(Suc (Suc 0), CQ (Differential (Const 0)) (Const 0) CQRightSubst)\n ,(1, Rrule CohideRR 0)\n ,(1, CQ (Differential (Var vid1)) (DiffVar vid1) CQLeftSubst)\n ,(0, Rrule EquivR 0)\n ,(0, Lrule EquivForwardL 1)\n ,(Suc (Suc 0), Lrule EquivForwardL 1)\n ,(Suc (Suc (Suc 0)), CloseId 0 0)\n ,(Suc (Suc 0), CloseId 0 0)\n ,(Suc 0, CloseId 0 0)\n ,(0, Lrule EquivBackwardL (Suc (Suc 0)))\n ,(0, CloseId 0 0)\n ,(0, Lrule EquivBackwardL (Suc 0))\n ,(0, CloseId 0 0)\n ,(0, CloseId 0 0)\n ])\""], ["", "lemma CE_result_correct:\"proof_result CEProof = ([],([],[CEReq]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_result CEProof = ([], [], [CEReq])", "unfolding CEProof_def CEReq_def CQ1Concl_def  CQ2Concl_def Implies_def Or_def f0_def TT_def Equiv_def Box_def CQRightSubst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_result\n     (([],\n       [! (! (Geq (Differential (Var vid1)) (Differential (Const 0)) &&\n              Geq ($' vid1) (Const 0)) &&\n           ! (! (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n              ! (Geq ($' vid1) (Const 0))))]),\n      [(0, Cut (! (! (Geq (Differential (Var vid1))\n                       (Differential (Const 0)) &&\n                      Geq ($' vid1) (Differential (Const 0))) &&\n                   ! (! (Geq (Differential (Var vid1))\n                          (Differential (Const 0))) &&\n                      ! (Geq ($' vid1) (Differential (Const 0))))))),\n       (0, Cut (! (! (Geq ($' vid1) (Differential (Const 0)) &&\n                      Geq ($' vid1) (Const 0)) &&\n                   ! (! (Geq ($' vid1) (Differential (Const 0))) &&\n                      ! (Geq ($' vid1) (Const 0)))))),\n       (1, Rrule CohideRR 0),\n       (Suc (Suc 0),\n        CQ (Differential (Const 0)) (Const 0)\n         \\<lparr>SFunctions = Map.empty,\n            SPredicates =\n              \\<lambda>p.\n                 if p = vid1\n                 then Some (Geq ($' vid1) ($f (Inr vid1) local.empty))\n                 else None,\n            SContexts = Map.empty, SPrograms = Map.empty,\n            SODEs = Map.empty\\<rparr>),\n       (1, Rrule CohideRR 0),\n       (1, CQ (Differential (Var vid1)) ($' vid1) CQLeftSubst),\n       (0, Rrule EquivR 0), (0, Lrule EquivForwardL 1),\n       (Suc (Suc 0), Lrule EquivForwardL 1),\n       (Suc (Suc (Suc 0)), CloseId 0 0), (Suc (Suc 0), CloseId 0 0),\n       (Suc 0, CloseId 0 0), (0, Lrule EquivBackwardL (Suc (Suc 0))),\n       (0, CloseId 0 0), (0, Lrule EquivBackwardL (Suc 0)),\n       (0, CloseId 0 0), (0, CloseId 0 0)]) =\n    ([], [],\n     [! (! (Geq (Differential (Var vid1)) (Differential (Const 0)) &&\n            Geq ($' vid1) (Const 0)) &&\n         ! (! (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n            ! (Geq ($' vid1) (Const 0))))])", "by (auto simp add: id_simps)"], ["", "definition DiffConstSubst::\"('sf,'sc,'sz) subst\"\nwhere \"DiffConstSubst = \\<lparr>\n    SFunctions = (\\<lambda>f. (if f = fid1 then (Some (Const 0)) else None)),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>_. None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "definition DiffConstProof::\"('sf,'sc,'sz) pf\"\nwhere \"DiffConstProof = (([],[(Equals (Differential (Const 0)) (Const 0))]), [\n  (0, AxSubst AdConst DiffConstSubst)])\""], ["", "lemma diffconst_result_correct:\"proof_result DiffConstProof = ([], ([],[Equals (Differential (Const 0)) (Const 0)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_result DiffConstProof =\n    ([], [], [Equals (Differential (Const 0)) (Const 0)])", "by(auto simp add: prover DiffConstProof_def)"], ["", "lemma diffconst_sound_lemma:\"sound (proof_result DiffConstProof)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (proof_result DiffConstProof)", "apply(rule proof_sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok DiffConstProof", "unfolding DiffConstProof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok\n     (([], [Equals (Differential (Const 0)) (Const 0)]),\n      [(0, AxSubst AdConst DiffConstSubst)])", "by (auto simp add: prover DiffConstProof_def DiffConstSubst_def Equals_def empty_def TUadmit_def)"], ["", "lemma valid_of_sound:\"sound ([], ([],[\\<phi>])) \\<Longrightarrow> valid \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([], [], [\\<phi>]) \\<Longrightarrow> valid \\<phi>", "unfolding valid_def sound_def TT_def FF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I.\n       is_interp I \\<longrightarrow>\n       (\\<forall>i\\<ge>0.\n           i < length (fst ([], [], [\\<phi>])) \\<longrightarrow>\n           seq_sem I (fst ([], [], [\\<phi>]) ! i) = UNIV) \\<longrightarrow>\n       seq_sem I (snd ([], [], [\\<phi>])) = UNIV \\<Longrightarrow>\n    \\<forall>I \\<nu>.\n       is_interp I \\<longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "apply (auto simp add: TT_def FF_def Or_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I a b.\n       \\<lbrakk>\\<forall>I.\n                   is_interp I \\<longrightarrow>\n                   fml_sem I\n                    (Geq (Const 0) (Const 0) \\<rightarrow>\n                     ! (! \\<phi> && ! (Geq (Const 0) (Const 1)))) =\n                   UNIV;\n        is_interp I\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> fml_sem I \\<phi>", "subgoal for I a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I.\n                is_interp I \\<longrightarrow>\n                fml_sem I\n                 (Geq (Const 0) (Const 0) \\<rightarrow>\n                  ! (! \\<phi> && ! (Geq (Const 0) (Const 1)))) =\n                UNIV;\n     is_interp I\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> fml_sem I \\<phi>", "apply(erule allE[where x=I])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interp I;\n     is_interp I \\<longrightarrow>\n     fml_sem I\n      (Geq (Const 0) (Const 0) \\<rightarrow>\n       ! (! \\<phi> && ! (Geq (Const 0) (Const 1)))) =\n     UNIV\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> fml_sem I \\<phi>", "by(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma almost_diff_const_sound:\"sound ([], ([], [Equals (Differential (Const 0)) (Const 0)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([], [], [Equals (Differential (Const 0)) (Const 0)])", "using diffconst_result_correct diffconst_sound_lemma"], ["proof (prove)\nusing this:\n  proof_result DiffConstProof =\n  ([], [], [Equals (Differential (Const 0)) (Const 0)])\n  sound (proof_result DiffConstProof)\n\ngoal (1 subgoal):\n 1. sound ([], [], [Equals (Differential (Const 0)) (Const 0)])", "by simp"], ["", "lemma almost_diff_const:\"valid (Equals (Differential (Const 0)) (Const 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Equals (Differential (Const 0)) (Const 0))", "using almost_diff_const_sound valid_of_sound"], ["proof (prove)\nusing this:\n  sound ([], [], [Equals (Differential (Const 0)) (Const 0)])\n  sound ([], [], [?\\<phi>]) \\<Longrightarrow> valid ?\\<phi>\n\ngoal (1 subgoal):\n 1. valid (Equals (Differential (Const 0)) (Const 0))", "by auto\n\n\\<comment> \\<open>Note: this is just unpacking the definition: the axiom is defined as literally this formula\\<close>"], ["", "lemma almost_diff_var:\"valid (Equals (Differential (trm.Var vid1)) ($' vid1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Equals (Differential (Var vid1)) ($' vid1))", "using diff_var_axiom_valid"], ["proof (prove)\nusing this:\n  valid diff_var_axiom\n\ngoal (1 subgoal):\n 1. valid (Equals (Differential (Var vid1)) ($' vid1))", "unfolding diff_var_axiom_def"], ["proof (prove)\nusing this:\n  valid (Equals (Differential (Var vid1)) ($' vid1))\n\ngoal (1 subgoal):\n 1. valid (Equals (Differential (Var vid1)) ($' vid1))", "by auto"], ["", "lemma CESound_lemma:\"sound (proof_result CEProof)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (proof_result CEProof)", "apply(rule proof_sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok CEProof", "unfolding CEProof_def CEReq_def CQ1Concl_def CQ2Concl_def Equiv_def CQRightSubst_def diff_const_axiom_valid diff_var_axiom_valid empty_def Or_def expand_singleton \n  diff_var_axiom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok\n     (([],\n       [! (! (Geq (Differential (Var vid1)) (Differential (Const 0)) &&\n              Geq ($' vid1) (Const 0)) &&\n           ! (! (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n              ! (Geq ($' vid1) (Const 0))))]),\n      [(0, Cut (! (! (Geq (Differential (Var vid1))\n                       (Differential (Const 0)) &&\n                      Geq ($' vid1) (Differential (Const 0))) &&\n                   ! (! (Geq (Differential (Var vid1))\n                          (Differential (Const 0))) &&\n                      ! (Geq ($' vid1) (Differential (Const 0))))))),\n       (0, Cut (! (! (Geq ($' vid1) (Differential (Const 0)) &&\n                      Geq ($' vid1) (Const 0)) &&\n                   ! (! (Geq ($' vid1) (Differential (Const 0))) &&\n                      ! (Geq ($' vid1) (Const 0)))))),\n       (1, Rrule CohideRR 0),\n       (Suc (Suc 0),\n        CQ (Differential (Const 0)) (Const 0)\n         \\<lparr>SFunctions = Map.empty,\n            SPredicates =\n              \\<lambda>p.\n                 if p = vid1\n                 then Some\n                       (Geq ($' vid1) ($f (Inr vid1) (\\<lambda>i. Const 0)))\n                 else None,\n            SContexts = Map.empty, SPrograms = Map.empty,\n            SODEs = Map.empty\\<rparr>),\n       (1, Rrule CohideRR 0),\n       (1, CQ (Differential (Var vid1)) ($' vid1) CQLeftSubst),\n       (0, Rrule EquivR 0), (0, Lrule EquivForwardL 1),\n       (Suc (Suc 0), Lrule EquivForwardL 1),\n       (Suc (Suc (Suc 0)), CloseId 0 0), (Suc (Suc 0), CloseId 0 0),\n       (Suc 0, CloseId 0 0), (0, Lrule EquivBackwardL (Suc (Suc 0))),\n       (0, CloseId 0 0), (0, Lrule EquivBackwardL (Suc 0)),\n       (0, CloseId 0 0), (0, CloseId 0 0)])", "by (auto simp add: prover CEProof_def CEReq_def CQ1Concl_def CQ2Concl_def Equiv_def\n    CQRightSubst_def diff_const_axiom_valid diff_var_axiom_valid empty_def Or_def expand_singleton \n    TUadmit_def NTUadmit_def almost_diff_const CQLeftSubst_def almost_diff_var)"], ["", "lemma sound_to_valid:\"sound ([], ([], [\\<phi>])) \\<Longrightarrow> valid \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([], [], [\\<phi>]) \\<Longrightarrow> valid \\<phi>", "unfolding  valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([], [], [\\<phi>]) \\<Longrightarrow>\n    \\<forall>I \\<nu>.\n       is_interp I \\<longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I a b.\n       \\<lbrakk>sound ([], [], [\\<phi>]); is_interp I\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> fml_sem I \\<phi>", "apply(drule soundD_mem)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I a b. is_interp I \\<Longrightarrow> is_interp (?I7 I a b)\n 2. \\<And>I a b \\<phi>.\n       \\<lbrakk>is_interp I; List.member [] \\<phi>\\<rbrakk>\n       \\<Longrightarrow> seq_sem (?I7 I a b) \\<phi> = UNIV\n 3. \\<And>I a b.\n       \\<lbrakk>is_interp I;\n        seq_sem (?I7 I a b) ([], [\\<phi>]) = UNIV\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> fml_sem I \\<phi>", "by (auto simp add: member_rec(2))"], ["", "lemma CE1pre:\"sound ([], ([], [CEReq]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([], [], [CEReq])", "using CE_result_correct CESound_lemma"], ["proof (prove)\nusing this:\n  proof_result CEProof = ([], [], [CEReq])\n  sound (proof_result CEProof)\n\ngoal (1 subgoal):\n 1. sound ([], [], [CEReq])", "by simp"], ["", "lemma CE1pre_valid:\"valid CEReq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid CEReq", "by (rule sound_to_valid[OF CE1pre])"], ["", "lemma CE1pre_valid2:\"valid (! (! (Geq (Differential (trm.Var vid1)) (Differential (Const 0)) && Geq ($' vid1) (Const 0)) &&\n              ! (! (Geq (Differential (trm.Var vid1)) (Differential (Const 0))) && ! (Geq ($' vid1) (Const 0))))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (! (! (Geq (Differential (Var vid1)) (Differential (Const 0)) &&\n            Geq ($' vid1) (Const 0)) &&\n         ! (! (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n            ! (Geq ($' vid1) (Const 0)))))", "using CE1pre_valid"], ["proof (prove)\nusing this:\n  valid CEReq\n\ngoal (1 subgoal):\n 1. valid\n     (! (! (Geq (Differential (Var vid1)) (Differential (Const 0)) &&\n            Geq ($' vid1) (Const 0)) &&\n         ! (! (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n            ! (Geq ($' vid1) (Const 0)))))", "unfolding CEReq_def Equiv_def Or_def"], ["proof (prove)\nusing this:\n  valid\n   (! (! (Geq (Differential (Var vid1)) (Differential (Const 0)) &&\n          Geq ($' vid1) (Const 0)) &&\n       ! (! (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n          ! (Geq ($' vid1) (Const 0)))))\n\ngoal (1 subgoal):\n 1. valid\n     (! (! (Geq (Differential (Var vid1)) (Differential (Const 0)) &&\n            Geq ($' vid1) (Const 0)) &&\n         ! (! (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n            ! (Geq ($' vid1) (Const 0)))))", "by auto"], ["", "definition SystemDISubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemDISubst = \n  \\<lparr> SFunctions = (\\<lambda>f. \n    (     if f = fid1 then Some(Function (Inr vid1) empty)\n     else if f = fid2 then Some(Const 0)\n     else None)),\n    SPredicates = (\\<lambda>p. if p = vid1 then Some TT else None),\n    SContexts = (\\<lambda>_. None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>c. if c = vid1 then Some (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (trm.Var vid1))) else None)\n  \\<rparr>\""], ["", "(*\n  Implies \n  (Implies (Prop vid1 empty) ([[EvolveODE (OVar vid1) (Prop vid1 empty)]](Geq (Differential (f1 fid1 vid1)) (Differential (f1 fid2 vid1)))))\n  (Implies\n     (Implies(Prop vid1 empty) (Geq (f1 fid1 vid1) (f1 fid2 vid1)))\n     ([[EvolveODE (OVar vid1) (Prop vid1 empty)]](Geq (f1 fid1 vid1) (f1 fid2 vid1))))\"\n*)\n(*\nImplies\n  (Implies TT ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]]\n     (Geq (Differential (Var vid1)) (Differential (Const 0)))))\n  (Implies\n     (Implies TT (Geq (Var vid1) (Const 0)))\n     ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) TT]](Geq (Var vid1) (Const 0))))\n*)"], ["", "definition SystemDCSubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemDCSubst = \n  \\<lparr> SFunctions = (\\<lambda>\n  f.  None),\n    SPredicates = (\\<lambda>p.  None),\n    SContexts = (\\<lambda>C. \n    if C = pid1 then\n      Some TT\n    else if C = pid2 then\n      Some (Geq (Differential (Var vid1)) (Differential (Const 0)))\n    else if C = pid3 then\n      Some (Geq (Function fid1 empty) (Const 0)) \n    else \n     None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>c. if c = vid1 then Some (OProd (OSing vid1 (Function fid1 empty)) (OSing vid2 (trm.Var vid1))) else None)\n  \\<rparr>\""], ["", "definition SystemVSubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemVSubst = \n  \\<lparr> SFunctions = (\\<lambda>f.  None),\n    SPredicates = (\\<lambda>p. if p = vid1 then Some (Geq (Function (Inl fid1) empty) (Const 0)) else None),\n    SContexts = (\\<lambda>_. None),\n    SPrograms = (\\<lambda>a. if a = vid1 then \n      Some (EvolveODE (OProd \n                         (OSing vid1 (Function fid1 empty)) \n                         (OSing vid2 (Var vid1))) \n                      (And TT (Geq (Function fid1 empty) (Const 0)))) \n                      else None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "definition SystemVSubst2::\"('sf,'sc,'sz) subst\"\nwhere \"SystemVSubst2 = \n  \\<lparr> SFunctions = (\\<lambda>f.  None),\n    SPredicates = (\\<lambda>p. if p = vid1 then Some (Geq (Function (Inl fid1) empty) (Const 0)) else None),\n    SContexts = (\\<lambda>_. None),\n    SPrograms = (\\<lambda>a. if a = vid1 then \n      Some (EvolveODE (OProd \n                         (OSing vid1 (Function fid1 empty)) \n                         (OSing vid2 (Var vid1))) \n                      TT) \n                      else None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "definition SystemDESubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemDESubst = \n  \\<lparr> SFunctions = (\\<lambda>f. if f = fid1 then Some(Function (Inl fid1) empty) else None),\n    SPredicates = (\\<lambda>p. if p = vid2 then Some(And TT (Geq (Function (Inl fid1) empty) (Const 0))) else None),\n    SContexts = (\\<lambda>C. if C = pid1 then Some(Geq (Differential (Var vid1)) (Differential (Const 0))) else None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "lemma systemdesubst_correct:\"\\<exists> ODE.(([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]] ((Geq (Differential (Var vid1)) (Differential (Const 0))))) \\<leftrightarrow>\n ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (And TT (Geq (f0 fid1) (Const 0)))]]\n    [[DiffAssign vid1 (f0 fid1)]](Geq (Differential (Var vid1)) (Differential (Const 0)))))\n    = Fsubst ((([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE) (p1 vid2 vid1)]] (P pid1)) \\<leftrightarrow>\n          ([[EvolveODE ((OProd  (OSing vid1 (f1 fid1 vid1))) ODE) (p1 vid2 vid1)]]\n               [[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))) SystemDESubst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ODE.\n       ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n           (TT &&\n            Geq (f0 fid1)\n             (Const\n               0))]]Geq (Differential (Var vid1))\n                     (Differential (Const 0)) \\<leftrightarrow>\n        ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n            (TT &&\n             Geq (f0 fid1)\n              (Const\n                0))]][[DiffAssign vid1\n                        (f0 fid1)]]Geq (Differential (Var vid1))\n                                    (Differential (Const 0)))) =\n       Fsubst\n        ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n            (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n         ([[EvolveODE (OProd (OSing vid1 (f1 fid1 vid1)) ODE)\n             (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n        SystemDESubst", "apply(rule exI[where x=\"OSing vid2 (trm.Var vid1)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n        (TT &&\n         Geq (f0 fid1)\n          (Const\n            0))]]Geq (Differential (Var vid1))\n                  (Differential (Const 0)) \\<leftrightarrow>\n     ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n         (TT &&\n          Geq (f0 fid1)\n           (Const\n             0))]][[DiffAssign vid1\n                     (f0 fid1)]]Geq (Differential (Var vid1))\n                                 (Differential (Const 0)))) =\n    Fsubst\n     ([[EvolveODE\n         (OProd (OSing vid1 (f1 fid1 vid1)) (OSing vid2 (Var vid1)))\n         (p1 vid2 vid1)]]P pid1 \\<leftrightarrow>\n      ([[EvolveODE\n          (OProd (OSing vid1 (f1 fid1 vid1)) (OSing vid2 (Var vid1)))\n          (p1 vid2 vid1)]][[DiffAssign vid1 (f1 fid1 vid1)]]P pid1))\n     SystemDESubst", "by(auto simp add: f0_def f1_def Box_def Or_def Equiv_def empty_def TT_def P_def p1_def SystemDESubst_def empty_def)\n  \n\\<comment> \\<open>\\<open>[{dx=, dy=x&r>=r&>=r}]r>=r&>=r->[D{x}:=]D{x}>=D{r}->\\<close>\\<close>\n\\<comment> \\<open>\\<open>[{dx=, dy=x&r>=r&>=r}]r>=r&>=r->\\<close>\\<close>\n\\<comment> \\<open>\\<open>[{dx=, dy=x&r>=r&>=r}][D{x}:=]D{x}>=D{r}\\<close>\\<close>\n\\<comment> \\<open>\\<open>([[$\\<alpha> vid1]]((Predicational pid1) \\<rightarrow> (Predicational pid2)))\\<close>\\<close>\n\\<comment> \\<open>\\<open>\\<rightarrow> ([[$\\<alpha> vid1]]Predicational pid1) \\<rightarrow> ([[$\\<alpha> vid1]]Predicational pid2)\\<close>\\<close>"], ["", "definition SystemKSubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemKSubst = \\<lparr> SFunctions = (\\<lambda>f.  None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. if C = pid1 then \n        (Some (And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0)))) \n      else if C = pid2 then \n        (Some ([[DiffAssign vid1 (Function fid1 empty)]](Geq (Differential (Var vid1)) (Differential (Const 0))))) else None),\n    SPrograms = (\\<lambda>c. if c = vid1 then Some (EvolveODE (OProd (OSing vid1 (Function fid1 empty)) (OSing vid2 (Var vid1))) (And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0)))) else None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "lemma subst_imp_simp:\"Fsubst (Implies p q) \\<sigma> = (Implies (Fsubst p \\<sigma>) (Fsubst q \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fsubst (p \\<rightarrow> q) \\<sigma> =\n    (Fsubst p \\<sigma> \\<rightarrow> Fsubst q \\<sigma>)", "unfolding Implies_def Or_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fsubst (! (! q && ! (! p))) \\<sigma> =\n    ! (! (Fsubst q \\<sigma>) && ! (! (Fsubst p \\<sigma>)))", "by auto"], ["", "lemma subst_equiv_simp:\"Fsubst (Equiv p q) \\<sigma> = (Equiv (Fsubst p \\<sigma>) (Fsubst q \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fsubst (p \\<leftrightarrow> q) \\<sigma> =\n    (Fsubst p \\<sigma> \\<leftrightarrow> Fsubst q \\<sigma>)", "unfolding Implies_def Or_def Equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fsubst (! (! (p && q) && ! (! p && ! q))) \\<sigma> =\n    ! (! (Fsubst p \\<sigma> && Fsubst q \\<sigma>) &&\n       ! (! (Fsubst p \\<sigma>) && ! (Fsubst q \\<sigma>)))", "by auto"], ["", "lemma subst_box_simp:\"Fsubst (Box p q) \\<sigma> = (Box (Psubst p \\<sigma>) (Fsubst q \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fsubst ([[p]]q) \\<sigma> = ([[Psubst p \\<sigma>]]Fsubst q \\<sigma>)", "unfolding Box_def Or_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fsubst (! (\\<langle> p \\<rangle> ! q)) \\<sigma> =\n    ! (\\<langle> Psubst p \\<sigma> \\<rangle> ! (Fsubst q \\<sigma>))", "by auto"], ["", "lemma pfsubst_box_simp:\"PFsubst (Box p q) \\<sigma> = (Box (PPsubst p \\<sigma>) (PFsubst q \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PFsubst ([[p]]q) \\<sigma> = ([[PPsubst p \\<sigma>]]PFsubst q \\<sigma>)", "unfolding Box_def Or_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. PFsubst (! (\\<langle> p \\<rangle> ! q)) \\<sigma> =\n    ! (\\<langle> PPsubst p \\<sigma> \\<rangle> ! (PFsubst q \\<sigma>))", "by auto"], ["", "lemma pfsubst_imp_simp:\"PFsubst (Implies p q) \\<sigma> = (Implies (PFsubst p \\<sigma>) (PFsubst q \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PFsubst (p \\<rightarrow> q) \\<sigma> =\n    (PFsubst p \\<sigma> \\<rightarrow> PFsubst q \\<sigma>)", "unfolding Box_def Implies_def Or_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. PFsubst (! (! q && ! (! p))) \\<sigma> =\n    ! (! (PFsubst q \\<sigma>) && ! (! (PFsubst p \\<sigma>)))", "by auto"], ["", "definition SystemDWSubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemDWSubst = \\<lparr> SFunctions = (\\<lambda>f.  None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. if C = pid1 then Some (And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0))) else None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>c. if c = vid1 then Some (OProd (OSing vid1 (Function fid1 empty)) (OSing vid2 (Var vid1))) else None)\n  \\<rparr>\""], ["", "definition SystemCESubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemCESubst = \\<lparr> SFunctions = (\\<lambda>f.  None),\n    SPredicates = (\\<lambda>_. None),\n    SContexts = (\\<lambda>C. if C = pid1 then Some(Implies(And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0))) ([[DiffAssign vid1 (Function fid1 empty)]](Predicational (Inr ())))) else None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "lemma SystemCESubstOK:\n  \"step_ok \n  ([([],[Equiv (Implies(And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0))) ([[DiffAssign vid1 (Function fid1 empty)]]( SystemCEFml1))) \n         (Implies(And (Geq (Const 0) (Const 0)) (Geq (Function fid1 empty) (Const 0))) ([[DiffAssign vid1 (Function fid1 empty)]]( (SystemCEFml2))))\n         ])],\n         ([],[]))\n         \n         0 \n         (CE SystemCEFml1 SystemCEFml2 SystemCESubst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step_ok\n     ([([],\n        [(Geq (Const 0) (Const 0) &&\n          Geq ($f fid1 local.empty) (Const 0)) \\<rightarrow>\n         [[DiffAssign vid1\n            ($f fid1 local.empty)]]SystemCEFml1 \\<leftrightarrow>\n         ((Geq (Const 0) (Const 0) &&\n           Geq ($f fid1 local.empty) (Const 0)) \\<rightarrow>\n          [[DiffAssign vid1 ($f fid1 local.empty)]]SystemCEFml2)])],\n      [], [])\n     0 (CE SystemCEFml1 SystemCEFml2 SystemCESubst)", "apply(rule Step_CE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. [([],\n      [(Geq (Const 0) (Const 0) &&\n        Geq ($f fid1 local.empty) (Const 0)) \\<rightarrow>\n       [[DiffAssign vid1\n          ($f fid1 local.empty)]]SystemCEFml1 \\<leftrightarrow>\n       ((Geq (Const 0) (Const 0) &&\n         Geq ($f fid1 local.empty) (Const 0)) \\<rightarrow>\n        [[DiffAssign vid1 ($f fid1 local.empty)]]SystemCEFml2)])] !\n    0 =\n    ([],\n     [Fsubst\n       (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n        InContext pid1 SystemCEFml2)\n       SystemCESubst])\n 2. valid (SystemCEFml1 \\<leftrightarrow> SystemCEFml2)\n 3. fsafe SystemCEFml1\n 4. fsafe SystemCEFml2\n 5. ssafe SystemCESubst\n 6. Fadmit SystemCESubst\n     (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n      InContext pid1 SystemCEFml2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [([],\n      [(Geq (Const 0) (Const 0) &&\n        Geq ($f fid1 local.empty) (Const 0)) \\<rightarrow>\n       [[DiffAssign vid1\n          ($f fid1 local.empty)]]SystemCEFml1 \\<leftrightarrow>\n       ((Geq (Const 0) (Const 0) &&\n         Geq ($f fid1 local.empty) (Const 0)) \\<rightarrow>\n        [[DiffAssign vid1 ($f fid1 local.empty)]]SystemCEFml2)])] !\n    0 =\n    ([],\n     [Fsubst\n       (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n        InContext pid1 SystemCEFml2)\n       SystemCESubst])", "by(auto simp add: subst_equiv_simp subst_imp_simp subst_box_simp SystemCESubst_def SystemCEFml1_def SystemCEFml2_def pfsubst_imp_simp pfsubst_box_simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. valid (SystemCEFml1 \\<leftrightarrow> SystemCEFml2)\n 2. fsafe SystemCEFml1\n 3. fsafe SystemCEFml2\n 4. ssafe SystemCESubst\n 5. Fadmit SystemCESubst\n     (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n      InContext pid1 SystemCEFml2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (SystemCEFml1 \\<leftrightarrow> SystemCEFml2)", "using CE1pre_valid"], ["proof (prove)\nusing this:\n  valid CEReq\n\ngoal (1 subgoal):\n 1. valid (SystemCEFml1 \\<leftrightarrow> SystemCEFml2)", "by (auto simp add: CEReq_def SystemCEFml1_def SystemCEFml2_def CE1pre_valid)"], ["proof (prove)\ngoal (4 subgoals):\n 1. fsafe SystemCEFml1\n 2. fsafe SystemCEFml2\n 3. ssafe SystemCESubst\n 4. Fadmit SystemCESubst\n     (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n      InContext pid1 SystemCEFml2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsafe SystemCEFml1", "unfolding SystemCEFml1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsafe (Geq (Differential (Var vid1)) (Differential (Const 0)))", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. fsafe SystemCEFml2\n 2. ssafe SystemCESubst\n 3. Fadmit SystemCESubst\n     (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n      InContext pid1 SystemCEFml2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsafe SystemCEFml2", "unfolding SystemCEFml2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsafe (Geq ($' vid1) (Const 0))", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. ssafe SystemCESubst\n 2. Fadmit SystemCESubst\n     (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n      InContext pid1 SystemCEFml2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ssafe SystemCESubst", "unfolding SystemCESubst_def ssafe_def Implies_def Box_def Or_def empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i f'.\n        SFunctions\n         \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n            SContexts =\n              \\<lambda>C.\n                 if C = pid1\n                 then Some\n                       (! (! (! (\\<langle> DiffAssign vid1\n      ($f fid1 (\\<lambda>i. Const 0)) \\<rangle> ! (Pc (Inr ())))) &&\n                           ! (! (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 (\\<lambda>i. Const 0))\n                                  (Const 0)))))\n                 else None,\n            SPrograms = Map.empty, SODEs = Map.empty\\<rparr>\n         i =\n        Some f' \\<longrightarrow>\n        dfree f') \\<and>\n    (\\<forall>f f'.\n        SPredicates\n         \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n            SContexts =\n              \\<lambda>C.\n                 if C = pid1\n                 then Some\n                       (! (! (! (\\<langle> DiffAssign vid1\n      ($f fid1 (\\<lambda>i. Const 0)) \\<rangle> ! (Pc (Inr ())))) &&\n                           ! (! (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 (\\<lambda>i. Const 0))\n                                  (Const 0)))))\n                 else None,\n            SPrograms = Map.empty, SODEs = Map.empty\\<rparr>\n         f =\n        Some f' \\<longrightarrow>\n        fsafe f') \\<and>\n    (\\<forall>f f'.\n        SPrograms\n         \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n            SContexts =\n              \\<lambda>C.\n                 if C = pid1\n                 then Some\n                       (! (! (! (\\<langle> DiffAssign vid1\n      ($f fid1 (\\<lambda>i. Const 0)) \\<rangle> ! (Pc (Inr ())))) &&\n                           ! (! (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 (\\<lambda>i. Const 0))\n                                  (Const 0)))))\n                 else None,\n            SPrograms = Map.empty, SODEs = Map.empty\\<rparr>\n         f =\n        Some f' \\<longrightarrow>\n        hpsafe f') \\<and>\n    (\\<forall>f f'.\n        SODEs\n         \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n            SContexts =\n              \\<lambda>C.\n                 if C = pid1\n                 then Some\n                       (! (! (! (\\<langle> DiffAssign vid1\n      ($f fid1 (\\<lambda>i. Const 0)) \\<rangle> ! (Pc (Inr ())))) &&\n                           ! (! (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 (\\<lambda>i. Const 0))\n                                  (Const 0)))))\n                 else None,\n            SPrograms = Map.empty, SODEs = Map.empty\\<rparr>\n         f =\n        Some f' \\<longrightarrow>\n        osafe f') \\<and>\n    (\\<forall>C C'.\n        SContexts\n         \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n            SContexts =\n              \\<lambda>C.\n                 if C = pid1\n                 then Some\n                       (! (! (! (\\<langle> DiffAssign vid1\n      ($f fid1 (\\<lambda>i. Const 0)) \\<rangle> ! (Pc (Inr ())))) &&\n                           ! (! (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 (\\<lambda>i. Const 0))\n                                  (Const 0)))))\n                 else None,\n            SPrograms = Map.empty, SODEs = Map.empty\\<rparr>\n         C =\n        Some C' \\<longrightarrow>\n        fsafe C')", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fadmit SystemCESubst\n     (InContext pid1 SystemCEFml1 \\<leftrightarrow>\n      InContext pid1 SystemCEFml2)", "unfolding SystemCESubst_def Equiv_def Or_def SystemCEFml1_def SystemCEFml2_def TUadmit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fadmit\n     \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n        SContexts =\n          \\<lambda>C.\n             if C = pid1\n             then Some\n                   ((Geq (Const 0) (Const 0) &&\n                     Geq ($f fid1 local.empty) (Const 0)) \\<rightarrow>\n                    [[DiffAssign vid1 ($f fid1 local.empty)]]Pc (Inr ()))\n             else None,\n        SPrograms = Map.empty, SODEs = Map.empty\\<rparr>\n     (! (! (InContext pid1\n             (Geq (Differential (Var vid1)) (Differential (Const 0))) &&\n            InContext pid1 (Geq ($' vid1) (Const 0))) &&\n         ! (! (InContext pid1\n                (Geq (Differential (Var vid1)) (Differential (Const 0)))) &&\n            ! (InContext pid1 (Geq ($' vid1) (Const 0))))))", "apply (auto simp add: TUadmit_def FUadmit_def Box_def Implies_def Or_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. PFUadmit\n     (\\<lambda>_. Geq (Differential (Var vid1)) (Differential (Const 0)))\n     (Geq (Const 0) (Const 0)) UNIV\n 2. PFUadmit\n     (\\<lambda>_. Geq (Differential (Var vid1)) (Differential (Const 0)))\n     (! (InContext (Inr ()) (Geq (Const 0) (Const 0)))) {Inr vid1}\n 3. PFUadmit (\\<lambda>_. Geq ($' vid1) (Const 0)) (Geq (Const 0) (Const 0))\n     UNIV\n 4. PFUadmit (\\<lambda>_. Geq ($' vid1) (Const 0))\n     (! (InContext (Inr ()) (Geq (Const 0) (Const 0)))) {Inr vid1}", "unfolding PFUadmit_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. True\n 2. True\n 3. True\n 4. True", "by auto\n  \n\\<comment> \\<open>\\<open>[D{x}:=f]Dv{x}>=r<->f>=r\\<close>\\<close>\n\\<comment> \\<open>\\<open>[[DiffAssign vid1  ($f fid1 empty)]] (Prop vid1 (singleton (DiffVar vid1))))\\<close>\\<close>\n\\<comment> \\<open>\\<open>\\<leftrightarrow> Prop vid1 (singleton ($f fid1 empty))\\<close>\\<close>"], ["", "definition SystemDiffAssignSubst::\"('sf,'sc,'sz) subst\"\nwhere \"SystemDiffAssignSubst = \\<lparr> SFunctions = (\\<lambda>f.  None),\n    SPredicates = (\\<lambda>p. if p = vid1 then Some (Geq (Function (Inr vid1) empty) (Const 0)) else None),\n    SContexts = (\\<lambda>_. None),\n    SPrograms = (\\<lambda>_. None),\n    SODEs = (\\<lambda>_. None)\n  \\<rparr>\""], ["", "lemma SystemDICutCorrect:\"SystemDICut = Fsubst DIGeqaxiom SystemDISubst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SystemDICut = Fsubst DIGeqaxiom SystemDISubst", "unfolding SystemDICut_def DIGeqaxiom_def SystemDISubst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((TT \\<rightarrow>\n      [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n         TT]]Geq (Differential (Var vid1))\n              (Differential (Const 0))) \\<rightarrow>\n     (TT \\<rightarrow> Geq (Var vid1) (Const 0)) \\<rightarrow>\n     [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n        TT]]Geq (Var vid1) (Const 0)) =\n    Fsubst\n     (($\\<phi> vid1 local.empty \\<rightarrow>\n       [[EvolveODE (OVar vid1)\n          ($\\<phi> vid1\n            local.empty)]]Geq (Differential (f1 fid1 vid1))\n                           (Differential (f1 fid2 vid1))) \\<rightarrow>\n      ($\\<phi> vid1 local.empty \\<rightarrow>\n       Geq (f1 fid1 vid1) (f1 fid2 vid1)) \\<rightarrow>\n      [[EvolveODE (OVar vid1)\n         ($\\<phi> vid1 local.empty)]]Geq (f1 fid1 vid1) (f1 fid2 vid1))\n     \\<lparr>SFunctions =\n               \\<lambda>f.\n                  if f = fid1 then Some ($f (Inr vid1) local.empty)\n                  else if f = fid2 then Some (Const 0) else None,\n        SPredicates = \\<lambda>p. if p = vid1 then Some TT else None,\n        SContexts = Map.empty, SPrograms = Map.empty,\n        SODEs =\n          \\<lambda>c.\n             if c = vid1\n             then Some\n                   (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n             else None\\<rparr>", "by (auto simp add: f1_def p1_def f0_def Implies_def Or_def id_simps TT_def Box_def empty_def)\n\n\\<comment> \\<open>\\<open>v\\<ge>0 \\<and> A()\\<ge>0 \\<rightarrow> [{x'=v, v'=A()}]v\\<ge>0\\<close>\\<close>"], ["", "definition SystemProof :: \"('sf, 'sc, 'sz) pf\"\nwhere \"SystemProof =\n  (SystemConcl, [\n  (0, Rrule ImplyR 0)\n  ,(0, Lrule AndL 0)\n  ,(0, Cut SystemDICut)\n  ,(0, Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(0, Lrule ImplyL 0)\n  ,(Suc (Suc 0), CloseId 0 0)\n  ,(Suc 0, AxSubst ADIGeq SystemDISubst) \\<comment> \\<open>8\\<close>\n  ,(Suc 0, Rrule ImplyR 0)\n  \\<^cancel>\\<open>,(0, CloseId 0 0)\\<close>\n  ,(Suc 0, CloseId 1 0)        \n  \\<^cancel>\\<open>,(0, Rrule AndR 0)\\<close>\n  ,(0, Rrule ImplyR 0)   \n  ,(0, Cut SystemDCCut)\n  ,(0, Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(0, Lrule EquivBackwardL 0)\n  ,(0, Rrule CohideR 0)\n  ,(0, AxSubst ADC SystemDCSubst) \\<comment> \\<open>17\\<close>\n  ,(0, CloseId 0 0)\n  ,(0, Rrule CohideRR 0)\n  ,(0, Cut SystemVCut)\n  ,(0, Lrule ImplyL 0) \n  ,(0, Rrule CohideRR 0)\n  ,(0, Cut SystemDECut)\n  ,(0, Lrule EquivBackwardL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(1, CloseId (Suc 1) 0) \\<comment> \\<open>Last step\\<close>\n  ,(Suc 1, CloseId 0 0)\n  ,(1, AxSubst AV SystemVSubst) \\<comment> \\<open>28\\<close>\n  ,(0, Cut SystemVCut2)\n  \n  ,(0, Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(Suc 1, CloseId 0 0)\n  ,(Suc 1, CloseId (Suc 2) 0)\n  \n  ,(Suc 1, AxSubst AV SystemVSubst2) \\<comment> \\<open>34\\<close>\n  ,(0, Rrule CohideRR 0)\n  ,(0, DEAxiomSchema (OSing vid2 (trm.Var vid1)) SystemDESubst) \\<comment> \\<open>36\\<close>\n  ,(0, Cut SystemKCut)\n  ,(0, Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(0, Lrule ImplyL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(0, AxSubst AK SystemKSubst) \\<comment> \\<open>42\\<close>\n  ,(0, CloseId 0 0)\n  ,(0, Rrule CohideR 0)\n  ,(1, AxSubst ADW SystemDWSubst) \\<comment> \\<open>45\\<close>\n  ,(0, G)\n  ,(0, Cut SystemEquivCut)\n  ,(0, Lrule EquivBackwardL 0)\n  ,(0, Rrule CohideR 0)\n  ,(0, CloseId 0 0)\n  ,(0, Rrule CohideR 0)\n  ,(0, CE SystemCEFml1 SystemCEFml2 SystemCESubst) \\<comment> \\<open>52\\<close>\n  ,(0, Rrule ImplyR 0)\n  ,(0, Lrule AndL 0)\n  ,(0, Cut SystemDiffAssignCut) \n  ,(0, Lrule EquivBackwardL 0)\n  ,(0, Rrule CohideRR 0)\n  ,(0, CloseId 0 0)\n  ,(0, CloseId 1 0)\n  ,(0, AxSubst Adassign SystemDiffAssignSubst) \\<comment> \\<open>60\\<close>\n  ])\""], ["", "lemma system_result_correct:\"proof_result SystemProof = \n  ([],\n  ([],[Implies (And (Geq (Var vid1) (Const 0)) (Geq (f0 fid1) (Const 0)))\n        ([[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1))) (TT)]]Geq (Var vid1) (Const 0))]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_result SystemProof =\n    ([], [],\n     [(Geq (Var vid1) (Const 0) && Geq (f0 fid1) (Const 0)) \\<rightarrow>\n      [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n         TT]]Geq (Var vid1) (Const 0)])", "unfolding SystemProof_def SystemConcl_def Implies_def Or_def f0_def TT_def Equiv_def SystemDICut_def SystemDCCut_def\n  proof_result.simps deriv_result.simps start_proof.simps  Box_def SystemDCSubst_def SystemVCut_def SystemDECut_def SystemKCut_def SystemEquivCut_def\n  SystemDiffAssignCut_def SystemVCut2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. step_result\n     (step_result\n       (step_result\n         (step_result\n           (step_result\n             (step_result\n               (step_result\n                 (step_result\n                   (step_result\n                     (step_result\n                       (step_result\n                         (step_result\n                           (step_result\n                             (step_result\n                               (step_result\n                                 (step_result\n                                   (step_result\n                                     (step_result\n (step_result\n   (step_result\n     (step_result\n       (step_result\n         (step_result\n           (step_result\n             (step_result\n               (step_result\n                 (step_result\n                   (step_result\n                     (step_result\n                       (step_result\n                         (step_result\n                           (step_result\n                             (step_result\n                               (step_result\n                                 (step_result\n                                   (step_result\n                                     (step_result\n (step_result\n   (step_result\n     (step_result\n       (step_result\n         (step_result\n           (step_result\n             (step_result\n               (step_result\n                 (step_result\n                   (step_result\n                     (step_result\n                       (step_result\n                         (step_result\n                           (step_result\n                             (step_result\n                               (step_result\n                                 (step_result\n                                   (step_result\n                                     (step_result\n (step_result\n   (step_result\n     (step_result\n       (step_result\n         ([([],\n            [! (! (! (\\<langle> EvolveODE\n                                 (OProd (OSing vid1 ($f fid1 local.empty))\n                                   (OSing vid2 (Var vid1)))\n                                 (Geq (Const 0)\n                                   (Const\n                                     0)) \\<rangle> !\n              (Geq (Var vid1) (Const 0)))) &&\n                ! (! (Geq (Var vid1) (Const 0) &&\n                      Geq ($f fid1 local.empty) (Const 0))))])],\n          [],\n          [! (! (! (\\<langle> EvolveODE\n                               (OProd (OSing vid1 ($f fid1 local.empty))\n                                 (OSing vid2 (Var vid1)))\n                               (Geq (Const 0)\n                                 (Const\n                                   0)) \\<rangle> !\n            (Geq (Var vid1) (Const 0)))) &&\n              ! (! (Geq (Var vid1) (Const 0) &&\n                    Geq ($f fid1 local.empty) (Const 0))))])\n         (0, Rrule ImplyR 0))\n       (0, Lrule AndL 0))\n     (0, Cut (! (! (! (! (! (\\<langle> EvolveODE\n  (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n  (Geq (Const 0) (Const 0)) \\<rangle> ! (Geq (Var vid1) (Const 0)))) &&\n                       ! (! (! (! (Geq (Var vid1) (Const 0)) &&\n                                ! (! (Geq (Const 0) (Const 0)))))))) &&\n                 ! (! (! (! (! (\\<langle> EvolveODE\n     (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n     (Geq (Const 0)\n       (Const\n         0)) \\<rangle> ! (Geq (Differential (Var vid1))\n                           (Differential (Const 0))))) &&\n                          ! (! (Geq (Const 0) (Const 0))))))))))\n   (0, Lrule ImplyL 0))\n (0, Rrule CohideRR 0))\n                                     (0, Lrule ImplyL 0))\n                                   (Suc (Suc 0), CloseId 0 0))\n                                 (Suc 0, AxSubst ADIGeq SystemDISubst))\n                               (Suc 0, Rrule ImplyR 0))\n                             (Suc 0, CloseId 1 0))\n                           (0, Rrule ImplyR 0))\n                         (0, Cut (! (!\n(! (! (! (\\<langle> EvolveODE\n                     (OProd (OSing vid1 ($f fid1 local.empty))\n                       (OSing vid2 (Var vid1)))\n                     (Geq (Const 0)\n                       (Const\n                         0)) \\<rangle> !\n  (Geq (Differential (Var vid1)) (Differential (Const 0)))) &&\n       ! (\\<langle> EvolveODE\n                     (OProd (OSing vid1 ($f fid1 local.empty))\n                       (OSing vid2 (Var vid1)))\n                     (Geq (Const 0) (Const 0) &&\n                      Geq ($f fid1 local.empty)\n                       (Const\n                         0)) \\<rangle> !\n  (Geq (Differential (Var vid1)) (Differential (Const 0))))) &&\n    ! (! (! (\\<langle> EvolveODE\n                        (OProd (OSing vid1 ($f fid1 local.empty))\n                          (OSing vid2 (Var vid1)))\n                        (Geq (Const 0)\n                          (Const\n                            0)) \\<rangle> !\n     (Geq (Differential (Var vid1)) (Differential (Const 0))))) &&\n       ! (! (\\<langle> EvolveODE\n                        (OProd (OSing vid1 ($f fid1 local.empty))\n                          (OSing vid2 (Var vid1)))\n                        (Geq (Const 0) (Const 0) &&\n                         Geq ($f fid1 local.empty)\n                          (Const\n                            0)) \\<rangle> !\n     (Geq (Differential (Var vid1)) (Differential (Const 0)))))))) &&\n                                     !\n(! (! (\\<langle> EvolveODE\n                  (OProd (OSing vid1 ($f fid1 local.empty))\n                    (OSing vid2 (Var vid1)))\n                  (Geq (Const 0)\n                    (Const\n                      0)) \\<rangle> ! (Geq ($f fid1 local.empty)\n  (Const 0)))))))))\n                       (0, Lrule ImplyL 0))\n                     (0, Rrule CohideRR 0))\n                   (0, Lrule EquivBackwardL 0))\n                 (0, Rrule CohideR 0))\n               (0, AxSubst ADC\n                    \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n                       SContexts =\n                         \\<lambda>C.\n                            if C = pid1 then Some (Geq (Const 0) (Const 0))\n                            else if C = pid2\n                                 then Some\n (Geq (Differential (Var vid1)) (Differential (Const 0)))\n                                 else if C = pid3\nthen Some (Geq ($f fid1 local.empty) (Const 0)) else None,\n                       SPrograms = Map.empty,\n                       SODEs =\n                         \\<lambda>c.\n                            if c = vid1\n                            then Some\n                                  (OProd (OSing vid1 ($f fid1 local.empty))\n                                    (OSing vid2 (Var vid1)))\n                            else None\\<rparr>))\n             (0, CloseId 0 0))\n           (0, Rrule CohideRR 0))\n         (0, Cut (! (! (! (\\<langle> EvolveODE\n(OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n(Geq (Const 0) (Const 0) &&\n Geq ($f fid1 local.empty)\n  (Const 0)) \\<rangle> ! (Geq ($f fid1 local.empty) (Const 0)))) &&\n                     ! (! (Geq ($f fid1 local.empty) (Const 0)))))))\n       (0, Lrule ImplyL 0))\n     (0, Rrule CohideRR 0))\n   (0, Cut (! (! (! (\\<langle> EvolveODE\n                                (OProd (OSing vid1 ($f fid1 local.empty))\n                                  (OSing vid2 (Var vid1)))\n                                (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 local.empty)\n                                  (Const\n                                    0)) \\<rangle> !\n             (Geq (Differential (Var vid1)) (Differential (Const 0)))) &&\n                  ! (\\<langle> EvolveODE\n                                (OProd (OSing vid1 ($f fid1 local.empty))\n                                  (OSing vid2 (Var vid1)))\n                                (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 local.empty)\n                                  (Const\n                                    0)) \\<rangle> !\n             (! (\\<langle> DiffAssign vid1\n                            ($f fid1\n                              local.empty) \\<rangle> !\n                (Geq (Differential (Var vid1))\n                  (Differential (Const 0))))))) &&\n               ! (! (! (\\<langle> EvolveODE\n                                   (OProd (OSing vid1 ($f fid1 local.empty))\n                                     (OSing vid2 (Var vid1)))\n                                   (Geq (Const 0) (Const 0) &&\n                                    Geq ($f fid1 local.empty)\n                                     (Const\n 0)) \\<rangle> ! (Geq (Differential (Var vid1))\n                   (Differential (Const 0))))) &&\n                  ! (! (\\<langle> EvolveODE\n                                   (OProd (OSing vid1 ($f fid1 local.empty))\n                                     (OSing vid2 (Var vid1)))\n                                   (Geq (Const 0) (Const 0) &&\n                                    Geq ($f fid1 local.empty)\n                                     (Const\n 0)) \\<rangle> ! (! (\\<langle> DiffAssign vid1\n                                ($f fid1\n                                  local.empty) \\<rangle> !\n                    (Geq (Differential (Var vid1))\n                      (Differential (Const 0))))))))))))\n (0, Lrule EquivBackwardL 0))\n                                     (0, Rrule CohideRR 0))\n                                   (1, CloseId (Suc 1) 0))\n                                 (Suc 1, CloseId 0 0))\n                               (1, AxSubst AV SystemVSubst))\n                             (0, Cut (!\n (! (! (\\<langle> EvolveODE\n                   (OProd (OSing vid1 ($f fid1 local.empty))\n                     (OSing vid2 (Var vid1)))\n                   (Geq (Const 0)\n                     (Const\n                       0)) \\<rangle> !\n(Geq ($f fid1 local.empty) (Const 0)))) &&\n  ! (! (Geq ($f fid1 local.empty) (Const 0)))))))\n                           (0, Lrule ImplyL 0))\n                         (0, Rrule CohideRR 0))\n                       (Suc 1, CloseId 0 0))\n                     (Suc 1, CloseId (Suc 2) 0))\n                   (Suc 1, AxSubst AV SystemVSubst2))\n                 (0, Rrule CohideRR 0))\n               (0, DEAxiomSchema (OSing vid2 (Var vid1)) SystemDESubst))\n             (0, Cut (! (! (! (! (! (\\<langle> EvolveODE\n          (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n          (Geq (Const 0) (Const 0) &&\n           Geq ($f fid1 local.empty)\n            (Const\n              0)) \\<rangle> ! (! (\\<langle> DiffAssign vid1\n       ($f fid1\n         local.empty) \\<rangle> ! (Geq (Differential (Var vid1))\n                                    (Differential (Const 0))))))) &&\n                               ! (! (!\n(\\<langle> EvolveODE\n            (OProd (OSing vid1 ($f fid1 local.empty))\n              (OSing vid2 (Var vid1)))\n            (Geq (Const 0) (Const 0) &&\n             Geq ($f fid1 local.empty)\n              (Const\n                0)) \\<rangle> ! (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 local.empty)\n                                  (Const 0))))))) &&\n                         ! (! (! (\\<langle> EvolveODE\n       (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n       (Geq (Const 0) (Const 0) &&\n        Geq ($f fid1 local.empty)\n         (Const\n           0)) \\<rangle> ! (! (! (! (\\<langle> DiffAssign vid1\n          ($f fid1\n            local.empty) \\<rangle> ! (Geq (Differential (Var vid1))\n (Differential (Const 0))))) &&\n                               ! (! (Geq (Const 0) (Const 0) &&\n                                     Geq ($f fid1 local.empty)\n(Const 0))))))))))))\n           (0, Lrule ImplyL 0))\n         (0, Rrule CohideRR 0))\n       (0, Lrule ImplyL 0))\n     (0, Rrule CohideRR 0))\n   (0, AxSubst AK SystemKSubst))\n (0, CloseId 0 0))\n                                     (0, Rrule CohideR 0))\n                                   (1, AxSubst ADW SystemDWSubst))\n                                 (0, G))\n                               (0, Cut (!\n   (! (! (! (! (\\<langle> DiffAssign vid1\n                           ($f fid1\n                             local.empty) \\<rangle> !\n               (Geq (Differential (Var vid1)) (Differential (Const 0))))) &&\n          ! (! (Geq (Const 0) (Const 0) &&\n                Geq ($f fid1 local.empty) (Const 0)))) &&\n       ! (! (! (\\<langle> DiffAssign vid1\n                           ($f fid1\n                             local.empty) \\<rangle> !\n               (Geq ($' vid1) (Const 0)))) &&\n          ! (! (Geq (Const 0) (Const 0) &&\n                Geq ($f fid1 local.empty) (Const 0))))) &&\n    ! (! (! (! (! (\\<langle> DiffAssign vid1\n                              ($f fid1\n                                local.empty) \\<rangle> !\n                  (Geq (Differential (Var vid1))\n                    (Differential (Const 0))))) &&\n             ! (! (Geq (Const 0) (Const 0) &&\n                   Geq ($f fid1 local.empty) (Const 0))))) &&\n       ! (! (! (! (\\<langle> DiffAssign vid1\n                              ($f fid1\n                                local.empty) \\<rangle> !\n                  (Geq ($' vid1) (Const 0)))) &&\n             ! (! (Geq (Const 0) (Const 0) &&\n                   Geq ($f fid1 local.empty) (Const 0))))))))))\n                             (0, Lrule EquivBackwardL 0))\n                           (0, Rrule CohideR 0))\n                         (0, CloseId 0 0))\n                       (0, Rrule CohideR 0))\n                     (0, CE SystemCEFml1 SystemCEFml2 SystemCESubst))\n                   (0, Rrule ImplyR 0))\n                 (0, Lrule AndL 0))\n               (0, Cut (! (! (! (\\<langle> DiffAssign vid1\n      ($f fid1 local.empty) \\<rangle> ! (Geq ($' vid1) (Const 0))) &&\n                              Geq ($f fid1 local.empty) (Const 0)) &&\n                           ! (! (! (\\<langle> DiffAssign vid1\n         ($f fid1 local.empty) \\<rangle> ! (Geq ($' vid1) (Const 0)))) &&\n                              ! (Geq ($f fid1 local.empty) (Const 0)))))))\n             (0, Lrule EquivBackwardL 0))\n           (0, Rrule CohideRR 0))\n         (0, CloseId 0 0))\n       (0, CloseId 1 0))\n     (0, AxSubst Adassign SystemDiffAssignSubst) =\n    ([], [],\n     [! (! (! (\\<langle> EvolveODE\n                          (OProd (OSing vid1 ($f fid1 local.empty))\n                            (OSing vid2 (Var vid1)))\n                          (Geq (Const 0)\n                            (Const\n                              0)) \\<rangle> !\n       (Geq (Var vid1) (Const 0)))) &&\n         ! (! (Geq (Var vid1) (Const 0) &&\n               Geq ($f fid1 local.empty) (Const 0))))])", "(* slow *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. step_result\n     (step_result\n       (step_result\n         (step_result\n           (step_result\n             (step_result\n               (step_result\n                 (step_result\n                   (step_result\n                     (step_result\n                       (step_result\n                         (step_result\n                           (step_result\n                             (step_result\n                               (step_result\n                                 (step_result\n                                   (step_result\n                                     (step_result\n (step_result\n   (step_result\n     (step_result\n       (step_result\n         (step_result\n           (step_result\n             (step_result\n               (step_result\n                 (step_result\n                   (step_result\n                     (step_result\n                       (step_result\n                         (step_result\n                           (step_result\n                             (step_result\n                               (step_result\n                                 (step_result\n                                   (step_result\n                                     (step_result\n (step_result\n   (step_result\n     (step_result\n       (step_result\n         (step_result\n           (step_result\n             (step_result\n               (step_result\n                 (step_result\n                   (step_result\n                     (step_result\n                       (step_result\n                         (step_result\n                           (step_result\n                             (step_result\n                               (step_result\n                                 (step_result\n                                   (step_result\n                                     (step_result\n (step_result\n   (step_result\n     (step_result\n       (step_result\n         ([([],\n            [! (! (! (\\<langle> EvolveODE\n                                 (OProd (OSing vid1 ($f fid1 local.empty))\n                                   (OSing vid2 (Var vid1)))\n                                 (Geq (Const 0)\n                                   (Const\n                                     0)) \\<rangle> !\n              (Geq (Var vid1) (Const 0)))) &&\n                ! (! (Geq (Var vid1) (Const 0) &&\n                      Geq ($f fid1 local.empty) (Const 0))))])],\n          [],\n          [! (! (! (\\<langle> EvolveODE\n                               (OProd (OSing vid1 ($f fid1 local.empty))\n                                 (OSing vid2 (Var vid1)))\n                               (Geq (Const 0)\n                                 (Const\n                                   0)) \\<rangle> !\n            (Geq (Var vid1) (Const 0)))) &&\n              ! (! (Geq (Var vid1) (Const 0) &&\n                    Geq ($f fid1 local.empty) (Const 0))))])\n         (0, Rrule ImplyR 0))\n       (0, Lrule AndL 0))\n     (0, Cut (! (! (! (! (! (\\<langle> EvolveODE\n  (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n  (Geq (Const 0) (Const 0)) \\<rangle> ! (Geq (Var vid1) (Const 0)))) &&\n                       ! (! (! (! (Geq (Var vid1) (Const 0)) &&\n                                ! (! (Geq (Const 0) (Const 0)))))))) &&\n                 ! (! (! (! (! (\\<langle> EvolveODE\n     (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n     (Geq (Const 0)\n       (Const\n         0)) \\<rangle> ! (Geq (Differential (Var vid1))\n                           (Differential (Const 0))))) &&\n                          ! (! (Geq (Const 0) (Const 0))))))))))\n   (0, Lrule ImplyL 0))\n (0, Rrule CohideRR 0))\n                                     (0, Lrule ImplyL 0))\n                                   (Suc (Suc 0), CloseId 0 0))\n                                 (Suc 0, AxSubst ADIGeq SystemDISubst))\n                               (Suc 0, Rrule ImplyR 0))\n                             (Suc 0, CloseId 1 0))\n                           (0, Rrule ImplyR 0))\n                         (0, Cut (! (!\n(! (! (! (\\<langle> EvolveODE\n                     (OProd (OSing vid1 ($f fid1 local.empty))\n                       (OSing vid2 (Var vid1)))\n                     (Geq (Const 0)\n                       (Const\n                         0)) \\<rangle> !\n  (Geq (Differential (Var vid1)) (Differential (Const 0)))) &&\n       ! (\\<langle> EvolveODE\n                     (OProd (OSing vid1 ($f fid1 local.empty))\n                       (OSing vid2 (Var vid1)))\n                     (Geq (Const 0) (Const 0) &&\n                      Geq ($f fid1 local.empty)\n                       (Const\n                         0)) \\<rangle> !\n  (Geq (Differential (Var vid1)) (Differential (Const 0))))) &&\n    ! (! (! (\\<langle> EvolveODE\n                        (OProd (OSing vid1 ($f fid1 local.empty))\n                          (OSing vid2 (Var vid1)))\n                        (Geq (Const 0)\n                          (Const\n                            0)) \\<rangle> !\n     (Geq (Differential (Var vid1)) (Differential (Const 0))))) &&\n       ! (! (\\<langle> EvolveODE\n                        (OProd (OSing vid1 ($f fid1 local.empty))\n                          (OSing vid2 (Var vid1)))\n                        (Geq (Const 0) (Const 0) &&\n                         Geq ($f fid1 local.empty)\n                          (Const\n                            0)) \\<rangle> !\n     (Geq (Differential (Var vid1)) (Differential (Const 0)))))))) &&\n                                     !\n(! (! (\\<langle> EvolveODE\n                  (OProd (OSing vid1 ($f fid1 local.empty))\n                    (OSing vid2 (Var vid1)))\n                  (Geq (Const 0)\n                    (Const\n                      0)) \\<rangle> ! (Geq ($f fid1 local.empty)\n  (Const 0)))))))))\n                       (0, Lrule ImplyL 0))\n                     (0, Rrule CohideRR 0))\n                   (0, Lrule EquivBackwardL 0))\n                 (0, Rrule CohideR 0))\n               (0, AxSubst ADC\n                    \\<lparr>SFunctions = Map.empty, SPredicates = Map.empty,\n                       SContexts =\n                         \\<lambda>C.\n                            if C = pid1 then Some (Geq (Const 0) (Const 0))\n                            else if C = pid2\n                                 then Some\n (Geq (Differential (Var vid1)) (Differential (Const 0)))\n                                 else if C = pid3\nthen Some (Geq ($f fid1 local.empty) (Const 0)) else None,\n                       SPrograms = Map.empty,\n                       SODEs =\n                         \\<lambda>c.\n                            if c = vid1\n                            then Some\n                                  (OProd (OSing vid1 ($f fid1 local.empty))\n                                    (OSing vid2 (Var vid1)))\n                            else None\\<rparr>))\n             (0, CloseId 0 0))\n           (0, Rrule CohideRR 0))\n         (0, Cut (! (! (! (\\<langle> EvolveODE\n(OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n(Geq (Const 0) (Const 0) &&\n Geq ($f fid1 local.empty)\n  (Const 0)) \\<rangle> ! (Geq ($f fid1 local.empty) (Const 0)))) &&\n                     ! (! (Geq ($f fid1 local.empty) (Const 0)))))))\n       (0, Lrule ImplyL 0))\n     (0, Rrule CohideRR 0))\n   (0, Cut (! (! (! (\\<langle> EvolveODE\n                                (OProd (OSing vid1 ($f fid1 local.empty))\n                                  (OSing vid2 (Var vid1)))\n                                (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 local.empty)\n                                  (Const\n                                    0)) \\<rangle> !\n             (Geq (Differential (Var vid1)) (Differential (Const 0)))) &&\n                  ! (\\<langle> EvolveODE\n                                (OProd (OSing vid1 ($f fid1 local.empty))\n                                  (OSing vid2 (Var vid1)))\n                                (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 local.empty)\n                                  (Const\n                                    0)) \\<rangle> !\n             (! (\\<langle> DiffAssign vid1\n                            ($f fid1\n                              local.empty) \\<rangle> !\n                (Geq (Differential (Var vid1))\n                  (Differential (Const 0))))))) &&\n               ! (! (! (\\<langle> EvolveODE\n                                   (OProd (OSing vid1 ($f fid1 local.empty))\n                                     (OSing vid2 (Var vid1)))\n                                   (Geq (Const 0) (Const 0) &&\n                                    Geq ($f fid1 local.empty)\n                                     (Const\n 0)) \\<rangle> ! (Geq (Differential (Var vid1))\n                   (Differential (Const 0))))) &&\n                  ! (! (\\<langle> EvolveODE\n                                   (OProd (OSing vid1 ($f fid1 local.empty))\n                                     (OSing vid2 (Var vid1)))\n                                   (Geq (Const 0) (Const 0) &&\n                                    Geq ($f fid1 local.empty)\n                                     (Const\n 0)) \\<rangle> ! (! (\\<langle> DiffAssign vid1\n                                ($f fid1\n                                  local.empty) \\<rangle> !\n                    (Geq (Differential (Var vid1))\n                      (Differential (Const 0))))))))))))\n (0, Lrule EquivBackwardL 0))\n                                     (0, Rrule CohideRR 0))\n                                   (1, CloseId (Suc 1) 0))\n                                 (Suc 1, CloseId 0 0))\n                               (1, AxSubst AV SystemVSubst))\n                             (0, Cut (!\n (! (! (\\<langle> EvolveODE\n                   (OProd (OSing vid1 ($f fid1 local.empty))\n                     (OSing vid2 (Var vid1)))\n                   (Geq (Const 0)\n                     (Const\n                       0)) \\<rangle> !\n(Geq ($f fid1 local.empty) (Const 0)))) &&\n  ! (! (Geq ($f fid1 local.empty) (Const 0)))))))\n                           (0, Lrule ImplyL 0))\n                         (0, Rrule CohideRR 0))\n                       (Suc 1, CloseId 0 0))\n                     (Suc 1, CloseId (Suc 2) 0))\n                   (Suc 1, AxSubst AV SystemVSubst2))\n                 (0, Rrule CohideRR 0))\n               (0, DEAxiomSchema (OSing vid2 (Var vid1)) SystemDESubst))\n             (0, Cut (! (! (! (! (! (\\<langle> EvolveODE\n          (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n          (Geq (Const 0) (Const 0) &&\n           Geq ($f fid1 local.empty)\n            (Const\n              0)) \\<rangle> ! (! (\\<langle> DiffAssign vid1\n       ($f fid1\n         local.empty) \\<rangle> ! (Geq (Differential (Var vid1))\n                                    (Differential (Const 0))))))) &&\n                               ! (! (!\n(\\<langle> EvolveODE\n            (OProd (OSing vid1 ($f fid1 local.empty))\n              (OSing vid2 (Var vid1)))\n            (Geq (Const 0) (Const 0) &&\n             Geq ($f fid1 local.empty)\n              (Const\n                0)) \\<rangle> ! (Geq (Const 0) (Const 0) &&\n                                 Geq ($f fid1 local.empty)\n                                  (Const 0))))))) &&\n                         ! (! (! (\\<langle> EvolveODE\n       (OProd (OSing vid1 ($f fid1 local.empty)) (OSing vid2 (Var vid1)))\n       (Geq (Const 0) (Const 0) &&\n        Geq ($f fid1 local.empty)\n         (Const\n           0)) \\<rangle> ! (! (! (! (\\<langle> DiffAssign vid1\n          ($f fid1\n            local.empty) \\<rangle> ! (Geq (Differential (Var vid1))\n (Differential (Const 0))))) &&\n                               ! (! (Geq (Const 0) (Const 0) &&\n                                     Geq ($f fid1 local.empty)\n(Const 0))))))))))))\n           (0, Lrule ImplyL 0))\n         (0, Rrule CohideRR 0))\n       (0, Lrule ImplyL 0))\n     (0, Rrule CohideRR 0))\n   (0, AxSubst AK SystemKSubst))\n (0, CloseId 0 0))\n                                     (0, Rrule CohideR 0))\n                                   (1, AxSubst ADW SystemDWSubst))\n                                 (0, G))\n                               (0, Cut (!\n   (! (! (! (! (\\<langle> DiffAssign vid1\n                           ($f fid1\n                             local.empty) \\<rangle> !\n               (Geq (Differential (Var vid1)) (Differential (Const 0))))) &&\n          ! (! (Geq (Const 0) (Const 0) &&\n                Geq ($f fid1 local.empty) (Const 0)))) &&\n       ! (! (! (\\<langle> DiffAssign vid1\n                           ($f fid1\n                             local.empty) \\<rangle> !\n               (Geq ($' vid1) (Const 0)))) &&\n          ! (! (Geq (Const 0) (Const 0) &&\n                Geq ($f fid1 local.empty) (Const 0))))) &&\n    ! (! (! (! (! (\\<langle> DiffAssign vid1\n                              ($f fid1\n                                local.empty) \\<rangle> !\n                  (Geq (Differential (Var vid1))\n                    (Differential (Const 0))))) &&\n             ! (! (Geq (Const 0) (Const 0) &&\n                   Geq ($f fid1 local.empty) (Const 0))))) &&\n       ! (! (! (! (\\<langle> DiffAssign vid1\n                              ($f fid1\n                                local.empty) \\<rangle> !\n                  (Geq ($' vid1) (Const 0)))) &&\n             ! (! (Geq (Const 0) (Const 0) &&\n                   Geq ($f fid1 local.empty) (Const 0))))))))))\n                             (0, Lrule EquivBackwardL 0))\n                           (0, Rrule CohideR 0))\n                         (0, CloseId 0 0))\n                       (0, Rrule CohideR 0))\n                     (0, CE SystemCEFml1 SystemCEFml2 SystemCESubst))\n                   (0, Rrule ImplyR 0))\n                 (0, Lrule AndL 0))\n               (0, Cut (! (! (! (\\<langle> DiffAssign vid1\n      ($f fid1 local.empty) \\<rangle> ! (Geq ($' vid1) (Const 0))) &&\n                              Geq ($f fid1 local.empty) (Const 0)) &&\n                           ! (! (! (\\<langle> DiffAssign vid1\n         ($f fid1 local.empty) \\<rangle> ! (Geq ($' vid1) (Const 0)))) &&\n                              ! (Geq ($f fid1 local.empty) (Const 0)))))))\n             (0, Lrule EquivBackwardL 0))\n           (0, Rrule CohideRR 0))\n         (0, CloseId 0 0))\n       (0, CloseId 1 0))\n     (0, AxSubst Adassign SystemDiffAssignSubst) =\n    ([], [],\n     [! (! (! (\\<langle> EvolveODE\n                          (OProd (OSing vid1 ($f fid1 local.empty))\n                            (OSing vid2 (Var vid1)))\n                          (Geq (Const 0)\n                            (Const\n                              0)) \\<rangle> !\n       (Geq (Var vid1) (Const 0)))) &&\n         ! (! (Geq (Var vid1) (Const 0) &&\n               Geq ($f fid1 local.empty) (Const 0))))])", "apply( simp add:  prover)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SystemSound_lemma:\"sound (proof_result SystemProof)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (proof_result SystemProof)", "apply(rule proof_sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok SystemProof", "unfolding SystemProof_def SystemConcl_def CQ1Concl_def CQ2Concl_def Equiv_def CQRightSubst_def diff_const_axiom_valid diff_var_axiom_valid empty_def Or_def expand_singleton \n  diff_var_axiom_def SystemDICut_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok\n     (([],\n       [(Geq (Var vid1) (Const 0) && Geq (f0 fid1) (Const 0)) \\<rightarrow>\n        [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n           TT]]Geq (Var vid1) (Const 0)]),\n      [(0, Rrule ImplyR 0), (0, Lrule AndL 0),\n       (0, Cut ((TT \\<rightarrow>\n                 [[EvolveODE\n                    (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n                    TT]]Geq (Differential (Var vid1))\n                         (Differential (Const 0))) \\<rightarrow>\n                (TT \\<rightarrow> Geq (Var vid1) (Const 0)) \\<rightarrow>\n                [[EvolveODE\n                   (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n                   TT]]Geq (Var vid1) (Const 0))),\n       (0, Lrule ImplyL 0), (0, Rrule CohideRR 0), (0, Lrule ImplyL 0),\n       (Suc (Suc 0), CloseId 0 0), (Suc 0, AxSubst ADIGeq SystemDISubst),\n       (Suc 0, Rrule ImplyR 0), (Suc 0, CloseId 1 0), (0, Rrule ImplyR 0),\n       (0, Cut SystemDCCut), (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideR 0),\n       (0, AxSubst ADC SystemDCSubst), (0, CloseId 0 0),\n       (0, Rrule CohideRR 0), (0, Cut SystemVCut), (0, Lrule ImplyL 0),\n       (0, Rrule CohideRR 0), (0, Cut SystemDECut),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideRR 0),\n       (1, CloseId (Suc 1) 0), (Suc 1, CloseId 0 0),\n       (1, AxSubst AV SystemVSubst), (0, Cut SystemVCut2),\n       (0, Lrule ImplyL 0), (0, Rrule CohideRR 0), (Suc 1, CloseId 0 0),\n       (Suc 1, CloseId (Suc 2) 0), (Suc 1, AxSubst AV SystemVSubst2),\n       (0, Rrule CohideRR 0),\n       (0, DEAxiomSchema (OSing vid2 (Var vid1)) SystemDESubst),\n       (0, Cut SystemKCut), (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n       (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n       (0, AxSubst AK SystemKSubst), (0, CloseId 0 0), (0, Rrule CohideR 0),\n       (1, AxSubst ADW SystemDWSubst), (0, G), (0, Cut SystemEquivCut),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideR 0), (0, CloseId 0 0),\n       (0, Rrule CohideR 0),\n       (0, CE SystemCEFml1 SystemCEFml2 SystemCESubst), (0, Rrule ImplyR 0),\n       (0, Lrule AndL 0), (0, Cut SystemDiffAssignCut),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideRR 0), (0, CloseId 0 0),\n       (0, CloseId 1 0), (0, AxSubst Adassign SystemDiffAssignSubst)])", "(* slow *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_ok\n     (([],\n       [(Geq (Var vid1) (Const 0) && Geq (f0 fid1) (Const 0)) \\<rightarrow>\n        [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n           TT]]Geq (Var vid1) (Const 0)]),\n      [(0, Rrule ImplyR 0), (0, Lrule AndL 0),\n       (0, Cut ((TT \\<rightarrow>\n                 [[EvolveODE\n                    (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n                    TT]]Geq (Differential (Var vid1))\n                         (Differential (Const 0))) \\<rightarrow>\n                (TT \\<rightarrow> Geq (Var vid1) (Const 0)) \\<rightarrow>\n                [[EvolveODE\n                   (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n                   TT]]Geq (Var vid1) (Const 0))),\n       (0, Lrule ImplyL 0), (0, Rrule CohideRR 0), (0, Lrule ImplyL 0),\n       (Suc (Suc 0), CloseId 0 0), (Suc 0, AxSubst ADIGeq SystemDISubst),\n       (Suc 0, Rrule ImplyR 0), (Suc 0, CloseId 1 0), (0, Rrule ImplyR 0),\n       (0, Cut SystemDCCut), (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideR 0),\n       (0, AxSubst ADC SystemDCSubst), (0, CloseId 0 0),\n       (0, Rrule CohideRR 0), (0, Cut SystemVCut), (0, Lrule ImplyL 0),\n       (0, Rrule CohideRR 0), (0, Cut SystemDECut),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideRR 0),\n       (1, CloseId (Suc 1) 0), (Suc 1, CloseId 0 0),\n       (1, AxSubst AV SystemVSubst), (0, Cut SystemVCut2),\n       (0, Lrule ImplyL 0), (0, Rrule CohideRR 0), (Suc 1, CloseId 0 0),\n       (Suc 1, CloseId (Suc 2) 0), (Suc 1, AxSubst AV SystemVSubst2),\n       (0, Rrule CohideRR 0),\n       (0, DEAxiomSchema (OSing vid2 (Var vid1)) SystemDESubst),\n       (0, Cut SystemKCut), (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n       (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n       (0, AxSubst AK SystemKSubst), (0, CloseId 0 0), (0, Rrule CohideR 0),\n       (1, AxSubst ADW SystemDWSubst), (0, G), (0, Cut SystemEquivCut),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideR 0), (0, CloseId 0 0),\n       (0, Rrule CohideR 0),\n       (0, CE SystemCEFml1 SystemCEFml2 SystemCESubst), (0, Rrule ImplyR 0),\n       (0, Lrule AndL 0), (0, Cut SystemDiffAssignCut),\n       (0, Lrule EquivBackwardL 0), (0, Rrule CohideRR 0), (0, CloseId 0 0),\n       (0, CloseId 1 0), (0, AxSubst Adassign SystemDiffAssignSubst)])", "apply (auto simp add: prover CEProof_def CEReq_def CQ1Concl_def CQ2Concl_def Equiv_def\n    CQRightSubst_def diff_const_axiom_valid diff_var_axiom_valid empty_def Or_def expand_singleton \n    TUadmit_def NTUadmit_def almost_diff_const CQLeftSubst_def almost_diff_var f0_def TT_def SystemDISubst_def f1_def p1_def SystemDCCut_def SystemDCSubst_def\n    SystemVCut_def SystemDECut_def SystemVSubst_def\n    SystemVCut2_def SystemVSubst2_def  SystemDESubst_def P_def SystemKCut_def  SystemKSubst_def SystemDWSubst_def SystemEquivCut_def\n    SystemCESubst_def SystemCEFml1_def SystemCEFml2_def CE1pre_valid2 SystemDiffAssignCut_def SystemDiffAssignSubst_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma system_sound:\"sound ([], SystemConcl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound ([], SystemConcl)", "using SystemSound_lemma system_result_correct"], ["proof (prove)\nusing this:\n  sound (proof_result SystemProof)\n  proof_result SystemProof =\n  ([], [],\n   [(Geq (Var vid1) (Const 0) && Geq (f0 fid1) (Const 0)) \\<rightarrow>\n    [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n       TT]]Geq (Var vid1) (Const 0)])\n\ngoal (1 subgoal):\n 1. sound ([], SystemConcl)", "unfolding SystemConcl_def"], ["proof (prove)\nusing this:\n  sound (proof_result SystemProof)\n  proof_result SystemProof =\n  ([], [],\n   [(Geq (Var vid1) (Const 0) && Geq (f0 fid1) (Const 0)) \\<rightarrow>\n    [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n       TT]]Geq (Var vid1) (Const 0)])\n\ngoal (1 subgoal):\n 1. sound\n     ([], [],\n      [(Geq (Var vid1) (Const 0) && Geq (f0 fid1) (Const 0)) \\<rightarrow>\n       [[EvolveODE (OProd (OSing vid1 (f0 fid1)) (OSing vid2 (Var vid1)))\n          TT]]Geq (Var vid1) (Const 0)])", "by auto"], ["", "lemma DIAnd_result_correct:\"proof_result (proof_take 61 DIAndProof) = DIAnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_result (proof_take 61 DIAndProof) = DIAnd", "unfolding DIAndProof_def DIAndConcl_def Implies_def Or_def \n  proof_result.simps deriv_result.simps start_proof.simps DIAndCutP12_def  DIAndSG1_def DIAndSG2_def DIAndCutP1_def Box_def DIAndCut34Elim1_def DIAndCut12Intro_def DIAndCut34Elim2_def DIAnd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proof_result\n     (proof_take 61\n       (([],\n         [! (! (! (! (! (\\<langle> $\\<alpha>\n                                    vid1 \\<rangle> !\n              (Pc pid1 && Pc pid2))) &&\n                   ! (! (! (\\<langle> $\\<alpha>\n vid1 \\<rangle> ! (Pc pid3 && Pc pid4)))))) &&\n             ! (! (Pc pid1 && Pc pid2)))]),\n        [(0, Rrule ImplyR 0), (0, Lrule AndL 0), (0, Rrule ImplyR 0),\n         (0, Cut (! (\\<langle> $\\<alpha> vid1 \\<rangle> ! (Pc pid1)))),\n         (1, Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid1))) &&\n                           ! (! (! (\\<langle> $\\<alpha>\n         vid1 \\<rangle> ! (Pc pid3)))))) &&\n                     ! (! (Pc pid1))))),\n         (0, Rrule CohideR 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc (Suc 0),\n          Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (Pc pid3))) &&\n                        ! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid3 && Pc pid4)))))) &&\n                  ! (! (! (\\<langle> $\\<alpha>\nvid1 \\<rangle> ! (! (! (Pc pid3) && ! (! (Pc pid3 && Pc pid4)))))))))),\n         (0, Lrule ImplyL 0), (Suc (Suc (Suc 0)), Lrule ImplyL 0),\n         (0, Rrule CohideRR 0), (0, Rrule CohideRR 0),\n         (Suc 0, Rrule CohideRR 0), (Suc (Suc (Suc (Suc (Suc 0)))), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc (Suc 0)))), Lrule AndL 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc 0)), AxSubst AK DIAndSubst341),\n         (Suc (Suc 0), CloseId 0 0), (Suc 0, CloseId 0 0),\n         (0, Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid1 && Pc pid2))) &&\n                           ! (! (! (\\<langle> $\\<alpha>\n         vid1 \\<rangle> ! (Pc pid2)))))) &&\n                     ! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (! (! (Pc pid1 && Pc pid2) && ! (! (Pc pid2)))))))))),\n         (Suc 0, Rrule CohideRR 0), (Suc (Suc 0), AxSubst AK DIAndSubst12),\n         (0, Lrule ImplyL 0), (1, Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (! (! (Pc pid1 && Pc pid2) && ! (! (Pc pid2)))))) &&\n                        ! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid1)))))) &&\n                  ! (! (! (\\<langle> $\\<alpha>\nvid1 \\<rangle> ! (! (! (! (! (Pc pid1 && Pc pid2) && ! (! (Pc pid2)))) &&\n                     ! (! (Pc pid1)))))))))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))), AxSubst AK DIAndCurry12),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0),\n         (Suc (Suc 0), Lrule ImplyL 0), (Suc (Suc 0), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc 0))), Rrule ImplyR 0),\n         (Suc (Suc (Suc (Suc 0))), Rrule AndR 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc (Suc 0))), CloseId 1 0), (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (Pc pid4))) &&\n                        ! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid3 && Pc pid4)))))) &&\n                  ! (! (! (\\<langle> $\\<alpha>\nvid1 \\<rangle> ! (! (! (Pc pid4) && ! (! (Pc pid3 && Pc pid4)))))))))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))), AxSubst AK DIAndSubst342),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0), (Suc (Suc (Suc 0)), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc 0)), Lrule AndL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc 0, CloseId 0 0),\n         (1, Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid2))) &&\n                           ! (! (! (\\<langle> $\\<alpha>\n         vid1 \\<rangle> ! (Pc pid4)))))) &&\n                     ! (! (Pc pid2))))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc 0)), CloseId 4 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 0 0), (Suc (Suc (Suc 0)), CloseId 0 0),\n         (1, CloseId 1 0)])) =\n    ([([],\n       [! (! (! (! (! (\\<langle> $\\<alpha> vid1 \\<rangle> ! (Pc pid1))) &&\n                 ! (! (! (\\<langle> $\\<alpha>\n                                     vid1 \\<rangle> ! (Pc pid3)))))) &&\n           ! (! (Pc pid1)))]),\n      ([],\n       [! (! (! (! (! (\\<langle> $\\<alpha> vid1 \\<rangle> ! (Pc pid2))) &&\n                 ! (! (! (\\<langle> $\\<alpha>\n                                     vid1 \\<rangle> ! (Pc pid4)))))) &&\n           ! (! (Pc pid2)))])],\n     [],\n     [! (! (! (! (! (\\<langle> $\\<alpha>\n                                vid1 \\<rangle> ! (Pc pid1 && Pc pid2))) &&\n               ! (! (! (\\<langle> $\\<alpha>\n                                   vid1 \\<rangle> !\n             (Pc pid3 && Pc pid4)))))) &&\n         ! (! (Pc pid1 && Pc pid2)))])", "using pne12 pne13 pne14 pne23 pne24 pne34"], ["proof (prove)\nusing this:\n  pid1 \\<noteq> pid2\n  pid1 \\<noteq> pid3\n  pid1 \\<noteq> pid4\n  pid2 \\<noteq> pid3\n  pid2 \\<noteq> pid4\n  pid3 \\<noteq> pid4\n\ngoal (1 subgoal):\n 1. proof_result\n     (proof_take 61\n       (([],\n         [! (! (! (! (! (\\<langle> $\\<alpha>\n                                    vid1 \\<rangle> !\n              (Pc pid1 && Pc pid2))) &&\n                   ! (! (! (\\<langle> $\\<alpha>\n vid1 \\<rangle> ! (Pc pid3 && Pc pid4)))))) &&\n             ! (! (Pc pid1 && Pc pid2)))]),\n        [(0, Rrule ImplyR 0), (0, Lrule AndL 0), (0, Rrule ImplyR 0),\n         (0, Cut (! (\\<langle> $\\<alpha> vid1 \\<rangle> ! (Pc pid1)))),\n         (1, Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid1))) &&\n                           ! (! (! (\\<langle> $\\<alpha>\n         vid1 \\<rangle> ! (Pc pid3)))))) &&\n                     ! (! (Pc pid1))))),\n         (0, Rrule CohideR 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc (Suc 0),\n          Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (Pc pid3))) &&\n                        ! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid3 && Pc pid4)))))) &&\n                  ! (! (! (\\<langle> $\\<alpha>\nvid1 \\<rangle> ! (! (! (Pc pid3) && ! (! (Pc pid3 && Pc pid4)))))))))),\n         (0, Lrule ImplyL 0), (Suc (Suc (Suc 0)), Lrule ImplyL 0),\n         (0, Rrule CohideRR 0), (0, Rrule CohideRR 0),\n         (Suc 0, Rrule CohideRR 0), (Suc (Suc (Suc (Suc (Suc 0)))), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc (Suc 0)))), Lrule AndL 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc 0)), AxSubst AK DIAndSubst341),\n         (Suc (Suc 0), CloseId 0 0), (Suc 0, CloseId 0 0),\n         (0, Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid1 && Pc pid2))) &&\n                           ! (! (! (\\<langle> $\\<alpha>\n         vid1 \\<rangle> ! (Pc pid2)))))) &&\n                     ! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (! (! (Pc pid1 && Pc pid2) && ! (! (Pc pid2)))))))))),\n         (Suc 0, Rrule CohideRR 0), (Suc (Suc 0), AxSubst AK DIAndSubst12),\n         (0, Lrule ImplyL 0), (1, Lrule ImplyL 0),\n         (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (! (! (Pc pid1 && Pc pid2) && ! (! (Pc pid2)))))) &&\n                        ! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid1)))))) &&\n                  ! (! (! (\\<langle> $\\<alpha>\nvid1 \\<rangle> ! (! (! (! (! (Pc pid1 && Pc pid2) && ! (! (Pc pid2)))) &&\n                     ! (! (Pc pid1)))))))))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))), AxSubst AK DIAndCurry12),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0),\n         (Suc (Suc 0), Lrule ImplyL 0), (Suc (Suc 0), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc (Suc 0))), Rrule ImplyR 0),\n         (Suc (Suc (Suc (Suc 0))), Rrule AndR 0),\n         (Suc (Suc (Suc (Suc (Suc 0)))), CloseId 0 0),\n         (Suc (Suc (Suc (Suc 0))), CloseId 1 0), (Suc (Suc 0), CloseId 0 0),\n         (Suc 0,\n          Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n   vid1 \\<rangle> ! (Pc pid4))) &&\n                        ! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid3 && Pc pid4)))))) &&\n                  ! (! (! (\\<langle> $\\<alpha>\nvid1 \\<rangle> ! (! (! (Pc pid4) && ! (! (Pc pid3 && Pc pid4)))))))))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc (Suc 0))), AxSubst AK DIAndSubst342),\n         (Suc (Suc (Suc 0)), Rrule CohideRR 0), (Suc (Suc (Suc 0)), G),\n         (0, Rrule ImplyR 0), (Suc (Suc (Suc 0)), Lrule AndL 0),\n         (Suc (Suc (Suc 0)), CloseId 1 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc 0, CloseId 0 0),\n         (1, Cut (! (! (! (! (! (\\<langle> $\\<alpha>\n      vid1 \\<rangle> ! (Pc pid2))) &&\n                           ! (! (! (\\<langle> $\\<alpha>\n         vid1 \\<rangle> ! (Pc pid4)))))) &&\n                     ! (! (Pc pid2))))),\n         (0, Lrule ImplyL 0), (0, Rrule CohideRR 0),\n         (Suc (Suc (Suc 0)), CloseId 4 0), (Suc (Suc 0), Lrule ImplyL 0),\n         (Suc (Suc (Suc 0)), CloseId 0 0), (Suc (Suc (Suc 0)), CloseId 0 0),\n         (1, CloseId 1 0)])) =\n    ([([],\n       [! (! (! (! (! (\\<langle> $\\<alpha> vid1 \\<rangle> ! (Pc pid1))) &&\n                 ! (! (! (\\<langle> $\\<alpha>\n                                     vid1 \\<rangle> ! (Pc pid3)))))) &&\n           ! (! (Pc pid1)))]),\n      ([],\n       [! (! (! (! (! (\\<langle> $\\<alpha> vid1 \\<rangle> ! (Pc pid2))) &&\n                 ! (! (! (\\<langle> $\\<alpha>\n                                     vid1 \\<rangle> ! (Pc pid4)))))) &&\n           ! (! (Pc pid2)))])],\n     [],\n     [! (! (! (! (! (\\<langle> $\\<alpha>\n                                vid1 \\<rangle> ! (Pc pid1 && Pc pid2))) &&\n               ! (! (! (\\<langle> $\\<alpha>\n                                   vid1 \\<rangle> !\n             (Pc pid3 && Pc pid4)))))) &&\n         ! (! (Pc pid1 && Pc pid2)))])", "by (auto)"], ["", "theorem DIAnd_sound: \"sound DIAnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound DIAnd", "using DIAndSound_lemma DIAnd_result_correct"], ["proof (prove)\nusing this:\n  sound (proof_result (proof_take 61 DIAndProof))\n  proof_result (proof_take 61 DIAndProof) = DIAnd\n\ngoal (1 subgoal):\n 1. sound DIAnd", "by auto"], ["", "end"], ["", "end"]]}