{"file_name": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic/Denotational_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic", "problem_names": ["lemma agree_nil:\"Vagree \\<nu> \\<omega> {}\"", "lemma agree_supset:\"A \\<supseteq> B \\<Longrightarrow> Vagree \\<nu> \\<nu>' A \\<Longrightarrow> Vagree \\<nu> \\<nu>' B\"", "lemma VSagree_nil:\"VSagree \\<nu> \\<omega> {}\"", "lemma VSagree_supset:\"A \\<supseteq> B \\<Longrightarrow> VSagree \\<nu> \\<nu>' A \\<Longrightarrow> VSagree \\<nu> \\<nu>' B\"", "lemma VSagree_UNIV_eq:\"VSagree A B UNIV \\<Longrightarrow> A = B\"", "lemma agree_comm:\"\\<And>A B V. Vagree A B V \\<Longrightarrow> Vagree B A V\"", "lemma agree_sub:\"\\<And>\\<nu> \\<omega> A B . A \\<subseteq> B \\<Longrightarrow> Vagree \\<nu> \\<omega> B \\<Longrightarrow> Vagree \\<nu> \\<omega> A\"", "lemma agree_UNIV_eq:\"\\<And>\\<nu> \\<omega>. Vagree \\<nu> \\<omega> UNIV \\<Longrightarrow> \\<nu> = \\<omega>\"", "lemma agree_UNIV_fst:\"\\<And>\\<nu> \\<omega>. Vagree \\<nu> \\<omega> (Inl ` UNIV) \\<Longrightarrow> (fst \\<nu>) = (fst \\<omega>)\"", "lemma agree_UNIV_snd:\"\\<And>\\<nu> \\<omega>. Vagree \\<nu> \\<omega> (Inr ` UNIV) \\<Longrightarrow> (snd \\<nu>) = (snd \\<omega>)\"", "lemma Vagree_univ:\"\\<And>a b c d. Vagree (a,b) (c,d) UNIV \\<Longrightarrow> a = c \\<and> b = d\"", "lemma agree_union:\"\\<And>\\<nu> \\<omega> A B. Vagree \\<nu> \\<omega> A \\<Longrightarrow> Vagree \\<nu> \\<omega> B \\<Longrightarrow> Vagree \\<nu> \\<omega> (A \\<union> B)\"", "lemma agree_trans:\"Vagree \\<nu> \\<mu> A \\<Longrightarrow> Vagree \\<mu> \\<omega> B \\<Longrightarrow> Vagree \\<nu> \\<omega> (A \\<inter> B)\"", "lemma agree_refl:\"Vagree \\<nu> \\<nu> A\"", "lemma VSagree_sub:\"\\<And>\\<nu> \\<omega> A B . A \\<subseteq> B \\<Longrightarrow> VSagree \\<nu> \\<omega> B \\<Longrightarrow> VSagree \\<nu> \\<omega> A\"", "lemma VSagree_refl:\"VSagree \\<nu> \\<nu> A\"", "lemma is_interpD:\"is_interp I \\<Longrightarrow> \\<forall>x. \\<forall>i. (FDERIV (Functions I i) x :> (FunctionFrechet I i x))\"", "lemma Iagree_Func:\"Iagree I J V \\<Longrightarrow> Inl f \\<in> V \\<Longrightarrow> Functions I f = Functions J f\"", "lemma Iagree_Contexts:\"Iagree I J V \\<Longrightarrow> Inr (Inl C) \\<in> V \\<Longrightarrow> Contexts I C = Contexts J C\"", "lemma Iagree_Pred:\"Iagree I J V \\<Longrightarrow> Inr (Inr p) \\<in> V \\<Longrightarrow> Predicates I p = Predicates J p\"", "lemma Iagree_Prog:\"Iagree I J V \\<Longrightarrow> Inr (Inr a) \\<in> V \\<Longrightarrow> Programs I a = Programs J a\"", "lemma Iagree_ODE:\"Iagree I J V \\<Longrightarrow> Inr (Inr a) \\<in> V \\<Longrightarrow> ODEs I a = ODEs J a\"", "lemma Iagree_comm:\"\\<And>A B V. Iagree A B V \\<Longrightarrow> Iagree B A V\"", "lemma Iagree_sub:\"\\<And>I J A B . A \\<subseteq> B \\<Longrightarrow> Iagree I J B \\<Longrightarrow> Iagree I J A\"", "lemma Iagree_refl:\"Iagree I I A\"", "lemma ODE_vars_lr:\n  fixes x::\"'sz\" and ODE::\"('sf,'sz) ODE\" and I::\"('sf,'sc,'sz) interp\"\n  shows \"Inl x \\<in> semBV I ODE \\<longleftrightarrow> Inr x \\<in> semBV I ODE\"", "lemma mk_v_exists:\"\\<exists>\\<omega>. Vagree \\<omega> \\<nu> (- semBV I ODE) \n\\<and> Vagree \\<omega> (mk_xode I ODE sol) (semBV I ODE)\"", "lemma mk_v_agree:\"Vagree (mk_v I ODE \\<nu> sol) \\<nu> (- semBV I ODE) \n\\<and> Vagree (mk_v I ODE \\<nu> sol) (mk_xode I ODE sol) (semBV I ODE)\"", "lemma mk_v_concrete:\"mk_v I ODE \\<nu> sol = ((\\<chi> i. (if Inl i \\<in> semBV I ODE then sol else (fst \\<nu>)) $ i),\n  (\\<chi> i. (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol else (snd \\<nu>)) $ i))\"", "lemma svar_case:\n  \"sterm_sem I (Var x) = (\\<lambda>v. v $ x)\"", "lemma sconst_case:\n  \"sterm_sem I (Const r) = (\\<lambda>v. r)\"", "lemma sfunction_case:\n  \"sterm_sem I (Function f args) = (\\<lambda>v. Functions I f (\\<chi> i. sterm_sem I (args i) v))\"", "lemma splus_case:\n  \"sterm_sem I (Plus t1 t2) = (\\<lambda>v. (sterm_sem I t1 v) + (sterm_sem I t2 v))\"", "lemma stimes_case:\n  \"sterm_sem I (Times t1 t2) = (\\<lambda>v. (sterm_sem I t1 v) * (sterm_sem I t2 v))\"", "lemma or_sem [simp]:\n  \"fml_sem I (Or \\<phi> \\<psi>) = fml_sem I \\<phi> \\<union> fml_sem I \\<psi>\"", "lemma iff_sem [simp]: \"(\\<nu> \\<in> fml_sem I (A \\<leftrightarrow> B))\n  \\<longleftrightarrow> ((\\<nu> \\<in> fml_sem I A) \\<longleftrightarrow> (\\<nu> \\<in> fml_sem I B))\"", "lemma box_sem [simp]:\"fml_sem I (Box \\<alpha> \\<phi>) = {\\<nu>. \\<forall> \\<omega>. (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<longrightarrow> \\<omega> \\<in> fml_sem I \\<phi>}\"", "lemma forall_sem [simp]:\"fml_sem I (Forall x \\<phi>) = {v. \\<forall>r. (repv v x r) \\<in> fml_sem I \\<phi>}\"", "lemma greater_sem[simp]:\"fml_sem I (Greater \\<theta> \\<theta>') = {v. dterm_sem I \\<theta> v > dterm_sem I \\<theta>' v}\"", "lemma loop_sem:\"prog_sem I (Loop \\<alpha>) = (prog_sem I \\<alpha>)\\<^sup>*\"", "lemma impl_sem [simp]: \"(\\<nu> \\<in> fml_sem I (A \\<rightarrow> B))\n  = ((\\<nu> \\<in> fml_sem I A) \\<longrightarrow> (\\<nu> \\<in> fml_sem I B))\"", "lemma equals_sem [simp]: \"(\\<nu> \\<in> fml_sem I (Equals \\<theta> \\<theta>'))\n  = (dterm_sem I \\<theta> \\<nu> = dterm_sem I \\<theta>' \\<nu>)\"", "lemma diamond_sem [simp]: \"fml_sem I (Diamond \\<alpha> \\<phi>)\n  = {\\<nu>. \\<exists> \\<omega>. (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<and> \\<omega> \\<in> fml_sem I \\<phi>}\"", "lemma tt_sem [simp]:\"fml_sem I TT = UNIV\"", "lemma ff_sem [simp]:\"fml_sem I FF = {}\"", "lemma iff_to_impl: \"((\\<nu> \\<in> fml_sem I A) \\<longleftrightarrow> (\\<nu> \\<in> fml_sem I B))\n  \\<longleftrightarrow> (((\\<nu> \\<in> fml_sem I A) \\<longrightarrow> (\\<nu> \\<in> fml_sem I B))\n     \\<and> ((\\<nu> \\<in> fml_sem I B) \\<longrightarrow> (\\<nu> \\<in> fml_sem I A)))\"", "lemma and_foldl_sem:\"\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> (\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>)\"", "lemma and_foldl_sem_conv:\"(\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT)\"", "lemma or_foldl_sem:\"List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Gamma> FF)\"", "lemma or_foldl_sem_conv:\"\\<nu> \\<in> fml_sem I (foldr Or \\<Gamma> FF) \\<Longrightarrow> \\<exists> \\<phi>. \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>\"", "lemma seq_semI':\"(\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Delta> FF)) \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>)\"", "lemma seq_semD':\"\\<And>P. \\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>) \\<Longrightarrow> ((\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Delta> FF)) \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma sublistI:\"(\\<And>x. List.member A x \\<Longrightarrow> List.member B x) \\<Longrightarrow> sublist A B\"", "lemma \\<Gamma>_sub_sem:\"sublist \\<Gamma>1 \\<Gamma>2 \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma>2 TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma>1 TT)\"", "lemma seq_semI:\"List.member \\<Delta> \\<psi> \\<Longrightarrow>((\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<psi>) \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>)\"", "lemma seq_semD:\"\\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>) \\<Longrightarrow> (\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow> \\<exists>\\<phi>. (List.member \\<Delta> \\<phi>) \\<and>\\<nu> \\<in> fml_sem I \\<phi> \"", "lemma seq_MP:\"\\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Delta> FF)\"", "lemma soundI:\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>i. i \\<ge> 0 \\<Longrightarrow> i < length SG \\<Longrightarrow> seq_sem I (nth SG i) = UNIV) \\<Longrightarrow> seq_sem I G = UNIV) \\<Longrightarrow> sound (SG,G)\"", "lemma soundI':\"(\\<And>I \\<nu>. is_interp I \\<Longrightarrow> (\\<And>i . i \\<ge> 0 \\<Longrightarrow> i < length SG \\<Longrightarrow> \\<nu> \\<in> seq_sem I (nth SG i)) \\<Longrightarrow> \\<nu> \\<in> seq_sem I G) \\<Longrightarrow> sound (SG,G)\"", "lemma soundI_mem:\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi>. List.member SG \\<phi> \\<Longrightarrow> seq_sem I \\<phi> = UNIV) \\<Longrightarrow> seq_sem I C = UNIV) \\<Longrightarrow> sound (SG,C)\"", "lemma soundI_memv:\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi> \\<nu>. List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>) \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C)) \\<Longrightarrow> sound (SG,C)\"", "lemma soundI_memv':\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi> \\<nu>. List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>) \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C)) \\<Longrightarrow> R = (SG,C) \\<Longrightarrow> sound R\"", "lemma soundD_mem:\"sound (SG,C) \\<Longrightarrow> (\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi>. List.member SG \\<phi> \\<Longrightarrow> seq_sem I \\<phi> = UNIV) \\<Longrightarrow> seq_sem I C = UNIV)\"", "lemma soundD_memv:\"sound (SG,C) \\<Longrightarrow> (\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi> \\<nu>. List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>) \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C))\""], "translations": [["", "lemma agree_nil:\"Vagree \\<nu> \\<omega> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vagree \\<nu> \\<omega> {}", "by (auto simp add: Vagree_def)"], ["", "lemma agree_supset:\"A \\<supseteq> B \\<Longrightarrow> Vagree \\<nu> \\<nu>' A \\<Longrightarrow> Vagree \\<nu> \\<nu>' B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<subseteq> A; Vagree \\<nu> \\<nu>' A\\<rbrakk>\n    \\<Longrightarrow> Vagree \\<nu> \\<nu>' B", "by (auto simp add: Vagree_def)"], ["", "lemma VSagree_nil:\"VSagree \\<nu> \\<omega> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VSagree \\<nu> \\<omega> {}", "by (auto simp add: VSagree_def)"], ["", "lemma VSagree_supset:\"A \\<supseteq> B \\<Longrightarrow> VSagree \\<nu> \\<nu>' A \\<Longrightarrow> VSagree \\<nu> \\<nu>' B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<subseteq> A; VSagree \\<nu> \\<nu>' A\\<rbrakk>\n    \\<Longrightarrow> VSagree \\<nu> \\<nu>' B", "by (auto simp add: VSagree_def)"], ["", "lemma VSagree_UNIV_eq:\"VSagree A B UNIV \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VSagree A B UNIV \\<Longrightarrow> A = B", "unfolding VSagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>UNIV. A $ i = B $ i \\<Longrightarrow> A = B", "by (auto simp add: vec_eq_iff)"], ["", "lemma agree_comm:\"\\<And>A B V. Vagree A B V \\<Longrightarrow> Vagree B A V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B V. Vagree A B V \\<Longrightarrow> Vagree B A V", "unfolding Vagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B V.\n       (\\<forall>i.\n           Inl i \\<in> V \\<longrightarrow> fst A $ i = fst B $ i) \\<and>\n       (\\<forall>i.\n           Inr i \\<in> V \\<longrightarrow>\n           snd A $ i = snd B $ i) \\<Longrightarrow>\n       (\\<forall>i.\n           Inl i \\<in> V \\<longrightarrow> fst B $ i = fst A $ i) \\<and>\n       (\\<forall>i. Inr i \\<in> V \\<longrightarrow> snd B $ i = snd A $ i)", "by auto"], ["", "lemma agree_sub:\"\\<And>\\<nu> \\<omega> A B . A \\<subseteq> B \\<Longrightarrow> Vagree \\<nu> \\<omega> B \\<Longrightarrow> Vagree \\<nu> \\<omega> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega> A B.\n       \\<lbrakk>A \\<subseteq> B; Vagree \\<nu> \\<omega> B\\<rbrakk>\n       \\<Longrightarrow> Vagree \\<nu> \\<omega> A", "unfolding Vagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega> A B.\n       \\<lbrakk>A \\<subseteq> B;\n        (\\<forall>i.\n            Inl i \\<in> B \\<longrightarrow>\n            fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n        (\\<forall>i.\n            Inr i \\<in> B \\<longrightarrow>\n            snd \\<nu> $ i = snd \\<omega> $ i)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>i.\n                             Inl i \\<in> A \\<longrightarrow>\n                             fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n                         (\\<forall>i.\n                             Inr i \\<in> A \\<longrightarrow>\n                             snd \\<nu> $ i = snd \\<omega> $ i)", "by auto"], ["", "lemma agree_UNIV_eq:\"\\<And>\\<nu> \\<omega>. Vagree \\<nu> \\<omega> UNIV \\<Longrightarrow> \\<nu> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega>.\n       Vagree \\<nu> \\<omega> UNIV \\<Longrightarrow> \\<nu> = \\<omega>", "unfolding Vagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega>.\n       (\\<forall>i.\n           Inl i \\<in> UNIV \\<longrightarrow>\n           fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n       (\\<forall>i.\n           Inr i \\<in> UNIV \\<longrightarrow>\n           snd \\<nu> $ i = snd \\<omega> $ i) \\<Longrightarrow>\n       \\<nu> = \\<omega>", "by (auto simp add: vec_eq_iff)"], ["", "lemma agree_UNIV_fst:\"\\<And>\\<nu> \\<omega>. Vagree \\<nu> \\<omega> (Inl ` UNIV) \\<Longrightarrow> (fst \\<nu>) = (fst \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega>.\n       Vagree \\<nu> \\<omega> (range Inl) \\<Longrightarrow>\n       fst \\<nu> = fst \\<omega>", "unfolding Vagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega>.\n       (\\<forall>i.\n           Inl i \\<in> range Inl \\<longrightarrow>\n           fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n       (\\<forall>i.\n           Inr i \\<in> range Inl \\<longrightarrow>\n           snd \\<nu> $ i = snd \\<omega> $ i) \\<Longrightarrow>\n       fst \\<nu> = fst \\<omega>", "by (auto simp add: vec_eq_iff)"], ["", "lemma agree_UNIV_snd:\"\\<And>\\<nu> \\<omega>. Vagree \\<nu> \\<omega> (Inr ` UNIV) \\<Longrightarrow> (snd \\<nu>) = (snd \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega>.\n       Vagree \\<nu> \\<omega> (range Inr) \\<Longrightarrow>\n       snd \\<nu> = snd \\<omega>", "unfolding Vagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega>.\n       (\\<forall>i.\n           Inl i \\<in> range Inr \\<longrightarrow>\n           fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n       (\\<forall>i.\n           Inr i \\<in> range Inr \\<longrightarrow>\n           snd \\<nu> $ i = snd \\<omega> $ i) \\<Longrightarrow>\n       snd \\<nu> = snd \\<omega>", "by (auto simp add: vec_eq_iff)"], ["", "lemma Vagree_univ:\"\\<And>a b c d. Vagree (a,b) (c,d) UNIV \\<Longrightarrow> a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       Vagree (a, b) (c, d) UNIV \\<Longrightarrow> a = c \\<and> b = d", "by (auto simp add: Vagree_def vec_eq_iff)"], ["", "lemma agree_union:\"\\<And>\\<nu> \\<omega> A B. Vagree \\<nu> \\<omega> A \\<Longrightarrow> Vagree \\<nu> \\<omega> B \\<Longrightarrow> Vagree \\<nu> \\<omega> (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega> A B.\n       \\<lbrakk>Vagree \\<nu> \\<omega> A; Vagree \\<nu> \\<omega> B\\<rbrakk>\n       \\<Longrightarrow> Vagree \\<nu> \\<omega> (A \\<union> B)", "unfolding Vagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega> A B.\n       \\<lbrakk>(\\<forall>i.\n                    Inl i \\<in> A \\<longrightarrow>\n                    fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n                (\\<forall>i.\n                    Inr i \\<in> A \\<longrightarrow>\n                    snd \\<nu> $ i = snd \\<omega> $ i);\n        (\\<forall>i.\n            Inl i \\<in> B \\<longrightarrow>\n            fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n        (\\<forall>i.\n            Inr i \\<in> B \\<longrightarrow>\n            snd \\<nu> $ i = snd \\<omega> $ i)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>i.\n                             Inl i \\<in> A \\<union> B \\<longrightarrow>\n                             fst \\<nu> $ i = fst \\<omega> $ i) \\<and>\n                         (\\<forall>i.\n                             Inr i \\<in> A \\<union> B \\<longrightarrow>\n                             snd \\<nu> $ i = snd \\<omega> $ i)", "by (auto simp add: vec_eq_iff)"], ["", "lemma agree_trans:\"Vagree \\<nu> \\<mu> A \\<Longrightarrow> Vagree \\<mu> \\<omega> B \\<Longrightarrow> Vagree \\<nu> \\<omega> (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Vagree \\<nu> \\<mu> A; Vagree \\<mu> \\<omega> B\\<rbrakk>\n    \\<Longrightarrow> Vagree \\<nu> \\<omega> (A \\<inter> B)", "by (auto simp add: Vagree_def)"], ["", "lemma agree_refl:\"Vagree \\<nu> \\<nu> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vagree \\<nu> \\<nu> A", "by (auto simp add: Vagree_def)"], ["", "lemma VSagree_sub:\"\\<And>\\<nu> \\<omega> A B . A \\<subseteq> B \\<Longrightarrow> VSagree \\<nu> \\<omega> B \\<Longrightarrow> VSagree \\<nu> \\<omega> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega> A B.\n       \\<lbrakk>A \\<subseteq> B; VSagree \\<nu> \\<omega> B\\<rbrakk>\n       \\<Longrightarrow> VSagree \\<nu> \\<omega> A", "unfolding VSagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<nu> \\<omega> A B.\n       \\<lbrakk>A \\<subseteq> B;\n        \\<forall>i\\<in>B. \\<nu> $ i = \\<omega> $ i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>A. \\<nu> $ i = \\<omega> $ i", "by auto"], ["", "lemma VSagree_refl:\"VSagree \\<nu> \\<nu> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VSagree \\<nu> \\<nu> A", "by (auto simp add: VSagree_def)"], ["", "subsection Interpretations"], ["", "text\\<open>\n    For convenience we pretend interpretations contain an extra field called\n  FunctionFrechet specifying the Frechet derivative \\verb|(FunctionFrechet f \\<nu>)| : $R^m \\rightarrow R$ \n  for every function in every state. The proposition \\verb|(is_interp I)| says that such a\n  derivative actually exists and is continuous (i.e. all functions are C1-continuous)\n  without saying what the exact derivative is.\n  \n  The type parameters 'a, 'b, 'c are finite types whose cardinalities indicate the maximum number \n  of functions, contexts, and <everything else defined by the interpretation>, respectively.\n\\<close>"], ["", "record ('a, 'b, 'c) interp =\n  Functions       :: \"'a \\<Rightarrow> 'c Rvec \\<Rightarrow> real\"\n  Predicates      :: \"'c \\<Rightarrow> 'c Rvec \\<Rightarrow> bool\"\n  Contexts        :: \"'b \\<Rightarrow> 'c state set \\<Rightarrow> 'c state set\"\n  Programs        :: \"'c \\<Rightarrow> ('c state * 'c state) set\"\n  ODEs            :: \"'c \\<Rightarrow> 'c simple_state \\<Rightarrow> 'c simple_state\"\n  ODEBV           :: \"'c \\<Rightarrow> 'c set\""], ["", "fun FunctionFrechet :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> 'a \\<Rightarrow> 'c Rvec \\<Rightarrow> 'c Rvec \\<Rightarrow> real\"\n  where \"FunctionFrechet I i = (THE f'. \\<forall> x. (Functions I i has_derivative f' x) (at x))\"\n\n\\<comment> \\<open>For an interpretation to be valid, all functions must be differentiable everywhere.\\<close>"], ["", "definition is_interp :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> bool\"\n  where \"is_interp I \\<equiv>\n   \\<forall>x. \\<forall>i. ((FDERIV (Functions I i) x :> (FunctionFrechet I i x)) \\<and> continuous_on UNIV (\\<lambda>x. Blinfun (FunctionFrechet I i x)))\""], ["", "lemma is_interpD:\"is_interp I \\<Longrightarrow> \\<forall>x. \\<forall>i. (FDERIV (Functions I i) x :> (FunctionFrechet I i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_interp I \\<Longrightarrow>\n    \\<forall>x i.\n       (Functions I i has_derivative FunctionFrechet I i x) (at x)", "unfolding is_interp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x i.\n       (Functions I i has_derivative FunctionFrechet I i x) (at x) \\<and>\n       continuous_on UNIV\n        (\\<lambda>x. Blinfun (FunctionFrechet I i x)) \\<Longrightarrow>\n    \\<forall>x i.\n       (Functions I i has_derivative FunctionFrechet I i x) (at x)", "by auto\n  \n\\<comment> \\<open>Agreement between interpretations.\\<close>"], ["", "definition Iagree :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a + 'b + 'c) set \\<Rightarrow> bool\"\nwhere \"Iagree I J V \\<equiv>\n  (\\<forall>i\\<in>V.\n    (\\<forall>x. i = Inl x \\<longrightarrow> Functions I x = Functions J x) \\<and>\n    (\\<forall>x. i = Inr (Inl x) \\<longrightarrow> Contexts I x = Contexts J x) \\<and>\n    (\\<forall>x. i = Inr (Inr x) \\<longrightarrow> Predicates I x = Predicates J x) \\<and>\n    (\\<forall>x. i = Inr (Inr x) \\<longrightarrow> Programs I x = Programs J x) \\<and>\n    (\\<forall>x. i = Inr (Inr x) \\<longrightarrow> ODEs I x = ODEs J x) \\<and>\n    (\\<forall>x. i = Inr (Inr x) \\<longrightarrow> ODEBV I x = ODEBV J x))\""], ["", "lemma Iagree_Func:\"Iagree I J V \\<Longrightarrow> Inl f \\<in> V \\<Longrightarrow> Functions I f = Functions J f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Iagree I J V; Inl f \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Functions I f = Functions J f", "unfolding Iagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>V.\n                (\\<forall>x.\n                    i = Inl x \\<longrightarrow>\n                    Functions I x = Functions J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inl x) \\<longrightarrow>\n                    Contexts I x = Contexts J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Predicates I x = Predicates J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Programs I x = Programs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEs I x = ODEs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEBV I x = ODEBV J x);\n     Inl f \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Functions I f = Functions J f", "by auto"], ["", "lemma Iagree_Contexts:\"Iagree I J V \\<Longrightarrow> Inr (Inl C) \\<in> V \\<Longrightarrow> Contexts I C = Contexts J C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Iagree I J V; Inr (Inl C) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Contexts I C = Contexts J C", "unfolding Iagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>V.\n                (\\<forall>x.\n                    i = Inl x \\<longrightarrow>\n                    Functions I x = Functions J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inl x) \\<longrightarrow>\n                    Contexts I x = Contexts J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Predicates I x = Predicates J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Programs I x = Programs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEs I x = ODEs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEBV I x = ODEBV J x);\n     Inr (Inl C) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Contexts I C = Contexts J C", "by auto"], ["", "lemma Iagree_Pred:\"Iagree I J V \\<Longrightarrow> Inr (Inr p) \\<in> V \\<Longrightarrow> Predicates I p = Predicates J p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Iagree I J V; Inr (Inr p) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Predicates I p = Predicates J p", "unfolding Iagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>V.\n                (\\<forall>x.\n                    i = Inl x \\<longrightarrow>\n                    Functions I x = Functions J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inl x) \\<longrightarrow>\n                    Contexts I x = Contexts J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Predicates I x = Predicates J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Programs I x = Programs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEs I x = ODEs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEBV I x = ODEBV J x);\n     Inr (Inr p) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Predicates I p = Predicates J p", "by auto"], ["", "lemma Iagree_Prog:\"Iagree I J V \\<Longrightarrow> Inr (Inr a) \\<in> V \\<Longrightarrow> Programs I a = Programs J a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Iagree I J V; Inr (Inr a) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Programs I a = Programs J a", "unfolding Iagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>V.\n                (\\<forall>x.\n                    i = Inl x \\<longrightarrow>\n                    Functions I x = Functions J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inl x) \\<longrightarrow>\n                    Contexts I x = Contexts J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Predicates I x = Predicates J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Programs I x = Programs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEs I x = ODEs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEBV I x = ODEBV J x);\n     Inr (Inr a) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> Programs I a = Programs J a", "by auto"], ["", "lemma Iagree_ODE:\"Iagree I J V \\<Longrightarrow> Inr (Inr a) \\<in> V \\<Longrightarrow> ODEs I a = ODEs J a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Iagree I J V; Inr (Inr a) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> ODEs I a = ODEs J a", "unfolding Iagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>V.\n                (\\<forall>x.\n                    i = Inl x \\<longrightarrow>\n                    Functions I x = Functions J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inl x) \\<longrightarrow>\n                    Contexts I x = Contexts J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Predicates I x = Predicates J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    Programs I x = Programs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEs I x = ODEs J x) \\<and>\n                (\\<forall>x.\n                    i = Inr (Inr x) \\<longrightarrow>\n                    ODEBV I x = ODEBV J x);\n     Inr (Inr a) \\<in> V\\<rbrakk>\n    \\<Longrightarrow> ODEs I a = ODEs J a", "by auto"], ["", "lemma Iagree_comm:\"\\<And>A B V. Iagree A B V \\<Longrightarrow> Iagree B A V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B V. Iagree A B V \\<Longrightarrow> Iagree B A V", "unfolding Iagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B V.\n       \\<forall>i\\<in>V.\n          (\\<forall>x.\n              i = Inl x \\<longrightarrow>\n              Functions A x = Functions B x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inl x) \\<longrightarrow>\n              Contexts A x = Contexts B x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow>\n              Predicates A x = Predicates B x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow>\n              Programs A x = Programs B x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow> ODEs A x = ODEs B x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow>\n              ODEBV A x = ODEBV B x) \\<Longrightarrow>\n       \\<forall>i\\<in>V.\n          (\\<forall>x.\n              i = Inl x \\<longrightarrow>\n              Functions B x = Functions A x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inl x) \\<longrightarrow>\n              Contexts B x = Contexts A x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow>\n              Predicates B x = Predicates A x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow>\n              Programs B x = Programs A x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow> ODEs B x = ODEs A x) \\<and>\n          (\\<forall>x.\n              i = Inr (Inr x) \\<longrightarrow> ODEBV B x = ODEBV A x)", "by auto"], ["", "lemma Iagree_sub:\"\\<And>I J A B . A \\<subseteq> B \\<Longrightarrow> Iagree I J B \\<Longrightarrow> Iagree I J A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I J A B.\n       \\<lbrakk>A \\<subseteq> B; Iagree I J B\\<rbrakk>\n       \\<Longrightarrow> Iagree I J A", "unfolding Iagree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I J A B.\n       \\<lbrakk>A \\<subseteq> B;\n        \\<forall>i\\<in>B.\n           (\\<forall>x.\n               i = Inl x \\<longrightarrow>\n               Functions I x = Functions J x) \\<and>\n           (\\<forall>x.\n               i = Inr (Inl x) \\<longrightarrow>\n               Contexts I x = Contexts J x) \\<and>\n           (\\<forall>x.\n               i = Inr (Inr x) \\<longrightarrow>\n               Predicates I x = Predicates J x) \\<and>\n           (\\<forall>x.\n               i = Inr (Inr x) \\<longrightarrow>\n               Programs I x = Programs J x) \\<and>\n           (\\<forall>x.\n               i = Inr (Inr x) \\<longrightarrow> ODEs I x = ODEs J x) \\<and>\n           (\\<forall>x.\n               i = Inr (Inr x) \\<longrightarrow>\n               ODEBV I x = ODEBV J x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>A.\n                            (\\<forall>x.\n                                i = Inl x \\<longrightarrow>\n                                Functions I x = Functions J x) \\<and>\n                            (\\<forall>x.\n                                i = Inr (Inl x) \\<longrightarrow>\n                                Contexts I x = Contexts J x) \\<and>\n                            (\\<forall>x.\n                                i = Inr (Inr x) \\<longrightarrow>\n                                Predicates I x = Predicates J x) \\<and>\n                            (\\<forall>x.\n                                i = Inr (Inr x) \\<longrightarrow>\n                                Programs I x = Programs J x) \\<and>\n                            (\\<forall>x.\n                                i = Inr (Inr x) \\<longrightarrow>\n                                ODEs I x = ODEs J x) \\<and>\n                            (\\<forall>x.\n                                i = Inr (Inr x) \\<longrightarrow>\n                                ODEBV I x = ODEBV J x)", "by auto"], ["", "lemma Iagree_refl:\"Iagree I I A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Iagree I I A", "by (auto simp add: Iagree_def)\n\n\\<comment> \\<open>Semantics for differential-free terms. Because there are no differentials, depends only on the \\<open>x\\<close> variables\\<close>\n\\<comment> \\<open>and not the \\<open>x'\\<close> variables.\\<close>"], ["", "primrec sterm_sem :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a, 'c) trm \\<Rightarrow> 'c simple_state \\<Rightarrow> real\"\nwhere\n  \"sterm_sem I (Var x) v = v $ x\"\n| \"sterm_sem I (Function f args) v = Functions I f (\\<chi> i. sterm_sem I (args i) v)\"\n| \"sterm_sem I (Plus t1 t2) v = sterm_sem I t1 v + sterm_sem I t2 v\"\n| \"sterm_sem I (Times t1 t2) v = sterm_sem I t1 v * sterm_sem I t2 v\"\n| \"sterm_sem I (Const r) v = r\"\n| \"sterm_sem I ($' c) v = undefined\"\n| \"sterm_sem I (Differential d) v = undefined\"\n  \n\\<comment> \\<open>\\<open>frechet I \\<theta> \\<nu>\\<close> syntactically computes the frechet derivative of the term \\<open>\\<theta>\\<close> in the interpretation\\<close>\n\\<comment> \\<open>\\<open>I\\<close> at state \\<open>\\<nu>\\<close> (containing only the unprimed variables). The frechet derivative is a\\<close>\n\\<comment> \\<open>linear map from the differential state \\<open>\\<nu>\\<close> to reals.\\<close>"], ["", "primrec frechet :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a, 'c) trm \\<Rightarrow> 'c simple_state \\<Rightarrow> 'c simple_state \\<Rightarrow> real\"\nwhere\n  \"frechet I (Var x) v = (\\<lambda>v'. v' \\<bullet> axis x 1)\"\n| \"frechet I (Function f args) v =\n    (\\<lambda>v'. FunctionFrechet I f (\\<chi> i. sterm_sem I (args i) v) (\\<chi> i. frechet I (args i) v v'))\"\n| \"frechet I (Plus t1 t2) v = (\\<lambda>v'. frechet I t1 v v' + frechet I t2 v v')\"\n| \"frechet I (Times t1 t2) v =\n    (\\<lambda>v'. sterm_sem I t1 v * frechet I t2 v v' + frechet I t1 v v' * sterm_sem I t2 v)\"\n| \"frechet I (Const r) v = (\\<lambda>v'. 0)\"\n| \"frechet I ($' c) v = undefined\"\n| \"frechet I (Differential d) v = undefined\""], ["", "definition directional_derivative :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a, 'c) trm \\<Rightarrow> 'c state \\<Rightarrow> real\"\nwhere \"directional_derivative I t = (\\<lambda>v. frechet I t (fst v) (snd v))\"\n\n\\<comment> \\<open>Sem for terms that are allowed to contain differentials.\\<close>\n\\<comment> \\<open>Note there is some duplication with \\<open>sterm_sem\\<close>.\\<close>"], ["", "primrec dterm_sem :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a, 'c) trm \\<Rightarrow> 'c state \\<Rightarrow> real\"\nwhere\n  \"dterm_sem I (Var x) = (\\<lambda>v. fst v $ x)\"\n| \"dterm_sem I (DiffVar x) = (\\<lambda>v. snd v $ x)\"\n| \"dterm_sem I (Function f args) = (\\<lambda>v. Functions I f (\\<chi> i. dterm_sem I (args i) v))\"\n| \"dterm_sem I (Plus t1 t2) = (\\<lambda>v. (dterm_sem I t1 v) + (dterm_sem I t2 v))\"\n| \"dterm_sem I (Times t1 t2) = (\\<lambda>v. (dterm_sem I t1 v) * (dterm_sem I t2 v))\"\n| \"dterm_sem I (Differential t) = (\\<lambda>v. directional_derivative I t v)\"\n| \"dterm_sem I (Const c) = (\\<lambda>v. c)\""], ["", "text\\<open> The semantics of an ODE is the vector field at a given point. ODE's are all time-independent\n  so no time variable is necessary. Terms on the RHS of an ODE must be differential-free, so\n  depends only on the xs.\n\n  The safety predicate \\texttt{osafe} ensures the domains of ODE1 and ODE2 are disjoint, so vector addition\n  is equivalent to saying \"take things defined from ODE1 from ODE1, take things defined\n  by ODE2 from ODE2\"\\<close>"], ["", "fun ODE_sem:: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a, 'c) ODE \\<Rightarrow> 'c Rvec \\<Rightarrow> 'c Rvec\"\n  where\n  ODE_sem_OVar:\"ODE_sem I (OVar x) = ODEs I x\"\n| ODE_sem_OSing:\"ODE_sem I (OSing x \\<theta>) =  (\\<lambda>\\<nu>. (\\<chi> i. if i = x then sterm_sem I \\<theta> \\<nu> else 0))\"\n\\<comment> \\<open>Note: Could define using \\<open>SOME\\<close> operator in a way that more closely matches above description,\\<close>\n\\<comment> \\<open>but that gets complicated in the \\<open>OVar\\<close> case because not all variables are bound by the \\<open>OVar\\<close>\\<close>\n| ODE_sem_OProd:\"ODE_sem I (OProd ODE1 ODE2) = (\\<lambda>\\<nu>. ODE_sem I ODE1 \\<nu> + ODE_sem I ODE2 \\<nu>)\"\n\n\\<comment> \\<open>The bound variables of an ODE\\<close>"], ["", "fun ODE_vars :: \"('a,'b,'c) interp \\<Rightarrow> ('a, 'c) ODE \\<Rightarrow> 'c set\"\n  where \n  \"ODE_vars I (OVar c) = ODEBV I c\"\n| \"ODE_vars I (OSing x \\<theta>) = {x}\"\n| \"ODE_vars I (OProd ODE1 ODE2) = ODE_vars I ODE1 \\<union> ODE_vars I ODE2\""], ["", "fun semBV ::\"('a, 'b,'c) interp \\<Rightarrow> ('a, 'c) ODE \\<Rightarrow> ('c + 'c) set\"\n  where \"semBV I ODE = Inl ` (ODE_vars I ODE) \\<union> Inr ` (ODE_vars I ODE)\""], ["", "lemma ODE_vars_lr:\n  fixes x::\"'sz\" and ODE::\"('sf,'sz) ODE\" and I::\"('sf,'sc,'sz) interp\"\n  shows \"Inl x \\<in> semBV I ODE \\<longleftrightarrow> Inr x \\<in> semBV I ODE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Inl x \\<in> semBV I ODE) = (Inr x \\<in> semBV I ODE)", "by (induction \"ODE\", auto)"], ["", "fun mk_xode::\"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a::finite, 'c::finite) ODE \\<Rightarrow> 'c::finite simple_state \\<Rightarrow> 'c::finite state\"\nwhere \"mk_xode I ODE sol = (sol, ODE_sem I ODE sol)\""], ["", "text\\<open> Given an initial state $\\nu$ and solution to an ODE at some point, construct the resulting state $\\omega$.\n  This is defined using the SOME operator because the concrete definition is unwieldy. \\<close>"], ["", "definition mk_v::\"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a::finite, 'c::finite) ODE \\<Rightarrow> 'c::finite state \\<Rightarrow> 'c::finite simple_state \\<Rightarrow> 'c::finite state\"\nwhere \"mk_v I ODE \\<nu> sol = (THE \\<omega>. \n  Vagree \\<omega> \\<nu> (- semBV I ODE) \n\\<and> Vagree \\<omega> (mk_xode I ODE sol) (semBV I ODE))\"\n\n\\<comment> \\<open>\\<open>repv \\<nu> x r\\<close> replaces the value of (unprimed) variable \\<open>x\\<close> in the state \\<open>\\<nu>\\<close> with r\\<close>"], ["", "fun repv :: \"'c::finite state \\<Rightarrow> 'c \\<Rightarrow> real \\<Rightarrow> 'c state\"\nwhere \"repv v x r = ((\\<chi> y. if x = y then r else vec_nth (fst v) y), snd v)\"\n\n\\<comment> \\<open>\\<open>repd \\<nu> x' r\\<close> replaces the value of (primed) variable \\<open>x'\\<close> in the state \\<open>\\<nu>\\<close> with \\<open>r\\<close>\\<close>"], ["", "fun repd :: \"'c::finite state \\<Rightarrow> 'c \\<Rightarrow> real \\<Rightarrow> 'c state\"\nwhere \"repd v x r = (fst v, (\\<chi> y. if x = y then r else vec_nth (snd v) y))\"  \n  \n\\<comment> \\<open>Semantics for formulas, differential formulas, programs.\\<close>"], ["", "fun fml_sem  :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a::finite, 'b::finite, 'c::finite) formula \\<Rightarrow> 'c::finite state set\" and\n  prog_sem :: \"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a::finite, 'b::finite, 'c::finite) hp \\<Rightarrow> ('c::finite state * 'c::finite state) set\"\nwhere\n  \"fml_sem I (Geq t1 t2) = {v. dterm_sem I t1 v \\<ge> dterm_sem I t2 v}\"\n| \"fml_sem I (Prop P terms) = {\\<nu>. Predicates I P (\\<chi> i. dterm_sem I (terms i) \\<nu>)}\"\n| \"fml_sem I (Not \\<phi>) = {v. v \\<notin> fml_sem I \\<phi>}\"\n| \"fml_sem I (And \\<phi> \\<psi>) = fml_sem I \\<phi> \\<inter> fml_sem I \\<psi>\"\n| \"fml_sem I (Exists x \\<phi>) = {v | v r. (repv v x r) \\<in> fml_sem I \\<phi>}\"\n| \"fml_sem I (Diamond \\<alpha> \\<phi>) = {\\<nu> | \\<nu> \\<omega>. (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<and> \\<omega> \\<in> fml_sem I \\<phi>}\"\n| \"fml_sem I (InContext c \\<phi>) = Contexts I c (fml_sem I \\<phi>)\"\n\n| \"prog_sem I (Pvar p) = Programs I p\"\n| \"prog_sem I (Assign x t) = {(\\<nu>, \\<omega>). \\<omega> = repv \\<nu> x (dterm_sem I t \\<nu>)}\"\n| \"prog_sem I (DiffAssign x t) = {(\\<nu>, \\<omega>). \\<omega> = repd \\<nu> x (dterm_sem I t \\<nu>)}\"\n| \"prog_sem I (Test \\<phi>) = {(\\<nu>, \\<nu>) | \\<nu>. \\<nu> \\<in> fml_sem I \\<phi>}\"\n| \"prog_sem I (Choice \\<alpha> \\<beta>) = prog_sem I \\<alpha> \\<union> prog_sem I \\<beta>\"\n| \"prog_sem I (Sequence \\<alpha> \\<beta>) = prog_sem I \\<alpha> O prog_sem I \\<beta>\"\n| \"prog_sem I (Loop \\<alpha>) = (prog_sem I \\<alpha>)\\<^sup>*\"\n| \"prog_sem I (EvolveODE ODE \\<phi>) =\n  ({(\\<nu>, mk_v I ODE \\<nu> (sol t)) | \\<nu> sol t.\n      t \\<ge> 0 \\<and>\n      (sol solves_ode (\\<lambda>_. ODE_sem I ODE)) {0..t} {x. mk_v I ODE \\<nu> x \\<in> fml_sem I \\<phi>} \\<and>\n      sol 0 = fst \\<nu>})\""], ["", "context ids begin"], ["", "definition valid :: \"('sf, 'sc, 'sz) formula \\<Rightarrow> bool\"\nwhere \"valid \\<phi> \\<equiv> (\\<forall> I. \\<forall> \\<nu>. is_interp I \\<longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>)\""], ["", "end"], ["", "text\\<open> Because mk\\_v is defined with the SOME operator, need to construct a state that satisfies\n    ${\\tt Vagree} \\omega \\nu (- {\\tt ODE\\_vars\\ ODE}) \n     \\wedge {\\tt Vagree} \\omega {\\tt (mk\\_xode\\ I\\ ODE\\ sol)\\ (ODE\\_vars\\ ODE)})$\n    to do anything useful \\<close>"], ["", "fun concrete_v::\"('a::finite, 'b::finite, 'c::finite) interp \\<Rightarrow> ('a::finite, 'c::finite) ODE \\<Rightarrow> 'c::finite state \\<Rightarrow> 'c::finite simple_state \\<Rightarrow> 'c::finite state\"\nwhere \"concrete_v I ODE \\<nu> sol =\n((\\<chi> i. (if Inl i \\<in> semBV I ODE then sol else (fst \\<nu>)) $ i),\n (\\<chi> i. (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol else (snd \\<nu>)) $ i))\""], ["", "lemma mk_v_exists:\"\\<exists>\\<omega>. Vagree \\<omega> \\<nu> (- semBV I ODE) \n\\<and> Vagree \\<omega> (mk_xode I ODE sol) (semBV I ODE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<omega>.\n       Vagree \\<omega> \\<nu> (- semBV I ODE) \\<and>\n       Vagree \\<omega> (mk_xode I ODE sol) (semBV I ODE)", "by(rule exI[where x=\"(concrete_v I ODE \\<nu> sol)\"], auto simp add: Vagree_def)"], ["", "lemma mk_v_agree:\"Vagree (mk_v I ODE \\<nu> sol) \\<nu> (- semBV I ODE) \n\\<and> Vagree (mk_v I ODE \\<nu> sol) (mk_xode I ODE sol) (semBV I ODE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vagree (mk_v I ODE \\<nu> sol) \\<nu> (- semBV I ODE) \\<and>\n    Vagree (mk_v I ODE \\<nu> sol) (mk_xode I ODE sol) (semBV I ODE)", "unfolding mk_v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vagree\n     (THE \\<omega>.\n         Vagree \\<omega> \\<nu> (- semBV I ODE) \\<and>\n         Vagree \\<omega> (mk_xode I ODE sol) (semBV I ODE))\n     \\<nu> (- semBV I ODE) \\<and>\n    Vagree\n     (THE \\<omega>.\n         Vagree \\<omega> \\<nu> (- semBV I ODE) \\<and>\n         Vagree \\<omega> (mk_xode I ODE sol) (semBV I ODE))\n     (mk_xode I ODE sol) (semBV I ODE)", "apply(rule theI[where a= \"((\\<chi> i. (if Inl i \\<in> semBV I ODE then sol else (fst \\<nu>)) $ i),\n  (\\<chi> i. (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol else (snd \\<nu>)) $ i))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Vagree\n     (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n      \\<chi>i.\n         (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n          else snd \\<nu>) $\n         i)\n     \\<nu> (- semBV I ODE) \\<and>\n    Vagree\n     (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n      \\<chi>i.\n         (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n          else snd \\<nu>) $\n         i)\n     (mk_xode I ODE sol) (semBV I ODE)\n 2. \\<And>x.\n       Vagree x \\<nu> (- semBV I ODE) \\<and>\n       Vagree x (mk_xode I ODE sol) (semBV I ODE) \\<Longrightarrow>\n       x =\n       (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n        \\<chi>i.\n           (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n            else snd \\<nu>) $\n           i)", "using exE[OF mk_v_exists, of \\<nu> I ODE sol]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      Vagree x \\<nu> (- semBV I ODE) \\<and>\n      Vagree x (mk_xode I ODE sol) (semBV I ODE) \\<Longrightarrow>\n      ?Q) \\<Longrightarrow>\n  ?Q\n\ngoal (2 subgoals):\n 1. Vagree\n     (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n      \\<chi>i.\n         (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n          else snd \\<nu>) $\n         i)\n     \\<nu> (- semBV I ODE) \\<and>\n    Vagree\n     (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n      \\<chi>i.\n         (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n          else snd \\<nu>) $\n         i)\n     (mk_xode I ODE sol) (semBV I ODE)\n 2. \\<And>x.\n       Vagree x \\<nu> (- semBV I ODE) \\<and>\n       Vagree x (mk_xode I ODE sol) (semBV I ODE) \\<Longrightarrow>\n       x =\n       (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n        \\<chi>i.\n           (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n            else snd \\<nu>) $\n           i)", "by (auto simp add: Vagree_def vec_eq_iff)"], ["", "lemma mk_v_concrete:\"mk_v I ODE \\<nu> sol = ((\\<chi> i. (if Inl i \\<in> semBV I ODE then sol else (fst \\<nu>)) $ i),\n  (\\<chi> i. (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol else (snd \\<nu>)) $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_v I ODE \\<nu> sol =\n    (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n     \\<chi>i.\n        (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol else snd \\<nu>) $\n        i)", "apply(rule agree_UNIV_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vagree (mk_v I ODE \\<nu> sol)\n     (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n      \\<chi>i.\n         (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n          else snd \\<nu>) $\n         i)\n     UNIV", "using mk_v_agree[of I ODE \\<nu> sol]"], ["proof (prove)\nusing this:\n  Vagree (mk_v I ODE \\<nu> sol) \\<nu> (- semBV I ODE) \\<and>\n  Vagree (mk_v I ODE \\<nu> sol) (mk_xode I ODE sol) (semBV I ODE)\n\ngoal (1 subgoal):\n 1. Vagree (mk_v I ODE \\<nu> sol)\n     (\\<chi>i. (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n      \\<chi>i.\n         (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n          else snd \\<nu>) $\n         i)\n     UNIV", "unfolding Vagree_def"], ["proof (prove)\nusing this:\n  ((\\<forall>i.\n       Inl i \\<in> - semBV I ODE \\<longrightarrow>\n       fst (mk_v I ODE \\<nu> sol) $ i = fst \\<nu> $ i) \\<and>\n   (\\<forall>i.\n       Inr i \\<in> - semBV I ODE \\<longrightarrow>\n       snd (mk_v I ODE \\<nu> sol) $ i = snd \\<nu> $ i)) \\<and>\n  (\\<forall>i.\n      Inl i \\<in> semBV I ODE \\<longrightarrow>\n      fst (mk_v I ODE \\<nu> sol) $ i = fst (mk_xode I ODE sol) $ i) \\<and>\n  (\\<forall>i.\n      Inr i \\<in> semBV I ODE \\<longrightarrow>\n      snd (mk_v I ODE \\<nu> sol) $ i = snd (mk_xode I ODE sol) $ i)\n\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        Inl i \\<in> UNIV \\<longrightarrow>\n        fst (mk_v I ODE \\<nu> sol) $ i =\n        fst (\\<chi>i.\n                (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n             \\<chi>i.\n                (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n                 else snd \\<nu>) $\n                i) $\n        i) \\<and>\n    (\\<forall>i.\n        Inr i \\<in> UNIV \\<longrightarrow>\n        snd (mk_v I ODE \\<nu> sol) $ i =\n        snd (\\<chi>i.\n                (if Inl i \\<in> semBV I ODE then sol else fst \\<nu>) $ i,\n             \\<chi>i.\n                (if Inr i \\<in> semBV I ODE then ODE_sem I ODE sol\n                 else snd \\<nu>) $\n                i) $\n        i)", "by auto"], ["", "subsection \\<open>Trivial Simplification Lemmas\\<close>"], ["", "text \\<open>\n We often want to pretend the definitions in the semantics are written slightly\n differently than they are. Since the simplifier has some trouble guessing that\n these are the right simplifications to do, we write them all out explicitly as\n lemmas, even though they prove trivially.\n\\<close>"], ["", "lemma svar_case:\n  \"sterm_sem I (Var x) = (\\<lambda>v. v $ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_sem I (Var x) = (\\<lambda>v. v $ x)", "by auto"], ["", "lemma sconst_case:\n  \"sterm_sem I (Const r) = (\\<lambda>v. r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_sem I (Const r) = (\\<lambda>v. r)", "by auto"], ["", "lemma sfunction_case:\n  \"sterm_sem I (Function f args) = (\\<lambda>v. Functions I f (\\<chi> i. sterm_sem I (args i) v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_sem I ($f f args) =\n    (\\<lambda>v. Functions I f (\\<chi>i. sterm_sem I (args i) v))", "by auto"], ["", "lemma splus_case:\n  \"sterm_sem I (Plus t1 t2) = (\\<lambda>v. (sterm_sem I t1 v) + (sterm_sem I t2 v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_sem I (Plus t1 t2) =\n    (\\<lambda>v. sterm_sem I t1 v + sterm_sem I t2 v)", "by auto"], ["", "lemma stimes_case:\n  \"sterm_sem I (Times t1 t2) = (\\<lambda>v. (sterm_sem I t1 v) * (sterm_sem I t2 v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_sem I (Times t1 t2) =\n    (\\<lambda>v. sterm_sem I t1 v * sterm_sem I t2 v)", "by auto"], ["", "lemma or_sem [simp]:\n  \"fml_sem I (Or \\<phi> \\<psi>) = fml_sem I \\<phi> \\<union> fml_sem I \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I (\\<phi> || \\<psi>) =\n    fml_sem I \\<phi> \\<union> fml_sem I \\<psi>", "by (auto simp add: Or_def)"], ["", "lemma iff_sem [simp]: \"(\\<nu> \\<in> fml_sem I (A \\<leftrightarrow> B))\n  \\<longleftrightarrow> ((\\<nu> \\<in> fml_sem I A) \\<longleftrightarrow> (\\<nu> \\<in> fml_sem I B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> \\<in> fml_sem I (A \\<leftrightarrow> B)) =\n    ((\\<nu> \\<in> fml_sem I A) = (\\<nu> \\<in> fml_sem I B))", "by (auto simp add: Equiv_def)"], ["", "lemma box_sem [simp]:\"fml_sem I (Box \\<alpha> \\<phi>) = {\\<nu>. \\<forall> \\<omega>. (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<longrightarrow> \\<omega> \\<in> fml_sem I \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I ([[\\<alpha>]]\\<phi>) =\n    {\\<nu>.\n     \\<forall>\\<omega>.\n        (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<longrightarrow>\n        \\<omega> \\<in> fml_sem I \\<phi>}", "unfolding Box_def fml_sem.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. v \\<notin> {uu_.\n                    \\<exists>\\<nu> \\<omega>.\n                       uu_ = \\<nu> \\<and>\n                       (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<and>\n                       \\<omega> \\<in> {v. v \\<notin> fml_sem I \\<phi>}}} =\n    {\\<nu>.\n     \\<forall>\\<omega>.\n        (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<longrightarrow>\n        \\<omega> \\<in> fml_sem I \\<phi>}", "using Collect_cong"], ["proof (prove)\nusing this:\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n\ngoal (1 subgoal):\n 1. {v. v \\<notin> {uu_.\n                    \\<exists>\\<nu> \\<omega>.\n                       uu_ = \\<nu> \\<and>\n                       (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<and>\n                       \\<omega> \\<in> {v. v \\<notin> fml_sem I \\<phi>}}} =\n    {\\<nu>.\n     \\<forall>\\<omega>.\n        (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<longrightarrow>\n        \\<omega> \\<in> fml_sem I \\<phi>}", "by (auto)"], ["", "lemma forall_sem [simp]:\"fml_sem I (Forall x \\<phi>) = {v. \\<forall>r. (repv v x r) \\<in> fml_sem I \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I (Forall x \\<phi>) =\n    {v. \\<forall>r. repv v x r \\<in> fml_sem I \\<phi>}", "unfolding Forall_def fml_sem.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. v \\<notin> {uu_.\n                    \\<exists>v r.\n                       uu_ = v \\<and>\n                       repv v x r \\<in> {v. v \\<notin> fml_sem I \\<phi>}}} =\n    {v. \\<forall>r. repv v x r \\<in> fml_sem I \\<phi>}", "using Collect_cong"], ["proof (prove)\nusing this:\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n\ngoal (1 subgoal):\n 1. {v. v \\<notin> {uu_.\n                    \\<exists>v r.\n                       uu_ = v \\<and>\n                       repv v x r \\<in> {v. v \\<notin> fml_sem I \\<phi>}}} =\n    {v. \\<forall>r. repv v x r \\<in> fml_sem I \\<phi>}", "by (auto)"], ["", "lemma greater_sem[simp]:\"fml_sem I (Greater \\<theta> \\<theta>') = {v. dterm_sem I \\<theta> v > dterm_sem I \\<theta>' v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I (Greater \\<theta> \\<theta>') =\n    {v. dterm_sem I \\<theta>' v < dterm_sem I \\<theta> v}", "unfolding Greater_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I (Geq \\<theta> \\<theta>' && ! (Geq \\<theta>' \\<theta>)) =\n    {v. dterm_sem I \\<theta>' v < dterm_sem I \\<theta> v}", "by auto"], ["", "lemma loop_sem:\"prog_sem I (Loop \\<alpha>) = (prog_sem I \\<alpha>)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog_sem I \\<alpha>** = (prog_sem I \\<alpha>)\\<^sup>*", "by (auto)"], ["", "lemma impl_sem [simp]: \"(\\<nu> \\<in> fml_sem I (A \\<rightarrow> B))\n  = ((\\<nu> \\<in> fml_sem I A) \\<longrightarrow> (\\<nu> \\<in> fml_sem I B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> \\<in> fml_sem I (A \\<rightarrow> B)) =\n    (\\<nu> \\<in> fml_sem I A \\<longrightarrow> \\<nu> \\<in> fml_sem I B)", "by (auto simp add: Implies_def)"], ["", "lemma equals_sem [simp]: \"(\\<nu> \\<in> fml_sem I (Equals \\<theta> \\<theta>'))\n  = (dterm_sem I \\<theta> \\<nu> = dterm_sem I \\<theta>' \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> \\<in> fml_sem I (Equals \\<theta> \\<theta>')) =\n    (dterm_sem I \\<theta> \\<nu> = dterm_sem I \\<theta>' \\<nu>)", "by (auto simp add: Equals_def)"], ["", "lemma diamond_sem [simp]: \"fml_sem I (Diamond \\<alpha> \\<phi>)\n  = {\\<nu>. \\<exists> \\<omega>. (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<and> \\<omega> \\<in> fml_sem I \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I (\\<langle> \\<alpha> \\<rangle> \\<phi>) =\n    {\\<nu>.\n     \\<exists>\\<omega>.\n        (\\<nu>, \\<omega>) \\<in> prog_sem I \\<alpha> \\<and>\n        \\<omega> \\<in> fml_sem I \\<phi>}", "by auto"], ["", "lemma tt_sem [simp]:\"fml_sem I TT = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I TT = UNIV", "unfolding TT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I (Geq (Const 0) (Const 0)) = UNIV", "by auto"], ["", "lemma ff_sem [simp]:\"fml_sem I FF = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I FF = {}", "unfolding FF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem I (Geq (Const 0) (Const 1)) = {}", "by auto"], ["", "lemma iff_to_impl: \"((\\<nu> \\<in> fml_sem I A) \\<longleftrightarrow> (\\<nu> \\<in> fml_sem I B))\n  \\<longleftrightarrow> (((\\<nu> \\<in> fml_sem I A) \\<longrightarrow> (\\<nu> \\<in> fml_sem I B))\n     \\<and> ((\\<nu> \\<in> fml_sem I B) \\<longrightarrow> (\\<nu> \\<in> fml_sem I A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<nu> \\<in> fml_sem I A) = (\\<nu> \\<in> fml_sem I B)) =\n    ((\\<nu> \\<in> fml_sem I A \\<longrightarrow>\n      \\<nu> \\<in> fml_sem I B) \\<and>\n     (\\<nu> \\<in> fml_sem I B \\<longrightarrow> \\<nu> \\<in> fml_sem I A))", "by (auto)"], ["", "fun seq2fml :: \"('a,'b,'c) sequent \\<Rightarrow> ('a,'b,'c) formula\"\nwhere\n  \"seq2fml (ante,succ) = Implies (foldr And ante TT) (foldr Or succ FF)\""], ["", "context ids begin"], ["", "fun seq_sem ::\"('sf, 'sc, 'sz) interp \\<Rightarrow> ('sf, 'sc, 'sz) sequent \\<Rightarrow> 'sz state set\"\nwhere \"seq_sem I S = fml_sem I (seq2fml S)\""], ["", "lemma and_foldl_sem:\"\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> (\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT) \\<Longrightarrow>\n    (\\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>)", "by(induction \\<Gamma>, auto simp add: member_rec)"], ["", "lemma and_foldl_sem_conv:\"(\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n    \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)", "by(induction \\<Gamma>, auto simp add: member_rec)"], ["", "lemma or_foldl_sem:\"List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Gamma> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member \\<Gamma> \\<phi>;\n     \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF)", "by(induction \\<Gamma>, auto simp add: member_rec)"], ["", "lemma or_foldl_sem_conv:\"\\<nu> \\<in> fml_sem I (foldr Or \\<Gamma> FF) \\<Longrightarrow> \\<exists> \\<phi>. \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<in> fml_sem I (foldr (||) \\<Gamma> FF) \\<Longrightarrow>\n    \\<exists>\\<phi>.\n       \\<nu> \\<in> fml_sem I \\<phi> \\<and> List.member \\<Gamma> \\<phi>", "by(induction \\<Gamma>, auto simp add: member_rec)"], ["", "lemma seq_semI':\"(\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Delta> FF)) \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)) \\<Longrightarrow>\n    \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "by auto"], ["", "lemma seq_semD':\"\\<And>P. \\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>) \\<Longrightarrow> ((\\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Delta> FF)) \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n        (\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT) \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)) \\<Longrightarrow>\n        P\\<rbrakk>\n       \\<Longrightarrow> P", "by simp"], ["", "definition sublist::\"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\nwhere \"sublist A B \\<equiv> (\\<forall>x. List.member A x \\<longrightarrow> List.member B x)\""], ["", "lemma sublistI:\"(\\<And>x. List.member A x \\<Longrightarrow> List.member B x) \\<Longrightarrow> sublist A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        List.member A x \\<Longrightarrow> List.member B x) \\<Longrightarrow>\n    sublist A B", "unfolding sublist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        List.member A x \\<Longrightarrow> List.member B x) \\<Longrightarrow>\n    \\<forall>x. List.member A x \\<longrightarrow> List.member B x", "by auto"], ["", "lemma \\<Gamma>_sub_sem:\"sublist \\<Gamma>1 \\<Gamma>2 \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma>2 TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma>1 TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sublist \\<Gamma>1 \\<Gamma>2;\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT)", "unfolding sublist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                List.member \\<Gamma>1 x \\<longrightarrow>\n                List.member \\<Gamma>2 x;\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>2 TT)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma>1 TT)", "by (metis and_foldl_sem and_foldl_sem_conv)"], ["", "lemma seq_semI:\"List.member \\<Delta> \\<psi> \\<Longrightarrow>((\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<psi>) \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member \\<Delta> \\<psi>;\n     (\\<And>\\<phi>.\n         List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I \\<psi>\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>)", "apply(rule seq_semI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member \\<Delta> \\<psi>;\n     (\\<And>\\<phi>.\n         List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I \\<psi>;\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "using and_foldl_sem[of \\<nu> I \\<Gamma>] or_foldl_sem"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT);\n   List.member \\<Gamma> ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<nu> \\<in> fml_sem I ?\\<phi>\n  \\<lbrakk>List.member ?\\<Gamma> ?\\<phi>;\n   ?\\<nu> \\<in> fml_sem ?I ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member \\<Delta> \\<psi>;\n     (\\<And>\\<phi>.\n         List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n         \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow>\n     \\<nu> \\<in> fml_sem I \\<psi>;\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by blast"], ["", "lemma seq_semD:\"\\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>) \\<Longrightarrow> (\\<And>\\<phi>. List.member \\<Gamma> \\<phi> \\<Longrightarrow> \\<nu> \\<in> fml_sem I \\<phi>) \\<Longrightarrow> \\<exists>\\<phi>. (List.member \\<Delta> \\<phi>) \\<and>\\<nu> \\<in> fml_sem I \\<phi> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>.\n                         List.member \\<Delta> \\<phi> \\<and>\n                         \\<nu> \\<in> fml_sem I \\<phi>", "apply(rule seq_semD')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n 2. \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>;\n     ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT) \\<Longrightarrow>\n     ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>.\n                         List.member \\<Delta> \\<phi> \\<and>\n                         \\<nu> \\<in> fml_sem I \\<phi>", "using and_foldl_sem_conv or_foldl_sem_conv"], ["proof (prove)\nusing this:\n  (\\<And>\\<phi>.\n      List.member ?\\<Gamma> \\<phi> \\<Longrightarrow>\n      ?\\<nu> \\<in> fml_sem ?I \\<phi>) \\<Longrightarrow>\n  ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT)\n  ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Gamma> FF) \\<Longrightarrow>\n  \\<exists>\\<phi>.\n     ?\\<nu> \\<in> fml_sem ?I \\<phi> \\<and> List.member ?\\<Gamma> \\<phi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ?\\<nu> \\<in> seq_sem ?I (?\\<Gamma>, ?\\<Delta>)\n 2. \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<And>\\<phi>.\n        List.member \\<Gamma> \\<phi> \\<Longrightarrow>\n        \\<nu> \\<in> fml_sem I \\<phi>;\n     ?\\<nu> \\<in> fml_sem ?I (foldr (&&) ?\\<Gamma> TT) \\<Longrightarrow>\n     ?\\<nu> \\<in> fml_sem ?I (foldr (||) ?\\<Delta> FF)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>.\n                         List.member \\<Delta> \\<phi> \\<and>\n                         \\<nu> \\<in> fml_sem I \\<phi>", "by blast+"], ["", "lemma seq_MP:\"\\<nu> \\<in> seq_sem I (\\<Gamma>,\\<Delta>) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr And \\<Gamma> TT) \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr Or \\<Delta> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nu> \\<in> seq_sem I (\\<Gamma>, \\<Delta>);\n     \\<nu> \\<in> fml_sem I (foldr (&&) \\<Gamma> TT)\\<rbrakk>\n    \\<Longrightarrow> \\<nu> \\<in> fml_sem I (foldr (||) \\<Delta> FF)", "by(induction \\<Delta>, auto)"], ["", "definition seq_valid\nwhere \"seq_valid S \\<equiv> \\<forall>I. is_interp I \\<longrightarrow> seq_sem I S = UNIV\""], ["", "text\\<open> Soundness for derived rules is local soundness, i.e. if the premisses are all true in the same interpretation,\n  then the conclusion is also true in that same interpretation. \\<close>"], ["", "definition sound :: \"('sf, 'sc, 'sz) rule \\<Rightarrow> bool\"\nwhere \"sound R \\<longleftrightarrow> (\\<forall>I. is_interp I \\<longrightarrow> (\\<forall>i. i \\<ge> 0 \\<longrightarrow> i < length (fst R) \\<longrightarrow> seq_sem I (nth (fst R) i) = UNIV) \\<longrightarrow> seq_sem I (snd R) = UNIV)\""], ["", "lemma soundI:\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>i. i \\<ge> 0 \\<Longrightarrow> i < length SG \\<Longrightarrow> seq_sem I (nth SG i) = UNIV) \\<Longrightarrow> seq_sem I G = UNIV) \\<Longrightarrow> sound (SG,G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>is_interp I;\n         \\<And>i.\n            \\<lbrakk>0 \\<le> i; i < length SG\\<rbrakk>\n            \\<Longrightarrow> seq_sem I (SG ! i) = UNIV\\<rbrakk>\n        \\<Longrightarrow> seq_sem I G = UNIV) \\<Longrightarrow>\n    sound (SG, G)", "unfolding sound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>is_interp I;\n         \\<And>i.\n            \\<lbrakk>0 \\<le> i; i < length SG\\<rbrakk>\n            \\<Longrightarrow> seq_sem I (SG ! i) = UNIV\\<rbrakk>\n        \\<Longrightarrow> seq_sem I G = UNIV) \\<Longrightarrow>\n    \\<forall>I.\n       is_interp I \\<longrightarrow>\n       (\\<forall>i\\<ge>0.\n           i < length (fst (SG, G)) \\<longrightarrow>\n           seq_sem I (fst (SG, G) ! i) = UNIV) \\<longrightarrow>\n       seq_sem I (snd (SG, G)) = UNIV", "by auto"], ["", "lemma soundI':\"(\\<And>I \\<nu>. is_interp I \\<Longrightarrow> (\\<And>i . i \\<ge> 0 \\<Longrightarrow> i < length SG \\<Longrightarrow> \\<nu> \\<in> seq_sem I (nth SG i)) \\<Longrightarrow> \\<nu> \\<in> seq_sem I G) \\<Longrightarrow> sound (SG,G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I \\<nu>.\n        \\<lbrakk>is_interp I;\n         \\<And>i.\n            \\<lbrakk>0 \\<le> i; i < length SG\\<rbrakk>\n            \\<Longrightarrow> \\<nu> \\<in> seq_sem I (SG ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I G) \\<Longrightarrow>\n    sound (SG, G)", "unfolding sound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I \\<nu>.\n        \\<lbrakk>is_interp I;\n         \\<And>i.\n            \\<lbrakk>0 \\<le> i; i < length SG\\<rbrakk>\n            \\<Longrightarrow> \\<nu> \\<in> seq_sem I (SG ! i)\\<rbrakk>\n        \\<Longrightarrow> \\<nu> \\<in> seq_sem I G) \\<Longrightarrow>\n    \\<forall>I.\n       is_interp I \\<longrightarrow>\n       (\\<forall>i\\<ge>0.\n           i < length (fst (SG, G)) \\<longrightarrow>\n           seq_sem I (fst (SG, G) ! i) = UNIV) \\<longrightarrow>\n       seq_sem I (snd (SG, G)) = UNIV", "by auto"], ["", "lemma soundI_mem:\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi>. List.member SG \\<phi> \\<Longrightarrow> seq_sem I \\<phi> = UNIV) \\<Longrightarrow> seq_sem I C = UNIV) \\<Longrightarrow> sound (SG,C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>is_interp I;\n         \\<And>\\<phi>.\n            List.member SG \\<phi> \\<Longrightarrow>\n            seq_sem I \\<phi> = UNIV\\<rbrakk>\n        \\<Longrightarrow> seq_sem I C = UNIV) \\<Longrightarrow>\n    sound (SG, C)", "apply (auto simp add: sound_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I a b.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_interp I;\n                    \\<And>a b.\n                       List.member SG (a, b) \\<Longrightarrow>\n                       fml_sem I\n                        (foldr (&&) a TT \\<rightarrow> foldr (||) b FF) =\n                       UNIV\\<rbrakk>\n                   \\<Longrightarrow> fml_sem I (seq2fml C) = UNIV;\n        is_interp I;\n        \\<forall>i<length SG. fml_sem I (seq2fml (SG ! i)) = UNIV\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> fml_sem I (seq2fml C)", "by (metis in_set_conv_nth in_set_member iso_tuple_UNIV_I seq2fml.simps)"], ["", "lemma soundI_memv:\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi> \\<nu>. List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>) \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C)) \\<Longrightarrow> sound (SG,C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>is_interp I;\n         \\<And>\\<phi> \\<nu>.\n            List.member SG \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> (\\<And>\\<nu>.\n                              \\<nu> \\<in> seq_sem I C)) \\<Longrightarrow>\n    sound (SG, C)", "apply(rule soundI_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>\\<And>I \\<nu>.\n                   \\<lbrakk>is_interp I;\n                    \\<And>\\<phi> \\<nu>.\n                       List.member SG \\<phi> \\<Longrightarrow>\n                       \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<nu> \\<in> seq_sem I C;\n        is_interp I;\n        \\<And>\\<phi>.\n           List.member SG \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "using impl_sem"], ["proof (prove)\nusing this:\n  (?\\<nu> \\<in> fml_sem ?I (?A \\<rightarrow> ?B)) =\n  (?\\<nu> \\<in> fml_sem ?I ?A \\<longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?B)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>\\<And>I \\<nu>.\n                   \\<lbrakk>is_interp I;\n                    \\<And>\\<phi> \\<nu>.\n                       List.member SG \\<phi> \\<Longrightarrow>\n                       \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> \\<nu> \\<in> seq_sem I C;\n        is_interp I;\n        \\<And>\\<phi>.\n           List.member SG \\<phi> \\<Longrightarrow>\n           seq_sem I \\<phi> = UNIV\\<rbrakk>\n       \\<Longrightarrow> seq_sem I C = UNIV", "by blast"], ["", "lemma soundI_memv':\"(\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi> \\<nu>. List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>) \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C)) \\<Longrightarrow> R = (SG,C) \\<Longrightarrow> sound R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>is_interp I;\n                 \\<And>\\<phi> \\<nu>.\n                    List.member SG \\<phi> \\<Longrightarrow>\n                    \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n                \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C);\n     R = (SG, C)\\<rbrakk>\n    \\<Longrightarrow> sound R", "using  soundI_mem"], ["proof (prove)\nusing this:\n  (\\<And>I.\n      \\<lbrakk>is_interp I;\n       \\<And>\\<phi>.\n          List.member ?SG \\<phi> \\<Longrightarrow>\n          seq_sem I \\<phi> = UNIV\\<rbrakk>\n      \\<Longrightarrow> seq_sem I ?C = UNIV) \\<Longrightarrow>\n  sound (?SG, ?C)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>is_interp I;\n                 \\<And>\\<phi> \\<nu>.\n                    List.member SG \\<phi> \\<Longrightarrow>\n                    \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n                \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C);\n     R = (SG, C)\\<rbrakk>\n    \\<Longrightarrow> sound R", "using impl_sem"], ["proof (prove)\nusing this:\n  (\\<And>I.\n      \\<lbrakk>is_interp I;\n       \\<And>\\<phi>.\n          List.member ?SG \\<phi> \\<Longrightarrow>\n          seq_sem I \\<phi> = UNIV\\<rbrakk>\n      \\<Longrightarrow> seq_sem I ?C = UNIV) \\<Longrightarrow>\n  sound (?SG, ?C)\n  (?\\<nu> \\<in> fml_sem ?I (?A \\<rightarrow> ?B)) =\n  (?\\<nu> \\<in> fml_sem ?I ?A \\<longrightarrow> ?\\<nu> \\<in> fml_sem ?I ?B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>is_interp I;\n                 \\<And>\\<phi> \\<nu>.\n                    List.member SG \\<phi> \\<Longrightarrow>\n                    \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n                \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C);\n     R = (SG, C)\\<rbrakk>\n    \\<Longrightarrow> sound R", "by blast"], ["", "lemma soundD_mem:\"sound (SG,C) \\<Longrightarrow> (\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi>. List.member SG \\<phi> \\<Longrightarrow> seq_sem I \\<phi> = UNIV) \\<Longrightarrow> seq_sem I C = UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow>\n    (\\<And>I.\n        \\<lbrakk>is_interp I;\n         \\<And>\\<phi>.\n            List.member SG \\<phi> \\<Longrightarrow>\n            seq_sem I \\<phi> = UNIV\\<rbrakk>\n        \\<Longrightarrow> seq_sem I C = UNIV)", "apply (auto simp add: sound_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I a b.\n       \\<lbrakk>\\<forall>I.\n                   is_interp I \\<longrightarrow>\n                   (\\<forall>i<length SG.\n                       fml_sem I (seq2fml (SG ! i)) =\n                       UNIV) \\<longrightarrow>\n                   fml_sem I (seq2fml C) = UNIV;\n        is_interp I;\n        \\<And>a b.\n           List.member SG (a, b) \\<Longrightarrow>\n           fml_sem I (foldr (&&) a TT \\<rightarrow> foldr (||) b FF) =\n           UNIV\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> fml_sem I (seq2fml C)", "using in_set_conv_nth in_set_member iso_tuple_UNIV_I seq2fml.simps"], ["proof (prove)\nusing this:\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  ?x \\<in> UNIV \\<equiv> True\n  seq2fml (?ante, ?succ) =\n  (foldr (&&) ?ante TT \\<rightarrow> foldr (||) ?succ FF)\n\ngoal (1 subgoal):\n 1. \\<And>I a b.\n       \\<lbrakk>\\<forall>I.\n                   is_interp I \\<longrightarrow>\n                   (\\<forall>i<length SG.\n                       fml_sem I (seq2fml (SG ! i)) =\n                       UNIV) \\<longrightarrow>\n                   fml_sem I (seq2fml C) = UNIV;\n        is_interp I;\n        \\<And>a b.\n           List.member SG (a, b) \\<Longrightarrow>\n           fml_sem I (foldr (&&) a TT \\<rightarrow> foldr (||) b FF) =\n           UNIV\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> fml_sem I (seq2fml C)", "by (metis seq2fml.elims)"], ["", "lemma soundD_memv:\"sound (SG,C) \\<Longrightarrow> (\\<And>I. is_interp I \\<Longrightarrow> (\\<And>\\<phi> \\<nu>. List.member SG \\<phi> \\<Longrightarrow> \\<nu> \\<in> seq_sem I \\<phi>) \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow>\n    (\\<And>I.\n        \\<lbrakk>is_interp I;\n         \\<And>\\<phi> \\<nu>.\n            List.member SG \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C))", "using soundD_mem"], ["proof (prove)\nusing this:\n  \\<lbrakk>sound (?SG, ?C); is_interp ?I;\n   \\<And>\\<phi>.\n      List.member ?SG \\<phi> \\<Longrightarrow>\n      seq_sem ?I \\<phi> = UNIV\\<rbrakk>\n  \\<Longrightarrow> seq_sem ?I ?C = UNIV\n\ngoal (1 subgoal):\n 1. sound (SG, C) \\<Longrightarrow>\n    (\\<And>I.\n        \\<lbrakk>is_interp I;\n         \\<And>\\<phi> \\<nu>.\n            List.member SG \\<phi> \\<Longrightarrow>\n            \\<nu> \\<in> seq_sem I \\<phi>\\<rbrakk>\n        \\<Longrightarrow> (\\<And>\\<nu>. \\<nu> \\<in> seq_sem I C))", "by (metis UNIV_I UNIV_eq_I)"], ["", "end"], ["", "end"]]}