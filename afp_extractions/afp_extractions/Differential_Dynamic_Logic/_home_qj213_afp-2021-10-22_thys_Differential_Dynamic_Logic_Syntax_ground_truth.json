{"file_name": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic/Syntax.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Differential_Dynamic_Logic", "problem_names": ["lemma sizeF_diseq:\"sizeF p \\<noteq> sizeF q \\<Longrightarrow> p \\<noteq> q\"", "lemma [expr_diseq]:\"p \\<noteq> And p q\"", "lemma [expr_diseq]:\"q \\<noteq> And p q\"", "lemma [expr_diseq]:\"p \\<noteq> Not p\"", "lemma [expr_diseq]:\"p \\<noteq> Or p q\"", "lemma [expr_diseq]:\"q \\<noteq> Or p q\"", "lemma [expr_diseq]:\"p \\<noteq> Implies p q\"", "lemma [expr_diseq]:\"q \\<noteq> Implies p q\"", "lemma [expr_diseq]:\"p \\<noteq> Equiv p q\"", "lemma [expr_diseq]:\"q \\<noteq> Equiv p q\"", "lemma [expr_diseq]:\"p \\<noteq> Exists x p\"", "lemma [expr_diseq]:\"p \\<noteq> Diamond a p\"", "lemma [expr_diseq]:\"p \\<noteq> InContext C p\"", "lemma expand_singleton:\"singleton t = (\\<lambda>i. (if i = vid1 then t else (Const 0)))\"", "lemma dfree_is_dsafe: \"dfree \\<theta> \\<Longrightarrow> dsafe \\<theta>\"", "lemma hp_induct [case_names Var Assign DiffAssign Test Evolve Choice Compose Star]:\n   \"(\\<And>x. P ($\\<alpha> x)) \\<Longrightarrow>\n    (\\<And>x1 x2. P (x1 := x2)) \\<Longrightarrow>\n    (\\<And>x1 x2. P (DiffAssign x1 x2)) \\<Longrightarrow>\n    (\\<And>x. P (? x)) \\<Longrightarrow>\n    (\\<And>x1 x2. P (EvolveODE x1 x2)) \\<Longrightarrow>\n    (\\<And>x1 x2. P x1 \\<Longrightarrow> P x2 \\<Longrightarrow> P (x1 \\<union>\\<union> x2)) \\<Longrightarrow>\n    (\\<And>x1 x2. P x1 \\<Longrightarrow> P x2 \\<Longrightarrow> P (x1 ;; x2)) \\<Longrightarrow>\n    (\\<And>x. P x \\<Longrightarrow> P x**) \\<Longrightarrow>\n     P hp\"", "lemma fml_induct:\n  \"(\\<And>t1 t2. P (Geq t1 t2))\n  \\<Longrightarrow> (\\<And>p args. P (Prop p args))\n  \\<Longrightarrow> (\\<And>p. P p \\<Longrightarrow> P (Not p))\n  \\<Longrightarrow> (\\<And>p q. P p \\<Longrightarrow> P q \\<Longrightarrow> P (And p q))\n  \\<Longrightarrow> (\\<And>x p. P p \\<Longrightarrow> P (Exists x p))\n  \\<Longrightarrow> (\\<And>a p. P p \\<Longrightarrow> P (Diamond a p))\n  \\<Longrightarrow> (\\<And>C p. P p \\<Longrightarrow> P (InContext C p))\n  \\<Longrightarrow> P \\<phi>\"", "lemma proj_sing1:\"(singleton \\<theta> vid1) = \\<theta>\"", "lemma proj_sing2:\"vid1 \\<noteq> y  \\<Longrightarrow> (singleton \\<theta> y) = (Const 0)\""], "translations": [["", "lemma sizeF_diseq:\"sizeF p \\<noteq> sizeF q \\<Longrightarrow> p \\<noteq> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sizeF p \\<noteq> sizeF q \\<Longrightarrow> p \\<noteq> q", "by auto"], ["", "named_theorems \"expr_diseq\" \"Structural disequality rules for expressions\""], ["", "lemma [expr_diseq]:\"p \\<noteq> And p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> (p && q)", "by(induction p, auto)"], ["", "lemma [expr_diseq]:\"q \\<noteq> And p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p && q)", "by(induction q, auto)"], ["", "lemma [expr_diseq]:\"p \\<noteq> Not p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> ! p", "by(induction p, auto)"], ["", "lemma [expr_diseq]:\"p \\<noteq> Or p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> (p || q)", "by(rule sizeF_diseq, auto simp add: Or_def)"], ["", "lemma [expr_diseq]:\"q \\<noteq> Or p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p || q)", "by(rule sizeF_diseq, auto simp add: Or_def)"], ["", "lemma [expr_diseq]:\"p \\<noteq> Implies p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> (p \\<rightarrow> q)", "by(rule sizeF_diseq, auto simp add: Implies_def Or_def)"], ["", "lemma [expr_diseq]:\"q \\<noteq> Implies p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p \\<rightarrow> q)", "by(rule sizeF_diseq, auto simp add: Implies_def Or_def)"], ["", "lemma [expr_diseq]:\"p \\<noteq> Equiv p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> (p \\<leftrightarrow> q)", "by(rule sizeF_diseq, auto simp add: Equiv_def Or_def)"], ["", "lemma [expr_diseq]:\"q \\<noteq> Equiv p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> (p \\<leftrightarrow> q)", "by(rule sizeF_diseq, auto simp add: Equiv_def Or_def)"], ["", "lemma [expr_diseq]:\"p \\<noteq> Exists x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> Exists x p", "by(induction p, auto)"], ["", "lemma [expr_diseq]:\"p \\<noteq> Diamond a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> (\\<langle> a \\<rangle> p)", "by(induction p, auto)"], ["", "lemma [expr_diseq]:\"p \\<noteq> InContext C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> InContext C p", "by(induction p, auto)\n\n\\<comment> \\<open>A predicational is like a context with no argument, i.e. a variable standing for a\\<close>\n\\<comment> \\<open>state-dependent formula, given meaning by the interpretation. This differs from a predicate\\<close>\n\\<comment> \\<open>because predicates depend only on their arguments (which might then indirectly depend on the state).\\<close>\n\\<comment> \\<open>We encode a predicational as a context applied to a formula whose truth value is constant with\\<close>\n\\<comment> \\<open>respect to the state (specifically, always true)\\<close>"], ["", "fun Predicational :: \"'b \\<Rightarrow> ('a, 'b, 'c) formula\" (\"Pc\")\nwhere \"Predicational P = InContext P (Geq (Const 0) (Const 0))\"\n\n\\<comment> \\<open>Abbreviations for common syntactic constructs in order to make axiom definitions, etc. more\\<close>\n\\<comment> \\<open>readable.\\<close>"], ["", "context ids begin\n\\<comment> \\<open>\"Empty\" function argument tuple, encoded as tuple where all arguments assume a constant value.\\<close>"], ["", "definition empty::\" 'b \\<Rightarrow> ('a, 'b) trm\"\nwhere \"empty \\<equiv> \\<lambda>i.(Const 0)\"\n\n\\<comment> \\<open>Function argument tuple with (effectively) one argument, where all others have a constant value.\\<close>"], ["", "fun singleton :: \"('a, 'sz) trm \\<Rightarrow> ('sz \\<Rightarrow> ('a, 'sz) trm)\"\nwhere \"singleton t i = (if i = vid1 then t else (Const 0))\""], ["", "lemma expand_singleton:\"singleton t = (\\<lambda>i. (if i = vid1 then t else (Const 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton t = (\\<lambda>i. if i = vid1 then t else Const 0)", "by auto\n\n\\<comment> \\<open>Function applied to one argument\\<close>"], ["", "definition f1::\"'sf \\<Rightarrow> 'sz \\<Rightarrow> ('sf,'sz) trm\"\nwhere \"f1 f x = Function f (singleton (Var x))\"\n\n\\<comment> \\<open>Function applied to zero arguments (simulates a constant symbol given meaning by the interpretation)\\<close>"], ["", "definition f0::\"'sf \\<Rightarrow> ('sf,'sz) trm\"\nwhere \"f0 f = Function f empty\"\n\n\\<comment> \\<open>Predicate applied to one argument\\<close>"], ["", "definition p1::\"'sz \\<Rightarrow> 'sz \\<Rightarrow> ('sf, 'sc, 'sz) formula\"\nwhere \"p1 p x = Prop p (singleton (Var x))\"\n\n\\<comment> \\<open>Predicational\\<close>"], ["", "definition P::\"'sc \\<Rightarrow> ('sf, 'sc, 'sz) formula\"\nwhere \"P p = Predicational p\""], ["", "end"], ["", "subsection \\<open>Well-Formedness predicates\\<close>"], ["", "inductive dfree :: \"('a, 'c) trm \\<Rightarrow> bool\"\nwhere\n  dfree_Var: \"dfree (Var i)\"\n| dfree_Const: \"dfree (Const r)\"\n| dfree_Fun: \"(\\<And>i. dfree (args i)) \\<Longrightarrow> dfree (Function i args)\"\n| dfree_Plus: \"dfree \\<theta>\\<^sub>1 \\<Longrightarrow> dfree \\<theta>\\<^sub>2 \\<Longrightarrow> dfree (Plus \\<theta>\\<^sub>1 \\<theta>\\<^sub>2)\"\n| dfree_Times: \"dfree \\<theta>\\<^sub>1 \\<Longrightarrow> dfree \\<theta>\\<^sub>2 \\<Longrightarrow> dfree (Times \\<theta>\\<^sub>1 \\<theta>\\<^sub>2)\""], ["", "inductive dsafe :: \"('a, 'c) trm \\<Rightarrow> bool\"\nwhere\n  dsafe_Var: \"dsafe (Var i)\"\n| dsafe_Const: \"dsafe (Const r)\"\n| dsafe_Fun: \"(\\<And>i. dsafe (args i)) \\<Longrightarrow> dsafe (Function i args)\"\n| dsafe_Plus: \"dsafe \\<theta>\\<^sub>1 \\<Longrightarrow> dsafe \\<theta>\\<^sub>2 \\<Longrightarrow> dsafe (Plus \\<theta>\\<^sub>1 \\<theta>\\<^sub>2)\"\n| dsafe_Times: \"dsafe \\<theta>\\<^sub>1 \\<Longrightarrow> dsafe \\<theta>\\<^sub>2 \\<Longrightarrow> dsafe (Times \\<theta>\\<^sub>1 \\<theta>\\<^sub>2)\"\n| dsafe_Diff: \"dfree \\<theta> \\<Longrightarrow> dsafe (Differential \\<theta>)\"\n| dsafe_DiffVar: \"dsafe ($' i)\"\n\n\\<comment> \\<open>Explictly-written variables that are bound by the ODE. Needed to compute whether\\<close>\n\\<comment> \\<open>ODE's are valid (e.g. whether they bind the same variable twice)\\<close>"], ["", "fun ODE_dom::\"('a, 'c) ODE \\<Rightarrow> 'c set\"\nwhere \n  \"ODE_dom (OVar c) =  {}\"\n| \"ODE_dom (OSing x \\<theta>) = {x}\"\n| \"ODE_dom (OProd ODE1 ODE2) = ODE_dom ODE1 \\<union> ODE_dom ODE2\""], ["", "inductive osafe:: \"('a, 'c) ODE \\<Rightarrow> bool\"\nwhere\n  osafe_Var:\"osafe (OVar c)\"\n| osafe_Sing:\"dfree \\<theta> \\<Longrightarrow> osafe (OSing x \\<theta>)\"\n| osafe_Prod:\"osafe ODE1 \\<Longrightarrow> osafe ODE2 \\<Longrightarrow> ODE_dom ODE1 \\<inter> ODE_dom ODE2 = {} \\<Longrightarrow> osafe (OProd ODE1 ODE2)\"\n\n\\<comment> \\<open>Programs/formulas without any differential terms. This definition not currently used but may\\<close>\n\\<comment> \\<open>be useful in the future.\\<close>"], ["", "inductive hpfree:: \"('a, 'b, 'c) hp \\<Rightarrow> bool\"\n  and     ffree::  \"('a, 'b, 'c) formula \\<Rightarrow> bool\"\nwhere\n  \"hpfree (Pvar x)\"\n| \"dfree e \\<Longrightarrow> hpfree (Assign x e)\"\n\\<comment> \\<open>Differential programs allowed but not differential terms\\<close>\n| \"dfree e \\<Longrightarrow> hpfree (DiffAssign x e)\"\n| \"ffree P \\<Longrightarrow> hpfree (Test P)\" \n\\<comment> \\<open>Differential programs allowed but not differential terms\\<close>\n| \"osafe ODE \\<Longrightarrow> ffree P \\<Longrightarrow> hpfree (EvolveODE ODE P)\"\n| \"hpfree a \\<Longrightarrow> hpfree b \\<Longrightarrow> hpfree (Choice a b )\"\n| \"hpfree a \\<Longrightarrow> hpfree b \\<Longrightarrow> hpfree (Sequence a b)\"\n| \"hpfree a \\<Longrightarrow> hpfree (Loop a)\"\n| \"ffree f \\<Longrightarrow> ffree (InContext C f)\"\n| \"(\\<And>arg. arg \\<in> range args \\<Longrightarrow> dfree arg) \\<Longrightarrow> ffree (Prop p args)\"\n| \"ffree p \\<Longrightarrow> ffree (Not p)\"\n| \"ffree p \\<Longrightarrow> ffree q \\<Longrightarrow> ffree (And p q)\"\n| \"ffree p \\<Longrightarrow> ffree (Exists x p)\"\n| \"hpfree a \\<Longrightarrow> ffree p \\<Longrightarrow> ffree (Diamond a p)\"\n| \"ffree (Predicational P)\"\n| \"dfree t1 \\<Longrightarrow> dfree t2 \\<Longrightarrow> ffree (Geq t1 t2)\""], ["", "inductive hpsafe:: \"('a, 'b, 'c) hp \\<Rightarrow> bool\"\n  and     fsafe::  \"('a, 'b, 'c) formula \\<Rightarrow> bool\"\nwhere\n   hpsafe_Pvar:\"hpsafe (Pvar x)\"\n | hpsafe_Assign:\"dsafe e \\<Longrightarrow> hpsafe (Assign x e)\"\n | hpsafe_DiffAssign:\"dsafe e \\<Longrightarrow> hpsafe (DiffAssign x e)\"\n | hpsafe_Test:\"fsafe P \\<Longrightarrow> hpsafe (Test P)\" \n | hpsafe_Evolve:\"osafe ODE \\<Longrightarrow> fsafe P \\<Longrightarrow> hpsafe (EvolveODE ODE P)\"\n | hpsafe_Choice:\"hpsafe a \\<Longrightarrow> hpsafe b \\<Longrightarrow> hpsafe (Choice a b )\"\n | hpsafe_Sequence:\"hpsafe a \\<Longrightarrow> hpsafe b \\<Longrightarrow> hpsafe (Sequence a b)\"\n | hpsafe_Loop:\"hpsafe a \\<Longrightarrow> hpsafe (Loop a)\"\n\n | fsafe_Geq:\"dsafe t1 \\<Longrightarrow> dsafe t2 \\<Longrightarrow> fsafe (Geq t1 t2)\"\n | fsafe_Prop:\"(\\<And>i. dsafe (args i)) \\<Longrightarrow> fsafe (Prop p args)\"\n | fsafe_Not:\"fsafe p \\<Longrightarrow> fsafe (Not p)\"\n | fsafe_And:\"fsafe p \\<Longrightarrow> fsafe q \\<Longrightarrow> fsafe (And p q)\"\n | fsafe_Exists:\"fsafe p \\<Longrightarrow> fsafe (Exists x p)\"\n | fsafe_Diamond:\"hpsafe a \\<Longrightarrow> fsafe p \\<Longrightarrow> fsafe (Diamond a p)\"\n | fsafe_InContext:\"fsafe f \\<Longrightarrow> fsafe (InContext C f)\"\n\n\\<comment> \\<open>Auto-generated simplifier rules for safety predicates\\<close>"], ["", "inductive_simps\n      dfree_Plus_simps[simp]: \"dfree (Plus a b)\"\n  and dfree_Times_simps[simp]: \"dfree (Times a b)\"\n  and dfree_Var_simps[simp]: \"dfree (Var x)\"\n  and dfree_DiffVar_simps[simp]: \"dfree (DiffVar x)\"\n  and dfree_Differential_simps[simp]: \"dfree (Differential x)\"\n  and dfree_Fun_simps[simp]: \"dfree (Function i args)\"\n  and dfree_Const_simps[simp]: \"dfree (Const r)\""], ["", "inductive_simps\n      dsafe_Plus_simps[simp]: \"dsafe (Plus a b)\"\n  and dsafe_Times_simps[simp]: \"dsafe (Times a b)\"\n  and dsafe_Var_simps[simp]: \"dsafe (Var x)\"\n  and dsafe_DiffVar_simps[simp]: \"dsafe (DiffVar x)\"\n  and dsafe_Fun_simps[simp]: \"dsafe (Function i args)\"\n  and dsafe_Diff_simps[simp]: \"dsafe (Differential a)\"\n  and dsafe_Const_simps[simp]: \"dsafe (Const r)\""], ["", "inductive_simps\n      osafe_OVar_simps[simp]:\"osafe (OVar c)\"\n  and osafe_OSing_simps[simp]:\"osafe (OSing x \\<theta>)\"\n  and osafe_OProd_simps[simp]:\"osafe (OProd ODE1 ODE2)\""], ["", "inductive_simps\n      hpsafe_Pvar_simps[simp]: \"hpsafe (Pvar a)\"\n  and hpsafe_Sequence_simps[simp]: \"hpsafe (a ;; b)\"\n  and hpsafe_Loop_simps[simp]: \"hpsafe (a**)\"\n  and hpsafe_ODE_simps[simp]: \"hpsafe (EvolveODE ODE p)\"\n  and hpsafe_Choice_simps[simp]: \"hpsafe (a \\<union>\\<union> b)\"\n  and hpsafe_Assign_simps[simp]: \"hpsafe (Assign x e)\"\n  and hpsafe_DiffAssign_simps[simp]: \"hpsafe (DiffAssign x e)\"\n  and hpsafe_Test_simps[simp]: \"hpsafe (? p)\"\n  \n  and fsafe_Geq_simps[simp]: \"fsafe (Geq t1 t2)\"\n  and fsafe_Prop_simps[simp]: \"fsafe (Prop p args)\"\n  and fsafe_Not_simps[simp]: \"fsafe (Not p)\"\n  and fsafe_And_simps[simp]: \"fsafe (And p q)\"\n  and fsafe_Exists_simps[simp]: \"fsafe (Exists x p)\"\n  and fsafe_Diamond_simps[simp]: \"fsafe (Diamond a p)\"\n  and fsafe_Context_simps[simp]: \"fsafe (InContext C p)\""], ["", "definition Ssafe::\"('sf,'sc,'sz) sequent \\<Rightarrow> bool\"\nwhere \"Ssafe S \\<longleftrightarrow>((\\<forall>i. i \\<ge> 0 \\<longrightarrow> i < length (fst S) \\<longrightarrow> fsafe (nth (fst S) i))\n                 \\<and>(\\<forall>i. i \\<ge> 0 \\<longrightarrow> i < length (snd S) \\<longrightarrow> fsafe (nth (snd S) i)))\""], ["", "definition Rsafe::\"('sf,'sc,'sz) rule \\<Rightarrow> bool\"\nwhere \"Rsafe R \\<longleftrightarrow> ((\\<forall>i. i \\<ge> 0 \\<longrightarrow> i < length (fst R) \\<longrightarrow> Ssafe (nth (fst R) i)) \n                    \\<and> Ssafe (snd R))\"\n  \n\\<comment> \\<open>Basic reasoning principles about syntactic constructs, including inductive principles\\<close>"], ["", "lemma dfree_is_dsafe: \"dfree \\<theta> \\<Longrightarrow> dsafe \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfree \\<theta> \\<Longrightarrow> dsafe \\<theta>", "by (induction rule: dfree.induct) (auto intro: dsafe.intros)"], ["", "lemma hp_induct [case_names Var Assign DiffAssign Test Evolve Choice Compose Star]:\n   \"(\\<And>x. P ($\\<alpha> x)) \\<Longrightarrow>\n    (\\<And>x1 x2. P (x1 := x2)) \\<Longrightarrow>\n    (\\<And>x1 x2. P (DiffAssign x1 x2)) \\<Longrightarrow>\n    (\\<And>x. P (? x)) \\<Longrightarrow>\n    (\\<And>x1 x2. P (EvolveODE x1 x2)) \\<Longrightarrow>\n    (\\<And>x1 x2. P x1 \\<Longrightarrow> P x2 \\<Longrightarrow> P (x1 \\<union>\\<union> x2)) \\<Longrightarrow>\n    (\\<And>x1 x2. P x1 \\<Longrightarrow> P x2 \\<Longrightarrow> P (x1 ;; x2)) \\<Longrightarrow>\n    (\\<And>x. P x \\<Longrightarrow> P x**) \\<Longrightarrow>\n     P hp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. P ($\\<alpha> x); \\<And>x1 x2. P (x1 := x2);\n     \\<And>x1 x2. P (DiffAssign x1 x2); \\<And>x. P (? x);\n     \\<And>x1 x2. P (EvolveODE x1 x2);\n     \\<And>x1 x2.\n        \\<lbrakk>P x1; P x2\\<rbrakk>\n        \\<Longrightarrow> P (x1 \\<union>\\<union> x2);\n     \\<And>x1 x2.\n        \\<lbrakk>P x1; P x2\\<rbrakk> \\<Longrightarrow> P (x1 ;; x2);\n     \\<And>x. P x \\<Longrightarrow> P x**\\<rbrakk>\n    \\<Longrightarrow> P hp", "by(induction rule: hp.induct) (auto)"], ["", "lemma fml_induct:\n  \"(\\<And>t1 t2. P (Geq t1 t2))\n  \\<Longrightarrow> (\\<And>p args. P (Prop p args))\n  \\<Longrightarrow> (\\<And>p. P p \\<Longrightarrow> P (Not p))\n  \\<Longrightarrow> (\\<And>p q. P p \\<Longrightarrow> P q \\<Longrightarrow> P (And p q))\n  \\<Longrightarrow> (\\<And>x p. P p \\<Longrightarrow> P (Exists x p))\n  \\<Longrightarrow> (\\<And>a p. P p \\<Longrightarrow> P (Diamond a p))\n  \\<Longrightarrow> (\\<And>C p. P p \\<Longrightarrow> P (InContext C p))\n  \\<Longrightarrow> P \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t1 t2. P (Geq t1 t2); \\<And>p args. P ($\\<phi> p args);\n     \\<And>p. P p \\<Longrightarrow> P (! p);\n     \\<And>p q. \\<lbrakk>P p; P q\\<rbrakk> \\<Longrightarrow> P (p && q);\n     \\<And>x p. P p \\<Longrightarrow> P (Exists x p);\n     \\<And>a p. P p \\<Longrightarrow> P (\\<langle> a \\<rangle> p);\n     \\<And>C p. P p \\<Longrightarrow> P (InContext C p)\\<rbrakk>\n    \\<Longrightarrow> P \\<phi>", "by (induction rule: formula.induct) (auto)"], ["", "context ids begin"], ["", "lemma proj_sing1:\"(singleton \\<theta> vid1) = \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton \\<theta> vid1 = \\<theta>", "by (auto)"], ["", "lemma proj_sing2:\"vid1 \\<noteq> y  \\<Longrightarrow> (singleton \\<theta> y) = (Const 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vid1 \\<noteq> y \\<Longrightarrow> singleton \\<theta> y = Const 0", "by (auto)"], ["", "end"], ["", "end"]]}