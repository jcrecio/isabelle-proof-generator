{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive_Languages/Context_Free_Grammar.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive_Languages", "problem_names": ["lemma subst_in_cfls: \"subst P = to_language {w. in_cfls P w}\"", "lemma \\<oo>\\<^sub>P_in_cfl: \"\\<oo>\\<^sub>P \\<alpha> \\<Longrightarrow> in_cfl \\<alpha> []\"", "lemma \\<dd>\\<^sub>P_in_cfl: \"\\<beta> |\\<in>| \\<dd>\\<^sub>P \\<alpha> a \\<Longrightarrow> in_cfl \\<beta> w \\<Longrightarrow> in_cfl \\<alpha> (a # w)\"", "lemma in_cfls_in_cfl: \"in_cfls P w \\<Longrightarrow> fBex P (\\<lambda>\\<alpha>. in_cfl \\<alpha> w)\"", "lemma in_cfls_mono: \"in_cfls P w \\<Longrightarrow> P |\\<subseteq>| Q \\<Longrightarrow> in_cfls Q w\"", "lemma in_cfl_in_cfls: \"in_cfl G \\<alpha> w \\<Longrightarrow> in_cfls G {|\\<alpha>|} w\"", "lemma lang_lang_trad: \"lang = to_language (lang_trad G)\"", "lemma \"in_language palindromes.lang []\"", "lemma \"in_language palindromes.lang [True]\"", "lemma \"in_language palindromes.lang [False]\"", "lemma \"in_language palindromes.lang [True, True]\"", "lemma \"in_language palindromes.lang [True, False, True]\"", "lemma \"\\<not> in_language palindromes.lang [True, False]\"", "lemma \"\\<not> in_language palindromes.lang [True, False, True, False]\"", "lemma \"in_language palindromes.lang [True, False, True, True, False, True]\"", "lemma \"\\<not> in_language palindromes.lang [True, False, True, False, False, True]\"", "lemma \"in_language Dyck.lang []\"", "lemma \"\\<not> in_language Dyck.lang [True]\"", "lemma \"\\<not> in_language Dyck.lang [False]\"", "lemma \"in_language Dyck.lang [True, False, True, False]\"", "lemma \"in_language Dyck.lang [True, True, False, False]\"", "lemma \"in_language Dyck.lang [True, False, True, False]\"", "lemma \"in_language Dyck.lang [True, False, True, False, True, True, False, False]\"", "lemma \"\\<not> in_language Dyck.lang [True, False, True, True, False]\"", "lemma \"\\<not> in_language Dyck.lang [True, True, False, False, False, True]\"", "lemma \"in_language abSSa.lang []\"", "lemma \"\\<not> in_language abSSa.lang [True]\"", "lemma \"\\<not> in_language abSSa.lang [False]\"", "lemma \"in_language abSSa.lang [True, False, True]\"", "lemma \"in_language abSSa.lang [True, False, True, False, True, True, False, True, True]\"", "lemma \"in_language abSSa.lang [True, False, True, False, True, True]\"", "lemma \"\\<not> in_language abSSa.lang [True, False, True, True, False]\"", "lemma \"\\<not> in_language abSSa.lang [True, True, False, False, False, True]\""], "translations": [["", "lemma subst_in_cfls: \"subst P = to_language {w. in_cfls P w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.subst P = to_language {w. local.in_cfls P w}", "by (coinduction arbitrary: P) (auto intro: in_cfls.intros)"], ["", "lemma \\<oo>\\<^sub>P_in_cfl: \"\\<oo>\\<^sub>P \\<alpha> \\<Longrightarrow> in_cfl \\<alpha> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.\\<oo>\\<^sub>P \\<alpha> \\<Longrightarrow> local.in_cfl \\<alpha> []", "by (induct \\<alpha> rule: \\<oo>\\<^sub>P.induct) (auto intro!: in_cfl.intros elim: fBexI[rotated])"], ["", "lemma \\<dd>\\<^sub>P_in_cfl: \"\\<beta> |\\<in>| \\<dd>\\<^sub>P \\<alpha> a \\<Longrightarrow> in_cfl \\<beta> w \\<Longrightarrow> in_cfl \\<alpha> (a # w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> |\\<in>| local.\\<dd>\\<^sub>P \\<alpha> a;\n     local.in_cfl \\<beta> w\\<rbrakk>\n    \\<Longrightarrow> local.in_cfl \\<alpha> (a # w)", "proof (induct \\<alpha> a arbitrary: \\<beta> w rule: \\<dd>\\<^sub>P.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a \\<beta> w.\n       \\<lbrakk>\\<beta> |\\<in>| local.\\<dd>\\<^sub>P [] a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl [] (a # w)\n 2. \\<And>b \\<alpha> a \\<beta> w.\n       \\<lbrakk>\\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inl b # \\<alpha>) a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl (Inl b # \\<alpha>) (a # w)\n 3. \\<And>N \\<alpha> a \\<beta> w.\n       \\<lbrakk>\\<And>\\<beta> w.\n                   \\<lbrakk>[] |\\<in>| cfg.prod G N;\n                    \\<beta> |\\<in>| local.\\<dd>\\<^sub>P \\<alpha> a;\n                    local.in_cfl \\<beta> w\\<rbrakk>\n                   \\<Longrightarrow> local.in_cfl \\<alpha> (a # w);\n        \\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inr N # \\<alpha>) a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl (Inr N # \\<alpha>) (a # w)", "case (3 N \\<alpha> a)"], ["proof (state)\nthis:\n  \\<lbrakk>[] |\\<in>| cfg.prod G N;\n   ?\\<beta>5 |\\<in>| local.\\<dd>\\<^sub>P \\<alpha> a;\n   local.in_cfl ?\\<beta>5 ?w5\\<rbrakk>\n  \\<Longrightarrow> local.in_cfl \\<alpha> (a # ?w5)\n  \\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inr N # \\<alpha>) a\n  local.in_cfl \\<beta> w\n\ngoal (3 subgoals):\n 1. \\<And>a \\<beta> w.\n       \\<lbrakk>\\<beta> |\\<in>| local.\\<dd>\\<^sub>P [] a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl [] (a # w)\n 2. \\<And>b \\<alpha> a \\<beta> w.\n       \\<lbrakk>\\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inl b # \\<alpha>) a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl (Inl b # \\<alpha>) (a # w)\n 3. \\<And>N \\<alpha> a \\<beta> w.\n       \\<lbrakk>\\<And>\\<beta> w.\n                   \\<lbrakk>[] |\\<in>| cfg.prod G N;\n                    \\<beta> |\\<in>| local.\\<dd>\\<^sub>P \\<alpha> a;\n                    local.in_cfl \\<beta> w\\<rbrakk>\n                   \\<Longrightarrow> local.in_cfl \\<alpha> (a # w);\n        \\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inr N # \\<alpha>) a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl (Inr N # \\<alpha>) (a # w)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>[] |\\<in>| cfg.prod G N;\n   ?\\<beta>5 |\\<in>| local.\\<dd>\\<^sub>P \\<alpha> a;\n   local.in_cfl ?\\<beta>5 ?w5\\<rbrakk>\n  \\<Longrightarrow> local.in_cfl \\<alpha> (a # ?w5)\n  \\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inr N # \\<alpha>) a\n  local.in_cfl \\<beta> w", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] |\\<in>| cfg.prod G N;\n   ?\\<beta>5 |\\<in>| local.\\<dd>\\<^sub>P \\<alpha> a;\n   local.in_cfl ?\\<beta>5 ?w5\\<rbrakk>\n  \\<Longrightarrow> local.in_cfl \\<alpha> (a # ?w5)\n  \\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inr N # \\<alpha>) a\n  local.in_cfl \\<beta> w\n\ngoal (1 subgoal):\n 1. local.in_cfl (Inr N # \\<alpha>) (a # w)", "by (auto simp: rev_fBexI neq_Nil_conv split: if_splits\n      intro!: in_cfl.intros  elim!: rev_fBexI[of \"_ # _\"])"], ["proof (state)\nthis:\n  local.in_cfl (Inr N # \\<alpha>) (a # w)\n\ngoal (2 subgoals):\n 1. \\<And>a \\<beta> w.\n       \\<lbrakk>\\<beta> |\\<in>| local.\\<dd>\\<^sub>P [] a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl [] (a # w)\n 2. \\<And>b \\<alpha> a \\<beta> w.\n       \\<lbrakk>\\<beta> |\\<in>| local.\\<dd>\\<^sub>P (Inl b # \\<alpha>) a;\n        local.in_cfl \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> local.in_cfl (Inl b # \\<alpha>) (a # w)", "qed (auto split: if_splits intro: in_cfl.intros)"], ["", "lemma in_cfls_in_cfl: \"in_cfls P w \\<Longrightarrow> fBex P (\\<lambda>\\<alpha>. in_cfl \\<alpha> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.in_cfls P w \\<Longrightarrow>\n    fBex P (\\<lambda>\\<alpha>. local.in_cfl \\<alpha> w)", "by (induct P w rule: in_cfls.induct)\n    (auto simp: \\<oo>\\<^sub>P_in_cfl \\<dd>\\<^sub>P_in_cfl ffUnion.rep_eq fmember.rep_eq fBex.rep_eq fBall.rep_eq\n      intro: in_cfl.intros elim: rev_bexI)"], ["", "lemma in_cfls_mono: \"in_cfls P w \\<Longrightarrow> P |\\<subseteq>| Q \\<Longrightarrow> in_cfls Q w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.in_cfls P w; P |\\<subseteq>| Q\\<rbrakk>\n    \\<Longrightarrow> local.in_cfls Q w", "proof (induct P w arbitrary: Q rule: in_cfls.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P Q.\n       \\<lbrakk>fBex P local.\\<oo>\\<^sub>P; P |\\<subseteq>| Q\\<rbrakk>\n       \\<Longrightarrow> local.in_cfls Q []\n 2. \\<And>a P w Q.\n       \\<lbrakk>local.in_cfls\n                 (ffUnion\n                   ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`|\n                    P))\n                 w;\n        \\<And>Q.\n           ffUnion\n            ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`|\n             P) |\\<subseteq>|\n           Q \\<Longrightarrow>\n           local.in_cfls Q w;\n        P |\\<subseteq>| Q\\<rbrakk>\n       \\<Longrightarrow> local.in_cfls Q (a # w)", "case (2 a P w)"], ["proof (state)\nthis:\n  local.in_cfls\n   (ffUnion ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`| P)) w\n  ffUnion\n   ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`| P) |\\<subseteq>|\n  ?Q5 \\<Longrightarrow>\n  local.in_cfls ?Q5 w\n  P |\\<subseteq>| Q\n\ngoal (2 subgoals):\n 1. \\<And>P Q.\n       \\<lbrakk>fBex P local.\\<oo>\\<^sub>P; P |\\<subseteq>| Q\\<rbrakk>\n       \\<Longrightarrow> local.in_cfls Q []\n 2. \\<And>a P w Q.\n       \\<lbrakk>local.in_cfls\n                 (ffUnion\n                   ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`|\n                    P))\n                 w;\n        \\<And>Q.\n           ffUnion\n            ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`|\n             P) |\\<subseteq>|\n           Q \\<Longrightarrow>\n           local.in_cfls Q w;\n        P |\\<subseteq>| Q\\<rbrakk>\n       \\<Longrightarrow> local.in_cfls Q (a # w)", "from 2(3) 2(2)[of \"ffUnion ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`| Q)\"]"], ["proof (chain)\npicking this:\n  P |\\<subseteq>| Q\n  ffUnion\n   ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`| P) |\\<subseteq>|\n  ffUnion\n   ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`|\n    Q) \\<Longrightarrow>\n  local.in_cfls\n   (ffUnion ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`| Q)) w", "show ?case"], ["proof (prove)\nusing this:\n  P |\\<subseteq>| Q\n  ffUnion\n   ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`| P) |\\<subseteq>|\n  ffUnion\n   ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`|\n    Q) \\<Longrightarrow>\n  local.in_cfls\n   (ffUnion ((\\<lambda>\\<alpha>. local.\\<dd>\\<^sub>P \\<alpha> a) |`| Q)) w\n\ngoal (1 subgoal):\n 1. local.in_cfls Q (a # w)", "by (auto intro!: ffunion_mono in_cfls.intros)"], ["proof (state)\nthis:\n  local.in_cfls Q (a # w)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>fBex P local.\\<oo>\\<^sub>P; P |\\<subseteq>| Q\\<rbrakk>\n       \\<Longrightarrow> local.in_cfls Q []", "qed (auto intro!: in_cfls.intros)"], ["", "end"], ["", "locale cfg_wgreibach =\n  fixes G :: \"('t, 'n :: finite) cfg\"\n  assumes weakGreibach: \"\\<And>N \\<alpha>. \\<alpha> |\\<in>| prod G N \\<Longrightarrow> wgreibach \\<alpha>\"\nbegin"], ["", "lemma in_cfl_in_cfls: \"in_cfl G \\<alpha> w \\<Longrightarrow> in_cfls G {|\\<alpha>|} w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_cfl G \\<alpha> w \\<Longrightarrow> in_cfls G {|\\<alpha>|} w", "proof (induct \\<alpha> w rule: in_cfl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. in_cfls G {|[]|} []\n 2. \\<And>\\<alpha> w a.\n       \\<lbrakk>in_cfl G \\<alpha> w; in_cfls G {|\\<alpha>|} w\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inl a # \\<alpha>|} (a # w)\n 3. \\<And>N \\<alpha> w.\n       fBex (cfg.prod G N)\n        (\\<lambda>\\<beta>.\n            in_cfl G (\\<beta> @ \\<alpha>) w \\<and>\n            in_cfls G {|\\<beta> @ \\<alpha>|} w) \\<Longrightarrow>\n       in_cfls G {|Inr N # \\<alpha>|} w", "case (3 N \\<alpha> w)"], ["proof (state)\nthis:\n  fBex (cfg.prod G N)\n   (\\<lambda>\\<beta>.\n       in_cfl G (\\<beta> @ \\<alpha>) w \\<and>\n       in_cfls G {|\\<beta> @ \\<alpha>|} w)\n\ngoal (3 subgoals):\n 1. in_cfls G {|[]|} []\n 2. \\<And>\\<alpha> w a.\n       \\<lbrakk>in_cfl G \\<alpha> w; in_cfls G {|\\<alpha>|} w\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inl a # \\<alpha>|} (a # w)\n 3. \\<And>N \\<alpha> w.\n       fBex (cfg.prod G N)\n        (\\<lambda>\\<beta>.\n            in_cfl G (\\<beta> @ \\<alpha>) w \\<and>\n            in_cfls G {|\\<beta> @ \\<alpha>|} w) \\<Longrightarrow>\n       in_cfls G {|Inr N # \\<alpha>|} w", "then"], ["proof (chain)\npicking this:\n  fBex (cfg.prod G N)\n   (\\<lambda>\\<beta>.\n       in_cfl G (\\<beta> @ \\<alpha>) w \\<and>\n       in_cfls G {|\\<beta> @ \\<alpha>|} w)", "obtain \\<beta> where\n    \\<beta>: \"\\<beta> |\\<in>| prod G N\" and\n    in_cfl: \"in_cfl G (\\<beta> @ \\<alpha>) w\" and\n    in_cfls: \"in_cfls G {|\\<beta> @ \\<alpha>|} w\""], ["proof (prove)\nusing this:\n  fBex (cfg.prod G N)\n   (\\<lambda>\\<beta>.\n       in_cfl G (\\<beta> @ \\<alpha>) w \\<and>\n       in_cfls G {|\\<beta> @ \\<alpha>|} w)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n         in_cfl G (\\<beta> @ \\<alpha>) w;\n         in_cfls G {|\\<beta> @ \\<alpha>|} w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta> |\\<in>| cfg.prod G N\n  in_cfl G (\\<beta> @ \\<alpha>) w\n  in_cfls G {|\\<beta> @ \\<alpha>|} w\n\ngoal (3 subgoals):\n 1. in_cfls G {|[]|} []\n 2. \\<And>\\<alpha> w a.\n       \\<lbrakk>in_cfl G \\<alpha> w; in_cfls G {|\\<alpha>|} w\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inl a # \\<alpha>|} (a # w)\n 3. \\<And>N \\<alpha> w.\n       fBex (cfg.prod G N)\n        (\\<lambda>\\<beta>.\n            in_cfl G (\\<beta> @ \\<alpha>) w \\<and>\n            in_cfls G {|\\<beta> @ \\<alpha>|} w) \\<Longrightarrow>\n       in_cfls G {|Inr N # \\<alpha>|} w", "then"], ["proof (chain)\npicking this:\n  \\<beta> |\\<in>| cfg.prod G N\n  in_cfl G (\\<beta> @ \\<alpha>) w\n  in_cfls G {|\\<beta> @ \\<alpha>|} w", "show ?case"], ["proof (prove)\nusing this:\n  \\<beta> |\\<in>| cfg.prod G N\n  in_cfl G (\\<beta> @ \\<alpha>) w\n  in_cfls G {|\\<beta> @ \\<alpha>|} w\n\ngoal (1 subgoal):\n 1. in_cfls G {|Inr N # \\<alpha>|} w", "proof (cases \\<beta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N; in_cfl G (\\<beta> @ \\<alpha>) w;\n     in_cfls G {|\\<beta> @ \\<alpha>|} w; \\<beta> = []\\<rbrakk>\n    \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w\n 2. \\<And>a list.\n       \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n        in_cfl G (\\<beta> @ \\<alpha>) w; in_cfls G {|\\<beta> @ \\<alpha>|} w;\n        \\<beta> = a # list\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w", "case [simp]: Nil"], ["proof (state)\nthis:\n  \\<beta> = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N; in_cfl G (\\<beta> @ \\<alpha>) w;\n     in_cfls G {|\\<beta> @ \\<alpha>|} w; \\<beta> = []\\<rbrakk>\n    \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w\n 2. \\<And>a list.\n       \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n        in_cfl G (\\<beta> @ \\<alpha>) w; in_cfls G {|\\<beta> @ \\<alpha>|} w;\n        \\<beta> = a # list\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w", "from \\<beta> in_cfls"], ["proof (chain)\npicking this:\n  \\<beta> |\\<in>| cfg.prod G N\n  in_cfls G {|\\<beta> @ \\<alpha>|} w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> |\\<in>| cfg.prod G N\n  in_cfls G {|\\<beta> @ \\<alpha>|} w\n\ngoal (1 subgoal):\n 1. in_cfls G {|Inr N # \\<alpha>|} w", "by (cases w) (auto intro!: in_cfls.intros elim: in_cfls_mono)"], ["proof (state)\nthis:\n  in_cfls G {|Inr N # \\<alpha>|} w\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n        in_cfl G (\\<beta> @ \\<alpha>) w; in_cfls G {|\\<beta> @ \\<alpha>|} w;\n        \\<beta> = a # list\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n        in_cfl G (\\<beta> @ \\<alpha>) w; in_cfls G {|\\<beta> @ \\<alpha>|} w;\n        \\<beta> = a # list\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w", "case [simp]: (Cons x \\<gamma>)"], ["proof (state)\nthis:\n  \\<beta> = x # \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n        in_cfl G (\\<beta> @ \\<alpha>) w; in_cfls G {|\\<beta> @ \\<alpha>|} w;\n        \\<beta> = a # list\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w", "from weakGreibach[OF \\<beta>]"], ["proof (chain)\npicking this:\n  wgreibach \\<beta>", "obtain a where [simp]: \"x = Inl a\""], ["proof (prove)\nusing this:\n  wgreibach \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>a. x = Inl a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases x) auto"], ["proof (state)\nthis:\n  x = Inl a\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n        in_cfl G (\\<beta> @ \\<alpha>) w; in_cfls G {|\\<beta> @ \\<alpha>|} w;\n        \\<beta> = a # list\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w", "with \\<beta> in_cfls"], ["proof (chain)\npicking this:\n  \\<beta> |\\<in>| cfg.prod G N\n  in_cfls G {|\\<beta> @ \\<alpha>|} w\n  x = Inl a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> |\\<in>| cfg.prod G N\n  in_cfls G {|\\<beta> @ \\<alpha>|} w\n  x = Inl a\n\ngoal (1 subgoal):\n 1. in_cfls G {|Inr N # \\<alpha>|} w", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> |\\<in>| cfg.prod G N;\n     in_cfls G {|\\<beta> @ \\<alpha>|} w; x = Inl a\\<rbrakk>\n    \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} w", "apply (rule  in_cfl.cases[OF in_cfl]; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>Inl a # \\<gamma> |\\<in>| cfg.prod G N; w = a # w;\n        in_cfl G (\\<gamma> @ \\<alpha>) w;\n        in_cfls G {|\\<gamma> @ \\<alpha>|} w\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inr N # \\<alpha>|} (a # w)", "apply (force intro: in_cfls.intros(2) elim!: in_cfls_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  in_cfls G {|Inr N # \\<alpha>|} w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_cfls G {|Inr N # \\<alpha>|} w\n\ngoal (2 subgoals):\n 1. in_cfls G {|[]|} []\n 2. \\<And>\\<alpha> w a.\n       \\<lbrakk>in_cfl G \\<alpha> w; in_cfls G {|\\<alpha>|} w\\<rbrakk>\n       \\<Longrightarrow> in_cfls G {|Inl a # \\<alpha>|} (a # w)", "qed (auto intro!: in_cfls.intros)"], ["", "abbreviation lang where\n  \"lang \\<equiv> subst G {|[Inr (init G)]|}\""], ["", "lemma lang_lang_trad: \"lang = to_language (lang_trad G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang = to_language (lang_trad G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang = to_language (lang_trad G)", "have \"in_cfls G {|[Inr (init G)]|} w \\<longleftrightarrow> in_cfl G [Inr (init G)] w\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_cfls G {|[Inr (init G)]|} w = in_cfl G [Inr (init G)] w", "by (auto dest: in_cfls_in_cfl in_cfl_in_cfls)"], ["proof (state)\nthis:\n  in_cfls G {|[Inr (init G)]|} ?w = in_cfl G [Inr (init G)] ?w\n\ngoal (1 subgoal):\n 1. lang = to_language (lang_trad G)", "then"], ["proof (chain)\npicking this:\n  in_cfls G {|[Inr (init G)]|} ?w = in_cfl G [Inr (init G)] ?w", "show ?thesis"], ["proof (prove)\nusing this:\n  in_cfls G {|[Inr (init G)]|} ?w = in_cfl G [Inr (init G)] ?w\n\ngoal (1 subgoal):\n 1. lang = to_language (lang_trad G)", "by (auto simp: subst_in_cfls)"], ["proof (state)\nthis:\n  lang = to_language (lang_trad G)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nThe function @{term in_language} decides the word problem for a given language.\nSince we can construct the language of a CFG using @{const cfg_wgreibach.lang} we obtain an\nexecutable (but not very efficient) decision procedure for CFGs for free.\n\\<close>"], ["", "abbreviation \"\\<aa> \\<equiv> Inl True\""], ["", "abbreviation \"\\<bb> \\<equiv> Inl False\""], ["", "abbreviation \"S \\<equiv> Inr ()\""], ["", "interpretation palindromes: cfg_wgreibach \"\\<lparr>init = (), prod = \\<lambda>_. {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>], [\\<bb>, S, \\<bb>]|}\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg_wgreibach\n     \\<lparr>init = (),\n        prod =\n          \\<lambda>_.\n             {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n               [\\<bb>, S, \\<bb>]|}\\<rparr>", "by unfold_locales auto"], ["", "lemma \"in_language palindromes.lang []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod =\n            \\<lambda>_.\n               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                 [\\<bb>, S, \\<bb>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                          [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n     []", "by normalization"], ["", "lemma \"in_language palindromes.lang [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod =\n            \\<lambda>_.\n               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                 [\\<bb>, S, \\<bb>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                          [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n     [True]", "by normalization"], ["", "lemma \"in_language palindromes.lang [False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod =\n            \\<lambda>_.\n               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                 [\\<bb>, S, \\<bb>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                          [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n     [False]", "by normalization"], ["", "lemma \"in_language palindromes.lang [True, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod =\n            \\<lambda>_.\n               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                 [\\<bb>, S, \\<bb>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                          [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n     [True, True]", "by normalization"], ["", "lemma \"in_language palindromes.lang [True, False, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod =\n            \\<lambda>_.\n               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                 [\\<bb>, S, \\<bb>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                          [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n     [True, False, True]", "by normalization"], ["", "lemma \"\\<not> in_language palindromes.lang [True, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod =\n                   \\<lambda>_.\n                      {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                        [\\<bb>, S, \\<bb>]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                                 [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n            [True, False]", "by normalization"], ["", "lemma \"\\<not> in_language palindromes.lang [True, False, True, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod =\n                   \\<lambda>_.\n                      {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                        [\\<bb>, S, \\<bb>]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                                 [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n            [True, False, True, False]", "by normalization"], ["", "lemma \"in_language palindromes.lang [True, False, True, True, False, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod =\n            \\<lambda>_.\n               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                 [\\<bb>, S, \\<bb>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                          [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n     [True, False, True, True, False, True]", "by normalization"], ["", "lemma \"\\<not> in_language palindromes.lang [True, False, True, False, False, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod =\n                   \\<lambda>_.\n                      {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                        [\\<bb>, S, \\<bb>]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[], [\\<aa>], [\\<bb>], [\\<aa>, S, \\<aa>],\n                                 [\\<bb>, S, \\<bb>]|}\\<rparr>)]|})\n            [True, False, True, False, False, True]", "by normalization"], ["", "interpretation Dyck: cfg_wgreibach \"\\<lparr>init = (), prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg_wgreibach\n     \\<lparr>init = (),\n        prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>", "by unfold_locales auto"], ["", "lemma \"in_language Dyck.lang []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n     []", "by normalization"], ["", "lemma \"\\<not> in_language Dyck.lang [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n            [True]", "by normalization"], ["", "lemma \"\\<not> in_language Dyck.lang [False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n            [False]", "by normalization"], ["", "lemma \"in_language Dyck.lang [True, False, True, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n     [True, False, True, False]", "by normalization"], ["", "lemma \"in_language Dyck.lang [True, True, False, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n     [True, True, False, False]", "by normalization"], ["", "lemma \"in_language Dyck.lang [True, False, True, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n     [True, False, True, False]", "by normalization"], ["", "lemma \"in_language Dyck.lang [True, False, True, False, True, True, False, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n     [True, False, True, False, True, True, False, False]", "by normalization"], ["", "lemma \"\\<not> in_language Dyck.lang [True, False, True, True, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n            [True, False, True, True, False]", "by normalization"], ["", "lemma \"\\<not> in_language Dyck.lang [True, True, False, False, False, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod = \\<lambda>_. {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[], [\\<aa>, S, \\<bb>, S]|}\\<rparr>)]|})\n            [True, True, False, False, False, True]", "by normalization"], ["", "interpretation abSSa: cfg_wgreibach \"\\<lparr>init = (), prod = \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg_wgreibach\n     \\<lparr>init = (),\n        prod = \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>", "by unfold_locales auto"], ["", "lemma \"in_language abSSa.lang []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n     []", "by normalization"], ["", "lemma \"\\<not> in_language abSSa.lang [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod =\n                   \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[],\n                                 [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n            [True]", "by normalization"], ["", "lemma \"\\<not> in_language abSSa.lang [False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod =\n                   \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[],\n                                 [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n            [False]", "by normalization"], ["", "lemma \"in_language abSSa.lang [True, False, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n     [True, False, True]", "by normalization"], ["", "lemma \"in_language abSSa.lang [True, False, True, False, True, True, False, True, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n     [True, False, True, False, True, True, False, True, True]", "by normalization"], ["", "lemma \"in_language abSSa.lang [True, False, True, False, True, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language\n     (subst\n       \\<lparr>init = (),\n          prod = \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n       {|[Inr (init\n                \\<lparr>init = (),\n                   prod =\n                     \\<lambda>_.\n                        {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n     [True, False, True, False, True, True]", "by normalization"], ["", "lemma \"\\<not> in_language abSSa.lang [True, False, True, True, False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod =\n                   \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[],\n                                 [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n            [True, False, True, True, False]", "by normalization"], ["", "lemma \"\\<not> in_language abSSa.lang [True, True, False, False, False, True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language\n            (subst\n              \\<lparr>init = (),\n                 prod =\n                   \\<lambda>_. {|[], [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>\n              {|[Inr (init\n                       \\<lparr>init = (),\n                          prod =\n                            \\<lambda>_.\n                               {|[],\n                                 [\\<aa>, \\<bb>, S, S, \\<aa>]|}\\<rparr>)]|})\n            [True, True, False, False, False, True]", "by normalization"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}