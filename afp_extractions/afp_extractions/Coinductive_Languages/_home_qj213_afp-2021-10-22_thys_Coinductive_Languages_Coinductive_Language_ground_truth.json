{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive_Languages/Coinductive_Language.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive_Languages", "problem_names": ["theorem Plus_ZeroL[simp]: \"Plus Zero r = r\"", "theorem Plus_ZeroR[simp]: \"Plus r Zero = r\"", "theorem Plus_assoc: \"Plus (Plus r s) t = Plus r (Plus s t)\"", "theorem Plus_comm: \"Plus r s = Plus s r\"", "lemma Plus_rotate: \"Plus r (Plus s t) = Plus s (Plus r t)\"", "theorem Plus_idem: \"Plus r r = r\"", "lemma Plus_idem_assoc: \"Plus r (Plus r s) = Plus r s\"", "lemmas Plus_ACI[simp] = Plus_rotate Plus_comm Plus_assoc Plus_idem_assoc Plus_idem", "lemma Plus_OneL[simp]: \"\\<oo> r \\<Longrightarrow> Plus One r = r\"", "lemma Plus_OneR[simp]: \"\\<oo> r \\<Longrightarrow> Plus r One = r\"", "lemma TimesLR_ZeroL[simp]: \"TimesLR Zero r = Zero\"", "lemma TimesLR_ZeroR[simp]: \"TimesLR r Zero = Zero\"", "lemma TimesLR_PlusL[simp]: \"TimesLR (Plus r s) t = Plus (TimesLR r t) (TimesLR s t)\"", "lemma TimesLR_PlusR[simp]: \"TimesLR r (Plus s t) = Plus (TimesLR r s) (TimesLR r t)\"", "lemma Times_Plus_Zero[simp]: \"Times_Plus Zero = Zero\"", "lemma Times_Plus_Plus[simp]: \"Times_Plus (Plus r s) = Plus (Times_Plus r) (Times_Plus s)\"", "lemma Times_Plus_TimesLR_One[simp]: \"Times_Plus (TimesLR r One) = r\"", "lemma Times_Plus_TimesLR_PlusL[simp]:\n  \"Times_Plus (TimesLR (Plus r s) t) = Plus (Times_Plus (TimesLR r t)) (Times_Plus (TimesLR s t))\"", "lemma Times_Plus_TimesLR_PlusR[simp]:\n  \"Times_Plus (TimesLR r (Plus s t)) = Plus (Times_Plus (TimesLR r s)) (Times_Plus (TimesLR r t))\"", "lemma \\<oo>_Times[simp]:\n  \"\\<oo> (Times r s) = (\\<oo> r \\<and> \\<oo> s)\"", "lemma \\<dd>_Times[simp]:\n  \"\\<dd> (Times r s) = (\\<lambda>a. if \\<oo> r then Plus (Times (\\<dd> r a) s) (\\<dd> s a) else Times (\\<dd> r a) s)\"", "theorem Times_ZeroL[simp]: \"Times Zero r = Zero\"", "theorem Times_ZeroR[simp]: \"Times r Zero = Zero\"", "theorem Times_OneL[simp]: \"Times One r = r\"", "theorem Times_OneR[simp]: \"Times r One = r\"", "lemma language_coinduct_upto_Plus[unfolded rel_fun_def, simplified, case_names Lang, consumes 1]:\n  assumes R: \"R L K\" and hyp:\n    \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L = \\<oo> K \\<and> rel_fun (=) (Plus_cong R) (\\<dd> L) (\\<dd> K))\"\n  shows \"L = K\"", "theorem Times_PlusL[simp]: \"Times (Plus r s) t = Plus (Times r t) (Times s t)\"", "theorem Times_PlusR[simp]: \"Times r (Plus s t) = Plus (Times r s) (Times r t)\"", "theorem Times_assoc[simp]: \"Times (Times r s) t = Times r (Times s t)\"", "lemma StarLR_Zero[simp]: \"StarLR Zero r = Zero\"", "lemma StarLR_Plus[simp]: \"StarLR (Plus r s) t = Plus (StarLR r t) (StarLR s t)\"", "lemma StarLR_Times_Plus_One[simp]: \"StarLR (Times r (Plus One s)) s = StarLR r s\"", "lemma StarLR_Times: \"StarLR (Times r s) t = Times r (StarLR s t)\"", "lemma \\<oo>_Star[simp]: \"\\<oo> (Star r)\"", "lemma \\<dd>_Star[simp]: \"\\<dd> (Star r) = (\\<lambda>a. Times (\\<dd> r a) (Star r))\"", "lemma Star_Zero[simp]: \"Star Zero = One\"", "lemma Star_One[simp]: \"Star One = One\"", "lemma Star_unfoldL: \"Star r = Plus One (Times r (Star r))\"", "lemma ShuffleLR_ZeroL[simp]: \"ShuffleLR Zero r = Zero\"", "lemma ShuffleLR_ZeroR[simp]: \"ShuffleLR r Zero = Zero\"", "lemma ShuffleLR_PlusL[simp]: \"ShuffleLR (Plus r s) t = Plus (ShuffleLR r t) (ShuffleLR s t)\"", "lemma ShuffleLR_PlusR[simp]: \"ShuffleLR r (Plus s t) = Plus (ShuffleLR r s) (ShuffleLR r t)\"", "lemma Shuffle_Plus_ShuffleLR_One[simp]: \"Times_Plus (ShuffleLR r One) = r\"", "lemma Shuffle_Plus_ShuffleLR_PlusL[simp]:\n  \"Times_Plus (ShuffleLR (Plus r s) t) = Plus (Times_Plus (ShuffleLR r t)) (Times_Plus (ShuffleLR s t))\"", "lemma Shuffle_Plus_ShuffleLR_PlusR[simp]:\n  \"Times_Plus (ShuffleLR r (Plus s t)) = Plus (Times_Plus (ShuffleLR r s)) (Times_Plus (ShuffleLR r t))\"", "lemma \\<oo>_Shuffle[simp]:\n  \"\\<oo> (Shuffle r s) = (\\<oo> r \\<and> \\<oo> s)\"", "lemma \\<dd>_Shuffle[simp]:\n  \"\\<dd> (Shuffle r s) = (\\<lambda>a. Plus (Shuffle (\\<dd> r a) s) (Shuffle r (\\<dd> s a)))\"", "theorem Shuffle_ZeroL[simp]: \"Shuffle Zero r = Zero\"", "theorem Shuffle_ZeroR[simp]: \"Shuffle r Zero = Zero\"", "theorem Shuffle_OneL[simp]: \"Shuffle One r = r\"", "theorem Shuffle_OneR[simp]: \"Shuffle r One = r\"", "theorem Shuffle_PlusL[simp]: \"Shuffle (Plus r s) t = Plus (Shuffle r t) (Shuffle s t)\"", "theorem Shuffle_PlusR[simp]: \"Shuffle r (Plus s t) = Plus (Shuffle r s) (Shuffle r t)\"", "theorem Shuffle_assoc[simp]: \"Shuffle (Shuffle r s) t = Shuffle r (Shuffle s t)\"", "theorem Shuffle_comm[simp]: \"Shuffle r s = Shuffle s r\"", "lemma language_coinduct_upto_regular[unfolded rel_fun_def, simplified, case_names Lang, consumes 1]:\n  assumes R: \"R L K\" and hyp:\n    \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L = \\<oo> K \\<and> rel_fun (=) (regular_cong R) (\\<dd> L) (\\<dd> K))\"\n  shows \"L = K\"", "lemma Star_unfoldR: \"Star r = Plus One (Times (Star r) r)\"", "lemma Star_Star[simp]: \"Star (Star r) = Star r\"", "lemma Times_Star[simp]: \"Times (Star r) (Star r) = Star r\"", "lemma Zero_One[simp]: \"Zero \\<noteq> One\"", "lemmas language_defs = zero_language_def one_language_def plus_language_def times_language_def\n  less_eq_language_def less_language_def", "lemma \\<oo>_mono[dest]: \"r \\<le> s \\<Longrightarrow> \\<oo> r \\<Longrightarrow> \\<oo> s\"", "lemma \\<dd>_mono[dest]: \"r \\<le> s \\<Longrightarrow> \\<dd> r a \\<le> \\<dd> s a\"", "theorem language_simulation_coinduction[consumes 1, case_names Lang, coinduct pred]:\n  assumes \"R L K\"\n      and \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L \\<le> \\<oo> K \\<and> (\\<forall>x. R (\\<dd> L x) (\\<dd> K x)))\"\n  shows \"L \\<le> K\"", "lemma le_PlusL[intro!, simp]: \"r \\<le> Plus r s\"", "lemma le_PlusR[intro!, simp]: \"s \\<le> Plus r s\"", "theorem language_simulation_coinduction_upto_Plus_Times[consumes 1, case_names Lang, coinduct pred]:\n  assumes R: \"R L K\"\n      and hyp: \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L \\<le> \\<oo> K \\<and> (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x)))\"\n    shows \"L \\<le> K\"", "lemma ge_One[simp]: \"One \\<le> r \\<longleftrightarrow> \\<oo> r\"", "lemma Plus_mono: \"\\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk> \\<Longrightarrow> Plus r1 r2 \\<le> Plus s1 s2\"", "lemma Plus_upper: \"\\<lbrakk>r1 \\<le> s; r2 \\<le> s\\<rbrakk> \\<Longrightarrow> Plus r1 r2 \\<le> s\"", "lemma Inter_mono: \"\\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk> \\<Longrightarrow> Inter r1 r2 \\<le> Inter s1 s2\"", "lemma Times_mono: \"\\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk> \\<Longrightarrow> Times r1 r2 \\<le> Times s1 s2\"", "theorem le_StarL: \"Plus One (Times r (Star r)) \\<le> Star r\"", "theorem le_StarR: \"Plus One (Times (Star r) r) \\<le> Star r\"", "lemma le_TimesL[intro, simp]: \"\\<oo> s \\<Longrightarrow> r \\<le> Times r s\"", "lemma le_TimesR[intro, simp]: \"\\<oo> r \\<Longrightarrow> s \\<le> Times r s\"", "lemma Plus_le_iff: \"Plus r s \\<le> t \\<longleftrightarrow> r \\<le> t \\<and> s \\<le> t\"", "lemma Plus_Times_pre_cong_mono:\n  \"L' \\<le> L \\<Longrightarrow> K \\<le> K' \\<Longrightarrow> Plus_Times_pre_cong R L K \\<Longrightarrow> Plus_Times_pre_cong R L' K'\"", "theorem ardenL: \"Plus r (Times s x) \\<le> x \\<Longrightarrow> Times (Star s) r \\<le> x\"", "theorem ardenR: \"Plus r (Times x s) \\<le> x \\<Longrightarrow> Times r (Star s) \\<le> x\"", "lemma le_Star[intro!, simp]: \"s \\<le> Star s\"", "lemma Star_mono: \"r \\<le> s \\<Longrightarrow> Star r \\<le> Star s\"", "lemma Not_antimono: \"r \\<le> s \\<Longrightarrow> Not s \\<le> Not r\"", "lemma Not_Plus[simp]: \"Not (Plus r s) = Inter (Not r) (Not s)\"", "lemma Not_Inter[simp]: \"Not (Inter r s) = Plus (Not r) (Not s)\"", "lemma Inter_assoc[simp]: \"Inter (Inter r s) t = Inter r (Inter s t)\"", "lemma Inter_comm: \"Inter r s = Inter s r\"", "lemma Inter_idem[simp]: \"Inter r r = r\"", "lemma Inter_ZeroL[simp]: \"Inter Zero r = Zero\"", "lemma Inter_ZeroR[simp]: \"Inter r Zero = Zero\"", "lemma Inter_FullL[simp]: \"Inter Full r = r\"", "lemma Inter_FullR[simp]: \"Inter r Full = r\"", "lemma Plus_FullL[simp]: \"Plus Full r = Full\"", "lemma Plus_FullR[simp]: \"Plus r Full = Full\"", "lemma Not_Not[simp]: \"Not (Not r) = r\"", "lemma Not_Zero[simp]: \"Not Zero = Full\"", "lemma Not_Full[simp]: \"Not Full = Zero\"", "lemma bisimulation:\n  assumes \"Times r s = Times s t\"\n  shows \"Times (Star r) s = Times s (Star t)\"", "lemma sliding: \"Times (Star (Times r s)) r = Times r (Star (Times s r))\"", "lemma denesting: \"Star (Plus r s) = Times (Star r) (Star (Times s (Star r)))\"", "lemma \\<oo>_foldr_Plus: \"\\<oo> (foldr Plus xs s) = (\\<exists>x\\<in>set (s # xs). \\<oo> x)\"", "lemma \\<dd>_foldr_Plus: \"\\<dd> (foldr Plus xs s) a = foldr Plus (map (\\<lambda>r. \\<dd> r a) xs) (\\<dd> s a)\"", "lemma \\<oo>_PLUS[simp]: \"\\<oo> (PLUS xs) = (\\<exists>x\\<in>set xs. \\<oo> x)\"", "lemma \\<dd>_PLUS[simp]: \"\\<dd> (PLUS xs) a = PLUS (map (\\<lambda>r. \\<dd> r a) xs)\"", "lemma \\<oo>_foldr_Times: \"\\<oo> (foldr Times xs s) = (\\<forall>x\\<in>set (s # xs). \\<oo> x)\"", "lemma tails_snoc[simp]: \"tails (xs @ [x]) = map (\\<lambda>ys. ys @ [x]) (tails xs) @ [[]]\"", "lemma length_tails[simp]: \"length (tails xs) = Suc (length xs)\"", "lemma \\<dd>_foldr_Times: \"\\<dd> (foldr Times xs s) a =\n  (let n = length (takeWhile \\<oo> xs)\n  in PLUS (map (\\<lambda>zs. TIMES (\\<dd> (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [s])))))\"", "lemma \\<oo>_TIMES[simp]: \"\\<oo> (TIMES xs) = (\\<forall>x\\<in>set xs. \\<oo> x)\"", "lemma TIMES_snoc_One[simp]: \"TIMES (xs @ [One]) = TIMES xs\"", "lemma \\<dd>_TIMES[simp]: \"\\<dd> (TIMES xs) a = (let n = length (takeWhile \\<oo> xs)\n  in PLUS (map (\\<lambda>zs. TIMES (\\<dd> (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [One])))))\"", "lemma in_language_to_language[simp]: \"Collect (in_language (to_language L)) = L\"", "lemma to_language_in_language[simp]: \"to_language (Collect (in_language L)) = L\"", "lemma in_language_bij: \"bij (Collect o in_language)\"", "lemma to_language_bij: \"bij to_language\""], "translations": [["", "theorem Plus_ZeroL[simp]: \"Plus Zero r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus Zero r = r", "by (coinduction arbitrary: r) simp"], ["", "theorem Plus_ZeroR[simp]: \"Plus r Zero = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r Zero = r", "by (coinduction arbitrary: r) simp"], ["", "theorem Plus_assoc: \"Plus (Plus r s) t = Plus r (Plus s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus (Plus r s) t = Plus r (Plus s t)", "by (coinduction arbitrary: r s t) auto"], ["", "theorem Plus_comm: \"Plus r s = Plus s r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r s = Plus s r", "by (coinduction arbitrary: r s) auto"], ["", "lemma Plus_rotate: \"Plus r (Plus s t) = Plus s (Plus r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r (Plus s t) = Plus s (Plus r t)", "using Plus_assoc Plus_comm"], ["proof (prove)\nusing this:\n  Plus (Plus ?r ?s) ?t = Plus ?r (Plus ?s ?t)\n  Plus ?r ?s = Plus ?s ?r\n\ngoal (1 subgoal):\n 1. Plus r (Plus s t) = Plus s (Plus r t)", "by metis"], ["", "theorem Plus_idem: \"Plus r r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r r = r", "by (coinduction arbitrary: r) auto"], ["", "lemma Plus_idem_assoc: \"Plus r (Plus r s) = Plus r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r (Plus r s) = Plus r s", "by (metis Plus_assoc Plus_idem)"], ["", "lemmas Plus_ACI[simp] = Plus_rotate Plus_comm Plus_assoc Plus_idem_assoc Plus_idem"], ["", "lemma Plus_OneL[simp]: \"\\<oo> r \\<Longrightarrow> Plus One r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> r \\<Longrightarrow> Plus One r = r", "by (coinduction arbitrary: r) auto"], ["", "lemma Plus_OneR[simp]: \"\\<oo> r \\<Longrightarrow> Plus r One = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> r \\<Longrightarrow> Plus r One = r", "by (coinduction arbitrary: r) auto"], ["", "text \\<open>\n  Concatenation is not primitively corecursive---the corecursive call of its derivative is\n  guarded by @{term Plus}. However, it can be defined as a composition of two primitively\n  corecursive functions.\n\\<close>"], ["", "primcorec TimesLR :: \"'a language \\<Rightarrow> 'a language \\<Rightarrow> ('a \\<times> bool) language\" where\n  \"\\<oo> (TimesLR r s) = (\\<oo> r \\<and> \\<oo> s)\"\n| \"\\<dd> (TimesLR r s) = (\\<lambda>(a, b).\n   if b then TimesLR (\\<dd> r a) s else if \\<oo> r then TimesLR (\\<dd> s a) One else Zero)\""], ["", "primcorec Times_Plus :: \"('a \\<times> bool) language \\<Rightarrow> 'a language\" where\n  \"\\<oo> (Times_Plus r) = \\<oo> r\"\n| \"\\<dd> (Times_Plus r) = (\\<lambda>a. Times_Plus (Plus (\\<dd> r (a, True)) (\\<dd> r (a, False))))\""], ["", "lemma TimesLR_ZeroL[simp]: \"TimesLR Zero r = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TimesLR Zero r = Zero", "by (coinduction arbitrary: r) auto"], ["", "lemma TimesLR_ZeroR[simp]: \"TimesLR r Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TimesLR r Zero = Zero", "by (coinduction arbitrary: r) (auto intro: exI[of _ Zero])"], ["", "lemma TimesLR_PlusL[simp]: \"TimesLR (Plus r s) t = Plus (TimesLR r t) (TimesLR s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TimesLR (Plus r s) t = Plus (TimesLR r t) (TimesLR s t)", "by (coinduction arbitrary: r s t) auto"], ["", "lemma TimesLR_PlusR[simp]: \"TimesLR r (Plus s t) = Plus (TimesLR r s) (TimesLR r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TimesLR r (Plus s t) = Plus (TimesLR r s) (TimesLR r t)", "by (coinduction arbitrary: r s t) auto"], ["", "lemma Times_Plus_Zero[simp]: \"Times_Plus Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus Zero = Zero", "by coinduction simp"], ["", "lemma Times_Plus_Plus[simp]: \"Times_Plus (Plus r s) = Plus (Times_Plus r) (Times_Plus s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus (Plus r s) = Plus (Times_Plus r) (Times_Plus s)", "proof (coinduction arbitrary: r s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (Times_Plus (Plus r s)) =\n       \\<oo> (Plus (Times_Plus r) (Times_Plus s)) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (Times_Plus (Plus r s)) x =\n               Times_Plus (Plus ra sa) \\<and>\n               \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x =\n               Plus (Times_Plus ra) (Times_Plus sa)) \\<or>\n           \\<dd> (Times_Plus (Plus r s)) x =\n           \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x)", "case (Lang r s)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (Times_Plus (Plus r s)) =\n       \\<oo> (Plus (Times_Plus r) (Times_Plus s)) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (Times_Plus (Plus r s)) x =\n               Times_Plus (Plus ra sa) \\<and>\n               \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x =\n               Plus (Times_Plus ra) (Times_Plus sa)) \\<or>\n           \\<dd> (Times_Plus (Plus r s)) x =\n           \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (Times_Plus (Plus r s)) =\n    \\<oo> (Plus (Times_Plus r) (Times_Plus s)) \\<and>\n    (\\<forall>x.\n        (\\<exists>r s.\n            \\<dd> (Times_Plus (Plus r s)) x = Times_Plus (Plus r s) \\<and>\n            \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x =\n            Plus (Times_Plus r) (Times_Plus s)) \\<or>\n        \\<dd> (Times_Plus (Plus r s)) x =\n        \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x)", "unfolding Times_Plus.sel Plus.sel"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<oo> r \\<or> \\<oo> s) = (\\<oo> r \\<or> \\<oo> s) \\<and>\n    (\\<forall>x.\n        (\\<exists>r s.\n            Times_Plus\n             (Plus (Plus (\\<dd> r (x, True)) (\\<dd> s (x, True)))\n               (Plus (\\<dd> r (x, False)) (\\<dd> s (x, False)))) =\n            Times_Plus (Plus r s) \\<and>\n            Plus\n             (Times_Plus (Plus (\\<dd> r (x, True)) (\\<dd> r (x, False))))\n             (Times_Plus (Plus (\\<dd> s (x, True)) (\\<dd> s (x, False)))) =\n            Plus (Times_Plus r) (Times_Plus s)) \\<or>\n        Times_Plus\n         (Plus (Plus (\\<dd> r (x, True)) (\\<dd> s (x, True)))\n           (Plus (\\<dd> r (x, False)) (\\<dd> s (x, False)))) =\n        Plus (Times_Plus (Plus (\\<dd> r (x, True)) (\\<dd> r (x, False))))\n         (Times_Plus (Plus (\\<dd> s (x, True)) (\\<dd> s (x, False)))))", "by (intro conjI[OF refl]) (metis Plus_comm Plus_rotate)"], ["proof (state)\nthis:\n  \\<oo> (Times_Plus (Plus r s)) =\n  \\<oo> (Plus (Times_Plus r) (Times_Plus s)) \\<and>\n  (\\<forall>x.\n      (\\<exists>r s.\n          \\<dd> (Times_Plus (Plus r s)) x = Times_Plus (Plus r s) \\<and>\n          \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x =\n          Plus (Times_Plus r) (Times_Plus s)) \\<or>\n      \\<dd> (Times_Plus (Plus r s)) x =\n      \\<dd> (Plus (Times_Plus r) (Times_Plus s)) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Times_Plus_TimesLR_One[simp]: \"Times_Plus (TimesLR r One) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus (TimesLR r One) = r", "by (coinduction arbitrary: r) simp"], ["", "lemma Times_Plus_TimesLR_PlusL[simp]:\n  \"Times_Plus (TimesLR (Plus r s) t) = Plus (Times_Plus (TimesLR r t)) (Times_Plus (TimesLR s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus (TimesLR (Plus r s) t) =\n    Plus (Times_Plus (TimesLR r t)) (Times_Plus (TimesLR s t))", "by (coinduction arbitrary: r s t) auto"], ["", "lemma Times_Plus_TimesLR_PlusR[simp]:\n  \"Times_Plus (TimesLR r (Plus s t)) = Plus (Times_Plus (TimesLR r s)) (Times_Plus (TimesLR r t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus (TimesLR r (Plus s t)) =\n    Plus (Times_Plus (TimesLR r s)) (Times_Plus (TimesLR r t))", "by (coinduction arbitrary: r s t) auto"], ["", "definition Times :: \"'a language \\<Rightarrow> 'a language \\<Rightarrow> 'a language\" where\n  \"Times r s = Times_Plus (TimesLR r s)\""], ["", "lemma \\<oo>_Times[simp]:\n  \"\\<oo> (Times r s) = (\\<oo> r \\<and> \\<oo> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (Times r s) = (\\<oo> r \\<and> \\<oo> s)", "unfolding Times_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (Times_Plus (TimesLR r s)) = (\\<oo> r \\<and> \\<oo> s)", "by simp"], ["", "lemma \\<dd>_Times[simp]:\n  \"\\<dd> (Times r s) = (\\<lambda>a. if \\<oo> r then Plus (Times (\\<dd> r a) s) (\\<dd> s a) else Times (\\<dd> r a) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (Times r s) =\n    (\\<lambda>a.\n        if \\<oo> r then Plus (Times (\\<dd> r a) s) (\\<dd> s a)\n        else Times (\\<dd> r a) s)", "unfolding Times_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (Times_Plus (TimesLR r s)) =\n    (\\<lambda>a.\n        if \\<oo> r\n        then Plus (Times_Plus (TimesLR (\\<dd> r a) s)) (\\<dd> s a)\n        else Times_Plus (TimesLR (\\<dd> r a) s))", "by auto"], ["", "theorem Times_ZeroL[simp]: \"Times Zero r = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times Zero r = Zero", "by coinduction simp"], ["", "theorem Times_ZeroR[simp]: \"Times r Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times r Zero = Zero", "by (coinduction arbitrary: r) auto"], ["", "theorem Times_OneL[simp]: \"Times One r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times One r = r", "by (coinduction arbitrary: r rule: language.coinduct_strong) (simp add: rel_fun_def)"], ["", "theorem Times_OneR[simp]: \"Times r One = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times r One = r", "by (coinduction arbitrary: r) simp"], ["", "text \\<open>\n  Coinduction up-to @{term Plus}--congruence relaxes the coinduction hypothesis by requiring\n  membership in the congruence closure of the bisimulation rather than in the bisimulation itself.\n\\<close>"], ["", "inductive Plus_cong for R where\n  Refl[intro]: \"x = y \\<Longrightarrow> Plus_cong R x y\"\n| Base[intro]: \"R x y \\<Longrightarrow> Plus_cong R x y\"\n| Sym: \"Plus_cong R x y \\<Longrightarrow> Plus_cong R y x\"\n| Trans[intro]: \"Plus_cong R x y \\<Longrightarrow> Plus_cong R y z \\<Longrightarrow> Plus_cong R x z\"\n| Plus[intro]: \"\\<lbrakk>Plus_cong R x y; Plus_cong R x' y'\\<rbrakk> \\<Longrightarrow> Plus_cong R (Plus x x') (Plus y y')\""], ["", "lemma language_coinduct_upto_Plus[unfolded rel_fun_def, simplified, case_names Lang, consumes 1]:\n  assumes R: \"R L K\" and hyp:\n    \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L = \\<oo> K \\<and> rel_fun (=) (Plus_cong R) (\\<dd> L) (\\<dd> K))\"\n  shows \"L = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = K", "proof (coinduct rule: language.coinduct[of \"Plus_cong R\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. Plus_cong R L K\n 2. \\<And>language language'.\n       Plus_cong R language language' \\<Longrightarrow>\n       \\<oo> language = \\<oo> language' \\<and>\n       rel_fun (=) (Plus_cong R) (\\<dd> language) (\\<dd> language')", "fix L K"], ["proof (state)\ngoal (2 subgoals):\n 1. Plus_cong R L K\n 2. \\<And>language language'.\n       Plus_cong R language language' \\<Longrightarrow>\n       \\<oo> language = \\<oo> language' \\<and>\n       rel_fun (=) (Plus_cong R) (\\<dd> language) (\\<dd> language')", "assume \"Plus_cong R L K\""], ["proof (state)\nthis:\n  Plus_cong R L K\n\ngoal (2 subgoals):\n 1. Plus_cong R L K\n 2. \\<And>language language'.\n       Plus_cong R language language' \\<Longrightarrow>\n       \\<oo> language = \\<oo> language' \\<and>\n       rel_fun (=) (Plus_cong R) (\\<dd> language) (\\<dd> language')", "then"], ["proof (chain)\npicking this:\n  Plus_cong R L K", "show \"\\<oo> L = \\<oo> K \\<and> rel_fun (=) (Plus_cong R) (\\<dd> L) (\\<dd> K)\""], ["proof (prove)\nusing this:\n  Plus_cong R L K\n\ngoal (1 subgoal):\n 1. \\<oo> L = \\<oo> K \\<and> rel_fun (=) (Plus_cong R) (\\<dd> L) (\\<dd> K)", "by (induct rule: Plus_cong.induct) (auto simp: rel_fun_def intro: Sym dest: hyp)"], ["proof (state)\nthis:\n  \\<oo> L = \\<oo> K \\<and> rel_fun (=) (Plus_cong R) (\\<dd> L) (\\<dd> K)\n\ngoal (1 subgoal):\n 1. Plus_cong R L K", "qed (intro Base R)"], ["", "theorem Times_PlusL[simp]: \"Times (Plus r s) t = Plus (Times r t) (Times s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Plus r s) t = Plus (Times r t) (Times s t)", "by (coinduction arbitrary: r s rule: language_coinduct_upto_Plus) auto"], ["", "theorem Times_PlusR[simp]: \"Times r (Plus s t) = Plus (Times r s) (Times r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times r (Plus s t) = Plus (Times r s) (Times r t)", "by (coinduction arbitrary: r s rule: language_coinduct_upto_Plus) fastforce"], ["", "theorem Times_assoc[simp]: \"Times (Times r s) t = Times r (Times s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Times r s) t = Times r (Times s t)", "by (coinduction arbitrary: r s t rule: language_coinduct_upto_Plus) fastforce"], ["", "text \\<open>\n  Similarly to @{term Times}, iteration is not primitively corecursive (guardedness by\n  @{term Times} is required). We apply a similar trick to obtain its definition.\n\\<close>"], ["", "primcorec StarLR :: \"'a language \\<Rightarrow> 'a language \\<Rightarrow> 'a language\" where\n  \"\\<oo> (StarLR r s) = \\<oo> r\"\n| \"\\<dd> (StarLR r s) = (\\<lambda>a. StarLR (\\<dd> (Times r (Plus One s)) a) s)\""], ["", "lemma StarLR_Zero[simp]: \"StarLR Zero r = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StarLR Zero r = Zero", "by coinduction auto"], ["", "lemma StarLR_Plus[simp]: \"StarLR (Plus r s) t = Plus (StarLR r t) (StarLR s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StarLR (Plus r s) t = Plus (StarLR r t) (StarLR s t)", "by (coinduction arbitrary: r s) (auto simp del: Plus_ACI Times_PlusR)"], ["", "lemma StarLR_Times_Plus_One[simp]: \"StarLR (Times r (Plus One s)) s = StarLR r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StarLR (Times r (Plus One s)) s = StarLR r s", "proof (coinduction arbitrary: r s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "case Lang"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "{"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "define L and R where \"L = Plus (\\<dd> r a) (Plus (Times (\\<dd> r a) s) (\\<dd> s a))\"\n    and \"R = Times (Plus (\\<dd> r a) (Plus (Times (\\<dd> r a) s) (\\<dd> s a))) s\""], ["proof (state)\nthis:\n  L = Plus (\\<dd> r a) (Plus (Times (\\<dd> r a) s) (\\<dd> s a))\n  R = Times (Plus (\\<dd> r a) (Plus (Times (\\<dd> r a) s) (\\<dd> s a))) s\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "have \"Plus L (Plus R (\\<dd> s a)) = Plus (Plus L (\\<dd> s a)) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus L (Plus R (\\<dd> s a)) = Plus (Plus L (\\<dd> s a)) R", "by (metis Plus_assoc Plus_comm)"], ["proof (state)\nthis:\n  Plus L (Plus R (\\<dd> s a)) = Plus (Plus L (\\<dd> s a)) R\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "also"], ["proof (state)\nthis:\n  Plus L (Plus R (\\<dd> s a)) = Plus (Plus L (\\<dd> s a)) R\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "have \"Plus L (\\<dd> s a) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus L (\\<dd> s a) = L", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus (Plus (\\<dd> r a) (Plus (Times (\\<dd> r a) s) (\\<dd> s a)))\n     (\\<dd> s a) =\n    Plus (\\<dd> r a) (Plus (Times (\\<dd> r a) s) (\\<dd> s a))", "by simp"], ["proof (state)\nthis:\n  Plus L (\\<dd> s a) = L\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "finally"], ["proof (chain)\npicking this:\n  Plus L (Plus R (\\<dd> s a)) = Plus L R", "have \"Plus L (Plus R (\\<dd> s a)) = Plus L R\""], ["proof (prove)\nusing this:\n  Plus L (Plus R (\\<dd> s a)) = Plus L R\n\ngoal (1 subgoal):\n 1. Plus L (Plus R (\\<dd> s a)) = Plus L R", "."], ["proof (state)\nthis:\n  Plus L (Plus R (\\<dd> s a)) = Plus L R\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "}"], ["proof (state)\nthis:\n  Plus (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n   (Plus\n     (Times\n       (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2))) s)\n     (\\<dd> s ?a2)) =\n  Plus (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n   (Times (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n     s)\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n       (\\<forall>x.\n           (\\<exists>ra sa.\n               \\<dd> (StarLR (Times r (Plus One s)) s) x =\n               StarLR (Times ra (Plus One sa)) sa \\<and>\n               \\<dd> (StarLR r s) x = StarLR ra sa) \\<or>\n           \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "then"], ["proof (chain)\npicking this:\n  Plus (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n   (Plus\n     (Times\n       (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2))) s)\n     (\\<dd> s ?a2)) =\n  Plus (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n   (Times (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n     s)", "show ?case"], ["proof (prove)\nusing this:\n  Plus (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n   (Plus\n     (Times\n       (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2))) s)\n     (\\<dd> s ?a2)) =\n  Plus (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n   (Times (Plus (\\<dd> r ?a2) (Plus (Times (\\<dd> r ?a2) s) (\\<dd> s ?a2)))\n     s)\n\ngoal (1 subgoal):\n 1. \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n    (\\<forall>x.\n        (\\<exists>r s.\n            \\<dd> (StarLR (Times r (Plus One s)) s) x =\n            StarLR (Times r (Plus One s)) s \\<and>\n            \\<dd> (StarLR r s) x = StarLR r s) \\<or>\n        \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)", "by (auto simp del: StarLR_Plus Plus_assoc Times_PlusL)"], ["proof (state)\nthis:\n  \\<oo> (StarLR (Times r (Plus One s)) s) = \\<oo> (StarLR r s) \\<and>\n  (\\<forall>x.\n      (\\<exists>r s.\n          \\<dd> (StarLR (Times r (Plus One s)) s) x =\n          StarLR (Times r (Plus One s)) s \\<and>\n          \\<dd> (StarLR r s) x = StarLR r s) \\<or>\n      \\<dd> (StarLR (Times r (Plus One s)) s) x = \\<dd> (StarLR r s) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma StarLR_Times: \"StarLR (Times r s) t = Times r (StarLR s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StarLR (Times r s) t = Times r (StarLR s t)", "by (coinduction arbitrary: r s t rule: language_coinduct_upto_Plus)\n    (fastforce simp del: Plus_ACI Times_PlusR)"], ["", "definition Star :: \"'a language \\<Rightarrow> 'a language\" where\n  \"Star r = StarLR One r\""], ["", "lemma \\<oo>_Star[simp]: \"\\<oo> (Star r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (Star r)", "unfolding Star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (StarLR One r)", "by simp"], ["", "lemma \\<dd>_Star[simp]: \"\\<dd> (Star r) = (\\<lambda>a. Times (\\<dd> r a) (Star r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (Star r) = (\\<lambda>a. Times (\\<dd> r a) (Star r))", "unfolding Star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (StarLR One r) = (\\<lambda>a. Times (\\<dd> r a) (StarLR One r))", "by (auto simp add: Star_def StarLR_Times[symmetric])"], ["", "lemma Star_Zero[simp]: \"Star Zero = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Star Zero = One", "by coinduction auto"], ["", "lemma Star_One[simp]: \"Star One = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Star One = One", "by coinduction auto"], ["", "lemma Star_unfoldL: \"Star r = Plus One (Times r (Star r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Star r = Plus One (Times r (Star r))", "by coinduction auto"], ["", "primcorec Inter :: \"'a language \\<Rightarrow> 'a language \\<Rightarrow> 'a language\" where\n  \"\\<oo> (Inter r s) = (\\<oo> r \\<and> \\<oo> s)\"\n| \"\\<dd> (Inter r s) = (\\<lambda>a. Inter (\\<dd> r a) (\\<dd> s a))\""], ["", "primcorec Not :: \"'a language \\<Rightarrow> 'a language\" where\n  \"\\<oo> (Not r) = (\\<not> \\<oo> r)\"\n| \"\\<dd> (Not r) = (\\<lambda>a. Not (\\<dd> r a))\""], ["", "primcorec Full :: \"'a language\" (\"\\<Sigma>\\<^sup>*\") where\n  \"\\<oo> Full = True\"\n| \"\\<dd> Full = (\\<lambda>_. Full)\""], ["", "text \\<open>\n  Shuffle product is not primitively corecursive---the corecursive call of its derivative is\n  guarded by @{term Plus}. However, it can be defined as a composition of two primitively\n  corecursive functions.\n\\<close>"], ["", "primcorec ShuffleLR :: \"'a language \\<Rightarrow> 'a language \\<Rightarrow> ('a \\<times> bool) language\" where\n  \"\\<oo> (ShuffleLR r s) = (\\<oo> r \\<and> \\<oo> s)\"\n| \"\\<dd> (ShuffleLR r s) = (\\<lambda>(a, b). if b then ShuffleLR (\\<dd> r a) s else ShuffleLR r (\\<dd> s a))\""], ["", "lemma ShuffleLR_ZeroL[simp]: \"ShuffleLR Zero r = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShuffleLR Zero r = Zero", "by (coinduction arbitrary: r) auto"], ["", "lemma ShuffleLR_ZeroR[simp]: \"ShuffleLR r Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShuffleLR r Zero = Zero", "by (coinduction arbitrary: r) (auto intro: exI[of _ Zero])"], ["", "lemma ShuffleLR_PlusL[simp]: \"ShuffleLR (Plus r s) t = Plus (ShuffleLR r t) (ShuffleLR s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShuffleLR (Plus r s) t = Plus (ShuffleLR r t) (ShuffleLR s t)", "by (coinduction arbitrary: r s t) auto"], ["", "lemma ShuffleLR_PlusR[simp]: \"ShuffleLR r (Plus s t) = Plus (ShuffleLR r s) (ShuffleLR r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShuffleLR r (Plus s t) = Plus (ShuffleLR r s) (ShuffleLR r t)", "by (coinduction arbitrary: r s t) auto"], ["", "lemma Shuffle_Plus_ShuffleLR_One[simp]: \"Times_Plus (ShuffleLR r One) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus (ShuffleLR r One) = r", "by (coinduction arbitrary: r) simp"], ["", "lemma Shuffle_Plus_ShuffleLR_PlusL[simp]:\n  \"Times_Plus (ShuffleLR (Plus r s) t) = Plus (Times_Plus (ShuffleLR r t)) (Times_Plus (ShuffleLR s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus (ShuffleLR (Plus r s) t) =\n    Plus (Times_Plus (ShuffleLR r t)) (Times_Plus (ShuffleLR s t))", "by (coinduction arbitrary: r s t) auto"], ["", "lemma Shuffle_Plus_ShuffleLR_PlusR[simp]:\n  \"Times_Plus (ShuffleLR r (Plus s t)) = Plus (Times_Plus (ShuffleLR r s)) (Times_Plus (ShuffleLR r t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times_Plus (ShuffleLR r (Plus s t)) =\n    Plus (Times_Plus (ShuffleLR r s)) (Times_Plus (ShuffleLR r t))", "by (coinduction arbitrary: r s t) auto"], ["", "definition Shuffle :: \"'a language \\<Rightarrow> 'a language \\<Rightarrow> 'a language\" where\n  \"Shuffle r s = Times_Plus (ShuffleLR r s)\""], ["", "lemma \\<oo>_Shuffle[simp]:\n  \"\\<oo> (Shuffle r s) = (\\<oo> r \\<and> \\<oo> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (Shuffle r s) = (\\<oo> r \\<and> \\<oo> s)", "unfolding Shuffle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (Times_Plus (ShuffleLR r s)) = (\\<oo> r \\<and> \\<oo> s)", "by simp"], ["", "lemma \\<dd>_Shuffle[simp]:\n  \"\\<dd> (Shuffle r s) = (\\<lambda>a. Plus (Shuffle (\\<dd> r a) s) (Shuffle r (\\<dd> s a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (Shuffle r s) =\n    (\\<lambda>a. Plus (Shuffle (\\<dd> r a) s) (Shuffle r (\\<dd> s a)))", "unfolding Shuffle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (Times_Plus (ShuffleLR r s)) =\n    (\\<lambda>a.\n        Plus (Times_Plus (ShuffleLR (\\<dd> r a) s))\n         (Times_Plus (ShuffleLR r (\\<dd> s a))))", "by auto"], ["", "theorem Shuffle_ZeroL[simp]: \"Shuffle Zero r = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle Zero r = Zero", "by (coinduction arbitrary: r rule: language_coinduct_upto_Plus) (auto 0 4)"], ["", "theorem Shuffle_ZeroR[simp]: \"Shuffle r Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle r Zero = Zero", "by (coinduction arbitrary: r rule: language_coinduct_upto_Plus) (auto 0 4)"], ["", "theorem Shuffle_OneL[simp]: \"Shuffle One r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle One r = r", "by (coinduction arbitrary: r) simp"], ["", "theorem Shuffle_OneR[simp]: \"Shuffle r One = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle r One = r", "by (coinduction arbitrary: r) simp"], ["", "theorem Shuffle_PlusL[simp]: \"Shuffle (Plus r s) t = Plus (Shuffle r t) (Shuffle s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle (Plus r s) t = Plus (Shuffle r t) (Shuffle s t)", "by (coinduction arbitrary: r s t rule: language_coinduct_upto_Plus)\n    (force intro!: Trans[OF Plus[OF Base Base] Refl])"], ["", "theorem Shuffle_PlusR[simp]: \"Shuffle r (Plus s t) = Plus (Shuffle r s) (Shuffle r t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle r (Plus s t) = Plus (Shuffle r s) (Shuffle r t)", "by (coinduction arbitrary: r s t rule: language_coinduct_upto_Plus)\n    (force intro!: Trans[OF Plus[OF Base Base] Refl])"], ["", "theorem Shuffle_assoc[simp]: \"Shuffle (Shuffle r s) t = Shuffle r (Shuffle s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle (Shuffle r s) t = Shuffle r (Shuffle s t)", "by (coinduction arbitrary: r s t rule: language_coinduct_upto_Plus) fastforce"], ["", "theorem Shuffle_comm[simp]: \"Shuffle r s = Shuffle s r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Shuffle r s = Shuffle s r", "by (coinduction arbitrary: r s rule: language_coinduct_upto_Plus)\n    (auto intro!: Trans[OF Plus[OF Base Base] Refl])"], ["", "text \\<open>\n  We generalize coinduction up-to @{term Plus} to coinduction up-to all previously defined concepts.\n\\<close>"], ["", "inductive regular_cong for R where\n  Refl[intro]: \"x = y \\<Longrightarrow> regular_cong R x y\"\n| Sym[intro]: \"regular_cong R x y \\<Longrightarrow> regular_cong R y x\"\n| Trans[intro]: \"\\<lbrakk>regular_cong R x y; regular_cong R y z\\<rbrakk> \\<Longrightarrow> regular_cong R x z\"\n| Base[intro]: \"R x y \\<Longrightarrow> regular_cong R x y\"\n| Plus[intro, simp]: \"\\<lbrakk>regular_cong R x y; regular_cong R x' y'\\<rbrakk> \\<Longrightarrow>\n    regular_cong R (Plus x x') (Plus y y')\"\n| Times[intro, simp]: \"\\<lbrakk>regular_cong R x y; regular_cong R x' y'\\<rbrakk> \\<Longrightarrow>\n    regular_cong R (Times x x') (Times y y')\"\n| Star[intro, simp]: \"\\<lbrakk>regular_cong R x y\\<rbrakk> \\<Longrightarrow>\n    regular_cong R (Star x) (Star y)\"\n| Inter[intro, simp]: \"\\<lbrakk>regular_cong R x y; regular_cong R x' y'\\<rbrakk> \\<Longrightarrow>\n    regular_cong R (Inter x x') (Inter y y')\"\n| Not[intro, simp]: \"\\<lbrakk>regular_cong R x y\\<rbrakk> \\<Longrightarrow>\n    regular_cong R (Not x) (Not y)\"\n| Shuffle[intro, simp]: \"\\<lbrakk>regular_cong R x y; regular_cong R x' y'\\<rbrakk> \\<Longrightarrow>\n    regular_cong R (Shuffle x x') (Shuffle y y')\""], ["", "lemma language_coinduct_upto_regular[unfolded rel_fun_def, simplified, case_names Lang, consumes 1]:\n  assumes R: \"R L K\" and hyp:\n    \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L = \\<oo> K \\<and> rel_fun (=) (regular_cong R) (\\<dd> L) (\\<dd> K))\"\n  shows \"L = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = K", "proof (coinduct rule: language.coinduct[of \"regular_cong R\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. regular_cong R L K\n 2. \\<And>language language'.\n       regular_cong R language language' \\<Longrightarrow>\n       \\<oo> language = \\<oo> language' \\<and>\n       rel_fun (=) (regular_cong R) (\\<dd> language) (\\<dd> language')", "fix L K"], ["proof (state)\ngoal (2 subgoals):\n 1. regular_cong R L K\n 2. \\<And>language language'.\n       regular_cong R language language' \\<Longrightarrow>\n       \\<oo> language = \\<oo> language' \\<and>\n       rel_fun (=) (regular_cong R) (\\<dd> language) (\\<dd> language')", "assume \"regular_cong R L K\""], ["proof (state)\nthis:\n  regular_cong R L K\n\ngoal (2 subgoals):\n 1. regular_cong R L K\n 2. \\<And>language language'.\n       regular_cong R language language' \\<Longrightarrow>\n       \\<oo> language = \\<oo> language' \\<and>\n       rel_fun (=) (regular_cong R) (\\<dd> language) (\\<dd> language')", "then"], ["proof (chain)\npicking this:\n  regular_cong R L K", "show \"\\<oo> L = \\<oo> K \\<and> rel_fun (=) (regular_cong R) (\\<dd> L) (\\<dd> K)\""], ["proof (prove)\nusing this:\n  regular_cong R L K\n\ngoal (1 subgoal):\n 1. \\<oo> L = \\<oo> K \\<and>\n    rel_fun (=) (regular_cong R) (\\<dd> L) (\\<dd> K)", "by (induct rule: regular_cong.induct) (auto dest: hyp simp: rel_fun_def)"], ["proof (state)\nthis:\n  \\<oo> L = \\<oo> K \\<and> rel_fun (=) (regular_cong R) (\\<dd> L) (\\<dd> K)\n\ngoal (1 subgoal):\n 1. regular_cong R L K", "qed (intro Base R)"], ["", "lemma Star_unfoldR: \"Star r = Plus One (Times (Star r) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Star r = Plus One (Times (Star r) r)", "proof (coinduction arbitrary: r rule: language_coinduct_upto_regular)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n            (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))", "case Lang"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n            (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))", "{"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n            (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n            (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))", "have \"Plus (Times (\\<dd> r a) (Times (Star r) r)) (\\<dd> r a) =\n      Times (\\<dd> r a) (Plus One (Times (Star r) r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus (Times (\\<dd> r a) (Times (Star r) r)) (\\<dd> r a) =\n    Times (\\<dd> r a) (Plus One (Times (Star r) r))", "by simp"], ["proof (state)\nthis:\n  Plus (Times (\\<dd> r a) (Times (Star r) r)) (\\<dd> r a) =\n  Times (\\<dd> r a) (Plus One (Times (Star r) r))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n            (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))", "}"], ["proof (state)\nthis:\n  Plus (Times (\\<dd> r ?a2) (Times (Star r) r)) (\\<dd> r ?a2) =\n  Times (\\<dd> r ?a2) (Plus One (Times (Star r) r))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n            (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))", "then"], ["proof (chain)\npicking this:\n  Plus (Times (\\<dd> r ?a2) (Times (Star r) r)) (\\<dd> r ?a2) =\n  Times (\\<dd> r ?a2) (Plus One (Times (Star r) r))", "show ?case"], ["proof (prove)\nusing this:\n  Plus (Times (\\<dd> r ?a2) (Times (Star r) r)) (\\<dd> r ?a2) =\n  Times (\\<dd> r ?a2) (Plus One (Times (Star r) r))\n\ngoal (1 subgoal):\n 1. \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n    (\\<forall>x.\n        regular_cong\n         (\\<lambda>L__ K__.\n             \\<exists>r.\n                L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n         (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))", "by (auto simp del: Times_PlusR)"], ["proof (state)\nthis:\n  \\<oo> (Star r) = \\<oo> (Plus One (Times (Star r) r)) \\<and>\n  (\\<forall>x.\n      regular_cong\n       (\\<lambda>L__ K__.\n           \\<exists>r.\n              L__ = Star r \\<and> K__ = Plus One (Times (Star r) r))\n       (\\<dd> (Star r) x) (\\<dd> (Plus One (Times (Star r) r)) x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Star_Star[simp]: \"Star (Star r) = Star r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Star (Star r) = Star r", "by (subst Star_unfoldL, coinduction arbitrary: r rule: language_coinduct_upto_regular) auto"], ["", "lemma Times_Star[simp]: \"Times (Star r) (Star r) = Star r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Star r) (Star r) = Star r", "proof (coinduction arbitrary: r rule: language_coinduct_upto_regular)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Times (Star r) (Star r)) = \\<oo> (Star r) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Times (Star r) (Star r) \\<and> K__ = Star r)\n            (\\<dd> (Times (Star r) (Star r)) x) (\\<dd> (Star r) x))", "case Lang"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Times (Star r) (Star r)) = \\<oo> (Star r) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Times (Star r) (Star r) \\<and> K__ = Star r)\n            (\\<dd> (Times (Star r) (Star r)) x) (\\<dd> (Star r) x))", "have *: \"\\<And>r s. Plus (Times r s) r = Times r (Plus s One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s. Plus (Times r s) r = Times r (Plus s One)", "by simp"], ["proof (state)\nthis:\n  Plus (Times ?r ?s) ?r = Times ?r (Plus ?s One)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<oo> (Times (Star r) (Star r)) = \\<oo> (Star r) \\<and>\n       (\\<forall>x.\n           regular_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r.\n                   L__ = Times (Star r) (Star r) \\<and> K__ = Star r)\n            (\\<dd> (Times (Star r) (Star r)) x) (\\<dd> (Star r) x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (Times (Star r) (Star r)) = \\<oo> (Star r) \\<and>\n    (\\<forall>x.\n        regular_cong\n         (\\<lambda>L__ K__.\n             \\<exists>r. L__ = Times (Star r) (Star r) \\<and> K__ = Star r)\n         (\\<dd> (Times (Star r) (Star r)) x) (\\<dd> (Star r) x))", "by (auto simp del: Times_PlusR Plus_ACI simp: Times_PlusR[symmetric] *)"], ["proof (state)\nthis:\n  \\<oo> (Times (Star r) (Star r)) = \\<oo> (Star r) \\<and>\n  (\\<forall>x.\n      regular_cong\n       (\\<lambda>L__ K__.\n           \\<exists>r. L__ = Times (Star r) (Star r) \\<and> K__ = Star r)\n       (\\<dd> (Times (Star r) (Star r)) x) (\\<dd> (Star r) x))\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation language :: (type) \"{semiring_1, order}\"\nbegin"], ["", "lemma Zero_One[simp]: \"Zero \\<noteq> One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Zero \\<noteq> One", "by (metis One.simps(1) Zero.simps(1))"], ["", "definition \"zero_language = Zero\""], ["", "definition \"one_language = One\""], ["", "definition \"plus_language = Plus\""], ["", "definition \"times_language = Times\""], ["", "definition \"less_eq_language r s = (Plus r s = s)\""], ["", "definition \"less_language r s = (Plus r s = s \\<and> r \\<noteq> s)\""], ["", "lemmas language_defs = zero_language_def one_language_def plus_language_def times_language_def\n  less_eq_language_def less_language_def"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a language, order_class) &&&\n    OFCLASS('a language, semiring_1_class)", "proof intro_classes"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a * b * c = a * (b * c)\n 6. \\<And>a. 1 * a = a\n 7. \\<And>a. a * 1 = a\n 8. \\<And>a b c. a + b + c = a + (b + c)\n 9. \\<And>a b. a + b = b + a\n 10. \\<And>a. 0 + a = a\nA total of 15 subgoals...", "fix x y z :: \"'a language\""], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a * b * c = a * (b * c)\n 6. \\<And>a. 1 * a = a\n 7. \\<And>a. a * 1 = a\n 8. \\<And>a b c. a + b + c = a + (b + c)\n 9. \\<And>a b. a + b = b + a\n 10. \\<And>a. 0 + a = a\nA total of 15 subgoals...", "assume \"x \\<le> y\" \"y \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a * b * c = a * (b * c)\n 6. \\<And>a. 1 * a = a\n 7. \\<And>a. a * 1 = a\n 8. \\<And>a b c. a + b + c = a + (b + c)\n 9. \\<And>a b. a + b = b + a\n 10. \\<And>a. 0 + a = a\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> z", "show \"x \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "unfolding language_defs"], ["proof (prove)\nusing this:\n  Plus x y = y\n  Plus y z = z\n\ngoal (1 subgoal):\n 1. Plus x z = z", "by (metis Plus_assoc)"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (14 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>a b c. a * b * c = a * (b * c)\n 5. \\<And>a. 1 * a = a\n 6. \\<And>a. a * 1 = a\n 7. \\<And>a b c. a + b + c = a + (b + c)\n 8. \\<And>a b. a + b = b + a\n 9. \\<And>a. 0 + a = a\n 10. \\<And>a. 0 * a = 0\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>a b c. a * b * c = a * (b * c)\n 5. \\<And>a. 1 * a = a\n 6. \\<And>a. a * 1 = a\n 7. \\<And>a b c. a + b + c = a + (b + c)\n 8. \\<And>a b. a + b = b + a\n 9. \\<And>a. 0 + a = a\n 10. \\<And>a. 0 * a = 0\nA total of 14 subgoals...", "fix x y z :: \"'a language\""], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>a b c. a * b * c = a * (b * c)\n 5. \\<And>a. 1 * a = a\n 6. \\<And>a. a * 1 = a\n 7. \\<And>a b c. a + b + c = a + (b + c)\n 8. \\<And>a b. a + b = b + a\n 9. \\<And>a. 0 + a = a\n 10. \\<And>a. 0 * a = 0\nA total of 14 subgoals...", "show \"x + y + z = x + (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y + z = x + (y + z)", "unfolding language_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus (Plus x y) z = Plus x (Plus y z)", "by (rule Plus_assoc)"], ["proof (state)\nthis:\n  x + y + z = x + (y + z)\n\ngoal (13 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>a b c. a * b * c = a * (b * c)\n 5. \\<And>a. 1 * a = a\n 6. \\<And>a. a * 1 = a\n 7. \\<And>a b. a + b = b + a\n 8. \\<And>a. 0 + a = a\n 9. \\<And>a. 0 * a = 0\n 10. \\<And>a. a * 0 = 0\nA total of 13 subgoals...", "qed (auto simp: language_defs)"], ["", "end"], ["", "lemma \\<oo>_mono[dest]: \"r \\<le> s \\<Longrightarrow> \\<oo> r \\<Longrightarrow> \\<oo> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> s; \\<oo> r\\<rbrakk> \\<Longrightarrow> \\<oo> s", "unfolding less_eq_language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Plus r s = s; \\<oo> r\\<rbrakk> \\<Longrightarrow> \\<oo> s", "by (auto dest: arg_cong[of _ _ \\<oo>])"], ["", "lemma \\<dd>_mono[dest]: \"r \\<le> s \\<Longrightarrow> \\<dd> r a \\<le> \\<dd> s a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> s \\<Longrightarrow> \\<dd> r a \\<le> \\<dd> s a", "unfolding less_eq_language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r s = s \\<Longrightarrow> Plus (\\<dd> r a) (\\<dd> s a) = \\<dd> s a", "by (metis Plus.simps(2))"], ["", "text \\<open>\n  For reasoning about @{term \"(\\<le>)\"}, we prove a coinduction principle and generalize it\n  to support up-to reasoning.\n\\<close>"], ["", "theorem language_simulation_coinduction[consumes 1, case_names Lang, coinduct pred]:\n  assumes \"R L K\"\n      and \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L \\<le> \\<oo> K \\<and> (\\<forall>x. R (\\<dd> L x) (\\<dd> K x)))\"\n  shows \"L \\<le> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> K", "using \\<open>R L K\\<close>"], ["proof (prove)\nusing this:\n  R L K\n\ngoal (1 subgoal):\n 1. L \\<le> K", "unfolding less_eq_language_def"], ["proof (prove)\nusing this:\n  R L K\n\ngoal (1 subgoal):\n 1. Plus L K = K", "by (coinduction arbitrary: L K) (auto dest!: assms(2))"], ["", "lemma le_PlusL[intro!, simp]: \"r \\<le> Plus r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> Plus r s", "by (coinduction arbitrary: r s) auto"], ["", "lemma le_PlusR[intro!, simp]: \"s \\<le> Plus r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> Plus r s", "by (coinduction arbitrary: r s) auto"], ["", "inductive Plus_Times_pre_cong for R where\n  pre_Less[intro, simp]: \"x \\<le> y \\<Longrightarrow> Plus_Times_pre_cong R x y\"\n| pre_Trans[intro]: \"\\<lbrakk>Plus_Times_pre_cong R x y; Plus_Times_pre_cong R y z\\<rbrakk> \\<Longrightarrow> Plus_Times_pre_cong R x z\"\n| pre_Base[intro, simp]: \"R x y \\<Longrightarrow> Plus_Times_pre_cong R x y\"\n| pre_Plus[intro!, simp]: \"\\<lbrakk>Plus_Times_pre_cong R x y; Plus_Times_pre_cong R x' y'\\<rbrakk> \\<Longrightarrow>\n    Plus_Times_pre_cong R (Plus x x') (Plus y y')\"\n| pre_Times[intro!, simp]: \"\\<lbrakk>Plus_Times_pre_cong R x y; Plus_Times_pre_cong R x' y'\\<rbrakk> \\<Longrightarrow>\n    Plus_Times_pre_cong R (Times x x') (Times y y')\""], ["", "theorem language_simulation_coinduction_upto_Plus_Times[consumes 1, case_names Lang, coinduct pred]:\n  assumes R: \"R L K\"\n      and hyp: \"(\\<And>L K. R L K \\<Longrightarrow> \\<oo> L \\<le> \\<oo> K \\<and> (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x)))\"\n    shows \"L \\<le> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> K", "proof (coinduct rule: language_simulation_coinduction[of \"Plus_Times_pre_cong R\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. Plus_Times_pre_cong R L K\n 2. \\<And>L K.\n       Plus_Times_pre_cong R L K \\<Longrightarrow>\n       \\<oo> L \\<le> \\<oo> K \\<and>\n       (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x))", "fix L K"], ["proof (state)\ngoal (2 subgoals):\n 1. Plus_Times_pre_cong R L K\n 2. \\<And>L K.\n       Plus_Times_pre_cong R L K \\<Longrightarrow>\n       \\<oo> L \\<le> \\<oo> K \\<and>\n       (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x))", "assume \"Plus_Times_pre_cong R L K\""], ["proof (state)\nthis:\n  Plus_Times_pre_cong R L K\n\ngoal (2 subgoals):\n 1. Plus_Times_pre_cong R L K\n 2. \\<And>L K.\n       Plus_Times_pre_cong R L K \\<Longrightarrow>\n       \\<oo> L \\<le> \\<oo> K \\<and>\n       (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x))", "then"], ["proof (chain)\npicking this:\n  Plus_Times_pre_cong R L K", "show \"\\<oo> L \\<le> \\<oo> K \\<and> (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x))\""], ["proof (prove)\nusing this:\n  Plus_Times_pre_cong R L K\n\ngoal (1 subgoal):\n 1. \\<oo> L \\<le> \\<oo> K \\<and>\n    (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x))", "by (induct rule: Plus_Times_pre_cong.induct) (auto dest: hyp)"], ["proof (state)\nthis:\n  \\<oo> L \\<le> \\<oo> K \\<and>\n  (\\<forall>x. Plus_Times_pre_cong R (\\<dd> L x) (\\<dd> K x))\n\ngoal (1 subgoal):\n 1. Plus_Times_pre_cong R L K", "qed (intro pre_Base R)"], ["", "lemma ge_One[simp]: \"One \\<le> r \\<longleftrightarrow> \\<oo> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (One \\<le> r) = \\<oo> r", "unfolding less_eq_language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Plus One r = r) = \\<oo> r", "by (metis One.sel(1) Plus.sel(1) Plus_OneL)"], ["", "lemma Plus_mono: \"\\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk> \\<Longrightarrow> Plus r1 r2 \\<le> Plus s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk>\n    \\<Longrightarrow> Plus r1 r2 \\<le> Plus s1 s2", "by (coinduction arbitrary: r1 r2 s1 s2) (auto elim!: \\<dd>_mono)"], ["", "lemma Plus_upper: \"\\<lbrakk>r1 \\<le> s; r2 \\<le> s\\<rbrakk> \\<Longrightarrow> Plus r1 r2 \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r1 \\<le> s; r2 \\<le> s\\<rbrakk>\n    \\<Longrightarrow> Plus r1 r2 \\<le> s", "by (coinduction arbitrary: r1 r2 s) auto"], ["", "lemma Inter_mono: \"\\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk> \\<Longrightarrow> Inter r1 r2 \\<le> Inter s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk>\n    \\<Longrightarrow> Inter r1 r2 \\<le> Inter s1 s2", "by (coinduction arbitrary: r1 r2 s1 s2) (force elim!: \\<dd>_mono)"], ["", "lemma Times_mono: \"\\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk> \\<Longrightarrow> Times r1 r2 \\<le> Times s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r1 \\<le> s1; r2 \\<le> s2\\<rbrakk>\n    \\<Longrightarrow> Times r1 r2 \\<le> Times s1 s2", "by (coinduction arbitrary: r1 r2 s1 s2) (auto 0 3 elim!: \\<dd>_mono)"], ["", "text \\<open>\n  We prove the missing axioms of Kleene Algebras about @{term Star}, as well as monotonicity\n  properties and three standard interesting rules: bisimulation, sliding, and denesting.\n\\<close>"], ["", "theorem le_StarL: \"Plus One (Times r (Star r)) \\<le> Star r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus One (Times r (Star r)) \\<le> Star r", "by coinduction auto"], ["", "theorem le_StarR: \"Plus One (Times (Star r) r) \\<le> Star r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus One (Times (Star r) r) \\<le> Star r", "by (rule order_eq_refl[OF Star_unfoldR[symmetric]])"], ["", "lemma le_TimesL[intro, simp]: \"\\<oo> s \\<Longrightarrow> r \\<le> Times r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> s \\<Longrightarrow> r \\<le> Times r s", "by (coinduction arbitrary: r) auto"], ["", "lemma le_TimesR[intro, simp]: \"\\<oo> r \\<Longrightarrow> s \\<le> Times r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> r \\<Longrightarrow> s \\<le> Times r s", "by coinduction auto"], ["", "lemma Plus_le_iff: \"Plus r s \\<le> t \\<longleftrightarrow> r \\<le> t \\<and> s \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Plus r s \\<le> t) = (r \\<le> t \\<and> s \\<le> t)", "unfolding less_eq_language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Plus (Plus r s) t = t) = (Plus r t = t \\<and> Plus s t = t)", "by (metis Plus_assoc Plus_idem_assoc Plus_rotate)"], ["", "lemma Plus_Times_pre_cong_mono:\n  \"L' \\<le> L \\<Longrightarrow> K \\<le> K' \\<Longrightarrow> Plus_Times_pre_cong R L K \\<Longrightarrow> Plus_Times_pre_cong R L' K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L' \\<le> L; K \\<le> K'; Plus_Times_pre_cong R L K\\<rbrakk>\n    \\<Longrightarrow> Plus_Times_pre_cong R L' K'", "by (metis pre_Trans pre_Less)"], ["", "theorem ardenL: \"Plus r (Times s x) \\<le> x \\<Longrightarrow> Times (Star s) r \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r (Times s x) \\<le> x \\<Longrightarrow> Times (Star s) r \\<le> x", "proof (coinduction arbitrary: r s x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r s x.\n       Plus r (Times s x) \\<le> x \\<Longrightarrow>\n       \\<oo> (Times (Star s) r) \\<le> \\<oo> x \\<and>\n       (\\<forall>xa.\n           Plus_Times_pre_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r s x.\n                   L__ = Times (Star s) r \\<and>\n                   K__ = x \\<and> Plus r (Times s x) \\<le> x)\n            (\\<dd> (Times (Star s) r) xa) (\\<dd> x xa))", "case Lang"], ["proof (state)\nthis:\n  Plus r (Times s x) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>r s x.\n       Plus r (Times s x) \\<le> x \\<Longrightarrow>\n       \\<oo> (Times (Star s) r) \\<le> \\<oo> x \\<and>\n       (\\<forall>xa.\n           Plus_Times_pre_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r s x.\n                   L__ = Times (Star s) r \\<and>\n                   K__ = x \\<and> Plus r (Times s x) \\<le> x)\n            (\\<dd> (Times (Star s) r) xa) (\\<dd> x xa))", "then"], ["proof (chain)\npicking this:\n  Plus r (Times s x) \\<le> x", "show ?case"], ["proof (prove)\nusing this:\n  Plus r (Times s x) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<oo> (Times (Star s) r) \\<le> \\<oo> x \\<and>\n    (\\<forall>x.\n        Plus_Times_pre_cong\n         (\\<lambda>L__ K__.\n             \\<exists>r s x.\n                L__ = Times (Star s) r \\<and>\n                K__ = x \\<and> Plus r (Times s x) \\<le> x)\n         (\\<dd> (Times (Star s) r) x) (\\<dd> x x))", "by (subst Plus_Times_pre_cong_mono[OF order_refl \\<dd>_mono[OF Lang]]) auto"], ["proof (state)\nthis:\n  \\<oo> (Times (Star s) r) \\<le> \\<oo> x \\<and>\n  (\\<forall>x.\n      Plus_Times_pre_cong\n       (\\<lambda>L__ K__.\n           \\<exists>r s x.\n              L__ = Times (Star s) r \\<and>\n              K__ = x \\<and> Plus r (Times s x) \\<le> x)\n       (\\<dd> (Times (Star s) r) x) (\\<dd> x x))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ardenR: \"Plus r (Times x s) \\<le> x \\<Longrightarrow> Times r (Star s) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r (Times x s) \\<le> x \\<Longrightarrow> Times r (Star s) \\<le> x", "proof (coinduction arbitrary: r s x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r s x.\n       Plus r (Times x s) \\<le> x \\<Longrightarrow>\n       \\<oo> (Times r (Star s)) \\<le> \\<oo> x \\<and>\n       (\\<forall>xa.\n           Plus_Times_pre_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r s x.\n                   L__ = Times r (Star s) \\<and>\n                   K__ = x \\<and> Plus r (Times x s) \\<le> x)\n            (\\<dd> (Times r (Star s)) xa) (\\<dd> x xa))", "case Lang"], ["proof (state)\nthis:\n  Plus r (Times x s) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>r s x.\n       Plus r (Times x s) \\<le> x \\<Longrightarrow>\n       \\<oo> (Times r (Star s)) \\<le> \\<oo> x \\<and>\n       (\\<forall>xa.\n           Plus_Times_pre_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r s x.\n                   L__ = Times r (Star s) \\<and>\n                   K__ = x \\<and> Plus r (Times x s) \\<le> x)\n            (\\<dd> (Times r (Star s)) xa) (\\<dd> x xa))", "then"], ["proof (chain)\npicking this:\n  Plus r (Times x s) \\<le> x", "have \"Plus_Times_pre_cong (\\<lambda>L K. \\<exists>r s. L = Times r (Star s) \\<and> Plus r (Times K s) \\<le> K)\n    (\\<dd> (Times r (Star s)) a) (\\<dd> x a)\" for a"], ["proof (prove)\nusing this:\n  Plus r (Times x s) \\<le> x\n\ngoal (1 subgoal):\n 1. Plus_Times_pre_cong\n     (\\<lambda>L K.\n         \\<exists>r s.\n            L = Times r (Star s) \\<and> Plus r (Times K s) \\<le> K)\n     (\\<dd> (Times r (Star s)) a) (\\<dd> x a)", "using \\<dd>_mono[OF Lang, of a]"], ["proof (prove)\nusing this:\n  Plus r (Times x s) \\<le> x\n  \\<dd> (Plus r (Times x s)) a \\<le> \\<dd> x a\n\ngoal (1 subgoal):\n 1. Plus_Times_pre_cong\n     (\\<lambda>L K.\n         \\<exists>r s.\n            L = Times r (Star s) \\<and> Plus r (Times K s) \\<le> K)\n     (\\<dd> (Times r (Star s)) a) (\\<dd> x a)", "by (auto 0 4 simp del: Times_PlusL simp: Times_PlusL[symmetric] Plus_le_iff split: if_splits)"], ["proof (state)\nthis:\n  Plus_Times_pre_cong\n   (\\<lambda>L K.\n       \\<exists>r s. L = Times r (Star s) \\<and> Plus r (Times K s) \\<le> K)\n   (\\<dd> (Times r (Star s)) ?a) (\\<dd> x ?a)\n\ngoal (1 subgoal):\n 1. \\<And>r s x.\n       Plus r (Times x s) \\<le> x \\<Longrightarrow>\n       \\<oo> (Times r (Star s)) \\<le> \\<oo> x \\<and>\n       (\\<forall>xa.\n           Plus_Times_pre_cong\n            (\\<lambda>L__ K__.\n                \\<exists>r s x.\n                   L__ = Times r (Star s) \\<and>\n                   K__ = x \\<and> Plus r (Times x s) \\<le> x)\n            (\\<dd> (Times r (Star s)) xa) (\\<dd> x xa))", "with Lang"], ["proof (chain)\npicking this:\n  Plus r (Times x s) \\<le> x\n  Plus_Times_pre_cong\n   (\\<lambda>L K.\n       \\<exists>r s. L = Times r (Star s) \\<and> Plus r (Times K s) \\<le> K)\n   (\\<dd> (Times r (Star s)) ?a) (\\<dd> x ?a)", "show ?case"], ["proof (prove)\nusing this:\n  Plus r (Times x s) \\<le> x\n  Plus_Times_pre_cong\n   (\\<lambda>L K.\n       \\<exists>r s. L = Times r (Star s) \\<and> Plus r (Times K s) \\<le> K)\n   (\\<dd> (Times r (Star s)) ?a) (\\<dd> x ?a)\n\ngoal (1 subgoal):\n 1. \\<oo> (Times r (Star s)) \\<le> \\<oo> x \\<and>\n    (\\<forall>x.\n        Plus_Times_pre_cong\n         (\\<lambda>L__ K__.\n             \\<exists>r s x.\n                L__ = Times r (Star s) \\<and>\n                K__ = x \\<and> Plus r (Times x s) \\<le> x)\n         (\\<dd> (Times r (Star s)) x) (\\<dd> x x))", "by auto"], ["proof (state)\nthis:\n  \\<oo> (Times r (Star s)) \\<le> \\<oo> x \\<and>\n  (\\<forall>x.\n      Plus_Times_pre_cong\n       (\\<lambda>L__ K__.\n           \\<exists>r s x.\n              L__ = Times r (Star s) \\<and>\n              K__ = x \\<and> Plus r (Times x s) \\<le> x)\n       (\\<dd> (Times r (Star s)) x) (\\<dd> x x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_Star[intro!, simp]: \"s \\<le> Star s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> Star s", "by coinduction auto"], ["", "lemma Star_mono: \"r \\<le> s \\<Longrightarrow> Star r \\<le> Star s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> s \\<Longrightarrow> Star r \\<le> Star s", "by coinduction auto"], ["", "lemma Not_antimono: \"r \\<le> s \\<Longrightarrow> Not s \\<le> Not r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> s \\<Longrightarrow>\n    Coinductive_Language.Not s \\<le> Coinductive_Language.Not r", "by (coinduction arbitrary: r s) auto"], ["", "lemma Not_Plus[simp]: \"Not (Plus r s) = Inter (Not r) (Not s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Coinductive_Language.Not (Plus r s) =\n    Inter (Coinductive_Language.Not r) (Coinductive_Language.Not s)", "by (coinduction arbitrary: r s) auto"], ["", "lemma Not_Inter[simp]: \"Not (Inter r s) = Plus (Not r) (Not s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Coinductive_Language.Not (Inter r s) =\n    Plus (Coinductive_Language.Not r) (Coinductive_Language.Not s)", "by (coinduction arbitrary: r s) auto"], ["", "lemma Inter_assoc[simp]: \"Inter (Inter r s) t = Inter r (Inter s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inter (Inter r s) t = Inter r (Inter s t)", "by (coinduction arbitrary: r s t) auto"], ["", "lemma Inter_comm: \"Inter r s = Inter s r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inter r s = Inter s r", "by (coinduction arbitrary: r s) auto"], ["", "lemma Inter_idem[simp]: \"Inter r r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inter r r = r", "by (coinduction arbitrary: r) auto"], ["", "lemma Inter_ZeroL[simp]: \"Inter Zero r = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inter Zero r = Zero", "by (coinduction arbitrary: r) auto"], ["", "lemma Inter_ZeroR[simp]: \"Inter r Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inter r Zero = Zero", "by (coinduction arbitrary: r) auto"], ["", "lemma Inter_FullL[simp]: \"Inter Full r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inter \\<Sigma>\\<^sup>* r = r", "by (coinduction arbitrary: r) auto"], ["", "lemma Inter_FullR[simp]: \"Inter r Full = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inter r \\<Sigma>\\<^sup>* = r", "by (coinduction arbitrary: r) auto"], ["", "lemma Plus_FullL[simp]: \"Plus Full r = Full\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus \\<Sigma>\\<^sup>* r = \\<Sigma>\\<^sup>*", "by (coinduction arbitrary: r) auto"], ["", "lemma Plus_FullR[simp]: \"Plus r Full = Full\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r \\<Sigma>\\<^sup>* = \\<Sigma>\\<^sup>*", "by (coinduction arbitrary: r) auto"], ["", "lemma Not_Not[simp]: \"Not (Not r) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Coinductive_Language.Not (Coinductive_Language.Not r) = r", "by (coinduction arbitrary: r) auto"], ["", "lemma Not_Zero[simp]: \"Not Zero = Full\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Coinductive_Language.Not Zero = \\<Sigma>\\<^sup>*", "by coinduction simp"], ["", "lemma Not_Full[simp]: \"Not Full = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Coinductive_Language.Not \\<Sigma>\\<^sup>* = Zero", "by coinduction simp"], ["", "lemma bisimulation:\n  assumes \"Times r s = Times s t\"\n  shows \"Times (Star r) s = Times s (Star t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Star r) s = Times s (Star t)", "proof (rule antisym[OF ardenL[OF Plus_upper[OF le_TimesL]] ardenR[OF Plus_upper[OF le_TimesR]]])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<oo> (Star t)\n 2. Times r (Times s (Star t)) \\<le> Times s (Star t)\n 3. \\<oo> (Star r)\n 4. Times (Times (Star r) s) t \\<le> Times (Star r) s", "show \"Times r (Times s (Star t)) \\<le> Times s (Star t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times r (Times s (Star t)) \\<le> Times s (Star t)", "by (rule order_trans[OF _\n        Times_mono[OF order_refl ord_le_eq_trans[OF le_PlusR Star_unfoldL[symmetric]]]])\n      (simp only: assms Times_assoc[symmetric])"], ["proof (state)\nthis:\n  Times r (Times s (Star t)) \\<le> Times s (Star t)\n\ngoal (3 subgoals):\n 1. \\<oo> (Star t)\n 2. \\<oo> (Star r)\n 3. Times (Times (Star r) s) t \\<le> Times (Star r) s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<oo> (Star t)\n 2. \\<oo> (Star r)\n 3. Times (Times (Star r) s) t \\<le> Times (Star r) s", "show \"Times (Times (Star r) s) t \\<le> Times (Star r) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Times (Star r) s) t \\<le> Times (Star r) s", "by (rule order_trans[OF _\n        Times_mono[OF ord_le_eq_trans[OF le_PlusR Star_unfoldR[symmetric]] order_refl]])\n      (simp only: assms Times_assoc)"], ["proof (state)\nthis:\n  Times (Times (Star r) s) t \\<le> Times (Star r) s\n\ngoal (2 subgoals):\n 1. \\<oo> (Star t)\n 2. \\<oo> (Star r)", "qed simp_all"], ["", "lemma sliding: \"Times (Star (Times r s)) r = Times r (Star (Times s r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Star (Times r s)) r = Times r (Star (Times s r))", "proof (rule antisym[OF ardenL[OF Plus_upper[OF le_TimesL]] ardenR[OF Plus_upper[OF le_TimesR]]])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<oo> (Star (Times s r))\n 2. Times (Times r s) (Times r (Star (Times s r)))\n    \\<le> Times r (Star (Times s r))\n 3. \\<oo> (Star (Times r s))\n 4. Times (Times (Star (Times r s)) r) (Times s r)\n    \\<le> Times (Star (Times r s)) r", "show \"Times (Times r s) (Times r (Star (Times s r))) \\<le> Times r (Star (Times s r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Times r s) (Times r (Star (Times s r)))\n    \\<le> Times r (Star (Times s r))", "by (rule order_trans[OF _\n        Times_mono[OF order_refl ord_le_eq_trans[OF le_PlusR Star_unfoldL[symmetric]]]]) simp"], ["proof (state)\nthis:\n  Times (Times r s) (Times r (Star (Times s r)))\n  \\<le> Times r (Star (Times s r))\n\ngoal (3 subgoals):\n 1. \\<oo> (Star (Times s r))\n 2. \\<oo> (Star (Times r s))\n 3. Times (Times (Star (Times r s)) r) (Times s r)\n    \\<le> Times (Star (Times r s)) r", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<oo> (Star (Times s r))\n 2. \\<oo> (Star (Times r s))\n 3. Times (Times (Star (Times r s)) r) (Times s r)\n    \\<le> Times (Star (Times r s)) r", "show \"Times (Times (Star (Times r s)) r) (Times s r) \\<le> Times (Star (Times r s)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Times (Star (Times r s)) r) (Times s r)\n    \\<le> Times (Star (Times r s)) r", "by (rule order_trans[OF _\n        Times_mono[OF ord_le_eq_trans[OF le_PlusR Star_unfoldR[symmetric]] order_refl]]) simp"], ["proof (state)\nthis:\n  Times (Times (Star (Times r s)) r) (Times s r)\n  \\<le> Times (Star (Times r s)) r\n\ngoal (2 subgoals):\n 1. \\<oo> (Star (Times s r))\n 2. \\<oo> (Star (Times r s))", "qed simp_all"], ["", "lemma denesting: \"Star (Plus r s) = Times (Star r) (Star (Times s (Star r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Star (Plus r s) = Times (Star r) (Star (Times s (Star r)))", "proof (rule antisym[OF ord_eq_le_trans[OF Times_OneR[symmetric] ardenL[OF Plus_upper]]\n   ardenR[OF Plus_upper[OF Star_mono[OF le_PlusL]]]])"], ["proof (state)\ngoal (3 subgoals):\n 1. One \\<le> Times (Star r) (Star (Times s (Star r)))\n 2. Times (Plus r s) (Times (Star r) (Star (Times s (Star r))))\n    \\<le> Times (Star r) (Star (Times s (Star r)))\n 3. Times (Star (Plus r s)) (Times s (Star r)) \\<le> Star (Plus r s)", "show \"Times (Plus r s) (Times (Star r) (Star (Times s (Star r))))\n    \\<le> Times (Star r) (Star (Times s (Star r)))\" (is \"Times _ ?L \\<le> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Plus r s) (Times (Star r) (Star (Times s (Star r))))\n    \\<le> Times (Star r) (Star (Times s (Star r)))", "unfolding Times_PlusL"], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus (Times r (Times (Star r) (Star (Times s (Star r)))))\n     (Times s (Times (Star r) (Star (Times s (Star r)))))\n    \\<le> Times (Star r) (Star (Times s (Star r)))", "by (rule Plus_upper,\n      metis Star_unfoldL Times_assoc Times_mono le_PlusR order_refl,\n      metis Star_unfoldL Times_assoc \\<oo>_Star le_PlusR le_TimesR order_trans)"], ["proof (state)\nthis:\n  Times (Plus r s) (Times (Star r) (Star (Times s (Star r))))\n  \\<le> Times (Star r) (Star (Times s (Star r)))\n\ngoal (2 subgoals):\n 1. One \\<le> Times (Star r) (Star (Times s (Star r)))\n 2. Times (Star (Plus r s)) (Times s (Star r)) \\<le> Star (Plus r s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. One \\<le> Times (Star r) (Star (Times s (Star r)))\n 2. Times (Star (Plus r s)) (Times s (Star r)) \\<le> Star (Plus r s)", "show \"Times (Star (Plus r s)) (Times s (Star r)) \\<le> Star (Plus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Times (Star (Plus r s)) (Times s (Star r)) \\<le> Star (Plus r s)", "by (metis Plus_comm Star_unfoldL Times_PlusR Times_assoc ardenR bisimulation le_PlusR)"], ["proof (state)\nthis:\n  Times (Star (Plus r s)) (Times s (Star r)) \\<le> Star (Plus r s)\n\ngoal (1 subgoal):\n 1. One \\<le> Times (Star r) (Star (Times s (Star r)))", "qed simp"], ["", "text \\<open>\nIt is useful to lift binary operators @{term Plus} and @{term Times}\nto $n$-ary operators (that take a list as input).\n\\<close>"], ["", "definition PLUS :: \"'a language list \\<Rightarrow> 'a language\" where\n  \"PLUS xs \\<equiv> foldr Plus xs Zero\""], ["", "lemma \\<oo>_foldr_Plus: \"\\<oo> (foldr Plus xs s) = (\\<exists>x\\<in>set (s # xs). \\<oo> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (foldr Plus xs s) = (\\<exists>x\\<in>set (s # xs). \\<oo> x)", "by (induct xs arbitrary: s) auto"], ["", "lemma \\<dd>_foldr_Plus: \"\\<dd> (foldr Plus xs s) a = foldr Plus (map (\\<lambda>r. \\<dd> r a) xs) (\\<dd> s a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (foldr Plus xs s) a =\n    foldr Plus (map (\\<lambda>r. \\<dd> r a) xs) (\\<dd> s a)", "by (induct xs arbitrary: s) simp_all"], ["", "lemma \\<oo>_PLUS[simp]: \"\\<oo> (PLUS xs) = (\\<exists>x\\<in>set xs. \\<oo> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (PLUS xs) = (\\<exists>x\\<in>set xs. \\<oo> x)", "unfolding PLUS_def \\<oo>_foldr_Plus"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (set (Zero # xs)) \\<oo> = (\\<exists>x\\<in>set xs. \\<oo> x)", "by simp"], ["", "lemma \\<dd>_PLUS[simp]: \"\\<dd> (PLUS xs) a = PLUS (map (\\<lambda>r. \\<dd> r a) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (PLUS xs) a = PLUS (map (\\<lambda>r. \\<dd> r a) xs)", "unfolding PLUS_def \\<dd>_foldr_Plus"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr Plus (map (\\<lambda>r. \\<dd> r a) xs) (\\<dd> Zero a) =\n    foldr Plus (map (\\<lambda>r. \\<dd> r a) xs) Zero", "by simp"], ["", "definition TIMES :: \"'a language list \\<Rightarrow> 'a language\" where\n  \"TIMES xs \\<equiv> foldr Times xs One\""], ["", "lemma \\<oo>_foldr_Times: \"\\<oo> (foldr Times xs s) = (\\<forall>x\\<in>set (s # xs). \\<oo> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (foldr Times xs s) = (\\<forall>x\\<in>set (s # xs). \\<oo> x)", "by (induct xs) (auto simp: PLUS_def)"], ["", "primrec tails where\n  \"tails [] = [[]]\"\n| \"tails (x # xs) = (x # xs) # tails xs\""], ["", "lemma tails_snoc[simp]: \"tails (xs @ [x]) = map (\\<lambda>ys. ys @ [x]) (tails xs) @ [[]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tails (xs @ [x]) = map (\\<lambda>ys. ys @ [x]) (tails xs) @ [[]]", "by (induct xs) auto"], ["", "lemma length_tails[simp]: \"length (tails xs) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tails xs) = Suc (length xs)", "by (induct xs) auto"], ["", "lemma \\<dd>_foldr_Times: \"\\<dd> (foldr Times xs s) a =\n  (let n = length (takeWhile \\<oo> xs)\n  in PLUS (map (\\<lambda>zs. TIMES (\\<dd> (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [s])))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (foldr Times xs s) a =\n    (let n = length (takeWhile \\<oo> xs)\n     in PLUS\n         (map (\\<lambda>zs. TIMES (\\<dd> (hd zs) a # tl zs))\n           (take (Suc n) (tails (xs @ [s])))))", "by (induct xs) (auto simp: TIMES_def PLUS_def Let_def foldr_map o_def)"], ["", "lemma \\<oo>_TIMES[simp]: \"\\<oo> (TIMES xs) = (\\<forall>x\\<in>set xs. \\<oo> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (TIMES xs) = (\\<forall>x\\<in>set xs. \\<oo> x)", "unfolding TIMES_def \\<oo>_foldr_Times"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (One # xs)) \\<oo> = (\\<forall>x\\<in>set xs. \\<oo> x)", "by simp"], ["", "lemma TIMES_snoc_One[simp]: \"TIMES (xs @ [One]) = TIMES xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TIMES (xs @ [One]) = TIMES xs", "by (induct xs) (auto simp: TIMES_def)"], ["", "lemma \\<dd>_TIMES[simp]: \"\\<dd> (TIMES xs) a = (let n = length (takeWhile \\<oo> xs)\n  in PLUS (map (\\<lambda>zs. TIMES (\\<dd> (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [One])))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dd> (TIMES xs) a =\n    (let n = length (takeWhile \\<oo> xs)\n     in PLUS\n         (map (\\<lambda>zs. TIMES (\\<dd> (hd zs) a # tl zs))\n           (take (Suc n) (tails (xs @ [One])))))", "unfolding TIMES_def \\<dd>_foldr_Times"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let n = length (takeWhile \\<oo> xs)\n     in PLUS\n         (map (\\<lambda>zs. foldr Times (\\<dd> (hd zs) a # tl zs) One)\n           (take (Suc n) (tails (xs @ [One]))))) =\n    (let n = length (takeWhile \\<oo> xs)\n     in PLUS\n         (map (\\<lambda>zs. foldr Times (\\<dd> (hd zs) a # tl zs) One)\n           (take (Suc n) (tails (xs @ [One])))))", "by simp"], ["", "section \\<open>Word-theoretic Semantics of Languages\\<close>"], ["", "text \\<open>\nWe show our @{type language} codatatype being isomorphic to the standard\nlanguage representation as a set of lists.\n\\<close>"], ["", "primrec in_language :: \"'a language \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"in_language L [] = \\<oo> L\"\n| \"in_language L (x # xs) = in_language (\\<dd> L x) xs\""], ["", "primcorec to_language :: \"'a list set \\<Rightarrow> 'a language\" where\n  \"\\<oo> (to_language L) = ([] \\<in> L)\"\n| \"\\<dd> (to_language L) = (\\<lambda>a. to_language {w. a # w \\<in> L})\""], ["", "lemma in_language_to_language[simp]: \"Collect (in_language (to_language L)) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (in_language (to_language L)) = L", "proof (rule set_eqI, unfold mem_Collect_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. in_language (to_language L) x = (x \\<in> L)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. in_language (to_language L) x = (x \\<in> L)", "show \"in_language (to_language L) w = (w \\<in> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language (to_language L) w = (w \\<in> L)", "by (induct w arbitrary: L) auto"], ["proof (state)\nthis:\n  in_language (to_language L) w = (w \\<in> L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_language_in_language[simp]: \"to_language (Collect (in_language L)) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_language (Collect (in_language L)) = L", "by (coinduction arbitrary: L) auto"], ["", "lemma in_language_bij: \"bij (Collect o in_language)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (Collect \\<circ> in_language)", "proof (rule bijI', unfold o_apply, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       Collect (in_language x) = Collect (in_language y) \\<Longrightarrow>\n       x = y\n 2. \\<And>y. \\<exists>x. y = Collect (in_language x)", "fix L R :: \"'a language\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       Collect (in_language x) = Collect (in_language y) \\<Longrightarrow>\n       x = y\n 2. \\<And>y. \\<exists>x. y = Collect (in_language x)", "assume \"Collect (in_language L) = Collect (in_language R)\""], ["proof (state)\nthis:\n  Collect (in_language L) = Collect (in_language R)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       Collect (in_language x) = Collect (in_language y) \\<Longrightarrow>\n       x = y\n 2. \\<And>y. \\<exists>x. y = Collect (in_language x)", "then"], ["proof (chain)\npicking this:\n  Collect (in_language L) = Collect (in_language R)", "show \"L = R\""], ["proof (prove)\nusing this:\n  Collect (in_language L) = Collect (in_language R)\n\ngoal (1 subgoal):\n 1. L = R", "unfolding set_eq_iff mem_Collect_eq"], ["proof (prove)\nusing this:\n  \\<forall>x. in_language L x = in_language R x\n\ngoal (1 subgoal):\n 1. L = R", "by (coinduction arbitrary: L R) (metis in_language.simps)"], ["proof (state)\nthis:\n  L = R\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. y = Collect (in_language x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. y = Collect (in_language x)", "fix L :: \"'a list set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. y = Collect (in_language x)", "have \"L = Collect (in_language (to_language L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = Collect (in_language (to_language L))", "by simp"], ["proof (state)\nthis:\n  L = Collect (in_language (to_language L))\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. y = Collect (in_language x)", "then"], ["proof (chain)\npicking this:\n  L = Collect (in_language (to_language L))", "show \"\\<exists>K. L = Collect (in_language K)\""], ["proof (prove)\nusing this:\n  L = Collect (in_language (to_language L))\n\ngoal (1 subgoal):\n 1. \\<exists>K. L = Collect (in_language K)", "by blast"], ["proof (state)\nthis:\n  \\<exists>K. L = Collect (in_language K)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_language_bij: \"bij to_language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij to_language", "by (rule o_bij[of \"Collect o in_language\"]) (simp_all add: fun_eq_iff)"], ["", "(*<*)"], ["", "hide_const (open) TimesLR Times_Plus StarLR ShuffleLR"], ["", "end"], ["", "(*>*)"]]}